#ifdef _DBGRAM
#include <stdio.h>
#include <stdint.h>

static char *gram[] = {
"NULL",
"<PROGRAM> ::= <STMT.LIST> ; EOF",
"<STMT.LIST> ::= <STMT>",
"<STMT.LIST) ::= <STMT.LIST) ; <STMT>",
"<STMT) ::= <BASIC.STMT)",
"<STMT> ::= <IF.STMT>",
"<STMT) ::= <ERROR)",
"<BASIC.STMT) ::= <DECL.STMT>",
"<BASIC.STMT) ::= <GROUP>",
"<BASIC.STMT> ::= <PROC.DEFINITION>",
"<BASIC.STMT> ::= <RETURN.STMT>",
"<BASIC.STMT) ::= <CALL.STMT>",
"<BASIC.STMT> ::= <GOTO.STMT>",
"<BASIC.STMT) :: = <REPEAT.STMT>",
"<BASIC.STMT> :: = <CONTROL.STMT>",
"<BASIC.STMT) ::= <COMPARE.STMT>",
"<BASIC.STMT> ::= <EXCHANGE.STMT>",
"<BASIC.STMT> ::= <ASSIGN.STMT>",
"<BASIC.STMT> ::= <LABEL.DEFINITION) <BASIC.STMT>",
"<IF.STMT> ::= <LABEL.DEFINITION> <IF.STMT>",
"<DECL.STMT) ::= DECLARE <DECL.ELEMENT>",
"<DECL.STMT> ::= <DECL.STMT> , <DECL.ELEMENT)",
"<INITIAL.HEAD> ::= INITIAL (",
"<ENDING> ::= END",
"<ENDING> ::= END <IDENTIFIER>",
"<ENDING> ::= <LABEL.DEFINITION) <ENDING>",
"<INITIALIZATION> :: = <EMPTY>",
"<INITIALIZATION> ::= <ASSIGN.STMT>",
"<ASSIGN.STMT> ::= <VAR.ASSIGN>",
"<ASSIGN.STMT> ::= <REG.ASSIGN>",
"<LABEL.DEFINITION> ::= <IDENTIFIER>",
"<LABEL.DEFINITION> ::= <NUMBER>",
"<IF.STMT> ::= <IF.CLAUSE> <STMT>",
"<IF.STMT> ::= <IF.CLAUSE> <TRUE.PART> <STMT>",
"<IF.CLAUSE> ::= IF <COMPOUND.CONDITION> THEN",
"<TRUE.PART> ::= <BASIC.STMT> ELSE",
"<COMPOUND.CONDITION> ::= <AND.HEAD> <SIMPLE.CONDIITON>",
"<COMPOUND.CONDITION> ::= <OR.HEAD> <SIMPLE.CONDIITON>",
"<COMPOUND.CONDITION> ::= <SIMPLE.CONDIITON>",
"<AND.HEAD> ::= <SIMPLE.CONDIITON> AND",
"<AND.HEAD> ::= <AND.HEAD> <SIMPLE.CONDIITON> AND",
"<OR.HEAD> ::= <SIMPLE.CONDIITON> OR",
"<OR.HEAD> ::= <OR.HEAD> <SIMPLE.CONDIITON> OR",
"<SIMPLE.CONDITION> ::= ( <STMT.LIST> ) <CONDIITON>",
"<SIMPLE.CONDITION> ::= <CONDITION>",
"<CONDITION> ::= NOT ZERO",
"<CONDITION> ::= ZERO",
"<CONDITION> ::= NOT CY",
"<CONDITION> ::= CY",
"<CONDITION> ::= PY ODD",
"<CONDITION> ::= PY EVEN",
"<CONDITION> ::= PLUS",
"<CONDITION> ::= MINUS",
"<DECL.ELEMENT> ::= <STORAGE.DECLARATION>",
"<DECL.ELEMENT> ::= <IDENT.SPECIFICATION> <TYPE>",
"<DECL.ELEMENT> ::= <IDENTIFIER> <DATA.LIST>",
"<DATA.LIST> ::= <DATA.HEAD> <CONSTANT> )",
"<DATA.HEAD> ::= DATA (",
"<DATA.HEAD> ::= <DATA.HEAD> <CONSTANT> ,",
"<STORAGE.DECLARATION> ::= <IDENT.SPECIFICATION> BYTE",
"<STORAGE.DECLARATION> ::= <BOUND.HEAD> <NUMBER> ) BYTE",
"<STORAGE.DECLARATION> ::= <STORAGE.DECLARATION> <INITIAL.LIST>",
"<TYPE> :: = LABEL",
"<TYPE> :: = EXTERNAL",
"<TYPE> :: = COMMON",
"<IDENT.SPECIFICATION> ::= <IDENTIFIER>",
"<IDENT.SPECIFICATION> ::= <IDENT.LIST> <IDENTIFIER> )",
"<IDENT.LIST> ::= (",
"<IDENT.LIST> ::= <IDENT.LIST> <IDENTIFIER> ,",
"<BOUND.HEAD> ::= <IDENT.SPECIFICATION>",
"<INITIAL.LIST> ::= <INITIAL.HEAD> <CONSTANT> )",
"<INITIAL.HEAD> ::= <INITIAL.HEAD> <CONSTANT> ,",
"<GROUP> ::= <GROUP.HEAD> ; <ENDING>",
"<GROUP.HEAD> ::= <DO>",
"<GROUP.HEAD> ::= <DO> <ITERATIVE.CLAUSE",
"<GROUP.HEAD> ::= <DO> <CASE.SELECTOR>",
"<GROUP.HEAD> ::= <GROUP.HEAD> ; <STMT>",
"<DO> ::= DO",
"<ITERATIVE.CLAUSE> ::= <INITIALIZATION> <BY> <ASSIGN.STMT> <WHILE> <COMPOUND.CONDITION>",
"<ITERATIVE.CLAUSE> ::= <INITIALIZATION> <WHILE><COMPOUND.CONDITION>",
"<BY> ::= BY",
"<WHILE> ::= WHILE",
"<CASE.SELECTOR> ::= CASE <REG>",
"<PROC DEFINITION> ::= <PROC.HEAD> <STMT.LIST> ; <ENDING>",
"<PROC.HEAD> ::= <PROC.NAME> ;",
"<PROC.HEAD> ::= <PROC.NAME> <FORMAL.PARAM.LIST",
"<PROC.NAME> :: <LABEL.DEFINITION> PROCEDURE",
"<FORMAL.PARAM.LIST> ::= <FP.HEAD> <IDENTIFIER> )",
"<FP.HEAD> ::= (",
"<FP.HEAD> ::= <FP.HEAD> <IDENTIFIER> ,",
"<RETURN.STMT> ::= RETURN",
"<RETURN.STMT> ::= IF <SIMPLE.CONDITION> RETURN",
"<CALL.STMT> ::= <CALL> <IDENTIFIER>",
"<CALL.STMT> ::= <CALL> <ACTUAL.PARAM.LIST>",
"<CALL.STMT> ::= <CALL> <NUMBER>",
"<ACTUAL.PARAM.LIST> ::= <AP.HEAD> <CONSTANT> )",
"<AP.HEAD> ::= <IDENTIFIER> (",
"<AP.HEAD> ::= <AP.HEAD> <CONSTANT> ,",
"<CALL> ::= CALL",
"<CALL> ::= IF <SIMPLE.CONDITION> CALL",
"<GOTO.STMT> ::= <GOTO> <IDENTIFIER>",
"<GOTO.STMT> ::= <GOTO> <NUMBER>",
"<GOTO.STMT> ::= <GOTO> M ( HL )",
"<GOTO> ::= GOTO",
"<GOTO> ::= IF <SIMPLE.CONDITION> GOTO",
"<REPEAT.STMT) ::= <REPEAT> <STMT.LIST> ; UNTIL <COMPOUND.CONDIITON",
"<REPEAT> ::= REPEAT",
"<CONTROL.STMT> :: = HALT",
"<CONTROL.STMT> :: = NOP",
"<CONTROL.STMT> :: = DISABLE",
"<CONTROL.STMT> :: = ENABLE",
"<COMPARE.STMT> ::= <REG> :: <SEC>",
"<EXCHANGE.STMT> ::= <REG> == <REG.EXPR>",
"<VAR.ASSIGN> ::= <VAR> = <REG.EXPR>",
"<REG.EXPR> ::= <REG>",
"<REG.EXPR> ::= ( <REG.ASSIGN> )",
"<REG.ASSIGN> ::= <REG> = <PRIM> <BINARY.OP> <SEC>",
"<REG.ASSIGN> ::= <REG> = <UNARY.OP> <PRIM>",
"<REG.ASSIGN> ::= <REG> = <PRIM>",
"<REG.ASSIGN> ::= <REG.ASSIGN> , <BINARY.OP> <SEC>",
"<PRIM> ::= <VAR>",
"<PRIM> ::= <SEC>",
"<SEC> ::= <REG.EXPR>",
"<SEC> ::= <CONSTANT>",
"<CONSTANT> ::= <STRING>",
"<CONSTANT> ::= <NUMBER>",
"<CONSTANT> ::= - <NUMBER>",
"<CONSTANT> ::= . <IDENTIFIER>",
"<CONSTANT> ::= . <IDENTIFIER> ( <NUMBER> )",
"<CONSTANT> ::= . <STRING>",
"<REG> ::= <A.L>",
"<REG> ::= BC",
"<REG> ::= DE",
"<REG> ::= HL",
"<REG> ::= SP",
"<REG> ::= STACK",
"<REG> ::= PSW",
"<REG> ::= M ( HL )",
"<REG> ::= CY",
"<BINARY.OP> ::= +",
"<BINARY.OP> ::= -",
"<BINARY.OP> ::= AND",
"<BINARY.OP> ::= OR",
"<BINARY.OP> ::= OR",
"<BINARY.OP> ::= ++",
"<BINARY.OP> ::= --",
"<BINARY.OP> ::= <",
"<BINARY.OP> ::= >",
"<BINARY.OP> ::= NOT",
"<BINARY.OP> ::= DEC",
"<BINARY.OP> ::= >>",
"<BINARY.OP> ::= <<",
"<VAR> ::= M ( BC )",
"<VAR> ::= M ( DE )",
"<VAR> ::= <IDENTIFIER>",
"<VAR> ::= <IDENTIFIER> ( NUMBER )",
"<VAR> ::= IN ( NUMBER )",
"<VAR> ::= OUT ( NUMBER )",
"<VAR> ::= M ( <CONSTANT> )"
};


void printg(uint16_t n) {
    if (n <= 158)
        printf("%d: %s\n", n, gram[n]);
    else
        printf("%d: ERROR\n", n);
}
#endif