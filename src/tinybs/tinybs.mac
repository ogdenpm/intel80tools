this is tiny basic for the 8086
TBASIC                         ; ABSOLUTE LOCATED CODE FOR 5 CHIP BOARD
TBASIC.OBJ                     ; OBJECT CODE OUTPUT FROM ASM86
TBASIC.MP2                     ; LOCATE DATA (SYMBOL TABLE, MEMORY MAP ETC.)
TBASIC.LOG
TBASIC.BAK
TBASIC.SRC                     ; SOURCE CODE (ASSEMBLY)
LOC   .CSD                     ; SUBMIT FILE TO INVOKE LOC86
TBMAC                          ; MACROS TO TEST TBASIC USING ICE86
TBASIC.DOC                     ; DOCUMENTATION FILE
TBASIC.HEX                     ; HEX OUTPUT OF OH86 READY TO BE PROGRAMMED INTO                                     8755A
TBASIC.LST                     ; LISTING OF TBASIC ASSEMBLY


TBASIC IS A TINY BASIC INTERPRETER FOR THE 8088 5 CHIP BOARD.  IT USES THE
8155 RAM FOR VARIABLE, STACK AND BUFFER STORAGE AND DEDICATES THE 8185 TO
USER PROGRAM MEMORY.  THE SOURCE CODE IS FAIRLY WELL DOCUMENTED.

THE LOC.CSD SUBMIT FILE INVOKES LOC86 WITH THE PROPER CONTROLS TO LOCATE
TBASIC IN THE FIRST PAGE OF 8088 MEMORY TO FIT ON THE 5 CHIP BOARD.

TBMAC PROVIDES THE INITIALIZATION AND OPERATION MACROS FOR SIMULATING TBASIC
ON ICE86.  THE ICE BREAKES WHENEVER AN INPUT OR OUTPUT OPERATION IS NEEDED FROM THE SYSTEM.
:020000020000FC
:020000000000FE
:020000020000FC
:06000200000000000000F8
:020000020000FC
:06000800000000000000F2
:020000020F00ED
:100000004C495354F69052554EF6644E4557F654AB
:100010004E455854F7834C4554F8524946F7D84753
:100020004F544FF67E474F535542F6E852455455CC
:10003000524EF70952454DF7D3464F52F724494ED9
:10004000505554F7F75052494E54F6A353544F505D
:10005000F65EF84D524E44F924414253F95D53493E
:100060005A45F96BF902544FF734F9A553544550EA
:10007000F741F7463E3DF86D23F8733EF8793DF8B9
:10008000873C3DF8813CF88DF893484F573F0D4F22
:0F0090004B0D574841543F0D534F525259210DBC
:020000020F40AD
:100000004C495354F69052554EF6644E4557F654AB
:100010004E455854F7834C4554F8524946F7D84753
:100020004F544FF67E474F535542F6E852455455CC
:10003000524EF70952454DF7D3464F52F724494ED9
:10004000505554F7F75052494E54F6A353544F505D
:10005000F65EF84D524E44F924414253F95D53493E
:100060005A45F96BF902544FF734F9A553544550EA
:10007000F741F7463E3DF86D23F8733EF8793DF8B9
:10008000873C3DF8813CF88DF893484F573F0D4F22
:0F0090004B0D574841543F0D534F525259210DBC
:020000020F509D
:1000000058E88504E99E04E816005D2E8A46003A09
:10001000047407452E8B6E00FFE54683C503FFE59C
:100020008A04463C2074F94EC3E8F4FF462C407421
:100030000477184EC3E8D90303DB724C8D06FF1218
:100040002BC33B061D10723D8BD8C33C1BF572E3DE
:100050008D1E20109803D803D8C3E8C3FFBB00004F
:100060008AEF2C3072F33C0977EF80FFF07319FEB2
:10007000C58BD303DB03DB03DA03DB250F0003D8D7
:10008000468A04EBDDE95104568D368AF0E91A04FC
:10009000BCFF1390C60608100090C6060910009019
:1000A000E886058D368FF02AC0E8A7048D06041077
:1000B000A30A10B80000A31110A30D10B03EE81F52
:1000C00004568D365510E891FFE854FF0BDB597547
:1000D00008803E091000744DC34E4E891C51562BAA
:1000E000CE51E84204567511E859045F578B0E1D36
:1000F000102BCEF3A4893E1D105B8B361D108BCECA
:100100002BCB5F03FE4E81FFFF127316893E1D103D
:100110004FE304FDF3A4FC8BFE475E592BCEF3A402
:10012000EB9AE9B403BF00F0E8F5FE5156B1FFF3D6
:10013000A6B07F807CFF2E740E4E263A45FF720AD1
:10014000AE73FD475EEBE5AE73FD4F268B1D86FB60
:100150005859FFE3E847038D06B010A31D10E83D92
:1001600003E92CFFE837038D36B010BB0000E8BE72
:100170000372EE89360A104646BF10F0EBAAE8E299
:100180000156E81903E89F03750358EBE6E9F9FE09
:10019000E8C7FEE80803E88E0372C6E83204E88E7A
:1001A00003EBF6B106E85FFE3BB0F6E87B04EBC973
:1001B000E854FE0DBBF6E87004EBB0E849FE23C836
:1001C000F6E89F018ACBEB05E89803EB11E837FED0
:1001D0002CD8F6E8B302EBE3E84E04E822FEE8820E
:1001E0000151E8AD0359EBE5E81C04E8750156E858
:1001F00035037599FF360A10FF360D1089260D104C
:10020000C70611100000E96AFFE89202A10D100B69
:10021000C0746D8BE08F060D108F060A105EE8C566
:1002200003E8DCFDE8E003E84A02891E1110BF661E
:10023000F0E9F4FEE82C01891E1510BF6CF0E9E727
:10024000FEE81F01EB03BB0100891E1310A10A1079
:10025000A3171089361910B90A008B1611108BECF0
:100260008B46000BC074163BC2740903E9EBF14DD9
:100270004D8B460089460A3BEC75F403E1E880FDAE
:10028000E92202E8A3FD72F8891E0F10A111100BDC
:10029000C074ED3BC37409E84C038B1E0F10EBECEC
:1002A0008B0E13108B070306131089070BC97808F0
:1002B0003B0615107717EB0639061510720F8B1ECB
:1002C0001710891E0A108B361910E833FDE8160343
:1002D000E82DFDBB0000EB03E888000BDB7403E9AD
:1002E00097FEE861027203E989FEE9A3FD8B260F00
:1002F000108F060A105E5E56E86802EB07E829FDDB
:10030000723FEB1656E821FD72568A0CB000880445
:100310008BFE5E57E83C025E880C56FF360A108959
:10032000260F10538D060610A30A10B03AE8B0014C
:100330008D365510E82C008BC35B89078F060A1099
:100340005E58E8C2FC2C4AF8EBADE8B3FC803C0DEB
:10035000740BE81F01E8AFFC2C5DF8EBF5E8A0FC9E
:10036000E94201E83E0053BF74F0E9BBFDE8250017
:100370007D0CC3E81F007506C3E819007E028AD809
:10038000C3E811007EF8C3E80B0074F2C3E805006F
:100390007CECC35BC3E80C008BCB5B58532BDB3B83
:1003A000C1B001C3E860FC2DAEF82BDBEB20E856B2
:1003B000FC2BB4F8E81F00E84DFC2BC8F853E815F7
:1003C000005803D8705BEBEFE83CFC2D20F953E8B4
:1003D0000400F7DBEBEBE82300E82BFC2AECF853F6
:1003E000E8190058F7EB70398BD8EBEDE818FC2FC3
:0903F00020F953E806005899F7C2
:020000020F8F5E
:10000900FBEBECBF54F0E926FDE824FC72038B1FDF
:10001900C3E84DFC0AED750FE8F3FB28A5F9E8499B
:10002900FFE8EAFB29A5F9C3E964FCE8EAFF0BDB71
:1000390078F674F4BA050090EC243F8AE04AEC8B18
:10004900D0538B1E1B1081FB9CFD7203BB90F52EB8
:100059008B0743891E1B105BF7E28BC22BD2F7F388
:100069008BDA43C3E8B1FF0BDB79F8F7DB71F4E90D
:100079001DFC8D1EFF122B1E1D10C3E8B2FB722C36
:1000890053E88AFB3DA5F9E8E0FE8BC35B8907C30A
:10009900E87BFB3B93F958E9E6FCE871FB0D9DF918
:1000A90058E9CEFCC3E87FFB3C0D74F8568D3692B7
:1000B900F02AC0E8A4005E8A0450C604008B360A00
:1000C900108B040BC074167903E928FEE808014E69
:1000D900588804B03FE85A012AC0E87D00E9B7FB17
:1000E900568D3698F0EBCAE848018D365510E8DF91
:1000F90001247F3C1A74E63C0A74F3E834010AC00F
:1001090074EC3C7F74113C18741B8804463C0D74D4
:100119001981FEA51075D781FE551074084E8A0401
:10012900E80F01EBC9E80801EBC0C3E961FB0BDB90
:1001390078F98D36B0108D06A510403BF072EBA111
:100149001D10483BC672E3391C73DF46468BFEB06F
:100159000DB9FFFFF2AE8BF7EBDC8AE826AC3AC5A6
:100169007407E8CD003C0D75F3C3E8A1FA227AFAC9
:10017900B022E8E5FF3C0D5B7503E9F5FB4343FF5E
:10018900E3E88AFA2784FAB027EBE7E880FA5F23E5
:10019900FAB08DE89C005BEBE48BC3BB0A00532AE1
:1001A900ED0BC07906B52DF7D8FEC9FEC999F7F34D
:1001B9000BC0740352EBF40AC97E09B020E872003F
:1001C900FEC9EBF58AC5E869008BC20430E8620014
:1001D900583D0A0075F5C38B1C534646B104E8B86F
:1001E900FFB020E84C002AC0E86FFF5BC35B8F06B5
:1001F9001110833E11100074108F0613108F06150D
:10020900108F0617108F06191053C3E9D2FE81FC0F
:10021900001376F7598B1E11100BDB7410FF36197A
:1002290010FF361710FF361510FF3613105351C340
:10023900B00D0AC07403E8B4003C0D7401C3B00AE0
:06024900E8EFFFB00DC359
:020000020000FC
:020000000000FE
:02000002010BF0
:1000000000000000000000000000000000000000F0
:1000100000000000000000000000000000000000E0
:1000200000000000000000000000000000000000D0
:1000300000000000000000000000000000000000C0
:1000400000000000000000000000000000000000B0
:1000500000000000000000000000000000000000A0
:100060000000000000000000000000000000000090
:100070000000000000000000000000000000000080
:100080000000000000000000000000000000000070
:100090000000000000000000000000000000000060
:1000A0000000000000000000000000000000000050
:1000B0000000000000000000000000000000000040
:1000C0000000000000000000000000000000000030
:1000D0000000000000000000000000000000000020
:1000E0000000000000000000000000000000000010
:1000F0000000000000000000000000000000000000
:1001000000000000000000000000000000000000EF
:1001100000000000000000000000000000000000DF
:1001200000000000000000000000000000000000CF
:1001300000000000000000000000000000000000BF
:1001400000000000000000000000000000000000AF
:10015000000000000000000000000000000000009F
:10016000000000000000000000000000000000008F
:10017000000000000000000000000000000000007F
:10018000000000000000000000000000000000006F
:10019000000000000000000000000000000000005F
:1001A000000000000000000000000000000000004F
:1001B000000000000000000000000000000000003F
:1001C000000000000000000000000000000000002F
:1001D000000000000000000000000000000000001F
:1001E000000000000000000000000000000000000F
:1001F00000000000000000000000000000000000FF
:1002000000000000000000000000000000000000EE
:1002100000000000000000000000000000000000DE
:1002200000000000000000000000000000000000CE
:1002300000000000000000000000000000000000BE
:0F024000000000000000000000000000000000AF
:020000020FB33A
:10000F008EC08ED0BF0010B91F00F3AA8926A7108B
:10001F00FF0E0610BE0010BF0014B91F00F3A52E6F
:10002F00C706000088F52EC706020000002EC7067F
:10003F00080001FC2EC7060A000000BA0000B0013C
:10004F00EEBA0100B0FFEEBA03F033C0EE4AB0FFD4
:10005F00EE4A4AEEB840008ED0BCFF13908ED88E79
:10006F00C033C08BD88BC88BD08BE88BF08BF89CB0
:10007F000EB890F550E8BB01BA0500B0CAEE4AB011
:10008F00DAEE33D2B0C1EEE9C7F9B002C606A91055
:10009F000090A2AE109C0EB8E0FB50E89501EB5E0D
:1000AF0090EBFEA0AD10C3500D000FD1E0A3AB102D
:1000BF00C606AA100090C606AF100090B001EBD292
:1000CF0058C3E86E01BA0200EC8AE0BA01F0EC50B6
:1000DF008BC8BA0100E858008926A710BA00F0B8FB
:1000EF0040008ED08EC08ED88B26A710E84100BA64
:1000FF0001F0E86800598ACDBA0200E85F00A0AEAF
:10010F001024037406B84000EB1490A0AE1424031F
:10011F00740533C0EB08902EA10C003540008ED033
:10012F008ED88B26A7101F075D5F5E5A595B58CF7D
:10013F00A0AF1024037514A1AB108A1EAE1080CB94
:10014F00FEF6D30AC3EED1F8A3AB10FE06AF1080B4
:10015F003EAF10037506C606AF100090C38A1EAEE1
:10016F00108AFB80E301743A803EAF10007520FEC9
:10017F0006AA10803EAA100A7515C606AE1000908A
:10018F00BBFFFB8926A71083C416538B26A71059D4
:10019F008926A71033C08ED08ED88EC08B26A7107D
:1001AF0051C38ADF80E30274E680E704746880E15C
:1001BF00807407D10EA510EB0590D106A510EC2485
:1001CF00807407D10EA510EB0590D106A510FE0681
:1001DF00AF10803EAF100375B6C606AF100090A1EA
:1001EF00A510C706A510FF0080E480D02EAD100823
:1001FF0026AD10FE06A910803EA910097591C606FE
:10020F00A91000908026AD107F90C606AE1000900A
:10021F00BBE2FBE96DFF80E1807403E971FFC60665
:10022F00AE100690C606AF100190C706A510FE01CE
:10023F00E95CFF891E00105B50FF360010515256CB
:10024F005755061E8926A7108CD133C08ED08EC06D
:0D025F008ED88B26A7102E890E0C0053C3DD
:020000020FFFEE
:0E000000B800008ED8BCFF1390EA3FFB000052
:020000020100FB
:10000000000000000000FFFF0000000000000000F2
:0F001000000000000000000000000090F5B0109C
:020000020102F9
:1000000000000000000000000000000000000000F0
:1000100000000000000000000000000000000000E0
:1000200000000000000000000000000000000000D0
:0400300000000000CC
:020000020105F6
:0100040000FB
:020000020105F6
:1000050000000000000000000000000000000000EB
:1000150000000000000000000000000000000000DB
:1000250000000000000000000000000000000000CB
:1000350000000000000000000000000000000000BB
:1000450000000000000000000000000000000000AB
:02000002010AF1
:0B0005000000000000000000000000F0
:02000002014AB1
:01000E0000F1
:020000020130CB
:1000000000000000000000000000000000000000F0
:1000100000000000000000000000000000000000E0
:1000200000000000000000000000000000000000D0
:1000300000000000000000000000000000000000C0
:1000400000000000000000000000000000000000B0
:1000500000000000000000000000000000000000A0
:100060000000000000000000000000000000000090
:100070000000000000000000000000000000000080
:100080000000000000000000000000000000000070
:100090000000000000000000000000000000000060
:1000A0000000000000000000000000000000000050
:1000B0000000000000000000000000000000000040
:1000C0000000000000000000000000000000000030
:1000D0000000000000000000000000000000000020
:1000E0000000000000000000000000000000000010
:0F00F00000000000000000000000000000000001
:040000030000FB3FBF
:00000001FF
CGROUP  GROUP   ABS_0,MEMORY,DATA,DATA2,STACK,DATA4,CODE,CONST,CONST2,CONST3
DGROUP  GROUP   ABS_0,MEMORY,DATA,DATA2,STACK,DATA4,CODE,CONST,CONST2,CONST3
SGROUP  GROUP   ABS_0,MEMORY,DATA,DATA2,STACK,DATA4,CODE,CONST,CONST2,CONST3
        ASSUME  CS:CGROUP,DS:DGROUP,ES:DGROUP,SS:SGROUP
CODE    SEGMENT WORD PUBLIC 'CODE'
CODE    ENDS
CONST   SEGMENT WORD PUBLIC 'CONST'
CONST   ENDS
DATA    SEGMENT WORD PUBLIC 'DATA'
DATA    ENDS
DATA2   SEGMENT WORD 'DATA'
DATA2   ENDS
MEMORY  SEGMENT WORD MEMORY 'MEMORY'
MEMORY_ LABEL   BYTE
MEMORY  ENDS
ABS_0   SEGMENT AT 0
DZ0 DW ?
DZS DW 3 DUP (?)
TOO DW ?
TOS DW ?
STACKS DW ?
ABS_0   ENDS
;********************************************************************
;
; *** TABLES *** DIRECT *** EXEC ***
;
; THIS SECTION OF THE CODE TESTS A STRING AGAINST A TABLE.
; WHEN A MATCH IS FOUND, CONTROL IS TRANSFERED TO THE SECTION
; OF CODE ACCORDING TO THE TABLE.
;
; AT 'EXEC', D-E SHOULD POINT TO THE STRING AND H-L SHOULD POINT
; TO THE TABLE.  AT 'DIRECT', D-E SHOULD POINT TO THE STRING,
; AND H-L WILL BE SET UP TO POINT TO TAB1-1, WHICH IS THE TABLE OF
; ALL DIRECT AND STATEMENT COMMANDS.
;
; A '.' IN THE STRING WILL TERMINATE THE TEST AND THE PARTIAL
; MATCH WILL BE CONSIDERED AS A MATCH.  (E.G. 'P.', 'PR.',
; 'PRI.', 'PRIN.', OR 'PRINT' WILL ALL MATCH 'PRINT'
;
; THE TABLE CONSISTS OF ANY NUMBER OF ITEMS, EACH ITEM IS A
; STRING OF CHARACTERS WITH BIT 7 SET TO 0 AND A
; JUMP ADDRESS STORED HIGH-LOW WITH BIT 7 OF THE HIGH ORDER
; BYTE SET TO 1.
;
; END OF TABLE IS AN ITEM WITH A JUMP ADDRESS ONLY.  IF THE
; STRING DOES NOT MATCH ANY OF THE OTHER ITEMS, IT WILL DEFAULT
; TO THIS NULL ITEM.
;
;*********************************************************************

CONST   SEGMENT WORD PUBLIC 'CONST'

ORG 0F000H

TAB1    DB      'LIST'
        DB      HIGH(CGROUP:LIST),LOW(CGROUP:LIST)

        DB      'RUN'
        DB      HIGH(CGROUP:RUN),LOW(CGROUP:RUN)

        DB      'NEW'
        DB      HIGH(CGROUP:NEW),LOW(CGROUP:NEW)

TAB2    DB      'NEXT'
        DB      HIGH(CGROUP:NEXT),LOW(CGROUP:NEXT)

        DB      'LET'
        DB      HIGH(CGROUP:LET),LOW(CGROUP:LET)

        DB      'IF'
        DB      HIGH(CGROUP:IFF),LOW(CGROUP:IFF)

        DB      'GOTO'
        DB      HIGH(CGROUP:GOTO),LOW(CGROUP:GOTO)

        DB      'GOSUB'
        DB      HIGH(CGROUP:GOSUB),LOW(CGROUP:GOSUB)

        DB      'RETURN'
        DB      HIGH(CGROUP:RETURN),LOW(CGROUP:RETURN)

        DB      'REM'
        DB      HIGH(CGROUP:REM),LOW(CGROUP:REM)

        DB      'FOR'
        DB      HIGH(CGROUP:FOR),LOW(CGROUP:FOR)

        DB      'INPUT'
        DB      HIGH(CGROUP:INPUT),LOW(CGROUP:INPUT)

        DB      'PRINT'
        DB      HIGH(CGROUP:PRINT),LOW(CGROUP:PRINT)

        DB      'STOP'
        DB      HIGH(CGROUP:STOP),LOW(CGROUP:STOP)

        DB      HIGH(CGROUP:DEFLT),LOW(CGROUP:DEFLT)

;  ANY NEW COMMANDS MAY BE INSERTED BEFORE THE DEFAULT NULL STRING

TAB4    DB      'RND'
        DB      HIGH(CGROUP:RND),LOW(CGROUP:RND)

        DB      'ABS'
        DB      HIGH(CGROUP:ABS_),LOW(CGROUP:ABS_)

        DB      'SIZE'
        DB      HIGH(CGROUP:SIZE_),LOW(CGROUP:SIZE_)

        DB      HIGH(CGROUP:XP40),LOW(CGROUP:XP40)

;  ANY NEW FUNCTIONS MAY BE INSERTED ABOVE BEFORE THE DEFAULT STRING

TAB5    DB      'TO'
        DB      HIGH(CGROUP:FR1),LOW(CGROUP:FR1)

        DB      HIGH(CGROUP:QWHAT),LOW(CGROUP:QWHAT)

TAB6    DB      'STEP'
        DB      HIGH(CGROUP:FR2),LOW(CGROUP:FR2)

        DB      HIGH(CGROUP:FR3),LOW(CGROUP:FR3)

TAB8    DB      '>='
        DB      HIGH(CGROUP:XP11),LOW(CGROUP:XP11)

        DB      '#'
        DB      HIGH(CGROUP:XP12),LOW(CGROUP:XP12)

        DB      '>'
        DB      HIGH(CGROUP:XP13),LOW(CGROUP:XP13)

        DB      '='
        DB      HIGH(CGROUP:XP15),LOW(CGROUP:XP15)

        DB      '<='
        DB      HIGH(CGROUP:XP14),LOW(CGROUP:XP14)

        DB      '<'
        DB      HIGH(CGROUP:XP16),LOW(CGROUP:XP16)

        DB      HIGH(CGROUP:XP17),LOW(CGROUP:XP17)

;
; THE FOLLOWING IS A TABLE OF MESSAGES
;

HOW     DB      'HOW?',CR

OK      DB      'OK',CR

WHAT    DB      'WHAT?',CR

SORRY   DB      'SORRY!',CR

;
; END OF TABLES FOR USER 1
;

CONST ENDS
;
; TABLES FOR USER 2 FOLLOW (THEY ARE SAME AS USER 1 BUT WITHOUT LABELS
;

CONST3  SEGMENT WORD PUBLIC 'CONST3'

ORG 0F400H

        DB      'LIST'
        DB      HIGH(CGROUP:LIST),LOW(CGROUP:LIST)

        DB      'RUN'
        DB      HIGH(CGROUP:RUN),LOW(CGROUP:RUN)

        DB      'NEW'
        DB      HIGH(CGROUP:NEW),LOW(CGROUP:NEW)

        DB      'NEXT'
        DB      HIGH(CGROUP:NEXT),LOW(CGROUP:NEXT)

        DB      'LET'
        DB      HIGH(CGROUP:LET),LOW(CGROUP:LET)

        DB      'IF'
        DB      HIGH(CGROUP:IFF),LOW(CGROUP:IFF)

        DB      'GOTO'
        DB      HIGH(CGROUP:GOTO),LOW(CGROUP:GOTO)

        DB      'GOSUB'
        DB      HIGH(CGROUP:GOSUB),LOW(CGROUP:GOSUB)

        DB      'RETURN'
        DB      HIGH(CGROUP:RETURN),LOW(CGROUP:RETURN)

        DB      'REM'
        DB      HIGH(CGROUP:REM),LOW(CGROUP:REM)

        DB      'FOR'
        DB      HIGH(CGROUP:FOR),LOW(CGROUP:FOR)

        DB      'INPUT'
        DB      HIGH(CGROUP:INPUT),LOW(CGROUP:INPUT)

        DB      'PRINT'
        DB      HIGH(CGROUP:PRINT),LOW(CGROUP:PRINT)

        DB      'STOP'
        DB      HIGH(CGROUP:STOP),LOW(CGROUP:STOP)

        DB      HIGH(CGROUP:DEFLT),LOW(CGROUP:DEFLT)

        DB      'RND'
        DB      HIGH(CGROUP:RND),LOW(CGROUP:RND)

        DB      'ABS'
        DB      HIGH(CGROUP:ABS_),LOW(CGROUP:ABS_)

        DB      'SIZE'
        DB      HIGH(CGROUP:SIZE_),LOW(CGROUP:SIZE_)

        DB      HIGH(CGROUP:XP40),LOW(CGROUP:XP40)

        DB      'TO'
        DB      HIGH(CGROUP:FR1),LOW(CGROUP:FR1)

        DB      HIGH(CGROUP:QWHAT),LOW(CGROUP:QWHAT)

        DB      'STEP'
        DB      HIGH(CGROUP:FR2),LOW(CGROUP:FR2)

        DB      HIGH(CGROUP:FR3),LOW(CGROUP:FR3)

        DB      '>='
        DB      HIGH(CGROUP:XP11),LOW(CGROUP:XP11)

        DB      '#'
        DB      HIGH(CGROUP:XP12),LOW(CGROUP:XP12)

        DB      '>'
        DB      HIGH(CGROUP:XP13),LOW(CGROUP:XP13)

        DB      '='
        DB      HIGH(CGROUP:XP15),LOW(CGROUP:XP15)

        DB      '<='
        DB      HIGH(CGROUP:XP14),LOW(CGROUP:XP14)

        DB      '<'
        DB      HIGH(CGROUP:XP16),LOW(CGROUP:XP16)

        DB      HIGH(CGROUP:XP17),LOW(CGROUP:XP17)

        DB      'HOW?',CR

        DB      'OK',CR

        DB      'WHAT?',CR

        DB      'SORRY!',CR

CONST3 ENDS

        PUBLIC  START

CODE    SEGMENT WORD PUBLIC 'CODE'
ORG 0F500H
;********************************************************
;
;         TINY BASIC FOR THE 8086
;                VERSION 1.0
;                 @COPYLEFT
;            ALL WRONGS RESERVED
;
;********************************************************
CR      EQU     0DH
LF      EQU     0AH

FEND:   POP     AX              ;THROW AWAY RETURN ADDRESS
        CALL    FIN             ;LOOK FOR END OF LINE
        JMP     QWHAT           ;ERROR IF NOT END OF LINE

TSTC:   CALL    IGBLK           ;SKIP BLANKS
        POP     BP                      ;BP= RETURN ADDR
        MOV     AL,CS:[BP]              ;GET BYTE AFTER CALL
        CMP     AL,[SI]                 ;COMPARE TO NEXT BYTE OF TEXT
        JZ      SHORT TC2               ;YES.
        INC     BP                      ;NO. POINT TO NEXT BYTE
        MOV     BP,CS:[BP]              ;GET JUMP ADDRESS
        JMP     BP

TC2:    INC     SI                      ;POINT TO NEXT CHAR
        ADD     BP,3                    ;RETURN AFTER TSTC CALL
        JMP     BP

; IGBLK- SKIP BLANKS
;    RETURNS 1ST NON-BLANK CHAR IN AL
IGBLK:  MOV     AL,[SI]
        INC     SI
        CMP     AL,' '
        JZ      IGBLK
        DEC     SI
        RET

; TSTV- TEST FOR A VARIABLE
;   RETURNS: BX= ADDR OF VARIABLE
;               C FLAG SET-> VARIABLE NOT FOUND
TSTV:   CALL    IGBLK           ;SKIP BLANKS
        INC     SI              ;POINT TO NEXT CHAR
        SUB     AL,'@'          ;@ ARRAY?
        JZ      SHORT ATARY     ;YES
        JA      TV1             ;NO. VARIABLE NAME
R0:     DEC     SI
        RET                     ;NO. ILLEGAL CHAR
ATARY:  CALL    PARN            ;EVALUATE ARRAY INDEX
        ADD     BX,BX           ;INDEX TOO BIG?
        JB      QHOW            ;YES. ERROR
        LEA     AX,DGROUP:TXTEND        ;ADDR OF ARRAY ELEMENT=
        SUB     AX,BX           ;TXTEND- 2*(ARRAY INDEX)
        CMP     AX,TXTUNF       ;ADDR< END OF TEXT?
        JB      QSORRX          ;YES. ERROR
        MOV     BX,AX           ;BX= ADDR OF @(EXPR)
        RET

TV1:    CMP     AL,27           ;CHAR<= Z ?
        CMC
        JB      R0              ;NO. RETURN
        LEA     BX,VARBGN
        CBW
        ADD     BX,AX
        ADD     BX,AX           ;BX= VARIBLE ADDR= VARBGN + 2*(CHAR-A)
R1:     RET

; TSTNUM- LOOK FOR A (DECIMAL) NUMBER
;    RETURNS:   BX= NUMBER
;               CH= # OF DIGITS
TSTNUM: CALL    IGBLK           ;SKIP BLANKS
        MOV     BX,0            ;INIT NUMBER
        MOV     CH,BH           ;INIT COUNT
TN1:    SUB     AL,'0'
        JB      R1              ;NOT A VALID DIGIT
        CMP     AL,9
        JA      R1              ;NOT A VALID DIGIT
        CMP     BH,0F0H         ;NUMBER IS TOO BIG?
        JAE     QHOW            ;YES. ERROR
        INC     CH              ;COUNT 1 MORE DIGIT
        MOV     DX,BX
        ADD     BX,BX
        ADD     BX,BX
        ADD     BX,DX
        ADD     BX,BX           ;BX= 10*BX
        AND     AX,0FH
        ADD     BX,AX           ;ADD NEW DIGIT
        INC     SI
        MOV     AL,[SI]         ;GET NEXT CHAR
        JMP     TN1

QSORRX: JMP     QSORRY

QHOW:   PUSH    SI
AHOW:   LEA     SI,HOW
        JMP     ERROR

;****************************************************************
;
; *** MAIN ***
;
; THIS IS THE MAIN LOOP THAT COLLECTS THE TINY BASIC PROGRAM
; AND STORES IT IN MEMORY.
;
; AT 'START', IT PRINTS OUT "<CR>OK<CR><LF>", AND INITIALIZES
; THE STACK AND OTHER INTERNAL VARIABLES.  IT THEN PROMPTS
; ">" AND READS A LINE.  IF THE LINE STARTS WITH A NON-ZERO NUMBER,
; IT REPRESENTS A LINE NUMBER.  THE LINE NUMBER (16-BIT BINARY)
; AND THE REST OF THE LINE (INCLUDING <CR>) IS STORED IN MEMORY.
; IF A LINE WITH THE SAME LINE NUMBER IS ALREADY THERE, IT IS
; REPLACED BY THE NEW ONE.  IF THE REST OF THE LINE CONSISTS
; IF  A <CR> ONLY, IT IS NOT STORED AND ANY EXISTING LINE
; WITH THE SAME LINE NUMBER IS DELETED.
;
; AFTER A LINE IS INSERTED, REPLACED OR DELETED, THE PROGRAM
; LOOPS BACK AND ASKS FOR ANOTHER LINE.  THIS LOOP WILL BE
; TERMINATED WHEN IT READS A LINE WITH ZERO OR NO LINE NUMBER AND
; CONTROL IS THEN PASSED TO 'DIRECT'.
;
; THE PROGRAM SAVE AREA STARTS AT 'TXTBGN' AND ENDS AT 'TXTEND'.  WE
; ALWAYS FILL THIS AREA STARTING AT 'TXTBGN'.  THE UNFILLED PORTION
; IS POINTED TO BY THE CONTENTS OF 'TXTUNF'.
;
; MEMORY LOCATION 'CURRNT' POINTS TO THE LINE NUMBER THAT IS
; CURRENTLY BEING INTERPRETED.  WHILE WE ARE IN THIS LOOP OR
; WHILE WE ARE INTERPRETING A DIRECT COMMAND (SEE NEXT SECTION),
; 'CURRNT' SHOULD POINT TO A ZERO.
;
;*******************************************************************

START:  MOV     SP,OFFSET(STK)
        MOV     POLO,0
        MOV     RICI,0
ST1:    CALL    CRLF            ;OUTPUT <CR><LF>
        LEA     SI,OK
        SUB     AL,AL
        CALL    PRTSTG          ;OUTPUT OK MESSAGE
        LEA     AX,ZERO
        MOV     CURRNT,AX       ;INIT LINE #
ST2:    MOV     AX,0
        MOV     LOPVAR,AX
        MOV     STKGOS,AX       ;INIT LOOP VALUES
ST3:    MOV     AL,'>'
        CALL    GETLN           ;GET A LINE
        PUSH    SI              ;SAVE POINTER TO EMPTY BUFFER
        LEA     SI,BUFFER       ;POINT TO BUFFER START
        CALL    TSTNUM          ;GET LINE NUMBER
        CALL    IGBLK           ;SKIP BLANKS
        OR      BX,BX           ;SET FLAGS
        POP     CX              ;CX= END OF LINE
        JNZ     SHORT STCONT    ;LINE NUMBER EXISTS?
        CMP     RICI,0          ;NO.  FLAG SET?
        JZ      DIRECT          ;NO. DO DIRECT CALL
        RET                     ;YES. JUST RETURN

STCONT: DEC     SI              ;NOT A DIRECT CALL
        DEC     SI
        MOV     [SI],BX         ;PUT LINE # BEFORE LINE
        PUSH    CX              ;END OF LINE ON STACK
        PUSH    SI              ;START OF LINE ON STACK
        SUB     CX,SI
        PUSH    CX              ;LENGTH ON STACK
        CALL    FNDLN           ;GET POINTER TO TEXT AREA
        PUSH    SI              ;SAVE IT ON STACK
        JNZ     SHORT ST4       ;LINE ALREADY EXISTS?
                        ;YES. WIPE OUT OLD LINE
        CALL    FNDNXT          ;GET POINTER TO NEXT LINE
        POP     DI
        PUSH    DI
        MOV     CX,TXTUNF
        SUB     CX,SI           ;CX=COUNT
        REP     MOVS BYTE PTR ES:[DI],BYTE PTR [SI]
        MOV     TXTUNF,DI

; CREATE SPACE IN BUFFER AND MOVE NEW LINE INTO SPACE

ST4:    POP     BX              ;BX= POINTER INTO TEXT AREA
        MOV     SI,TXTUNF
        MOV     CX,SI
        SUB     CX,BX           ;CX= COUNT
        POP     DI              ;DI= LEN
        ADD     DI,SI           ;DEST= SOURCE+LEN
        DEC     SI              ;SOURCE= LAST CHAR IN BUFFER
        CMP     DI,OFFSET(DGROUP:TXTEND)        ;ENOUGH SPACE?
        JAE     QSORRZ          ;NO. ERROR
        MOV     TXTUNF,DI       ;SET NEW END OF TEXT
        DEC     DI
        JCXZ    ST5
        STD
        REP     MOVS BYTE PTR ES:[DI],BYTE PTR [SI]     ;MAKE SPACE
        CLD
ST5:    MOV     DI,SI
        INC     DI              ;DEST= CLEARED SPACE
        POP     SI              ;SOURCE= START OF NEW LINE
        POP     CX              ;CX= END OF NEW LINE
        SUB     CX,SI           ;COUNT= LEN OF NEW LINE
        REP     MOVS BYTE PTR ES:[DI],BYTE PTR [SI]     ;MOVE NEW LINE
        JMP     ST3

QSORRZ: JMP     QSORRY

DIRECT: MOV     DI,OFFSET(CGROUP:TAB1)
EXEC:   CALL    IGBLK           ;SKIP BLANKS
        PUSH    CX              ;SAVE CX
EX0:    PUSH    SI              ;SAVE POINTER
        MOV     CL,0FFH
EX1:    REPZ    CMPS BYTE PTR [SI],BYTE PTR ES:[DI]
        MOV     AL,7FH
        CMP     BYTE PTR [SI-1],'.'     ;PERIOD?
        JZ      EX3             ;YES. MATCH
        DEC     SI                      ;POINT AT 1ST UNMATCHED BYTE
        CMP     AL,ES:[DI-1]
        JB      EX5             ;JMP ADDRESS?
EX2:    SCAS    BYTE PTR ES:[DI]        ;NO. SCAN FOR IT
        JAE     EX2
        INC     DI              ;POINT PAST IT
        POP     SI              ;
        JMP     EX0             ;TRY NEXT TABLE ENTRY

EX3:    SCAS    BYTE PTR ES:[DI]        ;SCAN FOR JUMP ADDR
        JAE     EX3
EX5:    DEC     DI              ;POINT TO 1ST BYTE OF JUMP ADDR
        MOV     BX,ES:[DI]
        XCHG    BH,BL
                ;LOCATION OF AND BH,AL IF RUNNING IN LOW ROM
        POP     AX
        POP     CX              ;CLEAR STACK
        JMP     BX              ;JMP TO DIRECT ROUTINE

;*****************************************************************
;
; WHAT FOLLOWS IS THE CODE TO EXECUTE DIRECT AND STATEMENT
; COMMANDS.  CONTROL IS TRANSFERED TO THESE POINTS VIA THE
; COMMAND TABLE LOOKUP CODE OF 'DIRECT' AND 'EXEC' IN THE
; LAST SECTION.  AFTER THE COMMAND IS EXECUTED, CONTROL IS
; TRANSFERED TO OTHER SECTIONS AS FOLLOWS:
;
; FOR 'LIST', 'NEW' AND 'STOP':  GO BACK TO 'START'
; FOR 'RUN':  GO EXECUTE THE FIRST STORED LINE IF ANY, ELSE
; GO BACK TO 'START'.
; FOR 'GOTO' AND 'GOSUB':  GO EXECUTE THE TARGET LINE.
; FOR 'RETURN' AND 'NEXT':  GO BACK TO SAVED RETURN LINE.
; FOR ALL OTHERS:  IF 'CURRNT' IS 0, GO TO 'START', ELSE
; GO EXECUTE NEXT COMMAND.  (THIS IS DONE IN 'FINISH'.)
;
;******************************************************************
;
; *** NEW *** STOP *** RUN  (AND FRIENDS) *** GOTO ***
;
; 'NEW<CR>' SETS 'TXTUNF' TO POINT TO 'TXTBGN'.
;
; 'STOP<CR>' GOES BACK TO 'START'.
;
; 'RUN<CR>' FINDS THE FIRST STORED LINE, STORES ITS ADDRESS
; (IN 'CURRNT') AND EXECUTES IT.  NOTE THAT ONLY THOSE
; COMMANDS IN TAB2 ARE LEGAL FOR STORED PROGRAMS.
;
; THERE ARE THREE MORE ENTRIES IN 'RUN':
;
; 'RUNNXL' FINDS NEXT LINE, STORES ITS ADDRESS AND EXECUTES IT.
; 'RUNTSL' STORES THE ADDRESS OF THIS LINE AND EXECUTES IT.
; 'RUNSML' CONTINUES THE EXECUTION ON THE SAME LINE.
;
; 'GOTO <EXPR>' EVALUATES THE EXPRESSION, FINDS THE TARGET
; LINE AND JUMPS TO 'RUNTSL' TO DO IT.
;
;******************************************************************


NEW:    CALL    ENDCHK
        LEA     AX,DGROUP:TXTBGN
        MOV     TXTUNF,AX               ;RESET FREE SPACE POINTER

STOP:   CALL    ENDCHK
STAR1:  JMP     START

RUN:    CALL    ENDCHK
        LEA     SI,DGROUP:TXTBGN

RUNNXL: MOV     BX,0
        CALL    FNDLNP
        JB      STAR1

RUNTSL: MOV     CURRNT,SI               ;SAVE PTR TO RUNNING LINE
        INC     SI
        INC     SI                      ;SKIP LINE #

RUNSML: MOV     DI,OFFSET(CGROUP:TAB2)
        JMP     EXEC

GOTO:   CALL    EXPR                    ;EVALUATE THE EXPRESSION
        PUSH    SI                      ;SAVE THE PTR
        CALL    ENDCHK
        CALL    FNDLN                   ;FIND LINE <EXPR>
        JNZ     AHOW1           ;LINE DOESN'T EXIST
        POP     AX
        JMP     RUNTSL

AHOW1:  JMP     AHOW

;******************************************************************
;
; *** LIST *** PRINT ***
;
; LIST HAS TWO FORMS:
;
; 'LIST<CR>' LISTS ALL SAVED LINES.
; 'LIST #<CR>' STARTS LISTING AT LINE '#'.
; CONTROL/C STOPS THE LISTING.
;
; PRINT COMMAND IS 'PRINT....:' OR 'PRINT....<CR>'
; WHERE '....' IS A LIST OF EXPRESSIONS, FORMATS,
; BACKARROWS AND/OR STRINGS.  THESE ITEMS ARE SEPARATED
; BY COMMAS.
;
; A FORMAT IS A POUND SIGN (#) FOLLOWED BY A NUMBER.  IT CONTROLS
; THE NUMBER OF SPACES THE VALUE OF AN EXPRESSION IS GOING TO
; BE PRINTED IN.  IT STAYS EFFECTIVE FOR THE REST OF THE PRINT
; COMMAND UNLESS CHANGED BY ANOTHER FORMAT.  IF NO FORMAT IS
; SPECIFIED, 6 POSITIONS WILL BE USED.
;
; A STRING IS QUOTED IN A PAIR OF SINGLE QUOTES OR A PAIR OF
; DOUBLE QUOTES.
;
; A BACKARROW MEANS GENERATE A <CR> WITHOUT <LF>
;
; A <CR><LF> IS GENERATED AFTER THE ENTIRE LIST HAS BEEN
; PRINTED OR IF THE LIST IS A NULL LIST.  HOWEVER, IF THE LIST
; ENDED WITH A COMMA, NO <CR><LF> IS GENERATED.
;
;************************************************************************


LIST:   CALL    TSTNUM          ;LINE # ?
        CALL    ENDCHK
        CALL    FNDLN           ;FIND LINE
LS1:    JB      STAR1           ;LINE FOUND?
        CALL    PRTLN           ;YES. PRINT IT
        CALL    FNDLNP          ;FIND NEXT LINE
        JMP     LS1

PRINT:  MOV     CL,6            ;DEFAULT FIELD WIDTH=6
        CALL    TSTC            ;IS IT A ; ?
        DB      ';'
        DW      CGROUP:PR2
        CALL    CRLF            ;YES. JUST OUTPUT <CR><LF>
        JMP     RUNSML

PR2:    CALL    TSTC            ;IS IT A <CR> ?
        DB      CR
        DW      CGROUP:PR0
        CALL    CRLF            ;YES. JUST OUTPUT <CR><LF>
        JMP     RUNNXL

PR0:    CALL    TSTC            ;IS IT A #  ?
        DB      '#'
        DW      CGROUP:PR1
        CALL    EXPR            ;YES. EVALUATE EXPRESSION
        MOV     CL,BL           ;SET FIELD WIDTH
        JMP     SHORT PR3       ;CONTINUE

PR1:    CALL    QTSTG           ;LOOK FOR QUOTED STRING
        JMP     SHORT PR8

PR3:    CALL    TSTC            ;IS THERE A , ?
        DB      ','
        DW      CGROUP:PR6
        CALL    FIN             ;YES. LOOK FOR END OF LINE
        JMP     PR0             ;KEEP ON PRINTIN'

PR6:    CALL    CRLF            ;OUTPUT <CR><LF>
        CALL    FEND            ;MUST BE END OF LINE

PR8:    CALL    EXPR            ;EVALUATE <EXPR>
        PUSH    CX              ;SAVE FIELD WIDTH
        CALL    PRTNUM          ;PRINT THE FIELD
        POP     CX              ;RESTORE FIELD WIDTH
        JMP     PR3             ;LOOK FOR ANOTHER FIELD

;*******************************************************************************;
; *** GOSUB *** RETURN ***
;
; 'GOSUB <EXPR>;' OR 'GOSUB <CR>' IS LIKE THE 'GOTO'
; COMMAND, EXCEPT THAT THE CURRENT TEXT POINTER, STACK
; POINTER, ETC., ARE SAVED SO THAT EXECUTION CAN BE
; CONTINUED AFTER THE SUBROUTINE 'RETURN'.  IN ORDER THAT
; 'GOSUB' CAN BE NEXTED ( AND EVEN RECURSIVE ), THE SAVE AREA
; MUST BE STACKED.  THE STACK POINTER IS SAVED IN 'STKGOS'.
; THE OLD 'STKGOS' IS SAVED IN THE STACK.  IF WE ARE IN THE
; MAIN ROUTINE, 'STKGOS' IS ZERO (DONE IN THE MAIN CODE SECTION):
; BUT WE STILL SAVE IT AS A FLAG FOR NO FURTHER 'RETURNS'
;
; 'RETURN <CR>' UNDOES EVERYTHING THAT 'GOSUB' DID, AND THUS
; RETURNS CONTROL TO THE COMMAND AFTER THE MOST RECENT
; 'GOSUB'.  IF 'STKGOS' IS ZERO, IT INDICATES THAT WE NEVER
; HAD A 'GOSUB' AND IS AN ERROR CONDITION.
;
;*******************************************************************************
GOSUB:  CALL    PUSHA           ;SAVE CURRENT STATE
        CALL    EXPR            ;EVALUATE <EXPR>
        PUSH    SI              ;SAVE THE TEXT POINTER
        CALL    FNDLN           ;FIND THE LINE TO GOTO
        JNZ     AHOW1           ;LINE DOESN'T EXIST, <ERROR>
        PUSH    CURRNT          ;SAVE VARIABLES
        PUSH    STKGOS
        MOV     STKGOS,SP       ;SET GOSUB FRAME POINTER
        MOV     LOPVAR,0        ;CLEAR LOOP VARIABLE
        JMP     RUNTSL          ;GO EXECUTE THE FIRST LINE OF THE ROUTINE

RETURN: CALL    ENDCHK
        MOV     AX,STKGOS
        OR      AX,AX           ;IS THERE A FRAME SAVED?
        JZ      QWHAX           ;NO, <ERROR>
        MOV     SP,AX           ;SET STACK POINTER
        POP     STKGOS          ;RESTORE VARIABLES
        POP     CURRNT
        POP     SI              ;RESTORE TEXT POINTER
        CALL    POPA            ;RESTORE STATE
        CALL    FEND


;***************************************************************
;
; *** FOR *** NEXT ***
;
; 'FOR' HAS TWO FORMS:
;
; 'FOR VAR=EXP1 TO EXP2 STEP EXP3' AND 'FOR VAR=EXP1 TO EXP2'
;
; THE SECOND FORM MEANS THE SAME THING AS THE FIRST FORM WITH
; EXP1=1.  (I.E. WITH A STEP OF +1)
;
; BASIC WILL FIND THE VARIABLE 'VAR' AND SET ITS VALUE TO THE
; CURRENT VALUE OF EXP1.  IT ALSO EVALUATES EXP2 AND EXP1 AND
; SAVES THEM TOGETHER WITH THE TEXT POINTER ETC. IN THE
; 'FOR' SAVE AREA WHICH CONSISTS OF 'LOPVAR', 'LOPINC',
; 'LOPLMT', 'LOPLN' AND 'LOPPT'.  IF THERE IS ALREADY
; SOMETHING IN THE SAVE AREA (INDICATED BY NON-ZERO 'LOPVAR'),
; THE OLD SAVE AREA IS SAVED IN THE STACK BEFORE THE NEW ONE
; OVERWRITES IT.
;
; BASIC THEN DIGS IN THE STACK TO FIND OUT IF THIS SAME
; VARIABLE WAS USED IN ANOTHER CURRENTLY ACTIVE 'FOR' LOOP.
; IF SO, THEN THE OLD 'FOR' LOOP IS DEACTIVATED  (I.E.
; PURGED FROM THE STACK).
;
; 'NEXT <VARB>' SERVES AS THE LOGICAL (NOT NECESSARILY
; PHYSICAL) END OF THE 'FOR' LOOP.  THE CONTROL
; VARIABLE <VARB> IS CHECKED AGAINST 'LOPVAR'.  IF THEY ARE NOT
; THE SAME, BASIC THEN SHUFFLES THRU THE STACK TO FIND THE
; RIGHT ONE AND PURGES ALL THOSE THAT DID NOT MATCH.  EITHER
; WAY, BASIC THEN ADDS THE 'STEP' TO THAT VARIABLE AND CHECKS
; THE RESULT WITH THE LIMIT.  IF IT IS WITHIN LIMITS, CONTROL
; LOOPS BACK TO THE COMMAND FOLLOWING THE 'FOR'.  IF OUTSIDE
; THE LIMIT, THE SAVE AREA IS PURGED AND EXECUTION CONTINUES.
;
;***************************************************************

FOR:    CALL    PUSHA           ;SAVE STATE
        CALL    SETVAL          ;SET LOOP VARIABLE TO INITIAL VALUE
        MOV     LOPVAR,BX       ;SAVE LOOP VARIABLE ADDR
        MOV     DI,OFFSET(CGROUP:TAB5)  ;LOOK FOR 'TO'
        JMP     EXEC

FR1:    CALL    EXPR            ;EVALUATE <EXPR>
        MOV     LOPLMT,BX       ;SET LIMIT VALUE
        MOV     DI,OFFSET(CGROUP:TAB6)  ;LOOK FOR 'STEP'
        JMP     EXEC

FR2:    CALL    EXPR            ;EVALUATE EXPRESSION
        JMP     SHORT FR4

FR3:    MOV     BX,1            ;STEP NOT FOUND. USE 1

FR4:    MOV     LOPINC,BX       ;SET STEP VALUE
FR5:    MOV     AX,CURRNT
        MOV     LOPLN,AX        ;SAVE LINE POINTER
        MOV     LOPPT,SI        ;SAVE TEXT POINTER
        MOV     CX,10
        MOV     DX,LOPVAR       ;LOOK FOR LOPVAR IN STACK
        MOV     BP,SP
FR7:    MOV     AX,[BP]         ;GET WORD FROM STACK
        OR      AX,AX           ;PAST END OF STACK?
        JZ      SHORT FR8       ;YES. DON'T PURGE A STACK FRAME
        CMP     AX,DX           ;WORD= LOPVAR?
        JZ      FR10            ;YES.
        ADD     BP,CX
        JMP     FR7             ;NO. KEEP LOOKING

FR9:    DEC     BP
        DEC     BP
        MOV     AX,[BP]
FR10:   MOV     [BP+10],AX      ;PURGE 1 STACK FRAME
        CMP     BP,SP
        JNZ     FR9
        ADD     SP,CX
FR8:    CALL    FEND

QWHAX:  JMP     QWHAT

NEXT:   CALL    TSTV            ;LOOK FOR A VARIABLE
        JB      QWHAX           ;ERROR. NOT A VARIABLE
        MOV     VARNXT,BX       ;SAVE VARIABLE ADDR
NX0:    MOV     AX,LOPVAR       ;GET 'FOR' VARIABLE ADDR
        OR      AX,AX           ;ANY?
        JZ      QWHAX           ;NO. ERROR
        CMP     AX,BX           ;'FOR' VARIABLE='NEXT' VARIABLE?
        JZ      SHORT NX3
        CALL    POPA            ;NO. PEEL OFF A FRAME
        MOV     BX,VARNXT
        JMP     NX0             ;TRY AGAIN

NX3:    MOV     CX,LOPINC
        MOV     AX,[BX]         ;GET LOOP VARIABLE
        ADD     AX,LOPINC       ;ADD STEP VALUE
        MOV     [BX],AX         ;SAVE NEW LOOP VARIABLE
        OR      CX,CX
        JS      SHORT NX4
        CMP     AX,LOPLMT       ;NEW VALUE> LIMIT?
        JA      SHORT NX2       ;YES. GO TO NEXT LINE
        JMP     SHORT NX5
NX4:    CMP     LOPLMT,AX
        JB      SHORT NX2
NX5:    MOV     BX,LOPLN        ;NO. GO TO TOP OF LOOP
        MOV     CURRNT,BX       ;SET LINE POINTER
        MOV     SI,LOPPT        ;SET TEXT POINTER
        CALL    FEND

NX2:    CALL    POPA            ;PURGE 1 FRAME
        CALL    FEND
;*************************************************************
;
; *** REM *** IF *** INPUT *** LET *** DEFAULT ***
;
;*************************************************************

REM:    MOV     BX,0
        JMP     SHORT IFF1

IFF:    CALL    EXPR            ;EVALUATE <EXPR>
IFF1:   OR      BX,BX           ;TRUE?
        JZ      SHORT L_20      ;NO. SKIP REMAINDER OF LINE
        JMP     RUNSML
L_20:   CALL    FNDSKP          ;FIND NEXT LINE
        JB      STARX           ;NO MORE LINES. RE-START
        JMP     RUNTSL          ;RUN NEXT LINE
STARX:  JMP     START

INPERR: MOV     SP,STKINP       ;RESTORE STACK POINTER
        POP     CURRNT          ;RESTORE LINE POINTER
        POP     SI
        POP     SI              ;RESTORE TEXT POINTER

INPUT:  PUSH    SI              ;SAVE TEXT POINTER
        CALL    QTSTG           ;PRINT USER PROMPT, IF ANY
        JMP     SHORT IP2       ;NO USER PROMPT
        CALL    TSTV            ;LOOK FOR VARIABLE
        JB      SHORT IP4       ;NOT FOUND. LOOK FOR ,
        JMP     SHORT IP3       ;GO INPUT INTO THE VARIABLE

; USE VARIABLE NAME AS PROMPT

IP2:    PUSH    SI              ;SAVE TEXT POINTER
        CALL    TSTV            ;LOOK FOR VARIABLE
        JB      QWHAY           ;NOT FOUND. ERROR
        MOV     CL,[SI]         ;SAVE CHAR IN CL
        MOV     AL,0
        MOV     [SI],AL         ;PUT A NULL IN
        MOV     DI,SI
        POP     SI              ;GET POINTER TO VARIABLE NAME
        PUSH    DI              ;SAVE NULL POINTER
        CALL    PRTSTG          ;PRINT VARIABLE NAME
        POP     SI              ;GET NULL POINTER
        MOV     [SI],CL         ;REPLACE ORIGINAL CHAR
IP3:    PUSH    SI              ;SAVE TEXT POINTER
        PUSH    CURRNT          ;SAVE LINE POINTER
        MOV     STKINP,SP       ;SAVE STACK POINTER
        PUSH    BX              ;SAVE VARIABLE ADDR
        LEA     AX,M1
        MOV     CURRNT,AX       ;SET FLAG
        MOV     AL,':'
        CALL    GETLN           ;GET THE INPUT
        LEA     SI,BUFFER
        CALL    EXPR            ;EVALUATE <EXPR>
        MOV     AX,BX           ;VALUE IN AX
        POP     BX              ;RESTORE VARIABLE ADDR
        MOV     [BX],AX         ;STORE VALUE IN VARIABLE
        POP     CURRNT          ;RESTORE LINE POINTER
        POP     SI              ;RESTORE TEXT POINTER
IP4:    POP     AX              ;CLEAR STACK
        CALL    TSTC            ;LOOK FOR A ,
        DB      ','
        DW      CGROUP:IP5
        JMP     INPUT           ;FOUND. DO IT AGAIN
IP5:    CALL    FEND            ;NOT FOUND. DONE

DEFLT:  CMP     BYTE PTR [SI],CR        ;EMPTY LINE?
        JZ      SHORT LT1       ;YES. GO TO NEXT LINE

LET:    CALL    SETVAL          ;ASSIGN VALUE TO VARIABLE
        CALL    TSTC            ;LOOK FOR A ,
        DB      ','
        DW      CGROUP:LT1
        JMP     LET             ;FOUND. DO IT AGAIN
LT1:    CALL    FEND            ;NOT FOUND. DONE

QWHAY:  JMP     QWHAT

;*****************************************************************
;
; *** EXPR ***
;
;*****************************************************************

EXPR:   CALL    EXPR2           ;EVALUATE THE 1ST OPERAND
        PUSH    BX              ;SAVE IT
EXPR1:  MOV     DI,OFFSET(CGROUP:TAB8)
        JMP     EXEC            ;LOOK FOR RELATIONAL OPERATORS
;  >=

XP11:   CALL    XP18
        JGE     SHORT GRTN
        RET

;  #

XP12:   CALL    XP18
        JNZ     SHORT GRTN
        RET

;   >

XP13:   CALL    XP18
        JLE     XRTN            ;FALSE
GRTN:   MOV     BL,AL           ;TRUE
XRTN:   RET

;  <=

XP14:   CALL    XP18
        JLE     GRTN
        RET


;   =

XP15:   CALL    XP18
        JZ      GRTN            ;TRUE
        RET                     ;FALSE

;   <

XP16:   CALL    XP18
        JL      GRTN            ;TRUE
        RET                     ;FALSE

;  NOT FOUND

XP17:   POP     BX              ;CLEAR STACK
        RET

;  COMMON EXPR SUBROUTINE

XP18:   CALL    EXPR2           ;EVALUATE 2ND OPERAND
        MOV     CX,BX           ;PUT IT IN CX
        POP     BX              ;GET RETURN ADDR
        POP     AX              ;GET 1ST OPERAND
        PUSH    BX              ;PUT RETURN ADDR BACK
        SUB     BX,BX
        CMP     AX,CX           ;COMPARE THE OPERANDS
        MOV     AL,1            ;SET UP RETURN VALUES
        RET

;  ROUTINE 'EXPR2' EVALUATES TERMS

EXPR2:  CALL    TSTC            ;LOOK FOR A LEADING -
        DB      '-'
        DW      CGROUP:XP21
        SUB     BX,BX           ;FOUND. MAKE 1ST OPERAND 0
        JMP     SHORT XP27

XP21:   CALL    TSTC            ;IGNORE LEADING +
        DB      '+'
        DW      CGROUP:XP22

XP22:   CALL    EXPR3           ;EVALUATE 1ST OPERAND
XP23:   CALL    TSTC            ;LOOK FOR +
        DB      '+'
        DW      CGROUP:XP25

XP24:   PUSH    BX              ;SAVE 1ST OPERAND
        CALL    EXPR3           ;EVALUATE 2ND OPERAND

XP26:   POP     AX              ;GET 1ST OPERAND
        ADD     BX,AX           ;PERFORM OPERATION
        JO      QHOW1           ;OVERFLOW ERROR
        JMP     XP23            ;GO LOOK FOR MORE TERMS

XP25:   CALL    TSTC            ;LOOK FOR -
        DB      '-'
        DW      CGROUP:XP42
XP27:   PUSH    BX              ;SAVE 1ST OPERAND
        CALL    EXPR3           ;EVALUATE 2ND OPERAND
        NEG     BX              ;NEGATE 2ND OPERAND
        JMP     XP26            ;GO ADD THEM

;  ROUTINE 'EXPR3' EVALUATES FACTORS

EXPR3:  CALL    EXPR4           ;EVALUATE 1ST OPERAND
XP31:   CALL    TSTC            ;LOOK FOR *
        DB      '*'
        DW      CGROUP:XP34
        PUSH    BX              ;SAVE 1ST OPERAND
        CALL    EXPR4           ;EVALUATE 2ND OPERAND
        POP     AX              ;GET 1ST OPERAND
        IMUL    BX              ;AX= 1ST* 2ND
        JO      QHOW1           ;OVERFLOW
XP35:   MOV     BX,AX           ;PUT RESULT IN BX
        JMP     XP31            ;LOOK FOR MORE FACTORS

XP34:   CALL    TSTC            ;LOOK FOR /
        DB      '/'
        DW      CGROUP:XP42
        PUSH    BX              ;SAVE 1ST OPERAND
        CALL    EXPR4           ;EVALUATE 2ND OPERAND
        POP     AX              ;GET 1ST OPERAND
        CWD                     ;EXTEND IT
        IDIV    BX              ;AX= 1ST/2ND
        JMP     XP35            ;CONTINUE

;  ROUTINE 'EXPR4' EVALUATE SINGLE OPERANDS
;  BEWARE!!! EXPR4 CALLS EXPR IN SOME CASES. EXPRESSION EVALUATION IS RECURSIVE.

EXPR4:  MOV     DI,OFFSET(CGROUP:TAB4)
        JMP     EXEC            ;LOOK FOR BUILT-IN FUNCTIONS

XP40:   CALL    TSTV            ;LOOK FOR A VARIABLE
        JB      SHORT XP41      ;NOT FOUND
        MOV     BX,[BX]         ;GET VARIABLE CONTENTS
        RET

XP41:   CALL    TSTNUM          ;LOOK FOR A NUMBER
        OR      CH,CH           ;IS IT A NUMBER?
        JNZ     SHORT XP42              ;YES.

;  ROUTINE 'PARN' EVALUATE EXPRESSIONS IN PARENDS

PARN:   CALL    TSTC            ;LOOK FOR (
        DB      '('
        DW      CGROUP:QWHAT
        CALL    EXPR            ;EVALUATE THE EXPRESSION
        CALL    TSTC            ;LOOK FOR )
        DB      ')'
        DW      CGROUP:QWHAT
XP42:   RET

QHOW1:  JMP     QHOW

; RANDOM NUMBER BUILT-IN FUNCTION

RND:    CALL    PARN            ;EVALUATE THE OPERAND
        OR      BX,BX
        JS      QHOW1           ;MUST BE POSITIVE AND
        JZ      QHOW1           ;GREATER THAN 0
        MOV     DX,TIMHI
        IN      AL,DX
        AND     AL,3FH
        MOV     AH,AL
        DEC     DX
        IN      AL,DX
        MOV     DX,AX
        PUSH    BX
        MOV     BX,RANPNT
        CMP     BX,OFFSET(CGROUP:LSTROM)
        JB      SHORT RA1
        MOV     BX,OFFSET(CGROUP:START)
RA1:    MOV     AX,CS:[BX]
        INC     BX
        MOV     RANPNT,BX
        POP     BX
        MUL     DX
        MOV     AX,DX
        SUB     DX,DX           ;ZERO OUT THE DX REGISTER
        DIV     BX              ;GET THE MODULO VALUE
        MOV     BX,DX
        INC     BX
ARTN:   RET                     ;RETURN FROM BUILT IN FUNCTION

; ABSOLUTE VALUE BUILT-IN FUNCTION

ABS_:   CALL    PARN            ;EVALUATE THE OPERAND
        OR      BX,BX           ;SEE IF POSITIVE
        JNS     ARTN            ;IF >= 0 THEN ARTH
        NEG     BX              ;ELSE MAKE IT POSITIVE
        JNO     ARTN            ;AND RETURN IF NO OVERFLOW
        JMP     QHOW            ;ELSE PRINT ERROR.


;  ROUTINE TO GET SIZE OF @ ARRAY

SIZE_:  LEA     BX,DGROUP:TXTEND
        SUB     BX,TXTUNF
        RET

;******************************************************************
;
; *** SETVAL *** FIN *** ENDCHK *** ERROR (AND FRIENDS) ***
;
;******************************************************************

SETVAL: CALL    TSTV            ;LOOK FOR A VARIABLE
        JB      SHORT QWHAT
        PUSH    BX              ;SAVE VARIABLE ADDR
        CALL    TSTC            ;LOOK FOR =
        DB      '='
        DW      CGROUP:QWHAT
        CALL    EXPR            ;EVALUATE THE EXPRESSION
        MOV     AX,BX           ;PUT VALUE IN AX
        POP     BX
        MOV     [BX],AX         ;PUT VALUE IN VARIABLE
        RET

FIN:    CALL    TSTC            ;LOOK FOR ;
        DB      ';'
        DW      CGROUP:FI1
        POP     AX              ;CLEAR STACK
        JMP     RUNSML          ;RUN ON SAME LINE

FI1:    CALL    TSTC            ;LOOK FOR <CR>
        DB      CR
        DW      CGROUP:FI2
        POP     AX              ;CLEAR STACK
        JMP     RUNNXL          ;RUN NEXT LINE

FI2:    RET

ENDCHK: CALL    IGBLK           ;SKIP BLANKS
        CMP     AL,CR
        JZ      FI2

QWHAT:  PUSH    SI
AWHAT:  LEA     SI,WHAT
ERROR:  SUB     AL,AL
        CALL    PRTSTG          ;PRINT MESSAGE
        POP     SI
        MOV     AL,[SI]         ;GET NEXT CHAR IN LINE
        PUSH    AX              ;SAVE IT
        MOV     BYTE PTR [SI],0 ;REPLACE IT WITH NULL
        MOV     SI,CURRNT       ;GET LINE POINTER
        MOV     AX,[SI]         ;GET LINE NUMBER
        OR      AX,AX           ;TEST IT
        JZ      SHORT STAR2     ;IT'S 0. RE-START
        JNS     SHORT L_43
        JMP     INPERR          ;IT'S <0. INPUT ERROR
L_43:   CALL    PRTLN           ;PRINT THE LINE UP TO THE NULL
        DEC     SI
        POP     AX
        MOV     [SI],AL         ;REPLACE THE ORIGINAL CHAR
        MOV     AL,'?'
        CALL    OUTC            ;PRINT A ?
        SUB     AL,AL
        CALL    PRTSTG          ;PRINT THE REMAINDER OF THE LINE
STAR2:  JMP     START

QSORRY: PUSH    SI
ASORRY: LEA     SI,SORRY
        JMP     ERROR

;***************************************************************
;
; *** GETLN *** FNDLN (AND FRIENDS) ***
;
;***************************************************************

GETLN:  CALL    OUTC
GL0:    LEA     SI,BUFFER
GL1:    CALL    CI
GL2:    AND     AL,7FH
        CMP     AL,1AH                  ; CONTROL-Z
        JZ      STAR2
        CMP     AL,LF
        JZ      GL1
        CALL    OUTC
        OR      AL,AL
        JZ      GL1
        CMP     AL,7FH                  ;RUBOUT
        JZ      SHORT GL3
        CMP     AL,18H                  ; CONTROL-X
        JZ      SHORT GL4
        MOV     [SI],AL
        INC     SI
        CMP     AL,CR
        JZ      SHORT LRTN
        CMP     SI,OFFSET(DGROUP:BUFEND)
        JNZ     GL1

;  DO A RUBOUT

GL3:    CMP     SI,OFFSET(DGROUP:BUFFER)                ;AT START OF BUFFER?
        JZ      SHORT GL4               ;YES. JUST OUTPUT <CR><LF>
        DEC     SI
        MOV     AL,[SI]
        CALL    OUTC
        JMP     GL1

GL4:    CALL    CRLF
        JMP     GL0

LRTN:   RET

QHOW2:  JMP     QHOW

; FIND 1ST LINE WITH LINE # >= BX

FNDLN:  OR      BX,BX           ;MUST BE POSITIVE
        JS      QHOW2
        LEA     SI,DGROUP:TXTBGN        ;LOOK FROM START OF TEXT BUFFER

FNDLNP: LEA     AX,BUFEND
        INC     AX
        CMP     SI,AX           ;BELOW BUFEND?
        JB      LRTN            ;YES - MUST BE A DIRECT
        MOV     AX,TXTUNF
        DEC     AX
        CMP     AX,SI           ;PAST END OF TEXT BUFFER?
        JB      LRTN            ;YES. DONE
        CMP     [SI],BX         ;LINE#>= BX?
        JAE     LRTN            ;YES. DONE
FNDNXT: INC     SI
        INC     SI              ;POINT PAST LINE #
FNDSKP: MOV     DI,SI           ;SCAN FOR <CR>
        MOV     AL,CR
        MOV     CX,-1
        REPNZ   SCAS BYTE PTR ES:[DI]
        MOV     SI,DI
        JMP     FNDLNP

;*******************************************************************
;
; *** PRTSTG *** QTSTG *** PRTNUM *** PRTLN ***
;
;*******************************************************************

;  PRINT A STRING, PTR IN SI, DELIMITER IN AL

PRTSTG: MOV     CH,AL
PS1:    LODS    BYTE PTR ES:[SI]
        CMP     AL,CH
        JZ      SHORT L_48
        CALL    OUTC
        CMP     AL,CR
        JNZ     PS1
L_48:   RET

;  SCAN AND PRINT A QUOTED STRING

QTSTG:  CALL    TSTC            ;LOOK FOR "
        DB      '"'
        DW      CGROUP:QT3
        MOV     AL,'"'
QT1:    CALL    PRTSTG          ;PRINT STRING
        CMP     AL,CR           ;STRING TERMED BY <CR>?
        POP     BX
        JNZ     SHORT QT2
        JMP     RUNNXL          ;YES. RUN NEXT LINE
QT2:    INC     BX              ;NO. RETURN 2 BYTES PAST CALL

        INC     BX
        JMP     BX

QT3:    CALL    TSTC            ;LOOK FOR '
        DB      27H                     ; SINGLE QUOTE
        DW      CGROUP:QT4
        MOV     AL,27H
        JMP     QT1

QT4:    CALL    TSTC
        DB      5FH                     ; BACK-ARROW
        DW      CGROUP:LRTN
        MOV     AL,8DH                  ; YES, <CR> WITHOUT <LF>
        CALL    OUTC
        POP     BX
        JMP     QT2

; PRINT A NUMBER IN BX, FIELD WIDTH IN CH

PRTNUM: MOV     AX,BX           ;NUMBER IN AX
        MOV     BX,10           ;DIVISOR IN BX
        PUSH    BX              ;PUT MARKER ON STACK
        SUB     CH,CH           ;CLEAR SIGN
        OR      AX,AX           ;NEGATIVE NUMBER?
        JNS     SHORT PN1       ;NO.
        MOV     CH,'-'          ;YES.
        NEG     AX
        DEC     CL
PN1:    DEC     CL              ;COUNT OFF 1 SPACE
        CWD                     ;EXTEND AX INTO DX
        DIV     BX              ;DIVIDE
        OR      AX,AX           ;RESULT 0?
        JZ      SHORT PN3       ;YES. DONE DIVIDING
        PUSH    DX              ;NO. SAVE REMAINDER
        JMP     PN1

PN3:    OR      CL,CL           ;FIELD FULL?
PN4:    JLE     SHORT PN5       ;YES. GO ON
        MOV     AL,' '
        CALL    OUTC            ;PRINT LEADING BLANK
        DEC     CL              ;COUNT 1 MORE SPACE
        JMP     PN4

PN5:    MOV     AL,CH           ;PRINT SIGN
        CALL    OUTC
        MOV     AX,DX           ;PUT 1ST DIGIT IN AX

;  PRINT THE NUMBER. 1ST DIGIT IN AX, OTHERS ON STACK.

PN6:    ADD     AL,'0'          ;MAKE IT ASCII
        CALL    OUTC            ;PRINT THE DIGIT
        POP     AX              ;GET NEXT DIGIT
        CMP     AX,10           ;10 MARKS END OF DIGITS
        JNZ     PN6
        RET                     ;DONE

;  PRINT A LINE. SI=PTR

PRTLN:  MOV     BX,[SI]         ;GET LINE #
        PUSH    BX
        INC     SI
        INC     SI              ;POINT PAST LINE #
        MOV     CL,4
        CALL    PRTNUM          ;PRINT LINE #
        MOV     AL,' '
        CALL    OUTC            ;PRINT SPACE
        SUB     AL,AL
        CALL    PRTSTG          ;PRINT LINE
        POP     BX
        RET

;********************************************************************
;
; *** POPA *** PUSHA ***
;
;********************************************************************

POPA:   POP     BX              ;RETURN ADDR IN BX
        POP     LOPVAR          ;RESTORE LOPVAR
        CMP     LOPVAR,0
        JZ      SHORT PP1
        POP     LOPINC          ;RESTORE OTHER VARIABLES
        POP     LOPLMT
        POP     LOPLN
        POP     LOPPT
PP1:    PUSH    BX
        RET

QSORRQ: JMP     QSORRY

PUSHA:  CMP     SP,OFFSET(STKLMT)       ;STACK OVERFLOW?
        JBE     QSORRQ                  ;YES
        POP     CX                      ;RETURN ADDR IN CX
        MOV     BX,LOPVAR
        OR      BX,BX
        JZ      SHORT PU1
        PUSH    LOPPT                   ;NO. SAVE OTHER VARIABLES
        PUSH    LOPLN
        PUSH    LOPLMT
        PUSH    LOPINC
PU1:    PUSH    BX                      ;SAVE LOPVAR
        PUSH    CX
        RET

;*****************************************************************
;
; *** OUTC ***
;
;*****************************************************************

CRLF:   MOV     AL,CR

OUTC:   OR      AL,AL
        JZ      SHORT OC4       ;DON'T PRINT NULLS
        CALL    CO
OC4:    CMP     AL,CR           ;WAS IT A <CR> ?
        JZ      SHORT OCR
        RET

OCR:    MOV     AL,LF
        CALL    OUTC            ;OUTPUT A <LF>
        MOV     AL,CR
        RET

CODE ENDS
DATA SEGMENT    PUBLIC 'DATA'
COUNT DW ?
DATA ENDS
DATA4 SEGMENT   PUBLIC 'EXTRA'

ORG 10B0H
TXTBGN DB 24FH DUP (?)
TXTEND LABEL WORD

DATA4 ENDS

CODE SEGMENT WORD PUBLIC 'CODE'
INPORT EQU 0002H
PORTCNT EQU 00000H
INOUT EQU 001H
BITS EQU 7
OUTPT2 EQU 0F000H
INPRT2 EQU 0F001H
OUTDR  EQU 0F002H
INDR   EQU 0F003H
OUTPORT EQU 0001H
TIMHI  EQU 5

INIT:   MOV     ES,AX
        MOV     SS,AX
        MOV     DI,1000H
        MOV     CX,1FH
   REP  STOS    POLO
        MOV     STACKP,SP
        DEC     M1
        MOV     SI,1000H
        MOV     DI,1400H                ;AX = OFFSET FOR USER 2
        MOV     CX,1FH
        REP     MOVS    ZERO,ZERO
        MOV CGROUP:DZ0, OFFSET QHOW
        MOV CGROUP:DZS,CODE
        MOV CGROUP:TOO, OFFSET TIMOUT   ;INITIALIZE INTERRUPT
        MOV CGROUP:TOS,CODE
        MOV DX,PORTCNT
        MOV AL,INOUT
        OUT DX,AL
        MOV DX,OUTPORT
        MOV AL,0FFH
        OUT DX,AL
        MOV DX,INDR             ;SET UP USER 2'S I/O PORTS
        XOR AX,AX               ;ZERO OUT AX
        OUT DX,AL               ;OUTPUT 0 TO PORT CONTROL (INPUT)
        DEC DX
        MOV AL,0FFH             ;MAKE AL ALL ONES
        OUT DX,AL               ;OUTPUT 1 TO PORT CONTROL (OUTPUT)
        DEC DX
        DEC DX                  ;SET DX TO OUTPUT PORT
        OUT DX,AL               ;OUTPUT STOP BITS
        MOV AX,040H
        MOV SS,AX
        MOV SP,OFFSET(STK)
        MOV DS,AX
        MOV ES,AX
        XOR AX,AX
        MOV BX,AX
        MOV CX,AX
        MOV DX,AX
        MOV BP,AX
        MOV SI,AX
        MOV DI,AX
        PUSHF
        PUSH CS
        MOV AX,OFFSET(CGROUP:START)
        PUSH AX
        CALL SVREG
        MOV DX,TIMHI            ;SET TIMER COUNT AND MODE
        MOV AL,0CAH             ;TO MODE 4 (11) AND COUNT 02000H
        OUT DX,AL
        DEC DX
        MOV AL,0DAH             ;ZERO AL AND OUTPUT 0'S TO LOWER COIUNT
        OUT DX,AL
        XOR DX,DX               ;SET PORT CONTROL TO START COUNTING
        MOV AL,0C1H
        OUT DX,AL
        JMP START
CI:     MOV AL,2                        ;SAVE REGISTERS
        MOV INCYCL,0            ;RESET INPUT CYCLES
COMP:   MOV STATUS,AL           ;SET STATUS TO INPUT
        PUSHF                   ;SET UP STACK FOR IRET
        PUSH CS
        MOV AX,OFFSET(CGROUP:IORTI)
        PUSH AX
        CALL SVREG                      ;SAVE REGISTERS FOR NORMAL RETURN
        JMP USER?
IORTI:  JMP IORTI               ;LOOPS TO ITSELF UNTIL TIMEROUT
CIRT:   MOV AL,BYTEIN           ;RETURNS HERE WHEN CI HAS 7 BITS
        RET

CO:     PUSH AX                 ;SAVE REGISTERS
        OR AX,0F00H
        SAL AX,1                ;SHIFT LEFT TO SET UP START BIT
        MOV WORDOT,AX
        MOV OUTCYC,0            ;RESET OUTCYCLES
        MOV CONNT,0
        MOV AL,1                ;SET STATUS TO OUTPUT
        JMP COMP                ;SEE IF NEED TO GO TO ANOTHER USER
CORT:   POP AX
        RET
TIMOUT: CALL SVREG                      ;SAVE REGISTERS OF OLD
        MOV DX,INPORT           ;HAS NOT BEEN CHANGED)
        IN AL,DX
        MOV AH,AL
        MOV DX,INPRT2
        IN AL,DX
        PUSH AX
        MOV CX,AX               ;INPUT DATA, SAVE IN CX
        MOV DX,OUTPORT
        CALL OUTWORD            ;OUTPUT BIT FOR USER 1
        MOV STACKP,SP
        MOV DX,OUTPT2
        MOV AX,00040H
        MOV SS,AX               ;SET STACK SEGMENT TO USER 2
        MOV ES,AX
        MOV DS,AX
        MOV SP,STACKP
        CALL OUTWORD            ;OUTPUT WORD FOR USER 2
        MOV DX,INPRT2
        CALL INBYTE             ;INPUT BIT FOR USER 2
        POP CX
        MOV CL,CH               ;RESTORE PORT 1'S BYTE
        MOV DX,INPORT
        CALL INBYTE
USER?:  MOV AL,STATUS           ;CHECK USER 1 STATUS
        AND AL,03H
        JZ CKU2         ;USER 1 NOT IN CO OR CI, CHECK USER 2
        MOV AX,00040H           ;USER 1 IN CO OR CI, SET SEGMENTS
        JMP PRET1
CKU2:   MOV AL,STATS2           ;CHECK USER 2 STATUS
        AND AL,03H
        JZ  SWUS
        XOR AX,AX
        JMP PRET1               ;USER 2 ALSO NOT IN CO, CI; SWITCH USERS
SWUS:   MOV AX,CS:STACKS        ;SWITCH USERS:  GET STACK SEGMENT
        XOR AX,0040H
PRET1:  MOV SS,AX
        MOV DS,AX
        MOV SP,STACKP
        POP DS
        POP ES
        POP BP
        POP DI
        POP SI
        POP DX
        POP CX
        POP BX
        POP AX
        IRET
OUTWORD: MOV AL,CONNT           ;ONLY OUTPUT EVERY 3RD CYCLE
        AND     AL,03H
        JNZ     OUT1            ;NOT ON THIS CYCLE
        MOV AX,WORDOT   ;LOAD WORD OUT
        MOV BL,STATUS           ;LOAD STATUS BYTE
        OR BL,0FEH
        NOT BL
        OR AL,BL                        ;LOW ORDER BIT IS STOP BIT
        OUT DX,AL                       ;IF NOT IN CO ROUTINE
        SAR AX,1
        MOV WORDOT,AX
OUT1:   INC     CONNT           ;INCREMENT COUNT
        CMP     CONNT,3
        JNE     OTRT
        MOV     CONNT,0         ;RESET COUNT IF GREATER THAN 3
OTRT:   RET
INBYTE: MOV BL,STATUS
        MOV BH,BL
        AND BL,01H
        JZ CKIN
        CMP CONNT,0
        JNZ BRET
        INC OUTCYC
        CMP OUTCYC,10
        JNE BRET
        MOV STATUS,00H
        MOV BX,OFFSET(CGROUP:CORT)
RSST:   MOV STACKP,SP
        ADD SP,22
        PUSH BX
        MOV SP,STACKP
BRET:   POP CX
        MOV STACKP,SP
        XOR AX,AX
        MOV SS,AX
        MOV DS,AX
        MOV ES,AX
        MOV SP,STACKP
        PUSH CX
        RET
CKIN:   MOV     BL,BH           ;SEE IF IN INPUT MODE
        AND     BL,02H
        JZ      BRET            ;NO, NOT IN INPUT MODE
        AND     BH,04H          ;SEE IF STILL WAITING FOR START BIT
        JZ      WAITST          ;YES, STILL WAITING
        AND     CL,80H
        JZ      CK1             ;IF BIT-IN IS A 0, SHIFT LEFT
        ROR     BITSS,1         ;ELSE SHIFT BYTE RIGHT
        JMP     CK2
CK1:    ROL     BITSS,1
CK2:    IN      AL,DX
        AND     AL,80H
        JZ      CK3
        ROR     BITSS,1
        JMP     CK4
CK3:    ROL     BITSS,1
CK4:    INC     CONNT           ;UP COUNT BY 1
        CMP     CONNT,3
        JNZ     BRET            ;IF NOT THIRD COUNT, WAIT FOR  MORE
        MOV     CONNT,0         ;ELSE RESET CONNT
        MOV     AX,BITSS        ;BRING IN VOTE
        MOV     BITSS,00FFH     ;RESET VOTE COUNTER
        AND     AH,80H
        SHR     BYTEIN,1        ;MAKE ROOM FOR NEXT BIT
        OR      BYTEIN,AH       ;OR ON NEXT BIT (MAJORITY RULE)
        INC     INCYCL          ;ALL BITS IN?
        CMP     INCYCL,9
        JNE     BRET            ;IF NOT, WAIT FOR MORE
        MOV     INCYCL,0        ;ELSE RESET INCYCLE
        AND     BYTEIN,7FH      ;PREPARE BYTE IN FOR RETURN TO PROGRAM
        MOV     STATUS,0        ;RESET STATUS
        MOV     BX,OFFSET(CGROUP:CIRT)  ;SET BX TO RETURN LOCATION
        JMP     RSST
WAITST: AND     CL,80H          ;SEE IF THIS IS A START BIT
        JZ      SETST           ;THIS DONE BECAUSE OF RELATIVE JUMP LIMITS
        JMP     BRET            ;NOT YET
SETST:  MOV     STATUS,6        ;ELSE SET STATUS TO INPUT MODE, START RECEIVED
        MOV     CONNT,1         ;SET COUNT AS IF 0 HAS BEEN ENTERED (IT HAS)
        MOV     BITSS,01FEH     ;SET BITS FOR 1 0 RECEIVED
        JMP     BRET
SVREG:  MOV BL1,BX
        POP BX
        PUSH AX
        PUSH BL1
        PUSH CX
        PUSH DX
        PUSH SI
        PUSH DI
        PUSH BP
        PUSH ES
        PUSH DS
        MOV STACKP,SP
        MOV CX,SS
        XOR AX,AX
        MOV SS,AX
        MOV ES,AX
        MOV DS,AX
        MOV SP,STACKP
        MOV CS:STACKS,CX
        PUSH BX
        RET
LSTROM  LABEL BYTE
CODE ENDS
CONST2 SEGMENT
ORG 0FFF0H
        MOV AX,DGROUP
        MOV DS,AX
        MOV SP,OFFSET(STK)
DB      0EAH   ;   BOOTSTRAP
DW OFFSET INIT
DW 0
CONST2 ENDS

DATA    SEGMENT WORD PUBLIC 'DATA'
ORG 1000H
BL1     DW      ?
BL2     DW      ?
ZERO    DW      0
M1      DW      -1
POLO    DB      0
RICI    DB      0
CURRNT  DW      0
Z       DB      0
STKGOS  DW      0
VARNXT  LABEL   WORD
STKINP  DW      0
LOPVAR  DW      0
LOPINC  DW      0
LOPLMT  DW      0
LOPLN   DW      0
LOPPT   DW      0
RANPNT  DW      CGROUP:START
TXTUNF  DW      DGROUP:TXTBGN

DATA    ENDS

DATA2   SEGMENT WORD 'DATA'
        ORG 01020H

VARBGN  DB      2*26 DUP (?)
        DB      1 DUP (?)
BUFFER  DB      80 DUP (?)
BUFEND  LABEL   BYTE
BITSS   DW      ?
STACKP  DW      ?
INCYCL  DB      ?
OUTCYC  DB      ?
WORDOT  DW      ?
BYTEIN  DB      ?
STATUS  DB      ?
CONNT   DB      ?
        ORG 14AEH
STATS2  DB      ?
DATA2   ENDS

STACK   SEGMENT WORD STACK 'STACK'
        ORG 01300H
STKLMT  LABEL   BYTE
        DB      0FFH DUP (?)
STK     LABEL   WORD

STACK   ENDS
END     INIT
CGROUP  GROUP   ABS_0,MEMORY,DATA,DATA2,STACK,DATA4,CODE,CONST,CONST2
DGROUP  GROUP   ABS_0,MEMORY,DATA,DATA2,STACK,DATA4,CODE,CONST,CONST2
        ASSUME  CS:CGROUP,DS:DGROUP,ES:DGROUP,SS:STACK
CODE    SEGMENT WORD PUBLIC 'CODE'
CODE    ENDS
CONST   SEGMENT WORD PUBLIC 'CONST'
CONST   ENDS
DATA    SEGMENT WORD PUBLIC 'DATA'
DATA    ENDS
DATA2   SEGMENT WORD PUBLIC 'DATA'
DATA2   ENDS
ABS_0   SEGMENT AT 0
DZ0 DW ?
DZS DW ?
ABS_0   ENDS

        PUBLIC  START

CODE    SEGMENT WORD PUBLIC 'CODE'


;********************************************************
;
;         TINY BASIC FOR THE 8086
;                VERSION 1.0
;                 @COPYLEFT
;            ALL WRONGS RESERVED
;
;********************************************************

CR      EQU     0DH
LF      EQU     0AH

FEND:   POP     AX              ;THROW AWAY RETURN ADDRESS
        CALL    FIN             ;LOOK FOR END OF LINE
        JMP     QWHAT           ;ERROR IF NOT END OF LINE

TSTC:   CALL    IGBLK           ;SKIP BLANKS
        POP     BP                      ;BP= RETURN ADDR
        MOV     AL,CS:[BP]              ;GET BYTE AFTER CALL
        CMP     AL,[SI]                 ;COMPARE TO NEXT BYTE OF TEXT
        JZ      SHORT TC2               ;YES.
        INC     BP                      ;NO. POINT TO NEXT BYTE
        MOV     BP,CS:[BP]              ;GET JUMP ADDRESS
        JMP     BP

TC2:    INC     SI                      ;POINT TO NEXT CHAR
        ADD     BP,3                    ;RETURN AFTER TSTC CALL
        JMP     BP

; IGBLK- SKIP BLANKS
;    RETURNS 1ST NON-BLANK CHAR IN AL
IGBLK:  MOV     AL,[SI]
        INC     SI
        CMP     AL,' '
        JZ      IGBLK
        DEC     SI
        RET

; TSTV- TEST FOR A VARIABLE
;   RETURNS: BX= ADDR OF VARIABLE
;               C FLAG SET-> VARIABLE NOT FOUND
TSTV:   CALL    IGBLK           ;SKIP BLANKS
        INC     SI              ;POINT TO NEXT CHAR
        SUB     AL,'@'          ;@ ARRAY?
        JZ      SHORT ATARY     ;YES
        JA      TV1             ;NO. VARIABLE NAME
R0:     DEC     SI
        RET                     ;NO. ILLEGAL CHAR
ATARY:  CALL    PARN            ;EVALUATE ARRAY INDEX
        ADD     BX,BX           ;INDEX TOO BIG?
        JB      QHOW            ;YES. ERROR
        LEA     AX,DGROUP:TXTEND        ;ADDR OF ARRAY ELEMENT=
        SUB     AX,BX           ;TXTEND- 2*(ARRAY INDEX)
        CMP     AX,TXTUNF       ;ADDR< END OF TEXT?
        JB      QSORRX          ;YES. ERROR
        MOV     BX,AX           ;BX= ADDR OF @(EXPR)
        RET

TV1:    CMP     AL,27           ;CHAR<= Z ?
        CMC
        JB      R0              ;NO. RETURN
        LEA     BX,VARBGN
        CBW
        ADD     BX,AX
        ADD     BX,AX           ;BX= VARIBLE ADDR= VARBGN + 2*(CHAR-A)
R1:     RET

; TSTNUM- LOOK FOR A (DECIMAL) NUMBER
;    RETURNS:   BX= NUMBER
;               CH= # OF DIGITS
TSTNUM: CALL    IGBLK           ;SKIP BLANKS
        MOV     BX,0            ;INIT NUMBER
        MOV     CH,BH           ;INIT COUNT
TN1:    SUB     AL,'0'
        JB      R1              ;NOT A VALID DIGIT
        CMP     AL,9
        JA      R1              ;NOT A VALID DIGIT
        CMP     BH,0F0H         ;NUMBER IS TOO BIG?
        JAE     QHOW            ;YES. ERROR
        INC     CH              ;COUNT 1 MORE DIGIT
        MOV     DX,BX
        ADD     BX,BX
        ADD     BX,BX
        ADD     BX,DX
        ADD     BX,BX           ;BX= 10*BX
        AND     AX,0FH
        ADD     BX,AX           ;ADD NEW DIGIT
        INC     SI
        MOV     AL,[SI]         ;GET NEXT CHAR
        JMP     TN1

QSORRX: JMP     QSORRY

QHOW:   PUSH    SI
AHOW:   LEA     SI,HOW
        JMP     ERROR

;****************************************************************
;
; *** MAIN ***
;
; THIS IS THE MAIN LOOP THAT COLLECTS THE TINY BASIC PROGRAM
; AND STORES IT IN MEMORY.
;
; AT 'START', IT PRINTS OUT "<CR>OK<CR><LF>", AND INITIALIZES
; THE STACK AND OTHER INTERNAL VARIABLES.  IT THEN PROMPTS
; ">" AND READS A LINE.  IF THE LINE STARTS WITH A NON-ZERO NUMBER,
; IT REPRESENTS A LINE NUMBER.  THE LINE NUMBER (16-BIT BINARY)
; AND THE REST OF THE LINE (INCLUDING <CR>) IS STORED IN MEMORY.
; IF A LINE WITH THE SAME LINE NUMBER IS ALREADY THERE, IT IS
; REPLACED BY THE NEW ONE.  IF THE REST OF THE LINE CONSISTS
; IF  A <CR> ONLY, IT IS NOT STORED AND ANY EXISTING LINE
; WITH THE SAME LINE NUMBER IS DELETED.
;
; AFTER A LINE IS INSERTED, REPLACED OR DELETED, THE PROGRAM
; LOOPS BACK AND ASKS FOR ANOTHER LINE.  THIS LOOP WILL BE
; TERMINATED WHEN IT READS A LINE WITH ZERO OR NO LINE NUMBER AND
; CONTROL IS THEN PASSED TO 'DIRECT'.
;
; THE PROGRAM SAVE AREA STARTS AT 'TXTBGN' AND ENDS AT 'TXTEND'.  WE
; ALWAYS FILL THIS AREA STARTING AT 'TXTBGN'.  THE UNFILLED PORTION
; IS POINTED TO BY THE CONTENTS OF 'TXTUNF'.
;
; MEMORY LOCATION 'CURRNT' POINTS TO THE LINE NUMBER THAT IS
; CURRENTLY BEING INTERPRETED.  WHILE WE ARE IN THIS LOOP OR
; WHILE WE ARE INTERPRETING A DIRECT COMMAND (SEE NEXT SECTION),
; 'CURRNT' SHOULD POINT TO A ZERO.
;
;*******************************************************************

START:  MOV     SP,OFFSET(STK)
        MOV     POLO,0          ;INIT VARIABLES
        MOV     RICI,0
ST1:    CALL    CRLF            ;OUTPUT <CR><LF>
        LEA     SI,OK
        SUB     AL,AL
        CALL    PRTSTG          ;OUTPUT OK MESSAGE
        LEA     AX,ZERO
        MOV     CURRNT,AX       ;INIT LINE #
ST2:    MOV     AX,0
        MOV     LOPVAR,AX
        MOV     STKGOS,AX       ;INIT LOOP VALUES
ST3:    MOV     AL,'>'
        CALL    GETLN           ;GET A LINE
        PUSH    SI              ;SAVE POINTER TO EMPTY BUFFER
        LEA     SI,BUFFER       ;POINT TO BUFFER START
        CALL    TSTNUM          ;GET LINE NUMBER
        CALL    IGBLK           ;SKIP BLANKS
        OR      BX,BX           ;SET FLAGS
        POP     CX              ;CX= END OF LINE
        JNZ     SHORT STCONT    ;LINE NUMBER EXISTS?
        CMP     RICI,0          ;NO.  FLAG SET?
        JZ      DIRECT          ;NO. DO DIRECT CALL
        RET                     ;YES. JUST RETURN

STCONT: DEC     SI              ;NOT A DIRECT CALL
        DEC     SI
        MOV     [SI],BX         ;PUT LINE # BEFORE LINE
        PUSH    CX              ;END OF LINE ON STACK
        PUSH    SI              ;START OF LINE ON STACK
        SUB     CX,SI
        PUSH    CX              ;LENGTH ON STACK
        CALL    FNDLN           ;GET POINTER TO TEXT AREA
        PUSH    SI              ;SAVE IT ON STACK
        JNZ     SHORT ST4       ;LINE ALREADY EXISTS?
                        ;YES. WIPE OUT OLD LINE
        CALL    FNDNXT          ;GET POINTER TO NEXT LINE
        POP     DI
        PUSH    DI
        MOV     CX,TXTUNF
        SUB     CX,SI           ;CX=COUNT
        REP     MOVS BYTE PTR ES:[DI],BYTE PTR [SI]
        MOV     TXTUNF,DI

; CREATE SPACE IN BUFFER AND MOVE NEW LINE INTO SPACE

ST4:    POP     BX              ;BX= POINTER INTO TEXT AREA
        MOV     SI,TXTUNF
        MOV     CX,SI
        SUB     CX,BX           ;CX= COUNT
        POP     DI              ;DI= LEN
        ADD     DI,SI           ;DEST= SOURCE+LEN
        DEC     SI              ;SOURCE= LAST CHAR IN BUFFER
        CMP     DI,OFFSET(DGROUP:TXTEND)        ;ENOUGH SPACE?
        JAE     QSORRZ          ;NO. ERROR
        MOV     TXTUNF,DI       ;SET NEW END OF TEXT
        DEC     DI
        JCXZ    ST5
        STD
        REP     MOVS BYTE PTR ES:[DI],BYTE PTR [SI]     ;MAKE SPACE
        CLD
ST5:    MOV     DI,SI
        INC     DI              ;DEST= CLEARED SPACE
        POP     SI              ;SOURCE= START OF NEW LINE
        POP     CX              ;CX= END OF NEW LINE
        SUB     CX,SI           ;COUNT= LEN OF NEW LINE
        REP     MOVS BYTE PTR ES:[DI],BYTE PTR [SI]     ;MOVE NEW LINE
        JMP     ST3

QSORRZ: JMP     QSORRY

;******************************************************************
;
; *** TABLES *** DIRECT *** & EXEC ***
;
; THIS SECTION OF THE CODE TESTS A STRING AGAINST A TABLE.
; WHEN A MATCH IS FOUND, CONTROL IS TRANSFERRED TO THE SECTION
; OF CODE ACCORDING TO THE TABLE.
;
; AT 'EXEC', D-E SHOULD POINT TO THE STRING AND H-L SHOULD POINT
; TO THE TABLE.  AT 'DIRECT', D-E SHOULD POINT TO THE STRING,
; H-L WILL BE SET UP TO POINT TO TAB1-1, WHICH IS THE TABLE OF
; ALL DIRECT AND STATEMENT COMMANDS.
;
; A '.' IN THE STRING WILL TERMINATE THE TEST AND THE PARTIAL
; MATCH WILL BE CONSIDERED AS A MATCH.  (E.G.  'P.', 'PR.',
; 'PRI.', 'PRIN.' OR 'PRINT' WILL ALL MATCH 'PRINT'.
;
; THE TABLE CONSISTS OF ANY NUMBER OF ITEMS.  EACH ITEM
; IS A STRING OF CHARACTERS WITH BIT 7 SET TO 0 AND
; A JUMP ADDRESS STORED HIGH-LOW WITH BIT 7 OF THE HIGH
; ORDER BYTE SET TO 1.
;
; END OF TABLE IS AN ITEM WITH A JUMP ADDRESS ONLY.  IF THE
; STRING DOES NOT MATCH ANY OF THE OTHER ITEMS, IT WILL
; MATCH THIS NULL ITEM AS DEFAULT.
;
;********************************************************************

CONST   SEGMENT WORD PUBLIC 'CONST'

TAB1    DB      'LIST'
        DB      HIGH(CGROUP:LIST) ,LOW(CGROUP:LIST)
        DB      'RUN'
        DB      HIGH(CGROUP:RUN),LOW(CGROUP:RUN)
        DB      'NEW'
        DB      HIGH(CGROUP:NEW),LOW(CGROUP:NEW)

TAB2    DB      'NEXT'
        DB      HIGH(CGROUP:NEXT),LOW(CGROUP:NEXT)
        DB      'LET'
        DB      HIGH(CGROUP:LET),LOW(CGROUP:LET)
        DB      'IF'
        DB      HIGH(CGROUP:IFF),LOW(CGROUP:IFF)
        DB      'GOTO'
        DB      HIGH(CGROUP:GOTO),LOW(CGROUP:GOTO)
        DB      'GOSUB'
        DB      HIGH(CGROUP:GOSUB),LOW(CGROUP:GOSUB)
        DB      'RETURN'
        DB      HIGH(CGROUP:RETURN),LOW(CGROUP:RETURN)
        DB      'REM'
        DB      HIGH(CGROUP:REM),LOW(CGROUP:REM)
        DB      'FOR'
        DB      HIGH(CGROUP:FOR),LOW(CGROUP:FOR)
        DB      'INPUT'
        DB      HIGH(CGROUP:INPUT),LOW(CGROUP:INPUT)
        DB      'PRINT'
        DB      HIGH(CGROUP:PRINT),LOW(CGROUP:PRINT)
        DB      'STOP'
        DB      HIGH(CGROUP:STOP),LOW(CGROUP:STOP)
        DB      HIGH(CGROUP:DEFLT),LOW(CGROUP:DEFLT)

;       DB      'YOU MAY INSERT MORE COMMANDS.'

TAB4    DB      'RND'
        DB      HIGH(CGROUP:RND),LOW(CGROUP:RND)
        DB      'ABS'
        DB      HIGH(CGROUP:ABS_),LOW(CGROUP:ABS_)
        DB      'SIZE'
        DB      HIGH(CGROUP:SIZE_),LOW(CGROUP:SIZE_)
;       DB      'INSERT OTHER FUNCTIONS HERE'
        DB      HIGH(CGROUP:XP40),LOW(CGROUP:XP40)


TAB5    DB      'TO'
        DB      HIGH(CGROUP:FR1),LOW(CGROUP:FR1)
        DB      HIGH(CGROUP:QWHAT),LOW(CGROUP:QWHAT)

TAB6    DB      'STEP'
        DB      HIGH(CGROUP:FR2),LOW(CGROUP:FR2)
        DB      HIGH(CGROUP:FR3),LOW(CGROUP:FR3)

TAB8    DB      '>='
        DB      HIGH(CGROUP:XP11),LOW(CGROUP:XP11)
        DB      '#'
        DB      HIGH(CGROUP:XP12),LOW(CGROUP:XP12)
        DB      '>'
        DB      HIGH(CGROUP:XP13),LOW(CGROUP:XP13)
        DB      '='
        DB      HIGH(CGROUP:XP15),LOW(CGROUP:XP15)
        DB      '<='
        DB      HIGH(CGROUP:XP14),LOW(CGROUP:XP14)
        DB      '<'
        DB      HIGH(CGROUP:XP16),LOW(CGROUP:XP16)
        DB      HIGH(CGROUP:XP17),LOW(CGROUP:XP17)
CONST   ENDS

DIRECT: MOV     DI,OFFSET(DGROUP:TAB1)
EXEC:   CALL    IGBLK           ;SKIP BLANKS
        PUSH    CX              ;SAVE CX
EX0:    PUSH    SI              ;SAVE POINTER
        MOV     CL,0FFH
EX1:    REPZ    CMPS BYTE PTR [SI],BYTE PTR ES:[DI]
        MOV     AL,7FH
        CMP     BYTE PTR [SI-1],'.'     ;PERIOD?
        JZ      EX3             ;YES. MATCH
        DEC     SI                      ;POINT AT 1ST UNMATCHED BYTE
        CMP     AL,[DI-1]
        JB      EX5             ;JMP ADDRESS?
EX2:    SCAS    BYTE PTR ES:[DI]        ;NO. SCAN FOR IT
        JAE     EX2
        INC     DI              ;POINT PAST IT
        POP     SI              ;
        JMP     EX0             ;TRY NEXT TABLE ENTRY

EX3:    SCAS    BYTE PTR ES:[DI]        ;SCAN FOR JUMP ADDR
        JAE     EX3
EX5:    DEC     DI              ;POINT TO 1ST BYTE OF JUMP ADDR
        MOV     BX,[DI]
        XCHG    BH,BL
                ;LOCATION OF AND BH,AL IF RUNNING IN LOW ROM
        POP     AX              ;CLEAR STACK
        POP     CX              ;RESTORE CX
        JMP     BX              ;JMP TO DIRECT ROUTINE

;*****************************************************************
;
; WHAT FOLLOWS IS THE CODE TO EXECUTE DIRECT AND STATEMENT
; COMMANDS.  CONTROL IS TRANSFERED TO THESE POINTS VIA THE
; COMMAND TABLE LOOKUP CODE OF 'DIRECT' AND 'EXEC' IN THE
; LAST SECTION.  AFTER THE COMMAND IS EXECUTED, CONTROL IS
; TRANSFERED TO OTHER SECTIONS AS FOLLOWS:
;
; FOR 'LIST', 'NEW' AND 'STOP':  GO BACK TO 'START'
; FOR 'RUN':  GO EXECUTE THE FIRST STORED LINE IF ANY, ELSE
; GO BACK TO 'START'.
; FOR 'GOTO' AND 'GOSUB':  GO EXECUTE THE TARGET LINE.
; FOR 'RETURN' AND 'NEXT':  GO BACK TO SAVED RETURN LINE.
; FOR ALL OTHERS:  IF 'CURRNT' IS 0, GO TO 'START', ELSE
; GO EXECUTE NEXT COMMAND.  (THIS IS DONE IN 'FINISH'.)
;
;******************************************************************
;
; *** NEW *** STOP *** RUN  (AND FRIENDS) *** GOTO ***
;
; 'NEW<CR>' SETS 'TXTUNF' TO POINT TO 'TXTBGN'.
;
; 'STOP<CR>' GOES BACK TO 'START'.
;
; 'RUN<CR>' FINDS THE FIRST STORED LINE, STORES ITS ADDRESS
; (IN 'CURRNT') AND EXECUTES IT.  NOTE THAT ONLY THOSE
; COMMANDS IN TAB2 ARE LEGAL FOR STORED PROGRAMS.
;
; THERE ARE THREE MORE ENTRIES IN 'RUN':
;
; 'RUNNXL' FINDS NEXT LINE, STORES ITS ADDRESS AND EXECUTES IT.
; 'RUNTSL' STORES THE ADDRESS OF THIS LINE AND EXECUTES IT.
; 'RUNSML' CONTINUES THE EXECUTION ON THE SAME LINE.
;
; 'GOTO <EXPR>' EVALUATES THE EXPRESSION, FINDS THE TARGET
; LINE AND JUMPS TO 'RUNTSL' TO DO IT.
;
;******************************************************************


NEW:    CALL    ENDCHK
        LEA     AX,DGROUP:TXTBGN
        MOV     TXTUNF,AX               ;RESET FREE SPACE POINTER

STOP:   CALL    ENDCHK
STAR1:  JMP     START

RUN:    CALL    ENDCHK
        LEA     SI,DGROUP:TXTBGN

RUNNXL: MOV     BX,0
        CALL    FNDLNP
        JB      STAR1

RUNTSL: MOV     CURRNT,SI               ;SAVE PTR TO RUNNING LINE
        INC     SI
        INC     SI                      ;SKIP LINE #

RUNSML: MOV     DI,OFFSET(DGROUP:TAB2)
        JMP     EXEC

GOTO:   CALL    EXPR                    ;EVALUATE THE EXPRESSION
        PUSH    SI                      ;SAVE THE PTR
        CALL    ENDCHK
        CALL    FNDLN                   ;FIND LINE <EXPR>
        JNZ     AHOW1           ;LINE DOESN'T EXIST
        POP     AX
        JMP     RUNTSL

AHOW1:  JMP     AHOW

;******************************************************************
;
; *** LIST *** PRINT ***
;
; LIST HAS TWO FORMS:
;
; 'LIST<CR>' LISTS ALL SAVED LINES.
; 'LIST #<CR>' STARTS LISTING AT LINE '#'.
; CONTROL/C STOPS THE LISTING.
;
; PRINT COMMAND IS 'PRINT....:' OR 'PRINT....<CR>'
; WHERE '....' IS A LIST OF EXPRESSIONS, FORMATS,
; BACKARROWS AND/OR STRINGS.  THESE ITEMS ARE SEPARATED
; BY COMMAS.
;
; A FORMAT IS A POUND SIGN (#) FOLLOWED BY A NUMBER.  IT CONTROLS
; THE NUMBER OF SPACES THE VALUE OF AN EXPRESSION IS GOING TO
; BE PRINTED IN.  IT STAYS EFFECTIVE FOR THE REST OF THE PRINT
; COMMAND UNLESS CHANGED BY ANOTHER FORMAT.  IF NO FORMAT IS
; SPECIFIED, 6 POSITIONS WILL BE USED.
;
; A STRING IS QUOTED IN A PAIR OF SINGLE QUOTES OR A PAIR OF
; DOUBLE QUOTES.
;
; A BACKARROW MEANS GENERATE A <CR> WITHOUT <LF>
;
; A <CR><LF> IS GENERATED AFTER THE ENTIRE LIST HAS BEEN
; PRINTED OR IF THE LIST IS A NULL LIST.  HOWEVER, IF THE LIST
; ENDED WITH A COMMA, NO <CR><LF> IS GENERATED.
;
;************************************************************************


LIST:   CALL    TSTNUM          ;LINE # ?
        CALL    ENDCHK
        CALL    FNDLN           ;FIND LINE
LS1:    JB      STAR1           ;LINE FOUND?
        CALL    PRTLN           ;YES. PRINT IT
        CALL    FNDLNP          ;FIND NEXT LINE
        JMP     LS1

PRINT:  MOV     CL,6            ;DEFAULT FIELD WIDTH=6
        CALL    TSTC            ;IS IT A ; ?
        DB      ';'
        DW      CGROUP:PR2
        CALL    CRLF            ;YES. JUST OUTPUT <CR><LF>
        JMP     RUNSML

PR2:    CALL    TSTC            ;IS IT A <CR> ?
        DB      CR
        DW      CGROUP:PR0
        CALL    CRLF            ;YES. JUST OUTPUT <CR><LF>
        JMP     RUNNXL

PR0:    CALL    TSTC            ;IS IT A #  ?
        DB      '#'
        DW      CGROUP:PR1
        CALL    EXPR            ;YES. EVALUATE EXPRESSION
        MOV     CL,BL           ;SET FIELD WIDTH
        JMP     SHORT PR3       ;CONTINUE

PR1:    CALL    QTSTG           ;LOOK FOR QUOTED STRING
        JMP     SHORT PR8

PR3:    CALL    TSTC            ;IS THERE A , ?
        DB      ','
        DW      CGROUP:PR6
        CALL    FIN             ;YES. LOOK FOR END OF LINE
        JMP     PR0             ;KEEP ON PRINTIN'

PR6:    CALL    CRLF            ;OUTPUT <CR><LF>
        CALL    FEND            ;MUST BE END OF LINE

PR8:    CALL    EXPR            ;EVALUATE <EXPR>
        PUSH    CX              ;SAVE FIELD WIDTH
        CALL    PRTNUM          ;PRINT THE FIELD
        POP     CX              ;RESTORE FIELD WIDTH
        JMP     PR3             ;LOOK FOR ANOTHER FIELD

;***************************************************************
;
; *** GOSUB *** RETURN ***
;
; 'GOSUB <EXPR>;' OR 'GOSUB <CR>' IS LIKE THE 'GOTO'
; COMMAND, EXCEPT THAT THE CURRENT TEXT POINTER, STACK
; POINTER, ETC. ARE SAVED SO THAT EXECUTION CAN BE
; CONTINUED AFTER THE SUBROUTINE 'RETURN'.  IN ORDER THAT
; 'GOSUB' CAN BE NESTED (AND EVEN RECURSIVE), THE SAVE AREA
; MUST BE STACKED.  THE STACK POINTER IS SAVED IN 'STKGOS'.
; THE OLD 'STKGOS' IS SAVED IN THE STACK.  IF WE ARE IN THE
; MAIN ROUTINE, 'STKGOS' IS ZERO (DONE IN MAIN CODE SECTION),
; BUT WE STILL SAVE IT AS A FLAG FOR NO FURTHER 'RETURN'S.
;
; 'RETURN<CR>' UNDOES EVERYTHING THAT 'GOSUB' DID, AND THUS
; RETURNS CONTROL TO THE COMMAND AFTER THE MOST RECENT
; 'GOSUB'.  IF 'STKGOS' IS ZERO, IT INDICATES THAT WE NEVER
; HAD A 'GOSUB' AND IS AN ERROR CONDITION.
;
;*****************************************************************

GOSUB:  CALL    PUSHA           ;SAVE CURRENT STATE
        CALL    EXPR            ;EVALUATE <EXPR>
        PUSH    SI              ;SAVE TEXT POINTER
        CALL    FNDLN           ;FIND LINE
        JNZ     AHOW1           ;LINE DOESN'T EXIST (ERROR)
        PUSH    CURRNT          ;SAVE VARIABLES
        PUSH    STKGOS
        MOV     STKGOS,SP       ;SET GOSUB FRAME POINTER
        MOV     LOPVAR,0        ;CLEAR LOOP VARIABLE
        JMP     RUNTSL          ;CONTINUE

RETURN: CALL    ENDCHK
        MOV     AX,STKGOS
        OR      AX,AX           ;IS THERE A FRAME SAVED?
        JZ      QWHAX           ;NO. ERROR
        MOV     SP,AX           ;SET STACK POINTER
        POP     STKGOS          ;RESTORE VARIABLES
        POP     CURRNT
        POP     SI              ;RESTORE TEXT POINTER
        CALL    POPA            ;RESTORE STATE
        CALL    FEND

;***************************************************************
;
; *** FOR *** NEXT ***
;
; 'FOR' HAS TWO FORMS:
;
; 'FOR VAR=EXP1 TO EXP2 STEP EXP3' AND 'FOR VAR=EXP1 TO EXP2'
;
; THE SECOND FORM MEANS THE SAME THING AS THE FIRST FORM WITH
; EXP1=1.  (I.E. WITH A STEP OF +1)
;
; BASIC WILL FIND THE VARIABLE 'VAR' AND SET ITS VALUE TO THE
; CURRENT VALUE OF EXP1.  IT ALSO EVALUATES EXP2 AND EXP1 AND
; SAVES THEM TOGETHER WITH THE TEXT POINTER ETC. IN THE
; 'FOR' SAVE AREA WHICH CONSISTS OF 'LOPVAR', 'LOPINC',
; 'LOPLMT', 'LOPLN' AND 'LOPPT'.  IF THERE IS ALREADY
; SOMETHING IN THE SAVE AREA (INDICATED BY NON-ZERO 'LOPVAR'),
; THE OLD SAVE AREA IS SAVED IN THE STACK BEFORE THE NEW ONE
; OVERWRITES IT.
;
; BASIC THEN DIGS IN THE STACK TO FIND OUT IF THIS SAME
; VARIABLE WAS USED IN ANOTHER CURRENTLY ACTIVE 'FOR' LOOP.
; IF SO, THEN THE OLD 'FOR' LOOP IS DEACTIVATED  (I.E.
; PURGED FROM THE STACK).
;
; 'NEXT <VARB>' SERVES AS THE LOGICAL (NOT NECESSARILY
; PHYSICAL) END OF THE 'FOR' LOOP.  THE CONTROL
; VARIABLE <VARB> IS CHECKED AGAINST 'LOPVAR'.  IF THEY ARE NOT
; THE SAME, BASIC THEN SHUFFLES THRU THE STACK TO FIND THE
; RIGHT ONE AND PURGES ALL THOSE THAT DID NOT MATCH.  EITHER
; WAY, BASIC THEN ADDS THE 'STEP' TO THAT VARIABLE AND CHECKS
; THE RESULT WITH THE LIMIT.  IF IT IS WITHIN LIMITS, CONTROL
; LOOPS BACK TO THE COMMAND FOLLOWING THE 'FOR'.  IF OUTSIDE
; THE LIMIT, THE SAVE AREA IS PURGED AND EXECUTION CONTINUES.
;
;***************************************************************

FOR:    CALL    PUSHA           ;SAVE STATE
        CALL    SETVAL          ;SET LOOP VARIABLE TO INITIAL VALUE
        MOV     LOPVAR,BX       ;SAVE LOOP VARIABLE ADDR
        MOV     DI,OFFSET(DGROUP:TAB5)  ;LOOK FOR 'TO'
        JMP     EXEC

FR1:    CALL    EXPR            ;EVALUATE <EXPR>
        MOV     LOPLMT,BX       ;SET LIMIT VALUE
        MOV     DI,OFFSET(DGROUP:TAB6)  ;LOOK FOR 'STEP'
        JMP     EXEC

FR2:    CALL    EXPR            ;STEP FOUND. EVALUATE <EXPR>
        JMP     SHORT FR4

FR3:    MOV     BX,1            ;STEP NOT FOUND. USE 1

FR4:    MOV     LOPINC,BX       ;SET STEP VALUE
FR5:    MOV     AX,CURRNT
        MOV     LOPLN,AX        ;SAVE LINE POINTER
        MOV     LOPPT,SI        ;SAVE TEXT POINTER
        MOV     CX,10
        MOV     DX,LOPVAR       ;LOOK FOR LOPVAR IN STACK
        MOV     BP,SP
FR7:    MOV     AX,[BP]         ;GET WORD FROM STACK
        OR      AX,AX           ;PAST END OF STACK?
        JZ      SHORT FR8       ;YES. DON'T PURGE A STACK FRAME
        CMP     AX,DX           ;WORD= LOPVAR?
        JZ      FR10            ;YES.
        ADD     BP,CX
        JMP     FR7             ;NO. KEEP LOOKING

FR9:    DEC     BP
        DEC     BP
        MOV     AX,[BP]
FR10:   MOV     [BP+10],AX      ;PURGE 1 STACK FRAME
        CMP     BP,SP
        JNZ     FR9
        ADD     SP,CX
FR8:    CALL    FEND

QWHAX:  JMP     QWHAT

NEXT:   CALL    TSTV            ;LOOK FOR A VARIABLE
        JB      QWHAX           ;ERROR. NOT A VARIABLE
        MOV     VARNXT,BX       ;SAVE VARIABLE ADDR
NX0:    MOV     AX,LOPVAR       ;GET 'FOR' VARIABLE ADDR
        OR      AX,AX           ;ANY?
        JZ      QWHAX           ;NO. ERROR
        CMP     AX,BX           ;'FOR' VARIABLE='NEXT' VARIABLE?
        JZ      SHORT NX3
        CALL    POPA            ;NO. PEEL OFF A FRAME
        MOV     BX,VARNXT
        JMP     NX0             ;TRY AGAIN

NX3:    MOV     CX,LOPINC
        MOV     AX,[BX]         ;GET LOOP VARIABLE
        ADD     AX,LOPINC       ;ADD STEP VALUE
        MOV     [BX],AX         ;SAVE NEW LOOP VARIABLE
        OR      CX,CX           ;SET FLAGS
        JS      SHORT NX4       ;TEST FOR NEGITIVE STEP
        CMP     AX,LOPLMT       ;NEW VALUE> LIMIT?
        JA      SHORT NX2       ;YES. GO TO NEXT LINE
        JMP     SHORT NX5       ;SKIP NEGITIVE ROUTINE
NX4:    CMP     LOPLMT,AX       ;NEW VALUE < LOOP LIMIT?
        JB      SHORT NX2
NX5:    MOV     BX,LOPLN        ;NO. GO TO TOP OF LOOP
        MOV     CURRNT,BX       ;SET LINE POINTER
        MOV     SI,LOPPT        ;SET TEXT POINTER
        CALL    FEND

NX2:    CALL    POPA            ;PURGE 1 FRAME
        CALL    FEND
;*************************************************************
;
; *** REM *** IF *** INPUT *** LET *** DEFAULT ***
;
;*************************************************************

REM:    MOV     BX,0
        JMP     SHORT IFF1

IFF:    CALL    EXPR            ;EVALUATE <EXPR>
IFF1:   OR      BX,BX           ;TRUE?
        JZ      SHORT L_20      ;NO. SKIP REMAINDER OF LINE
        JMP     RUNSML
L_20:   CALL    FNDSKP          ;FIND NEXT LINE
        JB      STARX           ;NO MORE LINES. RE-START
        JMP     RUNTSL          ;RUN NEXT LINE
STARX:  JMP     START

INPERR: MOV     SP,STKINP       ;RESTORE STACK POINTER
        POP     CURRNT          ;RESTORE LINE POINTER
        POP     SI
        POP     SI              ;RESTORE TEXT POINTER

INPUT:  PUSH    SI              ;SAVE TEXT POINTER
        CALL    QTSTG           ;PRINT USER PROMPT, IF ANY
        JMP     SHORT IP2       ;NO USER PROMPT
        CALL    TSTV            ;LOOK FOR VARIABLE
        JB      SHORT IP4       ;NOT FOUND. LOOK FOR ,
        JMP     SHORT IP3       ;GO INPUT INTO THE VARIABLE

; USE VARIABLE NAME AS PROMPT

IP2:    PUSH    SI              ;SAVE TEXT POINTER
        CALL    TSTV            ;LOOK FOR VARIABLE
        JB      QWHAY           ;NOT FOUND. ERROR
        MOV     CL,[SI]         ;SAVE CHAR IN CL
        MOV     AL,0
        MOV     [SI],AL         ;PUT A NULL IN
        MOV     DI,SI
        POP     SI              ;GET POINTER TO VARIABLE NAME
        PUSH    DI              ;SAVE NULL POINTER
        CALL    PRTSTG          ;PRINT VARIABLE NAME
        POP     SI              ;GET NULL POINTER
        MOV     [SI],CL         ;REPLACE ORIGINAL CHAR
IP3:    PUSH    SI              ;SAVE TEXT POINTER
        PUSH    CURRNT          ;SAVE LINE POINTER
        MOV     STKINP,SP       ;SAVE STACK POINTER
        PUSH    BX              ;SAVE VARIABLE ADDR
        LEA     AX,M1
        MOV     CURRNT,AX       ;SET FLAG
        MOV     AL,':'
        CALL    GETLN           ;GET THE INPUT
        LEA     SI,BUFFER
        CALL    EXPR            ;EVALUATE <EXPR>
        MOV     AX,BX           ;VALUE IN AX
        POP     BX              ;RESTORE VARIABLE ADDR
        MOV     [BX],AX         ;STORE VALUE IN VARIABLE
        POP     CURRNT          ;RESTORE LINE POINTER
        POP     SI              ;RESTORE TEXT POINTER
IP4:    POP     AX              ;CLEAR STACK
        CALL    TSTC            ;LOOK FOR A ,
        DB      ','
        DW      CGROUP:IP5
        JMP     INPUT           ;FOUND. DO IT AGAIN
IP5:    CALL    FEND            ;NOT FOUND. DONE

DEFLT:  CMP     BYTE PTR [SI],CR        ;EMPTY LINE?
        JZ      SHORT LT1       ;YES. GO TO NEXT LINE

LET:    CALL    SETVAL          ;ASSIGN VALUE TO VARIABLE
        CALL    TSTC            ;LOOK FOR A ,
        DB      ','
        DW      CGROUP:LT1
        JMP     LET             ;FOUND. DO IT AGAIN
LT1:    CALL    FEND            ;NOT FOUND. DONE

QWHAY:  JMP     QWHAT

;*****************************************************************
;
; *** EXPR ***
;
;*****************************************************************

EXPR:   CALL    EXPR2           ;EVALUATE THE 1ST OPERAND
        PUSH    BX              ;SAVE IT
EXPR1:  MOV     DI,OFFSET(DGROUP:TAB8)
        JMP     EXEC            ;LOOK FOR RELATIONAL OPERATORS

;   >=

XP11:   CALL    XP18
        JL      SHORT XRTN      ;RETURN FALSE
GRTN:   MOV     BL,AL           ;RETURN TRUE
XRTN:   RET

;   <>

XP12:   CALL    XP18
        JZ      XRTN            ;FALSE
        JMP     GRTN            ;TRUE

;   >

XP13:   CALL    XP18
        JLE     XRTN            ;FALSE
        JMP     GRTN            ;TRUE

XP14:   CALL    XP18
        JG      XRTN            ;FALSE
        JMP     GRTN            ;TRUE

;   =

XP15:   CALL    XP18
        JNZ     XRTN            ;FALSE
        JMP     GRTN            ;TRUE

;   <

XP16:   CALL    XP18
        JGE     XRTN            ;FALSE
        JMP     GRTN            ;TRUE

;  NOT FOUND

XP17:   POP     BX              ;CLEAR STACK
        RET

;  COMMON EXPR SUBROUTINE

XP18:   CALL    EXPR2           ;EVALUATE 2ND OPERAND
        MOV     CX,BX           ;PUT IT IN CX
        POP     BX              ;GET RETURN ADDR
        POP     AX              ;GET 1ST OPERAND
        PUSH    BX              ;PUT RETURN ADDR BACK
        SUB     BX,BX
        CMP     AX,CX           ;COMPARE THE OPERANDS
        MOV     AL,1            ;SET UP RETURN VALUES
        RET

;  ROUTINE 'EXPR2' EVALUATES TERMS

EXPR2:  CALL    TSTC            ;LOOK FOR A LEADING -
        DB      '-'
        DW      CGROUP:XP21
        SUB     BX,BX           ;FOUND. MAKE 1ST OPERAND 0
        JMP     SHORT XP27

XP21:   CALL    TSTC            ;IGNORE LEADING +
        DB      '+'
        DW      CGROUP:XP22

XP22:   CALL    EXPR3           ;EVALUATE 1ST OPERAND
XP23:   CALL    TSTC            ;LOOK FOR +
        DB      '+'
        DW      CGROUP:XP25

XP24:   PUSH    BX              ;SAVE 1ST OPERAND
        CALL    EXPR3           ;EVALUATE 2ND OPERAND

XP26:   POP     AX              ;GET 1ST OPERAND
        ADD     BX,AX           ;PERFORM OPERATION
        JO      QHOW1           ;OVERFLOW ERROR
        JMP     XP23            ;GO LOOK FOR MORE TERMS

XP25:   CALL    TSTC            ;LOOK FOR -
        DB      '-'
        DW      CGROUP:XP42
XP27:   PUSH    BX              ;SAVE 1ST OPERAND
        CALL    EXPR3           ;EVALUATE 2ND OPERAND
        NEG     BX              ;NEGATE 2ND OPERAND
        JMP     XP26            ;GO ADD THEM

;  ROUTINE 'EXPR3' EVALUATES FACTORS

EXPR3:  CALL    EXPR4           ;EVALUATE 1ST OPERAND
XP31:   CALL    TSTC            ;LOOK FOR *
        DB      '*'
        DW      CGROUP:XP34
        PUSH    BX              ;SAVE 1ST OPERAND
        CALL    EXPR4           ;EVALUATE 2ND OPERAND
        POP     AX              ;GET 1ST OPERAND
        IMUL    BX              ;AX= 1ST* 2ND
        JO      QHOW1           ;OVERFLOW
XP35:   MOV     BX,AX           ;PUT RESULT IN BX
        JMP     XP31            ;LOOK FOR MORE FACTORS

XP34:   CALL    TSTC            ;LOOK FOR /
        DB      '/'
        DW      CGROUP:XP42
        PUSH    BX              ;SAVE 1ST OPERAND
        CALL    EXPR4           ;EVALUATE 2ND OPERAND
        POP     AX              ;GET 1ST OPERAND
        CWD                     ;EXTEND IT
        IDIV    BX              ;AX= 1ST/2ND
        JMP     XP35            ;CONTINUE

;  ROUTINE 'EXPR4' EVALUATE SINGLE OPERANDS
;  BEWARE!!! EXPR4 CALLS EXPR IN SOME CASES. EXPRESSION EVALUATION IS RECURSIVE.

EXPR4:  MOV     DI,OFFSET(DGROUP:TAB4)
        JMP     EXEC            ;LOOK FOR BUILT-IN FUNCTIONS

XP40:   CALL    TSTV            ;LOOK FOR A VARIABLE
        JB      SHORT XP41      ;NOT FOUND
        MOV     BX,[BX]         ;GET VARIABLE CONTENTS
        RET

XP41:   CALL    TSTNUM          ;LOOK FOR A NUMBER
        OR      CH,CH           ;IS IT A NUMBER?
        JNZ     SHORT XP42              ;YES.

;  ROUTINE 'PARN' EVALUATE EXPRESSIONS IN PARENDS

PARN:   CALL    TSTC            ;LOOK FOR (
        DB      '('
        DW      CGROUP:QWHAT
        CALL    EXPR            ;EVALUATE THE EXPRESSION
        CALL    TSTC            ;LOOK FOR )
        DB      ')'
        DW      CGROUP:QWHAT
XP42:   RET

QHOW1:  JMP     QHOW

;  RANDOM NUMBER BUILT-IN FUNCTION

RND:    CALL    PARN            ;EVALUATE THE OPERAND
        OR      BX,BX
        JS      QHOW1           ;MUST BE POSITIVE
        JZ      QHOW1
        PUSH    BX              ;SAVE THE OPERAND
        MOV     BX,RANPNT
        CMP     BX,OFFSET(CGROUP:LSTROM)
        JB      SHORT RA1
        MOV     BX,OFFSET(CGROUP:START)
RA1:    MOV     AX,CS:[BX]
        INC     BX
        MOV     RANPNT,BX
        POP     BX
        SUB     DX,DX
        DIV     BX
        MOV     BX,DX
        INC     BX
ARTN:   RET

;  ABSOLUTE VALUE BUILT-IN FUNCTION

ABS_:   CALL    PARN            ;EVALUATE THE OPERAND
        OR      BX,BX           ;POSITIVE?
        JNS     ARTN            ;YES. DONE
        NEG     BX              ;MAKE IT POSITIVE
        JNO     ARTN            ;GOOD
        JMP     QHOW            ;OVERFLOW ERROR

;  ROUTINE TO GET SIZE OF @ ARRAY

SIZE_:  LEA     BX,DGROUP:TXTEND
        SUB     BX,TXTUNF
        RET

;******************************************************************
;
; *** SETVAL *** FIN *** ENDCHK *** ERROR (AND FRIENDS) ***
;
;******************************************************************

SETVAL: CALL    TSTV            ;LOOK FOR A VARIABLE
        JB      SHORT QWHAT
        PUSH    BX              ;SAVE VARIABLE ADDR
        CALL    TSTC            ;LOOK FOR =
        DB      '='
        DW      CGROUP:QWHAT
        CALL    EXPR            ;EVALUATE THE EXPRESSION
        MOV     AX,BX           ;PUT VALUE IN AX
        POP     BX
        MOV     [BX],AX         ;PUT VALUE IN VARIABLE
        RET

FIN:    CALL    TSTC            ;LOOK FOR ;
        DB      ';'
        DW      CGROUP:FI1
        POP     AX              ;CLEAR STACK
        JMP     RUNSML          ;RUN ON SAME LINE

FI1:    CALL    TSTC            ;LOOK FOR <CR>
        DB      CR
        DW      CGROUP:FI2
        POP     AX              ;CLEAR STACK
        JMP     RUNNXL          ;RUN NEXT LINE

FI2:    RET

ENDCHK: CALL    IGBLK           ;SKIP BLANKS
        CMP     AL,CR
        JZ      FI2

QWHAT:  PUSH    SI
AWHAT:  LEA     SI,WHAT
ERROR:  SUB     AL,AL
        CALL    PRTSTG          ;PRINT MESSAGE
        POP     SI
        MOV     AL,[SI]         ;GET NEXT CHAR IN LINE
        PUSH    AX              ;SAVE IT
        MOV     BYTE PTR [SI],0 ;REPLACE IT WITH NULL
        MOV     SI,CURRNT       ;GET LINE POINTER
        MOV     AX,[SI]         ;GET LINE NUMBER
        OR      AX,AX           ;TEST IT
        JZ      SHORT STAR2     ;IT'S 0. RE-START
        JNS     SHORT L_43
        JMP     INPERR          ;IT'S <0. INPUT ERROR
L_43:   CALL    PRTLN           ;PRINT THE LINE UP TO THE NULL
        DEC     SI
        POP     AX
        MOV     [SI],AL         ;REPLACE THE ORIGINAL CHAR
        MOV     AL,'?'
        CALL    OUTC            ;PRINT A ?
        SUB     AL,AL
        CALL    PRTSTG          ;PRINT THE REMAINDER OF THE LINE
STAR2:  JMP     START

QSORRY: PUSH    SI
ASORRY: LEA     SI,SORRY
        JMP     ERROR

;***************************************************************
;
; *** GETLN *** FNDLN (AND FRIENDS) ***
;
;***************************************************************

GETLN:  CALL    OUTC
GL0:    LEA     SI,BUFFER
GL1:    CMP     RICI,0          ;READ FROM PAPER TAPE?
        JZ      SHORT CALLCI            ;NO. FROM CONSOLE
        CALL    RI
        JMP     SHORT GL2

CALLCI: CALL    CI
GL2:    AND     AL,7FH
        CMP     AL,1AH                  ; CONTROL-Z
        JZ      STAR2
        CMP     AL,LF
        JZ      GL1
        CALL    OUTC
        OR      AL,AL
        JZ      GL1
        CMP     AL,7FH                  ;RUBOUT
        JZ      SHORT GL3
        CMP     AL,18H                  ; CONTROL-X
        JZ      SHORT GL4
        MOV     [SI],AL
        INC     SI
        CMP     AL,CR
        JZ      SHORT LRTN
        CMP     SI,OFFSET(DGROUP:BUFEND)
        JNZ     GL1

;  DO A RUBOUT

GL3:    CMP     SI,OFFSET(DGROUP:BUFFER)                ;AT START OF BUFFER?
        JZ      SHORT GL4               ;YES. JUST OUTPUT <CR><LF>
        DEC     SI
        MOV     AL,[SI]
        CALL    OUTC
        JMP     GL1

GL4:    CALL    CRLF
        JMP     GL0

LRTN:   RET

QHOW2:  JMP     QHOW

; FIND 1ST LINE WITH LINE # >= BX

FNDLN:  OR      BX,BX           ;MUST BE POSITIVE
        JS      QHOW2
        LEA     SI,DGROUP:TXTBGN        ;LOOK FROM START OF TEXT BUFFER

FNDLNP: LEA     AX,BUFEND
        INC     AX
        CMP     SI,AX           ;BELOW BUFEND?
        JB      LRTN            ;YES - MUST BE A DIRECT
        MOV     AX,TXTUNF
        DEC     AX
        CMP     AX,SI           ;PAST END OF TEXT BUFFER?
        JB      LRTN            ;YES. DONE
        CMP     [SI],BX         ;LINE#>= BX?
        JAE     LRTN            ;YES. DONE
FNDNXT: INC     SI
        INC     SI              ;POINT PAST LINE #
FNDSKP: MOV     DI,SI           ;SCAN FOR <CR>
        MOV     AL,CR
        MOV     CX,-1
        REPNZ   SCAS BYTE PTR ES:[DI]
        MOV     SI,DI
        JMP     FNDLNP

;*******************************************************************
;
; *** PRTSTG *** QTSTG *** PRTNUM *** PRTLN ***
;
;*******************************************************************

;  PRINT A STRING, PTR IN SI, DELIMITER IN AL

PRTSTG: MOV     CH,AL
PS1:    LODS    BYTE PTR [SI]
        CMP     AL,CH
        JZ      SHORT L_48
        CALL    OUTC
        CMP     AL,CR
        JNZ     PS1
L_48:   RET

;  SCAN AND PRINT A QUOTED STRING

QTSTG:  CALL    TSTC            ;LOOK FOR "
        DB      '"'
        DW      CGROUP:QT3
        MOV     AL,'"'
QT1:    CALL    PRTSTG          ;PRINT STRING
        CMP     AL,CR           ;STRING TERMED BY <CR>?
        POP     BX
        JNZ     SHORT QT2
        JMP     RUNNXL          ;YES. RUN NEXT LINE
QT2:    INC     BX              ;NO. RETURN 2 BYTES PAST CALL

        INC     BX
        JMP     BX

QT3:    CALL    TSTC            ;LOOK FOR '
        DB      27H                     ; SINGLE QUOTE
        DW      CGROUP:QT4
        MOV     AL,27H
        JMP     QT1

QT4:    CALL    TSTC
        DB      5FH                     ; BACK-ARROW
        DW      CGROUP:LRTN
        MOV     AL,8DH                  ; YES, <CR> WITHOUT <LF>
        CALL    OUTC
        POP     BX
        JMP     QT2

; PRINT A NUMBER IN BX, FIELD WIDTH IN CH

PRTNUM: MOV     AX,BX           ;NUMBER IN AX
        MOV     BX,10           ;DIVISOR IN BX
        PUSH    BX              ;PUT MARKER ON STACK
        SUB     CH,CH           ;CLEAR SIGN
        OR      AX,AX           ;NEGATIVE NUMBER?
        JNS     SHORT PN1       ;NO.
        MOV     CH,'-'          ;YES.
        NEG     AX
        DEC     CL
PN1:    DEC     CL              ;COUNT OFF 1 SPACE
        CWD                     ;EXTEND AX INTO DX
        DIV     BX              ;DIVIDE
        OR      AX,AX           ;RESULT 0?
        JZ      SHORT PN3       ;YES. DONE DIVIDING
        PUSH    DX              ;NO. SAVE REMAINDER
        JMP     PN1

PN3:    OR      CL,CL           ;FIELD FULL?
PN4:    JLE     SHORT PN5       ;YES. GO ON
        MOV     AL,' '
        CALL    OUTC            ;PRINT LEADING BLANK
        DEC     CL              ;COUNT 1 MORE SPACE
        JMP     PN4

PN5:    MOV     AL,CH           ;PRINT SIGN
        CALL    OUTC
        MOV     AX,DX           ;PUT 1ST DIGIT IN AX

;  PRINT THE NUMBER. 1ST DIGIT IN AX, OTHERS ON STACK.

PN6:    ADD     AL,'0'          ;MAKE IT ASCII
        CALL    OUTC            ;PRINT THE DIGIT
        POP     AX              ;GET NEXT DIGIT
        CMP     AX,10           ;10 MARKS END OF DIGITS
        JNZ     PN6
        RET                     ;DONE

;  PRINT A LINE. SI=PTR

PRTLN:  MOV     BX,[SI]         ;GET LINE #
        PUSH    BX
        INC     SI
        INC     SI              ;POINT PAST LINE #
        MOV     CL,4
        CALL    PRTNUM          ;PRINT LINE #
        MOV     AL,' '
        CALL    OUTC            ;PRINT SPACE
        SUB     AL,AL
        CALL    PRTSTG          ;PRINT LINE
        POP     BX
        RET

;********************************************************************
;
; *** POPA *** PUSHA ***
;
;********************************************************************

POPA:   POP     BX              ;RETURN ADDR IN BX
        POP     LOPVAR          ;RESTORE LOPVAR
        CMP     LOPVAR,0
        JZ      SHORT PP1
        POP     LOPINC          ;RESTORE OTHER VARIABLES
        POP     LOPLMT
        POP     LOPLN
        POP     LOPPT
PP1:    PUSH    BX
        RET

QSORRQ: JMP     QSORRY

PUSHA:  CMP     SP,OFFSET(STKLMT)       ;STACK OVERFLOW?
        JBE     QSORRQ                  ;YES
        POP     CX                      ;RETURN ADDR IN CX
        MOV     BX,LOPVAR
        OR      BX,BX                   ;LOPVAR=0?
        JZ      SHORT PU1               ;YES. JUST SAVE LOPVAR
        PUSH    LOPPT                   ;NO. SAVE OTHER VARIABLES
        PUSH    LOPLN
        PUSH    LOPLMT
        PUSH    LOPINC
PU1:    PUSH    BX              ;SAVE LOPVAR
        PUSH    CX
        RET

;*****************************************************************
;
; *** OUTC ***
;
;*****************************************************************

CRLF:   MOV     AL,CR

OUTC:   CMP     POLO,0          ;OUTPUT TO :PO: ?
        JZ      SHORT CALLCO    ;NO.
        CALL    PO              ;YES.
        JMP     SHORT OC4

CALLCO: OR      AL,AL
        JZ      SHORT OC4       ;DON'T PRINT NULLS
        CALL    CO
OC4:    CMP     AL,CR           ;WAS IT A <CR> ?
        JZ      SHORT OCR
        RET

OCR:    MOV     AL,LF
        CALL    OUTC            ;OUTPUT A <LF>
        MOV     AL,CR
        RET

        CODE ENDS

        DATA    SEGMENT PUBLIC 'DATA'
        COUNT DW ?
        DATA ENDS

        DATA4   SEGMENT PUBLIC 'EXTRA'
        TXTBGN DB 3FFH DUP (?)
        TXTEND LABEL WORD
        DATA4 ENDS

        CODE SEGMENT WORD PUBLIC 'CODE'
        INPORT EQU 0002H                ;8155 INPUT PORT - USING BIT 7
        PORTCNT EQU 00000H              ;8155 PROT CONTROL REGISTER
        INOUT EQU 001H                  ;8155 CONTROL CODE PORT A OUTPUT
                                        ;                  PORT B INPUT
        BITS EQU 7                      ;NUMBER OF BITS TO TRANSMIT

INIT:   MOV     AX,DGROUP
        MOV     DS,AX                   ;INIT REGISTERS
        MOV     ES,AX
        MOV     AX,STACK
        MOV     SS,AX
        MOV     SP,OFFSET(STK)
        LEA     AX,ZERO                 ;CLEAR ALL VARIALBE LOCATINS
        MOV     DI,AX
        MOV     CX,23
        XOR     AL,AL
   REP  STOS    POLO
        DEC     M1                      ;SET M1 TO 0FFFFH
        MOV     AX,OFFSET (CGROUP:START);INITIALIZE RND POINTER
        MOV     RANPNT,AX
        MOV     CGROUP:DZ0, OFFSET QHOW ;SET UP DIV. BY ZERO VECTOR
        MOV     CGROUP:DZS,CGROUP
        MOV     DX,PORTCNT              ;INITIALIZE I/O PORTS
        MOV     AL,INOUT
        OUT     DX,AL
        MOV     DX,OUTPORT
        MOV     AL,0FFH                 ;SET OUTPUT TO STOP BITS
        OUT     DX,AL
        CALL    ADAPT                   ;FIND OUT WHAT BAUD RATE IS
        JMP     START                   ;GO TO BEGINNING OF INTERPRETER

CI:     PUSH    DX                      ;CONSOLE IN ROUTINE
        PUSH    SI
        PUSH    CX
        PUSH    BX
        MOV     DX,INPORT
        MOV     SI,COUNT                ;LOAD BAUD RATE DELAY
IN0:    IN      AL,DX                   ;LOOK FOR A START BIT
        AND     AL,80H
        JNZ     IN0
        MOV     CX,SI                   ;PUT BAUD RATE DELAY IN CX
        SAR     CX,1                    ;DIVIDE BY 2 FOR 1/2 BIT TIME
IN3:    LOOP    IN3                     ;DELAY
        IN      AL,DX
        AND     AL,80H                  ;CHECK FOR LOW (START BIT)
        JNZ     IN0
        MOV     CX,SI                   ;RELOAD COUNT
        MOV     BL,BITS                 ;NUMBER OF BITS TO INPUT
IN6:    SHR     AH,1
IN5:    LOOP    IN5                     ;DELAY ONE BIT TIME
        IN      AL,DX                   ;READ IN ONE BIT
        AND     AL,80H
        OR      AH,AL
        MOV     CX,SI                   ;RELOAD DELAY COUNT
        DEC     BL                      ;DECREMENT BIT COUNT
        JNZ     IN6
        MOV     AL,AH
        SHR     AL,1                    ;SHIFT ONE MORE TO ALIGH NEW BYTE
        POP     BX
        POP     CX
        POP     SI
        POP     DX                      ;RESTORE REGISTERS
        RET
OUTPORT EQU 00001H

CO:     PUSH    BX
        PUSH    AX
        PUSH    DX
        PUSH    CX
        MOV     DX,OUTPORT              ;INITIALIZE DX TO OUTPUT PORT
        SAL     AX,1                    ;MOVE OVER TO ALLOW START BIT
        OR      AX,0F00H                ;SET START BIT AND STOP BITS
        MOV     BX,10                   ;OUTPUT 10 BITS

LOOP1:  OUT     DX,AL                   ;OUTPUT ONE BIT
        MOV     CX,COUNT                ;LOAD BIT DELAY TIME
LOOP2:  LOOP    LOOP2                   ;DELAY
        SAR     AX,1                    ;SHIFT NEXT BIT INTO PLACE
        DEC     BX                      ;DECREMENT BIT COUNT
        JNZ     LOOP1
        POP     CX
        POP     DX
        POP     AX
        POP     BX                      ;RESTORE REGISTERS
        RET

        SCALE EQU 03H
        OFFST EQU 0002H

ADAPT:  XOR     CX,CX                   ;CLEAR COUNT REGISTER
        MOV     DX,INPORT
AD1:    IN      AL,DX                   ;READ INPUT PORT
        AND     AL,80H
        JNZ     AD1                     ;WAIT FOR A START BIT
AD2:    IN      AL,DX                   ;CONTINUOUSLY CHECK FOR HIGH BIT
                                        ;IN SPACE CHARACTER (20H)
        AND     AL,80H
        LOOPZ   AD2
        NEG     CX                      ;INVERT COUNT REG FOR ACTUAL COUNT
        MOV     AX,CX
        XOR     DX,DX                   ;SET UP FOR SCALING
        MOV     BX,SCALE
        DIV     BX
        SUB     AX,OFFST                ;SUBTRACT OFFSET
        MOV     COUNT,AX                ;SAVE AS THE COUNT VARIABLE
        RET


PO:     RET
RI:     RET

CODE ENDS


CONST   SEGMENT PUBLIC 'CONST'

HOW     DB      'HOW?',CR
OK      DB      'OK',CR
WHAT    DB      'WHAT?',CR
SORRY   DB      'SORRY',CR
LSTROM LABEL BYTE

CONST ENDS

CONST2 SEGMENT PUBLIC 'CONST'
JMP     FAR PTR CGROUP:INIT
CONST2 ENDS

DATA    SEGMENT WORD PUBLIC 'DATA'
ZERO    DW      0
M1      DW      -1
POLO    DB      0
RICI    DB      0
CURRNT  DW      0
Z       DB      0
STKGOS  DW      0
VARNXT  LABEL   WORD
STKINP  DW      0
LOPVAR  DW      0
LOPINC  DW      0
LOPLMT  DW      0
LOPLN   DW      0
LOPPT   DW      0
RANPNT  DW      CGROUP:START
TXTUNF  DW      DGROUP:TXTBGN

DATA    ENDS

DATA2   SEGMENT WORD PUBLIC 'DATA'

VARBGN  DB      2*27 DUP (?)
        DB      1 DUP (?)
BUFFER  DB      80 DUP (?)
BUFEND  LABEL   BYTE

DATA2   ENDS

STACK   SEGMENT WORD STACK 'STACK'
STKLMT  LABEL   BYTE
        DB      40 DUP (?)
STK     LABEL   WORD

STACK   ENDS
END     INIT
