asmb.asm
    name asmb
    aseg
    org 7000h
; load, patch and run asm80

LOAD    equ     6
ERROR   equ     12
EXIT    equ     9
ISIS    equ     40h

; patch info
P1ADDR  equ     38B8h
P1VAL   equ     30h
P2ADDR  equ     3948h
P2VAL   equ     2Ah


start:
    lxi     sp,start
    mvi     c,LOAD
    lxi     d,lodprm
    call    ISIS 
    lda     status
    ora     a
    jnz     failed
    mvi     a, P1VAL
    sta     P1ADDR
    mvi     a,P2VAL
    sta     P2ADDR
    lhld    entry
    pchl

failed:
    mvi     c,ERROR
    lxi     d,errprm
    call    ISIS
    mvi     c,EXIT
    lxi     d,extprm
    call    ISIS


lodprm:         ; load parameters
    dw  filenm  ; path$p
    dw  0       ; load$offset
    dw  0       ; switch
    dw  entry   ; entry$p
    dw  status  ; status$p
errprm:         ; error parameters
status:
    dw  0       ; filled in with load status
    dw  status
extprm:         ; exit parameters
    dw  status
filenm:
    db  'ASM80 '
entry:          ; filled in with load entry
    ds  2

    end start
asmb12.asm
    name asmb12
    aseg
    org 7000h
; load, patch and run asm80

LOAD    equ     6
ERROR   equ     12
EXIT    equ     9
ISIS    equ     40h

; patch info
P1ADDR  equ     38B8h
P1VAL   equ     48h
P2ADDR  equ     3948h
P2VAL   equ     42h


start:
    lxi     sp,start
    mvi     c,LOAD
    lxi     d,lodprm
    call    ISIS 
    lda     status
    ora     a
    jnz     failed
    mvi     a, P1VAL
    sta     P1ADDR
    mvi     a,P2VAL
    sta     P2ADDR
    lhld    entry
    pchl

failed:
    mvi     c,ERROR
    lxi     d,errprm
    call    ISIS
    mvi     c,EXIT
    lxi     d,extprm
    call    ISIS


lodprm:         ; load parameters
    dw  filenm  ; path$p
    dw  0       ; load$offset
    dw  0       ; switch
    dw  entry   ; entry$p
    dw  status  ; status$p
errprm:         ; error parameters
status:
    dw  0       ; filled in with load status
    dw  status
extprm:         ; exit parameters
    dw  status
filenm:
    db  'ASM80 '
entry:          ; filled in with load entry
    ds  2

    end start
attrib.plm
3400H:
DO;
    DECLARE TRUE    LITERALLY '0FFH',
            FALSE   LITERALLY '0',
            CR      LITERALLY '0DH',
            LF      LITERALLY '0AH';

    DECLARE VER DATA(1, 8);
    DECLARE COPYRIGNT DATA('(C) 1975,1976 INTEL CORP');

    ISIS: PROCEDURE(CMD, PARAM$P);
        DECLARE CMD BYTE, PARAM$P ADDRESS;
        GOTO 40H;
    END ISIS;

    READ: PROCEDURE(CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P) ADDRESS;

        CALL ISIS(3, .CONN);
    END;

    WRITE: PROCEDURE(CONN, BUFF$P, COUNT, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, STATUS$P) ADDRESS;

        CALL ISIS(4, .CONN);
    END;

    ATTRIB: PROCEDURE (PATH$P, ATTRIB, ON$OFF, STATUS$P);
        DECLARE (PATH$P, ATTRIB, ON$OFF, STATUS$P) ADDRESS;

        CALL ISIS(10, .PATH$P);
    END ATTRIB;

    EXIT: PROCEDURE;
        DECLARE STATUS ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(9, .STATUS);
    END;

    ERROR: PROCEDURE(ERROR$NUM);
        DECLARE (ERROR$NUM, STATUS) ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(12, .ERROR$NUM);
    END;



    DEBLANK: PROCEDURE(PTR) ADDRESS;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE (C = ' ');
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;

    DELIMIT: PROCEDURE(PTR) ADDRESS;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE (C = ':' OR C = '.' OR
                 ('0' <= C AND C <= '9') OR
                 ('A' <= C AND C <= 'Z'));
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;

    NUMOUT: PROCEDURE(VALUE, BASE, LC, BUFADR, WIDTH);
        DECLARE (VALUE, BUFADR) ADDRESS, (BASE, LC, WIDTH) BYTE; 
        DECLARE DIGITS DATA('0123456789ABCDEF');
        DECLARE I BYTE;
        DECLARE BUF BASED BUFADR (1) BYTE;

        DO I = 1 TO WIDTH;
            BUF(WIDTH - I) = DIGITS(VALUE MOD BASE);
            VALUE = VALUE / BASE;   
        END;

        I = 0;
        DO WHILE BUF(I) = '0' AND I < WIDTH - 1;
            BUF(I) = LC;
            I = I + 1;
        END;
    END;

    REPORTERROR: PROCEDURE(ERRNUM);
        DECLARE ERRNUM ADDRESS;
        DECLARE NUMBERBUFFER(3) BYTE, I ADDRESS, STATUS ADDRESS;
     

        DECLARE ERRMSG DATA(0, 0,
            2, 'ILLEGAL AFTN ARGUMENT', 0,
            4, 'INCORRECTLY SPECIFIED FILE', 0,
            5, 'UNRECOGNIZED DEVICE NAME', 0,
            6, 'ATTEMPT TO WRITE TO INPUT DEVICE', 0,
            8, 'ATTEMPT TO READ FROM OUTPUT DEVICE', 0,
            9, 'DIRECTORY FULL', 0,
            0AH, 'NOT ON SAME DISK', 0,
            0BH, 'FILE ALREADY EXISTS', 0,
            0CH, 'FILE IS ALREADY OPEN', 0,
            0DH, 'NO SUCH FILE', 0,
            0EH, 'WRITE PROTECTED', 0,
            0FH, 'LOAD TOO LOW', 0,
            10H, 'BAD LOAD FORMAT', 0,
            11H, 'NOT A DISK FILE', 0,
            12H, 'ILLEGAL ISIS COMMAND', 0,
            13H, 'ATTEMPTED SEEK ON NON-DISK FILE', 0,
            14H, 'ATTEMPTED BACK SEEK TO FAR', 0,
            16H, 'ILLEGAL ACCESS MODE TO OPEN', 0,
            17H, 'MISSING FILENAME', 0,
            19H, 'ILLEGAL ECHO FILE', 0,
            1AH, 'ILLEGAL ATTRIBUTE IDENTIFIER', 0,
            1BH, 'ILLEGAL SEEK COMMAND', 0,
            1CH, 'MISSING EXTENSION', 0,
            1FH, 'CAN', 27H, 'T SEEK ON WRITE ONLY FILE', 0,
            20H, 'CAN', 27H, 'T DELETE OPEN FILE', 0,
            23H, 'SEEK PAST EOF', 0,
            0C9H, 'UNRECOGNIZED SWITCH', 0,
            0CAH, 'UNRECOGNIZED DELIMITER', 0,
            0CBH, 'INVALID SYNTAX', 0,
            0CCH, 'PREMATURE EOF', 0,
            0CEH, 'ILLEGAL DISKETTE LABEL', 0,
            0D0H, 'CHECKSUM ERROR', 0
        );



        IF ERRNUM <> 0 THEN
        DO;
            I = 0;
            DO WHILE I < LENGTH(ERRMSG);
                IF ERRNUM = ERRMSG(I) AND ERRMSG(I + 1) <> 0 THEN
                DO;
                    I = I + 1;
                    CALL WRITE(0, .(' '), 1, .STATUS);
                    DO WHILE ERRMSG(I) <> 0;
                        CALL WRITE(0, .ERRMSG(I), 1, .STATUS);
                        I = I + 1;
                    END;
                    CALL WRITE(0, .(0DH, 0AH), 2, .STATUS);
                    return;
                END;
                ELSE
                DO;
                    DO WHILE ERRMSG(I) <> 0;
                        I = I + 1;
                    END;
                    I = I + 1;
                END;
            end;
            CALL ERROR(ERRNUM);
        END;
    END;


    FILE$ERROR: PROCEDURE(STATUS, PTR, CALLEXIT);
        DECLARE (STATUS, PTR) ADDRESS, CALLEXIT BYTE;
        DECLARE ERR$STATUS ADDRESS;

        IF STATUS <> 0 THEN
        DO;
            PTR = DEBLANK(PTR);
            CALL WRITE(0, .(' '), 1, .ERR$STATUS);
            CALL WRITE(0, PTR, DELIMIT(PTR) - PTR, .ERR$STATUS);
            CALL WRITE(0, .(','), 1, .ERR$STATUS);
            CALL REPORTERROR(STATUS);
            IF CALLEXIT THEN
                CALL EXIT;
        END;
    END;

        
    DECLARE (PADW, ACTUAL, STATUS) ADDRESS;
    DECLARE BUFPTR ADDRESS, CH BASED BUFPTR BYTE;
    DECLARE BUFFER(128) BYTE;
    DECLARE SWID ADDRESS;
    DECLARE (PAD, ONOFF) BYTE;

MAIN:
    CALL READ(1, .BUFFER, 128, .ACTUAL, .STATUS);
    BUFPTR = DEBLANK(.BUFFER);
    IF CH = CR THEN DO;
        CALL REPORTERROR(0CBH);
        CALL EXIT;
    END;

    BUFPTR = DEBLANK(DELIMIT(BUFPTR));
   
    DO WHILE CH = '$';
        BUFPTR = BUFPTR + 1;
        IF CH = 'I' THEN
            SWID = 0;
        ELSE IF CH = 'S' THEN
            SWID = 1;
        ELSE IF CH = 'W' THEN
            SWID = 2;
        ELSE IF CH = 'F' THEN
            SWID = 3;
        ELSE DO;
            CALL REPORTERROR(0C9H);
            CALL EXIT;
        END;
        BUFPTR = DEBLANK(BUFPTR + 1);
        IF CH = '0' THEN
            ONOFF = 0;
        ELSE IF CH = '1' THEN
            ONOFF = 1;
        ELSE DO;
            CALL REPORTERROR(0C9H);
            CALL EXIT;
        END;
        CALL ATTRIB(.BUFFER, SWID, ONOFF, .STATUS);
        CALL FILEERROR(STATUS, .BUFFER, TRUE);
        BUFPTR = DEBLANK(BUFPTR + 1);
    END;
    IF CH <> CR THEN DO;
        CALL REPORTERROR(0C9H);
        CALL EXIT;
    END;
    CALL EXIT;
END;
EOF
batch.asm
        name batch
        aseg
        org 3200h

; isis calls
ISIS    equ     40h
READ    equ     3
CONSOL  equ     8
ERROR   equ     12
EXIT    equ     9

CR      equ     0dh

start:
        lxi     sp,stk
        mvi     c,READ
        lxi     d,rdprm
        call    ISIS    ; read the cmd line
        lda     status
        ora     a
        jnz     failed
        lhld    bufptr

scan:
        mov     a,m
        shld    bufptr
        inx     h
        cpi     CR     ; end of line
        jz      scan1
        cpi     ' '
        jz      scan    ; check for 'TO '
        cpi     'T'
        jnz     scan2
        mov     a,m
        inx     h
        cpi     'O'
        jnz     scan2
        mov     a,m
        cpi     ' '
        jz      scan3

scan2:
        lhld    bufptr  ; save as the batch file name
        shld    conprm

scan4:                  ; skip file name
        mov     a,m
        shld    bufptr
        inx     h
        cpi     CR
        jz      scan1
        cpi     ' '
        jnz     scan4

scan5:                  ; skip spaces
        mov     a,m
        shld    bufptr
        inx     h
        cpi     ' '
        jz      scan5
        cpi     CR
        jz      scan1   ; end of line
        cpi     'T'
        jnz     badcmd
        mov     a,m
        cpi     'O'
        jnz     badcmd
        inx     h
        mov     a,m
        cpi     ' '
        jnz     badcmd

scan3:                  ; set the output file
        shld    ofile
scan1:
        mvi     c,CONSOL
        lxi     d,conprm
        call    ISIS

done:
        mvi     c,EXIT
        lxi     d,extprm
        call    ISIS

badcmd:
        mvi     a,4     ; error 400h
        sta     status + 1


failed:
        mvi     c,ERROR
        lxi     d,errprm
        call    ISIS
        jmp     done

; the isis parameter blocks
rdprm:
        dw      1       ; read console
bufptr: dw      rdbuf
        dw      128
        dw      actual
        dw      status   

conprm: dw      bfile   ; default batch file, overwitten if needed
ofile:  dw      defco   ; output file, defaults to :CO:
        dw      status
bfile:  db      'BFILE '
defco:  db      ':CO: '
extprm: dw      status  ; shared
errprm:
status: dw      0       ; ISIS status here in case error call needed
        dw      status
actual: ds      2
rdbuf:  ds      128
        ds      4       ; stack area
stk:
        end     start
        
        
copy.plm
3400H:
DO;
    DECLARE TRUE    LITERALLY '0FFH',
            FALSE   LITERALLY '0',
            OK      LITERALLY '0',
            CR      LITERALLY '0DH',
            LF      LITERALLY '0AH';

    DECLARE READMODE    LITERALLY '1',
            WRITEMODE   LITERALLY '2',
            UPDATEMODE  LITERALLY '3';

    /* ERROR CODES */
    DECLARE BAD$PATH LITERALLY '4',
            BAD$DEVICE LITERALLY '5',
            FILE$EXISTS LITERALLY '0BH',
            NO$SUCH$FILE LITERALLY '0DH',
            NULL$FILENAME LITERALLY '23',
            NULL$EXTENSION LITERALLY '28',
            BAD$SWITCH  LITERALLY '0C9H',
            BAD$SYNTAX  LITERALLY '0CBH';

    DECLARE BOOLEAN LITERALLY 'BYTE';
    DECLARE F1DEV LITERALLY '1';

    DECLARE VER DATA(1, 10H);
    DECLARE COPYRIGHT DATA('(C) 1975,1976 INTEL CORP');

    MEMCHK: PROCEDURE ADDRESS;
        GOTO 0F81BH;
    END;

    ISIS: PROCEDURE(CMD, PARAM$P);
        DECLARE CMD BYTE, PARAM$P ADDRESS;
        GOTO 40H;
    END ISIS;

    OPEN: PROCEDURE(CONN$P, PATH$P, ACCESS, ECHO, STATUS$P);
        DECLARE (CONN$P, PATH$P, ACCESS, ECHO, STATUS$P) ADDRESS;

        CALL ISIS(0, .CONN$P);
    END;

    READ: PROCEDURE(CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P) ADDRESS;

        CALL ISIS(3, .CONN);
    END;

    WRITE: PROCEDURE(CONN, BUFF$P, COUNT, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, STATUS$P) ADDRESS;

        CALL ISIS(4, .CONN);
    END;

    CLOSE: PROCEDURE(CONN, STATUS$P);
        DECLARE (CONN, STATUS$P) ADDRESS;

        CALL ISIS(1, .CONN);
    END;

    ERROR: PROCEDURE(ERROR$NUM);
        DECLARE (ERROR$NUM, STATUS) ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(12, .ERROR$NUM);
    END;

	RENAME: PROCEDURE(OLD$P, NEW$P, STATUS$P);
    	DECLARE (OLD$P, NEW$P, STATUS$P) ADDRESS;
    	
    	CALL ISIS(7, .OLD$P);
	END;

    EXIT: PROCEDURE;
        DECLARE STATUS ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(9, .STATUS);
    END;


    DEBLANK: PROCEDURE(PTR) ADDRESS;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE (C = ' ');
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;

    DELIMIT: PROCEDURE(PTR) ADDRESS;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE (C = ':' OR C = '.' OR
                 ('0' <= C AND C <= '9') OR
                 ('A' <= C AND C <= 'Z'));
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;

    SEQ: PROCEDURE(S1, S2, CNT) BYTE;
        DECLARE (S1,S2) ADDRESS, CNT BYTE;
        DECLARE S1A BASED S1(1) BYTE;
        DECLARE S2A BASED S2(1) BYTE;
        DECLARE I BYTE;
        CNT = CNT - 1;
        DO I = 0 TO CNT;
            IF S1A(I) <> S2A(I) THEN
                RETURN 0;
        END;
        RETURN 0FFH;
    END;

    NUMOUT: PROCEDURE(VALUE, BASE, LC, BUFADR, WIDTH);
        DECLARE (VALUE, BUFADR) ADDRESS, (BASE, LC, WIDTH) BYTE; 
        DECLARE DIGITS DATA('0123456789ABCDEF');
        DECLARE I BYTE;
        DECLARE BUF BASED BUFADR (1) BYTE;

        DO I = 1 TO WIDTH;
            BUF(WIDTH - I) = DIGITS(VALUE MOD BASE);
            VALUE = VALUE / BASE;   
        END;

        I = 0;
        DO WHILE BUF(I) = '0' AND I < WIDTH - 1;
            BUF(I) = LC;
            I = I + 1;
        END;
    END;

    REPORTERROR: PROCEDURE(ERRNUM);
        DECLARE ERRNUM ADDRESS;
        DECLARE NUMBERBUFFER(4) BYTE, I ADDRESS, STATUS ADDRESS;
     

        DECLARE ERRMSG DATA(0, 0,
            2, 'ILLEGAL AFTN ARGUMENT', 0,
            4, 'INCORRECTLY SPECIFIED FILE', 0,
            5, 'UNRECOGNIZED DEVICE NAME', 0,
            6, 'ATTEMPT TO WRITE TO INPUT DEVICE', 0,
            8, 'ATTEMPT TO READ FROM OUTPUT DEVICE', 0,
            9, 'DIRECTORY FULL', 0,
            0AH, 'NOT ON SAME DISK', 0,
            0BH, 'FILE ALREADY EXISTS', 0,
            0CH, 'FILE IS ALREADY OPEN', 0,
            0DH, 'NO SUCH FILE', 0,
            0EH, 'WRITE PROTECTED', 0,
            0FH, 'LOAD TOO LOW', 0,
            10H, 'BAD LOAD FORMAT', 0,
            11H, 'NOT A DISK FILE', 0,
            12H, 'ILLEGAL ISIS COMMAND', 0,
            13H, 'ATTEMPTED SEEK ON NON-DISK FILE', 0,
            14H, 'ATTEMPTED BACK SEEK TO FAR', 0,
            16H, 'ILLEGAL ACCESS MODE TO OPEN', 0,
            17H, 'MISSING FILENAME', 0,
            19H, 'ILLEGAL ECHO FILE', 0,
            1AH, 'ILLEGAL ATTRIBUTE IDENTIFIER', 0,
            1BH, 'ILLEGAL SEEK COMMAND', 0,
            1CH, 'MISSING EXTENSION', 0,
            1FH, 'CAN', 27H, 'T SEEK ON WRITE ONLY FILE', 0,
            20H, 'CAN', 27H, 'T DELETE OPEN FILE', 0,
            23H, 'SEEK PAST EOF', 0,
            0C9H, 'UNRECOGNIZED SWITCH', 0,
            0CAH, 'UNRECOGNIZED DELIMITER', 0,
            0CBH, 'INVALID SYNTAX', 0,
            0CCH, 'PREMATURE EOF', 0,
            0CEH, 'ILLEGAL DISKETTE LABEL', 0,
            0D0H, 'CHECKSUM ERROR', 0
        );



        IF ERRNUM <> 0 THEN
        DO;
            I = 0;
            DO WHILE I < LENGTH(ERRMSG);
                IF ERRNUM = ERRMSG(I) AND ERRMSG(I + 1) <> 0 THEN
                DO;
                    I = I + 1;
                    CALL WRITE(0, .(' '), 1, .STATUS);
                    DO WHILE ERRMSG(I) <> 0;
                        CALL WRITE(0, .ERRMSG(I), 1, .STATUS);
                        I = I + 1;
                    END;
                    CALL WRITE(0, .(0DH, 0AH), 2, .STATUS);
                    return;
                END;
                ELSE
                DO;
                    DO WHILE ERRMSG(I) <> 0;
                        I = I + 1;
                    END;
                    I = I + 1;
                END;
            end;
            CALL ERROR(ERRNUM);
        END;
    END;

    CHECKERROR: PROCEDURE(ERRCODE);
        DECLARE ERRCODE ADDRESS;
        IF ERRCODE <> 0 THEN DO;
            CALL REPORTERROR(ERRCODE);
            CALL EXIT;
        END;
    END;

    DECLARE FULLNAME(15) BYTE;
    DECLARE DEVICENAMES(21) ADDRESS INITIAL (
        'F0','F1','TI','TO','VI','VO','I1','O1','TR','HR',
        'R1','R2','TP','HP','P1','P2','LP','L1','CI','CO','BB');
    DECLARE (PN, PN2) (10) BYTE;

    CANON: PROCEDURE(FILENAME, INTFN$P) BYTE;
        DECLARE (FILENAME, INTFN$P) ADDRESS;
        DECLARE PATHCH BASED FILENAME BYTE; /* CHAR OF FILENAME POINTS TO */
        DECLARE PATHCHARS BASED FILENAME (1) BYTE;
        DECLARE INTFN BASED INTFN$P (10) BYTE;  /* BYTE VERSION OF INTFN  */
        DECLARE STARTNAME ADDRESS, STARTCH BASED STARTNAME BYTE;
        DECLARE DEVPAIR(0) ADDRESS, (SECOND, FIRST) BYTE;
        DECLARE (PAD, J, I) BYTE;


        ALPHANUM: PROCEDURE BOOLEAN;
            RETURN (PATHCH >= 'A' AND PATHCH <= 'Z')
                OR (PATHCH >= '0' AND PATHCH <= '9');
        END;


        DO I = 0 TO LAST(INTFN);    /* CLEAR INTFN */
            INTFN(I) = 0;
        END;
        DO WHILE PATHCH = ' ';  /* SKIP LEADING SPACE */
            FILENAME = FILENAME + 1;
        END;
        STARTNAME = FILENAME;
        IF PATHCH = ':' THEN
        DO;
            INTFN(0) = 0FFH;
            FIRST = PATHCHARS(1);
            SECOND = PATHCHARS(2);
            IF PATHCHARS(3) <> ':' THEN
                RETURN BAD$PATH;

            DO I =  0 TO LAST(DEVICENAMES);
                IF DEVICENAMES(I) = DEVPAIR(0) THEN 
                    INTFN(0) = I;   /* SAVE DEVICE NUMBER */
            END;
            IF INTFN(0) = 0FFH THEN
                RETURN BAD$DEVICE;
            FILENAME = FILENAME + 4;
        END;

        FIRST = 0;
        DO I = 1 TO 6;
            IF ALPHANUM THEN
            DO;
                INTFN(I) = PATHCH;
                FIRST = 1;
                FILENAME = FILENAME + 1;
            END;
        END;
        IF PATHCH = '.' THEN
        DO;
            FILENAME = FILENAME + 1;
            DO I = 7 TO 9;
                IF ALPHANUM THEN
                DO;
                    INTFN(I) = PATHCH;
                    FILENAME = FILENAME + 1;
                END;
            END;
        END;
        IF INTFN(0) <= F1DEV AND FIRST = 0 THEN
            RETURN NULL$FILENAME;
        J =  -1;
        DO WHILE STARTNAME < FILENAME;
            J = J + 1;
            FULLNAME(J) = STARTCH;
            STARTNAME = STARTNAME + 1;
        END;
        IF FULLNAME(J) = '.' THEN
            RETURN NULL$EXTENSION;
        FULLNAME(J + 1) = ' ';
        IF ALPHANUM  OR PATHCH = '.' OR PATHCH = ':' THEN
            RETURN BAD$PATH;
        RETURN OK;
    END;

    DECLARE MODE BYTE INITIAL(WRITEMODE);
    DECLARE MEMSIZE ADDRESS;
    DECLARE BUFFER(128) BYTE;
    DECLARE (SWITCHPTR, FILEPTR, BUFPTR, ACTUAL, STATUS) ADDRESS;
    DECLARE SWITCH BASED SWITCHPTR (1) BYTE;
    DECLARE (AFTOUT, AFTIN) ADDRESS;


    FILE$ERROR: PROCEDURE(STATUS, PTR, CALLEXIT);
        DECLARE (STATUS, PTR) ADDRESS, CALLEXIT BYTE;
        DECLARE ERR$STATUS ADDRESS;

        IF STATUS <> 0 THEN
        DO;
            PTR = DEBLANK(PTR);
            CALL WRITE(0, .(' '), 1, .ERR$STATUS);
            CALL WRITE(0, PTR, DELIMIT(PTR) - PTR, .ERR$STATUS);
            CALL WRITE(0, .(','), 1, .ERR$STATUS);
            CALL REPORTERROR(STATUS);
            IF CALLEXIT THEN
                CALL EXIT;
        END;
    END;





MAIN:
    CALL READ(1, .BUFFER, 128, .ACTUAL, .STATUS);
    CALL CHECKERROR(STATUS);
    BUFPTR = DEBLANK(DELIMIT(DEBLANK(.BUFFER)));
    DO WHILE SEQ(BUFPTR, .(','), 1);
        BUFPTR = DEBLANK(DELIMIT(DEBLANK(BUFPTR + 1)));
    END;
    IF NOT SEQ(.('TO '), BUFPTR, 3) THEN
        CALL CHECKERROR(BAD$SYNTAX);
    ELSE
        FILEPTR = DEBLANK(DELIMIT(BUFPTR));

    SWITCHPTR = DEBLANK(DELIMIT(FILEPTR));
    DO WHILE SWITCH(0) <> CR;
        IF SWITCH(0) = '$' THEN DO;
            IF SWITCH(1) = 'U' THEN
                MODE = UPDATEMODE;
            ELSE DO;
                CALL REPORTERROR(BAD$SWITCH);
                CALL EXIT;
            END;
            SWITCHPTR = DEBLANK(SWITCHPTR + 2);
        END;
        ELSE DO;
            CALL REPORTERROR(BAD$SWITCH);
            CALL EXIT;
        END;
    END; 
    
    if (STATUS := CANON(FILEPTR, .PN)) <> 0 THEN 
        CALL FILEERROR(STATUS, FILEPTR, TRUE);
    IF PN(0) = 0 OR PN(0) = 1 THEN DO;
        CALL RENAME(FILEPTR, FILEPTR, .STATUS);
        IF STATUS <> NO$SUCH$FILE THEN
            IF STATUS <> FILE$EXISTS THEN
                CALL CHECKERROR(STATUS);
            ELSE IF MODE <> UPDATEMODE THEN DO;
                CALL FILEERROR(STATUS, FILEPTR, FALSE);
                /* NOTE ORIGINAL USES ACTUAL VS. STATUS */
                CALL WRITE(0, .(' DELETE', 3FH, ' '), 9, .ACTUAL);
                CALL READ(1, .MEMORY, 128, .ACTUAL, .STATUS);
                CALL CHECKERROR(STATUS);
                IF (MEMORY(0) = 'Y' OR MEMORY = 'Y' + 20H) THEN
                    ;
                ELSE
                    CALL EXIT;
            END;
    END;
    CALL OPEN(.AFTOUT, FILEPTR, MODE, 0, .STATUS);
    CALL FILEERROR(STATUS, FILEPTR, TRUE);
    MEMSIZE = (MEMCHK - .MEMORY) AND 0FFF8H;
    IF PN(0) > 1 THEN
        MEMSIZE = 256;      /* NONE FILE DEVICE */
    FILEPTR = DEBLANK(.BUFFER);
    DO WHILE BUFPTR >= FILEPTR;  /* TILL WE HAVE PROCESSED ALL SOURCE */
        CALL OPEN(.AFTIN, FILEPTR, READMODE, 0, .STATUS);
        CALL FILEERROR(STATUS, FILEPTR, TRUE);
        ACTUAL = 1;
        DO WHILE ACTUAL <> 0;
            CALL READ(AFTIN, .MEMORY, MEMSIZE, .ACTUAL, .STATUS);
            CALL WRITE(AFTOUT, .MEMORY, ACTUAL, .STATUS);
        END;
        CALL CLOSE(AFTIN, .STATUS);
        FILEPTR = DEBLANK(DEBLANK(DELIMIT(FILEPTR)) + 1);
    END;
    CALL CLOSE(AFTOUT, .STATUS);
    CALL EXIT;

END;
EOF
delete.plm
3400H:
DO;
    DECLARE TRUE    LITERALLY '0FFH',
            FALSE   LITERALLY '0',
            CR      LITERALLY '0DH',
            LF      LITERALLY '0AH';

    DECLARE VER DATA(1, 9);
    DECLARE COPYRIGNT DATA('(C) 1975,1976 INTEL CORP');

    ISIS: PROCEDURE(CMD, PARAM$P);
        DECLARE CMD BYTE, PARAM$P ADDRESS;
        GOTO 40H;
    END ISIS;

    READ: PROCEDURE(CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P) ADDRESS;

        CALL ISIS(3, .CONN);
    END;

    WRITE: PROCEDURE(CONN, BUFF$P, COUNT, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, STATUS$P) ADDRESS;

        CALL ISIS(4, .CONN);
    END;

    DELETE: PROCEDURE (PATH$P, STATUS$P);
        DECLARE (PATH$P, STATUS$P) ADDRESS;

        CALL ISIS(2, .PATH$P);
    END DELETE;

    ERROR: PROCEDURE(ERROR$NUM);
        DECLARE (ERROR$NUM, STATUS) ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(12, .ERROR$NUM);
    END;

    EXIT: PROCEDURE;
        DECLARE STATUS ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(9, .STATUS);
    END;

    DEBLANK: PROCEDURE(PTR) ADDRESS;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE (C = ' ');
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;

    DELIMIT: PROCEDURE(PTR) ADDRESS;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE (C = ':' OR C = '.' OR
                 ('0' <= C AND C <= '9') OR
                 ('A' <= C AND C <= 'Z'));
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;

    NUMOUT: PROCEDURE(VALUE, BASE, LC, BUFADR, WIDTH);
        DECLARE (VALUE, BUFADR) ADDRESS, (BASE, LC, WIDTH) BYTE; 
        DECLARE DIGITS DATA('0123456789ABCDEF');
        DECLARE I BYTE;
        DECLARE BUF BASED BUFADR (1) BYTE;

        DO I = 1 TO WIDTH;
            BUF(WIDTH - I) = DIGITS(VALUE MOD BASE);
            VALUE = VALUE / BASE;   
        END;

        I = 0;
        DO WHILE BUF(I) = '0' AND I < WIDTH - 1;
            BUF(I) = LC;
            I = I + 1;
        END;
    END;

    REPORTERROR: PROCEDURE(ERRNUM);
        DECLARE ERRNUM ADDRESS;
        DECLARE NUMBERBUFFER(4) BYTE, I ADDRESS, STATUS ADDRESS;
     

        DECLARE ERRMSG DATA(0, 0,
            2, 'ILLEGAL AFTN ARGUMENT', 0,
            4, 'INCORRECTLY SPECIFIED FILE', 0,
            5, 'UNRECOGNIZED DEVICE NAME', 0,
            6, 'ATTEMPT TO WRITE TO INPUT DEVICE', 0,
            8, 'ATTEMPT TO READ FROM OUTPUT DEVICE', 0,
            9, 'DIRECTORY FULL', 0,
            0AH, 'NOT ON SAME DISK', 0,
            0BH, 'FILE ALREADY EXISTS', 0,
            0CH, 'FILE IS ALREADY OPEN', 0,
            0DH, 'NO SUCH FILE', 0,
            0EH, 'WRITE PROTECTED', 0,
            0FH, 'LOAD TOO LOW', 0,
            10H, 'BAD LOAD FORMAT', 0,
            11H, 'NOT A DISK FILE', 0,
            12H, 'ILLEGAL ISIS COMMAND', 0,
            13H, 'ATTEMPTED SEEK ON NON-DISK FILE', 0,
            14H, 'ATTEMPTED BACK SEEK TO FAR', 0,
            16H, 'ILLEGAL ACCESS MODE TO OPEN', 0,
            17H, 'MISSING FILENAME', 0,
            19H, 'ILLEGAL ECHO FILE', 0,
            1AH, 'ILLEGAL ATTRIBUTE IDENTIFIER', 0,
            1BH, 'ILLEGAL SEEK COMMAND', 0,
            1CH, 'MISSING EXTENSION', 0,
            1FH, 'CAN', 27H, 'T SEEK ON WRITE ONLY FILE', 0,
            20H, 'CAN', 27H, 'T DELETE OPEN FILE', 0,
            23H, 'SEEK PAST EOF', 0,
            0C9H, 'UNRECOGNIZED SWITCH', 0,
            0CAH, 'UNRECOGNIZED DELIMITER', 0,
            0CBH, 'INVALID SYNTAX', 0,
            0CCH, 'PREMATURE EOF', 0,
            0CEH, 'ILLEGAL DISKETTE LABEL', 0,
            0D0H, 'CHECKSUM ERROR', 0
        );



        IF ERRNUM <> 0 THEN
        DO;
            I = 0;
            DO WHILE I < LENGTH(ERRMSG);
                IF ERRNUM = ERRMSG(I) AND ERRMSG(I + 1) <> 0 THEN
                DO;
                    I = I + 1;
                    CALL WRITE(0, .(' '), 1, .STATUS);
                    DO WHILE ERRMSG(I) <> 0;
                        CALL WRITE(0, .ERRMSG(I), 1, .STATUS);
                        I = I + 1;
                    END;
                    CALL WRITE(0, .(0DH, 0AH), 2, .STATUS);
                    return;
                END;
                ELSE
                DO;
                    DO WHILE ERRMSG(I) <> 0;
                        I = I + 1;
                    END;
                    I = I + 1;
                END;
            end;
            CALL ERROR(ERRNUM);
        END;
    END;

    DECLARE (STATUS, ACTUAL) ADDRESS;
    DECLARE BUFFER(128) BYTE;
    DECLARE BUFPTR ADDRESS, CH BASED BUFPTR BYTE;

MAIN:
    CALL READ(1, .BUFFER, 128, .ACTUAL, .STATUS);
    IF STATUS <> 0 THEN DO;
        CALL REPORTERROR(STATUS);
        CALL EXIT;
    END;

    BUFPTR = DEBLANK(.BUFFER);

    DO WHILE 1;
        ACTUAL = DELIMIT(BUFPTR) - BUFPTR;
        CALL WRITE(0, .(' '), 1, .STATUS);
        CALL WRITE(0, BUFPTR, ACTUAL, .STATUS);
        CALL WRITE(0, .(', '), 2, .STATUS);
        CALL DELETE(BUFPTR, .STATUS);
        IF STATUS <> 0 THEN
            CALL REPORTERROR(STATUS);
        ELSE
            CALL WRITE(0, .('DELETED', CR, LF), 9, .STATUS);
        BUFPTR = DEBLANK(DELIMIT(BUFPTR));
        IF CH = CR THEN
            CALL EXIT;
        IF CH = ',' THEN
            BUFPTR = DEBLANK(BUFPTR + 1);
        ELSE DO;
            CALL REPORTERROR(0CBH);
            CALL EXIT;
        END;
    END;
END;
EOF
dir.plm
3400H:
DO;
    DECLARE TRUE    LITERALLY '0FFH',
            FALSE   LITERALLY '0',
            CR      LITERALLY '0DH',
            LF      LITERALLY '0AH';

    DECLARE VER DATA(1, 9);
    DECLARE COPYRIGNT DATA('(C) 1975,1976 INTEL CORP');

    ISIS: PROCEDURE(CMD, PARAM$P);
        DECLARE CMD BYTE, PARAM$P ADDRESS;
        GOTO 40H;
    END ISIS;

    OPEN: PROCEDURE(CONN$P, PATH$P, ACCESS, ECHO, STATUS$P);
        DECLARE (CONN$P, PATH$P, ACCESS, ECHO, STATUS$P) ADDRESS;

        CALL ISIS(0, .CONN$P);
    END;

    READ: PROCEDURE(CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P) ADDRESS;

        CALL ISIS(3, .CONN);
    END;

    WRITE: PROCEDURE(CONN, BUFF$P, COUNT, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, STATUS$P) ADDRESS;

        CALL ISIS(4, .CONN);
    END;

    CLOSE: PROCEDURE(CONN, STATUS$P);
        DECLARE (CONN, STATUS$P) ADDRESS;

        CALL ISIS(1, .CONN);
    END;

    ERROR: PROCEDURE(ERROR$NUM);
        DECLARE (ERROR$NUM, STATUS) ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(12, .ERROR$NUM);
    END;

    EXIT: PROCEDURE;
        DECLARE STATUS ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(9, .STATUS);
    END;

    DEBLANK: PROCEDURE(PTR) ADDRESS;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE (C = ' ');
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;

    DELIMIT: PROCEDURE(PTR) ADDRESS;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE (C = ':' OR C = '.' OR
                 ('0' <= C AND C <= '9') OR
                 ('A' <= C AND C <= 'Z'));
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;

    NUMOUT: PROCEDURE(VALUE, BASE, LC, BUFADR, WIDTH);
        DECLARE (VALUE, BUFADR) ADDRESS, (BASE, LC, WIDTH) BYTE; 
        DECLARE DIGITS DATA('0123456789ABCDEF');
        DECLARE I BYTE;
        DECLARE BUF BASED BUFADR (1) BYTE;

        DO I = 1 TO WIDTH;
            BUF(WIDTH - I) = DIGITS(VALUE MOD BASE);
            VALUE = VALUE / BASE;   
        END;

        I = 0;
        DO WHILE BUF(I) = '0' AND I < WIDTH - 1;
            BUF(I) = LC;
            I = I + 1;
        END;
    END;

    REPORTERROR: PROCEDURE(ERRNUM);
        DECLARE ERRNUM ADDRESS;
        DECLARE NUMBERBUFFER(4) BYTE, I ADDRESS, STATUS ADDRESS;
     

        DECLARE ERRMSG DATA(0, 0,
            2, 'ILLEGAL AFTN ARGUMENT', 0,
            4, 'INCORRECTLY SPECIFIED FILE', 0,
            5, 'UNRECOGNIZED DEVICE NAME', 0,
            6, 'ATTEMPT TO WRITE TO INPUT DEVICE', 0,
            8, 'ATTEMPT TO READ FROM OUTPUT DEVICE', 0,
            9, 'DIRECTORY FULL', 0,
            0AH, 'NOT ON SAME DISK', 0,
            0BH, 'FILE ALREADY EXISTS', 0,
            0CH, 'FILE IS ALREADY OPEN', 0,
            0DH, 'NO SUCH FILE', 0,
            0EH, 'WRITE PROTECTED', 0,
            0FH, 'LOAD TOO LOW', 0,
            10H, 'BAD LOAD FORMAT', 0,
            11H, 'NOT A DISK FILE', 0,
            12H, 'ILLEGAL ISIS COMMAND', 0,
            13H, 'ATTEMPTED SEEK ON NON-DISK FILE', 0,
            14H, 'ATTEMPTED BACK SEEK TO FAR', 0,
            16H, 'ILLEGAL ACCESS MODE TO OPEN', 0,
            17H, 'MISSING FILENAME', 0,
            19H, 'ILLEGAL ECHO FILE', 0,
            1AH, 'ILLEGAL ATTRIBUTE IDENTIFIER', 0,
            1BH, 'ILLEGAL SEEK COMMAND', 0,
            1CH, 'MISSING EXTENSION', 0,
            1FH, 'CAN', 27H, 'T SEEK ON WRITE ONLY FILE', 0,
            20H, 'CAN', 27H, 'T DELETE OPEN FILE', 0,
            23H, 'SEEK PAST EOF', 0,
            0C9H, 'UNRECOGNIZED SWITCH', 0,
            0CAH, 'UNRECOGNIZED DELIMITER', 0,
            0CBH, 'INVALID SYNTAX', 0,
            0CCH, 'PREMATURE EOF', 0,
            0CEH, 'ILLEGAL DISKETTE LABEL', 0,
            0D0H, 'CHECKSUM ERROR', 0
        );



        IF ERRNUM <> 0 THEN
        DO;
            I = 0;
            DO WHILE I < LENGTH(ERRMSG);
                IF ERRNUM = ERRMSG(I) AND ERRMSG(I + 1) <> 0 THEN
                DO;
                    I = I + 1;
                    CALL WRITE(0, .(' '), 1, .STATUS);
                    DO WHILE ERRMSG(I) <> 0;
                        CALL WRITE(0, .ERRMSG(I), 1, .STATUS);
                        I = I + 1;
                    END;
                    CALL WRITE(0, .(0DH, 0AH), 2, .STATUS);
                    return;
                END;
                ELSE
                DO;
                    DO WHILE ERRMSG(I) <> 0;
                        I = I + 1;
                    END;
                    I = I + 1;
                END;
            end;
            CALL ERROR(ERRNUM);
        END;
    END;

    UNPATH: PROCEDURE(DIR$P, FILENAME$P);
        DECLARE (DIR$P, FILENAME$p) ADDRESS;
        DECLARE FILENAME BASED FILENAME$P (1) BYTE;
        DECLARE DIR BASED DIR$P (1) BYTE;
        DECLARE I BYTE;

        FILENAME(0) = ':';
        FILENAME(1) = 'F';
        FILENAME(3) = ':';
        IF DIR(0) = 0 THEN
            FILENAME(2) = '0';
        ELSE
            FILENAME(2) = '1';
        FILENAME$P = FILENAME$P + 4;
        DO I = 0 TO 5;
            if (FILENAME(0) := DIR(I + 1)) <> 0 THEN
                FILENAME$P = FILENAME$P + 1;
        END;
        IF DIR(7) <> 0 THEN DO;
            FILENAME(0) = '.';
            FILENAME$P = FILENAME$P + 1;
        END; 
        DO I = 0 TO 2;
            if (FILENAME(0) := DIR(I + 7)) <> 0 THEN
                FILENAME$P = FILENAME$P + 1;
        END;
        FILENAME(0) = ' ';
    END; 


    /* READ IN DIRECTORY ENTRY */
    DECLARE DIRECT$STATUS BYTE,
            DIRECT$NAME(6) BYTE,
            DIRECT$EXT(3) BYTE,
            DIRECT$ATTRIB BYTE,
            DIRECT$EOF$CNT BYTE,
            DIRECT$BLKCNT ADDRESS,
            DIRECT$HDRBLK ADDRESS;
    DECLARE PADDING(2) BYTE;
    

    LISTDIR: PROCEDURE(DRIVE, AFTOUT, FASTOUTPUT, LISTINVISIBLE);
        DECLARE (DRIVE, AFTOUT, FASTOUTPUT, LISTINVISIBLE) BYTE;
        DECLARE (AFT, STATUS, ACTUAL, PAD, USED) ADDRESS;

        DECLARE (HIFSIZE, LOFSIZE, BLKTOTAL) ADDRESS;
        DECLARE BUF(15) BYTE;
        DECLARE ISISLAB(13) BYTE INITIAL(':F :ISIS.LAB ');
        DECLARE ISISDIR(13) BYTE INITIAL(':F :ISIS.DIR ');
        DECLARE CRLF(2) BYTE INITIAL(CR, LF);
        DECLARE NAME(15) BYTE, I BYTE, NAMEPART BYTE;

        ADDTOTAL: PROCEDURE(DELTA);
            DECLARE DELTA ADDRESS;
            IF (LOFSIZE := LOFSIZE + DELTA) > 9999 THEN DO;
                LOFSIZE = LOFSIZE - 10000;
                HIFSIZE = HIFSIZE + 1;
            END;
            
        END;

        BLKTOTAL = 0;
        ISISLAB(2), ISISDIR(2) = DRIVE + '0';
        CALL OPEN(.AFT, .ISISLAB, 1, 0, .STATUS);
        BUF(0) = DRIVE;
        CALL READ(AFT, .BUF + 1, 9, .ACTUAL, .STATUS);
        CALL WRITE(AFTOUT, .('DIRECTORY OF '), 13, .STATUS);
        CALL UNPATH(.BUF, .NAME);
        I = DELIMIT(.NAME) - .NAME;
        CALL WRITE(AFTOUT, .NAME, I, .STATUS);
        CALL WRITE(AFTOUT, .(CR, LF), 2, .STATUS);
        CALL CLOSE(AFT, .STATUS);

        IF NOT FASTOUTPUT THEN
            CALL WRITE(AFTOUT, .('NAME  .EXT BLKS   LENGTH ATTR', CR, LF),
                                                                    31, .STATUS);
     
        
        CALL OPEN(.AFT, .ISISDIR, 1, 0, .STATUS);
        ACTUAL = 16;
        DIRECT$STATUS = 10H;
       
        DO WHILE ACTUAL = 16 AND DIRECT$STATUS <> 7FH;
            CALL READ(AFT, .DIRECT$STATUS, 16, .ACTUAL, .STATUS);
            IF ACTUAL = 16 AND NOT DIRECT$STATUS  
              AND ((DIRECT$ATTRIB AND 1) = 0 OR LISTINVISIBLE) THEN DO;
                DO I = 0 TO 8;
                    IF DIRECT$NAME(I) = 0 THEN
                        DIRECT$NAME(I) = ' ';
                END;
                I = 9;
                IF FASTOUTPUT THEN
                    DO WHILE DIRECT$NAME(I - 1) = ' ';
                        I = I - 1;
                    END;
                IF NOT FASTOUTPUT OR I > 6 THEN
                    NAMEPART = 6;
                ELSE
                    NAMEPART = I; 
                CALL WRITE(AFTOUT, .DIRECT$NAME, NAMEPART, .STATUS);
                IF FASTOUTPUT THEN DO;
                    IF I > 6 THEN DO;
                        CALL WRITE(AFTOUT, .('.'), 1, .STATUS);
                        CALL WRITE(AFTOUT, .DIRECT$EXT, I - 6, .STATUS);
                    END;
                END;
                ELSE DO;
                    IF DIRECT$EXT(0) <> ' ' THEN
                        CALL WRITE(AFTOUT, .('.'), 1, .STATUS);
                    CALL WRITE(AFTOUT, .DIRECT$EXT, 3, .STATUS);
                    IF DIRECT$EXT(0) = ' ' THEN
                        CALL WRITE(AFTOUT, .(' '), 1, .STATUS);

                    USED = DIRECT$BLKCNT;
                    IF USED > 0 THEN
                        USED = USED + (USED + 61) / 62;
                    ELSE
                        USED = 1;
                    BLKTOTAL = BLKTOTAL + USED;
                    CALL NUMOUT(USED, 10, ' ', .BUF, 5);
                    CALL WRITE(AFTOUT, .BUF, 5, .STATUS);
                    
                    USED = DIRECT$BLKCNT;
                    LOFSIZE = 0;
                    HIFSIZE = 0;
                    IF USED > 0 THEN DO;
                        USED = USED - 1;
                        CALL ADDTOTAL(DIRECT$EOF$CNT);
                        DO WHILE USED > 0;
                            USED = USED - 1;
                            CALL ADDTOTAL(128);
                        END;
                    END;
                    IF HIFSIZE <> 0 THEN DO;
                        CALL NUMOUT(HIFSIZE, 10, ' ', .BUF, 5);
                        CALL NUMOUT(LOFSIZE, 10, '0', .BUF(5), 4);
                    END;
                    ELSE
                        CALL NUMOUT(LOFSIZE, 10, ' ', .BUF, 9);
                    CALL WRITE(AFTOUT, .BUF, 9, .STATUS);

                    IF DIRECT$ATTRIB <> 0 THEN DO;
                        DO I = 0 TO 4;
                            BUF(I) = ' ';
                        END;
                        IF (DIRECT$ATTRIB AND 4) <> 0 THEN
                            BUF(1) = 'W';
                        IF (DIRECT$ATTRIB AND 2) <> 0 THEN
                            BUF(2) = 'S';
                        IF (DIRECT$ATTRIB AND 1) <> 0 THEN
                            BUF(3) = 'I';
                        IF (DIRECT$ATTRIB AND 80H) <> 0 THEN
                            BUF(4) = 'F';
                        CALL WRITE(AFTOUT, .BUF, 5, .STATUS);
                    END; 
                END;
                CALL WRITE(AFTOUT, .CRLF, 2, .STATUS);
            END;
        END;
        IF NOT FASTOUTPUT THEN DO;
            CALL NUMOUT(BLKTOTAL, 10, ' ', .BUF, 15);
            CALL WRITE(AFTOUT, .BUF, 15, .STATUS);
            CALL WRITE(AFTOUT, .CRLF, 2, .STATUS);
        END;
        CALL CLOSE(AFTOUT, .STATUS);
    END;


    SEQ: PROCEDURE(S1, S2, CNT) BYTE;
        DECLARE (S1,S2) ADDRESS, CNT BYTE;
        DECLARE S1A BASED S1(1) BYTE;
        DECLARE S2A BASED S2(1) BYTE;
        DECLARE I BYTE;
        CNT = CNT - 1;
        DO I = 0 TO CNT;
            IF S1A(I) <> S2A(I) THEN
                RETURN 0;
        END;
        RETURN 0FFH;
    END;





    DECLARE (AFTOUT, ACTUAL, STATUS) ADDRESS;
    DECLARE PAD BYTE,
            DRIVE BYTE INITIAL(0),
            LISTINVISIBLE BYTE INITIAL(FALSE),
            FASTOUTPUT BYTE INITIAL(FALSE);
    DECLARE BUFPTR ADDRESS, CH BASED BUFPTR BYTE;
    DECLARE BUFFER(128) BYTE;

MAIN:
    CALL READ(1, .BUFFER, 128, .ACTUAL, .STATUS);
    BUFPTR = DEBLANK(.BUFFER);
    AFTOUT = 0;
    IF SEQ(.('TO'), BUFPTR, 2) THEN DO;
        BUFPTR = DEBLANK(BUFPTR + 2);
        CALL OPEN(.AFTOUT, BUFPTR, 2, 0, .STATUS);
        IF STATUS <> 0 THEN DO;
            CALL REPORTERROR(STATUS);
            CALL EXIT;
        END;
        BUFPTR = DEBLANK(DELIMIT(BUFPTR));
    END;
    DO WHILE CH = '$';
        BUFPTR = BUFPTR + 1;
        IF CH = '1' THEN
            DRIVE = 1;
        ELSE IF CH = 'I' THEN
            LISTINVISIBLE = TRUE;
        ELSE IF CH = 'F' THEN
            FASTOUTPUT = TRUE;
        ELSE DO;
            CALL REPORTERROR(0C9H);
            CALL EXIT;
        END;
        BUFPTR = DEBLANK(DELIMIT(BUFPTR));
    END;
    IF CH <> CR THEN DO;
        CALL REPORTERROR(0C9H);
        CALL EXIT;
    END;
    CALL LISTDIR(DRIVE, AFTOUT, FASTOUTPUT, LISTINVISIBLE);
    CALL EXIT; 
         

END;
EOF
edit.plm
3300H:

DECLARE LIT LITERALLY 'LITERALLY';
DECLARE BELL LIT '7',
        BS  LIT '8',
        TAB LIT '9',
        LF  LIT '0AH',
        VT  LIT '0BH',
        FF  LIT '0CH',
        CR  LIT '0DH',
        ESC LIT '1BH',
        DQUOTE LIT '22H',
        HASH LIT '23H';

DECLARE CTRLC   LIT '3',
        CTRLR   LIT '12h',
        CTRLX   LIT '18h',
        CTRLZ   LIT '1Ah',
        RUBOUT  LIT '7FH';

DECLARE ISALPHA LIT '0',
        ISNUMBER   LIT '1',
        ISOTHER lIT '2';

DECLARE TRUE    LIT '0FFH',
        FALSE   LIT '0',
        OK      LIT '0',
        BOOL    LIT 'BYTE';

/* ERROR CODES */
    DECLARE BAD$PATH LITERALLY '4',
            BAD$DEVICE LITERALLY '5',
            FILE$EXISTS LITERALLY '0BH',
            NO$SUCH$FILE LITERALLY '0DH',
            NULL$FILENAME LITERALLY '23',
            NULL$EXTENSION LITERALLY '28',
            BAD$SWITCH  LITERALLY '0C9H',
            BAD$SYNTAX  LITERALLY '0CBH';

    DECLARE BOOLEAN LITERALLY 'BYTE';
    DECLARE F1DEV LITERALLY '1';



DECLARE VERS DATA(2, 6),
        COPYRIGHT DATA('(C) 1973,1974,1975,1976 INTEL CORP');

DECLARE SIGNON DATA(CR, LF, 'ISIS TEXT EDITOR, V1.3', CR, LF);

DECLARE ILLEGAL DATA(DQUOTE, ' ILLEGAL IN THIS CONTEXT', CR, LF);
DECLARE NOTFOUND DATA(CR, LF, 'CANNOT FIND ');
DECLARE DQCHAR DATA(DQUOTE);    /* NOT ACTUALLY USED */
/* ONLY THE FIRST CHAR OF BEGIN PUNCH IS EVER USED */
DECLARE BEGINPUNCH DATA(CR, LF, CR, LF, 'START PUNCH, TYPE CHAR', CR, LF);
DECLARE ITERFAULT DATA(CR, LF, 'ITERATION STACK FAULT');

DECLARE USRBREAK DATA(CR, LF, '*BREAK*', CR, LF);
DECLARE NEWFILE DATA('NEW FILE', CR, LF);

DECLARE W4EBA ADDRESS,
        (TEXTPTR, ENDPTR) ADDRESS,
        (W4EC0, W4EC2) ADDRESS,
        (CMDCNT, W37D6, W4EC8) ADDRESS,
        MEMSIZE ADDRESS,
        (CHAR, CHTYPE, BACKWARDS, CURCOL) BYTE,
        (ITER$SP, B4ED1, B37E2) BYTE,
        FINDLEN BYTE;
DECLARE INBUF(128) BYTE,
        INACTUAL ADDRESS,
        INPTR ADDRESS,
        ACTUAL ADDRESS,
        STATUS ADDRESS,
        (AFTIN, AFTOUT) ADDRESS,
        PAD3870(3) BYTE,
        MODE BYTE,
        (INPUT$PTR, BUFFER$PTR, OUTPUT$PTR) ADDRESS,
        W4F6A ADDRESS,
        PAD37C BYTE,
        BUFFER(128) BYTE,
        BA4FED(16) BYTE,
        FINDBUF(17) BYTE,
        ITER$STACK$PTR(8) ADDRESS,
        ITER$STACK$CNT(8) ADDRESS;


DECLARE BREAK LABEL;

    CI: PROCEDURE BYTE;
        GOTO 0F803H;
    END;

    CO: PROCEDURE(C);
        DECLARE C BYTE;
        GOTO 0F809H;
    END;

	CSTS: PROCEDURE BYTE;
		GOTO 0F812H;
	END;

    IOCHK: PROCEDURE BYTE;
        GOTO 0F815H;
    END;

    MEMCHK: PROCEDURE ADDRESS;
        GOTO 0F81BH;
    END;

    ISIS: PROCEDURE(CMD, PARAM$P);
        DECLARE CMD BYTE, PARAM$P ADDRESS;
        GOTO 40H;
    END ISIS;

    READ: PROCEDURE(CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P) ADDRESS;

        CALL ISIS(3, .CONN);
    END;

    WRITE: PROCEDURE(CONN, BUFF$P, COUNT, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, STATUS$P) ADDRESS;

        CALL ISIS(4, .CONN);
    END;

    EXIT: PROCEDURE;
        DECLARE STATUS ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(9, .STATUS);
    END;

    OPEN: PROCEDURE(CONN$P, PATH$P, ACCESS, ECHO, STATUS$P);
        DECLARE (CONN$P, PATH$P, ACCESS, ECHO, STATUS$P) ADDRESS;

        CALL ISIS(0, .CONN$P);
    END;

    CLOSE: PROCEDURE(CONN, STATUS$P);
        DECLARE (CONN, STATUS$P) ADDRESS;

        CALL ISIS(1, .CONN);
    END;

    DELETE: PROCEDURE (PATH$P, STATUS$P);
        DECLARE (PATH$P, STATUS$P) ADDRESS;

        CALL ISIS(2, .PATH$P);
    END DELETE;

	RENAME: PROCEDURE(OLD$P, NEW$P, STATUS$P);
    	DECLARE (OLD$P, NEW$P, STATUS$P) ADDRESS;
    	
    	CALL ISIS(7, .OLD$P);
	END;

    ERROR: PROCEDURE(ERROR$NUM);
        DECLARE (ERROR$NUM, STATUS) ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(12, .ERROR$NUM);
    END;

    SEQ: PROCEDURE(S1, S2, CNT) BYTE;
        DECLARE (S1,S2) ADDRESS, CNT BYTE;
        DECLARE S1A BASED S1(1) BYTE;
        DECLARE S2A BASED S2(1) BYTE;
        DECLARE I BYTE;
        CNT = CNT - 1;
        DO I = 0 TO CNT;
            IF S1A(I) <> S2A(I) THEN
                RETURN 0;
        END;
        RETURN 0FFH;
    END;

    NUMOUT: PROCEDURE(VALUE, BASE, LC, BUFADR, WIDTH);
        DECLARE (VALUE, BUFADR) ADDRESS, (BASE, LC, WIDTH) BYTE; 
        DECLARE DIGITS DATA('0123456789ABCDEF');
        DECLARE I BYTE;
        DECLARE BUF BASED BUFADR (1) BYTE;

        DO I = 1 TO WIDTH;
            BUF(WIDTH - I) = DIGITS(VALUE MOD BASE);
            VALUE = VALUE / BASE;   
        END;

        I = 0;
        DO WHILE BUF(I) = '0' AND I < WIDTH - 1;
            BUF(I) = LC;
            I = I + 1;
        END;
    END;

    REPORTERROR: PROCEDURE(ERRNUM);
        DECLARE ERRNUM ADDRESS;
        DECLARE NUMBERBUFFER(4) BYTE, I ADDRESS, STATUS ADDRESS;
     

        DECLARE ERRMSG DATA(0, 0,
            2, 'ILLEGAL AFTN ARGUMENT', 0,
            4, 'INCORRECTLY SPECIFIED FILE', 0,
            5, 'UNRECOGNIZED DEVICE NAME', 0,
            6, 'ATTEMPT TO WRITE TO INPUT DEVICE', 0,
            8, 'ATTEMPT TO READ FROM OUTPUT DEVICE', 0,
            9, 'DIRECTORY FULL', 0,
            0AH, 'NOT ON SAME DISK', 0,
            0BH, 'FILE ALREADY EXISTS', 0,
            0CH, 'FILE IS ALREADY OPEN', 0,
            0DH, 'NO SUCH FILE', 0,
            0EH, 'WRITE PROTECTED', 0,
            0FH, 'LOAD TOO LOW', 0,
            10H, 'BAD LOAD FORMAT', 0,
            11H, 'NOT A DISK FILE', 0,
            12H, 'ILLEGAL ISIS COMMAND', 0,
            13H, 'ATTEMPTED SEEK ON NON-DISK FILE', 0,
            14H, 'ATTEMPTED BACK SEEK TO FAR', 0,
            16H, 'ILLEGAL ACCESS MODE TO OPEN', 0,
            17H, 'MISSING FILENAME', 0,
            19H, 'ILLEGAL ECHO FILE', 0,
            1AH, 'ILLEGAL ATTRIBUTE IDENTIFIER', 0,
            1BH, 'ILLEGAL SEEK COMMAND', 0,
            1CH, 'MISSING EXTENSION', 0,
            1FH, 'CAN', 27H, 'T SEEK ON WRITE ONLY FILE', 0,
            20H, 'CAN', 27H, 'T DELETE OPEN FILE', 0,
            23H, 'SEEK PAST EOF', 0,
            0C9H, 'UNRECOGNIZED SWITCH', 0,
            0CAH, 'UNRECOGNIZED DELIMITER', 0,
            0CBH, 'INVALID SYNTAX', 0,
            0CCH, 'PREMATURE EOF', 0,
            0CEH, 'ILLEGAL DISKETTE LABEL', 0,
            0D0H, 'CHECKSUM ERROR', 0
        );



        IF ERRNUM <> 0 THEN
        DO;
            I = 0;
            DO WHILE I < LENGTH(ERRMSG);
                IF ERRNUM = ERRMSG(I) AND ERRMSG(I + 1) <> 0 THEN
                DO;
                    I = I + 1;
                    CALL WRITE(0, .(' '), 1, .STATUS);
                    DO WHILE ERRMSG(I) <> 0;
                        CALL WRITE(0, .ERRMSG(I), 1, .STATUS);
                        I = I + 1;
                    END;
                    CALL WRITE(0, .(0DH, 0AH), 2, .STATUS);
                    return;
                END;
                ELSE
                DO;
                    DO WHILE ERRMSG(I) <> 0;
                        I = I + 1;
                    END;
                    I = I + 1;
                END;
            end;
            CALL ERROR(ERRNUM);
        END;
    END;

    DEBLANK: PROCEDURE(PTR) ADDRESS;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE (C = ' ');
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;

    DELIMIT: PROCEDURE(PTR) ADDRESS;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE (C = ':' OR C = '.' OR
                 ('0' <= C AND C <= '9') OR
                 ('A' <= C AND C <= 'Z'));
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;

    FILE$ERROR: PROCEDURE(STATUS, PTR, CALLEXIT);
        DECLARE (STATUS, PTR) ADDRESS, CALLEXIT BYTE;
        DECLARE ERR$STATUS ADDRESS;

        IF STATUS <> 0 THEN
        DO;
            PTR = DEBLANK(PTR);
            CALL WRITE(0, .(' '), 1, .ERR$STATUS);
            CALL WRITE(0, PTR, DELIMIT(PTR) - PTR, .ERR$STATUS);
            CALL WRITE(0, .(','), 1, .ERR$STATUS);
            CALL REPORTERROR(STATUS);
            IF CALLEXIT THEN
                CALL EXIT;
        END;
    END;

    DECLARE FULLNAME(15) BYTE;
    DECLARE DEVICENAMES(21) ADDRESS INITIAL (
        'F0','F1','TI','TO','VI','VO','I1','O1','TR','HR',
        'R1','R2','TP','HP','P1','P2','LP','L1','CI','CO','BB');
    DECLARE (PN, PN2) (10) BYTE;

    CANON: PROCEDURE(FILENAME, INTFN$P) BYTE;
        DECLARE (FILENAME, INTFN$P) ADDRESS;
        DECLARE PATHCH BASED FILENAME BYTE; /* CHAR OF FILENAME POINTS TO */
        DECLARE PATHCHARS BASED FILENAME (1) BYTE;
        DECLARE INTFN BASED INTFN$P (10) BYTE;  /* BYTE VERSION OF INTFN  */
        DECLARE STARTNAME ADDRESS, STARTCH BASED STARTNAME BYTE;
        DECLARE DEVPAIR(0) ADDRESS, (SECOND, FIRST) BYTE;
        DECLARE (J, I) BYTE;


        ALPHANUM: PROCEDURE BOOLEAN;
            RETURN (PATHCH >= 'A' AND PATHCH <= 'Z')
                OR (PATHCH >= '0' AND PATHCH <= '9');
        END;


        DO I = 0 TO LAST(INTFN);    /* CLEAR INTFN */
            INTFN(I) = 0;
        END;
        DO WHILE PATHCH = ' ';  /* SKIP LEADING SPACE */
            FILENAME = FILENAME + 1;
        END;
        STARTNAME = FILENAME;
        IF PATHCH = ':' THEN
        DO;
            INTFN(0) = 0FFH;
            FIRST = PATHCHARS(1);
            SECOND = PATHCHARS(2);
            IF PATHCHARS(3) <> ':' THEN
                RETURN BAD$PATH;

            DO I =  0 TO LAST(DEVICENAMES);
                IF DEVICENAMES(I) = DEVPAIR(0) THEN 
                    INTFN(0) = I;   /* SAVE DEVICE NUMBER */
            END;
            IF INTFN(0) = 0FFH THEN
                RETURN BAD$DEVICE;
            FILENAME = FILENAME + 4;
        END;

        FIRST = 0;
        DO I = 1 TO 6;
            IF ALPHANUM THEN
            DO;
                INTFN(I) = PATHCH;
                FIRST = 1;
                FILENAME = FILENAME + 1;
            END;
        END;
        IF PATHCH = '.' THEN
        DO;
            FILENAME = FILENAME + 1;
            DO I = 7 TO 9;
                IF ALPHANUM THEN
                DO;
                    INTFN(I) = PATHCH;
                    FILENAME = FILENAME + 1;
                END;
            END;
        END;
        IF INTFN(0) <= F1DEV AND FIRST = 0 THEN
            RETURN NULL$FILENAME;
        J =  -1;
        DO WHILE STARTNAME < FILENAME;
            J = J + 1;
            FULLNAME(J) = STARTCH;
            STARTNAME = STARTNAME + 1;
        END;
        IF FULLNAME(J) = '.' THEN
            RETURN NULL$EXTENSION;
        FULLNAME(J + 1) = ' ';
        IF ALPHANUM  OR PATHCH = '.' OR PATHCH = ':' THEN
            RETURN BAD$PATH;
        RETURN OK;
    END;

    UNPATH: PROCEDURE(DIR$P, FILENAME$P);
        DECLARE (DIR$P, FILENAME$p) ADDRESS;
        DECLARE FILENAME BASED FILENAME$P (1) BYTE;
        DECLARE DIR BASED DIR$P (1) BYTE;
        DECLARE I BYTE;

        FILENAME(0) = ':';
        FILENAME(1) = 'F';
        FILENAME(3) = ':';
        IF DIR(0) = 0 THEN
            FILENAME(2) = '0';
        ELSE
            FILENAME(2) = '1';
        FILENAME$P = FILENAME$P + 4;
        DO I = 0 TO 5;
            if (FILENAME(0) := DIR(I + 1)) <> 0 THEN
                FILENAME$P = FILENAME$P + 1;
        END;
        IF DIR(7) <> 0 THEN DO;
            FILENAME(0) = '.';
            FILENAME$P = FILENAME$P + 1;
        END; 
        DO I = 0 TO 2;
            if (FILENAME(0) := DIR(I + 7)) <> 0 THEN
                FILENAME$P = FILENAME$P + 1;
        END;
        FILENAME(0) = ' ';
    END;


    GETCHAR: PROCEDURE BYTE;
        RETURN CI AND 7FH;
    END;

    DISPLAYCHAR: PROCEDURE(CH);
        DECLARE (CH, SPACES, I) BYTE;

        SPACES = CH = TAB AND (7 - (CURCOL AND 7));
        IF CH = TAB THEN
            CH = ' ';
        DO I = 0 TO SPACES;
            IF CH = CR THEN
                CURCOL = 0;
            IF CH = FF THEN
                CH = 21H;  /* EXCLAMATION MARK */
            IF CH = ESC OR CH = 07DH THEN
                CH = '$';
            IF CH >= ' ' THEN
                CURCOL = CURCOL + 1;
            CALL CO(CH);
        END;
    END;


    DISPLAYTEXT: PROCEDURE(STR$P,  LEN);
        DECLARE (STR$P, LEN, I) ADDRESS;
        DECLARE STR BASED STR$P (1) BYTE;

        DO I = 0 TO LEN;
            CALL DISPLAYCHAR(STR(I));
            IF CSTS AND (IOCHK AND 0FCH) <> 2 THEN
                IF GETCHAR = 3 THEN DO;
                    GOTO BREAK;
                END;
        END;
    END;
                
    GETC: PROCEDURE BYTE;
        IF INPTR >= INACTUAL THEN DO;
            CALL READ(AFTIN, .INBUF, 128, .INACTUAL, .STATUS);
            CALL FILEERROR(STATUS, INPUT$PTR, TRUE);
            IF INACTUAL < 128 THEN
                INBUF(INACTUAL) = CTRLZ;
            INPTR = 0;
        END;
        INPTR = INPTR + 1;
        RETURN INBUF(INPTR - 1) AND 7FH;
    END;

    MOVEUP: PROCEDURE;
        DECLARE DSTIDX ADDRESS;

        IF ITER$SP <> 0 THEN
            RETURN;
        DSTIDX = MEMSIZE - 1;

        DO WHILE W4EC8 >= W4EBA;
            MEMORY(DSTIDX) = MEMORY(W4EC8);
            DSTIDX = DSTIDX - 1;
            W4EC8 = W4EC8 - 1;
        END;
        W4EBA = DSTIDX + 1;
        W4EC8 = MEMSIZE - 1;
    END;

    /* GET TEXT INTO MEMORY UNTIL ESC ESC */
    /* NOTE TEXT IS COLLECTED BACKWARDS FROM TOP OF MEMORY */
    GETTEXT: PROCEDURE;
        DECLARE (INCH, PREVINCH) BYTE;
        DECLARE IDX ADDRESS;

        DO WHILE 1;
            B4ED1 = FALSE;
            W4EBA = MEMSIZE;
            W4EC8 = MEMSIZE - 1;
            PREVINCH = FALSE;
            ITER$SP = 0;
            CALL DISPLAYCHAR('*');
            INCH = GETCHAR;

            DO WHILE INCH <> CTRLC;    /* 3EDB */
                DO WHILE INCH = RUBOUT;
                    IF W4EBA <> MEMSIZE THEN DO;
                        IF (INCH := MEMORY(W4EBA)) = ESC THEN
                            INCH = '$';
                        CALL DISPLAYCHAR(INCH);
                        W4EBA = W4EBA + 1;
                        INCH = GETCHAR;
                        PREVINCH = 0;
                    END;
                    ELSE DO;
                        INCH = 3;
                        CALL DISPLAYCHAR(BELL);
                    END;
                END;
                IF INCH = CTRLX THEN DO;
                    CALL DISPLAYCHAR(HASH);
                    CALL DISPLAYTEXT(.BEGINPUNCH, 1);
                    DO WHILE W4EBA <> MEMSIZE AND MEMORY(W4EBA) <> LF;
                        W4EBA = W4EBA + 1;
                    END;
                    INCH = GETCHAR;
                END;
                ELSE IF INCH = CTRLR THEN DO;
                    CALL DISPLAYTEXT(.BEGINPUNCH, 1);
                    IDX = W4EBA;
                    DO WHILE IDX < MEMSIZE AND MEMORY(IDX) <> LF;
                        IDX = IDX + 1;
                    END;
                    DO WHILE IDX <> W4EBA;
                        CALL DISPLAYCHAR(MEMORY(IDX := IDX - 1));
                    END;
                    INCH = GETCHAR;
                END;
                ELSE IF ENDPTR >= W4EBA - 10 THEN DO;
                    INCH = GETCHAR;
                    CALL DISPLAYCHAR(BELL);
                END;
                ELSE DO;
                    IF INCH = CR THEN DO;
                        MEMORY(W4EBA := W4EBA - 1) = CR;
                        CALL DISPLAYCHAR(CR);
                        INCH = LF;
                    END;
                    IF INCH  <> 3 THEN DO;
                        IF INCH = 7DH THEN
                            INCH = ESC;
                        IF INCH = ESC THEN
                            CALL DISPLAYCHAR('$');
                        ELSE
                            CALL DISPLAYCHAR(INCH);
                        MEMORY(W4EBA := W4EBA - 1) = INCH;
                        IF INCH = ESC and PREVINCH = ESC THEN DO;
                            CALL DISPLAYTEXT(.BEGINPUNCH, 1);
                            RETURN;
                        END;
                        PREVINCH = INCH;
                        INCH = GETCHAR;                   
                    END;
                END; /* 2982 */
            END;
            CALL  DISPLAYTEXT(.BEGINPUNCH, 1);
        END;    /* WHILE 1 */
    END;

    GETCMDCH: PROCEDURE BYTE;
        DECLARE CH BYTE;

        IF W4EC8 < W4EBA THEN
            CALL GETTEXT;
        IF CSTS AND (IOCHK AND 0FCH) <> 2 THEN
            IF GETCHAR = 3 THEN
                CALL GETTEXT;
        CHTYPE = ISOTHER;
        CH = MEMORY(W4EC8); 
        IF CH >= 'A' AND CH <= 'Z' THEN
            CHTYPE = ISALPHA;
        IF (CH >= '0' AND CH <= '9') OR CH = '+' OR CH = '-' THEN
            CHTYPE = ISNUMBER;
        W4EC8 = W4EC8 - 1;
        RETURN CH;
     END;

    GETCMDNUM: PROCEDURE ADDRESS;
        DECLARE VAL ADDRESS;
        IF CHAR = '-' THEN DO;
            BACKWARDS = TRUE;
            CHAR = GETCMDCH;
        END;
        ELSE IF CHAR = '+' THEN
            CHAR = GETCMDCH;
        VAL =  0;
        DO WHILE CHTYPE = ISNUMBER;
            /* VAL = VAL * 10 + CHAR - '0' */
            VAL = SHL(SHL(VAL, 2) + VAL, 1) + CHAR - '0';
            CHAR = GETCMDCH;
        END;
        IF VAL = 0 AND BACKWARDS THEN
            RETURN 1;
        RETURN VAL;
    END;

    FINDREL: PROCEDURE ADDRESS;
        DECLARE START ADDRESS, (I, CH) BYTE;

        START = 0;
        DO WHILE MEMORY(TEXTPTR + START) <> 0FFH;
            I = 0;
            DO WHILE (CH := MEMORY(TEXTPTR + START + I)) = FINDBUF(I);
                IF FINDBUF(I + 1) = ESC THEN
                    RETURN START;
                I = I + 1;
            END;
            IF CH = 0FFH THEN
                RETURN 0FFFFH;
            START = START + 1;
        END;
        RETURN 0FFFFH;
    END;

    SEEKLINE: PROCEDURE ADDRESS;
        DECLARE STARTLINE ADDRESS, (JUNK, CH) BYTE;

        STARTLINE = TEXTPTR;
        IF CMDCNT = 0 OR BACKWARDS THEN DO;
            IF TEXTPTR = 1 THEN
                RETURN 1;
            IF TEXTPTR = ENDPTR  THEN
                STARTLINE = STARTLINE - 1;
            CMDCNT = CMDCNT + 1;
            DO WHILE CMDCNT <> 0 and TEXTPTR <> 1;
                IF (CH := MEMORY(STARTLINE)) = 0FFH THEN
                    RETURN STARTLINE + 1;
                IF CH = LF THEN
                    CMDCNT = CMDCNT - 1;
                STARTLINE = STARTLINE - 1;
            END;
            RETURN STARTLINE + 2;   /* AFTER THE MARKER */
        END;
        DO WHILE CMDCNT <> 0;
            IF (CH := MEMORY(STARTLINE)) = 0FFH THEN
                RETURN STARTLINE;
            IF CH = LF THEN
                CMDCNT = CMDCNT - 1;
            STARTLINE = STARTLINE + 1;
        END;
        RETURN STARTLINE;
    END;


    FINDLOC: PROCEDURE ADDRESS;
        DECLARE RELOFFSET ADDRESS;
 
        FINDLEN = 0;
        DO WHILE (FINDBUF(FINDLEN) := GETCMDCH) <> ESC;
            IF FINDLEN < 16 THEN
                FINDLEN = FINDLEN + 1;
        END;
        if (RELOFFSET := FINDREL) = 0FFFFH THEN DO;
            CALL DISPLAYTEXT(.NOTFOUND, 14);
            IF FINDLEN <> 0 THEN
                CALL DISPLAYTEXT(.FINDBUF, FINDLEN - 1);
            CALL CO(DQUOTE);
            CALL DISPLAYTEXT(.BEGINPUNCH, 1);
            GOTO BREAK;
        END;
        ELSE
            RETURN RELOFFSET + TEXTPTR;
    END;

    MOVEDOWN: PROCEDURE;
        ENDPTR = TEXTPTR;
        DO WHILE W4EC2 >= W4EC0;
            MEMORY(ENDPTR) = MEMORY(W4EC0);
            W4EC0 = W4EC0 + 1;
            ENDPTR = ENDPTR + 1;
        END;
        MEMORY(ENDPTR := ENDPTR - 1) = 0FFH;
        CALL MOVEUP;
    END;

MAIN:

    INPUT$PTR = .(':CI:');
    CALL READ(1, .BUFFER, 128, .ACTUAL, .STATUS);
    CALL FILEERROR(STATUS, INPUT$PTR, TRUE);
    BUFFER(ACTUAL) = CR;
    INPUT$PTR = DEBLANK(.BUFFER);
    BUFFER$PTR = DEBLANK(DELIMIT(INPUT$PTR));
    CALL DISPLAYTEXT(.SIGNON, 25);
    IF SEQ(BUFFER$PTR, .('TO'), 2) THEN DO;
        OUTPUT$PTR = DEBLANK(BUFFER$PTR + 2 );
        MODE = 2;
    END;
    ELSE DO;
        OUTPUT$PTR = INPUT$PTR;
        MODE = 1;
    END;

    STATUS = CANON(OUTPUT$PTR, .PN);
    IF STATUS <> 0 THEN
        CALL FILEERROR(STATUS, OUTPUT$PTR, TRUE);
    IF PN(0) > 1 THEN DO;
        IF MODE <> 2 THEN
            CALL FILEERROR(11H, OUTPUT$PTR, TRUE);
        BUFFER$PTR = OUTPUT$PTR;
    END;
    ELSE DO;
        IF PN(0) = 0 THEN
            BUFFER$PTR = .(':F0:EDIT.TMP ');
        IF PN(0) = 1 THEN
            BUFFER$PTR = .(':F1:EDIT.TMP ');
        IF MODE = 1 THEN DO;
            CALL RENAME(INPUT$PTR, INPUT$PTR, .STATUS);
            IF STATUS = 0BH THEN DO;
                PN(7) = 'B';
                PN(8) = 'A';
                PN(9) = 'K';
                CALL UNPATH(.PN, .BA4FED);
                W4F6A = .BA4FED;
            END;
            ELSE IF STATUS = 0DH THEN DO;
                MODE = 3;
                CALL DISPLAYTEXT(.NEWFILE, 9);
                INPUT$PTR = .(':BB: ');
            END;
            ELSE
                CALL FILEERROR(STATUS, INPUT$PTR, TRUE);
        END;
    END; /* 2F0E */

    CALL OPEN(.AFTIN, INPUT$PTR, 1, 0, .STATUS);
    CALL FILEERROR(STATUS, INPUT$PTR, TRUE);
    INPTR = INACTUAL;
    CALL OPEN(.AFTOUT, BUFFER$PTR, 2, 0, .STATUS);
    CALL FILEERROR(STATUS, BUFFER$PTR, TRUE);
    MEMSIZE = MEMCHK - .MEMORY;
    MEMORY(0) = 0FFH;
    MEMORY(1) = 0FFH;
    TEXTPTR = 1;
    ENDPTR = 1;
    CALL GETTEXT;

CMDLOOP:
    DO WHILE 1;
        W4EC0 = TEXTPTR;
        W4EC2 = ENDPTR;
        BACKWARDS = FALSE;
        CMDCNT = 1;
        CHAR = GETCMDCH;
        IF CHTYPE = ISNUMBER THEN
            CMDCNT = GETCMDNUM;
        IF CHAR = '<' THEN DO;
                IF (ITER$SP := ITER$SP + 1) > 8 THEN DO;
                    CALL DISPLAYTEXT(.ITERFAULT, 22);
                    GOTO BREAK;
                END;
                ITER$STACK$PTR(ITER$SP) = W4EC8;
                ITER$STACK$CNT(ITER$SP) = CMDCNT;
        END;
        ELSE IF CHAR = '>' AND ITER$SP <> 0 THEN DO;
            IF (ITER$STACK$CNT(ITER$SP) := ITER$STACK$CNT(ITER$SP) - 1) <> 0 THEN
                W4EC8 = ITER$STACK$PTR(ITER$SP);
            ELSE
                ITER$SP = ITER$SP - 1;
            GOTO CMDLOOP;
        END;
        ELSE IF CHTYPE = ISALPHA THEN DO;
            DO CASE CHAR - 'A';
                DO;             /* 'A' APPEND */
                    B37E2 = TRUE;
                    CMDCNT = 0;
                    DO WHILE B37E2;
                        if ENDPTR >= W4EBA - 10 OR B4ED1 THEN
                            B37E2 = 0;
                        ELSE IF (CHAR := GETC) <> CTRLZ THEN DO; 
                            IF CHAR <> 0 AND CHAR <> 7FH THEN DO;
                                IF CHAR = FF THEN
                                    B37E2 = 0;
                                MEMORY(ENDPTR) = CHAR;
                                ENDPTR = ENDPTR + 1;
                                IF CHAR = LF THEN
                                    IF (CMDCNT := CMDCNT + 1) = 50 THEN
                                        B37E2 = 0;
                            END;
                        END;
                        ELSE DO;
                            B4ED1 = 0FFH;
                            B37E2 = 0;
                        END;
                    END;
                    MEMORY(ENDPTR) = 0FFH;
                    GOTO CMDLOOP;
                END;
                DO;                 /* 'B' TEXT POINTER TO BEGINNING */
                    TEXTPTR = 1;
                    GOTO CMDLOOP;
                END;
                DO;                 /* 'C' TEXT POINTER CHARACTER */
                    IF BACKWARDS THEN DO;
                        IF TEXTPTR - 1 < CMDCNT THEN DO;
                            TEXTPTR = 1;
                            GOTO CMDLOOP;
                        END;
                        ELSE
                            TEXTPTR = TEXTPTR - CMDCNT;
                        GOTO CMDLOOP;
                    END;
                    ELSE IF (W37D6 := TEXTPTR + CMDCNT) > ENDPTR THEN
                        TEXTPTR = ENDPTR;
                    ELSE
                        TEXTPTR = W37D6;
                    GOTO CMDLOOP;
                END;
                DO;             /* 'D' DELETE */
                    IF BACKWARDS THEN DO;
                        IF TEXTPTR < CMDCNT THEN
                            TEXTPTR = 1;
                        ELSE
                            TEXTPTR = TEXTPTR - CMDCNT;
                    END;
                    ELSE IF (W37D6 := TEXTPTR + CMDCNT) > ENDPTR THEN
                        W4EC0 = ENDPTR;
                    ELSE
                        W4EC0 = W37D6;
                    CALL MOVEDOWN;
                    GOTO CMDLOOP;
                END;
                DO;         /* 'E' EXIT */
                    CALL WRITE(AFTOUT, .MEMORY + 1, ENDPTR - 1, .STATUS);
                    CALL FILEERROR(STATUS, BUFFER$PTR, TRUE);
                    DO WHILE INPTR < INACTUAL;
                        IF (CHAR := GETC) = CTRLZ THEN
                            INPTR = 128;
                        ELSE DO;
                            CALL WRITE(AFTOUT, .CHAR, 1, .STATUS);
                            CALL FILEERROR(STATUS, BUFFER$PTR, TRUE);
                        END;
                    END;

                    ACTUAL = MEMSIZE;
                    DO WHILE ACTUAL <> 0;
                        CALL READ(AFTIN, .MEMORY, MEMSIZE, .ACTUAL, .STATUS);
                        CALL FILEERROR(STATUS, INPUT$PTR, TRUE);
                        CALL WRITE(AFTOUT, .MEMORY, ACTUAL, .STATUS);
                        CALL FILEERROR(STATUS, BUFFER$PTR, TRUE);
                        IF ACTUAL < MEMSIZE THEN
                            ACTUAL = 0;
                    END;
                
                    CALL CLOSE(AFTOUT, .STATUS);
                    CALL FILEERROR(STATUS, BUFFER$PTR, TRUE);
                    CALL CLOSE(AFTIN, .STATUS);
                    CALL FILEERROR(STATUS, INPUT$PTR, TRUE);
                    IF PN(0) <= 1 THEN DO;  /* FILE BASED */
                        IF MODE = 1 THEN DO; 
                            CALL DELETE(W4F6A, .STATUS);
                            IF STATUS = 0EH THEN
                                CALL FILEERROR(STATUS, W4F6A, TRUE);
                            CALL RENAME(INPUT$PTR, W4F6A, .STATUS);
                            CALL FILEERROR(STATUS, INPUT$PTR, TRUE);
                        END;
                        CALL DELETE(OUTPUT$PTR, .STATUS);
                        IF STATUS = 0EH THEN
                            CALL FILEERROR(STATUS, OUTPUT$PTR, TRUE);
                        CALL RENAME(BUFFER$PTR, OUTPUT$PTR, .STATUS);
                        CALL FILEERROR(STATUS, OUTPUT$PTR, TRUE);
                    END;
                    CALL EXIT;
                    GOTO CMDLOOP;
                END;
                DO;             /* 'F' FIND */
                    TEXTPTR = FINDLOC + FINDLEN;
                    GOTO CMDLOOP;
                END;
                GOTO BADCMD; /* 'G' */
                GOTO BADCMD; /* 'H' */
    CASE$I:     DO;             /* 'I' INSERT */
                    DO WHILE (CHAR := GETCMDCH) <> ESC;
                        IF TEXTPTR = W4EC0 THEN DO; 
                            CALL MOVEUP;
                            IF W4EBA - 11 < W4EC2 THEN
                                GOTO BREAK;
                            W37D6 = W4EC2;
                            W4EC2, W4EC0 = W4EBA - 10;
                            DO WHILE W37D6 >= TEXTPTR;
                                MEMORY(W4EC0) = MEMORY(W37D6);
                                W37D6 = W37D6 - 1;
                                W4EC0 = W4EC0 - 1;
                            END;
                            W4EC0 = W4EC0 + 1;
                        END;
                        MEMORY(TEXTPTR) = CHAR;
                        TEXTPTR = TEXTPTR + 1; 
                    END; 
                    CALL MOVEDOWN;
                    GOTO CMDLOOP;
                END;
                GOTO BADCMD;            /* 'J' */
                DO;                     /* 'K' KILL */
                    IF (W4EC0 := SEEKLINE) < TEXTPTR THEN DO;
                        W37D6 = TEXTPTR;
                        TEXTPTR = W4EC0;
                        W4EC0 = W37D6;
                    END;
                    CALL MOVEDOWN;
                    GOTO CMDLOOP;
                END;
                DO;
                    TEXTPTR = SEEKLINE;      /* 'L' TEXT POINTER LINE*/
                    GOTO CMDLOOP;
                END;
                GOTO BADCMD;            /* 'M' */
                GOTO BADCMD;            /* 'N' */
                GOTO BADCMD;            /* 'O' */
                GOTO BADCMD;            /* 'P' */
                DO;                     /* 'Q' QUIT */
                    CALL CLOSE(AFTOUT, .STATUS);
                    CALL DELETE(BUFFER$PTR, .STATUS);
                    CALL EXIT;
                    GOTO CMDLOOP;
                END;
                GOTO BADCMD;            /* 'R' */
                DO;                     /* 'S' SUBSTITUTE */
                    W4EC0 = (TEXTPTR := FINDLOC) + FINDLEN;
                    GOTO CASE$I;
                END;
                DO;                     /* 'T' TYPE */
                    IF (W37D6 := SEEKLINE) = TEXTPTR THEN
                        GOTO CMDLOOP;
                    IF TEXTPTR < W37D6 THEN
                        CALL DISPLAYTEXT(.MEMORY + TEXTPTR, W37D6 - TEXTPTR - 1);
                    ELSE
                        CALL DISPLAYTEXT(.MEMORY + W37D6, TEXTPTR - W37D6 - 1);
                    GOTO CMDLOOP;
                END;
                GOTO BADCMD;            /* 'U' */
                GOTO BADCMD;            /* 'V' */
                DO;                     /* 'W' WRITE */
                    BACKWARDS = 0;
                    TEXTPTR = 1;
                    W4EC0 = SEEKLINE;
                    CALL WRITE(AFTOUT, .MEMORY + 1, W4EC0 - 1, .STATUS);
                    CALL FILEERROR(STATUS, BUFFER$PTR, TRUE);
                    CALL MOVEDOWN;
                    GOTO CMDLOOP;
                END;
                GOTO BADCMD;            /* 'X' */
                GOTO BADCMD;            /* 'Y' */
                DO;                     /* 'Z' TEXT POINTER END*/
                    TEXTPTR = ENDPTR;
                    GOTO CMDLOOP;
                END;
            END;    /* OF CASE */
        END;        /* OF IF */
        ELSE
BADCMD: IF CHAR > ' ' THEN DO;
            CALL DISPLAYTEXT(.BEGINPUNCH, 1);
            CALL CO(DQUOTE);
            CALL DISPLAYCHAR(CHAR);
            CALL DISPLAYTEXT(.ILLEGAL, 26);
            CALL GETTEXT;
        END;
    END; /* OF CMDLOOP */
BREAK:
    CALL DISPLAYTEXT(.USRBREAK, 10);
    CALL GETTEXT;
    GOTO CMDLOOP;
EOF
format.plm
3400H:
DO;
    DECLARE NSECTORS LITERALLY '26';
    DECLARE NTRACKS LITERALLY '77';
    DECLARE IOCW    LITERALLY '0',
            IOINS   LITERALLY '1',
            NSEC    LITERALLY '2',
            TADR    LITERALLY '3',
            SADR    LITERALLY '4',
            BUFLO   LITERALLY '5',
            BUFHI   LITERALLY '6';

    DECLARE TRUE    LITERALLY '0FFH',
            FALSE   LITERALLY '0',
            OK      LITERALLY '0',
            CR      LITERALLY '0DH',
            LF      LITERALLY '0AH';

    DECLARE DCMD$READ  LITERALLY '4',
            DCMD$WRITE LITERALLY '6';

    DECLARE INVISIBLE$A LITERALLY '1',
            SYSTEM$A    LITERALLY '2',
            WRITEP$A    LITERALLY '4',
            FORMAT$A    LITERALLY '80H';

    DECLARE READMODE    LITERALLY '1',
            WRITEMODE   LITERALLY '2',
            UPDATEMODE  LITERALLY '3';

    /* ERROR CODES */
    DECLARE NO$FREE$BUFFER LITERALLY '1',
            BAD$PATH LITERALLY '4',
            BAD$DEVICE LITERALLY '5',
            FILE$EXISTS LITERALLY '0BH',
            NO$SUCH$FILE LITERALLY '0DH',
            NULL$FILENAME LITERALLY '23',
            NULL$EXTENSION LITERALLY '28',
            BAD$SWITCH  LITERALLY '0C9H',
            BAD$SYNTAX  LITERALLY '0CBH';

    DECLARE BOOLEAN LITERALLY 'BYTE';
    DECLARE F1DEV LITERALLY '1';

    DECLARE WARNING LITERALLY '0';
    DECLARE MESSAGE LITERALLY '1';
    DECLARE ABORT LITERALLY '2';

    DECLARE VER DATA(1, 9);
    DECLARE COPYRIGNT DATA('(C) 1975,1976 INTEL CORP');
/*
	THE CODE BLOCK BELOW IS LOADED INTO ISIS.T0 ON NON SYSTEM DISKS TO PRINT A MESSAGE
	THE CORRESPONDING ASM CODE IS

		ASEG
		org 3000h

		IN	79H
		IN	7BH
	L3004:	IN	0FFH
		ANI	2
		JNZ	L3004
		LXI	H, MSG
		MVI	B, 32
	L3010:	MOV	C, M
		CALL	0F809H	; CO
		INX	H
		DCR	B
		JNZ	L3010
		RST	0
	MSG:	DB	0DH, 0AH
		DB	'NON-SYSTEM DISK, TRY ANOTHER'
		DB	0DH, 0AH
		END
*/
DECLARE CODEBLOCK DATA(0DBH, 79H, 0DBH, 7BH, 0DBH, 0FFH, 0E6H, 2,
			       0C2H, 4, 30H, 21H, 1AH, 30H, 6, 20H, 4EH,
			       0CDH, 9, 0F8H, 23H, 5, 0C2H, 10H, 30H, 0C7H,
			       CR, LF, 'NON-SYSTEM DISK, TRY ANOTHER', CR, LF);
DECLARE ATTRIBMAP DATA(INVISIBLE$A, SYSTEM$A, WRITEP$A);
DECLARE CRLF DATA(CR, LF);
DECLARE	ISIST0 DATA(':F1:ISIS.T0 '),
        ISISBIN DATA(':F1:ISIS.BIN '),
        ISISMAP DATA(':F1:ISIS.MAP '),
        ISISLAB DATA(':F1:ISIS.LAB '),
        ISISDIR DATA(':F1:ISIS.DIR ');

/* GLOBAL VARIABLES */
DECLARE BITMAP(256) BYTE,
        UNUSED(6) BYTE INITIAL(0FFH),
        MAPDCB(10) BYTE INITIAL(80H, 0, 2, 2, 2),    /* NOT USED */
        BITMASK(8) BYTE INITIAL(80H, 40H, 20H, 10H, 8, 4, 2, 1);
DECLARE DIRECT(10) BYTE,  DIRECTATTR BYTE, DIRECTOTHER(5) BYTE, PAD1(1) BYTE;
DECLARE FMTTABLE(77) BYTE INITIAL(
            1, 12,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,
            3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,
            3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,
            3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,
            3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3);
DECLARE BUFFER(128) BYTE;
DECLARE MEMSIZE ADDRESS;
DECLARE ACTUAL ADDRESS, PAD2 ADDRESS;
DECLARE (BUFFERPTR, II, JJ, NAMELEN) ADDRESS, PAD3 BYTE;
DECLARE (SYSTEM, COPYALL, COPY) BYTE;
DECLARE (AFTIN, AFTOUT, AFTDIR, STATUS) ADDRESS, PAD4 BYTE;
DECLARE SRCNAME(16) BYTE, DSTNAME(16) BYTE;



    MEMCK: PROCEDURE ADDRESS;
        GOTO 0F81BH;
    END;

    ISIS: PROCEDURE(CMD, PARAM$P);
        DECLARE CMD BYTE, PARAM$P ADDRESS;
        GOTO 40H;
    END ISIS;

    OPEN: PROCEDURE(CONN$P, PATH$P, ACCESS, ECHO, STATUS$P);
        DECLARE (CONN$P, PATH$P, ACCESS, ECHO, STATUS$P) ADDRESS;

        CALL ISIS(0, .CONN$P);
    END;

    READ: PROCEDURE(CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P) ADDRESS;

        CALL ISIS(3, .CONN);
    END;

    WRITE: PROCEDURE(CONN, BUFF$P, COUNT, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, STATUS$P) ADDRESS;

        CALL ISIS(4, .CONN);
    END;

    CLOSE: PROCEDURE(CONN, STATUS$P);
        DECLARE (CONN, STATUS$P) ADDRESS;

        CALL ISIS(1, .CONN);
    END;

    ERROR: PROCEDURE(ERROR$NUM);
        DECLARE (ERROR$NUM, STATUS) ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(12, .ERROR$NUM);
    END;

    EXIT: PROCEDURE;
        DECLARE STATUS ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(9, .STATUS);
    END;

    ATTRIB: PROCEDURE (PATH$P, ATTRIB, ON$OFF, STATUS$P);
        DECLARE (PATH$P, ATTRIB, ON$OFF, STATUS$P) ADDRESS;

        CALL ISIS(10, .PATH$P);
    END ATTRIB;

    DELETE: PROCEDURE (PATH$P, STATUS$P);
        DECLARE (PATH$P, STATUS$P) ADDRESS;

        CALL ISIS(2, .PATH$P);
    END DELETE;


    DISKIO: PROCEDURE(DRIVE, IOPB);
        DECLARE (DRIVE, IOPB) ADDRESS;
        DECLARE PARAMS(4) ADDRESS;

        PARAMS(0) = 'SK';
        PARAMS(1) = DRIVE;
        PARAMS(2) = IOPB;
        CALL ISIS('D', .PARAMS);
    END;

    

    /* NOT ACTUALLY USED */
    NUMOUT: PROCEDURE(VALUE, BASE, LC, BUFADR, WIDTH);
        DECLARE (VALUE, BUFADR) ADDRESS, (BASE, LC, WIDTH) BYTE; 
        DECLARE DIGITS DATA('0123456789ABCDEF');
        DECLARE I BYTE;
        DECLARE BUF BASED BUFADR (1) BYTE;

        DO I = 1 TO WIDTH;
            BUF(WIDTH - I) = DIGITS(VALUE MOD BASE);
            VALUE = VALUE / BASE;   
        END;

        I = 0;
        DO WHILE BUF(I) = '0' AND I < WIDTH - 1;
            BUF(I) = LC;
            I = I + 1;
        END;
    END;

    REPORTERROR: PROCEDURE(ERRNUM);
        DECLARE ERRNUM ADDRESS;
        DECLARE NUMBERBUFFER(4) BYTE, I ADDRESS, STATUS ADDRESS;
     

        DECLARE ERRMSG DATA(0, 0,
            2, 'ILLEGAL AFTN ARGUMENT', 0,
            4, 'INCORRECTLY SPECIFIED FILE', 0,
            5, 'UNRECOGNIZED DEVICE NAME', 0,
            6, 'ATTEMPT TO WRITE TO INPUT DEVICE', 0,
            8, 'ATTEMPT TO READ FROM OUTPUT DEVICE', 0,
            9, 'DIRECTORY FULL', 0,
            0AH, 'NOT ON SAME DISK', 0,
            0BH, 'FILE ALREADY EXISTS', 0,
            0CH, 'FILE IS ALREADY OPEN', 0,
            0DH, 'NO SUCH FILE', 0,
            0EH, 'WRITE PROTECTED', 0,
            0FH, 'LOAD TOO LOW', 0,
            10H, 'BAD LOAD FORMAT', 0,
            11H, 'NOT A DISK FILE', 0,
            12H, 'ILLEGAL ISIS COMMAND', 0,
            13H, 'ATTEMPTED SEEK ON NON-DISK FILE', 0,
            14H, 'ATTEMPTED BACK SEEK TO FAR', 0,
            16H, 'ILLEGAL ACCESS MODE TO OPEN', 0,
            17H, 'MISSING FILENAME', 0,
            19H, 'ILLEGAL ECHO FILE', 0,
            1AH, 'ILLEGAL ATTRIBUTE IDENTIFIER', 0,
            1BH, 'ILLEGAL SEEK COMMAND', 0,
            1CH, 'MISSING EXTENSION', 0,
            1FH, 'CAN', 27H, 'T SEEK ON WRITE ONLY FILE', 0,
            20H, 'CAN', 27H, 'T DELETE OPEN FILE', 0,
            23H, 'SEEK PAST EOF', 0,
            0C9H, 'UNRECOGNIZED SWITCH', 0,
            0CAH, 'UNRECOGNIZED DELIMITER', 0,
            0CBH, 'INVALID SYNTAX', 0,
            0CCH, 'PREMATURE EOF', 0,
            0CEH, 'ILLEGAL DISKETTE LABEL', 0,
            0D0H, 'CHECKSUM ERROR', 0
        );



        IF ERRNUM <> 0 THEN
        DO;
            I = 0;
            DO WHILE I < LENGTH(ERRMSG);
                IF ERRNUM = ERRMSG(I) AND ERRMSG(I + 1) <> 0 THEN
                DO;
                    I = I + 1;
                    CALL WRITE(0, .(' '), 1, .STATUS);
                    DO WHILE ERRMSG(I) <> 0;
                        CALL WRITE(0, .ERRMSG(I), 1, .STATUS);
                        I = I + 1;
                    END;
                    CALL WRITE(0, .(0DH, 0AH), 2, .STATUS);
                    return;
                END;
                ELSE
                DO;
                    DO WHILE ERRMSG(I) <> 0;
                        I = I + 1;
                    END;
                    I = I + 1;
                END;
            end;
            CALL ERROR(ERRNUM);
        END;
    END;



    CHECKERROR: PROCEDURE(SEVERITY, ERRCODE);
        DECLARE (SEVERITY, ERRCODE) BYTE;
        IF ERRCODE = 0 THEN
            RETURN;
        CALL REPORTERROR(ERRCODE);
        CALL EXIT;
    END;
    
    DECLARE BUFFER$TABLE(19) BYTE;   /* NOT USED */

    CLRBUF: PROCEDURE(PTR);
        DECLARE PTR ADDRESS, BUF BASED PTR (1) BYTE;
        DECLARE I BYTE;
        DO I = 0 TO 127;
            BUF(I) = 0;
        END;
    END;

    FREEBUF: PROCEDURE(BUFFER); /* NOT USED */
        DECLARE BUFFER ADDRESS;

        BUFFER$TABLE(SHR(BUFFER - .MEMORY, 7)) = 0;
    END;

    GETBUF: PROCEDURE ADDRESS;  /* NOT USED */
        DECLARE I BYTE;

        DO I = 0 TO LAST(BUFFER$TABLE);
            IF BUFFER$TABLE(I) = 0 THEN
            DO;
                BUFFER$TABLE(I) = 2;
                RETURN .MEMORY + SHL(DOUBLE(I), 7);
            END;
        END;
        CALL CHECKERROR(ABORT, NO$FREE$BUFFER);
    END;


    SETBLOCK: PROCEDURE(ADR);
        DECLARE ADR ADDRESS;
        DECLARE BYT BYTE;

        ADR = HIGH(ADR) * 26 + LOW(ADR) - 1;
        BYT = SHR(ADR, 3);
        BITMAP(BYT) = BITMAP(BYT) OR BITMASK(LOW(ADR) AND 7);
    END;

    /*
     ASBIO: ACCOMPLISHES THE TRANSFER OF 128 BYTES OF DATA FROM THE DISK 
       COMMAND  MUST BE THE NUMERIC VALUE OF THE FDCC COMMAND
                DESIRED. (LITERALS 'READ$COMMAND' AND 'WRITE$COMMAND'
                EXIST FOR THE COMMON OPERATIONS.)
       DISK     THE DRIVE FROM WHICH TO READ
       BLOCK    DISKETTE BLOCK NUMBER, A TRACK NUMBER (0-76)
                IN THE HIGH ORDER 8 BITS AND A SECTORE NUMBER (1-26)
                IN THE LOW ORDER 8 BITS
       BUFFER$PTR   THE ADDRESS OF A 128 BYTE BUFFER IN RAM
    */
    ABSIO: PROCEDURE (COMMAND, DISK, TRKSEC, BUFFER);
        DECLARE (COMMAND, DISK) BYTE, (TRKSEC, BUFFER) ADDRESS;
        /* VALUE OF 'DISK'  MUST BE 0 - 1 */
        DECLARE PAD BYTE;
        DECLARE DCB(10) BYTE INITIAL(80H);

        DCB(IOINS) = COMMAND;
        DCB(NSEC) = 1;
        DCB(TADR) = HIGH(TRKSEC);
        DCB(SADR) = LOW(TRKSEC);
        DCB(BUFLO) = LOW(BUFFER);
        DCB(BUFHI) = HIGH(BUFFER);
        CALL DISKIO(DISK, .DCB);
    END;


    FORMATTRACK: PROCEDURE(DISK, FIRSTTRK, LASTTRK, INTERLEAVE);
        DECLARE (DISK, FIRSTTRK, LASTTRK, INTERLEAVE) BYTE;
        DECLARE (I, J, CURTRACK) BYTE;
        DECLARE TRACKBUF(52) BYTE;
        DECLARE DCB(10) BYTE INITIAL(0C0H, 2, 0, 0, 0, 0, 0, 0, 0, 0);
        

        DO I = 1 to 51 BY 2;
            TRACKBUF(I) = 0C7H;
        END; 
        J = 0;

        DO CURTRACK = FIRSTTRK TO LASTTRK;
            DO I = 0 TO 51 BY 2;
                TRACKBUF(I) = 0;
            END;
            DO I = 1 TO NSECTORS;
                J = (J + INTERLEAVE) MOD NSECTORS;
                DO WHILE TRACKBUF(J + J) <> 0;
                    J = (J + 1) MOD NSECTORS;
                END;
                TRACKBUF(J + J) = I;
            END;
            
            DCB(TADR) = CURTRACK;
            DCB(BUFHI) = HIGH(.TRACKBUF);
            DCB(BUFLO) = LOW(.TRACKBUF);
            CALL DISKIO(DISK, .DCB);
        END;
    END;



    DEBLANK: PROCEDURE(PTR) ADDRESS;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE C = ' ';
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;

    DELIMIT: PROCEDURE(PTR) ADDRESS;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE (C = ':' OR C = '.' 
              OR ('0' <= C AND C <= '9')
              OR ('A' <= C AND C <= 'Z'));
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;

	MOVE: PROCEDURE(DST$P, SRC$P, CNT);
		DECLARE (DST$P, SRC$P) ADDRESS;
        DECLARE DST BASED DST$P (1) BYTE;
        DECLARE SRC BASED SRC$P (1) BYTE;
        DECLARE (CNT, I) BYTE;

		DO I = 0 TO CNT - 1;
            DST(I) = SRC(I);
		END;
	end;

    WRITEDIRECTORY: PROCEDURE(DRIVE);
        DECLARE DRIVE BYTE;
        DECLARE DISISDIR DATA('ISIS',0,0,'DIR');
        DECLARE DISISMAP DATA('ISIS',0,0,'MAP');
        DECLARE DISIST0  DATA('ISIS',0,0,'T0', 0);
        DECLARE DISISBIN DATA('ISIS',0,0,'BIN');
        DECLARE DISISLAB DATA('ISIS',0,0,'LAB');

        DECLARE I BYTE, JJ ADDRESS;
        DECLARE DIRBUFW(0) ADDRESS, DIRBUF(0) BYTE,
                DIR0W(0)   ADDRESS, DIR0(16) BYTE,
                DIR1W(0)   ADDRESS, DIR1(16) BYTE,
                DIR2W(0)   ADDRESS, DIR2(16) BYTE,
                DIR3W(0)   ADDRESS, DIR3(16) BYTE,
                DIR4W(0)   ADDRESS, DIR4(16) BYTE,
                DIR5W(0)   ADDRESS, DIR5(16) BYTE,
                DIR6W(0)   ADDRESS, DIR6(16) BYTE,
                DIR7W(0)   ADDRESS, DIR7(16) BYTE;

        DO I = 0 TO 255;
            BITMAP(I) = 0;
        END;
        CALL CLRBUF(.DIRBUF);
        DIRBUFW(2) = 1;
        DO I = 2 TO 23;
            DIRBUFW(I + 1) = DIRBUFW(I) + 1;
        END;
        CALL ABSIO(DCMD$WRITE, DRIVE, 18H, .DIRBUF);
        CALL CLRBUF(.DIRBUF);

        DIRBUFW(2) = 1AH;
        DO I = 2 TO 1;
            DIRBUFW(I + 1) = DIRBUFW(I) + 1;
        END;
        CALL ABSIO(DCMD$WRITE, DRIVE, 19H, .DIRBUF);
        CALL CLRBUF(.DIRBUF);

        DIRBUFW(2) = 102H;
        DO I = 2 TO 25;
            DIRBUFW(I + 1) = DIRBUFW(I) + 1;
        END;
        CALL ABSIO(DCMD$WRITE, DRIVE, 101H, .DIRBUF);
        CALL CLRBUF(.DIRBUF);

        DIRBUFW(2) = 202H;
        DO I = 2 TO 2;
            DIRBUFW(I + 1) = DIRBUFW(I) + 1;
        END;
        CALL ABSIO(DCMD$WRITE, DRIVE, 201H, .DIRBUF);
        CALL CLRBUF(.DIRBUF);

        CALL ABSIO(DCMD$WRITE, DRIVE, 204H, .DIRBUF);

        CALL CLRBUF(.DIRBUF);

        CALL MOVE(.DIR0(1), .DISISDIR, 9);
        DIR0W(6) = 19H;
        DIR0W(7) = 101H;
        DIR0(0) = 0;
        DIR0(10) = 1;
        DIR0(11) = 80H;

        CALL MOVE(.DIR1(1), .DISISMAP, 9);
        DIR1W(6) = 2H;
        DIR1W(7) = 201H;
        DIR1(0) = 0;
        DIR1(10) = 1;
        DIR1(11) = 80H;

        CALL MOVE(.DIR2(1), .DISIST0, 9);
        DIR2W(6) = 17H;
        DIR2W(7) = 18H;
        DIR2(0) = 0;
        DIR2(10) = 1;
        DIR2(11) = 80H;

        CALL MOVE(.DIR3(1), .DISISLAB, 9);
        DIR3W(6) = 1H;
        DIR3W(7) = 19H;
        DIR3(0) = 0;
        DIR3(10) = 1;
        DIR3(11) = 80H;

        CALL MOVE(.DIR4(1), .DISISBIN, 9);
        DIR4W(6) = 0;
        DIR4W(7) = 204H;
        DIR4(0) = 0;
        DIR4(10) = 1 OR 2;
        DIR4(11) = 80H;

        DO I = 5 TO 7;
            DIRBUF(I * 16) = 7FH;
        END;

        CALL ABSIO(DCMD$WRITE, DRIVE, 102H, .DIRBUF);
        CALL CLRBUF(.DIRBUF);

        DO I = 0 TO 7;
            DIRBUF(I * 16) = 7FH;
        END;

        DO I = 2 TO 25;
            CALL ABSIO(DCMD$WRITE, DRIVE, 102H - 1 + I, .DIRBUF);
        END;

        CALL SETBLOCK(101H);
        DO JJ = 102H TO 25 + 102H - 1;
            CALL SETBLOCK(JJ);
        END;

        CALL SETBLOCK(201H);
        DO JJ = 202H TO 2 + 202H - 1;
            CALL SETBLOCK(JJ);
        END;

        CALL SETBLOCK(18H);
        DO JJ = 1 TO 1 + 17H - 1;
            CALL SETBLOCK(JJ);
        END; 

        CALL SETBLOCK(19H);
        DO JJ = 1AH TO 1AH + 1 - 1;
            CALL SETBLOCK(JJ);
        END; 

        CALL SETBLOCK(204H);

        CALL ABSIO(DCMD$WRITE, DRIVE, 202H, .BITMAP);
        CALL ABSIO(DCMD$WRITE, DRIVE, 202H + 1, .BITMAP(128));


    END;


    DECLARE FULLNAME(15) BYTE;
    DECLARE DEVICENAMES(21) ADDRESS INITIAL (
        'F0','F1','TI','TO','VI','VO','I1','O1','TR','HR',
        'R1','R2','TP','HP','P1','P2','LP','L1','CI','CO','BB');
    DECLARE (PN, PN2) (10) BYTE;

    CANON: PROCEDURE(FILENAME, INTFN$P) BYTE;
        DECLARE (FILENAME, INTFN$P) ADDRESS;
        DECLARE PATHCH BASED FILENAME BYTE; /* CHAR OF FILENAME POINTS TO */
        DECLARE PATHCHARS BASED FILENAME (1) BYTE;
        DECLARE INTFN BASED INTFN$P (10) BYTE;  /* BYTE VERSION OF INTFN  */
        DECLARE STARTNAME ADDRESS, STARTCH BASED STARTNAME BYTE;
        DECLARE DEVPAIR(0) ADDRESS, (SECOND, FIRST) BYTE;
        DECLARE (J, I) BYTE;


        ALPHANUM: PROCEDURE BOOLEAN;
            RETURN (PATHCH >= 'A' AND PATHCH <= 'Z')
                OR (PATHCH >= '0' AND PATHCH <= '9');
        END;


        DO I = 0 TO LAST(INTFN);    /* CLEAR INTFN */
            INTFN(I) = 0;
        END;
        DO WHILE PATHCH = ' ';  /* SKIP LEADING SPACE */
            FILENAME = FILENAME + 1;
        END;
        STARTNAME = FILENAME;
        IF PATHCH = ':' THEN
        DO;
            INTFN(0) = 0FFH;
            FIRST = PATHCHARS(1);
            SECOND = PATHCHARS(2);
            IF PATHCHARS(3) <> ':' THEN
                RETURN BAD$PATH;

            DO I =  0 TO LAST(DEVICENAMES);
                IF DEVICENAMES(I) = DEVPAIR(0) THEN 
                    INTFN(0) = I;   /* SAVE DEVICE NUMBER */
            END;
            IF INTFN(0) = 0FFH THEN
                RETURN BAD$DEVICE;
            FILENAME = FILENAME + 4;
        END;

        FIRST = 0;
        DO I = 1 TO 6;
            IF ALPHANUM THEN
            DO;
                INTFN(I) = PATHCH;
                FIRST = 1;
                FILENAME = FILENAME + 1;
            END;
        END;
        IF PATHCH = '.' THEN
        DO;
            FILENAME = FILENAME + 1;
            DO I = 7 TO 9;
                IF ALPHANUM THEN
                DO;
                    INTFN(I) = PATHCH;
                    FILENAME = FILENAME + 1;
                END;
            END;
        END;
        IF INTFN(0) <= F1DEV AND FIRST = 0 THEN
            RETURN NULL$FILENAME;
        J =  -1;
        DO WHILE STARTNAME < FILENAME;
            J = J + 1;
            FULLNAME(J) = STARTCH;
            STARTNAME = STARTNAME + 1;
        END;
        IF FULLNAME(J) = '.' THEN
            RETURN NULL$EXTENSION;
        FULLNAME(J + 1) = ' ';
        IF ALPHANUM  OR PATHCH = '.' OR PATHCH = ':' THEN
            RETURN BAD$PATH;
        RETURN OK;
    END;


    UNPATH: PROCEDURE(DIR$P, FILENAME$P);
        DECLARE (DIR$P, FILENAME$p) ADDRESS;
        DECLARE FILENAME BASED FILENAME$P (1) BYTE;
        DECLARE DIR BASED DIR$P (1) BYTE;
        DECLARE I BYTE;

        FILENAME(0) = ':';
        FILENAME(1) = 'F';
        FILENAME(3) = ':';
        IF DIR(0) = 0 THEN
            FILENAME(2) = '0';
        ELSE
            FILENAME(2) = '1';
        FILENAME$P = FILENAME$P + 4;
        DO I = 0 TO 5;
            if (FILENAME(0) := DIR(I + 1)) <> 0 THEN
                FILENAME$P = FILENAME$P + 1;
        END;
        IF DIR(7) <> 0 THEN DO;
            FILENAME(0) = '.';
            FILENAME$P = FILENAME$P + 1;
        END; 
        DO I = 0 TO 2;
            if (FILENAME(0) := DIR(I + 7)) <> 0 THEN
                FILENAME$P = FILENAME$P + 1;
        END;
        FILENAME(0) = ' ';
    END; 

    DECLARE CHAR BASED BUFFER$PTR BYTE;
 
MAIN:
    COPYALL = FALSE;
    SYSTEM = FALSE;
	CALL READ(1, .BUFFER, 128, .ACTUAL, .STATUS);
    CALL CHECKERROR(ABORT, STATUS);
	BUFFER$PTR = DEBLANK(.BUFFER);
    IF CHAR = ':' THEN
        CALL CHECKERROR(ABORT, 0CEH);   /* ILLEGAL DISKETTE LABEL */

    STATUS = CANON(BUFFERPTR, .PN);
    CALL CHECKERROR(ABORT, STATUS);

	BUFFERPTR = DEBLANK(DELIMIT(DEBLANK(.BUFFER)));
    
    DO WHILE CHAR = '$';
        BUFFERPTR = BUFFERPTR + 1;
        IF CHAR = 'S' THEN DO;
            BUFFERPTR = DELIMIT(BUFFERPTR);
            SYSTEM = TRUE;
        END;
        ELSE IF CHAR = 'A' THEN DO;
            BUFFERPTR = DELIMIT(BUFFERPTR);
            COPYALL = TRUE;
        END;
        ELSE DO;
            CALL CHECKERROR(ABORT, 0C9H);
            CALL EXIT;
        END;
        BUFFERPTR = DEBLANK(BUFFERPTR);
    END;
    IF CHAR <> CR THEN DO;
        CALL CHECKERROR(ABORT, 0CBH);
        CALL EXIT;
    END;

    DO II = 0 TO 76;
        CALL FORMATTRACK(1, II, II, FMTTABLE(II)); 
    END;

    CALL WRITEDIRECTORY(1);
    /* WRITE THE LABEL NAME */
    CALL OPEN(.AFTOUT, .ISISLAB, 3, 0, .STATUS);
    CALL CHECKERROR(ABORT, STATUS);
    CALL WRITE(AFTOUT, .PN + 1, 9, .STATUS);
    CALL CHECKERROR(ABORT, STATUS);
    /* FILL IN REST OF LABEL */
    DO II = 1 TO 128 - 11 - 77;
        CALL WRITE(AFTOUT, .(0), 1, .STATUS);
        CALL CHECKERROR(ABORT, STATUS);
    END;
    CALL WRITE(AFTOUT, .(CR, LF), 2, .STATUS);
    CALL CHECKERROR(ABORT, STATUS);
    DO II = 0 TO 76;
        JJ = FMTTABLE(II) + '0';
        CALL WRITE(AFTOUT, .JJ, 1, .STATUS);
        CALL CHECKERROR(ABORT, STATUS);
    END; 
    CALL CLOSE(AFTOUT, .STATUS);
    CALL CHECKERROR(ABORT, STATUS);

	IF SYSTEM OR COPYALL THEN DO;
		IF COPYALL THEN
			CALL WRITE(0, .('COPYING ALL FILES', CR, LF), 19, .STATUS);
        ELSE
			CALL WRITE(0, .('COPYING SYSTEM FILES', CR, LF), 22, .STATUS);

		MEMSIZE = (MEMCK - .MEMORY) AND 0FFF8H;

        CALL OPEN(.AFTOUT, .ISIST0, 3, 0, .STATUS);
        CALL CHECKERROR(ABORT, STATUS);
        CALL OPEN(.AFTIN, .('ISIS.T0 '), 1, 0, .STATUS);
        CALL CHECKERROR(ABORT, STATUS);

        ACTUAL = 1;
        DO WHILE ACTUAL <> 0;
            CALL READ(AFTIN, .MEMORY, MEMSIZE, .ACTUAL, .STATUS);
            CALL CHECKERROR(ABORT, STATUS);
            CALL WRITE(AFTOUT, .MEMORY, ACTUAL, .STATUS);
            CALL CHECKERROR(ABORT, STATUS);
            IF ACTUAL < MEMSIZE THEN
                ACTUAL = 0;
        END;
        CALL CLOSE(AFTOUT, .STATUS);
        CALL CHECKERROR(ABORT, STATUS);
        CALL CLOSE(AFTIN, .STATUS);
        CALL CHECKERROR(ABORT, STATUS);

        CALL OPEN(.AFTDIR, .('ISIS.DIR'), 1, 0, .STATUS);
        CALL CHECKERROR(ABORT, STATUS);

        DIRECT(0) = 0;
        DO WHILE DIRECT(0) <> 7FH;
            CALL READ(AFTDIR, .DIRECT, 16, .ACTUAL, .STATUS);
            CALL CHECKERROR(ABORT, STATUS);
            IF ACTUAL < 16 THEN
                DIRECT(0) = 7FH;
            ELSE IF NOT DIRECT(0) THEN DO;
                if (COPY := ((DIRECTATTR AND SYSTEM$A) <> 0 OR  COPYALL)
                       AND  (DIRECTATTR AND FORMAT$A) = 0) THEN DO;
                    DIRECT(0) = 0;
                    CALL UNPATH(.DIRECT, .SRCNAME);
                    DIRECT(0) = 1;
                    CALL UNPATH(.DIRECT, .DSTNAME);
                    CALL OPEN(.AFTOUT, .DSTNAME, 3, 0, .STATUS);
                    CALL CHECKERROR(ABORT, STATUS);
                    CALL OPEN(.AFTIN, .SRCNAME, 1, 0, .STATUS);
                    CALL CHECKERROR(ABORT, STATUS);
                    ACTUAL = 1;
                    DO WHILE ACTUAL <> 0;
                        CALL READ(AFTIN, .MEMORY, MEMSIZE, .ACTUAL, .STATUS);
                        CALL CHECKERROR(ABORT, STATUS);
                        CALL WRITE(AFTOUT, .MEMORY, ACTUAL, .STATUS);
                        CALL CHECKERROR(ABORT, STATUS);
                        IF ACTUAL < MEMSIZE THEN
                            ACTUAL = 0;
                    END;
                    CALL CLOSE(AFTOUT, .STATUS);
                    CALL CHECKERROR(ABORT, STATUS);
                    CALL CLOSE(AFTIN, .STATUS);
                    CALL CHECKERROR(ABORT, STATUS);

                    DO II = 0 TO 2;
                        IF (ATTRIBMAP(II) AND DIRECTATTR) <> 0 THEN DO;
                            CALL ATTRIB(.DSTNAME, II, 0FFH, .STATUS);
                            CALL CHECKERROR(ABORT, STATUS);
                        END;
                    END;
                    NAMELEN = DELIMIT(.SRCNAME + 4) - .SRCNAME - 4;
                    CALL WRITE(0, .SRCNAME + 4, NAMELEN, .STATUS);
                    CALL WRITE(0, .CRLF, 2, .STATUS);
                END;
            END;
        END;        
        CALL CLOSE(AFTDIR, .STATUS);
        CALL CHECKERROR(ABORT, STATUS);
        CALL ATTRIB(.ISIST0, 3, 0FFH, .STATUS);
        CALL CHECKERROR(ABORT, STATUS);
        CALL ATTRIB(.ISISBIN, 2, 0FFH, .STATUS);
        CALL CHECKERROR(ABORT, STATUS);
    END;
    ELSE DO;
        CALL WRITE(0, .('NON-SYSTEM DISKETTE', CR, LF), 21, .STATUS);
        CALL OPEN(.AFTOUT, .ISIST0, 3, 0, .STATUS);
        CALL CHECKERROR(ABORT, STATUS);
        CALL WRITE(AFTOUT, .CODEBLOCK, 58, .STATUS);
        CALL CHECKERROR(ABORT, STATUS);
        CALL CLOSE(AFTOUT, .STATUS);
        CALL CHECKERROR(ABORT, STATUS);
        CALL ATTRIB(.ISIST0, 3, 0FFH, .STATUS);
        CALL CHECKERROR(ABORT, STATUS);
        CALL DELETE(.ISISBIN, .STATUS);
        CALL CHECKERROR(ABORT, STATUS);
    END;

    CALL ATTRIB(.ISISDIR, 3, 0FFH, .STATUS);
    CALL CHECKERROR(ABORT, STATUS);
    CALL ATTRIB(.ISISLAB, 3, 0FFH, .STATUS);
    CALL CHECKERROR(ABORT, STATUS);
    CALL ATTRIB(.ISISMAP, 3, 0FFH, .STATUS);
    CALL CHECKERROR(ABORT, STATUS);
    CALL EXIT;
END;
EOF

hexbin.plm
3300H:
DO;
    DECLARE TRUE    LITERALLY '0FFH',
            FALSE   LITERALLY '0',
            CR      LITERALLY '0DH',
            LF      LITERALLY '0AH';

    DECLARE READMODE    LITERALLY '1',
            WRITEMODE   LITERALLY '2',
            UPDATEMODE  LITERALLY '3';

    /* ERROR CODES */
    DECLARE FILE$EXISTS LITERALLY '0BH',
            NO$SUCH$FILE LITERALLY '0DH',
            BAD$SWITCH  LITERALLY '0C9H',
            BAD$SYNTAX  LITERALLY '0CBH',
            EARLY$EOF   LITERALLY '0CCH';

    DECLARE VER DATA(1, 8);
    DECLARE COPYRIGNT DATA('(C) 1975,1976 INTEL CORP');

    MEMCHK: PROCEDURE ADDRESS;
        GOTO 0F81BH;
    END;

    ISIS: PROCEDURE(CMD, PARAM$P);
        DECLARE CMD BYTE, PARAM$P ADDRESS;
        GOTO 40H;
    END ISIS;

    READ: PROCEDURE(CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P) ADDRESS;

        CALL ISIS(3, .CONN);
    END;

    WRITE: PROCEDURE(CONN, BUFF$P, COUNT, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, STATUS$P) ADDRESS;

        CALL ISIS(4, .CONN);
    END;

    ERROR: PROCEDURE(ERROR$NUM);
        DECLARE (ERROR$NUM, STATUS) ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(12, .ERROR$NUM);
    END;

    EXIT: PROCEDURE;
        DECLARE STATUS ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(9, .STATUS);
    END;

    OPEN: PROCEDURE(CONN$P, PATH$P, ACCESS, ECHO, STATUS$P);
        DECLARE (CONN$P, PATH$P, ACCESS, ECHO, STATUS$P) ADDRESS;

        CALL ISIS(0, .CONN$P);
    END;

    CLOSE: PROCEDURE(CONN, STATUS$P);
        DECLARE (CONN, STATUS$P) ADDRESS;

        CALL ISIS(1, .CONN);
    END;

    DEBLANK: PROCEDURE(PTR) ADDRESS;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE (C = ' ');
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;

    DELIMIT: PROCEDURE(PTR) ADDRESS;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE (C = ':' OR C = '.' OR
                 ('0' <= C AND C <= '9') OR
                 ('A' <= C AND C <= 'Z'));
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;

    SEQ: PROCEDURE(S1, S2, CNT) BYTE;
        DECLARE (S1,S2) ADDRESS, CNT BYTE;
        DECLARE S1A BASED S1(1) BYTE;
        DECLARE S2A BASED S2(1) BYTE;
        DECLARE I BYTE;
        CNT = CNT - 1;
        DO I = 0 TO CNT;
            IF S1A(I) <> S2A(I) THEN
                RETURN 0;
        END;
        RETURN 0FFH;
    END;


    SCANINTEGER: PROCEDURE(PTRPTR) ADDRESS;
        DECLARE PTRPTR ADDRESS;
        DECLARE PTR BASED PTRPTR ADDRESS;
        DECLARE (SCANPTR, BINVAL, OCTVAL, DECVAL, HEXVAL) ADDRESS;
        DECLARE C BASED SCANPTR BYTE;
        DECLARE (I, CONTINUE) BYTE;
        DECLARE DIGITS(16) BYTE INITIAL('0123456789ABCDEF');

        BINVAL, OCTVAL, DECVAL, HEXVAL = 0;
        SCANPTR = PTR;

        DO WHILE C = ' ';
            SCANPTR = SCANPTR + 1;
        END;

        CONTINUE = TRUE;
        DO WHILE CONTINUE;
            CONTINUE = FALSE;
            DO I = 0 TO 15;
                IF C = DIGITS(I) THEN DO;
                    IF I < 2 THEN
                        BINVAL = BINVAL + BINVAL + I;
                    OCTVAL = SHL(OCTVAL, 3) + I;
                    IF I < 10 THEN
                        DECVAL = DECVAL * 10 + I;
                    HEXVAL = SHL(HEXVAL, 4) + I;
                    SCANPTR = SCANPTR + 1;
                    CONTINUE = TRUE;
                END; 
            END;
        END;
        PTR = SCANPTR + 1;
        IF C = 'H' THEN
            RETURN HEXVAL;
        IF C = 'O' OR C = 'Q' THEN
            RETURN OCTVAL;
        PTR = SCANPTR;
        SCANPTR = SCANPTR - 1;
        IF C = 'B' THEN
            RETURN BINVAL;
        RETURN DECVAL;

    END;



    NUMOUT: PROCEDURE(VALUE, BASE, LC, BUFADR, WIDTH);
        DECLARE (VALUE, BUFADR) ADDRESS, (BASE, LC, WIDTH) BYTE; 
        DECLARE DIGITS DATA('0123456789ABCDEF');
        DECLARE I BYTE;
        DECLARE BUF BASED BUFADR (1) BYTE;

        DO I = 1 TO WIDTH;
            BUF(WIDTH - I) = DIGITS(VALUE MOD BASE);
            VALUE = VALUE / BASE;   
        END;

        I = 0;
        DO WHILE BUF(I) = '0' AND I < WIDTH - 1;
            BUF(I) = LC;
            I = I + 1;
        END;
    END;

    REPORTERROR: PROCEDURE(ERRNUM);
        DECLARE ERRNUM ADDRESS;
        DECLARE NUMBERBUFFER(4) BYTE, I ADDRESS, STATUS ADDRESS;
     

        DECLARE ERRMSG DATA(0, 0,
            2, 'ILLEGAL AFTN ARGUMENT', 0,
            4, 'INCORRECTLY SPECIFIED FILE', 0,
            5, 'UNRECOGNIZED DEVICE NAME', 0,
            6, 'ATTEMPT TO WRITE TO INPUT DEVICE', 0,
            8, 'ATTEMPT TO READ FROM OUTPUT DEVICE', 0,
            9, 'DIRECTORY FULL', 0,
            0AH, 'NOT ON SAME DISK', 0,
            0BH, 'FILE ALREADY EXISTS', 0,
            0CH, 'FILE IS ALREADY OPEN', 0,
            0DH, 'NO SUCH FILE', 0,
            0EH, 'WRITE PROTECTED', 0,
            0FH, 'LOAD TOO LOW', 0,
            10H, 'BAD LOAD FORMAT', 0,
            11H, 'NOT A DISK FILE', 0,
            12H, 'ILLEGAL ISIS COMMAND', 0,
            13H, 'ATTEMPTED SEEK ON NON-DISK FILE', 0,
            14H, 'ATTEMPTED BACK SEEK TO FAR', 0,
            16H, 'ILLEGAL ACCESS MODE TO OPEN', 0,
            17H, 'MISSING FILENAME', 0,
            19H, 'ILLEGAL ECHO FILE', 0,
            1AH, 'ILLEGAL ATTRIBUTE IDENTIFIER', 0,
            1BH, 'ILLEGAL SEEK COMMAND', 0,
            1CH, 'MISSING EXTENSION', 0,
            1FH, 'CAN', 27H, 'T SEEK ON WRITE ONLY FILE', 0,
            20H, 'CAN', 27H, 'T DELETE OPEN FILE', 0,
            23H, 'SEEK PAST EOF', 0,
            0C9H, 'UNRECOGNIZED SWITCH', 0,
            0CAH, 'UNRECOGNIZED DELIMITER', 0,
            0CBH, 'INVALID SYNTAX', 0,
            0CCH, 'PREMATURE EOF', 0,
            0CEH, 'ILLEGAL DISKETTE LABEL', 0,
            0D0H, 'CHECKSUM ERROR', 0
        );

        IF ERRNUM <> 0 THEN
        DO;
            I = 0;
            DO WHILE I < LENGTH(ERRMSG);
                IF ERRNUM = ERRMSG(I) AND ERRMSG(I + 1) <> 0 THEN
                DO;
                    I = I + 1;
                    CALL WRITE(0, .(' '), 1, .STATUS);
                    DO WHILE ERRMSG(I) <> 0;
                        CALL WRITE(0, .ERRMSG(I), 1, .STATUS);
                        I = I + 1;
                    END;
                    CALL WRITE(0, .(0DH, 0AH), 2, .STATUS);
                    return;
                END;
                ELSE
                DO;
                    DO WHILE ERRMSG(I) <> 0;
                        I = I + 1;
                    END;
                    I = I + 1;
                END;
            end;
            CALL ERROR(ERRNUM);
        END;
    END;

    FILE$ERROR: PROCEDURE(STATUS, PTR, CALLEXIT);
        DECLARE (STATUS, PTR) ADDRESS, CALLEXIT BYTE;
        DECLARE ERR$STATUS ADDRESS;

        IF STATUS <> 0 THEN
        DO;
            PTR = DEBLANK(PTR);
            CALL WRITE(0, .(' '), 1, .ERR$STATUS);
            CALL WRITE(0, PTR, DELIMIT(PTR) - PTR, .ERR$STATUS);
            CALL WRITE(0, .(','), 1, .ERR$STATUS);
            CALL REPORTERROR(STATUS);
            IF CALLEXIT THEN
                CALL EXIT;
        END;
    END;


    DECLARE BUFFER$SIZE ADDRESS;
    DECLARE IBUF(3328) BYTE, IPTR ADDRESS;
    DECLARE BUFFER(128) BYTE;
    DECLARE (BUFFER$PTR, OUTPUT$PTR, INPUT$PTR) ADDRESS;
    DECLARE (ACTUAL, STATUS) ADDRESS;
    DECLARE (START, ENDFILE) BYTE;
    DECLARE (AFT$OUT, AFT$IN) ADDRESS;
    DECLARE (START$VALUE, RECORD$PTR, CONTENT$PTR, LEN$PTR) ADDRESS;
    DECLARE (ADDR$PTR, RECORD$ADDR) ADDRESS;
    DECLARE (RLEN, TMP, I, CHECKSUM) BYTE;
    DECLARE LEN BASED LEN$PTR ADDRESS;
    DECLARE ADDR BASED ADDR$PTR ADDRESS;
    DECLARE CONTENT BASED CONTENT$PTR BYTE;
    DECLARE CHAR BASED BUFFER$PTR BYTE;


    GNC: PROCEDURE BYTE;

        IF IPTR = LENGTH(IBUF) THEN
        DO;
            CALL READ(AFT$IN, .IBUF, LENGTH(IBUF), .ACTUAL, .STATUS);
            CALL FILEERROR(STATUS, INPUT$PTR, TRUE);
            IF ACTUAL = 0 THEN
            DO;
                CALL FILEERROR(EARLY$EOF, INPUT$PTR, TRUE);
                CALL EXIT;
            END;
            IPTR = 0;
        END;
        IPTR = IPTR + 1;
        RETURN IBUF(IPTR - 1) AND 7FH;
    END GNC;

    HEX: PROCEDURE BYTE;
        DECLARE CHAR BYTE;

        IF (CHAR := GNC) >= '0' AND CHAR <= '9' THEN RETURN CHAR - '0';
        IF CHAR >= 'A' AND CHAR <= 'F' THEN RETURN CHAR - 37H;
        RETURN 0FFH;
    END HEX;

    BYTES: PROCEDURE BYTE;
        DECLARE CHAR BYTE;

        CHAR = SHL(HEX, 4) + HEX;
        CHECKSUM = CHECKSUM + CHAR;
        RETURN CHAR;
    END BYTES;


MAIN:
    START, ENDFILE = FALSE;
    INPUT$PTR = .(':CI: ');
    CALL READ(1, .BUFFER, LENGTH(BUFFER), .ACTUAL, .STATUS);
    CALL FILEERROR(STATUS, INPUT$PTR, TRUE);
    INPUT$PTR,BUFFER$PTR  = DEBLANK(.BUFFER);
    CALL OPEN(.AFT$IN, INPUT$PTR, READ$MODE, 0, .STATUS);
    CALL FILEERROR(STATUS, INPUT$PTR, TRUE);
    BUFFER$PTR = DEBLANK(DELIMIT(BUFFER$PTR));
    IF SEQ(.('TO '), BUFFER$PTR, 3) THEN
    DO;
        OUTPUT$PTR,BUFFER$PTR = DEBLANK(BUFFER$PTR + 2);
        BUFFER$PTR = DEBLANK(DELIMIT(BUFFER$PTR));
    END;
    ELSE DO;
        CALL REPORTERROR(BAD$SYNTAX);
        CALL EXIT;
    END;

    BUFFER$PTR = DELIMIT(DEBLANK(BUFFER$PTR));
    DO WHILE CHAR = '$';
        BUFFER$PTR = BUFFER$PTR + 1;
        IF CHAR = 'S' THEN DO;
            START = TRUE;
            BUFFER$PTR = DEBLANK(BUFFER$PTR + 1);
            IF CHAR <> '=' THEN DO;
                CALL REPORTERROR(BAD$SYNTAX);
                CALL EXIT;
            END;
            BUFFER$PTR = BUFFER$PTR + 1;
            START$VALUE = SCANINTEGER(.BUFFER$PTR);
        END;
        ELSE DO;
            CALL REPORTERROR(BAD$SWITCH);
            CALL EXIT;
        END;
        BUFFER$PTR = DEBLANK(DELIMIT(BUFFER$PTR));
    END;

    IF CHAR <> CR THEN DO;
        CALL REPORTERROR(BAD$SYNTAX);
        CALL EXIT;
    END;
    CALL OPEN(.AFT$OUT, OUTPUT$PTR, WRITEMODE, 0, .STATUS);
    CALL FILEERROR(STATUS, OUTPUT$PTR, TRUE);
    BUFFER$SIZE = MEMCHK - .MEMORY - 64;
    LEN$PTR = .MEMORY;
    LEN = 0;
    ADDR$PTR = .MEMORY + 2;
    ADDR = 0;
    CONTENT$PTR = .MEMORY + 4;
    RECORD$PTR = 0;
    IPTR = LENGTH(IBUF); 
    RLEN = 1;
    DO WHILE RLEN <> 0;
        DO WHILE GNC <> ':';
        END;
        CHECKSUM = 0;
        IF (RLEN := BYTES) <> 0 THEN DO;
            RECORD$ADDR = BYTES * 256 + BYTES;
            IF RECORD$PTR <> RECORD$ADDR OR LEN > BUFFER$SIZE THEN DO;
                IF LEN <> 0 THEN DO;
                    CALL WRITE(AFT$OUT, .MEMORY, LEN + 4, .STATUS);
                    CALL FILEERROR(STATUS, OUTPUT$PTR, TRUE);
                END;
                LEN = 0;
                RECORD$PTR = RECORD$ADDR;
                CONTENT$PTR = .MEMORY  + 4;
                ADDR = RECORD$ADDR;
            END;
            TMP = BYTES;
            DO I = 1 TO RLEN;
                CONTENT = BYTES;
                CONTENT$PTR = CONTENT$PTR + 1;
                RECORD$PTR = RECORD$PTR + 1;
                LEN = LEN + 1;
            END;
            TMP = BYTES;
            IF CHECKSUM <> 0 THEN DO;
                CALL FILEERROR(0D0H, INPUT$PTR, TRUE);
                CALL EXIT;
            END;
        END;
        ELSE DO;
            IF LEN <> 0 THEN DO;
                CALL WRITE(AFT$OUT, .MEMORY, LEN + 4, .STATUS);
                CALL FILEERROR(STATUS, OUTPUT$PTR, TRUE);
            END;
            LEN = 0;
            ADDR = BYTES * 256 + BYTES;
            IF START THEN
                ADDR = START$VALUE;
            CALL WRITE(AFT$OUT, .MEMORY, 4, .STATUS);
            CALL FILEERROR(STATUS, OUTPUT$PTR, TRUE);
        END;
    END;
    CALL CLOSE(AFT$IN, .STATUS);
    CALL FILEERROR(STATUS, INPUT$PTR, TRUE);
    CALL CLOSE(AFT$OUT, .STATUS);
    CALL FILEERROR(STATUS, OUTPUT$PTR, TRUE);
    CALL EXIT;

END;
EOF
isis.bin.cfg
$*=1 A=2 N=1 H=8

isis.bin.plm
3BH: DO;
    DECLARE VER DATA(1,2);

/* COMMON CONTROL CHARACTERS */
DECLARE CONTROL$E LITERALLY '5';
DECLARE BELL LITERALLY '7';
DECLARE BS LITERALLY '8';
DECLARE CR LITERALLY '0DH';
DECLARE LF LITERALLY '0AH';
DECLARE HASH LITERALLY '23H';
DECLARE CARET LITERALLY '5EH';
DECLARE CONTROL$P LITERALLY '10H';
DECLARE CONTROL$Q LITERALLY '11H';
DECLARE CONTROL$R LITERALLY '12H';
DECLARE CONTROL$S LITERALLY '13H';
DECLARE CONTROL$X LITERALLY '18H';
DECLARE CONTROL$Z LITERALLY '1AH';
DECLARE ESC LITERALLY '1BH';
DECLARE DELKEY LITERALLY '7FH';

/* BOOLEAN LITERALS */
DECLARE BOOLEAN LITERALLY 'BYTE';
DECLARE TRUE LITERALLY '0FFH';
DECLARE FALSE LITERALLY '0';

/* CONSOLE LITERALS */
DECLARE AFT$CONSOL$IN LITERALLY '3';
DECLARE AFT$CONSOL$OUT LITERALLY '2';
DECLARE READ$MODE LITERALLY '1';
DECLARE WRITE$MODE LITERALLY '2';
DECLARE UPDATE$MODE LITERALLY '3';

/* SEEK OPTIONS */
DECLARE SEEK$RETURN LITERALLY '0';
DECLARE SEEK$BACKWARD LITERALLY '1';
DECLARE SEEK$ABS LITERALLY '2';
DECLARE SEEK$FORWARD LITERALLY '3';
DECLARE SEEK$EOF LITERALLY '4';

/* ERROR CODES */
DECLARE OK LITERALLY '0';
DECLARE NO$FREE$BUFFER LITERALLY '1';
DECLARE BAD$AFT$NO LITERALLY '2';

DECLARE AFT$FULL LITERALLY '3';
DECLARE BAD$PATH LITERALLY '4';
DECLARE BAD$DEVICE LITERALLY '5';
DECLARE CANT$WRITE LITERALLY '6';
DECLARE DISK$FULL LITERALLY '7';
DECLARE CANT$READ LITERALLY '8';
DECLARE DIRECTORY$FULL LITERALLY '9';
DECLARE DIFFERENT$DISK LITERALLY '10';
DECLARE MULTIDEFINED LITERALLY '11';
DECLARE ALREADY$OPEN LITERALLY '12';
DECLARE NO$SUCH$FILE LITERALLY '13';
DECLARE WRITE$PROTECT LITERALLY '14';
DECLARE ISIS$OVERWRITE LITERALLY '15';
DECLARE BAD$LOAD$FORMAT LITERALLY '16';
DECLARE NON$DISK$FILE LITERALLY '17';
DECLARE BAD$COMMAND LITERALLY '18';
DECLARE NON$DISK$SEEK LITERALLY '19';
DECLARE LONG$BACK$SEEK LITERALLY '20';
DECLARE CANT$RESCAN LITERALLY '21';
DECLARE BAD$ACCESS LITERALLY '22';
DECLARE NULL$FILENAME LITERALLY '23';
DECLARE DISK$IO$ERROR LITERALLY '24';
DECLARE BAD$ECHO LITERALLY '25';
DECLARE BAD$ATTRIB LITERALLY '26';
DECLARE BAD$SEEK$ARG LITERALLY '27';
DECLARE NULL$EXTENSION LITERALLY '28';
DECLARE CONSOLE$EOF LITERALLY '29';
DECLARE DRIVE$NOT$READY LITERALLY '30';
DECLARE SEEK$ON$WRITE LITERALLY '31';
DECLARE CANT$DELETE LITERALLY '32';
DECLARE BAD$PARAMETER LITERALLY '33';
DECLARE BAD$RETSW LITERALLY '34';
DECLARE SEEK$PAST$EOF LITERALLY '35';

DECLARE WARNING LITERALLY '0';
DECLARE MESSAGE LITERALLY '1';
DECLARE ABORT LITERALLY '2';
DECLARE CMSK LITERALLY '0FCH';

/* ATTRIBUTES */
DECLARE INVISIBLE$ATTRIBUTE LITERALLY '1';
DECLARE SYSTEM$ATTRIBUTE LITERALLY '2';
DECLARE WRITEP$ATTRIBUTE LITERALLY '4';
DECLARE FORMAT$ATTRIBUTE LITERALLY '80H';

/* ACCESS MODE */
DECLARE ACCESS$READ LITERALLY '1';
DECLARE ACCESS$WRITE LITERALLY '2';

/* OMF RECORD TYPES */
DECLARE R$MODHDR LITERALLY '2';
DECLARE R$MODEND LITERALLY '4';
DECLARE R$CONTENT LITERALLY '6';
DECLARE R$RELOC LITERALLY '22H';

DECLARE AFT$BOTTOM LITERALLY '2';
DECLARE AFT$FIRST LITERALLY   '4';
DECLARE AFT$LAST LITERALLY '9';
DECLARE F1DEV LITERALLY '1';
DECLARE CIDEV LITERALLY '18';
DECLARE CODEV LITERALLY '19';
DECLARE BBDEV LITERALLY '20';

DECLARE BLINK LITERALLY '0';
DECLARE FLINK LITERALLY '1';

DECLARE CMD$RECAL LITERALLY '3';
DECLARE CMD$READ LITERALLY '4';
DECLARE CMD$WRITE LITERALLY '6';

DECLARE MDSMON LITERALLY '0';
DECLARE BTSTRP LITERALLY '8';

ISIS: PROCEDURE(COMMAND, PARAMETER$BLOCK);
    DECLARE COMMAND BYTE, PARAMETER$BLOCK ADDRESS;
    DECLARE PARAM BASED PARAMETER$BLOCK (5) ADDRESS;
    DECLARE COPYRIGHT DATA('(C) 1975,1976 INTEL CORP');
    DECLARE I BYTE;
    DECLARE SYSPARAM(0) ADDRESS;
    DECLARE USERSTATUS$P ADDRESS, USERSTATUS BASED USERSTATUS$P ADDRESS;
    DECLARE (PARAM1, PARAM2, PARAM3, PARAM4, PARAM5) ADDRESS;
    DECLARE RETPARAMIDX(14) BYTE INITIAL( 5, 2, 2, 5, 4, 5, 5, 3,
                                         3, 1, 4, 2, 2, 3);
    DECLARE PARAMTYPE(5) ADDRESS INITIAL(
                111110001010B,    /* BIT SET IF PARAMETER NEEDS TO CHECK FOR */
                111001100111110B,    /* ADDRESS BELOW MEMORY (3000H) */
                100001101000000B,
                100001110000B,
                11010010B);

    DECLARE COLD$START$FLAG BOOLEAN INITIAL (TRUE);
    DECLARE USERSP ADDRESS;
    DECLARE USRSTK(64) BYTE INITIAL(0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,
                                    0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,
                                    0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,
                                    0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,
                                    0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,
                                    0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,
                                    0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,
                                    0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,0C7H);
    DECLARE TOPSTACK(0) BYTE;

    CI: PROCEDURE BYTE;
        GOTO 0F803H;
    END;

    RI: PROCEDURE BYTE;
        GOTO 0F806H;
    END;

    CO: PROCEDURE(CH);
        DECLARE CH BYTE;
        GOTO 0F809H;
    END;

    PO: PROCEDURE(CH);
        DECLARE CH BYTE;
        GOTO 0F80CH;
    END;

    LO: PROCEDURE(CH);
        DECLARE CH BYTE;
        GOTO 0F80FH;
    END;

    IOCHK: PROCEDURE BYTE;
        GOTO 0F815H;
    END;

    IOSET: PROCEDURE(CH);
        DECLARE CH BYTE;
        GOTO 0F818H;
    END;

    MEMCK: PROCEDURE ADDRESS;
        GOTO 0F81BH;
    END;

    BINASC: PROCEDURE(VALUE, BASE, LC, BUFADR, WIDTH);
        DECLARE (VALUE, BUFADR) ADDRESS, (BASE, LC, WIDTH) BYTE;
        DECLARE DIGITS DATA('0123456789ABCDEF');
        DECLARE I BYTE;
        DECLARE BUF BASED BUFADR (1) BYTE;

        DO I = 1 TO WIDTH;
            BUF(WIDTH - I) = DIGITS(VALUE MOD BASE);
            VALUE = VALUE / BASE;
        END;

        I = 0;
        DO WHILE BUF(I) = '0' AND I < WIDTH - 1;
            BUF(I) = LC;
            I = I + 1;
        END;
    END;

    DECLARE STATUS ADDRESS;
    DECLARE DEBUG$TOGGLE BYTE INITIAL(0);
    DECLARE GLOBAL$SEVERITY BYTE INITIAL(0);
    DECLARE FDCC$ERROR$TYPE ADDRESS INITIAL(0);
    DECLARE INITIO$BASE ADDRESS INITIAL(6), INITIO BASED INITIO$BASE BYTE;
    /*
       THE ERR PROCEDURE IS USED TO HANDLE ERROR CONDIITONS.
           AN ERROR MESSAGE IS ISSUED TO THE CONSOLE, WHICH FOR
           DISK ERRORS HAS EXTENDED CONTENT
       CONTROL THEN PASSES TO THE MDS MONITOR

       ERROR$TYPE IS THE ERROR NUMBER WHICH IDENTIFIES THE PARTICUALAR
              TYPE OF ERROR, SUCH AS DISK I/O ERROR
    */
    ERR: PROCEDURE(SEVERITY, ERROR$TYPE);
        DECLARE (SEVERITY, ERROR$TYPE, I, IMAX) BYTE;
        DECLARE PC BASED USER$SP ADDRESS;
        DECLARE MSG1(8) BYTE INITIAL(CR, LF, 'ERROR '),
                MSG2(3) BYTE INITIAL(0, 0, 0), /* ERROR NUMBER GOES HERE */
                MSG3(9) BYTE INITIAL(' USER PC '),
                MSG4(4) BYTE INITIAL(0,0,0,0), /* USER PC IN HEX GOES HERE */
                MSG5(2) BYTE INITIAL(CR, LF),
                MSG6(5) BYTE INITIAL('FDCC='),
                MSG7(4) BYTE INITIAL(0,0,0,0), /* FDCC ERROR DATA GOES HERE */
                MSG8(2) BYTE INITIAL(CR, LF);

        IF (SEVERITY := SEVERITY OR GLOBAL$SEVERITY) <> WARNING THEN
        DO;
            CALL BINASC(ERROR$TYPE, 10, 0, .MSG2, 3);
            CALL BINASC(PC,16,'0',.MSG4,4);
            CALL IOSET((IOCHK AND CMSK) OR (INITIO AND 3));
            IMAX = 25;  /* NUMBER OF CHARACTERS IN NORMAL ERROR MESSAGE */
            IF ERROR$TYPE = DISK$IO$ERROR THEN
            DO;
                IMAX = 36;
                CALL BINASC(FDCC$ERROR$TYPE, 16, '0', .MSG7, 4);
            END;
            DO I = 0 TO IMAX;
                CALL CO(MSG1(I));
            END;
        END;
        ELSE
        DO;
            USER$STATUS = ERROR$TYPE;
            STACKPTR = USER$SP;
        END;
        IF SEVERITY >= ABORT THEN
        DO;
            IF DEBUG$TOGGLE THEN
                GOTO MDSMON;    /* EXIT VIA MONITOR */
            GOTO BTSTRP;        /* EXIT VIA SOFTWARE BOOTSTRAP */
        END;
    END;

    DECLARE BUFFER$TABLE(19) BYTE INITIAL(0,0,0,0,0,0,0,0,0,0,
                             0,0,0,0,0,0,0,0,0);

    CLRBUF: PROCEDURE(BUFFER$P);
        DECLARE BUFFER$P ADDRESS;
        DECLARE BUFFER BASED BUFFER$P (128) BYTE;
        DECLARE I BYTE;

        DO I = 0 TO 127;
            BUFFER(I) = 0;
        END;
    END;


    FREEBUF: PROCEDURE(BUFFER);
        DECLARE BUFFER ADDRESS;

        BUFFER$TABLE(SHR(BUFFER - .MEMORY, 7)) = 0;
    END;

    GETBUF: PROCEDURE ADDRESS;
        DECLARE I BYTE;

        DO I = 0 TO LAST(BUFFER$TABLE);
            IF BUFFER$TABLE(I) = 0 THEN
            DO;
                BUFFER$TABLE(I) = 2;
                RETURN .MEMORY + SHL(DOUBLE(I), 7);
            END;
        END;
        CALL ERR(ABORT, NO$FREE$BUFFER);
    END;

    /* THE AFT TABLES AND POINTERS TO CURRENTLY SELECTED ENTRY */
    DECLARE AFT$CURRENT BYTE INITIAL(0FFH);
    DECLARE POINTER$BASE ADDRESS, LINKS BASED POINTER$BASE (64) ADDRESS;
    DECLARE DATUM$BASE ADDRESS, DATUM BASED DATUM$BASE (128) BYTE;
    DECLARE CLOSED$P ADDRESS, CUR$CLOSED BASED CLOSED$P BYTE;
    DECLARE DEVICE$P ADDRESS, CUR$DEVICE BASED DEVICE$P BYTE;
    DECLARE ACCESS$P ADDRESS, CUR$ACCESS BASED ACCESS$P BYTE;
    DECLARE ECHOAFT$P ADDRESS, CUR$ECHOAFT BASED ECHOAFT$P BYTE;
    DECLARE EBUF$P ADDRESS, CUR$EBUF BASED EBUF$P ADDRESS;
    DECLARE DBUF$P ADDRESS, CUR$DBUF BASED DBUF$P ADDRESS;
    DECLARE BYTENO$P ADDRESS, CUR$BYTENO BASED BYTENO$P BYTE;
    DECLARE DNUM$P ADDRESS, CUR$DNUM BASED DNUM$P ADDRESS;
    DECLARE LBUF$P ADDRESS, CUR$LBUF BASED LBUF$P ADDRESS;
    DECLARE DPTR$P ADDRESS, CUR$DPTR BASED DPTR$P BYTE;
    DECLARE LASTBYTE$P ADDRESS, CUR$LASTBYTE BASED LASTBYTE$P BYTE;
    DECLARE ALLOC$P ADDRESS, CUR$ALLOC BASED ALLOC$P BYTE;
    DECLARE DMOD$P ADDRESS, CUR$DMOD BASED DMOD$P BYTE;
    DECLARE BLKCNT$P ADDRESS, CUR$BLKCNT BASED BLKCNT$P ADDRESS;
    DECLARE BLKNO$P ADDRESS, CUR$BLKNO BASED BLKNO$P ADDRESS;
    DECLARE LADDR$P ADDRESS, CUR$LADDR BASED LADDR$P ADDRESS;
    DECLARE L1ADDR$P ADDRESS, CUR$L1ADDR BASED L1ADDR$P ADDRESS;
    DECLARE DADDR$P ADDRESS, CUR$DADDR BASED DADDR$P ADDRESS;


    DECLARE CLOSED(10) BYTE INITIAL(0, 0, 0FFH, 0FFH, 0FFH, 0FFH,
                                    0FFH, 0FFH, 0FFH, 0FFH);
    DECLARE DEVICE(10) BYTE INITIAL(0, 1, 0, 0, 0, 0, 0, 0, 0, 0);
    DECLARE ACCESS(10) BYTE INITIAL(3, 3, 0, 0, 0, 0, 0, 0, 0, 0);
    DECLARE ECHOAFT(10) BYTE INITIAL(0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    DECLARE EBUF(10) ADDRESS INITIAL(0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    DECLARE DBUF(10) ADDRESS INITIAL(0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    DECLARE BYTENO(10) BYTE INITIAL(128, 128, 0, 0, 0, 0, 0, 0, 0, 0);
    DECLARE DNUM(10) ADDRESS INITIAL(0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    DECLARE LBUF(10) ADDRESS INITIAL(0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    DECLARE DPTR(10) BYTE INITIAL(0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    DECLARE LASTBYTE(10) BYTE INITIAL(128, 128, 0, 0, 0, 0, 0, 0, 0, 0);
    DECLARE ALLOC(10) BYTE INITIAL(0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    DECLARE DMOD(10) BYTE INITIAL(0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    DECLARE BLKCNT(10) ADDRESS INITIAL(25, 25, 0, 0, 0, 0, 0, 0, 0, 0);
    DECLARE BLKNO(10) ADDRESS INITIAL(0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    DECLARE LADDR(10) ADDRESS INITIAL(101H, 101H, 0, 0, 0, 0, 0, 0, 0, 0);
    DECLARE L1ADDR(10) ADDRESS INITIAL(101H, 101H, 0, 0, 0, 0, 0, 0, 0, 0);
    DECLARE DADDR(10) ADDRESS INITIAL(102H, 102H, 0, 0, 0, 0, 0, 0, 0, 0);


    SETTABS: PROCEDURE(AFT);
        DECLARE AFT BYTE;

        IF AFT$CURRENT <> AFT THEN
        DO;
            AFT$CURRENT = AFT;
            CLOSED$P = .CLOSED(AFT);
            DEVICE$P = .DEVICE(AFT);
            ACCESS$P = .ACCESS(AFT);
            ECHOAFT$P = .ECHOAFT(AFT);
            EBUF$P = .EBUF(AFT);
            BYTENO$P = .BYTENO(AFT);
            DNUM$P = .DNUM(AFT);
            DPTR$P = .DPTR(AFT);
            LASTBYTE$P = .LASTBYTE(AFT);
            BLKNO$P = .BLKNO(AFT);
            ALLOC$P = .ALLOC(AFT);
            DMOD$P = .DMOD(AFT);
            BLKCNT$P = .BLKCNT(AFT);
            LADDR$P = .LADDR(AFT);
            L1ADDR$P = .L1ADDR(AFT);
            DADDR$P = .DADDR(AFT);
        END;
        LBUF$P = .LBUF(AFT);
        DBUF$P = .DBUF(AFT);
        POINTER$BASE = CUR$LBUF;
        DATUM$BASE = CUR$DBUF;
    END;

    GETAFT: PROCEDURE BYTE;
        DECLARE I BYTE;

        DO I = AFT$BOTTOM TO AFT$LAST;
            IF CLOSED(I) THEN
                RETURN I;
        END;
        CALL ERR(ABORT, AFT$FULL);
    END;

    PACKBUFS: PROCEDURE ADDRESS;
        DECLARE I BYTE, BUFFER$TOP ADDRESS;

        LOWBUF: PROCEDURE(BUFPTR);
            DECLARE BUFPTR ADDRESS;
            DECLARE (NEWBUF, OLDBUF) ADDRESS, I BYTE;
            DECLARE BUFFER BASED BUFPTR ADDRESS,
                    NBUF BASED NEWBUF (128) BYTE,
                    OBUF BASED OLDBUF (128) BYTE;

            I = SHR(BUFFER - .MEMORY, 7);
            IF BUFFER$TABLE(I) <> 2 THEN
                RETURN;
            OLDBUF = BUFFER;
            CALL FREEBUF(OLDBUF);
            NEWBUF = GETBUF;
            IF BUFFER$TOP < NEWBUF THEN
                BUFFER$TOP = NEWBUF;
            IF NEWBUF = OLDBUF THEN
                RETURN;
            DO I = 0 TO 127;
                NBUF(I) = OBUF(I);
            END;
            BUFFER = NEWBUF;
        END;

        BUFFER$TOP = .MEMORY;
        DO I = AFT$BOTTOM TO AFT$LAST;
            CALL LOWBUF(.LBUF(I));
            CALL LOWBUF(.DBUF(I));
            CALL LOWBUF(.EBUF(I));
        END;
        RETURN BUFFER$TOP + 128;
    END;

    /*
       XEQIOPB PROVIDES ACCESS TO THE FDCC
       CONTROLLER 1 = BASE ADDRESS 78H (DRIVES 0, 1 FOR SD)

       DRIVE: AN INTEGER 0-1, SPECIFYING THE DISK TO BE ACCESSED
       IOPB:  THE ADDRESS OF A PARAMETER BLOCK TO BE SENT TO THE
          FDCC CONTROLLER. THIS PARAMETER MUST BE SET UP
          AS IF IT WERE FOR DRIVE 0; IF 'DRIVE' SELECTS
          ANOTHER DRIVE, 'DISKIO' WILL SET ALL THE NECESSARY
          BITS

       THE CALLER PROVIDES A PARAMETER BLOCK SPECIFYING SOME
       VALID DISK OPERATION ON DRIVE 0 AND AN INTEGER DRIVE SELECT VALUE
       IN THIS BOOT CODE ONLY READ AND RECAL ARE USED
       THE PROCEDURE WAITS FOR THE CONTROLLER TO GO UNBUSY, THEN
       PERFORMS THE DESIRED ACTION. IN CASE OF A CONTROLLER ERROR,
       THE DISK DRIVE IS RECALIBRATED AND THE ACTION IS TRIED AGAIN.
       IF SUCCESSFUL COMPLETION CANNOT BE OBTAINED AFTER 'MAX$RETRIES'
       ATTEMPTS, A FATAL ERROR OCCURS, OTHERWISE A NORMAL RETURN IS MADE

    */
        DECLARE FDCC$STATUS$0   LITERALLY   '78H',
                RESULT$TYPE$0   LITERALLY   '79H',
                RESULT$BYTE$0   LITERALLY   '7BH',
                LOW$ADDRESS$0   LITERALLY   '79H',
                HIGH$ADDRESS$0  LITERALLY   '7AH';

        DECLARE MAX$RETRIES     LITERALLY   '10',
                DISK$DONE       LITERALLY   '4',
                READ$COMMAND    LITERALLY   '4',
                WRITE$COMMAND   LITERALLY   '6',
                RECALIBRATE     LITERALLY   '3';

        DECLARE IOCW    LITERALLY '0',      /* IOPB OFFSETS */
                IOINS   LITERALLY '1',
                NSEC    LITERALLY '2',
                TADR    LITERALLY '3',
                SADR    LITERALLY '4',
                BUFLO   LITERALLY '5',
                BUFHI   LITERALLY '6';


    XEQIOPB: PROCEDURE(DRIVE, IOPB);
        /* THIS PROCEDURE ISSUES THE IOPB TO THE DISK CONTROLLER, IN THE */
        /* CASE OF THE 8271 IT ALSO TRANSFERS THE DATA BYTE BY BYTE */
        DECLARE DRIVE BYTE; /* DRIVE NUMBER: ASSUMES VALUE 0,1 */
        DECLARE IOPB ADDRESS;   /* POINTER TO THE PARAMATER BLOCK NAMED DCB */
        DECLARE DCB BASED IOPB (7) BYTE;

        DECLARE TEMPA(0) ADDRESS;
        DECLARE (TEMP2, TEMP1) BYTE;

        /* RECALIBRATE COMMAND */
        DECLARE RECAL$PB(5) BYTE INITIAL(80H, RECALIBRATE, 0, 0, 0);

        DECLARE I BYTE;     /* INDEX VARIABLE IN FOR STATEMENTS */

        DISABLE;
        RECAL$PB(IOINS) = RECALIBRATE;
        RECAL$PB(SADR) = 0;
        IF DRIVE THEN   /* TRUE IF DRIVE 1 */
        DO;
            DCB(IOINS) = DCB(IOINS) OR 30H;
            DCB(SADR) = DCB(SADR) OR 20H;
            RECAL$PB(IOINS) = RECALIBRATE OR 30H;
            RECAL$PB(SADR) = 20H;
        END;

        DO I = 0 TO MAX$RETRIES;
            DO WHILE (INPUT(FDCC$STATUS$0) AND DISK$DONE) <> 0;
                TEMP1 = INPUT(RESULT$TYPE$0);
                TEMP1 = INPUT(RESULT$BYTE$0);
            END;
            /* IF DISK DRIVE NOT READY, GIVE FATAL ERROR */
            IF (INPUT(FDCC$STATUS$0) AND (DRIVE + 1)) = 0 THEN
                CALL ERR(ABORT, DRIVE$NOT$READY);
            /* START IO */
            OUTPUT(LOW$ADDRESS$0) = LOW(IOPB);
            OUTPUT(HIGH$ADDRESS$0) = HIGH(IOPB);

            DO WHILE (INPUT(FDCC$STATUS$0) AND DISK$DONE) = 0;
                ;
            END;
            TEMP1 = INPUT(RESULT$TYPE$0);
            IF (TEMP2 := INPUT(RESULT$BYTE$0)) = 0 THEN
            DO;
                ENABLE;
                RETURN;
            END;

            OUTPUT(LOW$ADDRESS$0) = LOW(.RECAL$PB);
            OUTPUT(HIGH$ADDRESS$0) = HIGH(.RECAL$PB);

            DO WHILE (INPUT(FDCC$STATUS$0) AND DISK$DONE) = 0;
                ;
            END;
        END;
        FDCC$ERROR$TYPE = TEMPA;
        CALL ERR(ABORT, DISK$IO$ERROR);
    END;


    XIO: PROCEDURE(OPCODE, DRIVE, TRKSEC, BUFFER);
        DECLARE (OPCODE, DRIVE) BYTE, (TRKSEC, BUFFER) ADDRESS;
        DECLARE DCB(10) BYTE INITIAL(80H, 0, 0, 0, 0, 0, 0, 0, 0, 0);

        DCB(IOINS) = OPCODE;
        DCB(NSEC) = 1;
        DCB(TADR) = HIGH(TRKSEC);
        DCB(SADR) = LOW(TRKSEC);
        DCB(BUFLO) = LOW(BUFFER);
        DCB(BUFHI) = HIGH(BUFFER);
        CALL XEQIOPB(DRIVE, .DCB);
    END;

    RDSEC: PROCEDURE(TRKSEC, BUFFER);
         DECLARE (TRKSEC, BUFFER) ADDRESS;
         CALL XIO(CMD$READ, CUR$DEVICE, TRKSEC, BUFFER);
    END;

    WRSEC: PROCEDURE(TRKSEC, BUFFER);
        DECLARE (TRKSEC, BUFFER) ADDRESS;
        CALL XIO(CMD$WRITE, CUR$DEVICE, TRKSEC, BUFFER);
    END;

    DECLARE DEVICENAMES(21) ADDRESS INITIAL (
        'F0','F1','TI','TO','VI','VO','I1','O1','TR','HR',
        'R1','R2','TP','HP','P1','P2','LP','L1','CI','CO','BB');
    DECLARE FULLNAME(15) BYTE;
    DECLARE (PN, PN2) (10) BYTE;

    CANON: PROCEDURE(FILENAME, INTFN$P) BYTE;
        DECLARE (FILENAME, INTFN$P) ADDRESS;
        DECLARE PATHCH BASED FILENAME BYTE; /* CHAR OF FILENAME POINTS TO */
        DECLARE PATHCHARS BASED FILENAME (1) BYTE;
        DECLARE INTFN BASED INTFN$P (10) BYTE;  /* BYTE VERSION OF INTFN  */
        DECLARE STARTNAME ADDRESS, STARTCH BASED STARTNAME BYTE;
        DECLARE DEVPAIR(0) ADDRESS, (SECOND, FIRST) BYTE;
        DECLARE (J, I) BYTE;


        ALPHANUM: PROCEDURE BOOLEAN;
            RETURN (PATHCH >= 'A' AND PATHCH <= 'Z')
                OR (PATHCH >= '0' AND PATHCH <= '9');
        END;


        DO I = 0 TO LAST(INTFN);    /* CLEAR INTFN */
            INTFN(I) = 0;
        END;
        DO WHILE PATHCH = ' ';  /* SKIP LEADING SPACE */
            FILENAME = FILENAME + 1;
        END;
        STARTNAME = FILENAME;
        IF PATHCH = ':' THEN
        DO;
            INTFN(0) = 0FFH;
            FIRST = PATHCHARS(1);
            SECOND = PATHCHARS(2);
            IF PATHCHARS(3) <> ':' THEN
                RETURN BAD$PATH;

            DO I =  0 TO LAST(DEVICENAMES);
                IF DEVICENAMES(I) = DEVPAIR(0) THEN 
                    INTFN(0) = I;   /* SAVE DEVICE NUMBER */
            END;
            IF INTFN(0) = 0FFH THEN
                RETURN BAD$DEVICE;
            FILENAME = FILENAME + 4;
        END;

        FIRST = 0;
        DO I = 1 TO 6;
            IF ALPHANUM THEN
            DO;
                INTFN(I) = PATHCH;
                FIRST = 1;
                FILENAME = FILENAME + 1;
            END;
        END;
        IF PATHCH = '.' THEN
        DO;
            FILENAME = FILENAME + 1;
            DO I = 7 TO 9;
                IF ALPHANUM THEN
                DO;
                    INTFN(I) = PATHCH;
                    FILENAME = FILENAME + 1;
                END;
            END;
        END;
        IF INTFN(0) <= F1DEV AND FIRST = 0 THEN
            RETURN NULL$FILENAME;
        J =  -1;
        DO WHILE STARTNAME < FILENAME;
            J = J + 1;
            FULLNAME(J) = STARTCH;
            STARTNAME = STARTNAME + 1;
        END;
        IF FULLNAME(J) = '.' THEN
            RETURN NULL$EXTENSION;
        FULLNAME(J + 1) = ' ';
        IF ALPHANUM  OR PATHCH = '.' OR PATHCH = ':' THEN
            RETURN BAD$PATH;
        RETURN OK;
    END;

    GETFN: PROCEDURE(FILENAME, INTFN$P);
        DECLARE (FILENAME, INTFN$P) ADDRESS;

        IF (STATUS := CANON(FILENAME, INTFN$P)) <> 0 THEN
            CALL ERR(WARNING, STATUS);
    END;


    DECLARE BITMAPBUFFER(256) BYTE,
        CURRENT$BITMAP BYTE INITIAL(0FFH),
        MAP$CHANGE BYTE INITIAL(FALSE),
        BASETRKSEC(0) ADDRESS, (BASESECTOR, BASETRACK) BYTE,
        BITMAPINDEX ADDRESS,
        MAP$DCB(10) BYTE INITIAL(80H, 0, 2, 2, 2, 0, 0, 0, 0, 0),
        BITMASK(8) BYTE INITIAL(80H, 40H, 20H, 10H, 8, 4, 2, 1);

    RWMAP: PROCEDURE(DRIVE, OPCD);
        DECLARE (DRIVE, OPCD) BYTE;

        OPMAP: PROCEDURE;
            MAP$CHANGE = FALSE;
            BITMAPINDEX = 0;
            BASETRKSEC = 1;
            MAP$DCB(IOINS) = OPCD;
            MAP$DCB(BUFLO) = LOW(.BITMAPBUFFER);
            MAP$DCB(BUFHI) = HIGH(.BITMAPBUFFER);
            CALL XEQIOPB(DRIVE, .MAP$DCB);

        END;

        IF DRIVE <> CURRENT$BITMAP THEN
        DO;
            IF OPCD = CMD$WRITE THEN
                RETURN;
            IF CURRENT$BITMAP <> 0FFH AND MAP$CHANGE THEN
            DO;
                OPCD = CMD$WRITE;
                DRIVE = 1 - DRIVE;
                CALL OPMAP;
                OPCD = CMD$READ;
                DRIVE = 1 - DRIVE;
            END;
            CURRENT$BITMAP = DRIVE;
            CALL OPMAP;
        END;
        ELSE IF OPCD = CMD$WRITE THEN
            CALL OPMAP;
    END;


    ALLOCATE: PROCEDURE(DRIVE) ADDRESS;
        DECLARE DRIVE BYTE;
        DECLARE BITNO BYTE;
        DECLARE TRKSEC(0) ADDRESS, (SECTOR, TRACK) BYTE;
        DECLARE BITMAPBYTE$P ADDRESS, BITMAPBYTE BASED BITMAPBYTE$P BYTE;

        CALL RWMAP(DRIVE, CMD$READ);

        DO TRACK = BASETRACK TO 76;
            DO SECTOR = BASESECTOR TO 26;
                BITNO = LOW(BITMAPINDEX) AND 7;
                BITMAPBYTE$P = .BITMAPBUFFER + SHR(BITMAPINDEX, 3);
                IF (BITMASK(BITNO) AND BITMAPBYTE) = 0 THEN /* FOUND A SLOT */
                    DO;
                        MAP$CHANGE = TRUE;
                        BITMAPBYTE = BITMAPBYTE OR BITMASK(BITNO);
                        BASETRKSEC = TRKSEC;
                        RETURN TRKSEC;
                    END;
                BITMAPINDEX = BITMAPINDEX + 1;
            END;
            BASESECTOR = 1;
        END;
        CALL ERR(ABORT, DISK$FULL);
    END;

    DEALLOC: PROCEDURE(DRIVE, TRKSEC);
        DECLARE DRIVE BYTE, TRKSEC ADDRESS;
        DECLARE BITMAPBYTE$P ADDRESS, BITMAPBYTE BASED BITMAPBYTE$P BYTE;
        DECLARE BITNO BYTE;

        CALL RWMAP(DRIVE, CMD$READ);
        IF (BITMAPBYTE$P := HIGH(TRKSEC) * 26 + LOW(TRKSEC) - 1) <
                                                        BITMAPINDEX THEN
        DO;
            BITMAPINDEX = BITMAPBYTE$P;
            BASETRKSEC = TRKSEC;
        END;
        BITNO = LOW(BITMAPBYTE$P) AND 7;
        BITMAPBYTE$P = .BITMAPBUFFER + SHR(BITMAPBYTE$P, 3);
        BITMAPBYTE = BITMAPBYTE AND NOT BITMASK(BITNO);
        MAP$CHANGE = TRUE;
    END;


    DECLARE MAXLL   LITERALLY   '122';  /* MAXIMUM LINE LENGTH */

    DECLARE IOBYTEMASKS DATA(0FFH, 0FFH, 0FCH, 0FCH, 0FCH, 0FCH, 0FCH, 0FCH, 0F3H,
                             0F3H, 0F3H, 0F3H, 0CFH, 0CFH, 0CFH, 0CFH, 3FH, 3FH);

    DECLARE IOBYTEFLAGS DATA(0, 0, 0, 0, 1, 1, 3, 3, 0,
                             4, 8, 0Ch, 0, 10h, 20h,  30h,  80h, 0C0h);

    SIZECK: PROCEDURE;
        IF CUR$BLKNO = CUR$BLKCNT AND CUR$LASTBYTE < CUR$BYTENO THEN
            CUR$LASTBYTE = CUR$BYTENO;
        IF CUR$BLKNO > CUR$BLKCNT THEN
        DO;
            CUR$BLKCNT = CUR$BLKNO;
            CUR$LASTBYTE = CUR$BYTENO;
        END;
    END;


    FIO: PROCEDURE(AFTN, BUFFER, COUNT, ACTUAL$P, READFLAG);
        DECLARE AFTN BYTE, (BUFFER, COUNT, ACTUAL$P) ADDRESS, READFLAG BYTE;
        DECLARE ACTUAL BASED ACTUAL$P ADDRESS;
        DECLARE NEEDWRITE BYTE, (WORK$BUF, NEWLINKS$P) ADDRESS;
        DECLARE NEWLINKS BASED NEWLINKS$P (64) ADDRESS;
        DECLARE BUFCH BASED BUFFER BYTE;

        GETD: PROCEDURE;
            IF CUR$DADDR <> 0 THEN
                RETURN;

            CUR$ALLOC = TRUE;

            CUR$BLKNO = CUR$BLKNO - 1;
            LINKS(CUR$DPTR), CUR$DADDR = ALLOCATE(CUR$DEVICE);
            CUR$BLKNO = CUR$BLKNO + 1;

            IF CUR$ACCESS = 3 THEN
            DO;
                CALL CLRBUF(CUR$DBUF);
                CALL WRSEC(CUR$DADDR, CUR$DBUF);
            END;
        END;


        ACTUAL = 0;

        DO WHILE COUNT > ACTUAL;
            IF CUR$BLKCNT <= CUR$BLKNO AND READFLAG
              AND CUR$BYTENO = CUR$LASTBYTE THEN
                RETURN;
            IF CUR$BYTENO = 128 THEN
            DO;
                CUR$BYTENO = 0;
                IF CUR$DMOD THEN
                DO;
                    CALL WRSEC(CUR$DADDR, CUR$DBUF);
                    CUR$DMOD = FALSE;
                END;
                IF (CUR$DPTR := CUR$DPTR + 1) = 64 THEN
                DO;
                    IF LINKS(FLINK) = 0 THEN
                    DO;
                        LINKS(FLINK) = ALLOCATE(CUR$DEVICE);
                        CUR$ALLOC = TRUE;
                        CALL CLRBUF(CUR$DBUF);
                        NEWLINKS$P = CUR$DBUF;
                        NEWLINKS(0) = CUR$LADDR;    /* SAVE FORWARD LINK */
                        CALL RWMAP(CUR$DEVICE, CMD$WRITE);
                        CALL WRSEC(LINKS(FLINK), CUR$DBUF);
                    END;

                    IF CUR$ALLOC THEN
                    DO;
                        CALL RWMAP(CUR$DEVICE, CMD$WRITE);
                        CALL WRSEC(CUR$LADDR, CUR$LBUF);
                        CUR$ALLOC = FALSE;
                    END;
                    CUR$LADDR = LINKS(FLINK);
                    CALL RDSEC(CUR$LADDR, CUR$LBUF);
                    CUR$DPTR = 2;
                END;

                CUR$BLKNO = CUR$BLKNO + 1;
                CUR$DADDR = LINKS(CUR$DPTR);

                IF (NEEDWRITE := COUNT - ACTUAL >= 128 AND
                   (NOT READFLAG OR CUR$BLKNO < CUR$BLKCNT)) THEN
                DO;
                    ACTUAL = ACTUAL + (CUR$BYTENO := 128);
                    WORK$BUF = BUFFER;
                    BUFFER = BUFFER + 128;
                END;
                ELSE
                    WORK$BUF = CUR$DBUF;

                IF READFLAG THEN
                DO;
                    IF CUR$DADDR = 0 THEN
                        CALL CLRBUF(WORK$BUF);
                    ELSE
                        CALL RDSEC(CUR$DADDR, WORK$BUF);
                END;
                ELSE
                DO;
                    CALL GETD;
                    IF NEEDWRITE THEN
                        CALL WRSEC(CUR$DADDR, WORK$BUF);
                    ELSE IF CUR$ACCESS = UPDATE$MODE THEN
                        CALL RDSEC(CUR$DADDR, WORK$BUF);
                END;
            END;

            IF CUR$BYTENO <> 128 THEN
            DO;
                IF READFLAG THEN
                    BUFCH = DATUM(CUR$BYTENO);
                ELSE
                DO;
                    CALL GETD;
                    DATUM(CUR$BYTENO) = BUFCH;
                    CUR$DMOD = TRUE;
                END;
                CUR$BYTENO = CUR$BYTENO + 1;
                BUFFER = BUFFER + 1;
                ACTUAL = ACTUAL + 1;
            END;
        END; /* OF DO WHILE */
        CALL SIZECK;
    END;


    SETDEV: PROCEDURE;
        /*
           SET LOGICAL FILE ASSIGNMENTS TO USE MONITOR ROUTINES
           FOR DOING BYTE AT A TIME I/O DEVICES
        */
        CALL IOSET((IOCHK AND IOBYTEMASKS(CUR$DEVICE))
                    OR IOBYTEFLAGS(CUR$DEVICE));
    END;


    READ: PROCEDURE(AFT, BUFFER, COUNT, ACTUAL$P) ;
        DECLARE AFT BYTE, (BUFFER, COUNT, ACTUAL$P) ADDRESS;
        DECLARE ACTUAL BASED ACTUAL$P ADDRESS;
        DECLARE CH BASED BUFFER BYTE;
        DECLARE READCASE(18) BYTE INITIAL(0, 0, 1, 0FFH, 1, 0FFH, 1,
                          0FFH, 2, 2, 2, 2, 0FFH, 0FFH, 0FFH, 0FFH, 0FFH, 0FFH);

        ACTUAL = 0;
        CALL SETTABS(AFT);

        IF (CUR$ACCESS AND 1) = 0 THEN    /* NOT READ */
            CALL ERR(WARNING, CANT$READ);

        CALL SETDEV;
        IF CUR$DEVICE <= F1DEV THEN
            CALL FIO(AFT, BUFFER, COUNT, ACTUAL$P, TRUE);
        ELSE
        DO WHILE 1;
            IF ACTUAL = COUNT THEN
                RETURN;
            IF READCASE(CUR$DEVICE) THEN
                CH = CI;
            ELSE
            DO;
                CH = RI;
                IF CARRY THEN
                    RETURN;
            END;
            BUFFER = BUFFER + 1;
            ACTUAL = ACTUAL + 1;
        END;
    END;

    WRITE: PROCEDURE(AFT, BUFFER, COUNT);
        DECLARE AFT BYTE, (BUFFER, COUNT) ADDRESS;
        DECLARE CH BASED BUFFER BYTE;
        DECLARE ACTUAL ADDRESS;
        DECLARE WRITECASE(18) BYTE INITIAL(0, 0, 0FFH, 1, 0FFH, 1,
                                      0FFH, 1, 0FFH, 0FFH, 0FFH, 0FFH, 2, 2,
                                      2, 2, 3, 3);

        IF AFT = 0FFH THEN
            RETURN;
        CALL SETTABS(AFT);
        IF (CUR$ACCESS AND 2) = 0 OR CUR$CLOSED THEN
            CALL ERR(WARNING, CANT$WRITE);

        CALL SETDEV;

        DO WHILE COUNT <> 0;
            DO CASE WRITECASE(CUR$DEVICE);
            DO;     /* CASE 0 */
                CALL FIO(AFT, BUFFER, COUNT, .ACTUAL, FALSE);
                RETURN;
            END;
            DO;     /* CASE 1 */
                CALL CO(CH);
            END;
            CALL PO(CH);        /* CASE 2 */
            CALL LO(CH);        /* CASE 3 */
            END;

            COUNT = COUNT - 1;
            BUFFER = BUFFER + 1;
        END;
    END;



    EDIT: PROCEDURE(AFT, BUFFER, COUNT, ACTUAL$P);
        DECLARE AFT BYTE, (BUFFER, COUNT, ACTUAL$P) ADDRESS;
        DECLARE ACTUAL BASED ACTUAL$P ADDRESS;
        DECLARE LINE$P ADDRESS,
            IN$MODE BYTE,
            LPTR BYTE,
            CHAR BYTE,
            I BYTE,     /* NOTE READ CLOBBERS SELECTOR AS WELL */
            SELECTOR BYTE;
        DECLARE OBUF BASED BUFFER (1) BYTE;
        DECLARE BYTES BASED LINE$P (128) BYTE;
        DECLARE ADDR BASED LINE$P (64) ADDRESS;
        DECLARE SPECIALCHARS(8) BYTE INITIAL(0, DELKEY, CONTROL$Z, CONTROL$R,
                                 CONTROL$X, CR, LF, ESC);


        ECHO: PROCEDURE(CHAR);      /* NESTED SUB OF EDIT */
            DECLARE CHAR BYTE;
            CALL WRITE(CUR$ECHOAFT, .CHAR, 1);
            CALL SETTABS(AFT);
        END;

        LINE$P = EBUF(AFT);
        LPTR = BYTES(126);
        IN$MODE = BYTES(127);

        DO WHILE IN$MODE;
            CALL READ(AFT, .CHAR, 1, .I);
            BYTES(125) = FALSE;
            CHAR = CHAR AND 7FH;
            IF I = 0 THEN
            DO;
                IF AFT = AFT$CONSOL$IN THEN
                    CALL ERR(ABORT, CONSOLE$EOF);
                CHAR = CONTROL$Z;
            END;
            IF CHAR <> LF THEN
                CALL ECHO(BYTES(LPTR) := CHAR);

            SELECTOR = 0;
            DO I = 0 TO LAST(SPECIALCHARS);
                IF CHAR = SPECIALCHARS(I) THEN
                    SELECTOR = I;
            END;
            DO CASE SELECTOR;
                LPTR = LPTR + 1;    /* CASE 0 - NORMAL */
                DO;         /* CASE 1, RUBOUT */
                    IF LPTR <> 0 THEN
                    DO;
                        CALL ECHO(BYTES(LPTR := LPTR - 1));
                    END;
                    ELSE
                        CALL ECHO(BELL);
                END;
                DO;         /* CASE 2 - CONTROL-Z */
                    ACTUAL = 0;
                    BYTES(125) = TRUE;
                    ADDR(63) = 0FF00H;
                    CALL ECHO(CR);
                    CALL ECHO(LF);
                    RETURN;
                END;
                DO;         /* CASE 3 - CONTROL-R */
                    CALL ECHO(CR);
                    CALL ECHO(LF);
                    CALL WRITE(ECHOAFT(AFT), LINE$P, LPTR);
                END;
                DO;         /* CASE 4 - CONTROL-X */
                    LPTR = 0;
                    CALL ECHO(HASH);
                    CALL ECHO(CR);
                    CALL ECHO(LF);
                END;
                DO;         /* CASE 5 - CR */
                    BYTES(LPTR := LPTR + 1) = LF;
                    CALL ECHO(LF);
                    IN$MODE = FALSE;
                    LPTR = 0;
                END;
                DO;         /* CASE 6 - LF */
                    IF LPTR <> 0 THEN
                    DO;
                        CALL ECHO(BYTES(LPTR) := CHAR);
                        IN$MODE = FALSE;
                        LPTR = 0;
                    END;
                END;
                DO;         /* CASE 7 -  ESC */
                    CALL ECHO(0);
                    CALL ECHO('$');
                    IN$MODE = FALSE;
                    LPTR = 0;
                END;
            END; /* OF CASE */
            IF LPTR = 122 THEN
            DO;
                IN$MODE = FALSE;
                LPTR = 0;
            END;
        END;

        ACTUAL = 0;
        DO WHILE ACTUAL < COUNT AND NOT IN$MODE;
            IF LPTR < MAXLL THEN    /* 122 */
            DO;
                IF (OBUF(ACTUAL) := BYTES(LPTR)) = LF OR BYTES(LPTR) = ESC THEN
                DO;
                    IN$MODE = TRUE;
                    LPTR = -1;
                END;

                ACTUAL = ACTUAL + 1;
                LPTR = LPTR + 1;
            END;
            ELSE
            DO;
                IN$MODE = TRUE;
                LPTR = 0;
            END;
        END;
        BYTES(126) = LPTR;
        BYTES(127) = IN$MODE;
    END;


    RESCAN: PROCEDURE(AFTN);
        DECLARE AFTN BYTE;
        DECLARE BUF$P ADDRESS, BYTES BASED BUF$P(128) BYTE,
                      ADDR BASED BUF$P(64) ADDRESS;

        CALL SETTABS(AFTN);
        BUF$P = CUR$EBUF;
        IF CUR$ECHOAFT = 0 OR BYTES(125) THEN
            CALL ERR(WARNING, CANT$RESCAN);
        ADDR(63) = 0;   /* LPTR = 0, IN$MODE = FALSE */
    END;

    REWIND: PROCEDURE;
        CUR$BYTENO = 128;
        CUR$DPTR = 1;
        CUR$BLKNO = 0;
        CUR$ALLOC = 0;
        CUR$DMOD = 0;
        CUR$DADDR = 0;
        CALL RDSEC(CUR$LADDR := CUR$L1ADDR, CUR$LBUF);
    END;




    SEEK: PROCEDURE(AFT, MODE, BLOCKNO$P, BYTENO$P);
        DECLARE AFT BYTE, (MODE, BLOCKNO$P, BYTENO$P) ADDRESS;
        DECLARE BLOCKNO BASED BLOCKNO$P ADDRESS, BYTENO BASED BYTENO$P ADDRESS;
        DECLARE LOWMODE BYTE, BYTLO(0) BYTE, (BYT, BLK) ADDRESS;
        DECLARE BACKWARDS BYTE;
        DECLARE BYTENOSTEP(2) BYTE INITIAL(128, 1);
        DECLARE BLKNOSTEP(2) ADDRESS INITIAL(1, 0FFFFH);
        DECLARE NEXT ADDRESS;

        OFFEND: PROCEDURE(BLKNUMA, BLKNUMB, BYTENUMA, BYTENUMB) BOOLEAN;
            DECLARE (BLKNUMA, BLKNUMB) ADDRESS, (BYTENUMA, BYTENUMB) BYTE;

            BYTENUMA = BYTENUMA + LOW(BYT);
            BLKNUMA = (ROL(BYTENUMA, 1) AND 1) + BLK + BLKNUMA;
            BYTENUMA = BYTENUMA AND 7FH;
            BLKNUMB = BLKNUMB + (ROL(BYTENUMB, 1) AND 1);
            BYTENUMB = BYTENUMB AND 7FH;
            IF BLKNUMA <> BLKNUMB THEN
                RETURN BLKNUMB < BLKNUMA;
            RETURN BYTENUMB < BYTENUMA;

        END;

        BYT = BYTENO;
        BLK = BLOCKNO;

        IF MODE > SEEK$EOF THEN
            CALL ERR(WARNING, BAD$SEEK$ARG);

        CALL SETTABS(AFT);

        IF CUR$DEVICE > F1DEV THEN
            CALL ERR(WARNING, NON$DISK$SEEK);

        IF CUR$ACCESS = WRITE$MODE THEN
            CALL ERR(WARNING, SEEK$ON$WRITE);

        IF (LOWMODE := MODE) = SEEK$RETURN THEN
        DO;
            BYTENO = CUR$BYTENO;
            IF (BLOCKNO := CUR$BLKNO - 1) = 0FFFFH THEN
            DO;
                BLOCKNO, BYTENO = 0;
            END;
            RETURN;
        END;

        IF CUR$DMOD THEN
            CALL WRSEC(CUR$DADDR, CUR$DBUF);

        IF CUR$ALLOC THEN
        DO;
            CALL RWMAP(CUR$DEVICE, CMD$WRITE);
            CALL WRSEC(CUR$LADDR, CUR$LBUF);
        END;

        CUR$DMOD = 0;
        CUR$ALLOC = 0;

        IF LOWMODE = SEEK$EOF THEN
        DO;
            LOWMODE = SEEK$ABS;
            BYT = CUR$LASTBYTE;
            IF (BLK := CUR$BLKCNT - 1) = 0FFFFH THEN
                BLK, BYT = 0;
        END;
        IF LOWMODE = SEEK$ABS THEN
            CALL REWIND;

        BACKWARDS = (LOWMODE = 1) AND 1;
        BLK = (BLK AND 07FFFH) + SHR(BYT, 7);
        BYTLO = (BYTLO AND 7FH);
        IF NOT BACKWARDS THEN
        DO;
            IF (CUR$ACCESS = 1) AND OFFEND(CUR$BLKNO, CUR$BLKCNT,
                                         CUR$BYTENO, CUR$LASTBYTE) THEN
                CALL ERR(WARNING, SEEK$PAST$EOF);
        END;
        ELSE IF OFFEND(1, CUR$BLKNO, 0, CUR$BYTENO) THEN
                CALL ERR(WARNING, LONG$BACK$SEEK);

        DO WHILE BYTLO > 0;
            BYTLO = BYTLO - 1;
            IF CUR$BYTENO = BYTENOSTEP(BACKWARDS) THEN
            DO;
                CUR$BYTENO = BYTENOSTEP(1 - BACKWARDS);
                BLK = BLK + 1;
            END;
            ELSE
            DO;
                CUR$BYTENO = CUR$BYTENO + BLKNOSTEP(BACKWARDS);
            END;
            IF NOT BACKWARDS THEN
                CALL SIZECK;
        END;
        DO WHILE BLK > 0;
            BLK = BLK - 1;
            IF NOT BACKWARDS THEN
            DO;
                IF CUR$DPTR = 63 THEN
                DO;
                    CUR$DPTR = 1;
                    IF (NEXT := LINKS(FLINK)) = 0 THEN
                    DO;
                        LINKS(FLINK), NEXT = ALLOCATE(CUR$DEVICE);
                        CALL RWMAP(CUR$DEVICE, CMD$WRITE);
                        CALL WRSEC(CUR$LADDR, CUR$LBUF);
                        CALL CLRBUF(CUR$LBUF);
                        LINKS(BLINK) = CUR$LADDR;
                        CALL WRSEC(NEXT, CUR$LBUF);
                        CUR$LADDR = NEXT;
                    END;
                    ELSE
                        CALL RDSEC((CUR$LADDR := NEXT), CUR$LBUF);
                END;
                CUR$DPTR = CUR$DPTR + 1;
            END;
            ELSE IF (CUR$DPTR := CUR$DPTR - 1) < 2 THEN
                IF LINKS(BLINK) <> 0 THEN
                DO;
                    CUR$DPTR = 63;
                    CALL RDSEC(CUR$LADDR := LINKS(BLINK), CUR$LBUF);
                END;
            CUR$BLKNO = CUR$BLKNO + BLKNOSTEP(BACKWARDS);
        END;
        IF CUR$DADDR <> LINKS(CUR$DPTR) THEN
            IF (CUR$DADDR := LINKS(CUR$DPTR)) = 0 THEN
                CALL CLRBUF(CUR$DBUF);
            ELSE
                CALL RDSEC(CUR$DADDR, CUR$DBUF);
        CALL SIZECK;
    END;

    SYNC: PROCEDURE;
        CALL WRSEC(CUR$DADDR, CUR$DBUF);
    END;

    DECLARE DIRECT$EMPTY BYTE, DIRECT$FILE(9) BYTE, DIRECT$ATTRIB BYTE,
            DIRECT$EOF$COUNT BYTE, DIRECT$BLK ADDRESS, DIRECT$HDR$BLK ADDRESS;
    DECLARE DIRECT$INO BYTE;

    SEARCH: PROCEDURE(INTFN$P) BOOLEAN;
        DECLARE INTFN$P ADDRESS;
        DECLARE INTFN BASED INTFN$P (12) BYTE;
        DECLARE RCOUNT ADDRESS;
        DECLARE BLOCKNO ADDRESS INITIAL(0);
        DECLARE BYTENO ADDRESS;
        DECLARE (I, AFT) BYTE;
        DECLARE DNUM ADDRESS;
        DECLARE RETURN$VALUE BOOLEAN;
        /*
          THIS PROCEDURE IS USED TO LOOKUP A FILE NAME IN A
          DISK DIRECTORY. THE DEVICE NUMBER OF THE DISK
          IS CONTAINED IN FN(0), THE SIX CHARACTERS OF THE
          FILE NAME ARE IN FN(1) THROUGH FN(6), AND THE
          THREE CHARACTERS OF THE FILE EXTENSION ARE IN
          FN(7) THROUGH FN(9)

          THE PROCEDURE RETURNS 'TRUE' IF THE FILE IS FOUND,
          WITH DIRECT$I$NO POINTING TO THE ENTRY OF THE FILE IN THE
          DIRECTORY

          OTHERWISE, THE PROCEDURE RETURNS 'FALSE', AND DIRECT$I$NO POINTS
          AT A BLANK SLOT IN THE DIRECTORY. THE DIRECTORY MARKER IS
          ADJUSTED SO TAHT IT POINTS AT THE BEGINNING OF THE ENTRY
          POINTED TO BY DIRECT$I$NO.

          IF THE DIRECTORY IS FULL, DIRECT$I$NO = 0FFH
        */
        DBUF(AFT := CUR$DEVICE + 0) = GETBUF;
        LBUF(AFT) = GETBUF;
        CALL SETTABS(AFT);
        CALL REWIND;
        DIRECT$I$NO = 0FFH;
        DNUM = 0;
        RCOUNT = 1;
        DIRECT$EMPTY, RETURN$VALUE = 0;

        DO WHILE RCOUNT <> 0 AND DIRECT$EMPTY <> 7FH;
            CALL READ(AFT, .DIRECT$EMPTY, 16, .RCOUNT);
            IF DIRECT$EMPTY THEN
            DO;
                IF DIRECT$I$NO = 0FFH THEN
                    DIRECT$I$NO = DNUM;
            END;
            ELSE
            DO;
                DO I = 1 TO 9;
                    IF INTFN(I) <> DIRECT$FILE(I - 1) THEN
                    GOTO SKIP;
                END;
                DIRECT$I$NO = DNUM;
                RETURN$VALUE = 0FFH;
                RCOUNT = 0;
            END;
    SKIP:
            DNUM = DNUM + 1;
        END;

        IF DIRECT$I$NO <> 0FFH THEN
        DO;
            BYTENO = DIRECT$I$NO * 16;      /* SIZE OF DIRECT ENTRY */
            CALL SEEK(AFT, SEEK$ABS, .BLOCKNO, .BYTENO);
        END;
        CALL FREE$BUF(CUR$DBUF);
        CALL FREE$BUF(CUR$LBUF);
        RETURN RETURN$VALUE;
    END;


    ATTRIB: PROCEDURE(FILENAME, SWID, VALUE);
        DECLARE (FILENAME, SWID) ADDRESS, VALUE BYTE;
        DECLARE MASK(4) BYTE INITIAL(INVISIBLE$ATTRIBUTE,
                                       SYSTEM$ATTRIBUTE,
                                       WRITEP$ATTRIBUTE,
                                       FORMAT$ATTRIBUTE);

        IF SWID > 3 THEN
            CALL ERR(WARNING, BAD$ATTRIB);
        CALL GETFN(FILENAME, .PN);
        IF PN(0) > F1DEV THEN
            CALL ERR(WARNING, BAD$PATH);
        CALL SETTABS(PN(0));
        IF NOT SEARCH(.PN) THEN
            CALL ERR(WARNING, NO$SUCH$FILE);

        DIRECT$ATTRIB = DIRECT$ATTRIB OR MASK(LOW(SWID));
        IF NOT VALUE THEN
            DIRECT$ATTRIB = DIRECT$ATTRIB AND (NOT MASK(LOW(SWID)));
        CALL WRITE(PN(0), .DIRECT$EMPTY, 16);
        CALL SYNC;
    END;


    CLOSE: PROCEDURE(AFT);
        DECLARE AFT BYTE;
        DECLARE BLKZERO ADDRESS INITIAL(0), BYTNO ADDRESS INITIAL(0);
        DECLARE I BYTE;   /* READ RETURNS AN ADDRESS BUT HIGH BYTE WILL BE 0 */
        DECLARE CLOSECASE(21) BYTE INITIAL(0,0,       /* F0-F1 */
              1,2,1,2,1,2,1,1,1,1,  /* TI, TO, VI, VO, I1, O1, TR, HR, R1, R2 */
              3,3,3,3,4,4,0,0,0);   /* TP, HP, P1, P2, LP, L1, CI, CO, BB */

        CALL SETTABS(AFT);
        IF CUR$CLOSED THEN
            RETURN;
        IF CUR$ECHOAFT <> 0 THEN
            CALL FREE$BUF(CUR$EBUF);
        DO CASE CLOSECASE(CUR$DEVICE);
            DO; /* 0 - DISK OR CI,CO,BB */
                IF CUR$DMOD THEN
                    CALL WRSEC(CUR$DADDR, CUR$DBUF);
                IF CUR$ALLOC THEN
                    CALL WRSEC(CUR$LADDR, CUR$LBUF);

                CALL FREE$BUF(CUR$LBUF);
                CALL FREE$BUF(CUR$DBUF);
                IF CUR$ACCESS >= 2 THEN
                DO;
                    CALL SIZECK;
                    BLKZERO = 0;
                    CALL RWMAP(CUR$DEVICE, CMD$WRITE);
                    /* LET DEVICE USE RETURNED BUFFERS */
                    DBUF(CUR$DEVICE) = CUR$DBUF;
                    LBUF(CUR$DEVICE) = CUR$LBUF;
                    CALL SETTABS(CUR$DEVICE);
                    CALL REWIND;                 /* GET TO DIR HEADER */
                    BYTNO = 16 * DNUM(AFT);
                    /* SEEK TO FILE ENTRY */
                    CALL SEEK(CUR$DEVICE, SEEK$ABS, .BLKZERO, .BYTNO);
                    /* READ THE DIR ENTRY */
                    CALL READ(CUR$DEVICE, .DIRECT$EMPTY, 16, .I);
                    DIRECT$EOF$COUNT = LASTBYTE(AFT);
                    DIRECT$BLK = BLKCNT(AFT);
                    BYTNO = 16;
                    CALL SEEK(CUR$DEVICE, 1, .BLKZERO, .BYTNO);
                    CALL WRITE(CUR$DEVICE, .DIRECT$EMPTY, 16);
                    CALL SYNC;
                END;
            END;
            ;   /* 1 */
            CALL WRITE(AFT, .(CR, LF), 2);   /* 2 */
            DO I = 0 TO 119;    /* 3 OUTPUT 120 NULLS */
                CALL WRITE(AFT, .(0), 1);
            END;
            ;   /* 4 */
        END;
        CLOSED(AFT) = TRUE;
    END;


    RENAME: PROCEDURE(OLD$NAME, NEW$NAME);
        DECLARE (OLD$NAME, NEW$NAME) ADDRESS;
        DECLARE I BYTE;
        DECLARE ALREADY$EXISTS BOOLEAN;


        CALL GETFN(OLD$NAME, .PN2);
        CALL GETFN(NEW$NAME, .PN);
        IF PN(0) > F1DEV THEN
            CALL ERR(WARNING, NON$DISK$FILE);
        IF PN(0) <> PN2(0) THEN
            CALL ERR(WARNING, DIFFERENT$DISK);
        CALL SETTABS(PN(0));
        /* IF NEW$NAME ALREADY EXISTS AND OLD$NAME DOES NOT EXISTI,
           THEN WE WANT OT GIVE THE OLD$NAME ERROR MESSAGE.
           HOWEVER, SEARCH(NEW$NAME) SHOULD PRECEDE SEARCH(OLD$NAME)
           THIS IS BECAUSE POINTER VARIABLES SHOULD BE LEFT POINTING TO
           THE OLD FILE UPON EXIT FROM THIS PROCEDURE */
        ALREADY$EXISTS = SEARCH(.PN);
        IF NOT SEARCH(.PN2) THEN
            CALL ERR(WARNING, NO$SUCH$FILE);
        IF (DIRECT$ATTRIB AND (WRITEP$ATTRIBUTE OR FORMAT$ATTRIBUTE)) <> 0 THEN
            CALL ERR(WARNING, WRITE$PROTECT);
        IF ALREADY$EXISTS THEN
            CALL ERR(WARNING, MULTIDEFINED);
        DO I = 0 TO 8;
            DIRECT$FILE(I) = PN(I + 1);
        END;
        CALL WRITE(CUR$DEVICE + 0, .DIRECT$EMPTY, 16);
        CALL SYNC;
    END;

    SCRATCH: PROCEDURE(DRIVE);
        DECLARE DRIVE BYTE;
        DECLARE (AFT, I) BYTE;
        DECLARE BLOCKNO ADDRESS INITIAL (0);
        DECLARE BYTENO ADDRESS INITIAL(16 /* SIZE DIRECTORY ENTRY */);
        DECLARE LINKBUF$P ADDRESS, LINKBUF BASED LINKBUF$P (64) ADDRESS;

        /* INTERNAL DELETE ROUTING
        DRIVE = F0DEV .. F1DEV
        DIRECT MUST CONTAIN THE DIRECTORY ENTRY FOR AN EXISTING FILE OR DISK.
        AFT SLOT FOR THE APPROPRIATE DIRECTORY MUST HAVE BUFFERS;
        AND THESE BUFFERS MUST BE SETUP FOR DIRECTORY READING AND
        WRITING. THESE BUFFERS WILL BE CLOBBERED
        */
        DIRECT$EMPTY = TRUE;
        CALL SETTABS(AFT := DRIVE + 0);
        CALL WRITE(AFT, .DIRECT$EMPTY, 16);
        CALL XIO(CMD$WRITE, DRIVE, CUR$DADDR, CUR$DBUF);
        CALL SEEK(AFT, SEEK$BACKWARD, .BLOCKNO, .BYTENO);
        LINKBUF$P = CUR$DBUF;    /* LIST OF BLOCKS TO DELETE */
        DO WHILE DIRECT$HDR$BLK <> 0;
            CALL DEALLOC(DRIVE, DIRECT$HDR$BLK);
            CALL XIO(CMD$READ, DRIVE, DIRECT$HDR$BLK, LINKBUF$P);
            DIRECT$HDR$BLK = LINKBUF(FLINK);
            DO I = 2 TO 63;
                IF LINKBUF(I) <> 0 THEN
                    CALL DEALLOC(DRIVE, LINKBUF(I));
            END;
        END;
        CALL XIO(CMD$READ, DRIVE, CUR$DADDR, CUR$DBUF);
        CALL RWMAP(DRIVE, CMD$WRITE);
    END;


    DELETE: PROCEDURE(FILENAME);
        DECLARE FILENAME ADDRESS;
        DECLARE I BYTE;

        CALL GETFN(FILENAME, .PN);
        IF PN(0) > F1DEV THEN
            CALL ERR(WARNING, NON$DISK$FILE);
        ELSE
            CALL SETTABS(PN(0));
        IF SEARCH(.PN) THEN
        DO;
            IF (DIRECT$ATTRIB
              AND (WRITEP$ATTRIBUTE OR FORMAT$ATTRIBUTE)) = 0 THEN
            DO;
                DO I = AFT$BOTTOM TO AFT$LAST;
                    IF (NOT CLOSED(I))
                        AND (DEVICE(I) = PN(0)) AND (DNUM(I) = DIRECT$INO) THEN
                        CALL ERR(WARNING, CANT$DELETE);
                END;
                CALL SCRATCH(PN(0));
            END;
            ELSE
                CALL ERR(WARNING, WRITE$PROTECT);
        END;
        ELSE
            CALL ERR(WARNING, NO$SUCH$FILE);
    END;

    DECLARE ACCESS$SUPPORT DATA(3, 3, 1, 2, 1, 2,
                                1, 2, 1, 1, 1, 1, 2, 2,
                                2, 2, 2, 2, 1, 2);
    OPEN: PROCEDURE(FILENAME, INACCESS, ECHOAFT) BYTE;
        DECLARE (FILENAME, INACCESS, ECHOAFT) ADDRESS;
        DECLARE (AFT, REQACCESS, FOUND, TEMP, I) BYTE;
        DECLARE BUF$P ADDRESS, BYTES BASED BUF$P (128) BYTE,
                              ADDR BASED BUF$P (64) ADDRESS;

        FREE1: PROCEDURE(ERRNUM);
            DECLARE ERRNUM BYTE;

            IF CUR$ECHOAFT <> 0 THEN
                CALL FREE$BUF(CUR$EBUF);
            CALL ERR(WARNING, ERRNUM);
        END;

        FREE3: PROCEDURE(ERRNUM);
            DECLARE ERRNUM BYTE;

            CALL FREE$BUF(CUR$DBUF);
            CALL FREE$BUF(CUR$LBUF);
            CALL FREE1(ERRNUM);
        END;

        IF INACCESS > 3 OR (REQACCESS := INACCESS) = 0 THEN
            CALL ERR(WARNING, BAD$ACCESS);
        CALL GETFN(FILENAME, .PN);
        IF PN(0) = 20 THEN
            RETURN 0FFH;
        IF PN(0) = 0FFH THEN
                CALL ERR(WARNING, BAD$DEVICE);
        IF (ACCESS$SUPPORT(PN(0)) AND REQACCESS) = 0 THEN
                CALL ERR(WARNING, BAD$ACCESS);

        IF PN(0) = CIDEV THEN
            RETURN AFT$CONSOL$IN - AFT$BOTTOM;
        IF PN(0) = CODEV THEN
            RETURN AFT$CONSOL$OUT - AFT$BOTTOM;

        CALL SETTABS(AFT := GETAFT);
        CUR$ACCESS = REQACCESS;
        CUR$ECHOAFT = 0;
        IF ECHOAFT <> 0 THEN
        DO;
            CUR$ECHOAFT = AFT$BOTTOM + LOW(ECHOAFT);
            IF CUR$ECHOAFT < 2 THEN
                CUR$ECHOAFT = 0FFH;
            ELSE IF ACCESS(CUR$ECHOAFT) <> WRITE$MODE
              OR (CUR$ECHOAFT  >  10) THEN
                CALL ERR(WARNING, BAD$ECHO);

            BUF$P, CUR$EBUF = GET$BUF;
            BYTES(0) = LF;
            ADDR(63) = 0FF00H;
            BYTES(125) = TRUE;
        END;

        IF (CUR$DEVICE := PN(0)) <= F1DEV THEN
        DO;
            FOUND = SEARCH(.PN);
            CALL SETTABS(AFT);
            IF FOUND THEN
                DO I = AFT$BOTTOM TO AFT$LAST;
                    IF NOT CLOSED(I) THEN
                        IF DNUM(I) = DIRECT$I$NO AND DEVICE(I) = PN(0) THEN
                            CALL FREE1(ALREADY$OPEN);
                END;
            CUR$DNUM = DIRECT$I$NO;
            CUR$DBUF = GET$BUF;
            CUR$LBUF = GET$BUF;
            IF REQACCESS = 1 THEN
            DO;
                IF NOT FOUND THEN
                    CALL FREE3(NO$SUCH$FILE);
                CUR$L1ADDR = DIRECT$HDR$BLK;
                CUR$BLKCNT = DIRECT$BLK;
                CUR$LASTBYTE = DIRECT$EOF$COUNT;
                CALL REWIND;
            END;
            ELSE
            DO;
                IF NOT FOUND THEN
                DO;
                    IF DIRECT$I$NO = 0FFH THEN
                        CALL FREE3(DIRECTORY$FULL);
                    DIRECT$BLK = 0;
                    DIRECT$EOF$COUNT = 128;
                    DIRECT$ATTRIB = 0;
                END;
                IF (DIRECT$ATTRIB AND (WRITEP$ATTRIBUTE
                                       OR FORMAT$ATTRIBUTE)) <> 0 THEN
                    CALL FREE3(WRITE$PROTECT);

                IF REQACCESS = 2 AND FOUND THEN
                DO;
                    CALL SCRATCH(CUR$DEVICE);
                    CALL SETTABS(AFT);
                    DIRECT$BLK = 0;
                    DIRECT$EOF$COUNT = 128;
                END;
                CUR$LASTBYTE = DIRECT$EOF$COUNT;
                CUR$BLKCNT = DIRECT$BLK;
                IF NOT (TEMP := REQACCESS = 3 AND FOUND) THEN
                DO;
                    DIRECT$HDR$BLK = ALLOCATE(CUR$DEVICE);
                END;
                CUR$L1ADDR = DIRECT$HDR$BLK;
                DIRECT$EMPTY = 0;
                DO I = 0 TO 8;
                    DIRECT$FILE(I) = PN(I + 1);
                END;
                IF REQACCESS = 3 AND NOT FOUND THEN
                    DIRECT$ATTRIB = 0;
                CALL WRITE(CUR$DEVICE, .DIRECT$EMPTY, 16);
                CALL SYNC;

                CALL SETTABS(AFT);
                CALL REWIND;
                IF NOT TEMP THEN
                DO;
                    CALL CLRBUF(CUR$LBUF);
                    CALL RWMAP(CUR$DEVICE, CMD$WRITE);
                    CALL WRSEC(CUR$L1ADDR, CUR$LBUF);
                END;
            END;
        END;
        ELSE
        DO;
            DO I = AFT$BOTTOM TO AFT$LAST;
                IF NOT CLOSED(I) THEN
                    IF CUR$DEVICE = DEVICE(I) THEN
                        CALL FREE1(ALREADY$OPEN);
            END;
            IF CUR$DEVICE >= 12 AND CUR$DEVICE <= 15 THEN
                DO I = 1 TO 120;
                    CUR$CLOSED = FALSE;
                    CALL WRITE(AFT, .(0), 1);
                END;
        END;
        CUR$CLOSED = FALSE;
        RETURN AFT - AFT$BOTTOM;
    END;



    DECLARE CUR$CONSOL$IN(15) BYTE,
            CUR$CONSOL$OUT(15) BYTE;



    CONSOL: PROCEDURE(INFILE, OUTFILE);
        DECLARE (INFILE, OUTFILE) ADDRESS;
        DECLARE INSTRING BASED INFILE BYTE,
            OUTSTRING BASED OUTFILE BYTE;
        DECLARE COLD$CONSOL$IN(5)  BYTE INITIAL(': I: '),
                COLD$CONSOL$OUT(5) BYTE INITIAL(': O: ');
        DECLARE TEMP BYTE;
        DECLARE TDRV(2) BYTE INITIAL('TV'); /* T OR V IS 1ST LETTER OF NAME */

        IF COLD$START$FLAG THEN
        DO;
          COLD$START$FLAG = FALSE;
          COLD$CONSOL$IN(1), COLD$CONSOL$OUT(1) = TDRV(INITIO AND 1);
          INFILE = .COLD$CONSOL$IN;
          OUTFILE = .COLD$CONSOL$OUT;
        END;

        GLOBAL$SEVERITY = ABORT;
        CALL GETFN(OUTFILE, .PN);
        IF PN(0) = BBDEV THEN
            CALL ERR(WARNING, BAD$ECHO);
        IF PN(0) <> CODEV THEN
        DO;
            CALL CLOSE(AFT$CONSOL$OUT);
            TEMP = OPEN(OUTFILE, WRITE$MODE, FALSE);
            DO TEMP = 0 TO 14;
                CUR$CONSOL$OUT(TEMP) = FULLNAME(TEMP);
            END;
        END;
        CALL GETFN(INFILE, .PN);
        IF PN(0) = BBDEV THEN
            CALL ERR(ABORT, CONSOLE$EOF);
        IF PN(0) <> CIDEV THEN
        DO;
            CALL CLOSE(AFT$CONSOL$IN);
            TEMP = OPEN(INFILE, READ$MODE, 100H);
            DO TEMP = 0 TO 14;
                CUR$CONSOL$IN(TEMP) = FULLNAME(TEMP);
            END;
        END;
    END;


    WHOCON: PROCEDURE(AFT, BUFFER$P);
        DECLARE AFT BYTE;
        DECLARE BUFFER$P ADDRESS, BUFFER BASED BUFFER$P (1) BYTE;
        DECLARE NAME$P ADDRESS, NAME BASED NAME$P (1) BYTE;
        DECLARE I BYTE;

        IF AFT THEN
            NAME$P = .CUR$CONSOL$IN;
        ELSE
            NAME$P = .CUR$CONSOL$OUT;
        DO I = 0 TO 14;
            BUFFER(I) = NAME(I);
        END;
    END;


    LOAD: PROCEDURE(PATHNAME, BIAS, RETSW, ENTRY$P);
        DECLARE (PATHNAME, BIAS, RETSW, ENTRY$P) ADDRESS;
        DECLARE ENTRY BASED ENTRY$P ADDRESS;
        DECLARE PAD1 BYTE;
        DECLARE (AFT, I, RETSW$B) BYTE;
        DECLARE RECORD$LEN ADDRESS, RECORD$LOAD$ADDR ADDRESS;
        DECLARE ACTUAL ADDRESS,
                USER$BOTTOM ADDRESS INITIAL(0FFFFH), BUFFER$TOP ADDRESS;

        IF RETSW > 2 THEN
            CALL ERR(WARNING, BAD$RETSW);

        AFT = AFT$BOTTOM +  OPEN(PATHNAME, 1, 0);   /* OPEN$READ */

        IF (RETSW$B := RETSW) <> 0 THEN
            USER$BOTTOM = MEMCK;
        BUFFER$TOP = PACKBUFS;
        RECORD$LEN = 1;
        DO WHILE RECORD$LEN <> 0;
            /* READ THE LEN AND LOAD ADDRESS */
            CALL READ(AFT, .RECORD$LEN, 4, .ACTUAL);
            /* SHORT, RELOCATE OR ODD TYPE */
            IF ACTUAL < 4 THEN
                CALL ERR(ABORT, BAD$LOAD$FORMAT);
            RECORD$LOAD$ADDR = RECORD$LOAD$ADDR + BIAS;
            IF RECORD$LOAD$ADDR >= 18H AND RECORD$LOAD$ADDR <= 3FH
                  AND RECORD$LOAD$ADDR + RECORD$LEN <= 40H THEN
                ;
            ELSE
            DO;
                IF USER$BOTTOM > RECORD$LOAD$ADDR THEN
                /* FIRST ADDRESS WILL UPDATE THIS IF APPLICABLE */
                    USER$BOTTOM = RECORD$LOAD$ADDR; 
                IF BUFFER$TOP > RECORD$LOAD$ADDR
                  OR RECORD$LOAD$ADDR + RECORD$LEN  < RECORD$LOAD$ADDR THEN
                    CALL ERR(ABORT, ISIS$OVERWRITE);
            END;
            CALL READ(AFT, RECORD$LOAD$ADDR, RECORD$LEN, .ACTUAL);
            IF ACTUAL < RECORD$LEN THEN
                CALL ERR(ABORT, BAD$LOAD$FORMAT);
        END;
        CALL CLOSE(AFT);
        USER$BOTTOM = USER$BOTTOM AND 0FFF8H;
        DO I = 0 TO 18;
            IF .MEMORY + SHL(DOUBLE(I), 7) >= USER$BOTTOM THEN
                BUFFER$TABLE(I) = 1;
            ELSE
                BUFFER$TABLE(I) = BUFFER$TABLE(I) AND 0FEH;
        END;
        IF RETSW$B = 0 THEN
        DO;
            ENTRY = RECORD$LOAD$ADDR;
            RETURN;
        END;
        STACKPTR = USERSP;
        IF RETSW$B = 1 THEN
        DO;
            DEBUG$TOGGLE = FALSE;
            STACKPTR = STACKPTR + 2;
            GOTO RECORD$LOAD$ADDR;
        END;
        ENTRY$P = STACKPTR;
        ENTRY = RECORD$LOAD$ADDR;
        DEBUG$TOGGLE = TRUE;
        GOTO 0;
    END;

    EXIT: PROCEDURE;
        DECLARE I BYTE;
        DO I = AFT$FIRST TO AFT$LAST;
            CALL CLOSE(I);
        END;
        IF MAP$CHANGE THEN
            CALL RWMAP(CURRENT$BITMAP, CMD$WRITE);
        CURRENT$BITMAP = 0FFH;
        CALL LOAD(.('ISIS.CLI '), 0, 1, 0);
    END EXIT;

    DECLARE BOOTLOAD DATA(80H, 4, 26, 0, 1, 0, 30H);   /* 3000H -> MEMORY */

    REBOOT: PROCEDURE INTERRUPT 1;
        DECLARE I BYTE;
        STACKPTR = .TOPSTACK;
        DO I = AFT$BOTTOM TO AFT$LAST;
            CALL CLOSE(I);
        END;
        CALL XEQIOPB(0, .BOOTLOAD);
        GOTO 3000H;
    END;

    AFT$CHK: PROCEDURE;
        IF PARAM1 = 0FFH THEN
            CALL ERR(WARNING, OK); 
        IF (PARAM1 := PARAM1 + AFT$BOTTOM) >= 10 /* AFT$LAST + 1 */
                                         OR CLOSED(PARAM1) OR PARAM1 < AFT$BOTTOM THEN
            CALL ERR(WARNING, BAD$AFT$NO);
    END;

    /* ISIS */
    USERSP = STACKPTR;
    STACKPTR = .TOPSTACK;

    IF COMMAND = 'D' AND PARAM(0) = 'SK' THEN
        CALL XEQIOPB(PARAM(1), PARAM(2));
    ELSE
    DO;
        DO I = 0 TO 4;
            /* CHECK IF AN ADDRESS PARAMETER */
            IF SHR(PARAMTYPE(I), COMMAND + 1) THEN
                IF (PARAM(I) < .MEMORY) THEN
                    CALL ERR(ABORT, BAD$PARAMETER);
            SYSPARAM(I+1) = PARAM(I);
        END;

        /* GET THE RETURN STATUS ADDRESS */
        USERSTATUS$P = SYSPARAM(RETPARAMIDX(COMMAND));
        USERSTATUS = 0;
        GLOBAL$SEVERITY = 0;
        IF COMMAND < 14 THEN       /* MAX$COMMAND */
            DO CASE COMMAND;
            DO;     /* 0 - OPEN */
                DECLARE AFT BASED PARAM1 ADDRESS;
                AFT = OPEN(PARAM2, PARAM3, PARAM4);  /* FILE, ACCESS, MODE */
            END;
            DO;     /* 1 - CLOSE */
                CALL AFT$CHK;
                IF PARAM1 >= 4 THEN
                    CALL CLOSE(PARAM1);
            END;
            CALL DELETE(PARAM1);    /* 2 - DELETE - FILE */
            DO;         /* 3 - READ */
                DECLARE PARAM4VAL BASED PARAM4 ADDRESS;
                PARAM4VAL = 0;
                CALL AFT$CHK;
                IF ECHOAFT(PARAM1) = 0 THEN
                    /* AFTN, BUFFER, COUNT, ACTUAL */
                    CALL READ(PARAM1, PARAM2, PARAM3, PARAM4);
                ELSE
                    /* AFTN, BUFFER, COUNT, ACTUAL */
                    CALL EDIT(PARAM1, PARAM2, PARAM3, PARAM4);
            END;
            DO;         /* 4 - WRITE */
                CALL AFT$CHK;
                CALL WRITE(PARAM1, PARAM2, PARAM3); /* AFTN, BUFFER, COUNT */
            END;
            DO;         /* 5 - SEEK */
                CALL AFT$CHK;
                /* AFTN, BUFFER, COUNT, ACTUAL */
                CALL SEEK(PARAM1, PARAM2, PARAM3, PARAM4);
            END;
            /* 6 - LOAD - FILE, BASE, RETSW, ENTRY */
            CALL LOAD(PARAM1, PARAM2, PARAM3, PARAM4);
            CALL RENAME(PARAM1, PARAM2);      /* 7 - RENAME - FILE1, FILE2 */
            DO;                               /* 8 - CONSOLE - FILE1, FILE2 */
                GLOBAL$SEVERITY = 2;
                CALL CONSOL(PARAM1, PARAM2);
            END;
            CALL EXIT;                        /* 9 - EXIT */
            /* 10 - ATTRIB - FILE, SWID, SWVALUE */
            CALL ATTRIB(PARAM1, PARAM2, PARAM3);
            DO;         /* 11 - RESCAN */
                CALL AFT$CHK;
                CALL RESCAN(PARAM1);        /* AFTN */
            END;
            CALL ERR(MESSAGE, PARAM1);  /* 12 - ERROR - MESSAGE, ERRNUM */
            CALL WHOCON(PARAM1, PARAM2);    /* 13 - WHOCON - AFTN, BUFFER */
            END;
        ELSE
            CALL ERR(WARNING, BAD$COMMAND);
    END;
    STACKPTR = USERSP;
END;
END;
EOF

isis.bin_1.2.patch
TARGET=ISISBIN SOURCE=HEX START=0000 LOAD=0008

isis.cli.plm
/*
    THE SOURCE BELOW NEEDS TO BE COMPILED WITH THE FORTRAN CROSS COMPILER
    UNFORTUNATELY INTEL SEEM TO HAVE USED A LATER VERSION THAT SUPPORTED
    'AT' AND DID NOT FILL UNINITIALISED DATA WITH ZEROS

*/
3200H: DO; 
    DECLARE BOOLEAN LITERALLY 'BYTE';
    DECLARE TRUE    LITERALLY '0FFH';
    DECLARE FALSE   LITERALLY '0';
    DECLARE CR  LITERALLY '0DH',
            LF  LITERALLY '0AH';

    DECLARE BTSTRP LITERALLY '8';
    DECLARE MDSMON LITERALLY '0';

    DECLARE CVER DATA(1, 17);     /* ISIS.CLI VERSION */
    DECLARE COPYRIGHT DATA('(C) 1975,1976 INTEL CORP');

    ISIS: PROCEDURE(CMD, PARAM$P);
        DECLARE CMD BYTE, PARAM$P ADDRESS;
        GOTO 40H;
    END ISIS;

    READ: PROCEDURE(CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P) ADDRESS;

        CALL ISIS(3, .CONN);
    END;

    WRITE: PROCEDURE(CONN, BUFF$P, COUNT, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, STATUS$P) ADDRESS;

        CALL ISIS(4, .CONN);
    END;


    LOAD: PROCEDURE(PATH$P, LOAD$OFFSET, RETSW, ENTRY$P, STATUS$P);
        DECLARE (PATH$P, LOAD$OFFSET, RETSW, ENTRY$P, STATUS$P) ADDRESS;

        CALL ISIS(6, .PATH$P);
    END;
    
    RESCAN: PROCEDURE(CONN, STATUS$P);
        DECLARE (CONN, STATUS$P) ADDRESS;

        CALL ISIS(11, .CONN);
    END;

    ERROR: PROCEDURE(ERROR$NUM);
        DECLARE (ERROR$NUM, STATUS) ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(12, .ERROR$NUM);
    END;

    EXIT: PROCEDURE;
        DECLARE STATUS ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(9, .STATUS);
    END;

    DEBLANK: PROCEDURE(PTR) ADDRESS;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE (C = ' ');
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;

    DELIMIT: PROCEDURE(PTR) ADDRESS;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE (C = ':' OR C = '.' OR
                 ('0' <= C AND C <= '9') OR
                 ('A' <= C AND C <= 'Z'));
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;

    MEMCK: PROCEDURE ADDRESS;
        GOTO 0F81BH;
    END;


    SEQ: PROCEDURE(S1, S2, CNT) BYTE;
        DECLARE (S1,S2) ADDRESS, CNT BYTE;
        DECLARE S1A BASED S1(1) BYTE;
        DECLARE S2A BASED S2(1) BYTE;
        DECLARE I BYTE;
        CNT = CNT - 1;
        DO I = 0 TO CNT;
            IF S1A(I) <> S2A(I) THEN
                RETURN 0;
        END;
        RETURN 0FFH;
    END;

    /* NOT ACTUALLY USED */
    NUMOUT: PROCEDURE(VALUE, BASE, LC, BUFADR, WIDTH);
        DECLARE (VALUE, BUFADR) ADDRESS, (BASE, LC, WIDTH) BYTE; 
        DECLARE DIGITS DATA('0123456789ABCDEF');
        DECLARE I BYTE;
        DECLARE BUF BASED BUFADR (1) BYTE;

        DO I = 1 TO WIDTH;
            BUF(WIDTH - I) = DIGITS(VALUE MOD BASE);
            VALUE = VALUE / BASE;   
        END;

        I = 0;
        DO WHILE BUF(I) = '0' AND I < WIDTH - 1;
            BUF(I) = LC;
            I = I + 1;
        END;
    END;

    REPORTERROR: PROCEDURE(ERRNUM);
        DECLARE ERRNUM ADDRESS;
        DECLARE NUMBERBUFFER(3) BYTE, I ADDRESS, STATUS ADDRESS;
     

        DECLARE ERRMSG DATA(0, 0,
            2, 'ILLEGAL AFTN ARGUMENT', 0,
            4, 'INCORRECTLY SPECIFIED FILE', 0,
            5, 'UNRECOGNIZED DEVICE NAME', 0,
            6, 'ATTEMPT TO WRITE TO INPUT DEVICE', 0,
            8, 'ATTEMPT TO READ FROM OUTPUT DEVICE', 0,
            9, 'DIRECTORY FULL', 0,
            0AH, 'NOT ON SAME DISK', 0,
            0BH, 'FILE ALREADY EXISTS', 0,
            0CH, 'FILE IS ALREADY OPEN', 0,
            0DH, 'NO SUCH FILE', 0,
            0EH, 'WRITE PROTECTED', 0,
            0FH, 'LOAD TOO LOW', 0,
            10H, 'BAD LOAD FORMAT', 0,
            11H, 'NOT A DISK FILE', 0,
            12H, 'ILLEGAL ISIS COMMAND', 0,
            13H, 'ATTEMPTED SEEK ON NON-DISK FILE', 0,
            14H, 'ATTEMPTED BACK SEEK TO FAR', 0,
            16H, 'ILLEGAL ACCESS MODE TO OPEN', 0,
            17H, 'MISSING FILENAME', 0,
            19H, 'ILLEGAL ECHO FILE', 0,
            1AH, 'ILLEGAL ATTRIBUTE IDENTIFIER', 0,
            1BH, 'ILLEGAL SEEK COMMAND', 0,
            1CH, 'MISSING EXTENSION', 0,
            1FH, 'CAN', 27H, 'T SEEK ON WRITE ONLY FILE', 0,
            20H, 'CAN', 27H, 'T DELETE OPEN FILE', 0,
            23H, 'SEEK PAST EOF', 0,
            0C9H, 'UNRECOGNIZED SWITCH', 0,
            0CAH, 'UNRECOGNIZED DELIMITER', 0,
            0CBH, 'INVALID SYNTAX', 0,
            0CCH, 'PREMATURE EOF', 0,
            0CEH, 'ILLEGAL DISKETTE LABEL', 0,
            0D0H, 'CHECKSUM ERROR', 0
        );



        IF ERRNUM <> 0 THEN
        DO;
            I = 0;
            DO WHILE I < LENGTH(ERRMSG);
                IF ERRNUM = ERRMSG(I) AND ERRMSG(I + 1) <> 0 THEN
                DO;
                    I = I + 1;
                    CALL WRITE(0, .(' '), 1, .STATUS);
                    DO WHILE ERRMSG(I) <> 0;
                        CALL WRITE(0, .ERRMSG(I), 1, .STATUS);
                        I = I + 1;
                    END;
                    CALL WRITE(0, .(0DH, 0AH), 2, .STATUS);
                    return;
                END;
                ELSE
                DO;
                    DO WHILE ERRMSG(I) <> 0;
                        I = I + 1;
                    END;
                    I = I + 1;
                END;
            end;
            CALL ERROR(ERRNUM);
        END;
    END;


    FILE$ERROR: PROCEDURE(STATUS, PTR, CALLEXIT);
        DECLARE (STATUS, PTR) ADDRESS, CALLEXIT BYTE;
        DECLARE ERR$STATUS ADDRESS;

        IF STATUS <> 0 THEN
        DO;
            PTR = DEBLANK(PTR);
            CALL WRITE(0, .(' '), 1, .ERR$STATUS);
            CALL WRITE(0, PTR, DELIMIT(PTR) - PTR, .ERR$STATUS);
            CALL WRITE(0, .(','), 1, .ERR$STATUS);
            CALL REPORTERROR(STATUS);
            IF CALLEXIT THEN
                CALL EXIT;
        END;
    END;

MAIN:

    DECLARE BUFFER(128) BYTE;
    DECLARE DEBUG BOOLEAN;
    DECLARE BUFFER$PTR ADDRESS, CHAR BASED BUFFER$PTR BYTE;
    DECLARE (PATHNAME$PTR,ACTUAL,STATUS,ENTRY,RETSW) ADDRESS;
    DECLARE TOPSTACK ADDRESS, STACKWORD BASED TOPSTACK ADDRESS;


    STACKPTR = MEMCK;
    OUTPUT(0FCH) = 0FCH; /* ENABLE CONSOLE INTERRUPTS 0 AHD 1 */
    ENABLE;
    OUTPUT(0FDH) = 20H; /* SEND END OF INTERRUPT COMMAND */
    BUFFER$PTR = .(':CI: ');
    CALL RESCAN(1,.STATUS);
    IF STATUS = 0 THEN
    DO;
      CALL READ(1,.BUFFER,LENGTH(BUFFER),.ACTUAL,.STATUS);
      CALL FILE$ERROR(STATUS,BUFFER$PTR,TRUE);
    END;
    DO WHILE TRUE;
      CALL WRITE(0,.('-'),1,.STATUS);
      CALL REPORTERROR(STATUS);
      CALL READ(1,.BUFFER,LENGTH(BUFFER),.ACTUAL,.STATUS);
      CALL FILE$ERROR(STATUS,BUFFER$PTR,TRUE);
      BUFFER(ACTUAL) = CR;
      BUFFER$PTR = DEBLANK(.BUFFER);
      IF CHAR <> CR THEN
      DO;
        /* NOW CHECK FDR DEBUG MODE (PATHNAHE PRECEDED BY 'DEBUG' */
        DEBUG = FALSE; /* ASSUME NORMAL CASE, NOT DEBUGGING */
        IF SEQ(.('DEBUG'),BUFFER$PTR,5)
        AND (DELIMIT(BUFFER$PTR)=BUFFER$PTR+5) THEN
        DO;
          BUFFER$PTR = DEBLANK(DELIMIT(BUFFER$PTR+5));
          DEBUG = TRUE;
          IF CHAR = CR THEN DO;
            TOPSTACK = STACKPTR;
            STACKWORD = BTSTRP;
            GOTO MDSMON;
          END;
        END;
        PATHNAME$PTR = BUFFER$PTR;
        BUFFER$PTR = DELIMIT(DEBLANK(BUFFER$PTR));
        CALL RESCAN(1,.STATUS);
        CALL REPORTERROR(STATUS);
        CALL READ(1,.BUFFER,BUFFER$PTR-.BUFFER,.ACTUAL,.STATUS);
        CALL REPORTERROR(STATUS);
        IF DEBUG THEN RETSW = 2; ELSE RETSW = 1;
        CALL LOAD(PATHNAME$PTR,0,RETSW,.ENTRY,.STATUS);
        CALL FILE$ERROR(STATUS,PATHNAME$PTR,FALSE);
        CALL READ(1,.BUFFER,LENGTH(BUFFER),.ACTUAL,.STATUS);
        CALL REPORTERROR(STATUS);
      END;
    END;
END;
EOF
isis.t0.plm
/*
    THE SOURCE BELOW NEEDS TO BE COMPILED WITH THE FORTRAN CROSS COMPILER
*/
3000H: DO; 

    DECLARE BOOLEAN LITERALLY 'BYTE';
    DECLARE TRUE    LITERALLY '0FFH';
    DECLARE CMSK    LITERALLY '0FCH';
    DECLARE CR  LITERALLY '0DH',
            LF  LITERALLY '0AH';

    DECLARE T0VER DATA(1, 9);     /* ISIS.T0 VERSION ? */
    DECLARE COPYRIGHT DATA('(C) 1975,1976 INTEL CORP');

    DECLARE VERSION$LEVEL   LITERALLY   'BYTE$AT(3EH)',
            EDIT$LEVEL      LITERALLY   'BYTE$AT(3FH)';

    /* ALTHOUGH THE VARIABLES BELOW COULD HAVE BEEN
       EXPLICITLY FILLED WITH JUNK DATA TO MATCH THE ISIS.T0
       FILE. I USE THE PATCH CAPABILITY TO DO THIS INSTEAD
       AS THERE ARE OTHER HIDDEN LOCATIONS THAT NEED PATCHING
       WITH JUNK ('9') ANYWAY
    */
    DECLARE (USER$STATUS, USER$SP, START$ADDR) ADDRESS;

    DECLARE A$DEVICE BYTE INITIAL(0);
    DECLARE MEMBASE ADDRESS INITIAL(0);
    DECLARE BYTE$AT BASED MEMBASE (1) BYTE;

    DECLARE TEMP BYTE INITIAL(0);
    DECLARE ISIS$SIGNON(9) BYTE INITIAL(CR, LF, 'ISIS, V'),
            SIGN$V(2) BYTE INITIAL(0, 0), /* VERSION NUMBER */
            SIGN$DOT(1) BYTE INITIAL('.'),
            SIGN$E(2) BYTE INITIAL(0, 0),  /* EDIT NUMBER */
            SIGN$CRLF(2) BYTE INITIAL (CR, LF);


    ISIS: PROCEDURE(CMD, PARAM$P);
        DECLARE CMD BYTE, PARAM$P ADDRESS;
        GOTO 40H;
    END ISIS;

    READ: PROCEDURE(CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P) ADDRESS;

        CALL ISIS(3, .CONN);
    END;

    WRITE: PROCEDURE(CONN, BUFF$P, COUNT, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, STATUS$P) ADDRESS;

        CALL ISIS(4, .CONN);
    END;

    EXIT: PROCEDURE;
        DECLARE STATUS ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(9, .STATUS);
    END;

    CONSOL: PROCEDURE(CI$P, CO$P, STATUS$P);
        DECLARE (CI$P, CO$P,  STATUS$P) ADDRESS;

        CALL ISIS(8, .CI$P);
    END;

    NUMOUT: PROCEDURE(VALUE, BASE, LC, BUFADR, WIDTH);
        DECLARE (VALUE, BUFADR) ADDRESS, (BASE, LC, WIDTH) BYTE; 
        DECLARE DIGITS DATA('0123456789ABCDEF');
        DECLARE I BYTE;
        DECLARE BUF BASED BUFADR (1) BYTE;

        DO I = 1 TO WIDTH;
            BUF(WIDTH - I) = DIGITS(VALUE MOD BASE);
            VALUE = VALUE / BASE;   
        END;

        I = 0;
        DO WHILE BUF(I) = '0' AND I < WIDTH - 1;
            BUF(I) = LC;
            I = I + 1;
        END;
    END;



    /* THE FOLLOWING VARIABLES ARE USED IN THE ERR PROCEDURE */
    DECLARE STATUS ADDRESS INITIAL(0);
    DECLARE DEBUG$TOGGLE BYTE INITIAL(0);
    DECLARE GLOBAL$SEVERITY BYTE INITIAL(0);
    DECLARE FDCC$ERROR$TYPE ADDRESS INITIAL(0);
                                    /* HAS DATA ON DISK I/O ERRORS */
    /* USEFUL LITERALS */
    DECLARE WARNING LITERALLY '0',
            MESSAGE LITERALLY '1',
            ABORT   LITERALLY '2';

    DECLARE DISK$IO$ERROR   LITERALLY   '18H',
            DRIVE$NOT$READY LITERALLY   '1EH';

    DECLARE ISIS$HDR$BLK LITERALLY   '204H';


    DECLARE RTC LITERALLY '0FFH';   /* REAL TIME CLOCK */
    DECLARE BOOT LITERALLY '2';
    /* INPUT FROM RTC IS A BYTE. THE SECOND BIT FROM THE RIGHT
       CORRESPONDS TO THE BOOT SWITCH. IF THIS BIT IS 1 THE SWITCH IS
       ON, AND IF IT IS 0 THE  SWITCH IS OFF.
    */

    DECLARE MDSMON  LITERALLY   '0',
            BTSTRP  LITERALLY   '8';


    CI: PROCEDURE BYTE;
        GOTO 0F803H;
    END;

    RI: PROCEDURE BYTE;
        GOTO 0F806H;
    END;

    CO: PROCEDURE(C);
        DECLARE C BYTE;
        GOTO 0F809H;
    END;

    PO: PROCEDURE(C);
        DECLARE C BYTE;
        GOTO 0F80CH;
    END;

    LO: PROCEDURE(C);
        DECLARE C BYTE;
        GOTO 0F80FH;
    END;

    IOCHK: PROCEDURE BYTE;
        GOTO 0F815H;
    END;

    IOSET: PROCEDURE(C);
        DECLARE C BYTE;
        GOTO 0F818H;
    END;


    
    DECLARE INITIO$BASE ADDRESS INITIAL(6), INITIO BASED INITIO$BASE BYTE;

    /*
       THE ERR PROCEDURE IS USED TO HANDLE ERROR CONDIITONS.
           AN ERROR MESSAGE IS ISSUED TO THE CONSOLE, WHICH FOR
           DISK ERRORS HAS EXTENDED CONTENT
       CONTROL THEN PASSES TO THE MDS MONITOR

       ERROR$TYPE IS THE ERROR NUMBER WHICH IDENTIFIES THE PARTICUALAR
              TYPE OF ERROR, SUCH AS DISK I/O ERROR
    */

    ERR: PROCEDURE(SEVERITY, ERROR$TYPE);
        DECLARE (SEVERITY, ERROR$TYPE, I, IMAX) BYTE;
        DECLARE PC BASED USER$SP ADDRESS;
        DECLARE MSG1(8) BYTE INITIAL(CR, LF, 'ERROR '),
                MSG2(3) BYTE INITIAL(0, 0, 0), /* ERROR NUMBER GOES HERE */
                MSG3(9) BYTE INITIAL(' USER PC '),
                MSG4(4) BYTE INITIAL(0,0,0,0), /* USER PC IN HEX GOES HERE */
                MSG5(2) BYTE INITIAL(CR, LF),
                MSG6(5) BYTE INITIAL('FDCC='),
                MSG7(4) BYTE INITIAL(0,0,0,0), /* FDCC ERROR DATA GOES HERE */
                MSG8(2) BYTE INITIAL(CR, LF);

        IF (SEVERITY := SEVERITY OR GLOBAL$SEVERITY) <> WARNING THEN
        DO;
            CALL NUMOUT(ERROR$TYPE, 10, 0, .MSG2, 3);
            CALL NUMOUT(PC,16,'0',.MSG4,4);
            CALL IOSET((IOCHK AND CMSK) OR (INITIO AND 3));
            IMAX = 25;  /* NUMBER OF CHARACTERS IN NORMAL ERROR MESSAGE */
            IF ERROR$TYPE = DISK$IO$ERROR THEN
            DO;
                IMAX = 36;
                CALL NUMOUT(FDCC$ERROR$TYPE, 16, '0', .MSG7, 4);
            END;
            DO I = 0 TO IMAX;
                CALL CO(MSG1(I));
            END;
        END;
        ELSE
        DO;
            USER$STATUS = ERROR$TYPE;
            STACKPTR = USER$SP;
        END;
        IF SEVERITY >= ABORT THEN
        DO;
            IF DEBUG$TOGGLE THEN
                GOTO MDSMON;    /* EXIT VIA MONITOR */
            GOTO BTSTRP;        /* EXIT VIA SOFTWARE BOOTSTRAP */
        END;
    END;

    /*
       XEQIOPB PROVIDES ACCESS TO THE FDCC
       CONTROLLER 1 = BASE ADDRESS 78H (DRIVES 0, 1 FOR SD)

       DRIVE: AN INTEGER 0-1, SPECIFYING THE DISK TO BE ACCESSED
       IOPB:  THE ADDRESS OF A PARAMETER BLOCK TO BE SENT TO THE
          FDCC CONTROLLER. THIS PARAMETER MUST BE SET UP
          AS IF IT WERE FOR DRIVE 0; IF 'DRIVE' SELECTS
          ANOTHER DRIVE, 'DISKIO' WILL SET ALL THE NECESSARY
          BITS

       THE CALLER PROVIDES A PARAMETER BLOCK SPECIFYING SOME
       VALID DISK OPERATION ON DRIVE 0 AND AN INTEGER DRIVE SELECT VALUE
       IN THIS BOOT CODE ONLY READ AND RECAL ARE USED
       THE PROCEDURE WAITS FOR THE CONTROLLER TO GO UNBUSY, THEN
       PERFORMS THE DESIRED ACTION. IN CASE OF A CONTROLLER ERROR,
       THE DISK DRIVE IS RECALIBRATED AND THE ACTION IS TRIED AGAIN.
       IF SUCCESSFUL COMPLETION CANNOT BE OBTAINED AFTER 'MAX$RETRIES'
       ATTEMPTS, A FATAL ERROR OCCURS, OTHERWISE A NORMAL RETURN IS MADE

    */
        DECLARE FDCC$STATUS$0   LITERALLY   '78H',
                RESULT$TYPE$0   LITERALLY   '79H',
                RESULT$BYTE$0   LITERALLY   '7BH',
                LOW$ADDRESS$0   LITERALLY   '79H',
                HIGH$ADDRESS$0  LITERALLY   '7AH';

        DECLARE MAX$RETRIES     LITERALLY   '10',
                DISK$DONE       LITERALLY   '4',
                READ$COMMAND    LITERALLY   '4',
                WRITE$COMMAND   LITERALLY   '6',
                RECALIBRATE     LITERALLY   '3';

        DECLARE IOCW    LITERALLY '0',      /* IOPB OFFSETS */
                IOINS   LITERALLY '1',
                NSEC    LITERALLY '2',
                TADR    LITERALLY '3',
                SADR    LITERALLY '4',
                BUFLO   LITERALLY '5',
                BUFHI   LITERALLY '6';


    XEQIOPB: PROCEDURE(DRIVE, IOPB);
        /* THIS PROCEDURE ISSUES THE IOPB TO THE DISK CONTROLLER, IN THE */
        /* CASE OF THE 8271 IT ALSO TRANSFERS THE DATA BYTE BY BYTE */
        DECLARE DRIVE BYTE; /* DRIVE NUMBER: ASSUMES VALUE 0,1 */
        DECLARE IOPB ADDRESS;   /* POINTER TO THE PARAMATER BLOCK NAMED DCB */
        DECLARE DCB BASED IOPB (7) BYTE;

        DECLARE TEMPA(0) ADDRESS, (TEMP2, TEMP1) BYTE;

        /* RECALIBRATE COMMAND */
        DECLARE RECAL$PB(5) BYTE INITIAL(80H, RECALIBRATE, 0, 0, 0);

        DECLARE I BYTE;     /* INDEX VARIABLE IN FOR STATEMENTS */

        DISABLE;
        RECAL$PB(IOINS) = RECALIBRATE;
        RECAL$PB(SADR) = 0;
        IF DRIVE THEN   /* TRUE IF DRIVE 1 */
        DO;
            DCB(IOINS) = DCB(IOINS) OR 30H;
            DCB(SADR) = DCB(SADR) OR 20H;
            RECAL$PB(IOINS) = RECALIBRATE OR 30H;
            RECAL$PB(SADR) = 20H;
        END;

        DO I = 0 TO MAX$RETRIES;
            DO WHILE (INPUT(FDCC$STATUS$0) AND DISK$DONE) <> 0;
                TEMP1 = INPUT(RESULT$TYPE$0);
                TEMP1 = INPUT(RESULT$BYTE$0);
            END;
            /* IF DISK DRIVE NOT READY, GIVE FATAL ERROR */
            IF (INPUT(FDCC$STATUS$0) AND (DRIVE + 1)) = 0 THEN
                CALL ERR(ABORT, DRIVE$NOT$READY);
            /* START IO */
            OUTPUT(LOW$ADDRESS$0) = LOW(IOPB);
            OUTPUT(HIGH$ADDRESS$0) = HIGH(IOPB);

            DO WHILE (INPUT(FDCC$STATUS$0) AND DISK$DONE) = 0;
                ;
            END;
            TEMP1 = INPUT(RESULT$TYPE$0);
            IF (TEMP2 := INPUT(RESULT$BYTE$0)) = 0 THEN
            DO;
                ENABLE;
                RETURN;
            END;

            OUTPUT(LOW$ADDRESS$0) = LOW(.RECAL$PB);
            OUTPUT(HIGH$ADDRESS$0) = HIGH(.RECAL$PB);

            DO WHILE (INPUT(FDCC$STATUS$0) AND DISK$DONE) = 0;
                ;
            END;
        END;
        FDCC$ERROR$TYPE = TEMPA;
        CALL ERR(ABORT, DISK$IO$ERROR);
    END;

    XIO: PROCEDURE(OPCODE, DRIVE, TRKSEC, BUFFER);
        DECLARE (OPCODE, DRIVE) BYTE, (TRKSEC, BUFFER) ADDRESS;
        DECLARE DCB(10) BYTE INITIAL(80H);

        DCB(IOINS) = OPCODE;
        DCB(NSEC) = 1;
        DCB(TADR) = HIGH(TRKSEC);
        DCB(SADR) = LOW(TRKSEC);
        DCB(BUFLO) = LOW(BUFFER);
        DCB(BUFHI) = HIGH(BUFFER);
        CALL XEQIOPB(DRIVE, .DCB);
    END;

    RDSEC: PROCEDURE(TRKSEC, BUFFER);
         DECLARE (TRKSEC, BUFFER) ADDRESS;
         CALL XIO(READ$COMMAND, A$DEVICE, TRKSEC, BUFFER);
    END;

    WRSEC: PROCEDURE(TRKSEC, BUFFER);
        DECLARE (TRKSEC, BUFFER) ADDRESS;
        CALL XIO(WRITE$COMMAND, A$DEVICE, TRKSEC, BUFFER);
    END;

    /*

        ALDADR LOADS THE ABSOLUTE ISIS FILE INTO MEMORY
        HDRBLK - LOCATION OF ISIS FILE

        RETURNS - ADDRESS WHERE FILE IS LOADED
        THE FORMAT OF THE FILE IS BASICALLY THE CONTENT RECORDS
        FROM AN NORMAL ISIS EXECUTABLE WITH THE RECORD TYPE, SEGMENT ID AND CRC REMOVED
    */

    ALDADR: PROCEDURE(HDRBLK) ADDRESS;
        /* LOAD INTO MEMORY THE ABS LOAD FILE AT 'HDRBLK' */
        DECLARE HDRBLK ADDRESS;
        DECLARE BUF(128) BYTE, BUFPTR BYTE;
        DECLARE POINTERS(64) ADDRESS, PTRPTR BYTE;
        DECLARE LOADADR ADDRESS, TARGET BASED LOADADR BYTE;
        DECLARE LENGTH ADDRESS;

        DECLARE FLINK   LITERALLY   '1';    /* INDEXES INTO THE POINTERS ARRAY */

        L1B: PROCEDURE; /* LOAD 1 BYTE FROM BUFFER INTO MEMORY */
            TARGET = BUF(BUFPTR);   
            BUFPTR = BUFPTR + 1;
            LENGTH = LENGTH - 1;
            LOADADR = LOADADR + 1;
        END;

        G128B: PROCEDURE(BUFADR); /* GET 128 BYTES INTO BUFFER AT BUFADR */
            DECLARE BUFADR ADDRESS;

            IF (PTRPTR := PTRPTR + 1) = 64 THEN
            DO;
                IF POINTERS(FLINK) = 0 THEN
                    GOTO MDSMON;
                CALL XIO(READ$COMMAND, 0, POINTERS(FLINK), .POINTERS);
                PTRPTR = 2;
            END;
            IF POINTERS(PTRPTR) = 0 THEN
                GOTO MDSMON;
            CALL XIO(READ$COMMAND, 0, POINTERS(PTRPTR), BUFADR);
        END;

        G1B: PROCEDURE BYTE;    /* GET 1 BYTE */
            IF (BUFPTR AND 7FH) = 0 THEN
            DO;
                CALL G128B(.BUF);
                BUFPTR = 0;
            END;    
            BUFPTR = BUFPTR + 1;
            RETURN BUF(BUFPTR - 1);
        END;

        G2B: PROCEDURE ADDRESS; /* GET 2 BYTES */
            RETURN G1B + (256 * G1B);
        END;




        POINTERS(FLINK) = HDRBLK;   /* INITIALISZE G128B */
        PTRPTR = 63;
        BUFPTR = 0;

    START$LOADING$NEXT$RECORD:
        DO WHILE TRUE;
            LENGTH = G2B;
            LOADADR = G2B;
            IF LENGTH = 0 THEN
                RETURN LOADADR;
            DO WHILE BUFPTR <> 128;
                IF LENGTH > 0 THEN
                    CALL L1B;
                ELSE
                    GOTO START$LOADING$NEXT$RECORD;
            END;
            DO WHILE LENGTH >= 128;
                CALL G128B(LOADADR);
                LOADADR = LOADADR + 128;
                LENGTH = LENGTH - 128;
            END;
            
            BUFPTR = 0;
            IF LENGTH <> 0 THEN DO;
                CALL G128B(.BUF);
                DO WHILE LENGTH > 0;
                    CALL L1B;
                END;
            END;
        END;
        /* CANNOT REACH HERE !! */
    END; 


    T0BOOT:
    TEMP = INPUT(RESULT$TYPE$0);
    TEMP = INPUT(RESULT$BYTE$0);
    ENABLE;
    DO WHILE (INPUT(RTC) AND BOOT) <> 0;
        ;
    END;
    GLOBAL$SEVERITY = 0;
    DEBUG$TOGGLE = TRUE;
    START$ADDR = ALDADR(ISIS$HDR$BLK);
    IF START$ADDR <> 0 THEN
        GOTO START$ADDR;
    CALL CONSOL(.MEMORY, .MEMORY, .USERSTATUS);
    CALL NUMOUT(VERSION$LEVEL, 16, 0, .SIGN$V, 2);
    CALL NUMOUT(EDIT$LEVEL, 16, 0, .SIGN$E, 2);
    CALL WRITE(0, .ISIS$SIGNON, 16, .USERSTATUS);
    CALL EXIT;


END;
EOF;
isis.t0_1.2.patch
TARGET=IMAGE SOURCE=HEX START=3000 LOAD=3000
; UNIITIALISED - RANDOM DATA
363C 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
364F 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
3662 39

APPEND
 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
 00 39 00 39 00

load.asm
        name load
        aseg
        org 3200h

; isis calls
ISIS    equ     40h
READ    equ     3
LOAD    equ     6
ERROR   equ     12
EXIT    equ     9

CR      equ     0dh

start:  lxi     sp,start
        mvi     c,READ
        lxi     d,rdprm
        call    ISIS    ; read the cmd line
        lda     status
        ora     a
        jnz     failed
        lxi     h,rdbuf

scan:   inx     h       ; skip filename
        mov     a,m
        cpi     ' '
        jz      scan1
        cpi     ','
        jz      scan1
        cpi     CR
        jnz     scan
        mvi     m, ' '
        lxi     h,0
        shld    offset
        jmp     nosw
        
scan1:  lxi     d,0
        xchg

scan2:  shld    offset
        xchg

scan3:  inx     h
        mov     a,m
        cpi     CR
        jz      nosw
        cpi     ' '
        jz      scan5
        cpi     ','
        jz      scan5
        cpi     'H'     ; ignore H
        jz      scan3
        cpi     '0'     ; bad if not hex digit
        jc      badcmd
        cpi     '9' + 1
        jc      scan4
        cpi     'A'
        jc      badcmd
        cpi     'F' + 1
        jnc     badcmd
        sui     7       ; adjust for A-F

scan4:  sui     '0'     ; convert to 0-15 
        xchg
; the code below is needlessly complex
; shorter code would be
;       dad h
;       dad h
;       dad h
;       dad h
;       ora l
;       mov l,a
        push    psw
        mov     a,h
        ani     0Fh
        rlc
        rlc
        rlc
        rlc
        mov     h,a
        mov     a,l
        ani     0F0h
        rlc
        rlc
        rlc
        rlc
        ora     h
        mov     h,a
        mov     a,l
        ani     0Fh
        rlc
        rlc
        rlc
        rlc
        mov     l,a
        pop     psw
        ora     l
        mov     l,a
        jmp     scan2

scan5:  inx     h
        mov     a,m
        cpi     'M'
        jnz     nosw
        lxi     h,2

setsw:  shld    switch
        mvi     c,LOAD
        lxi     d,lodprm
        call    ISIS
        lda     status
        ora     a
        jnz     failed

done:   mvi     c,EXIT
        lxi     d,extprm
        call    ISIS

failed: lhld    status
        shld    errprm  ; save error code
        mvi     c,ERROR
        lxi     d,errprm
        call    ISIS
        jmp     done

nosw:   lxi     h,0
        jmp     setsw

badcmd:
        lxi     h,101h
        shld    status
        jmp     failed

; the isis parameter blocks
rdprm:
        dw      1       ; read console
        dw      rdbuf
        dw      32
        dw      actual
        dw      status   

lodprm: dw      rdbuf   ; file name
offset: ds      2
switch: ds      2
        dw      entry
        dw      status

errprm: ds      2       ; error code
        dw      status

extprm: dw      status

actual: ds      2
status: ds      2
entry:  ds      2
rdbuf:  
        end     start
        
        
rename.plm
3200H:
DO;
    DECLARE TRUE    LITERALLY '0FFH',
            FALSE   LITERALLY '0',
            CR      LITERALLY '0DH',
            LF      LITERALLY '0AH';

    DECLARE VER DATA(1, 8);
    DECLARE COPYRIGNT DATA('(C) 1975,1976 INTEL CORP');

    ISIS: PROCEDURE(CMD, PARAM$P);
        DECLARE CMD BYTE, PARAM$P ADDRESS;
        GOTO 40H;
    END ISIS;

    READ: PROCEDURE(CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P) ADDRESS;

        CALL ISIS(3, .CONN);
    END;

    WRITE: PROCEDURE(CONN, BUFF$P, COUNT, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, STATUS$P) ADDRESS;

        CALL ISIS(4, .CONN);
    END;

	RENAME: PROCEDURE(OLD$P, NEW$P, STATUS$P);
    	DECLARE (OLD$P, NEW$P, STATUS$P) ADDRESS;
    	
    	CALL ISIS(7, .OLD$P);
	END;

    ERROR: PROCEDURE(ERROR$NUM);
        DECLARE (ERROR$NUM, STATUS) ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(12, .ERROR$NUM);
    END;

    EXIT: PROCEDURE;
        DECLARE STATUS ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(9, .STATUS);
    END;

    DELETE: PROCEDURE (PATH$P, STATUS$P);
        DECLARE (PATH$P, STATUS$P) ADDRESS;

        CALL ISIS(2, .PATH$P);
    END DELETE;

    DEBLANK: PROCEDURE(PTR) ADDRESS;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE (C = ' ');
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;

    DELIMIT: PROCEDURE(PTR) ADDRESS;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE (C = ':' OR C = '.' OR
                 ('0' <= C AND C <= '9') OR
                 ('A' <= C AND C <= 'Z'));
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;

    SEQ: PROCEDURE(S1, S2, CNT) BYTE;
        DECLARE (S1,S2) ADDRESS, CNT BYTE;
        DECLARE S1A BASED S1(1) BYTE;
        DECLARE S2A BASED S2(1) BYTE;
        DECLARE I BYTE;
        CNT = CNT - 1;
        DO I = 0 TO CNT;
            IF S1A(I) <> S2A(I) THEN
                RETURN 0;
        END;
        RETURN 0FFH;
    END;

    NUMOUT: PROCEDURE(VALUE, BASE, LC, BUFADR, WIDTH);
        DECLARE (VALUE, BUFADR) ADDRESS, (BASE, LC, WIDTH) BYTE; 
        DECLARE DIGITS DATA('0123456789ABCDEF');
        DECLARE I BYTE;
        DECLARE BUF BASED BUFADR (1) BYTE;

        DO I = 1 TO WIDTH;
            BUF(WIDTH - I) = DIGITS(VALUE MOD BASE);
            VALUE = VALUE / BASE;   
        END;

        I = 0;
        DO WHILE BUF(I) = '0' AND I < WIDTH - 1;
            BUF(I) = LC;
            I = I + 1;
        END;
    END;

    REPORTERROR: PROCEDURE(ERRNUM);
        DECLARE ERRNUM ADDRESS;
        DECLARE NUMBERBUFFER(4) BYTE, I ADDRESS, STATUS ADDRESS;
     

        DECLARE ERRMSG DATA(0, 0,
            2, 'ILLEGAL AFTN ARGUMENT', 0,
            4, 'INCORRECTLY SPECIFIED FILE', 0,
            5, 'UNRECOGNIZED DEVICE NAME', 0,
            6, 'ATTEMPT TO WRITE TO INPUT DEVICE', 0,
            8, 'ATTEMPT TO READ FROM OUTPUT DEVICE', 0,
            9, 'DIRECTORY FULL', 0,
            0AH, 'NOT ON SAME DISK', 0,
            0BH, 'FILE ALREADY EXISTS', 0,
            0CH, 'FILE IS ALREADY OPEN', 0,
            0DH, 'NO SUCH FILE', 0,
            0EH, 'WRITE PROTECTED', 0,
            0FH, 'LOAD TOO LOW', 0,
            10H, 'BAD LOAD FORMAT', 0,
            11H, 'NOT A DISK FILE', 0,
            12H, 'ILLEGAL ISIS COMMAND', 0,
            13H, 'ATTEMPTED SEEK ON NON-DISK FILE', 0,
            14H, 'ATTEMPTED BACK SEEK TO FAR', 0,
            16H, 'ILLEGAL ACCESS MODE TO OPEN', 0,
            17H, 'MISSING FILENAME', 0,
            19H, 'ILLEGAL ECHO FILE', 0,
            1AH, 'ILLEGAL ATTRIBUTE IDENTIFIER', 0,
            1BH, 'ILLEGAL SEEK COMMAND', 0,
            1CH, 'MISSING EXTENSION', 0,
            1FH, 'CAN', 27H, 'T SEEK ON WRITE ONLY FILE', 0,
            20H, 'CAN', 27H, 'T DELETE OPEN FILE', 0,
            23H, 'SEEK PAST EOF', 0,
            0C9H, 'UNRECOGNIZED SWITCH', 0,
            0CAH, 'UNRECOGNIZED DELIMITER', 0,
            0CBH, 'INVALID SYNTAX', 0,
            0CCH, 'PREMATURE EOF', 0,
            0CEH, 'ILLEGAL DISKETTE LABEL', 0,
            0D0H, 'CHECKSUM ERROR', 0
        );



        IF ERRNUM <> 0 THEN
        DO;
            I = 0;
            DO WHILE I < LENGTH(ERRMSG);
                IF ERRNUM = ERRMSG(I) AND ERRMSG(I + 1) <> 0 THEN
                DO;
                    I = I + 1;
                    CALL WRITE(0, .(' '), 1, .STATUS);
                    DO WHILE ERRMSG(I) <> 0;
                        CALL WRITE(0, .ERRMSG(I), 1, .STATUS);
                        I = I + 1;
                    END;
                    CALL WRITE(0, .(0DH, 0AH), 2, .STATUS);
                    return;
                END;
                ELSE
                DO;
                    DO WHILE ERRMSG(I) <> 0;
                        I = I + 1;
                    END;
                    I = I + 1;
                END;
            end;
            CALL ERROR(ERRNUM);
        END;
    END;

    FILE$ERROR: PROCEDURE(STATUS, PTR, CALLEXIT);
        DECLARE (STATUS, PTR) ADDRESS, CALLEXIT BYTE;
        DECLARE ERR$STATUS ADDRESS;

        IF STATUS <> 0 THEN
        DO;
            PTR = DEBLANK(PTR);
            CALL WRITE(0, .(' '), 1, .ERR$STATUS);
            CALL WRITE(0, PTR, DELIMIT(PTR) - PTR, .ERR$STATUS);
            CALL WRITE(0, .(','), 1, .ERR$STATUS);
            CALL REPORTERROR(STATUS);
            IF CALLEXIT THEN
                CALL EXIT;
        END;
    END;


    DECLARE (ACTUAL, STATUS) ADDRESS;
    DECLARE BUFFER(128) BYTE;
    DECLARE BUFPTR ADDRESS;

    DECLARE BADCMD DATA('CANNOT READ COMMAND LINE.', CR, LF);
MAIN:
    CALL READ(1, .BUFFER, 128, .ACTUAL, .STATUS);
    IF STATUS <> 0 THEN DO;
        CALL REPORTERROR(STATUS);
        CALL WRITE(0, .BADCMD, 27, .STATUS);
        CALL EXIT;
    END;

    BUFPTR = DEBLANK(DELIMIT(DEBLANK(.BUFFER)));
    IF SEQ(.('TO '), BUFPTR, 3) THEN DO;
        BUFPTR = BUFPTR + 3;
        CALL RENAME(.BUFFER, .BUFFER, .STATUS);
        IF STATUS <> 0BH THEN
            CALL FILEERROR(STATUS, .BUFFER, TRUE);
        CALL RENAME(.BUFFER, BUFPTR, .STATUS);
        IF STATUS = 0BH THEN DO;
            CALL WRITE(0, .(' '), 1, .STATUS);
            CALL WRITE(0, BUFPTR, DELIMIT(BUFPTR) - BUFPTR, .STATUS);
            CALL WRITE(0, .(', ALREADY EXISTS, DELETE', 3FH, ' '), 26, .STATUS);
            CALL READ(1, .MEMORY, 128, .ACTUAL, .STATUS);
            IF MEMORY(0) = 'Y' OR MEMORY(0) = 'Y' + 20H THEN DO;
                CALL DELETE(BUFPTR, .STATUS);
                CALL FILEERROR(STATUS, BUFPTR, TRUE);
                CALL RENAME(.BUFFER, BUFPTR, .STATUS);
            END;
            ELSE
                CALL EXIT;
        END;
        IF STATUS <> 0 THEN
            CALL FILEERROR(STATUS, BUFPTR, TRUE);
    END;
    ELSE
            CALL REPORTERROR(0CBH);
    CALL EXIT;
END;
EOF
type.asm
    name type
    aseg
    org 3200h

CONSOL  equ     8
EXIT    equ     9
ISIS    equ     40h


start:  lxi     sp,stk
        mvi     c,CONSOL
        lxi     d,conprm
        call    ISIS
        mvi     c,EXIT
        lxi     d,extprm
        call    ISIS

; ISIS parameters
conprm: dw      ti
        dw      to
        dw      status

extprm: dw      status

ti:     db      ':TI: '
to:     db      ':TO: '
status: ds      2
        ds      4
stk:
        end     start
