asm80.plm
3400H: DO;
    DECLARE LIT LITERALLY 'LITERALLY',
            CR  LIT '0DH',
            LF  LIT '0AH',
            FF  LIT '0CH',
            TAB LIT '9',
            EOFCH LIT '1AH',
            TRUE    LIT '0FFH',
            FALSE   LIT '0';

    DECLARE VER DATA(2, 7),
            COPYRIGHT DATA('(C) 1975, 1976 INTEL CORP');
    DECLARE LSTEXT DATA('.LST ');
    DECLARE HEXEXT DATA('.HEX ');
    DECLARE ASMCOMPLETE DATA(CR, LF, LF, 'ASSEMBLY COMPLETE, NO PROGRAM ERRORS', CR, LF),
            BLOCK DATA('0 BLOCK');
    DECLARE PAGEHEADER DATA(0, LF, LF, LF, LF, LF, LF,
                            'ISIS 8080 MACRO ASSEMBLER, V1.1',
                            TAB, TAB, TAB, 'PAGE ', CR, LF, LF, LF, TAB, TAB, 0);
    DECLARE ACCUM1(0) ADDRESS, ACC1B(0) BYTE, (ACC1LOW, ACC1HIGH) BYTE,
            ACCUM2(0) ADDRESS, (ACC2LOW, ACC2HIGH) BYTE;
    DECLARE BUFFER(80) BYTE,
            FILENAME(15) BYTE,
            HEXOPEN BYTE,
            ERRCNT BYTE,
            NOHEX BYTE,
            NOLST BYTE,
            B57D5 BYTE,
            DEFOUT BYTE,
            INCNT BYTE,
            STATUS ADDRESS,
            ENDBUF$PTR ADDRESS,
            (IN$TMP, HEX$FILE) ADDRESS,
            (AFTIN, AFTHEX, AFTLST) ADDRESS,
            LST$FILE ADDRESS,
            (BUFFER$PTR, MEMORY$P, ITABLE$P) ADDRESS;
            /* B57F1 IS REFERENCED BUT NOT SET - TREAT AS ZERO */
    DECLARE (NUMTMP, WORDOPERAND, USE16, HAVETITLE, CUR$OP$FLAGS, IFDEPTH) BYTE,
            (IFSTATE, SKIPIF)(8) BYTE,
            (MACRODEPTH, EXPANDING, B5807) BYTE,
            (W5808, W5812) (5) ADDRESS,
            W581C(5) ADDRESS,
            (SYMTAB$END, SYMTAB)(5) ADDRESS,
            W583A ADDRESS,
            (B583C, B583D) BYTE,
            (W583E$P, W5840, W5842) ADDRESS,
            W583E BASED W583E$P ADDRESS,
            (ENDRAM, SYMHIGHMARK) ADDRESS,
            (PASS, MAXRECLEN) BYTE,
            (RECLEN, CHECKSUM, ENDSEEN) BYTE,
            RECBUF(17) BYTE,
            RECADDR ADDRESS;
    DECLARE (REF$P, MID$P, HIGH$P, LOW$P) ADDRESS,
            REFCH BASED REF$P BYTE,
            MIDCH BASED MID$P BYTE,
            MIDSYM BASED MID$P (8) BYTE,
            MIDWD BASED MID$P ADDRESS,
            LOWWD BASED LOW$P ADDRESS,
            HIGHWD BASED HIGH$P ADDRESS;
    DECLARE (II, JJ) BYTE, OPSP BYTE, OPSTACK(7) BYTE;
    DECLARE (PC, ADDR) ADDRESS, PAD3816 BYTE;
    DECLARE (NEWACTION, ACTION, NEXT$TOK$TYPE) BYTE,
            (TOKID, LASTCHREAD, RADIX, SHOWADDR) BYTE,
            (LINECOL, LINEEND, PAGEWIDTH, ROWCNT) BYTE,
            PAGENO ADDRESS,
            LINEBUF(120) BYTE, TITLE(66) BYTE,  TITLELEN BYTE;
    DECLARE (GETNEW, ERRORCH, TOKENCNT) BYTE,
            (TOKEN$P, SYM$P)(8) ADDRESS,
            TOKEN BASED TOKEN$P (8) BYTE,
            SYM BASED SYM$P (8) BYTE,
            SYMWD BASED SYM$P (4) ADDRESS,
            (TOKEN$TYPE, TOKEN$LEN)(8) BYTE,
            END$WORKBUF$P ADDRESS;


    ISIS: PROCEDURE(CMD, PARAM$P);
        DECLARE CMD BYTE, PARAM$P ADDRESS;
        GOTO 40H;
    END ISIS;

    OPEN: PROCEDURE(CONN$P, PATH$P, ACCESS, ECHO, STATUS$P);
        DECLARE (CONN$P, PATH$P, ACCESS, ECHO, STATUS$P) ADDRESS;

        CALL ISIS(0, .CONN$P);
    END;

    CLOSE: PROCEDURE(CONN, STATUS$P);
        DECLARE (CONN, STATUS$P) ADDRESS;

        CALL ISIS(1, .CONN);
    END;

    READ: PROCEDURE(CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P) ADDRESS;

        CALL ISIS(3, .CONN);
    END;

    WRITE: PROCEDURE(CONN, BUFF$P, COUNT, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, STATUS$P) ADDRESS;

        CALL ISIS(4, .CONN);
    END;

    SEEK: PROCEDURE(CONN, MODE, BLOCK$P, BYTE$P, STATUS$P);
        DECLARE (CONN, MODE, BLOCK$P, BYTE$P, STATUS$P) ADDRESS;

        CALL ISIS(5, .CONN);
    END;

    EXIT: PROCEDURE;
        DECLARE STATUS ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(9, .STATUS);
    END;

    ERROR: PROCEDURE(ERROR$NUM);
        DECLARE (ERROR$NUM, STATUS) ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(12, .ERROR$NUM);
    END;

    CHECKSTATUS: PROCEDURE;
        IF STATUS = 0 THEN
            RETURN;
        CALL ERROR(STATUS);
        CALL EXIT;
    END;

    BUFSKIPSPC: PROCEDURE;
        DECLARE CH BASED BUFFER$PTR BYTE;

        DO WHILE CH = ' ' AND BUFFER$PTR <> ENDBUF$PTR;
            BUFFER$PTR = BUFFER$PTR + 1;
        END;
    END;

    OPENFILE: PROCEDURE(ACCESS) ADDRESS;
        DECLARE ACCESS ADDRESS;
        DECLARE AFTN ADDRESS;
        DECLARE CH BASED BUFFER$PTR BYTE;

        CALL BUFSKIPSPC;
        CALL OPEN(.AFTN, BUFFER$PTR, ACCESS, 0, .STATUS);    
        CALL CHECKSTATUS;
        DO WHILE CH <> ' ' AND BUFFER$PTR <> ENDBUF$PTR;
            BUFFER$PTR = BUFFER$PTR + 1;
        END;
        CALL BUFSKIPSPC;
        RETURN AFTN;
    END;

    /* CHECK FOR TO (N = 1) OR LIST (N = 2) */
    CHK$TO$LIST: PROCEDURE(N);
        DECLARE N BYTE,  OFFSET BYTE;
        DECLARE KEYWORDS DATA ('TOLIST');
        DECLARE BUF BASED BUFFER$PTR (1) BYTE;

        OFFSET = 0;
        IF N = 4 THEN
            OFFSET = 2;
        DO II = 0 TO N - 1;
            IF BUF(II) <> KEYWORDS(II + OFFSET) THEN DO;
                STATUS = 0CBH;
                CALL CHECKSTATUS;
            END;
        END;
        BUFFER$PTR = BUFFER$PTR + N;
    END;

    OPEN$DEFAULT$OUT: PROCEDURE;
        DECLARE (I, J) BYTE;
        DECLARE CH BASED BUFFER$PTR BYTE;
        BUFFER$PTR = .BUFFER;
        CALL BUFSKIPSPC;
        I = 0;
        DO WHILE CH <> '.' AND CH <> ' ' AND CH <> CR;
            FILENAME(I) = CH;
            I = I + 1;
            BUFFER$PTR = BUFFER$PTR + 1;
        END;
        DO J = 0 TO 4;
            FILENAME(I + J) = HEXEXT(J);
        END;
        BUFFER$PTR = .FILENAME;
        AFTHEX = OPENFILE(2);

        DO J = 0 TO 4;
            FILENAME(I + J) = LSTEXT(J);
        END;
        BUFFER$PTR = .FILENAME;
        AFTLST = OPENFILE(2);
    END;

    CHKDOLST: PROCEDURE BYTE;
        IF PASS = 3 OR (PASS = 2 AND DEFOUT AND NOLST = 0) THEN
            RETURN 1;
        ELSE
            RETURN 0;
    END;

    READCH: PROCEDURE BYTE;
        DECLARE INBUF(128) BYTE;
        DECLARE ACTUAL ADDRESS;
        IF (INCNT := INCNT + 1) > 127 THEN DO;
            CALL READ(AFTIN, .INBUF, 128, .ACTUAL, .STATUS);
            IF ACTUAL = 0 THEN
                STATUS = 0CFH;
            CALL CHECKSTATUS;
            INCNT = 0;
        END;
        RETURN INBUF(INCNT) AND 7FH;
    END;

    WRITECH$CO: PROCEDURE(CH);
        DECLARE CH BYTE;
        CALL WRITE(0, .CH, 1, .STATUS);
        CALL CHECKSTATUS;
    END;

    WRITECH$HEX: PROCEDURE(CH);
        DECLARE CH BYTE;
        CALL WRITE(AFTHEX, .CH, 1, .STATUS);
        CALL CHECKSTATUS;
    END;

    WRITECH$LST: PROCEDURE(CH);
        DECLARE CH BYTE;
        CALL WRITE(AFTLST, .CH, 1, .STATUS);
        CALL CHECKSTATUS;
    END;

    MEMCHK: PROCEDURE ADDRESS;
        GOTO 0F81BH;
    END;


    HEX1: PROCEDURE(CH) BYTE;
        DECLARE CH BYTE;
        IF (CH := (CH AND 0FH) + '0') > '9' THEN
            CH = CH + 7;
        RETURN CH;
    END;

    WRITEHEX2$CO: PROCEDURE(N);
        DECLARE N BYTE;
        CALL WRITECH$CO(HEX1(ROR(N, 4)));
        CALL WRITECH$CO(HEX1(N));
    END;


    BUFCH$LST: PROCEDURE(CH);
        DECLARE CH BYTE;
        IF CH = LF THEN DO;
            CH = 0;
            DO WHILE CH < LINEEND;
                CH = CH + 1;
                CALL WRITECH$LST(LINEBUF(CH));
            END;
            LINEEND = 0;
            CALL WRITECH$LST(CR);
            CALL WRITECH$LST(LF);
        END;
        ELSE DO;
            IF CH >= ' ' THEN
                LINEBUF(LINECOL) = CH;
            IF LINECOL > LINEEND THEN
                LINEEND = LINECOL;
        END;
    END;

    ADDCH$LST: PROCEDURE(CH);
        DECLARE CH BYTE;
        DECLARE (SPACES, I) BYTE;

        IF CH = FF THEN DO;
            DO WHILE ROWCNT <> 0;
                IF (ROWCNT := ROWCNT + 1) = 66 THEN
                    ROWCNT = 0;
                CALL BUFCH$LST(LF);
            END;
            RETURN;
        END;   
        IF CH = CR THEN
            LINECOL = 0;
        IF CH = LF THEN
            ROWCNT = ROWCNT + 1;
        SPACES = CH = TAB AND (7 - (LINECOL AND 7));
        IF CH = TAB THEN
            CH = ' ';
        DO I = 0 TO SPACES;
            IF LINECOL < PAGEWIDTH THEN DO;
                LINECOL = LINECOL + (CH >= ' ' AND 1);
                CALL BUFCH$LST(CH);
            END;
        END;
    END;

    PUTCH$LST: PROCEDURE(CH);
        DECLARE CH BYTE;
        DECLARE (I, HDRCH, J) BYTE;
        DECLARE DIV ADDRESS, PAD BYTE;

        IF CH = FF OR ROWCNT >= 60 THEN DO;
            CALL ADDCH$LST(CR);
            CALL ADDCH$LST(FF);
            I = 0;
            DO WHILE (HDRCH := PAGEHEADER(I := I + 1)) <> 0;
                IF HDRCH = CR THEN DO;
                    DIV = 10000;
                    DO WHILE DIV > 0;
                        IF PAGENO >= DIV THEN
                            CALL ADDCH$LST(LOW(PAGENO / DIV MOD 10) + '0');
                        DIV = DIV / 10;
                    END;
                    CALL ADDCH$LST(CR);
                    CALL ADDCH$LST(LF);

                    DO J = 1 TO TITLELEN;
                        CALL ADDCH$LST(TITLE(J));
                    END;
                END;
                CALL ADDCH$LST(HDRCH);
            END;
                PAGENO = PAGENO + 1;
        END;
        IF CH <> FF THEN
            CALL ADDCH$LST(CH);
    END;


    DOPASS: PROCEDURE;
        RECORDERROR: PROCEDURE(CH);
            DECLARE CH BYTE;
            IF NOT ROR(SKIPIF(0),1) AND ERRORCH = ' ' THEN DO;
                ERRORCH = CH;
                IF PASS = 2 OR PASS = 3 THEN
                    ERRCNT = ERRCNT + 1;
            END;
        END;

        /* TREAT PTR AS POINTER TO AN ARRAY OF NIBBLES */
        /* INDEX INTO THIS ARRAY TO RETRIEVE THE NIBBLE */
        GETNIBBLEAT: PROCEDURE(PTR, N) BYTE;
            DECLARE PTR ADDRESS, N BYTE;
            DECLARE BA BASED PTR (1) BYTE;
            DECLARE TMP BYTE;
            TMP = BA(SHR(N, 1));
            IF N THEN
                TMP = ROR(TMP, 4);
            RETURN TMP AND 0FH;
        END;

        WRITEHEX2$HEX: PROCEDURE(N);
            DECLARE N BYTE;
            CALL WRITECH$HEX(HEX1(ROR(N, 4)));
            CALL WRITECH$HEX(HEX1(N));
        END;

        PUTHEX2$LST: PROCEDURE(N);
            DECLARE N BYTE;
            CALL PUTCH$LST(HEX1(ROR(N, 4)));
            CALL PUTCH$LST(HEX1(N));
        END;

        WRITEHEXREC$HEX: PROCEDURE(RECTYPE);
            DECLARE RECTYPE BYTE, I BYTE;

            CALL WRITECH$HEX(':');
            CALL WRITEHEX2$HEX(RECLEN);
            CALL WRITEHEX2$HEX(HIGH(RECADDR));
            CALL WRITEHEX2$HEX(LOW(RECADDR));
            CALL WRITEHEX2$HEX(RECTYPE);
            DO I = 1 TO RECLEN;
                CALL WRITEHEX2$HEX(RECBUF(I));
            END;
            CHECKSUM = CHECKSUM - HIGH(RECADDR) - LOW(RECADDR) - RECTYPE - RECLEN;
            CALL WRITEHEX2$HEX(CHECKSUM);
            CALL WRITECH$HEX(CR);
            CALL WRITECH$HEX(LF);
            CHECKSUM = 0;
            RECLEN = 0;
            MAXRECLEN = 16;
        END; 
                

        MKCODE: PROCEDURE(CODE);
            DECLARE CODE BYTE;
            
            IF (CODE AND 3) <> 0 THEN DO;
                IF ACC2HIGH <> 0 OR ACC2LOW > 7 OR (CODE AND ACC2LOW)
                   OR ((CODE AND 3) = 3 AND ACC2LOW > 2) THEN DO;
                    ACC2LOW = 0;
                    CALL RECORDERROR('R');
                END;

                IF ROR(CODE, 2) THEN
                    ACC2LOW = ROL(ACC2LOW, 3);

                ACC1LOW = ACC1LOW OR ACC2LOW;
            END;
            IF SHR(CODE, 3) THEN
                IF ACC2HIGH + 1 > 1 THEN
                    CALL RECORDERROR('V');

            IF (ACTION := SHR(CODE, 4) + 22H) = 22H THEN DO;
                IF ACC1HIGH > 0 THEN
                    CALL RECORDERROR('V');
                NEXT$TOK$TYPE = 6;
            END;
        END;

        ADJUSTMACROSTK: PROCEDURE;
            DO II = 0 TO 4;
                HIGHWD = LOWWD;
                HIGH$P = HIGH$P + ROL(5, 1);
                LOW$P = LOW$P + ROL(5, 1);
            END;
        END;

        /* NEST / UNNEST ROUTINES */
        /* LOCATION 0 HOLDS THE CURRENT ACCUM1(0) */
        /* PUSH COPIES CURRENT TO END OF LIST */
        /* POP COPIES END OF LIST TO CURRENT */
        UNNEST: PROCEDURE(SW);
            DECLARE SW BYTE;

            IF SW <> IFSTATE(0) THEN DO;
                CALL RECORDERROR((SW = 0FFH AND 5) + 'N');
                IF IFDEPTH > 1 THEN
                    IFDEPTH = 2;
                IF MACRODEPTH > 1 THEN
                    MACRODEPTH = 2;
            END;
            IF (MACRODEPTH > 1 AND IFSTATE(0) > 0) OR SW = 2 THEN DO;
                ENDRAM = W581C(0);
                /* POP MACRO */
                LOW$P = MACRODEPTH + MACRODEPTH + (HIGH$p := .W5808);
                CALL ADJUSTMACROSTK;
                IF PASS = 1 AND IFSTATE(0) = 3 THEN
                    SYMHIGHMARK = W583A; 
                EXPANDING = (MACRODEPTH := MACRODEPTH - 1) > 1;
                B583C = 0;
            END;
            IF IFDEPTH > 1 THEN DO;
                SKIPIF(0) = SKIPIF(IFDEPTH);
                IFSTATE(0) = IFSTATE(IFDEPTH);
                IFDEPTH = IFDEPTH - 1;
            END;
        END;


        NEST: PROCEDURE(SW);
            DECLARE SW BYTE;
            DECLARE ENTRYLEN BASED W583A ADDRESS;
            IF ENDSEEN THEN
                RETURN;
            IF (IFDEPTH := IFDEPTH + 1) >= 8 THEN
                CALL UNNEST(0FFH);
            ELSE DO;   
                IF SW <> 0 THEN DO;
                    IF (MACRODEPTH := MACRODEPTH + 1) >= 5 THEN
                        CALL UNNEST(255);
                    ELSE DO;
                        /* PUSH MACRO */
                        HIGH$P = MACRODEPTH + MACRODEPTH + (LOW$P := .W5808);
                        CALL ADJUSTMACROSTK;
                        IF (W581C(0) := ENDRAM) <= SYMHIGHMARK THEN
                            CALL RECORDERROR('T');
                        ELSE DO;
                            IF PASS = 1 THEN DO;
                                ENTRYLEN = 2;
                                SYMHIGHMARK = W583A + 2;
                            END;
                            IF SYMHIGHMARK < W583A THEN
                                CALL RECORDERROR('T');
                            ELSE DO;
                                SYMTAB = W583A + 2;
                                SYMTAB$END = W583A + ENTRYLEN;
                                IF SW <> 3 THEN
                                    W583A = SYMTAB$END;
                            END;
                        END;
                    END;
                END;
                SKIPIF(IFDEPTH) = SKIPIF(0);
                IFSTATE(IFDEPTH) = IFSTATE(0);
                IFSTATE(0) = SW;
            END;
        END;


        WRITESYM$HEX: PROCEDURE;
            DECLARE B5A4F BYTE;
            IF B57D5 THEN
                CALL PUTCH$LST(FF);
            B5A4F = 0;
            W583A = SYMTAB$END(0);
            ERRORCH = ' ';

            DO WHILE ERRORCH = ' ';
                CALL NEST(1);
                IF ERRORCH = ' ' THEN
                DO;
                    IF W583A >= SYMHIGHMARK THEN
                        ERRORCH = 'T';
                    IF NOT B57D5 THEN
                    DO;
                        B5A4F = B5A4F + 1;
                        CALL WRITE(AFTHEX, .BLOCK, 7, .STATUS);
                        CALL CHECKSTATUS;
                        CALL WRITEHEX2$HEX(B5A4F);
                        CALL WRITECH$HEX(' ');
                        CALL WRITECH$HEX('0');
                        CALL WRITECH$HEX(CR);
                        CALL WRITECH$HEX(LF);
                    END;
                    II, JJ = 0;
                    MID$P = SYMTAB(0);
                    DO WHILE MID$P < SYMTAB$END(0);
                        IF B57D5 THEN DO;    
                            IF (II := (II + 1) AND 3) = 1 THEN DO;
                                CALL PUTCH$LST(CR);
                                CALL PUTCH$LST(LF);
                            END;
                            DO JJ = 0 TO 4;
                                CALL PUTCH$LST(MIDSYM(JJ));
                            END;

                            CALL PUTCH$LST(' ');
                            CALL PUTHEX2$LST(MIDSYM(7));
                            CALL PUTHEX2$LST(MIDSYM(6));
                            IF MIDSYM(5) = 3 THEN
                                CALL PUTCH$LST('M');
                            CALL PUTCH$LST(TAB);
                        END;
                        ELSE DO;
                            CALL WRITECH$HEX('0');
                            CALL WRITECH$HEX(' ');
                            DO JJ = 0 TO 4;
                                CALL WRITECH$HEX(MIDSYM(JJ));
                            END;
                            CALL WRITECH$HEX(' ');
                            CALL WRITECH$HEX('0');
                            CALL WRITEHEX2$HEX(MIDSYM(7));
                            CALL WRITEHEX2$HEX(MIDSYM(6));
                            CALL WRITECH$HEX('H');
                            CALL WRITECH$HEX(CR);
                            CALL WRITECH$HEX(LF);
                        END;
                        MID$P = MID$P + 8;
                    END;
                    IF JJ > 0 AND B57D5 THEN DO;
                        CALL PUTCH$LST(CR);
                        CALL PUTCH$LST(LF);
                        CALL PUTCH$LST(LF);
                    END;
                    CALL UNNEST(1);
                END;
            END;
            IF B57D5 THEN
                CALL ADDCH$LST(FF);
            ELSE DO;
                CALL WRITECH$HEX(' ');
                CALL WRITECH$HEX('$');
                CALL WRITECH$HEX(CR);
                CALL WRITECH$HEX(LF);
            END;
        END;

        GETCH:  PROCEDURE BYTE;
            DECLARE CH BASED W5812 BYTE;
            IF GETNEW <> 0 THEN DO;
                IF EXPANDING THEN
                    DO WHILE 1;
                        W5812 = W5812 + 1;
                        IF (LASTCHREAD := CH) = EOFCH THEN
                            GOTO DONE;
                        IF LASTCHREAD <= 7FH THEN
                            GOTO APPEND; 
                        IF B5807 THEN DO;
                            B5807 = 0;
                            W5812 = W5808;
                            GOTO CONTINUE;  /* WORK AROUND OPTIMISATION */
                        END;
                        DO;
                            W5808 = W5812;
                            W5812 = W581C(0);
                            B5807 = 1;
                            DO WHILE (LASTCHREAD := LASTCHREAD - 1) >= 128;
                                W5812 = W5812 - (CH AND 7FH);        
                            END;
                        END;
                    CONTINUE:
                    END;
                ELSE 
                    DO WHILE (LASTCHREAD := READCH) = 0 OR LASTCHREAD = 07FH;
                    END;
        APPEND:
                IF CHKDOLST THEN
                    CALL PUTCH$LST(LASTCHREAD);
                IF PASS = 1 AND B583C THEN DO;
                    CH = LASTCHREAD;
                    B583C = (W5812 := W5812 + 1) < ENDRAM;
                END;
            END;
        DONE:
            GETNEW = 1;
            RETURN TOKID := LASTCHREAD;
        END; 

        /* CLASSIFY CHARACTER READ */
        /* 0 ILLEGAL */
        /* 1 WHITE SPACE TAB, LF, FF, SPACE */
        /* 2 SEMICOLON */
        /* 3 COLON */
        /* 4 CR */
        /* 5 ( ) * , -  / */
        /* 6 $ */
        /* 7 quote */
        /* 8 NUMERIC */
        /* 9 LETTER */

        CLASSIFY: PROCEDURE BYTE;
            DECLARE TABLE DATA(  0,   0,   0,   0, 10h,   1, 41h,   0,
                                 0,   0,   0,   0,   0,   0,   0,   0,
                                 1,   0,   6, 70h, 55h, 55h, 55h, 50h,
                               88h, 88h, 88h, 88h, 88h, 23h,   0,   0);
            IF GETCH > 7AH THEN       /* LOWER Z */
                RETURN 0;
            IF TOKID > 60H THEN         /* LOWER A - Z */
                RETURN 9;
            IF TOKID > 5AH THEN         /* > Z */
                RETURN 0;
            IF TOKID > 3EH THEN         /* @ - Z */
                RETURN 9;
            RETURN GETNIBBLEAT(.TABLE, TOKID);
        END; 

        MOVEUP: PROCEDURE(SADDR, EADDR) ADDRESS;
            DECLARE (SADDR, EADDR) ADDRESS;
            DECLARE SCH BASED EADDR BYTE;
            DECLARE DCH BASED ENDRAM BYTE;
            DO WHILE EADDR >= SADDR;
                IF SYMHIGHMARK >= ENDRAM THEN
                    CALL RECORDERROR('T');
                ELSE DO;
                    DCH = SCH;
                    ENDRAM = ENDRAM - 1;
                END;
                EADDR = EADDR - 1;
            END;
            RETURN ENDRAM;
        END;



        PUSH$TOKEN: PROCEDURE(NEW$TOKEN$TYPE);
            DECLARE NEW$TOKEN$TYPE BYTE;
            IF (TOKENCNT := TOKENCNT + 1) >= 8 THEN DO;
                TOKENCNT = 2;
                CALL RECORDERROR('S');
            END;
            /* PUSH PREVIOUS TOKEN */
            TOKEN$P(TOKENCNT) = TOKEN$P(0);
            SYM$P(TOKENCNT) = SYM$P(0);
            TOKEN$TYPE(TOKENCNT) = TOKEN$TYPE(0);
            TOKEN$LEN(TOKENCNT) = TOKEN$LEN(0);
            /* NEW TOKEN STARTS JUST AFTER PREVIOUS ONE */
            TOKEN$P(0) = TOKEN$P(0) + TOKEN$LEN(0);
            SYM$P(0) = 0;
            TOKEN$TYPE(0) = NEW$TOKEN$TYPE;
            TOKEN$LEN(0) = 0;
        END;

        ADDCH$TOKEN: PROCEDURE(CH);
            DECLARE CH BYTE;
            IF TOKEN$P + TOKEN$LEN < END$WORKBUF$P THEN DO;
                TOKEN(TOKEN$LEN) = CH;
                TOKEN$LEN = TOKEN$LEN + 1;
            END;
            ELSE
                CALL RECORDERROR('T');
        END;
                

        POP$TOKEN: PROCEDURE;
            TOKEN$P(0) = TOKEN$P(TOKENCNT);
            SYM$P(0) = SYM$P(TOKENCNT);
            TOKEN$TYPE(0) = TOKEN$TYPE(TOKENCNT);
            TOKEN$LEN(0) = TOKEN$LEN(TOKENCNT);
            TOKENCNT = TOKENCNT - 1;
        END;


        GETID: PROCEDURE(NEW$TOKEN$TYPE);
            DECLARE NEW$TOKEN$TYPE BYTE;

            CALL PUSH$TOKEN(NEW$TOKEN$TYPE);
            GETNEW = GETNEW - 1;

            DO WHILE CLASSIFY > 7;
                IF TOKID > 40H THEN
                    TOKID = TOKID AND 0DFH;
                CALL ADDCH$TOKEN(TOKID);
            END;
            GETNEW = GETNEW - 1;
        END;

        PRECEDENCE: PROCEDURE(N) BYTE;
            DECLARE N BYTE, PAD BYTE;
            DECLARE TABLE DATA(  0,   0, 67h, 61h, 76h, 56h, 34h, 73h,
                               77h, 11h, 11h, 11h, 11h,   0, 11h, 11h,
                               11h, 11h, 11h, 11h, 11h, 11h, 11h);

            RETURN GETNIBBLEAT(.TABLE, N);
        END;

        /* LOOK UP TOKEN IN ONE OF THE TWO SYMBOL TABLES */ /* USING A BINARY SEARCH */
        /* SYMBOLS ARE STORED AS 8 BYTE ENTRIES
           NAME(5) BYTE,
           TYPE BYTE,
           ACCUM1(0) ADDRESS
        */
        LOOKUP: PROCEDURE(TABLEID) BYTE;
            DECLARE TABLEID BYTE;
            DECLARE CMP BYTE;

            LOW$P = SYMTAB(TABLEID);
            HIGH$P, MID$P = SYMTAB$END(TABLEID);
            DECLARE MIDCH BASED MID$P BYTE,
                    REFCH BASED REF$P BYTE,
                    SYM BASED SYM$P(0) BYTE;

            DO WHILE (REF$P := LOW$P + SHR((HIGH$P - LOW$P) AND 0FFF0H, 1)) <> MID$P;
                MID$P = REF$P;
                REF$P = TOKEN$P(0);
                DO WHILE (CMP := MIDCH - REFCH) = 0;
                    MID$P = MID$P + 1;
                    IF (REF$P := REF$P + 1) = TOKEN$P(0) + TOKEN$LEN THEN DO;
                        IF TOKEN$LEN = 5 OR MIDCH = ' ' THEN DO;
                            SYM$P(0) = MID$P - TOKEN$LEN;
                            TOKEN$TYPE = SYM(5);
                            IF TOKEN$TYPE = 2AH OR TOKEN$TYPE = 22H OR  /* IMM16, LXI */
                               TOKEN$TYPE = 13H OR TOKEN$TYPE = 14H OR  /* DS DW */
                               TOKEN$TYPE = 18H OR TOKEN$TYPE = 1DH OR  /* EQU ORT */
                               TOKEN$TYPE = 1EH THEN                    /* SET */
                                USE16 = 1;
                            RETURN TOKEN$TYPE;
                        END;
                        ELSE GOTO BREAK;
                    END;
                END;
            BREAK:
                MID$P = (MID$P - REF$P) + TOKEN$P(0);
                IF ROL(CMP, 1) THEN   /* SIGN TEST */
                    LOW$P = MID$P;
                ELSE
                    HIGH$P = MID$P;
                
            END;
            SYM$P(0) = HIGH$P;
            RETURN 0;
        END;

        DECLARE W5A5C ADDRESS;

        INSERTSYM: PROCEDURE(NEWTYPE, N);
            DECLARE (NEWTYPE, N) BYTE, I BYTE;
            IF TOKENCNT <> 1 THEN
                CALL RECORDERROR('F');
            ELSE DO;
                IF TOKEN$TYPE = 0 THEN DO;
                    IF (HIGH$P := (LOW$P := SYMHIGHMARK) + 8) >= ENDRAM THEN DO;
                        CALL RECORDERROR('T'); 
                        GOTO DONE;
                    END;
                    ELSE DO;
                        SYMHIGHMARK = HIGH$P;
                        IF IFSTATE(0) <> 3 THEN
                            W583A = W583A + 8;
                        SYMTAB$END(N) = SYMTAB$END(N) + 8;
                        MID$P = SYMTAB(N) - 2;
                        MIDWD = MIDWD + 8;
                        DO WHILE (N := (N + 1) AND (MACRODEPTH >= N)) <> 1;
                            SYMTAB(N) = SYMTAB(N) + 8;
                            SYMTAB$END(N) = SYMTAB$END(N) + 8;
                        END;
                        DO WHILE LOW$P >= SYM$P;
                            HIGHWD = LOWWD;
                            HIGH$P = HIGH$P - 2;
                            LOW$P = LOW$P - 2;
                        END;
                        DO I = 0 TO 4;                        
                            N = ' ';
                            IF TOKEN$LEN > I THEN
                                N = TOKEN(I);
                            SYM(I) = N;
                        END;
                        TOKEN$TYPE = NEWTYPE;
                    END;
                END;
                ELSE IF (TOKEN$TYPE <> 4 OR TOKEN$TYPE <> NEWTYPE) AND PASS = 1 THEN
                    TOKEN$TYPE = 3;
                ELSE IF TOKEN$TYPE <> 4 THEN
                    IF SYMWD(3) <> W5A5C THEN
                        CALL RECORDERROR(((TOKEN$TYPE <> 3) AND 3) + 'M' + ((SYM$P(0) = 0) AND 1));
                IF SYM$P <> 0 THEN DO;
                    SYM(5) = TOKEN$TYPE;
                    IF TOKEN$TYPE = NEWTYPE THEN
                        SYMWD(3) = W5A5C;
                END;
        DONE:
                CALL POP$TOKEN;
            END;
        END;

        GETNUMVAL: PROCEDURE ADDRESS;
            ACCUM1 = 0;
            IF TOKENCNT < 1 THEN
                CALL RECORDERROR('F');
            ELSE DO;
                IF TOKEN$TYPE = 0 AND MACRODEPTH > 1 THEN
                    TOKEN$TYPE = LOOKUP(2);
                IF TOKEN$TYPE = 0 THEN
                    CALL RECORDERROR('U');
                ELSE DO;
                    IF TOKEN$TYPE <= 4 THEN DO;
                        TOKEN$P(0) = SYM$P +  6;
                        TOKEN$LEN = 2;
                    END;
                    ELSE IF TOKEN$LEN > 2 THEN
                        CALL RECORDERROR('V');
                    ACC1LOW = TOKEN(0);
                    IF TOKEN$LEN > 1 THEN
                        ACC1HIGH = TOKEN(1);
                    /* SEE IF NEED TO SWAP HIGH AND LOW BYTES */
                    IF TOKEN$TYPE = 5 AND USE16 AND TOKEN$LEN = 2 THEN DO;
                        NUMTMP = ACC1LOW;
                        ACC1LOW = ACC1HIGH;
                        ACC1HIGH = NUMTMP;
                    END;
                END;
            CALL POP$TOKEN;
            END;
            RETURN ACCUM1(0);
        END;

        DECLARE WORKBUF(66) BYTE;
                
        INCNT = 127;
        B57D5 = 0;
        IF PASS = 2 THEN
            CALL WRITESYM$HEX;
        USE16 = 0;
        WORDOPERAND = 0;
        HAVETITLE = 0;
        B583C = 0;
        SKIPIF(0) = 0;
        ADDR = 0;
        SHOWADDR = 0;
        ERRCNT = 0;
        SYMTAB(0) = ITABLE$P;
        SYMTAB$END(0), W583A = MEMORY$P;
        IF PASS = 1 THEN DO;
            DECLARE C BASED W5842 BYTE;
            W5842 = MEMCHK + 250;   /* MONITOR RAM AS WELL */
            ENDRAM = W5842 - 1;
            C = EOFCH;
            W5842 = ENDRAM;
            SYMHIGHMARK = SYMTAB$END(0);    /* NO SYMBOLS YET */
            TITLELEN = 0;
        END;
        IF CHKDOLST THEN DO;
            ROWCNT = 0;
            LINECOL = 0;
            LINEEND = 0;
            PAGENO = 1;
            PAGEWIDTH = 120;
            CALL WRITECH$LST(0Ch);
            CALL PUTCH$LST(0Ch);
        END;
        ERRORCH = ' ';
        RECLEN = 0;
        CHECKSUM = 0;
        ENDSEEN = 0;
        GETNEW = 0;
        TOKENCNT = 0;
        IFDEPTH = 0;
        MACRODEPTH = 0;
        TOKEN$LEN = 0;
        TOKEN$TYPE = 0;
        OPSP = 0;
        OPSTACK(0) = 0;
        PC = 0;
        RECADDR = 0;
        LASTCHREAD = CR;
        MAXRECLEN = 16;
        B583C = 0;
        EXPANDING = 0;
        B5807 = 0;
        CALL NEST(2);
        PC = 0;
        RECADDR = 0;
        END$WORKBUF$P = (TOKEN$P(0) := .WORKBUF) + 66;
        NEWACTION = 1;


COLLECTLOOP:
        IF NEWACTION = 0 THEN
            CALL RECORDERROR('E');

        NEWACTION = 0;
LOOP:
        DO CASE CLASSIFY;
            DO;                         /* CASE 0 ILLEGAL */
                IF NOT (TOKID = EOFCH AND EXPANDING) THEN DO;
                    CALL RECORDERROR('I');
                    GOTO LOOP;
                END;
            END;
            GOTO LOOP;                  /* CASE 1 WHITESPACE */
            DO;                         /* CASE 2 SEMICOLON  */
                DO WHILE CLASSIFY <> 4;
                END;
                TOKID = 1;
            END;
            DO;                         /* CASE 3 COLON */
                NEWACTION = 1;
                II = 0;
                IF GETCH <> ':' THEN
                    GETNEW = GETNEW - 1;
                ELSE IF MACRODEPTH > 1 THEN DO;
                    II = 2;
                    TOKEN$TYPE = LOOKUP(2);
        `       END;
                    
                IF SKIPIF(0) THEN DO;
                    IF NOT WORDOPERAND THEN
                        CALL POP$TOKEN;
                END;
                ELSE DO;
                    W5A5C = PC;
                    CALL INSERTSYM(2, II);
                END;
                GOTO LOOP;
            END;
            DO;                         /* CASE 4 CR */
                TOKID = 1;
            END;
            DO;                         /* CASE 5 ( ) *, - / */
                IF (TOKID = '+' OR TOKID = '-') AND NEWACTION <> 0 AND NEWACTION <> 3 THEN
                    TOKID = TOKID + 3;
                TOKID = TOKID - '(' + 2;
            END;
            DO;                         /* CASE 6 $ */
                CALL PUSH$TOKEN(7);
                CALL ADDCH$TOKEN(LOW(PC));
                CALL ADDCH$TOKEN(HIGH(PC));
                GOTO COLLECTLOOP;
            END;
            DO;                         /* CASE 7 QUOTE */
                CALL PUSH$TOKEN(5);
                DO WHILE GETCH <> CR;
                    IF TOKID = '''' THEN
                        IF GETCH <> '''' THEN
                            GOTO GOTSTRING;
                    CALL ADDCH$TOKEN(TOKID);
                END;
                CALL RECORDERROR('B');
    GOTSTRING:
                GETNEW = GETNEW - 1; 
                GOTO COLLECTLOOP;
            END;
            DO;                         /* CASE 8 NUMBER */
                CALL GETID(7); 
                IF (RADIX := TOKEN(TOKEN$LEN := TOKEN$LEN - 1)) = 'H' THEN
                    RADIX = 16;
                IF RADIX = 'O' THEN
                    RADIX = 8;
                IF RADIX = 'Q' THEN
                    RADIX = 8;
                IF RADIX = 'B' THEN
                    RADIX = 2;
                IF RADIX = 'D' THEN
                    RADIX = 10;
                IF RADIX > 16 THEN
                    RADIX = 10;
                ELSE
                    TOKEN$LEN = TOKEN$LEN - 1;
                ACCUM1(0) = 0;
                DO II = 0 TO TOKEN$LEN;
                    IF (TOKID := TOKEN(II) - '0') > 9 THEN
                        TOKID = TOKID - 7;
                    IF TOKID >= RADIX THEN DO;
                        TOKID = 0;
                        CALL RECORDERROR('I');
                    END;
                    ACCUM1(0) = ACCUM1(0) * RADIX + TOKID;
                END;
                TOKEN$LEN = 0;
                CALL ADDCH$TOKEN(LOW(ACCUM1(0)));
                CALL ADDCH$TOKEN(HIGH(ACCUM1(0)));
                GOTO COLLECTLOOP;
            END;
            DO;                     /* CASE 9 LETTER */
                ACCUM2(0) = W5812 - 1;
                CALL GETID(0);
                IF TOKEN$LEN > 5 THEN
                    TOKEN$LEN = 5;
                IF LOOKUP(1) = 0 THEN DO;
                    IF LOOKUP(0) = 1 THEN DO;
                        W5812 = (MID$P := ACCUM2(0)) + 2;
                        MIDSYM(0) = GETNUMVAL OR 80H;
                        MIDSYM(1) = TOKID; 
                        WORDOPERAND = 1;
                    END;
                END;
                IF TOKEN$TYPE = 23 THEN
                    W5840 = ACCUM2(0);
                IF TOKEN$TYPE = 0 AND MACRODEPTH > 1 THEN
                    IF LOOKUP(2) <> 32 THEN
                        TOKEN$TYPE = LOOKUP(0);
                IF (TOKID := TOKEN$TYPE) >= 31 THEN
                    TOKEN$TYPE = 2;
                IF TOKEN$TYPE > 10 THEN
                    CALL POP$TOKEN;
                IF TOKID > 4 THEN
                    GOTO HANDLEOP;
                GOTO COLLECTLOOP;
            END;
        END;    /* OF CASE */

                
DECLARE OPFLAGS DATA( 0, 80h,   0,   0, 0Fh, 0Fh,   0, 0Fh,
                    0Dh, 0Fh, 0Dh, 0Dh, 0Fh, 0Fh, 0Fh, 0Fh,
                    0Fh, 0Fh, 40h,   1, 4Dh, 80h, 80h, 80h,
                      1, 81h, 80h, 40h, 40h,   1,   1, 40h,
                    40h, 40h, 47h,   7,   7,   7, 17h, 47h,
                      7, 47h, 37h,   5);

HANDLEOP:
        IF OPFLAGS(TOKID) < 80H AND SKIPIF(0) THEN
            GOTO LOOP;
        IF PRECEDENCE(NEWACTION := TOKID) > PRECEDENCE(ACTION := OPSTACK(OPSP)) OR NEWACTION = 2 THEN DO;
            OPSTACK(OPSP := OPSP + 1) = NEWACTION;
            GOTO LOOP;
        END;
        IF ACTION = 0 THEN
            ACTION = NEWACTION;
        ELSE
            OPSP = OPSP - 1;
        IF (CUR$OP$FLAGS := OPFLAGS(ACTION)) THEN
            ACCUM2(0) = GETNUMVAL;
        IF (CUR$OP$FLAGS := ROR(CUR$OP$FLAGS, 1)) THEN
            ACCUM1(0) = GETNUMVAL;
        NEXT$TOK$TYPE = 7;
        DO CASE ACTION;
        ;               /* CASE 0 */
CASE$1: DO;             /* CASE 1 */
            REF$P = TOKEN$P(0) + TOKEN$LEN;
            IF SKIPIF(0) THEN
                REF$P = .WORKBUF;
            DO WHILE TOKENCNT > 0;
                IF TOKEN$TYPE <> 6 THEN
                    CALL RECORDERROR('Q');
                CALL POP$TOKEN;
            END;
            MID$P = .WORKBUF;
            II = 1;
            IF CHKDOLST THEN DO;
                DO WHILE II;
                    CALL PUTCH$LST(0Dh);
                    CALL PUTCH$LST(0);
                    CALL PUTCH$LST(ERRORCH); 
                    CALL PUTCH$LST(20h);
                    IF (SHOWADDR := MID$P <> REF$P OR SHOWADDR) THEN DO;
                        CALL PUTHEX2$LST(HIGH(ADDR));
                        CALL PUTHEX2$LST(LOW(ADDR));
                    END;
                    SHOWADDR = SHL(NOT SHOWADDR AND 1, 2);
                    DO JJ = 0 TO SHOWADDR;
                        CALL PUTCH$LST(' ');
                    END;
                    DO JJ = 1 TO 4;
                        IF MID$P < REF$P THEN
                            CALL PUTHEX2$LST(MIDCH);
                        ELSE DO;
                            CALL PUTCH$LST(' ');
                            CALL PUTCH$LST(' ');
                        END;
                        II = (MID$P := MID$P + 1) < REF$P;
                    END;
                    IF EXPANDING THEN
                        CALL PUTCH$LST('+');
                    ELSE
                        CALL PUTCH$LST(' ');
                    IF II THEN
                        CALL PUTCH$LST(LF);
                    ADDR = ADDR + 4;
                END;
            END;    /* CHKDOLST */
            IF PASS = 2 THEN DO;
                MID$P = .WORKBUF;
                IF RECADDR + RECLEN <> PC OR ENDSEEN THEN DO;
                    IF RECLEN > 0 THEN
                        CALL WRITEHEXREC$HEX(0);
                    RECADDR = PC;
                END;
                DO WHILE MID$P < REF$P; 
                    IF RECLEN = MAXRECLEN THEN DO;
                        CALL WRITEHEXREC$HEX(0);
                        RECADDR = RECADDR + 16;
                    END;
                    CHECKSUM = CHECKSUM - (RECBUF(RECLEN := RECLEN + 1) := MIDCH);
                    MID$P = MID$P + 1;
                END; 
                IF ENDSEEN THEN
                    CALL WRITEHEXREC$HEX(1);
            END;     /* PASS 2 */
            ADDR, PC = PC + REF$P - .WORKBUF;
            SHOWADDR = 0;
            WORDOPERAND = 0;
            USE16 = 0;
            ERRORCH = ' ';
            OPSP = 0;
            SKIPIF(0) = SKIPIF(0) > 0;
            IF ENDSEEN THEN DO;
                ENDSEEN = 0;
                B57D5 = 1;
                IF CHKDOLST THEN
                    CALL WRITESYM$HEX;
                RETURN;
            END; 
            GOTO LOOP;
        END;
        GOTO CASE$3;            /* CASE 2 ) */
CASE$3: DO;                     /* CASE 3 ( */
            IF NOT (ACTION = 2 AND NEWACTION = 3) THEN
                CALL RECORDERROR('B');
            IF TOKEN$TYPE  = 6 THEN
                TOKEN$LEN = 1;
            IF NEWACTION = 3 THEN
                GOTO LOOP; 
        END;
        ACCUM1(0) = ACCUM1(0) * ACCUM2(0);  /* CASE 4 * */
        ACCUM1(0) = ACCUM1(0) + ACCUM2(0);  /* CASE 5 + */ 
        CALL RECORDERROR('F');              /* CASE 6 , */
        ACCUM1(0) = ACCUM1(0) - ACCUM2(0);  /* CASE 7 - */
        ;                                   /* CASE 8 UNARY + */
        ACCUM1(0) = ACCUM1(0) / ACCUM2(0);  /* CASE 9  / */
        ACCUM1(0) = -ACCUM1(0);             /* CASE 10 UNARY - */
        ACCUM1(0) = NOT ACCUM1(0);          /* CASE 11 NOT */
        ACCUM1(0) = ACCUM1(0) AND ACCUM2(0); /* CASE 12 AND */
        ACCUM1(0) = ACCUM1(0) OR ACCUM2(0);  /* CASE 13 OR */
        ACCUM1(0) = ACCUM1(0) XOR ACCUM2(0); /* CASE 14 XOR */
        ACCUM1(0) = ACCUM1(0) MOD ACCUM2(0); /* CASE 15 MOD */
        DO;                                  /* CASE 16 SHL */
            IF ACC2LOW <> 0 THEN
            ACCUM1(0) = SHL(ACCUM1(0), ACC2LOW);
        END;
        DO;                                  /* CASE 17 SHR */
            IF ACC2LOW <> 0 THEN
            ACCUM1(0) = SHR(ACCUM1(0), ACC2LOW);
        END;
        DO;                                 /* CASE 18 DB */
            IF TOKEN$TYPE <> 5 AND TOKEN$TYPE <> 6 THEN DO;
                ACCUM1(0) = GETNUMVAL;
                IF ACC1HIGH -1  < 0FEH THEN 
                    CALL RECORDERROR('V');
                CUR$OP$FLAGS = 22H;
            END;
            TOKEN$TYPE = 6;
            NEXT$TOK$TYPE = 6;
        END;
        DO;                                 /* CASE 19 DS */
            SHOWADDR = 1;
            PC = PC + ACCUM2(0);            /* EXPECTED ACCUM1 */
            GOTO HANDLEOP;
        END;
        NEXT$TOK$TYPE = 6;                          /* CASE 20 DW */
        DO;                                 /* CASE 21 END */
            PC = 0;
            ACCUM1(0) = 0;
            IF TOKENCNT > 0 THEN
                PC = GETNUMVAL;
            SHOWADDR = 1;
            ENDSEEN = 1;
            SKIPIF(0) = 0;
            W581C(0) = ENDRAM;
            CALL UNNEST(2);
        END;
        CALL UNNEST(0);                   /* CASE 22 ENDIF */
        DO;                                 /* CASE 23 ENDM */
            IF NOT (IFSTATE(0) = 0 AND SKIPIF(0)) THEN DO;
                IF PASS = 1 AND B583C THEN DO;
                    DECLARE C BASED W5840 BYTE;
                    C = EOFCH;
                    W581C(0), W583E = MOVEUP(SYMHIGHMARK, W5840);
                END;
                CALL UNNEST(3);
            END;
            
        END;
        DO;                                 /* CASE 24 EQU */
            SHOWADDR = 1;
            W5A5C = ACCUM1(0);
            CALL INSERTSYM(2, 0);
        END;
        DO;                                 /* CASE 25 IF */
            CALL NEST(0);
            SKIPIF(0) = IFDEPTH > 1 AND (((ACCUM1(0) = 0) AND 1) OR SKIPIF(0));
        END;
CASE$26:DO;                           /* CASE 26 */
            CALL UNNEST(1);
            GOTO CASE$1;
        END;
CASE$27:DO;                           /* CASE 27 MACRO */
            W583E$P = SYM$P + 6;
            IF PASS = 1 THEN DO;
                W5A5C = W5842;
                CALL INSERTSYM(32, 0);
            END;
            ELSE DO;
                IF W5842 = W583E THEN
                    CALL RECORDERROR('T');
                IF TOKEN$TYPE = 3 THEN
                    CALL RECORDERROR('M');
                CALL POP$TOKEN;
            END;
            CALL NEST(3);
            TOKID = 28;
            B583D = 0;
        END;
        DO;                           /* CASE 28 */
            IF TOKENCNT <> 0 THEN DO;
                IF PASS = 1 THEN DO;
                    B583D = B583D + 1;
                    W5A5C = B583D;
                    CALL INSERTSYM(1, 0);
                END;
                ELSE
                    CALL POP$TOKEN;
            END;
            IF NEWACTION = 1 THEN DO;
                SKIPIF(0) = 1;
                W5812 = SYMHIGHMARK;
                B583C = ERRORCH = ' ';
            END;
        END;
        DO;                         /* CASE 29 ORG */
            SHOWADDR = 1;
            PC = ACCUM1(0);
        END;
        DO;                         /* CASE 30 SET */
            II = 0;
            IF TOKEN$TYPE = 0 AND MACRODEPTH > 1 THEN DO;
                II = 2;
                IF LOOKUP(2) <> 4 AND TOKEN$TYPE <> 0 THEN
                    CALL RECORDERROR('M');
                IF TOKEN$TYPE <> 4 THEN DO;
                    II = 0;
                    TOKEN$TYPE = LOOKUP(0);
                END;
            END;
            SHOWADDR = 1;
            W5A5C = ACCUM1(0);
            CALL INSERTSYM(4, II);
        END;
        DO;                         /* CASE 31 TITLE */
            IF NEWACTION = 1 THEN DO;
                IF PASS <> 1 OR NOT HAVETITLE THEN DO;
                    REF$P = .WORKBUF + 5;
                    TITLELEN = 0;
                    DO WHILE TOKEN$P(0) + TOKEN$LEN > REF$P;
                        IF TITLELEN < 66 AND (II := REFCH) <> FF THEN
                            TITLE(TITLELEN := TITLELEN + 1) = II;
                        REF$P = REF$P + 1;
                    END;
                END; 
                DO WHILE TOKENCNT > 0;
                    CALL POP$TOKEN;
                END;
                IF PASS = 1 THEN
                    HAVETITLE = 1;
            END;
        END;
        DO;                          /* CASE 32 */
            IF NEWACTION = 27 THEN
                GOTO CASE$27;
            ACTION = 33;
            W583E$P = ENDRAM;
            GOTO CASE$33;
        END;
CASE$33:DO;                        /* CASE 33 */
            IF TOKENCNT < 2 THEN
                CALL PUSH$TOKEN(5);
            IF TOKEN$TYPE <> 5 THEN DO;
                MID$P = GETNUMVAL;
                CALL PUSHTOKEN(5);
                CALL ADDCH$TOKEN('0');
                CALL ADDCH$TOKEN(HEX1(ROR(ACC1HIGH, 4)));
                CALL ADDCH$TOKEN(HEX1(ACC1HIGH));
                CALL ADDCH$TOKEN(HEX1(ROR(ACC1LOW, 4)));
                CALL ADDCH$TOKEN(HEX1(ACC1LOW));
                CALL ADDCH$TOKEN('H');
            END;
            CALL ADDCH$TOKEN(((II := TOKEN$LEN) + 1) OR 80H);
            ACCUM2(0) = MOVEUP(TOKEN$P, TOKEN$P + II);
            CALL POP$TOKEN;
            IF NEWACTION = 1 THEN DO;
                IF TOKENCNT <> 1 THEN
                    CALL RECORDERROR('F');
                ELSE DO;
                    ACCUM2(0) = MOVEUP(.(80H), .(81H));
                    CALL NEST(1);
                    W5812 = GETNUMVAL;
                    EXPANDING = 1;
                    W581C(0) = W583E$P;
                    IF ERRORCH = 'F' THEN
                        GOTO CASE$26;
                END;
            END; 
        END;
        CALL MKCODE(85h);          /* CASE 34 */
        CALL MKCODE(5);            /* CASE 35 */
        CALL MKCODE(7);            /* CASE 36 */
        CALL MKCODE(2);            /* CASE 37 */
        CALL MKCODE(8);            /* CASE 38 */
        CALL MKCODE(46h);          /* CASE 39 */
        CALL MKCODE(6);            /* CASE 40 */
        CALL MKCODE(36h);          /* CASE 41 */
        CALL MKCODE(0);            /* CASE 42 */
        CALL MKCODE(0);            /* CASE 43 */
        END; /* END OF CASE */
        IF SHOWADDR THEN
            ADDR = ACCUM1(0);
        IF (CUR$OP$FLAGS AND 1EH) <> 0 THEN
            CALL PUSH$TOKEN(NEXT$TOK$TYPE);
        DO II = 0 TO 3;
            IF (CUR$OP$FLAGS := ROR(CUR$OP$FLAGS, 1)) THEN
                CALL ADDCH$TOKEN(ACC1B(II));
        END;
        IF ROR(CUR$OP$FLAGS, 1) THEN
            IF NEWACTION = 6 THEN
                TOKID = ACTION;
        GOTO HANDLEOP;
    END;
    

        DECLARE ITABLE(856) BYTE INITIAL(
            'A    ',     3,     7,     0,
            'ACI  ',   26h,  0CEh,     0,
            'ADC  ',   25h,   88h,     0,
            'ADD  ',   25h,   80h,     0,
            'ADI  ',   26h,  0C6h,     0,
            'ANA  ',   25h,  0A0h,     0,
            'AND  ',   0Ch,     0,     0,
            'ANI  ',   26h,  0E6h,     0,
            'B    ',     3,     0,     0,
            'C    ',     3,     1,     0,
            'CALL ',   2Ah,  0CDh,     0,
            'CC   ',   2Ah,  0DCh,     0,
            'CM   ',   2Ah,  0FCh,     0,
            'CMA  ',   2Bh,   2Fh,     0,
            'CMC  ',   2Bh,   3Fh,     0,
            'CMP  ',   25h,  0B8h,     0,
            'CNC  ',   2Ah,  0D4h,     0,
            'CNZ  ',   2Ah,  0C4h,     0,
            'CP   ',   2Ah,  0F4h,     0,
            'CPE  ',   2Ah,  0ECh,     0,
            'CPI  ',   26h,  0FEh,     0,
            'CPO  ',   2Ah,  0E4h,     0,
            'CZ   ',   2Ah,  0CCh,     0,
            'D    ',     3,     2,     0,
            'DAA  ',   2Bh,   27h,     0,
            'DAD  ',   23h,     9,     0,
            'DB   ',   12h,     0,     0,
            'DCR  ',   28h,     5,     0,
            'DCX  ',   23h,   0Bh,     0,
            'DI   ',   2Bh,  0F3h,     0,
            'DS   ',   13h,     0,     0,
            'DW   ',   14h,     0,     0,
            'E    ',     3,     3,     0,
            'EI   ',   2Bh,  0FBh,     0,
            'END  ',   15h,     0,     0,
            'ENDIF',   16h,     0,     0,
            'ENDM ',   17h,     0,     0,
            'EQU  ',   18h,     0,     0,
            'H    ',     3,     4,     0,
            'HLT  ',   2Bh,   76h,     0,
            'IF   ',   19h,     0,     0,
            'IN   ',   26h,  0DBh,     0,
            'INR  ',   28h,     4,     0,
            'INX  ',   23h,     3,     0,
            'JC   ',   2Ah,  0DAh,     0,
            'JM   ',   2Ah,  0FAh,     0,
            'JMP  ',   2Ah,  0C3h,     0,
            'JNC  ',   2Ah,  0D2h,     0,
            'JNZ  ',   2Ah,  0C2h,     0,
            'JP   ',   2Ah,  0F2h,     0,
            'JPE  ',   2Ah,  0EAh,     0,
            'JPO  ',   2Ah,  0E2h,     0,
            'JZ   ',   2Ah,  0CAh,     0,
            'L    ',     3,     5,     0,
            'LDA  ',   2Ah,   3Ah,     0,
            'LDAX ',   24h,   0Ah,     0,
            'LHLD ',   2Ah,   2Ah,     0,
            'LXI  ',   22h,     1,     0,
            'M    ',     3,     6,     0,
            'MACRO',   1Bh,     0,     0,
            'MOD  ',   0Fh,     0,     0,
            'MOV  ',   29h,   40h,     0,
            'MVI  ',   27h,     6,     0,
            'NOP  ',   2Bh,     0,     0,
            'NOT  ',   0Bh,     0,     0,
            'OR   ',   0Dh,     0,     0,
            'ORA  ',   25h,  0B0h,     0,
            'ORG  ',   1Dh,     0,     0,
            'ORI  ',   26h,  0F6h,     0,
            'OUT  ',   26h,  0D3h,     0,
            'PCHL ',   2Bh,  0E9h,     0,
            'POP  ',   23h,  0C1h,     0,
            'PSW  ',     3,     6,     0,
            'PUSH ',   23h,  0C5h,     0,
            'RAL  ',   2Bh,   17h,     0,
            'RAR  ',   2Bh,   1Fh,     0,
            'RC   ',   2Bh,  0D8h,     0,
            'RET  ',   2Bh,  0C9h,     0,
            'RLC  ',   2Bh,     7,     0,
            'RM   ',   2Bh,  0F8h,     0,
            'RNC  ',   2Bh,  0D0h,     0,
            'RNZ  ',   2Bh,  0C0h,     0,
            'RP   ',   2Bh,  0F0h,     0,
            'RPE  ',   2Bh,  0E8h,     0,
            'RPO  ',   2Bh,  0E0h,     0,
            'RRC  ',   2Bh,   0Fh,     0,
            'RST  ',   28h,  0C7h,     0,
            'RZ   ',   2Bh,  0C8h,     0,
            'SBB  ',   25h,   98h,     0,
            'SBI  ',   26h,  0DEh,     0,
            'SET  ',   1Eh,     0,     0,
            'SHL  ',   10h,     0,     0,
            'SHLD ',   2Ah,   22h,     0,
            'SHR  ',   11h,     0,     0,
            'SP   ',     3,     6,     0,
            'SPHL ',   2Bh,  0F9h,     0,
            'STA  ',   2Ah,   32h,     0,
            'STAX ',   24h,     2,     0,
            'STC  ',   2Bh,   37h,     0,
            'SUB  ',   25h,   90h,     0,
            'SUI  ',   26h,  0D6h,     0,
            'TITLE',   1Fh,     0,     0,
            'XCHG ',   2Bh,  0EBh,     0,
            'XOR  ',   0Eh,     0,     0,
            'XRA  ',   25h,  0A8h,     0,
            'XRI  ',   26h,  0EEh,     0,
            'XTHL ',   2Bh,  0E3h,     0);



        DECLARE PAD3CFC ADDRESS, LASTADDRESS ADDRESS;
        DECLARE CH BASED BUFFER$PTR BYTE;
MAIN:
    CALL READ(1, .BUFFER, 80, .ENDBUF$PTR, .STATUS);
    BUFFER$PTR = .BUFFER;
    CALL CHECKSTATUS;
    ENDBUF$PTR = ENDBUF$PTR + .BUFFER;
    HEXOPEN, NOHEX, NOLST, DEFOUT = 0;
    ITABLE$P = .ITABLE;
    MEMORY$P = .LASTADDRESS;
    CALL WRITECH$CO(CR);
    II = 0;
    DO WHILE (JJ := PAGEHEADER(II := II + 1)) <> TAB;
        CALL WRITECH$CO(JJ);
    END; 
    DO PASS = 1 TO 3;
        DO CASE PASS; 
        ;                /* CASE 0 */
        DO;              /* CASE 1 */
            AFTIN = OPENFILE(1);
            IF (BUFFER$PTR = ENDBUF$PTR) OR CH = CR THEN DO;
                CALL OPEN$DEFAULT$OUT;
                DEFOUT = 1;
            END;
            ELSE DO;
                CALL CHK$TO$LIST(2);    /* CHECK FOR TO */
                HEX$FILE = BUFFER$PTR;
                IF (AFTHEX := OPENFILE(2)) = 255 THEN
                    NOHEX = 1;

                CALL CHK$TO$LIST(4);    /* CHECK FOR LIST */
                CALL CLOSE(AFTHEX, .STATUS);
                LST$FILE = BUFFER$PTR;
                IF (AFTLST := OPENFILE(2)) = 255 THEN
                    NOLST = 1;
            END;
        END;
        DO;              /* CASE 2 */
            IF NOHEX THEN
                GOTO CONTINUE;
            IF DEFOUT = 0 THEN DO;
                IF AFTHEX <> AFTLST THEN
                    DEFOUT = 1;
                ELSE
                    CALL CLOSE(AFTLST, .STATUS);
                BUFFER$PTR = HEX$FILE;
                AFTHEX = OPENFILE(2);
            END;
            HEXOPEN = 1;
        END;
        DO;             /* CASE 3 */
            IF NOLST OR DEFOUT THEN
                GOTO CONTINUE;
            IF HEXOPEN THEN
                CALL CLOSE(AFTHEX, .STATUS);
            BUFFER$PTR = LST$FILE;
            IF HEXOPEN = 1 THEN
                AFTLST = OPENFILE(2);
        END;
        END; /* OF CASE */
        IF PASS > 1 THEN DO;
            IN$TMP = 0;
            /* REWIND INPUT FILE */
            CALL SEEK(AFTIN, 2, .IN$TMP, .IN$TMP, .STATUS);
            CALL CHECKSTATUS;
        END;
        CALL DOPASS;
CONTINUE:
    END;

    IF ERRCNT = 0 THEN
        CALL WRITE(0, .ASMCOMPLETE, 41, .STATUS);
    ELSE DO;
        CALL WRITE(0, .ASMCOMPLETE, 22, .STATUS);
        CALL WRITEHEX2$CO(ERRCNT);
        CALL WRITECH$CO('H');
        IN$TMP = .ASMCOMPLETE + 24;
        CALL WRITE(0, IN$TMP, 17, .STATUS);
    END;
    CALL EXIT;
END;
EOF
asmb.asm
    name asmb
    aseg
    org 7000h
; load, patch and run asm80

LOAD    equ     6
ERROR   equ     12
EXIT    equ     9
ISIS    equ     40h

; page size patch info
P1ADDR  equ     38B8h   ; check in ADDCH$LST
P2ADDR  equ     3948h   ; check in PUTCH$LST
ROWCNT  equ     48      ; row limit witout header


start:
    lxi     sp,start
    mvi     c,LOAD
    lxi     d,lodprm
    call    ISIS 
    lda     status
    ora     a
    jnz     failed
    mvi     a,ROWCNT
    sta     P1ADDR
    mvi     a,ROWCNT - 6    ; allow for page header
    sta     P2ADDR
    lhld    entry
    pchl

failed:
    mvi     c,ERROR
    lxi     d,errprm
    call    ISIS
    mvi     c,EXIT
    lxi     d,extprm
    call    ISIS


lodprm:         ; load parameters
    dw  filenm  ; path$p
    dw  0       ; load$offset
    dw  0       ; switch
    dw  entry   ; entry$p
    dw  status  ; status$p
errprm:         ; error parameters
status:
    dw  0       ; filled in with load status
    dw  status
extprm:         ; exit parameters
    dw  status
filenm:
    db  'ASM80 '
entry:          ; filled in with load entry
    ds  2

    end start
asmb12.asm
    name asmb12
    aseg
    org 7000h
; load, patch and run asm80

LOAD    equ     6
ERROR   equ     12
EXIT    equ     9
ISIS    equ     40h

; page size patch info
P1ADDR  equ     38B8h   ; check in ADDCH$LST
P2ADDR  equ     3948h   ; check in PUTCH$LST
ROWCNT  equ     72      ; row limit witout header

start:
    lxi     sp,start
    mvi     c,LOAD
    lxi     d,lodprm
    call    ISIS 
    lda     status
    ora     a
    jnz     failed
    mvi     a,ROWCNT
    sta     P1ADDR
    mvi     a,ROWCNT - 6
    sta     P2ADDR
    lhld    entry
    pchl

failed:
    mvi     c,ERROR
    lxi     d,errprm
    call    ISIS
    mvi     c,EXIT
    lxi     d,extprm
    call    ISIS


lodprm:         ; load parameters
    dw  filenm  ; path$p
    dw  0       ; load$offset
    dw  0       ; switch
    dw  entry   ; entry$p
    dw  status  ; status$p
errprm:         ; error parameters
status:
    dw  0       ; filled in with load status
    dw  status
extprm:         ; exit parameters
    dw  status
filenm:
    db  'ASM80 '
entry:          ; filled in with load entry
    ds  2

    end start
attrib.plm
3400H:
DO;
    DECLARE TRUE    LITERALLY '0FFH',
            FALSE   LITERALLY '0',
            CR      LITERALLY '0DH',
            LF      LITERALLY '0AH';

    DECLARE VER DATA(1, 8);
    DECLARE COPYRIGNT DATA('(C) 1975,1976 INTEL CORP');

    ISIS: PROCEDURE(CMD, PARAM$P);
        DECLARE CMD BYTE, PARAM$P ADDRESS;
        GOTO 40H;
    END ISIS;

    READ: PROCEDURE(CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P) ADDRESS;

        CALL ISIS(3, .CONN);
    END;

    WRITE: PROCEDURE(CONN, BUFF$P, COUNT, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, STATUS$P) ADDRESS;

        CALL ISIS(4, .CONN);
    END;

    ATTRIB: PROCEDURE (PATH$P, ATTRIB, ON$OFF, STATUS$P);
        DECLARE (PATH$P, ATTRIB, ON$OFF, STATUS$P) ADDRESS;

        CALL ISIS(10, .PATH$P);
    END ATTRIB;

    EXIT: PROCEDURE;
        DECLARE STATUS ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(9, .STATUS);
    END;

    ERROR: PROCEDURE(ERROR$NUM);
        DECLARE (ERROR$NUM, STATUS) ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(12, .ERROR$NUM);
    END;



    DEBLANK: PROCEDURE(PTR) ADDRESS;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE (C = ' ');
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;

    DELIMIT: PROCEDURE(PTR) ADDRESS;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE (C = ':' OR C = '.' OR
                 ('0' <= C AND C <= '9') OR
                 ('A' <= C AND C <= 'Z'));
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;

    NUMOUT: PROCEDURE(VALUE, BASE, LC, BUFADR, WIDTH);
        DECLARE (VALUE, BUFADR) ADDRESS, (BASE, LC, WIDTH) BYTE; 
        DECLARE DIGITS DATA('0123456789ABCDEF');
        DECLARE I BYTE;
        DECLARE BUF BASED BUFADR (1) BYTE;

        DO I = 1 TO WIDTH;
            BUF(WIDTH - I) = DIGITS(VALUE MOD BASE);
            VALUE = VALUE / BASE;   
        END;

        I = 0;
        DO WHILE BUF(I) = '0' AND I < WIDTH - 1;
            BUF(I) = LC;
            I = I + 1;
        END;
    END;

    REPORTERROR: PROCEDURE(ERRNUM);
        DECLARE ERRNUM ADDRESS;
        DECLARE NUMBERBUFFER(3) BYTE, I ADDRESS, STATUS ADDRESS;
     

        DECLARE ERRMSG DATA(0, 0,
            2, 'ILLEGAL AFTN ARGUMENT', 0,
            4, 'INCORRECTLY SPECIFIED FILE', 0,
            5, 'UNRECOGNIZED DEVICE NAME', 0,
            6, 'ATTEMPT TO WRITE TO INPUT DEVICE', 0,
            8, 'ATTEMPT TO READ FROM OUTPUT DEVICE', 0,
            9, 'DIRECTORY FULL', 0,
            0AH, 'NOT ON SAME DISK', 0,
            0BH, 'FILE ALREADY EXISTS', 0,
            0CH, 'FILE IS ALREADY OPEN', 0,
            0DH, 'NO SUCH FILE', 0,
            0EH, 'WRITE PROTECTED', 0,
            0FH, 'LOAD TOO LOW', 0,
            10H, 'BAD LOAD FORMAT', 0,
            11H, 'NOT A DISK FILE', 0,
            12H, 'ILLEGAL ISIS COMMAND', 0,
            13H, 'ATTEMPTED SEEK ON NON-DISK FILE', 0,
            14H, 'ATTEMPTED BACK SEEK TO FAR', 0,
            16H, 'ILLEGAL ACCESS MODE TO OPEN', 0,
            17H, 'MISSING FILENAME', 0,
            19H, 'ILLEGAL ECHO FILE', 0,
            1AH, 'ILLEGAL ATTRIBUTE IDENTIFIER', 0,
            1BH, 'ILLEGAL SEEK COMMAND', 0,
            1CH, 'MISSING EXTENSION', 0,
            1FH, 'CAN', 27H, 'T SEEK ON WRITE ONLY FILE', 0,
            20H, 'CAN', 27H, 'T DELETE OPEN FILE', 0,
            23H, 'SEEK PAST EOF', 0,
            0C9H, 'UNRECOGNIZED SWITCH', 0,
            0CAH, 'UNRECOGNIZED DELIMITER', 0,
            0CBH, 'INVALID SYNTAX', 0,
            0CCH, 'PREMATURE EOF', 0,
            0CEH, 'ILLEGAL DISKETTE LABEL', 0,
            0D0H, 'CHECKSUM ERROR', 0
        );



        IF ERRNUM <> 0 THEN
        DO;
            I = 0;
            DO WHILE I < LENGTH(ERRMSG);
                IF ERRNUM = ERRMSG(I) AND ERRMSG(I + 1) <> 0 THEN
                DO;
                    I = I + 1;
                    CALL WRITE(0, .(' '), 1, .STATUS);
                    DO WHILE ERRMSG(I) <> 0;
                        CALL WRITE(0, .ERRMSG(I), 1, .STATUS);
                        I = I + 1;
                    END;
                    CALL WRITE(0, .(0DH, 0AH), 2, .STATUS);
                    return;
                END;
                ELSE
                DO;
                    DO WHILE ERRMSG(I) <> 0;
                        I = I + 1;
                    END;
                    I = I + 1;
                END;
            end;
            CALL ERROR(ERRNUM);
        END;
    END;


    FILE$ERROR: PROCEDURE(STATUS, PTR, CALLEXIT);
        DECLARE (STATUS, PTR) ADDRESS, CALLEXIT BYTE;
        DECLARE ERR$STATUS ADDRESS;

        IF STATUS <> 0 THEN
        DO;
            PTR = DEBLANK(PTR);
            CALL WRITE(0, .(' '), 1, .ERR$STATUS);
            CALL WRITE(0, PTR, DELIMIT(PTR) - PTR, .ERR$STATUS);
            CALL WRITE(0, .(','), 1, .ERR$STATUS);
            CALL REPORTERROR(STATUS);
            IF CALLEXIT THEN
                CALL EXIT;
        END;
    END;

        
    DECLARE (PADW, ACTUAL, STATUS) ADDRESS;
    DECLARE BUFPTR ADDRESS, CH BASED BUFPTR BYTE;
    DECLARE BUFFER(128) BYTE;
    DECLARE SWID ADDRESS;
    DECLARE (PAD, ONOFF) BYTE;

MAIN:
    CALL READ(1, .BUFFER, 128, .ACTUAL, .STATUS);
    BUFPTR = DEBLANK(.BUFFER);
    IF CH = CR THEN DO;
        CALL REPORTERROR(0CBH);
        CALL EXIT;
    END;

    BUFPTR = DEBLANK(DELIMIT(BUFPTR));
   
    DO WHILE CH = '$';
        BUFPTR = BUFPTR + 1;
        IF CH = 'I' THEN
            SWID = 0;
        ELSE IF CH = 'S' THEN
            SWID = 1;
        ELSE IF CH = 'W' THEN
            SWID = 2;
        ELSE IF CH = 'F' THEN
            SWID = 3;
        ELSE DO;
            CALL REPORTERROR(0C9H);
            CALL EXIT;
        END;
        BUFPTR = DEBLANK(BUFPTR + 1);
        IF CH = '0' THEN
            ONOFF = 0;
        ELSE IF CH = '1' THEN
            ONOFF = 1;
        ELSE DO;
            CALL REPORTERROR(0C9H);
            CALL EXIT;
        END;
        CALL ATTRIB(.BUFFER, SWID, ONOFF, .STATUS);
        CALL FILEERROR(STATUS, .BUFFER, TRUE);
        BUFPTR = DEBLANK(BUFPTR + 1);
    END;
    IF CH <> CR THEN DO;
        CALL REPORTERROR(0C9H);
        CALL EXIT;
    END;
    CALL EXIT;
END;
EOF
batch.asm
        name batch
        aseg
        org 3200h

; isis calls
ISIS    equ     40h
READ    equ     3
CONSOL  equ     8
ERROR   equ     12
EXIT    equ     9

CR      equ     0dh

start:
        lxi     sp,stk
        mvi     c,READ
        lxi     d,rdprm
        call    ISIS    ; read the cmd line
        lda     status
        ora     a
        jnz     failed
        lhld    bufptr

scan:
        mov     a,m
        shld    bufptr
        inx     h
        cpi     CR     ; end of line
        jz      scan1
        cpi     ' '
        jz      scan    ; check for 'TO '
        cpi     'T'
        jnz     scan2
        mov     a,m
        inx     h
        cpi     'O'
        jnz     scan2
        mov     a,m
        cpi     ' '
        jz      scan3

scan2:
        lhld    bufptr  ; save as the batch file name
        shld    conprm

scan4:                  ; skip file name
        mov     a,m
        shld    bufptr
        inx     h
        cpi     CR
        jz      scan1
        cpi     ' '
        jnz     scan4

scan5:                  ; skip spaces
        mov     a,m
        shld    bufptr
        inx     h
        cpi     ' '
        jz      scan5
        cpi     CR
        jz      scan1   ; end of line
        cpi     'T'
        jnz     badcmd
        mov     a,m
        cpi     'O'
        jnz     badcmd
        inx     h
        mov     a,m
        cpi     ' '
        jnz     badcmd

scan3:                  ; set the output file
        shld    ofile
scan1:
        mvi     c,CONSOL
        lxi     d,conprm
        call    ISIS

done:
        mvi     c,EXIT
        lxi     d,extprm
        call    ISIS

badcmd:
        mvi     a,4     ; error 400h
        sta     status + 1


failed:
        mvi     c,ERROR
        lxi     d,errprm
        call    ISIS
        jmp     done

; the isis parameter blocks
rdprm:
        dw      1       ; read console
bufptr: dw      rdbuf
        dw      128
        dw      actual
        dw      status   

conprm: dw      bfile   ; default batch file, overwitten if needed
ofile:  dw      defco   ; output file, defaults to :CO:
        dw      status
bfile:  db      'BFILE '
defco:  db      ':CO: '
extprm: dw      status  ; shared
errprm:
status: dw      0       ; ISIS status here in case error call needed
        dw      status
actual: ds      2
rdbuf:  ds      128
        ds      4       ; stack area
stk:
        end     start
        
        
copy.plm
3400H:
DO;
    DECLARE TRUE    LITERALLY '0FFH',
            FALSE   LITERALLY '0',
            OK      LITERALLY '0',
            CR      LITERALLY '0DH',
            LF      LITERALLY '0AH';

    DECLARE READMODE    LITERALLY '1',
            WRITEMODE   LITERALLY '2',
            UPDATEMODE  LITERALLY '3';

    /* ERROR CODES */
    DECLARE BAD$PATH LITERALLY '4',
            BAD$DEVICE LITERALLY '5',
            FILE$EXISTS LITERALLY '0BH',
            NO$SUCH$FILE LITERALLY '0DH',
            NULL$FILENAME LITERALLY '23',
            NULL$EXTENSION LITERALLY '28',
            BAD$SWITCH  LITERALLY '0C9H',
            BAD$SYNTAX  LITERALLY '0CBH';

    DECLARE BOOLEAN LITERALLY 'BYTE';
    DECLARE F1DEV LITERALLY '1';

    DECLARE VER DATA(1, 10H);
    DECLARE COPYRIGHT DATA('(C) 1975,1976 INTEL CORP');

    MEMCHK: PROCEDURE ADDRESS;
        GOTO 0F81BH;
    END;

    ISIS: PROCEDURE(CMD, PARAM$P);
        DECLARE CMD BYTE, PARAM$P ADDRESS;
        GOTO 40H;
    END ISIS;

    OPEN: PROCEDURE(CONN$P, PATH$P, ACCESS, ECHO, STATUS$P);
        DECLARE (CONN$P, PATH$P, ACCESS, ECHO, STATUS$P) ADDRESS;

        CALL ISIS(0, .CONN$P);
    END;

    READ: PROCEDURE(CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P) ADDRESS;

        CALL ISIS(3, .CONN);
    END;

    WRITE: PROCEDURE(CONN, BUFF$P, COUNT, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, STATUS$P) ADDRESS;

        CALL ISIS(4, .CONN);
    END;

    CLOSE: PROCEDURE(CONN, STATUS$P);
        DECLARE (CONN, STATUS$P) ADDRESS;

        CALL ISIS(1, .CONN);
    END;

    ERROR: PROCEDURE(ERROR$NUM);
        DECLARE (ERROR$NUM, STATUS) ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(12, .ERROR$NUM);
    END;

	RENAME: PROCEDURE(OLD$P, NEW$P, STATUS$P);
    	DECLARE (OLD$P, NEW$P, STATUS$P) ADDRESS;
    	
    	CALL ISIS(7, .OLD$P);
	END;

    EXIT: PROCEDURE;
        DECLARE STATUS ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(9, .STATUS);
    END;


    DEBLANK: PROCEDURE(PTR) ADDRESS;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE (C = ' ');
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;

    DELIMIT: PROCEDURE(PTR) ADDRESS;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE (C = ':' OR C = '.' OR
                 ('0' <= C AND C <= '9') OR
                 ('A' <= C AND C <= 'Z'));
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;

    SEQ: PROCEDURE(S1, S2, CNT) BYTE;
        DECLARE (S1,S2) ADDRESS, CNT BYTE;
        DECLARE S1A BASED S1(1) BYTE;
        DECLARE S2A BASED S2(1) BYTE;
        DECLARE I BYTE;
        CNT = CNT - 1;
        DO I = 0 TO CNT;
            IF S1A(I) <> S2A(I) THEN
                RETURN 0;
        END;
        RETURN 0FFH;
    END;

    NUMOUT: PROCEDURE(VALUE, BASE, LC, BUFADR, WIDTH);
        DECLARE (VALUE, BUFADR) ADDRESS, (BASE, LC, WIDTH) BYTE; 
        DECLARE DIGITS DATA('0123456789ABCDEF');
        DECLARE I BYTE;
        DECLARE BUF BASED BUFADR (1) BYTE;

        DO I = 1 TO WIDTH;
            BUF(WIDTH - I) = DIGITS(VALUE MOD BASE);
            VALUE = VALUE / BASE;   
        END;

        I = 0;
        DO WHILE BUF(I) = '0' AND I < WIDTH - 1;
            BUF(I) = LC;
            I = I + 1;
        END;
    END;

    REPORTERROR: PROCEDURE(ERRNUM);
        DECLARE ERRNUM ADDRESS;
        DECLARE NUMBERBUFFER(4) BYTE, I ADDRESS, STATUS ADDRESS;
     

        DECLARE ERRMSG DATA(0, 0,
            2, 'ILLEGAL AFTN ARGUMENT', 0,
            4, 'INCORRECTLY SPECIFIED FILE', 0,
            5, 'UNRECOGNIZED DEVICE NAME', 0,
            6, 'ATTEMPT TO WRITE TO INPUT DEVICE', 0,
            8, 'ATTEMPT TO READ FROM OUTPUT DEVICE', 0,
            9, 'DIRECTORY FULL', 0,
            0AH, 'NOT ON SAME DISK', 0,
            0BH, 'FILE ALREADY EXISTS', 0,
            0CH, 'FILE IS ALREADY OPEN', 0,
            0DH, 'NO SUCH FILE', 0,
            0EH, 'WRITE PROTECTED', 0,
            0FH, 'LOAD TOO LOW', 0,
            10H, 'BAD LOAD FORMAT', 0,
            11H, 'NOT A DISK FILE', 0,
            12H, 'ILLEGAL ISIS COMMAND', 0,
            13H, 'ATTEMPTED SEEK ON NON-DISK FILE', 0,
            14H, 'ATTEMPTED BACK SEEK TO FAR', 0,
            16H, 'ILLEGAL ACCESS MODE TO OPEN', 0,
            17H, 'MISSING FILENAME', 0,
            19H, 'ILLEGAL ECHO FILE', 0,
            1AH, 'ILLEGAL ATTRIBUTE IDENTIFIER', 0,
            1BH, 'ILLEGAL SEEK COMMAND', 0,
            1CH, 'MISSING EXTENSION', 0,
            1FH, 'CAN', 27H, 'T SEEK ON WRITE ONLY FILE', 0,
            20H, 'CAN', 27H, 'T DELETE OPEN FILE', 0,
            23H, 'SEEK PAST EOF', 0,
            0C9H, 'UNRECOGNIZED SWITCH', 0,
            0CAH, 'UNRECOGNIZED DELIMITER', 0,
            0CBH, 'INVALID SYNTAX', 0,
            0CCH, 'PREMATURE EOF', 0,
            0CEH, 'ILLEGAL DISKETTE LABEL', 0,
            0D0H, 'CHECKSUM ERROR', 0
        );



        IF ERRNUM <> 0 THEN
        DO;
            I = 0;
            DO WHILE I < LENGTH(ERRMSG);
                IF ERRNUM = ERRMSG(I) AND ERRMSG(I + 1) <> 0 THEN
                DO;
                    I = I + 1;
                    CALL WRITE(0, .(' '), 1, .STATUS);
                    DO WHILE ERRMSG(I) <> 0;
                        CALL WRITE(0, .ERRMSG(I), 1, .STATUS);
                        I = I + 1;
                    END;
                    CALL WRITE(0, .(0DH, 0AH), 2, .STATUS);
                    return;
                END;
                ELSE
                DO;
                    DO WHILE ERRMSG(I) <> 0;
                        I = I + 1;
                    END;
                    I = I + 1;
                END;
            end;
            CALL ERROR(ERRNUM);
        END;
    END;

    CHECKERROR: PROCEDURE(ERRCODE);
        DECLARE ERRCODE ADDRESS;
        IF ERRCODE <> 0 THEN DO;
            CALL REPORTERROR(ERRCODE);
            CALL EXIT;
        END;
    END;

    DECLARE FULLNAME(15) BYTE;
    DECLARE DEVICENAMES(21) ADDRESS INITIAL (
        'F0','F1','TI','TO','VI','VO','I1','O1','TR','HR',
        'R1','R2','TP','HP','P1','P2','LP','L1','CI','CO','BB');
    DECLARE (PN, PN2) (10) BYTE;

    CANON: PROCEDURE(FILENAME, INTFN$P) BYTE;
        DECLARE (FILENAME, INTFN$P) ADDRESS;
        DECLARE PATHCH BASED FILENAME BYTE; /* CHAR OF FILENAME POINTS TO */
        DECLARE PATHCHARS BASED FILENAME (1) BYTE;
        DECLARE INTFN BASED INTFN$P (10) BYTE;  /* BYTE VERSION OF INTFN  */
        DECLARE STARTNAME ADDRESS, STARTCH BASED STARTNAME BYTE;
        DECLARE DEVPAIR(0) ADDRESS, (SECOND, FIRST) BYTE;
        DECLARE (PAD, J, I) BYTE;


        ALPHANUM: PROCEDURE BOOLEAN;
            RETURN (PATHCH >= 'A' AND PATHCH <= 'Z')
                OR (PATHCH >= '0' AND PATHCH <= '9');
        END;


        DO I = 0 TO LAST(INTFN);    /* CLEAR INTFN */
            INTFN(I) = 0;
        END;
        DO WHILE PATHCH = ' ';  /* SKIP LEADING SPACE */
            FILENAME = FILENAME + 1;
        END;
        STARTNAME = FILENAME;
        IF PATHCH = ':' THEN
        DO;
            INTFN(0) = 0FFH;
            FIRST = PATHCHARS(1);
            SECOND = PATHCHARS(2);
            IF PATHCHARS(3) <> ':' THEN
                RETURN BAD$PATH;

            DO I =  0 TO LAST(DEVICENAMES);
                IF DEVICENAMES(I) = DEVPAIR(0) THEN 
                    INTFN(0) = I;   /* SAVE DEVICE NUMBER */
            END;
            IF INTFN(0) = 0FFH THEN
                RETURN BAD$DEVICE;
            FILENAME = FILENAME + 4;
        END;

        FIRST = 0;
        DO I = 1 TO 6;
            IF ALPHANUM THEN
            DO;
                INTFN(I) = PATHCH;
                FIRST = 1;
                FILENAME = FILENAME + 1;
            END;
        END;
        IF PATHCH = '.' THEN
        DO;
            FILENAME = FILENAME + 1;
            DO I = 7 TO 9;
                IF ALPHANUM THEN
                DO;
                    INTFN(I) = PATHCH;
                    FILENAME = FILENAME + 1;
                END;
            END;
        END;
        IF INTFN(0) <= F1DEV AND FIRST = 0 THEN
            RETURN NULL$FILENAME;
        J =  -1;
        DO WHILE STARTNAME < FILENAME;
            J = J + 1;
            FULLNAME(J) = STARTCH;
            STARTNAME = STARTNAME + 1;
        END;
        IF FULLNAME(J) = '.' THEN
            RETURN NULL$EXTENSION;
        FULLNAME(J + 1) = ' ';
        IF ALPHANUM  OR PATHCH = '.' OR PATHCH = ':' THEN
            RETURN BAD$PATH;
        RETURN OK;
    END;

    DECLARE MODE BYTE INITIAL(WRITEMODE);
    DECLARE MEMSIZE ADDRESS;
    DECLARE BUFFER(128) BYTE;
    DECLARE (SWITCHPTR, FILEPTR, BUFPTR, ACTUAL, STATUS) ADDRESS;
    DECLARE SWITCH BASED SWITCHPTR (1) BYTE;
    DECLARE (AFTOUT, AFTIN) ADDRESS;


    FILE$ERROR: PROCEDURE(STATUS, PTR, CALLEXIT);
        DECLARE (STATUS, PTR) ADDRESS, CALLEXIT BYTE;
        DECLARE ERR$STATUS ADDRESS;

        IF STATUS <> 0 THEN
        DO;
            PTR = DEBLANK(PTR);
            CALL WRITE(0, .(' '), 1, .ERR$STATUS);
            CALL WRITE(0, PTR, DELIMIT(PTR) - PTR, .ERR$STATUS);
            CALL WRITE(0, .(','), 1, .ERR$STATUS);
            CALL REPORTERROR(STATUS);
            IF CALLEXIT THEN
                CALL EXIT;
        END;
    END;





MAIN:
    CALL READ(1, .BUFFER, 128, .ACTUAL, .STATUS);
    CALL CHECKERROR(STATUS);
    BUFPTR = DEBLANK(DELIMIT(DEBLANK(.BUFFER)));
    DO WHILE SEQ(BUFPTR, .(','), 1);
        BUFPTR = DEBLANK(DELIMIT(DEBLANK(BUFPTR + 1)));
    END;
    IF NOT SEQ(.('TO '), BUFPTR, 3) THEN
        CALL CHECKERROR(BAD$SYNTAX);
    ELSE
        FILEPTR = DEBLANK(DELIMIT(BUFPTR));

    SWITCHPTR = DEBLANK(DELIMIT(FILEPTR));
    DO WHILE SWITCH(0) <> CR;
        IF SWITCH(0) = '$' THEN DO;
            IF SWITCH(1) = 'U' THEN
                MODE = UPDATEMODE;
            ELSE DO;
                CALL REPORTERROR(BAD$SWITCH);
                CALL EXIT;
            END;
            SWITCHPTR = DEBLANK(SWITCHPTR + 2);
        END;
        ELSE DO;
            CALL REPORTERROR(BAD$SWITCH);
            CALL EXIT;
        END;
    END; 
    
    if (STATUS := CANON(FILEPTR, .PN)) <> 0 THEN 
        CALL FILEERROR(STATUS, FILEPTR, TRUE);
    IF PN(0) = 0 OR PN(0) = 1 THEN DO;
        CALL RENAME(FILEPTR, FILEPTR, .STATUS);
        IF STATUS <> NO$SUCH$FILE THEN
            IF STATUS <> FILE$EXISTS THEN
                CALL CHECKERROR(STATUS);
            ELSE IF MODE <> UPDATEMODE THEN DO;
                CALL FILEERROR(STATUS, FILEPTR, FALSE);
                /* NOTE ORIGINAL USES ACTUAL VS. STATUS */
                CALL WRITE(0, .(' DELETE', 3FH, ' '), 9, .ACTUAL);
                CALL READ(1, .MEMORY, 128, .ACTUAL, .STATUS);
                CALL CHECKERROR(STATUS);
                IF (MEMORY(0) = 'Y' OR MEMORY = 'Y' + 20H) THEN
                    ;
                ELSE
                    CALL EXIT;
            END;
    END;
    CALL OPEN(.AFTOUT, FILEPTR, MODE, 0, .STATUS);
    CALL FILEERROR(STATUS, FILEPTR, TRUE);
    MEMSIZE = (MEMCHK - .MEMORY) AND 0FFF8H;
    IF PN(0) > 1 THEN
        MEMSIZE = 256;      /* NONE FILE DEVICE */
    FILEPTR = DEBLANK(.BUFFER);
    DO WHILE BUFPTR >= FILEPTR;  /* TILL WE HAVE PROCESSED ALL SOURCE */
        CALL OPEN(.AFTIN, FILEPTR, READMODE, 0, .STATUS);
        CALL FILEERROR(STATUS, FILEPTR, TRUE);
        ACTUAL = 1;
        DO WHILE ACTUAL <> 0;
            CALL READ(AFTIN, .MEMORY, MEMSIZE, .ACTUAL, .STATUS);
            CALL WRITE(AFTOUT, .MEMORY, ACTUAL, .STATUS);
        END;
        CALL CLOSE(AFTIN, .STATUS);
        FILEPTR = DEBLANK(DEBLANK(DELIMIT(FILEPTR)) + 1);
    END;
    CALL CLOSE(AFTOUT, .STATUS);
    CALL EXIT;

END;
EOF
delete.plm
3400H:
DO;
    DECLARE TRUE    LITERALLY '0FFH',
            FALSE   LITERALLY '0',
            CR      LITERALLY '0DH',
            LF      LITERALLY '0AH';

    DECLARE VER DATA(1, 9);
    DECLARE COPYRIGNT DATA('(C) 1975,1976 INTEL CORP');

    ISIS: PROCEDURE(CMD, PARAM$P);
        DECLARE CMD BYTE, PARAM$P ADDRESS;
        GOTO 40H;
    END ISIS;

    READ: PROCEDURE(CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P) ADDRESS;

        CALL ISIS(3, .CONN);
    END;

    WRITE: PROCEDURE(CONN, BUFF$P, COUNT, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, STATUS$P) ADDRESS;

        CALL ISIS(4, .CONN);
    END;

    DELETE: PROCEDURE (PATH$P, STATUS$P);
        DECLARE (PATH$P, STATUS$P) ADDRESS;

        CALL ISIS(2, .PATH$P);
    END DELETE;

    ERROR: PROCEDURE(ERROR$NUM);
        DECLARE (ERROR$NUM, STATUS) ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(12, .ERROR$NUM);
    END;

    EXIT: PROCEDURE;
        DECLARE STATUS ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(9, .STATUS);
    END;

    DEBLANK: PROCEDURE(PTR) ADDRESS;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE (C = ' ');
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;

    DELIMIT: PROCEDURE(PTR) ADDRESS;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE (C = ':' OR C = '.' OR
                 ('0' <= C AND C <= '9') OR
                 ('A' <= C AND C <= 'Z'));
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;

    NUMOUT: PROCEDURE(VALUE, BASE, LC, BUFADR, WIDTH);
        DECLARE (VALUE, BUFADR) ADDRESS, (BASE, LC, WIDTH) BYTE; 
        DECLARE DIGITS DATA('0123456789ABCDEF');
        DECLARE I BYTE;
        DECLARE BUF BASED BUFADR (1) BYTE;

        DO I = 1 TO WIDTH;
            BUF(WIDTH - I) = DIGITS(VALUE MOD BASE);
            VALUE = VALUE / BASE;   
        END;

        I = 0;
        DO WHILE BUF(I) = '0' AND I < WIDTH - 1;
            BUF(I) = LC;
            I = I + 1;
        END;
    END;

    REPORTERROR: PROCEDURE(ERRNUM);
        DECLARE ERRNUM ADDRESS;
        DECLARE NUMBERBUFFER(4) BYTE, I ADDRESS, STATUS ADDRESS;
     

        DECLARE ERRMSG DATA(0, 0,
            2, 'ILLEGAL AFTN ARGUMENT', 0,
            4, 'INCORRECTLY SPECIFIED FILE', 0,
            5, 'UNRECOGNIZED DEVICE NAME', 0,
            6, 'ATTEMPT TO WRITE TO INPUT DEVICE', 0,
            8, 'ATTEMPT TO READ FROM OUTPUT DEVICE', 0,
            9, 'DIRECTORY FULL', 0,
            0AH, 'NOT ON SAME DISK', 0,
            0BH, 'FILE ALREADY EXISTS', 0,
            0CH, 'FILE IS ALREADY OPEN', 0,
            0DH, 'NO SUCH FILE', 0,
            0EH, 'WRITE PROTECTED', 0,
            0FH, 'LOAD TOO LOW', 0,
            10H, 'BAD LOAD FORMAT', 0,
            11H, 'NOT A DISK FILE', 0,
            12H, 'ILLEGAL ISIS COMMAND', 0,
            13H, 'ATTEMPTED SEEK ON NON-DISK FILE', 0,
            14H, 'ATTEMPTED BACK SEEK TO FAR', 0,
            16H, 'ILLEGAL ACCESS MODE TO OPEN', 0,
            17H, 'MISSING FILENAME', 0,
            19H, 'ILLEGAL ECHO FILE', 0,
            1AH, 'ILLEGAL ATTRIBUTE IDENTIFIER', 0,
            1BH, 'ILLEGAL SEEK COMMAND', 0,
            1CH, 'MISSING EXTENSION', 0,
            1FH, 'CAN', 27H, 'T SEEK ON WRITE ONLY FILE', 0,
            20H, 'CAN', 27H, 'T DELETE OPEN FILE', 0,
            23H, 'SEEK PAST EOF', 0,
            0C9H, 'UNRECOGNIZED SWITCH', 0,
            0CAH, 'UNRECOGNIZED DELIMITER', 0,
            0CBH, 'INVALID SYNTAX', 0,
            0CCH, 'PREMATURE EOF', 0,
            0CEH, 'ILLEGAL DISKETTE LABEL', 0,
            0D0H, 'CHECKSUM ERROR', 0
        );



        IF ERRNUM <> 0 THEN
        DO;
            I = 0;
            DO WHILE I < LENGTH(ERRMSG);
                IF ERRNUM = ERRMSG(I) AND ERRMSG(I + 1) <> 0 THEN
                DO;
                    I = I + 1;
                    CALL WRITE(0, .(' '), 1, .STATUS);
                    DO WHILE ERRMSG(I) <> 0;
                        CALL WRITE(0, .ERRMSG(I), 1, .STATUS);
                        I = I + 1;
                    END;
                    CALL WRITE(0, .(0DH, 0AH), 2, .STATUS);
                    return;
                END;
                ELSE
                DO;
                    DO WHILE ERRMSG(I) <> 0;
                        I = I + 1;
                    END;
                    I = I + 1;
                END;
            end;
            CALL ERROR(ERRNUM);
        END;
    END;

    DECLARE (STATUS, ACTUAL) ADDRESS;
    DECLARE BUFFER(128) BYTE;
    DECLARE BUFPTR ADDRESS, CH BASED BUFPTR BYTE;

MAIN:
    CALL READ(1, .BUFFER, 128, .ACTUAL, .STATUS);
    IF STATUS <> 0 THEN DO;
        CALL REPORTERROR(STATUS);
        CALL EXIT;
    END;

    BUFPTR = DEBLANK(.BUFFER);

    DO WHILE 1;
        ACTUAL = DELIMIT(BUFPTR) - BUFPTR;
        CALL WRITE(0, .(' '), 1, .STATUS);
        CALL WRITE(0, BUFPTR, ACTUAL, .STATUS);
        CALL WRITE(0, .(', '), 2, .STATUS);
        CALL DELETE(BUFPTR, .STATUS);
        IF STATUS <> 0 THEN
            CALL REPORTERROR(STATUS);
        ELSE
            CALL WRITE(0, .('DELETED', CR, LF), 9, .STATUS);
        BUFPTR = DEBLANK(DELIMIT(BUFPTR));
        IF CH = CR THEN
            CALL EXIT;
        IF CH = ',' THEN
            BUFPTR = DEBLANK(BUFPTR + 1);
        ELSE DO;
            CALL REPORTERROR(0CBH);
            CALL EXIT;
        END;
    END;
END;
EOF
dir.plm
3400H:
DO;
    DECLARE TRUE    LITERALLY '0FFH',
            FALSE   LITERALLY '0',
            CR      LITERALLY '0DH',
            LF      LITERALLY '0AH';

    DECLARE VER DATA(1, 9);
    DECLARE COPYRIGNT DATA('(C) 1975,1976 INTEL CORP');

    ISIS: PROCEDURE(CMD, PARAM$P);
        DECLARE CMD BYTE, PARAM$P ADDRESS;
        GOTO 40H;
    END ISIS;

    OPEN: PROCEDURE(CONN$P, PATH$P, ACCESS, ECHO, STATUS$P);
        DECLARE (CONN$P, PATH$P, ACCESS, ECHO, STATUS$P) ADDRESS;

        CALL ISIS(0, .CONN$P);
    END;

    READ: PROCEDURE(CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P) ADDRESS;

        CALL ISIS(3, .CONN);
    END;

    WRITE: PROCEDURE(CONN, BUFF$P, COUNT, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, STATUS$P) ADDRESS;

        CALL ISIS(4, .CONN);
    END;

    CLOSE: PROCEDURE(CONN, STATUS$P);
        DECLARE (CONN, STATUS$P) ADDRESS;

        CALL ISIS(1, .CONN);
    END;

    ERROR: PROCEDURE(ERROR$NUM);
        DECLARE (ERROR$NUM, STATUS) ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(12, .ERROR$NUM);
    END;

    EXIT: PROCEDURE;
        DECLARE STATUS ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(9, .STATUS);
    END;

    DEBLANK: PROCEDURE(PTR) ADDRESS;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE (C = ' ');
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;

    DELIMIT: PROCEDURE(PTR) ADDRESS;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE (C = ':' OR C = '.' OR
                 ('0' <= C AND C <= '9') OR
                 ('A' <= C AND C <= 'Z'));
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;

    NUMOUT: PROCEDURE(VALUE, BASE, LC, BUFADR, WIDTH);
        DECLARE (VALUE, BUFADR) ADDRESS, (BASE, LC, WIDTH) BYTE; 
        DECLARE DIGITS DATA('0123456789ABCDEF');
        DECLARE I BYTE;
        DECLARE BUF BASED BUFADR (1) BYTE;

        DO I = 1 TO WIDTH;
            BUF(WIDTH - I) = DIGITS(VALUE MOD BASE);
            VALUE = VALUE / BASE;   
        END;

        I = 0;
        DO WHILE BUF(I) = '0' AND I < WIDTH - 1;
            BUF(I) = LC;
            I = I + 1;
        END;
    END;

    REPORTERROR: PROCEDURE(ERRNUM);
        DECLARE ERRNUM ADDRESS;
        DECLARE NUMBERBUFFER(4) BYTE, I ADDRESS, STATUS ADDRESS;
     

        DECLARE ERRMSG DATA(0, 0,
            2, 'ILLEGAL AFTN ARGUMENT', 0,
            4, 'INCORRECTLY SPECIFIED FILE', 0,
            5, 'UNRECOGNIZED DEVICE NAME', 0,
            6, 'ATTEMPT TO WRITE TO INPUT DEVICE', 0,
            8, 'ATTEMPT TO READ FROM OUTPUT DEVICE', 0,
            9, 'DIRECTORY FULL', 0,
            0AH, 'NOT ON SAME DISK', 0,
            0BH, 'FILE ALREADY EXISTS', 0,
            0CH, 'FILE IS ALREADY OPEN', 0,
            0DH, 'NO SUCH FILE', 0,
            0EH, 'WRITE PROTECTED', 0,
            0FH, 'LOAD TOO LOW', 0,
            10H, 'BAD LOAD FORMAT', 0,
            11H, 'NOT A DISK FILE', 0,
            12H, 'ILLEGAL ISIS COMMAND', 0,
            13H, 'ATTEMPTED SEEK ON NON-DISK FILE', 0,
            14H, 'ATTEMPTED BACK SEEK TO FAR', 0,
            16H, 'ILLEGAL ACCESS MODE TO OPEN', 0,
            17H, 'MISSING FILENAME', 0,
            19H, 'ILLEGAL ECHO FILE', 0,
            1AH, 'ILLEGAL ATTRIBUTE IDENTIFIER', 0,
            1BH, 'ILLEGAL SEEK COMMAND', 0,
            1CH, 'MISSING EXTENSION', 0,
            1FH, 'CAN', 27H, 'T SEEK ON WRITE ONLY FILE', 0,
            20H, 'CAN', 27H, 'T DELETE OPEN FILE', 0,
            23H, 'SEEK PAST EOF', 0,
            0C9H, 'UNRECOGNIZED SWITCH', 0,
            0CAH, 'UNRECOGNIZED DELIMITER', 0,
            0CBH, 'INVALID SYNTAX', 0,
            0CCH, 'PREMATURE EOF', 0,
            0CEH, 'ILLEGAL DISKETTE LABEL', 0,
            0D0H, 'CHECKSUM ERROR', 0
        );



        IF ERRNUM <> 0 THEN
        DO;
            I = 0;
            DO WHILE I < LENGTH(ERRMSG);
                IF ERRNUM = ERRMSG(I) AND ERRMSG(I + 1) <> 0 THEN
                DO;
                    I = I + 1;
                    CALL WRITE(0, .(' '), 1, .STATUS);
                    DO WHILE ERRMSG(I) <> 0;
                        CALL WRITE(0, .ERRMSG(I), 1, .STATUS);
                        I = I + 1;
                    END;
                    CALL WRITE(0, .(0DH, 0AH), 2, .STATUS);
                    return;
                END;
                ELSE
                DO;
                    DO WHILE ERRMSG(I) <> 0;
                        I = I + 1;
                    END;
                    I = I + 1;
                END;
            end;
            CALL ERROR(ERRNUM);
        END;
    END;

    UNPATH: PROCEDURE(DIR$P, FILENAME$P);
        DECLARE (DIR$P, FILENAME$p) ADDRESS;
        DECLARE FILENAME BASED FILENAME$P (1) BYTE;
        DECLARE DIR BASED DIR$P (1) BYTE;
        DECLARE I BYTE;

        FILENAME(0) = ':';
        FILENAME(1) = 'F';
        FILENAME(3) = ':';
        IF DIR(0) = 0 THEN
            FILENAME(2) = '0';
        ELSE
            FILENAME(2) = '1';
        FILENAME$P = FILENAME$P + 4;
        DO I = 0 TO 5;
            if (FILENAME(0) := DIR(I + 1)) <> 0 THEN
                FILENAME$P = FILENAME$P + 1;
        END;
        IF DIR(7) <> 0 THEN DO;
            FILENAME(0) = '.';
            FILENAME$P = FILENAME$P + 1;
        END; 
        DO I = 0 TO 2;
            if (FILENAME(0) := DIR(I + 7)) <> 0 THEN
                FILENAME$P = FILENAME$P + 1;
        END;
        FILENAME(0) = ' ';
    END; 


    /* READ IN DIRECTORY ENTRY */
    DECLARE DIRECT$STATUS BYTE,
            DIRECT$NAME(6) BYTE,
            DIRECT$EXT(3) BYTE,
            DIRECT$ATTRIB BYTE,
            DIRECT$EOF$CNT BYTE,
            DIRECT$BLKCNT ADDRESS,
            DIRECT$HDRBLK ADDRESS;
    DECLARE PADDING(2) BYTE;
    

    LISTDIR: PROCEDURE(DRIVE, AFTOUT, FASTOUTPUT, LISTINVISIBLE);
        DECLARE (DRIVE, AFTOUT, FASTOUTPUT, LISTINVISIBLE) BYTE;
        DECLARE (AFT, STATUS, ACTUAL, PAD, USED) ADDRESS;

        DECLARE (HIFSIZE, LOFSIZE, BLKTOTAL) ADDRESS;
        DECLARE BUF(15) BYTE;
        DECLARE ISISLAB(13) BYTE INITIAL(':F :ISIS.LAB ');
        DECLARE ISISDIR(13) BYTE INITIAL(':F :ISIS.DIR ');
        DECLARE CRLF(2) BYTE INITIAL(CR, LF);
        DECLARE NAME(15) BYTE, I BYTE, NAMEPART BYTE;

        ADDTOTAL: PROCEDURE(DELTA);
            DECLARE DELTA ADDRESS;
            IF (LOFSIZE := LOFSIZE + DELTA) > 9999 THEN DO;
                LOFSIZE = LOFSIZE - 10000;
                HIFSIZE = HIFSIZE + 1;
            END;
            
        END;

        BLKTOTAL = 0;
        ISISLAB(2), ISISDIR(2) = DRIVE + '0';
        CALL OPEN(.AFT, .ISISLAB, 1, 0, .STATUS);
        BUF(0) = DRIVE;
        CALL READ(AFT, .BUF + 1, 9, .ACTUAL, .STATUS);
        CALL WRITE(AFTOUT, .('DIRECTORY OF '), 13, .STATUS);
        CALL UNPATH(.BUF, .NAME);
        I = DELIMIT(.NAME) - .NAME;
        CALL WRITE(AFTOUT, .NAME, I, .STATUS);
        CALL WRITE(AFTOUT, .(CR, LF), 2, .STATUS);
        CALL CLOSE(AFT, .STATUS);

        IF NOT FASTOUTPUT THEN
            CALL WRITE(AFTOUT, .('NAME  .EXT BLKS   LENGTH ATTR', CR, LF),
                                                                    31, .STATUS);
     
        
        CALL OPEN(.AFT, .ISISDIR, 1, 0, .STATUS);
        ACTUAL = 16;
        DIRECT$STATUS = 10H;
       
        DO WHILE ACTUAL = 16 AND DIRECT$STATUS <> 7FH;
            CALL READ(AFT, .DIRECT$STATUS, 16, .ACTUAL, .STATUS);
            IF ACTUAL = 16 AND NOT DIRECT$STATUS  
              AND ((DIRECT$ATTRIB AND 1) = 0 OR LISTINVISIBLE) THEN DO;
                DO I = 0 TO 8;
                    IF DIRECT$NAME(I) = 0 THEN
                        DIRECT$NAME(I) = ' ';
                END;
                I = 9;
                IF FASTOUTPUT THEN
                    DO WHILE DIRECT$NAME(I - 1) = ' ';
                        I = I - 1;
                    END;
                IF NOT FASTOUTPUT OR I > 6 THEN
                    NAMEPART = 6;
                ELSE
                    NAMEPART = I; 
                CALL WRITE(AFTOUT, .DIRECT$NAME, NAMEPART, .STATUS);
                IF FASTOUTPUT THEN DO;
                    IF I > 6 THEN DO;
                        CALL WRITE(AFTOUT, .('.'), 1, .STATUS);
                        CALL WRITE(AFTOUT, .DIRECT$EXT, I - 6, .STATUS);
                    END;
                END;
                ELSE DO;
                    IF DIRECT$EXT(0) <> ' ' THEN
                        CALL WRITE(AFTOUT, .('.'), 1, .STATUS);
                    CALL WRITE(AFTOUT, .DIRECT$EXT, 3, .STATUS);
                    IF DIRECT$EXT(0) = ' ' THEN
                        CALL WRITE(AFTOUT, .(' '), 1, .STATUS);

                    USED = DIRECT$BLKCNT;
                    IF USED > 0 THEN
                        USED = USED + (USED + 61) / 62;
                    ELSE
                        USED = 1;
                    BLKTOTAL = BLKTOTAL + USED;
                    CALL NUMOUT(USED, 10, ' ', .BUF, 5);
                    CALL WRITE(AFTOUT, .BUF, 5, .STATUS);
                    
                    USED = DIRECT$BLKCNT;
                    LOFSIZE = 0;
                    HIFSIZE = 0;
                    IF USED > 0 THEN DO;
                        USED = USED - 1;
                        CALL ADDTOTAL(DIRECT$EOF$CNT);
                        DO WHILE USED > 0;
                            USED = USED - 1;
                            CALL ADDTOTAL(128);
                        END;
                    END;
                    IF HIFSIZE <> 0 THEN DO;
                        CALL NUMOUT(HIFSIZE, 10, ' ', .BUF, 5);
                        CALL NUMOUT(LOFSIZE, 10, '0', .BUF(5), 4);
                    END;
                    ELSE
                        CALL NUMOUT(LOFSIZE, 10, ' ', .BUF, 9);
                    CALL WRITE(AFTOUT, .BUF, 9, .STATUS);

                    IF DIRECT$ATTRIB <> 0 THEN DO;
                        DO I = 0 TO 4;
                            BUF(I) = ' ';
                        END;
                        IF (DIRECT$ATTRIB AND 4) <> 0 THEN
                            BUF(1) = 'W';
                        IF (DIRECT$ATTRIB AND 2) <> 0 THEN
                            BUF(2) = 'S';
                        IF (DIRECT$ATTRIB AND 1) <> 0 THEN
                            BUF(3) = 'I';
                        IF (DIRECT$ATTRIB AND 80H) <> 0 THEN
                            BUF(4) = 'F';
                        CALL WRITE(AFTOUT, .BUF, 5, .STATUS);
                    END; 
                END;
                CALL WRITE(AFTOUT, .CRLF, 2, .STATUS);
            END;
        END;
        IF NOT FASTOUTPUT THEN DO;
            CALL NUMOUT(BLKTOTAL, 10, ' ', .BUF, 15);
            CALL WRITE(AFTOUT, .BUF, 15, .STATUS);
            CALL WRITE(AFTOUT, .CRLF, 2, .STATUS);
        END;
        CALL CLOSE(AFTOUT, .STATUS);
    END;


    SEQ: PROCEDURE(S1, S2, CNT) BYTE;
        DECLARE (S1,S2) ADDRESS, CNT BYTE;
        DECLARE S1A BASED S1(1) BYTE;
        DECLARE S2A BASED S2(1) BYTE;
        DECLARE I BYTE;
        CNT = CNT - 1;
        DO I = 0 TO CNT;
            IF S1A(I) <> S2A(I) THEN
                RETURN 0;
        END;
        RETURN 0FFH;
    END;





    DECLARE (AFTOUT, ACTUAL, STATUS) ADDRESS;
    DECLARE PAD BYTE,
            DRIVE BYTE INITIAL(0),
            LISTINVISIBLE BYTE INITIAL(FALSE),
            FASTOUTPUT BYTE INITIAL(FALSE);
    DECLARE BUFPTR ADDRESS, CH BASED BUFPTR BYTE;
    DECLARE BUFFER(128) BYTE;

MAIN:
    CALL READ(1, .BUFFER, 128, .ACTUAL, .STATUS);
    BUFPTR = DEBLANK(.BUFFER);
    AFTOUT = 0;
    IF SEQ(.('TO'), BUFPTR, 2) THEN DO;
        BUFPTR = DEBLANK(BUFPTR + 2);
        CALL OPEN(.AFTOUT, BUFPTR, 2, 0, .STATUS);
        IF STATUS <> 0 THEN DO;
            CALL REPORTERROR(STATUS);
            CALL EXIT;
        END;
        BUFPTR = DEBLANK(DELIMIT(BUFPTR));
    END;
    DO WHILE CH = '$';
        BUFPTR = BUFPTR + 1;
        IF CH = '1' THEN
            DRIVE = 1;
        ELSE IF CH = 'I' THEN
            LISTINVISIBLE = TRUE;
        ELSE IF CH = 'F' THEN
            FASTOUTPUT = TRUE;
        ELSE DO;
            CALL REPORTERROR(0C9H);
            CALL EXIT;
        END;
        BUFPTR = DEBLANK(DELIMIT(BUFPTR));
    END;
    IF CH <> CR THEN DO;
        CALL REPORTERROR(0C9H);
        CALL EXIT;
    END;
    CALL LISTDIR(DRIVE, AFTOUT, FASTOUTPUT, LISTINVISIBLE);
    CALL EXIT; 
         

END;
EOF
edit.plm
3300H:

DECLARE LIT LITERALLY 'LITERALLY';
DECLARE BELL LIT '7',
        BS  LIT '8',
        TAB LIT '9',
        LF  LIT '0AH',
        VT  LIT '0BH',
        FF  LIT '0CH',
        CR  LIT '0DH',
        ESC LIT '1BH',
        DQUOTE LIT '22H',
        HASH LIT '23H';

DECLARE CTRLC   LIT '3',
        CTRLR   LIT '12h',
        CTRLX   LIT '18h',
        CTRLZ   LIT '1Ah',
        RUBOUT  LIT '7FH';

DECLARE ISALPHA LIT '0',
        ISNUMBER   LIT '1',
        ISOTHER lIT '2';

DECLARE TRUE    LIT '0FFH',
        FALSE   LIT '0',
        OK      LIT '0',
        BOOL    LIT 'BYTE';

/* ERROR CODES */
    DECLARE BAD$PATH LITERALLY '4',
            BAD$DEVICE LITERALLY '5',
            FILE$EXISTS LITERALLY '0BH',
            NO$SUCH$FILE LITERALLY '0DH',
            NULL$FILENAME LITERALLY '23',
            NULL$EXTENSION LITERALLY '28',
            BAD$SWITCH  LITERALLY '0C9H',
            BAD$SYNTAX  LITERALLY '0CBH';

    DECLARE BOOLEAN LITERALLY 'BYTE';
    DECLARE F1DEV LITERALLY '1';



DECLARE VERS DATA(2, 6),
        COPYRIGHT DATA('(C) 1973,1974,1975,1976 INTEL CORP');

DECLARE SIGNON DATA(CR, LF, 'ISIS TEXT EDITOR, V1.3', CR, LF);

DECLARE ILLEGAL DATA(DQUOTE, ' ILLEGAL IN THIS CONTEXT', CR, LF);
DECLARE NOTFOUND DATA(CR, LF, 'CANNOT FIND ');
DECLARE DQCHAR DATA(DQUOTE);    /* NOT ACTUALLY USED */
/* ONLY THE FIRST CHAR OF BEGIN PUNCH IS EVER USED */
DECLARE BEGINPUNCH DATA(CR, LF, CR, LF, 'START PUNCH, TYPE CHAR', CR, LF);
DECLARE ITERFAULT DATA(CR, LF, 'ITERATION STACK FAULT');

DECLARE USRBREAK DATA(CR, LF, '*BREAK*', CR, LF);
DECLARE NEWFILE DATA('NEW FILE', CR, LF);

DECLARE W4EBA ADDRESS,
        (TEXTPTR, ENDPTR) ADDRESS,
        (W4EC0, W4EC2) ADDRESS,
        (CMDCNT, W37D6, W4EC8) ADDRESS,
        MEMSIZE ADDRESS,
        (CHAR, CHTYPE, BACKWARDS, CURCOL) BYTE,
        (ITER$SP, B4ED1, B37E2) BYTE,
        FINDLEN BYTE;
DECLARE INBUF(128) BYTE,
        INACTUAL ADDRESS,
        INPTR ADDRESS,
        ACTUAL ADDRESS,
        STATUS ADDRESS,
        (AFTIN, AFTOUT) ADDRESS,
        PAD3870(3) BYTE,
        MODE BYTE,
        (INPUT$PTR, BUFFER$PTR, OUTPUT$PTR) ADDRESS,
        W4F6A ADDRESS,
        PAD37C BYTE,
        BUFFER(128) BYTE,
        BA4FED(16) BYTE,
        FINDBUF(17) BYTE,
        ITER$STACK$PTR(8) ADDRESS,
        ITER$STACK$CNT(8) ADDRESS;


DECLARE BREAK LABEL;

    CI: PROCEDURE BYTE;
        GOTO 0F803H;
    END;

    CO: PROCEDURE(C);
        DECLARE C BYTE;
        GOTO 0F809H;
    END;

	CSTS: PROCEDURE BYTE;
		GOTO 0F812H;
	END;

    IOCHK: PROCEDURE BYTE;
        GOTO 0F815H;
    END;

    MEMCHK: PROCEDURE ADDRESS;
        GOTO 0F81BH;
    END;

    ISIS: PROCEDURE(CMD, PARAM$P);
        DECLARE CMD BYTE, PARAM$P ADDRESS;
        GOTO 40H;
    END ISIS;

    READ: PROCEDURE(CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P) ADDRESS;

        CALL ISIS(3, .CONN);
    END;

    WRITE: PROCEDURE(CONN, BUFF$P, COUNT, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, STATUS$P) ADDRESS;

        CALL ISIS(4, .CONN);
    END;

    EXIT: PROCEDURE;
        DECLARE STATUS ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(9, .STATUS);
    END;

    OPEN: PROCEDURE(CONN$P, PATH$P, ACCESS, ECHO, STATUS$P);
        DECLARE (CONN$P, PATH$P, ACCESS, ECHO, STATUS$P) ADDRESS;

        CALL ISIS(0, .CONN$P);
    END;

    CLOSE: PROCEDURE(CONN, STATUS$P);
        DECLARE (CONN, STATUS$P) ADDRESS;

        CALL ISIS(1, .CONN);
    END;

    DELETE: PROCEDURE (PATH$P, STATUS$P);
        DECLARE (PATH$P, STATUS$P) ADDRESS;

        CALL ISIS(2, .PATH$P);
    END DELETE;

	RENAME: PROCEDURE(OLD$P, NEW$P, STATUS$P);
    	DECLARE (OLD$P, NEW$P, STATUS$P) ADDRESS;
    	
    	CALL ISIS(7, .OLD$P);
	END;

    ERROR: PROCEDURE(ERROR$NUM);
        DECLARE (ERROR$NUM, STATUS) ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(12, .ERROR$NUM);
    END;

    SEQ: PROCEDURE(S1, S2, CNT) BYTE;
        DECLARE (S1,S2) ADDRESS, CNT BYTE;
        DECLARE S1A BASED S1(1) BYTE;
        DECLARE S2A BASED S2(1) BYTE;
        DECLARE I BYTE;
        CNT = CNT - 1;
        DO I = 0 TO CNT;
            IF S1A(I) <> S2A(I) THEN
                RETURN 0;
        END;
        RETURN 0FFH;
    END;

    NUMOUT: PROCEDURE(VALUE, BASE, LC, BUFADR, WIDTH);
        DECLARE (VALUE, BUFADR) ADDRESS, (BASE, LC, WIDTH) BYTE; 
        DECLARE DIGITS DATA('0123456789ABCDEF');
        DECLARE I BYTE;
        DECLARE BUF BASED BUFADR (1) BYTE;

        DO I = 1 TO WIDTH;
            BUF(WIDTH - I) = DIGITS(VALUE MOD BASE);
            VALUE = VALUE / BASE;   
        END;

        I = 0;
        DO WHILE BUF(I) = '0' AND I < WIDTH - 1;
            BUF(I) = LC;
            I = I + 1;
        END;
    END;

    REPORTERROR: PROCEDURE(ERRNUM);
        DECLARE ERRNUM ADDRESS;
        DECLARE NUMBERBUFFER(4) BYTE, I ADDRESS, STATUS ADDRESS;
     

        DECLARE ERRMSG DATA(0, 0,
            2, 'ILLEGAL AFTN ARGUMENT', 0,
            4, 'INCORRECTLY SPECIFIED FILE', 0,
            5, 'UNRECOGNIZED DEVICE NAME', 0,
            6, 'ATTEMPT TO WRITE TO INPUT DEVICE', 0,
            8, 'ATTEMPT TO READ FROM OUTPUT DEVICE', 0,
            9, 'DIRECTORY FULL', 0,
            0AH, 'NOT ON SAME DISK', 0,
            0BH, 'FILE ALREADY EXISTS', 0,
            0CH, 'FILE IS ALREADY OPEN', 0,
            0DH, 'NO SUCH FILE', 0,
            0EH, 'WRITE PROTECTED', 0,
            0FH, 'LOAD TOO LOW', 0,
            10H, 'BAD LOAD FORMAT', 0,
            11H, 'NOT A DISK FILE', 0,
            12H, 'ILLEGAL ISIS COMMAND', 0,
            13H, 'ATTEMPTED SEEK ON NON-DISK FILE', 0,
            14H, 'ATTEMPTED BACK SEEK TO FAR', 0,
            16H, 'ILLEGAL ACCESS MODE TO OPEN', 0,
            17H, 'MISSING FILENAME', 0,
            19H, 'ILLEGAL ECHO FILE', 0,
            1AH, 'ILLEGAL ATTRIBUTE IDENTIFIER', 0,
            1BH, 'ILLEGAL SEEK COMMAND', 0,
            1CH, 'MISSING EXTENSION', 0,
            1FH, 'CAN', 27H, 'T SEEK ON WRITE ONLY FILE', 0,
            20H, 'CAN', 27H, 'T DELETE OPEN FILE', 0,
            23H, 'SEEK PAST EOF', 0,
            0C9H, 'UNRECOGNIZED SWITCH', 0,
            0CAH, 'UNRECOGNIZED DELIMITER', 0,
            0CBH, 'INVALID SYNTAX', 0,
            0CCH, 'PREMATURE EOF', 0,
            0CEH, 'ILLEGAL DISKETTE LABEL', 0,
            0D0H, 'CHECKSUM ERROR', 0
        );



        IF ERRNUM <> 0 THEN
        DO;
            I = 0;
            DO WHILE I < LENGTH(ERRMSG);
                IF ERRNUM = ERRMSG(I) AND ERRMSG(I + 1) <> 0 THEN
                DO;
                    I = I + 1;
                    CALL WRITE(0, .(' '), 1, .STATUS);
                    DO WHILE ERRMSG(I) <> 0;
                        CALL WRITE(0, .ERRMSG(I), 1, .STATUS);
                        I = I + 1;
                    END;
                    CALL WRITE(0, .(0DH, 0AH), 2, .STATUS);
                    return;
                END;
                ELSE
                DO;
                    DO WHILE ERRMSG(I) <> 0;
                        I = I + 1;
                    END;
                    I = I + 1;
                END;
            end;
            CALL ERROR(ERRNUM);
        END;
    END;

    DEBLANK: PROCEDURE(PTR) ADDRESS;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE (C = ' ');
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;

    DELIMIT: PROCEDURE(PTR) ADDRESS;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE (C = ':' OR C = '.' OR
                 ('0' <= C AND C <= '9') OR
                 ('A' <= C AND C <= 'Z'));
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;

    FILE$ERROR: PROCEDURE(STATUS, PTR, CALLEXIT);
        DECLARE (STATUS, PTR) ADDRESS, CALLEXIT BYTE;
        DECLARE ERR$STATUS ADDRESS;

        IF STATUS <> 0 THEN
        DO;
            PTR = DEBLANK(PTR);
            CALL WRITE(0, .(' '), 1, .ERR$STATUS);
            CALL WRITE(0, PTR, DELIMIT(PTR) - PTR, .ERR$STATUS);
            CALL WRITE(0, .(','), 1, .ERR$STATUS);
            CALL REPORTERROR(STATUS);
            IF CALLEXIT THEN
                CALL EXIT;
        END;
    END;

    DECLARE FULLNAME(15) BYTE;
    DECLARE DEVICENAMES(21) ADDRESS INITIAL (
        'F0','F1','TI','TO','VI','VO','I1','O1','TR','HR',
        'R1','R2','TP','HP','P1','P2','LP','L1','CI','CO','BB');
    DECLARE (PN, PN2) (10) BYTE;

    CANON: PROCEDURE(FILENAME, INTFN$P) BYTE;
        DECLARE (FILENAME, INTFN$P) ADDRESS;
        DECLARE PATHCH BASED FILENAME BYTE; /* CHAR OF FILENAME POINTS TO */
        DECLARE PATHCHARS BASED FILENAME (1) BYTE;
        DECLARE INTFN BASED INTFN$P (10) BYTE;  /* BYTE VERSION OF INTFN  */
        DECLARE STARTNAME ADDRESS, STARTCH BASED STARTNAME BYTE;
        DECLARE DEVPAIR(0) ADDRESS, (SECOND, FIRST) BYTE;
        DECLARE (J, I) BYTE;


        ALPHANUM: PROCEDURE BOOLEAN;
            RETURN (PATHCH >= 'A' AND PATHCH <= 'Z')
                OR (PATHCH >= '0' AND PATHCH <= '9');
        END;


        DO I = 0 TO LAST(INTFN);    /* CLEAR INTFN */
            INTFN(I) = 0;
        END;
        DO WHILE PATHCH = ' ';  /* SKIP LEADING SPACE */
            FILENAME = FILENAME + 1;
        END;
        STARTNAME = FILENAME;
        IF PATHCH = ':' THEN
        DO;
            INTFN(0) = 0FFH;
            FIRST = PATHCHARS(1);
            SECOND = PATHCHARS(2);
            IF PATHCHARS(3) <> ':' THEN
                RETURN BAD$PATH;

            DO I =  0 TO LAST(DEVICENAMES);
                IF DEVICENAMES(I) = DEVPAIR(0) THEN 
                    INTFN(0) = I;   /* SAVE DEVICE NUMBER */
            END;
            IF INTFN(0) = 0FFH THEN
                RETURN BAD$DEVICE;
            FILENAME = FILENAME + 4;
        END;

        FIRST = 0;
        DO I = 1 TO 6;
            IF ALPHANUM THEN
            DO;
                INTFN(I) = PATHCH;
                FIRST = 1;
                FILENAME = FILENAME + 1;
            END;
        END;
        IF PATHCH = '.' THEN
        DO;
            FILENAME = FILENAME + 1;
            DO I = 7 TO 9;
                IF ALPHANUM THEN
                DO;
                    INTFN(I) = PATHCH;
                    FILENAME = FILENAME + 1;
                END;
            END;
        END;
        IF INTFN(0) <= F1DEV AND FIRST = 0 THEN
            RETURN NULL$FILENAME;
        J =  -1;
        DO WHILE STARTNAME < FILENAME;
            J = J + 1;
            FULLNAME(J) = STARTCH;
            STARTNAME = STARTNAME + 1;
        END;
        IF FULLNAME(J) = '.' THEN
            RETURN NULL$EXTENSION;
        FULLNAME(J + 1) = ' ';
        IF ALPHANUM  OR PATHCH = '.' OR PATHCH = ':' THEN
            RETURN BAD$PATH;
        RETURN OK;
    END;

    UNPATH: PROCEDURE(DIR$P, FILENAME$P);
        DECLARE (DIR$P, FILENAME$p) ADDRESS;
        DECLARE FILENAME BASED FILENAME$P (1) BYTE;
        DECLARE DIR BASED DIR$P (1) BYTE;
        DECLARE I BYTE;

        FILENAME(0) = ':';
        FILENAME(1) = 'F';
        FILENAME(3) = ':';
        IF DIR(0) = 0 THEN
            FILENAME(2) = '0';
        ELSE
            FILENAME(2) = '1';
        FILENAME$P = FILENAME$P + 4;
        DO I = 0 TO 5;
            if (FILENAME(0) := DIR(I + 1)) <> 0 THEN
                FILENAME$P = FILENAME$P + 1;
        END;
        IF DIR(7) <> 0 THEN DO;
            FILENAME(0) = '.';
            FILENAME$P = FILENAME$P + 1;
        END; 
        DO I = 0 TO 2;
            if (FILENAME(0) := DIR(I + 7)) <> 0 THEN
                FILENAME$P = FILENAME$P + 1;
        END;
        FILENAME(0) = ' ';
    END;


    GETCHAR: PROCEDURE BYTE;
        RETURN CI AND 7FH;
    END;

    DISPLAYCHAR: PROCEDURE(CH);
        DECLARE (CH, SPACES, I) BYTE;

        SPACES = CH = TAB AND (7 - (CURCOL AND 7));
        IF CH = TAB THEN
            CH = ' ';
        DO I = 0 TO SPACES;
            IF CH = CR THEN
                CURCOL = 0;
            IF CH = FF THEN
                CH = 21H;  /* EXCLAMATION MARK */
            IF CH = ESC OR CH = 07DH THEN
                CH = '$';
            IF CH >= ' ' THEN
                CURCOL = CURCOL + 1;
            CALL CO(CH);
        END;
    END;


    DISPLAYTEXT: PROCEDURE(STR$P,  LEN);
        DECLARE (STR$P, LEN, I) ADDRESS;
        DECLARE STR BASED STR$P (1) BYTE;

        DO I = 0 TO LEN;
            CALL DISPLAYCHAR(STR(I));
            IF CSTS AND (IOCHK AND 0FCH) <> 2 THEN
                IF GETCHAR = 3 THEN DO;
                    GOTO BREAK;
                END;
        END;
    END;
                
    GETC: PROCEDURE BYTE;
        IF INPTR >= INACTUAL THEN DO;
            CALL READ(AFTIN, .INBUF, 128, .INACTUAL, .STATUS);
            CALL FILEERROR(STATUS, INPUT$PTR, TRUE);
            IF INACTUAL < 128 THEN
                INBUF(INACTUAL) = CTRLZ;
            INPTR = 0;
        END;
        INPTR = INPTR + 1;
        RETURN INBUF(INPTR - 1) AND 7FH;
    END;

    MOVEUP: PROCEDURE;
        DECLARE DSTIDX ADDRESS;

        IF ITER$SP <> 0 THEN
            RETURN;
        DSTIDX = MEMSIZE - 1;

        DO WHILE W4EC8 >= W4EBA;
            MEMORY(DSTIDX) = MEMORY(W4EC8);
            DSTIDX = DSTIDX - 1;
            W4EC8 = W4EC8 - 1;
        END;
        W4EBA = DSTIDX + 1;
        W4EC8 = MEMSIZE - 1;
    END;

    /* GET TEXT INTO MEMORY UNTIL ESC ESC */
    /* NOTE TEXT IS COLLECTED BACKWARDS FROM TOP OF MEMORY */
    GETTEXT: PROCEDURE;
        DECLARE (INCH, PREVINCH) BYTE;
        DECLARE IDX ADDRESS;

        DO WHILE 1;
            B4ED1 = FALSE;
            W4EBA = MEMSIZE;
            W4EC8 = MEMSIZE - 1;
            PREVINCH = FALSE;
            ITER$SP = 0;
            CALL DISPLAYCHAR('*');
            INCH = GETCHAR;

            DO WHILE INCH <> CTRLC;    /* 3EDB */
                DO WHILE INCH = RUBOUT;
                    IF W4EBA <> MEMSIZE THEN DO;
                        IF (INCH := MEMORY(W4EBA)) = ESC THEN
                            INCH = '$';
                        CALL DISPLAYCHAR(INCH);
                        W4EBA = W4EBA + 1;
                        INCH = GETCHAR;
                        PREVINCH = 0;
                    END;
                    ELSE DO;
                        INCH = 3;
                        CALL DISPLAYCHAR(BELL);
                    END;
                END;
                IF INCH = CTRLX THEN DO;
                    CALL DISPLAYCHAR(HASH);
                    CALL DISPLAYTEXT(.BEGINPUNCH, 1);
                    DO WHILE W4EBA <> MEMSIZE AND MEMORY(W4EBA) <> LF;
                        W4EBA = W4EBA + 1;
                    END;
                    INCH = GETCHAR;
                END;
                ELSE IF INCH = CTRLR THEN DO;
                    CALL DISPLAYTEXT(.BEGINPUNCH, 1);
                    IDX = W4EBA;
                    DO WHILE IDX < MEMSIZE AND MEMORY(IDX) <> LF;
                        IDX = IDX + 1;
                    END;
                    DO WHILE IDX <> W4EBA;
                        CALL DISPLAYCHAR(MEMORY(IDX := IDX - 1));
                    END;
                    INCH = GETCHAR;
                END;
                ELSE IF ENDPTR >= W4EBA - 10 THEN DO;
                    INCH = GETCHAR;
                    CALL DISPLAYCHAR(BELL);
                END;
                ELSE DO;
                    IF INCH = CR THEN DO;
                        MEMORY(W4EBA := W4EBA - 1) = CR;
                        CALL DISPLAYCHAR(CR);
                        INCH = LF;
                    END;
                    IF INCH  <> 3 THEN DO;
                        IF INCH = 7DH THEN
                            INCH = ESC;
                        IF INCH = ESC THEN
                            CALL DISPLAYCHAR('$');
                        ELSE
                            CALL DISPLAYCHAR(INCH);
                        MEMORY(W4EBA := W4EBA - 1) = INCH;
                        IF INCH = ESC and PREVINCH = ESC THEN DO;
                            CALL DISPLAYTEXT(.BEGINPUNCH, 1);
                            RETURN;
                        END;
                        PREVINCH = INCH;
                        INCH = GETCHAR;                   
                    END;
                END; /* 2982 */
            END;
            CALL  DISPLAYTEXT(.BEGINPUNCH, 1);
        END;    /* WHILE 1 */
    END;

    GETCMDCH: PROCEDURE BYTE;
        DECLARE CH BYTE;

        IF W4EC8 < W4EBA THEN
            CALL GETTEXT;
        IF CSTS AND (IOCHK AND 0FCH) <> 2 THEN
            IF GETCHAR = 3 THEN
                CALL GETTEXT;
        CHTYPE = ISOTHER;
        CH = MEMORY(W4EC8); 
        IF CH >= 'A' AND CH <= 'Z' THEN
            CHTYPE = ISALPHA;
        IF (CH >= '0' AND CH <= '9') OR CH = '+' OR CH = '-' THEN
            CHTYPE = ISNUMBER;
        W4EC8 = W4EC8 - 1;
        RETURN CH;
     END;

    GETCMDNUM: PROCEDURE ADDRESS;
        DECLARE VAL ADDRESS;
        IF CHAR = '-' THEN DO;
            BACKWARDS = TRUE;
            CHAR = GETCMDCH;
        END;
        ELSE IF CHAR = '+' THEN
            CHAR = GETCMDCH;
        VAL =  0;
        DO WHILE CHTYPE = ISNUMBER;
            /* VAL = VAL * 10 + CHAR - '0' */
            VAL = SHL(SHL(VAL, 2) + VAL, 1) + CHAR - '0';
            CHAR = GETCMDCH;
        END;
        IF VAL = 0 AND BACKWARDS THEN
            RETURN 1;
        RETURN VAL;
    END;

    FINDREL: PROCEDURE ADDRESS;
        DECLARE START ADDRESS, (I, CH) BYTE;

        START = 0;
        DO WHILE MEMORY(TEXTPTR + START) <> 0FFH;
            I = 0;
            DO WHILE (CH := MEMORY(TEXTPTR + START + I)) = FINDBUF(I);
                IF FINDBUF(I + 1) = ESC THEN
                    RETURN START;
                I = I + 1;
            END;
            IF CH = 0FFH THEN
                RETURN 0FFFFH;
            START = START + 1;
        END;
        RETURN 0FFFFH;
    END;

    SEEKLINE: PROCEDURE ADDRESS;
        DECLARE STARTLINE ADDRESS, (JUNK, CH) BYTE;

        STARTLINE = TEXTPTR;
        IF CMDCNT = 0 OR BACKWARDS THEN DO;
            IF TEXTPTR = 1 THEN
                RETURN 1;
            IF TEXTPTR = ENDPTR  THEN
                STARTLINE = STARTLINE - 1;
            CMDCNT = CMDCNT + 1;
            DO WHILE CMDCNT <> 0 and TEXTPTR <> 1;
                IF (CH := MEMORY(STARTLINE)) = 0FFH THEN
                    RETURN STARTLINE + 1;
                IF CH = LF THEN
                    CMDCNT = CMDCNT - 1;
                STARTLINE = STARTLINE - 1;
            END;
            RETURN STARTLINE + 2;   /* AFTER THE MARKER */
        END;
        DO WHILE CMDCNT <> 0;
            IF (CH := MEMORY(STARTLINE)) = 0FFH THEN
                RETURN STARTLINE;
            IF CH = LF THEN
                CMDCNT = CMDCNT - 1;
            STARTLINE = STARTLINE + 1;
        END;
        RETURN STARTLINE;
    END;


    FINDLOC: PROCEDURE ADDRESS;
        DECLARE RELOFFSET ADDRESS;
 
        FINDLEN = 0;
        DO WHILE (FINDBUF(FINDLEN) := GETCMDCH) <> ESC;
            IF FINDLEN < 16 THEN
                FINDLEN = FINDLEN + 1;
        END;
        if (RELOFFSET := FINDREL) = 0FFFFH THEN DO;
            CALL DISPLAYTEXT(.NOTFOUND, 14);
            IF FINDLEN <> 0 THEN
                CALL DISPLAYTEXT(.FINDBUF, FINDLEN - 1);
            CALL CO(DQUOTE);
            CALL DISPLAYTEXT(.BEGINPUNCH, 1);
            GOTO BREAK;
        END;
        ELSE
            RETURN RELOFFSET + TEXTPTR;
    END;

    MOVEDOWN: PROCEDURE;
        ENDPTR = TEXTPTR;
        DO WHILE W4EC2 >= W4EC0;
            MEMORY(ENDPTR) = MEMORY(W4EC0);
            W4EC0 = W4EC0 + 1;
            ENDPTR = ENDPTR + 1;
        END;
        MEMORY(ENDPTR := ENDPTR - 1) = 0FFH;
        CALL MOVEUP;
    END;

MAIN:

    INPUT$PTR = .(':CI:');
    CALL READ(1, .BUFFER, 128, .ACTUAL, .STATUS);
    CALL FILEERROR(STATUS, INPUT$PTR, TRUE);
    BUFFER(ACTUAL) = CR;
    INPUT$PTR = DEBLANK(.BUFFER);
    BUFFER$PTR = DEBLANK(DELIMIT(INPUT$PTR));
    CALL DISPLAYTEXT(.SIGNON, 25);
    IF SEQ(BUFFER$PTR, .('TO'), 2) THEN DO;
        OUTPUT$PTR = DEBLANK(BUFFER$PTR + 2 );
        MODE = 2;
    END;
    ELSE DO;
        OUTPUT$PTR = INPUT$PTR;
        MODE = 1;
    END;

    STATUS = CANON(OUTPUT$PTR, .PN);
    IF STATUS <> 0 THEN
        CALL FILEERROR(STATUS, OUTPUT$PTR, TRUE);
    IF PN(0) > 1 THEN DO;
        IF MODE <> 2 THEN
            CALL FILEERROR(11H, OUTPUT$PTR, TRUE);
        BUFFER$PTR = OUTPUT$PTR;
    END;
    ELSE DO;
        IF PN(0) = 0 THEN
            BUFFER$PTR = .(':F0:EDIT.TMP ');
        IF PN(0) = 1 THEN
            BUFFER$PTR = .(':F1:EDIT.TMP ');
        IF MODE = 1 THEN DO;
            CALL RENAME(INPUT$PTR, INPUT$PTR, .STATUS);
            IF STATUS = 0BH THEN DO;
                PN(7) = 'B';
                PN(8) = 'A';
                PN(9) = 'K';
                CALL UNPATH(.PN, .BA4FED);
                W4F6A = .BA4FED;
            END;
            ELSE IF STATUS = 0DH THEN DO;
                MODE = 3;
                CALL DISPLAYTEXT(.NEWFILE, 9);
                INPUT$PTR = .(':BB: ');
            END;
            ELSE
                CALL FILEERROR(STATUS, INPUT$PTR, TRUE);
        END;
    END; /* 2F0E */

    CALL OPEN(.AFTIN, INPUT$PTR, 1, 0, .STATUS);
    CALL FILEERROR(STATUS, INPUT$PTR, TRUE);
    INPTR = INACTUAL;
    CALL OPEN(.AFTOUT, BUFFER$PTR, 2, 0, .STATUS);
    CALL FILEERROR(STATUS, BUFFER$PTR, TRUE);
    MEMSIZE = MEMCHK - .MEMORY;
    MEMORY(0) = 0FFH;
    MEMORY(1) = 0FFH;
    TEXTPTR = 1;
    ENDPTR = 1;
    CALL GETTEXT;

CMDLOOP:
    DO WHILE 1;
        W4EC0 = TEXTPTR;
        W4EC2 = ENDPTR;
        BACKWARDS = FALSE;
        CMDCNT = 1;
        CHAR = GETCMDCH;
        IF CHTYPE = ISNUMBER THEN
            CMDCNT = GETCMDNUM;
        IF CHAR = '<' THEN DO;
                IF (ITER$SP := ITER$SP + 1) > 8 THEN DO;
                    CALL DISPLAYTEXT(.ITERFAULT, 22);
                    GOTO BREAK;
                END;
                ITER$STACK$PTR(ITER$SP) = W4EC8;
                ITER$STACK$CNT(ITER$SP) = CMDCNT;
        END;
        ELSE IF CHAR = '>' AND ITER$SP <> 0 THEN DO;
            IF (ITER$STACK$CNT(ITER$SP) := ITER$STACK$CNT(ITER$SP) - 1) <> 0 THEN
                W4EC8 = ITER$STACK$PTR(ITER$SP);
            ELSE
                ITER$SP = ITER$SP - 1;
            GOTO CMDLOOP;
        END;
        ELSE IF CHTYPE = ISALPHA THEN DO;
            DO CASE CHAR - 'A';
                DO;             /* 'A' APPEND */
                    B37E2 = TRUE;
                    CMDCNT = 0;
                    DO WHILE B37E2;
                        if ENDPTR >= W4EBA - 10 OR B4ED1 THEN
                            B37E2 = 0;
                        ELSE IF (CHAR := GETC) <> CTRLZ THEN DO; 
                            IF CHAR <> 0 AND CHAR <> 7FH THEN DO;
                                IF CHAR = FF THEN
                                    B37E2 = 0;
                                MEMORY(ENDPTR) = CHAR;
                                ENDPTR = ENDPTR + 1;
                                IF CHAR = LF THEN
                                    IF (CMDCNT := CMDCNT + 1) = 50 THEN
                                        B37E2 = 0;
                            END;
                        END;
                        ELSE DO;
                            B4ED1 = 0FFH;
                            B37E2 = 0;
                        END;
                    END;
                    MEMORY(ENDPTR) = 0FFH;
                    GOTO CMDLOOP;
                END;
                DO;                 /* 'B' TEXT POINTER TO BEGINNING */
                    TEXTPTR = 1;
                    GOTO CMDLOOP;
                END;
                DO;                 /* 'C' TEXT POINTER CHARACTER */
                    IF BACKWARDS THEN DO;
                        IF TEXTPTR - 1 < CMDCNT THEN DO;
                            TEXTPTR = 1;
                            GOTO CMDLOOP;
                        END;
                        ELSE
                            TEXTPTR = TEXTPTR - CMDCNT;
                        GOTO CMDLOOP;
                    END;
                    ELSE IF (W37D6 := TEXTPTR + CMDCNT) > ENDPTR THEN
                        TEXTPTR = ENDPTR;
                    ELSE
                        TEXTPTR = W37D6;
                    GOTO CMDLOOP;
                END;
                DO;             /* 'D' DELETE */
                    IF BACKWARDS THEN DO;
                        IF TEXTPTR < CMDCNT THEN
                            TEXTPTR = 1;
                        ELSE
                            TEXTPTR = TEXTPTR - CMDCNT;
                    END;
                    ELSE IF (W37D6 := TEXTPTR + CMDCNT) > ENDPTR THEN
                        W4EC0 = ENDPTR;
                    ELSE
                        W4EC0 = W37D6;
                    CALL MOVEDOWN;
                    GOTO CMDLOOP;
                END;
                DO;         /* 'E' EXIT */
                    CALL WRITE(AFTOUT, .MEMORY + 1, ENDPTR - 1, .STATUS);
                    CALL FILEERROR(STATUS, BUFFER$PTR, TRUE);
                    DO WHILE INPTR < INACTUAL;
                        IF (CHAR := GETC) = CTRLZ THEN
                            INPTR = 128;
                        ELSE DO;
                            CALL WRITE(AFTOUT, .CHAR, 1, .STATUS);
                            CALL FILEERROR(STATUS, BUFFER$PTR, TRUE);
                        END;
                    END;

                    ACTUAL = MEMSIZE;
                    DO WHILE ACTUAL <> 0;
                        CALL READ(AFTIN, .MEMORY, MEMSIZE, .ACTUAL, .STATUS);
                        CALL FILEERROR(STATUS, INPUT$PTR, TRUE);
                        CALL WRITE(AFTOUT, .MEMORY, ACTUAL, .STATUS);
                        CALL FILEERROR(STATUS, BUFFER$PTR, TRUE);
                        IF ACTUAL < MEMSIZE THEN
                            ACTUAL = 0;
                    END;
                
                    CALL CLOSE(AFTOUT, .STATUS);
                    CALL FILEERROR(STATUS, BUFFER$PTR, TRUE);
                    CALL CLOSE(AFTIN, .STATUS);
                    CALL FILEERROR(STATUS, INPUT$PTR, TRUE);
                    IF PN(0) <= 1 THEN DO;  /* FILE BASED */
                        IF MODE = 1 THEN DO; 
                            CALL DELETE(W4F6A, .STATUS);
                            IF STATUS = 0EH THEN
                                CALL FILEERROR(STATUS, W4F6A, TRUE);
                            CALL RENAME(INPUT$PTR, W4F6A, .STATUS);
                            CALL FILEERROR(STATUS, INPUT$PTR, TRUE);
                        END;
                        CALL DELETE(OUTPUT$PTR, .STATUS);
                        IF STATUS = 0EH THEN
                            CALL FILEERROR(STATUS, OUTPUT$PTR, TRUE);
                        CALL RENAME(BUFFER$PTR, OUTPUT$PTR, .STATUS);
                        CALL FILEERROR(STATUS, OUTPUT$PTR, TRUE);
                    END;
                    CALL EXIT;
                    GOTO CMDLOOP;
                END;
                DO;             /* 'F' FIND */
                    TEXTPTR = FINDLOC + FINDLEN;
                    GOTO CMDLOOP;
                END;
                GOTO BADCMD; /* 'G' */
                GOTO BADCMD; /* 'H' */
    CASE$I:     DO;             /* 'I' INSERT */
                    DO WHILE (CHAR := GETCMDCH) <> ESC;
                        IF TEXTPTR = W4EC0 THEN DO; 
                            CALL MOVEUP;
                            IF W4EBA - 11 < W4EC2 THEN
                                GOTO BREAK;
                            W37D6 = W4EC2;
                            W4EC2, W4EC0 = W4EBA - 10;
                            DO WHILE W37D6 >= TEXTPTR;
                                MEMORY(W4EC0) = MEMORY(W37D6);
                                W37D6 = W37D6 - 1;
                                W4EC0 = W4EC0 - 1;
                            END;
                            W4EC0 = W4EC0 + 1;
                        END;
                        MEMORY(TEXTPTR) = CHAR;
                        TEXTPTR = TEXTPTR + 1; 
                    END; 
                    CALL MOVEDOWN;
                    GOTO CMDLOOP;
                END;
                GOTO BADCMD;            /* 'J' */
                DO;                     /* 'K' KILL */
                    IF (W4EC0 := SEEKLINE) < TEXTPTR THEN DO;
                        W37D6 = TEXTPTR;
                        TEXTPTR = W4EC0;
                        W4EC0 = W37D6;
                    END;
                    CALL MOVEDOWN;
                    GOTO CMDLOOP;
                END;
                DO;
                    TEXTPTR = SEEKLINE;      /* 'L' TEXT POINTER LINE*/
                    GOTO CMDLOOP;
                END;
                GOTO BADCMD;            /* 'M' */
                GOTO BADCMD;            /* 'N' */
                GOTO BADCMD;            /* 'O' */
                GOTO BADCMD;            /* 'P' */
                DO;                     /* 'Q' QUIT */
                    CALL CLOSE(AFTOUT, .STATUS);
                    CALL DELETE(BUFFER$PTR, .STATUS);
                    CALL EXIT;
                    GOTO CMDLOOP;
                END;
                GOTO BADCMD;            /* 'R' */
                DO;                     /* 'S' SUBSTITUTE */
                    W4EC0 = (TEXTPTR := FINDLOC) + FINDLEN;
                    GOTO CASE$I;
                END;
                DO;                     /* 'T' TYPE */
                    IF (W37D6 := SEEKLINE) = TEXTPTR THEN
                        GOTO CMDLOOP;
                    IF TEXTPTR < W37D6 THEN
                        CALL DISPLAYTEXT(.MEMORY + TEXTPTR, W37D6 - TEXTPTR - 1);
                    ELSE
                        CALL DISPLAYTEXT(.MEMORY + W37D6, TEXTPTR - W37D6 - 1);
                    GOTO CMDLOOP;
                END;
                GOTO BADCMD;            /* 'U' */
                GOTO BADCMD;            /* 'V' */
                DO;                     /* 'W' WRITE */
                    BACKWARDS = 0;
                    TEXTPTR = 1;
                    W4EC0 = SEEKLINE;
                    CALL WRITE(AFTOUT, .MEMORY + 1, W4EC0 - 1, .STATUS);
                    CALL FILEERROR(STATUS, BUFFER$PTR, TRUE);
                    CALL MOVEDOWN;
                    GOTO CMDLOOP;
                END;
                GOTO BADCMD;            /* 'X' */
                GOTO BADCMD;            /* 'Y' */
                DO;                     /* 'Z' TEXT POINTER END*/
                    TEXTPTR = ENDPTR;
                    GOTO CMDLOOP;
                END;
            END;    /* OF CASE */
        END;        /* OF IF */
        ELSE
BADCMD: IF CHAR > ' ' THEN DO;
            CALL DISPLAYTEXT(.BEGINPUNCH, 1);
            CALL CO(DQUOTE);
            CALL DISPLAYCHAR(CHAR);
            CALL DISPLAYTEXT(.ILLEGAL, 26);
            CALL GETTEXT;
        END;
    END; /* OF CMDLOOP */
BREAK:
    CALL DISPLAYTEXT(.USRBREAK, 10);
    CALL GETTEXT;
    GOTO CMDLOOP;
EOF
format.plm
3400H:
DO;
    DECLARE NSECTORS LITERALLY '26';
    DECLARE NTRACKS LITERALLY '77';
    DECLARE IOCW    LITERALLY '0',
            IOINS   LITERALLY '1',
            NSEC    LITERALLY '2',
            TADR    LITERALLY '3',
            SADR    LITERALLY '4',
            BUFLO   LITERALLY '5',
            BUFHI   LITERALLY '6';

    DECLARE TRUE    LITERALLY '0FFH',
            FALSE   LITERALLY '0',
            OK      LITERALLY '0',
            CR      LITERALLY '0DH',
            LF      LITERALLY '0AH';

    DECLARE DCMD$READ  LITERALLY '4',
            DCMD$WRITE LITERALLY '6';

    DECLARE INVISIBLE$A LITERALLY '1',
            SYSTEM$A    LITERALLY '2',
            WRITEP$A    LITERALLY '4',
            FORMAT$A    LITERALLY '80H';

    DECLARE READMODE    LITERALLY '1',
            WRITEMODE   LITERALLY '2',
            UPDATEMODE  LITERALLY '3';

    /* ERROR CODES */
    DECLARE NO$FREE$BUFFER LITERALLY '1',
            BAD$PATH LITERALLY '4',
            BAD$DEVICE LITERALLY '5',
            FILE$EXISTS LITERALLY '0BH',
            NO$SUCH$FILE LITERALLY '0DH',
            NULL$FILENAME LITERALLY '23',
            NULL$EXTENSION LITERALLY '28',
            BAD$SWITCH  LITERALLY '0C9H',
            BAD$SYNTAX  LITERALLY '0CBH';

    DECLARE BOOLEAN LITERALLY 'BYTE';
    DECLARE F1DEV LITERALLY '1';

    DECLARE WARNING LITERALLY '0';
    DECLARE MESSAGE LITERALLY '1';
    DECLARE ABORT LITERALLY '2';

    DECLARE VER DATA(1, 9);
    DECLARE COPYRIGNT DATA('(C) 1975,1976 INTEL CORP');
/*
	THE CODE BLOCK BELOW IS LOADED INTO ISIS.T0 ON NON SYSTEM DISKS TO PRINT A MESSAGE
	THE CORRESPONDING ASM CODE IS

		ASEG
		org 3000h

		IN	79H
		IN	7BH
	L3004:	IN	0FFH
		ANI	2
		JNZ	L3004
		LXI	H, MSG
		MVI	B, 32
	L3010:	MOV	C, M
		CALL	0F809H	; CO
		INX	H
		DCR	B
		JNZ	L3010
		RST	0
	MSG:	DB	0DH, 0AH
		DB	'NON-SYSTEM DISK, TRY ANOTHER'
		DB	0DH, 0AH
		END
*/
DECLARE CODEBLOCK DATA(0DBH, 79H, 0DBH, 7BH, 0DBH, 0FFH, 0E6H, 2,
			       0C2H, 4, 30H, 21H, 1AH, 30H, 6, 20H, 4EH,
			       0CDH, 9, 0F8H, 23H, 5, 0C2H, 10H, 30H, 0C7H,
			       CR, LF, 'NON-SYSTEM DISK, TRY ANOTHER', CR, LF);
DECLARE ATTRIBMAP DATA(INVISIBLE$A, SYSTEM$A, WRITEP$A);
DECLARE CRLF DATA(CR, LF);
DECLARE	ISIST0 DATA(':F1:ISIS.T0 '),
        ISISBIN DATA(':F1:ISIS.BIN '),
        ISISMAP DATA(':F1:ISIS.MAP '),
        ISISLAB DATA(':F1:ISIS.LAB '),
        ISISDIR DATA(':F1:ISIS.DIR ');

/* GLOBAL VARIABLES */
DECLARE BITMAP(256) BYTE,
        UNUSED(6) BYTE INITIAL(0FFH),
        MAPDCB(10) BYTE INITIAL(80H, 0, 2, 2, 2),    /* NOT USED */
        BITMASK(8) BYTE INITIAL(80H, 40H, 20H, 10H, 8, 4, 2, 1);
DECLARE DIRECT(10) BYTE,  DIRECTATTR BYTE, DIRECTOTHER(5) BYTE, PAD1(1) BYTE;
DECLARE FMTTABLE(77) BYTE INITIAL(
            1, 12,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,
            3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,
            3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,
            3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,
            3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3);
DECLARE BUFFER(128) BYTE;
DECLARE MEMSIZE ADDRESS;
DECLARE ACTUAL ADDRESS, PAD2 ADDRESS;
DECLARE (BUFFERPTR, II, JJ, NAMELEN) ADDRESS, PAD3 BYTE;
DECLARE (SYSTEM, COPYALL, COPY) BYTE;
DECLARE (AFTIN, AFTOUT, AFTDIR, STATUS) ADDRESS, PAD4 BYTE;
DECLARE SRCNAME(16) BYTE, DSTNAME(16) BYTE;



    MEMCK: PROCEDURE ADDRESS;
        GOTO 0F81BH;
    END;

    ISIS: PROCEDURE(CMD, PARAM$P);
        DECLARE CMD BYTE, PARAM$P ADDRESS;
        GOTO 40H;
    END ISIS;

    OPEN: PROCEDURE(CONN$P, PATH$P, ACCESS, ECHO, STATUS$P);
        DECLARE (CONN$P, PATH$P, ACCESS, ECHO, STATUS$P) ADDRESS;

        CALL ISIS(0, .CONN$P);
    END;

    READ: PROCEDURE(CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P) ADDRESS;

        CALL ISIS(3, .CONN);
    END;

    WRITE: PROCEDURE(CONN, BUFF$P, COUNT, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, STATUS$P) ADDRESS;

        CALL ISIS(4, .CONN);
    END;

    CLOSE: PROCEDURE(CONN, STATUS$P);
        DECLARE (CONN, STATUS$P) ADDRESS;

        CALL ISIS(1, .CONN);
    END;

    ERROR: PROCEDURE(ERROR$NUM);
        DECLARE (ERROR$NUM, STATUS) ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(12, .ERROR$NUM);
    END;

    EXIT: PROCEDURE;
        DECLARE STATUS ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(9, .STATUS);
    END;

    ATTRIB: PROCEDURE (PATH$P, ATTRIB, ON$OFF, STATUS$P);
        DECLARE (PATH$P, ATTRIB, ON$OFF, STATUS$P) ADDRESS;

        CALL ISIS(10, .PATH$P);
    END ATTRIB;

    DELETE: PROCEDURE (PATH$P, STATUS$P);
        DECLARE (PATH$P, STATUS$P) ADDRESS;

        CALL ISIS(2, .PATH$P);
    END DELETE;


    DISKIO: PROCEDURE(DRIVE, IOPB);
        DECLARE (DRIVE, IOPB) ADDRESS;
        DECLARE PARAMS(4) ADDRESS;

        PARAMS(0) = 'SK';
        PARAMS(1) = DRIVE;
        PARAMS(2) = IOPB;
        CALL ISIS('D', .PARAMS);
    END;

    

    /* NOT ACTUALLY USED */
    NUMOUT: PROCEDURE(VALUE, BASE, LC, BUFADR, WIDTH);
        DECLARE (VALUE, BUFADR) ADDRESS, (BASE, LC, WIDTH) BYTE; 
        DECLARE DIGITS DATA('0123456789ABCDEF');
        DECLARE I BYTE;
        DECLARE BUF BASED BUFADR (1) BYTE;

        DO I = 1 TO WIDTH;
            BUF(WIDTH - I) = DIGITS(VALUE MOD BASE);
            VALUE = VALUE / BASE;   
        END;

        I = 0;
        DO WHILE BUF(I) = '0' AND I < WIDTH - 1;
            BUF(I) = LC;
            I = I + 1;
        END;
    END;

    REPORTERROR: PROCEDURE(ERRNUM);
        DECLARE ERRNUM ADDRESS;
        DECLARE NUMBERBUFFER(4) BYTE, I ADDRESS, STATUS ADDRESS;
     

        DECLARE ERRMSG DATA(0, 0,
            2, 'ILLEGAL AFTN ARGUMENT', 0,
            4, 'INCORRECTLY SPECIFIED FILE', 0,
            5, 'UNRECOGNIZED DEVICE NAME', 0,
            6, 'ATTEMPT TO WRITE TO INPUT DEVICE', 0,
            8, 'ATTEMPT TO READ FROM OUTPUT DEVICE', 0,
            9, 'DIRECTORY FULL', 0,
            0AH, 'NOT ON SAME DISK', 0,
            0BH, 'FILE ALREADY EXISTS', 0,
            0CH, 'FILE IS ALREADY OPEN', 0,
            0DH, 'NO SUCH FILE', 0,
            0EH, 'WRITE PROTECTED', 0,
            0FH, 'LOAD TOO LOW', 0,
            10H, 'BAD LOAD FORMAT', 0,
            11H, 'NOT A DISK FILE', 0,
            12H, 'ILLEGAL ISIS COMMAND', 0,
            13H, 'ATTEMPTED SEEK ON NON-DISK FILE', 0,
            14H, 'ATTEMPTED BACK SEEK TO FAR', 0,
            16H, 'ILLEGAL ACCESS MODE TO OPEN', 0,
            17H, 'MISSING FILENAME', 0,
            19H, 'ILLEGAL ECHO FILE', 0,
            1AH, 'ILLEGAL ATTRIBUTE IDENTIFIER', 0,
            1BH, 'ILLEGAL SEEK COMMAND', 0,
            1CH, 'MISSING EXTENSION', 0,
            1FH, 'CAN', 27H, 'T SEEK ON WRITE ONLY FILE', 0,
            20H, 'CAN', 27H, 'T DELETE OPEN FILE', 0,
            23H, 'SEEK PAST EOF', 0,
            0C9H, 'UNRECOGNIZED SWITCH', 0,
            0CAH, 'UNRECOGNIZED DELIMITER', 0,
            0CBH, 'INVALID SYNTAX', 0,
            0CCH, 'PREMATURE EOF', 0,
            0CEH, 'ILLEGAL DISKETTE LABEL', 0,
            0D0H, 'CHECKSUM ERROR', 0
        );



        IF ERRNUM <> 0 THEN
        DO;
            I = 0;
            DO WHILE I < LENGTH(ERRMSG);
                IF ERRNUM = ERRMSG(I) AND ERRMSG(I + 1) <> 0 THEN
                DO;
                    I = I + 1;
                    CALL WRITE(0, .(' '), 1, .STATUS);
                    DO WHILE ERRMSG(I) <> 0;
                        CALL WRITE(0, .ERRMSG(I), 1, .STATUS);
                        I = I + 1;
                    END;
                    CALL WRITE(0, .(0DH, 0AH), 2, .STATUS);
                    return;
                END;
                ELSE
                DO;
                    DO WHILE ERRMSG(I) <> 0;
                        I = I + 1;
                    END;
                    I = I + 1;
                END;
            end;
            CALL ERROR(ERRNUM);
        END;
    END;



    CHECKERROR: PROCEDURE(SEVERITY, ERRCODE);
        DECLARE (SEVERITY, ERRCODE) BYTE;
        IF ERRCODE = 0 THEN
            RETURN;
        CALL REPORTERROR(ERRCODE);
        CALL EXIT;
    END;
    
    DECLARE BUFFER$TABLE(19) BYTE;   /* NOT USED */

    CLRBUF: PROCEDURE(PTR);
        DECLARE PTR ADDRESS, BUF BASED PTR (1) BYTE;
        DECLARE I BYTE;
        DO I = 0 TO 127;
            BUF(I) = 0;
        END;
    END;

    FREEBUF: PROCEDURE(BUFFER); /* NOT USED */
        DECLARE BUFFER ADDRESS;

        BUFFER$TABLE(SHR(BUFFER - .MEMORY, 7)) = 0;
    END;

    GETBUF: PROCEDURE ADDRESS;  /* NOT USED */
        DECLARE I BYTE;

        DO I = 0 TO LAST(BUFFER$TABLE);
            IF BUFFER$TABLE(I) = 0 THEN
            DO;
                BUFFER$TABLE(I) = 2;
                RETURN .MEMORY + SHL(DOUBLE(I), 7);
            END;
        END;
        CALL CHECKERROR(ABORT, NO$FREE$BUFFER);
    END;


    SETBLOCK: PROCEDURE(ADR);
        DECLARE ADR ADDRESS;
        DECLARE BYT BYTE;

        ADR = HIGH(ADR) * 26 + LOW(ADR) - 1;
        BYT = SHR(ADR, 3);
        BITMAP(BYT) = BITMAP(BYT) OR BITMASK(LOW(ADR) AND 7);
    END;

    /*
     ASBIO: ACCOMPLISHES THE TRANSFER OF 128 BYTES OF DATA FROM THE DISK 
       COMMAND  MUST BE THE NUMERIC VALUE OF THE FDCC COMMAND
                DESIRED. (LITERALS 'READ$COMMAND' AND 'WRITE$COMMAND'
                EXIST FOR THE COMMON OPERATIONS.)
       DISK     THE DRIVE FROM WHICH TO READ
       BLOCK    DISKETTE BLOCK NUMBER, A TRACK NUMBER (0-76)
                IN THE HIGH ORDER 8 BITS AND A SECTORE NUMBER (1-26)
                IN THE LOW ORDER 8 BITS
       BUFFER$PTR   THE ADDRESS OF A 128 BYTE BUFFER IN RAM
    */
    ABSIO: PROCEDURE (COMMAND, DISK, TRKSEC, BUFFER);
        DECLARE (COMMAND, DISK) BYTE, (TRKSEC, BUFFER) ADDRESS;
        /* VALUE OF 'DISK'  MUST BE 0 - 1 */
        DECLARE PAD BYTE;
        DECLARE DCB(10) BYTE INITIAL(80H);

        DCB(IOINS) = COMMAND;
        DCB(NSEC) = 1;
        DCB(TADR) = HIGH(TRKSEC);
        DCB(SADR) = LOW(TRKSEC);
        DCB(BUFLO) = LOW(BUFFER);
        DCB(BUFHI) = HIGH(BUFFER);
        CALL DISKIO(DISK, .DCB);
    END;


    FORMATTRACK: PROCEDURE(DISK, FIRSTTRK, LASTTRK, INTERLEAVE);
        DECLARE (DISK, FIRSTTRK, LASTTRK, INTERLEAVE) BYTE;
        DECLARE (I, J, CURTRACK) BYTE;
        DECLARE TRACKBUF(52) BYTE;
        DECLARE DCB(10) BYTE INITIAL(0C0H, 2, 0, 0, 0, 0, 0, 0, 0, 0);
        

        DO I = 1 to 51 BY 2;
            TRACKBUF(I) = 0C7H;
        END; 
        J = 0;

        DO CURTRACK = FIRSTTRK TO LASTTRK;
            DO I = 0 TO 51 BY 2;
                TRACKBUF(I) = 0;
            END;
            DO I = 1 TO NSECTORS;
                J = (J + INTERLEAVE) MOD NSECTORS;
                DO WHILE TRACKBUF(J + J) <> 0;
                    J = (J + 1) MOD NSECTORS;
                END;
                TRACKBUF(J + J) = I;
            END;
            
            DCB(TADR) = CURTRACK;
            DCB(BUFHI) = HIGH(.TRACKBUF);
            DCB(BUFLO) = LOW(.TRACKBUF);
            CALL DISKIO(DISK, .DCB);
        END;
    END;



    DEBLANK: PROCEDURE(PTR) ADDRESS;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE C = ' ';
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;

    DELIMIT: PROCEDURE(PTR) ADDRESS;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE (C = ':' OR C = '.' 
              OR ('0' <= C AND C <= '9')
              OR ('A' <= C AND C <= 'Z'));
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;

	MOVE: PROCEDURE(DST$P, SRC$P, CNT);
		DECLARE (DST$P, SRC$P) ADDRESS;
        DECLARE DST BASED DST$P (1) BYTE;
        DECLARE SRC BASED SRC$P (1) BYTE;
        DECLARE (CNT, I) BYTE;

		DO I = 0 TO CNT - 1;
            DST(I) = SRC(I);
		END;
	end;

    WRITEDIRECTORY: PROCEDURE(DRIVE);
        DECLARE DRIVE BYTE;
        DECLARE DISISDIR DATA('ISIS',0,0,'DIR');
        DECLARE DISISMAP DATA('ISIS',0,0,'MAP');
        DECLARE DISIST0  DATA('ISIS',0,0,'T0', 0);
        DECLARE DISISBIN DATA('ISIS',0,0,'BIN');
        DECLARE DISISLAB DATA('ISIS',0,0,'LAB');

        DECLARE I BYTE, JJ ADDRESS;
        DECLARE DIRBUFW(0) ADDRESS, DIRBUF(0) BYTE,
                DIR0W(0)   ADDRESS, DIR0(16) BYTE,
                DIR1W(0)   ADDRESS, DIR1(16) BYTE,
                DIR2W(0)   ADDRESS, DIR2(16) BYTE,
                DIR3W(0)   ADDRESS, DIR3(16) BYTE,
                DIR4W(0)   ADDRESS, DIR4(16) BYTE,
                DIR5W(0)   ADDRESS, DIR5(16) BYTE,
                DIR6W(0)   ADDRESS, DIR6(16) BYTE,
                DIR7W(0)   ADDRESS, DIR7(16) BYTE;

        DO I = 0 TO 255;
            BITMAP(I) = 0;
        END;
        CALL CLRBUF(.DIRBUF);
        DIRBUFW(2) = 1;
        DO I = 2 TO 23;
            DIRBUFW(I + 1) = DIRBUFW(I) + 1;
        END;
        CALL ABSIO(DCMD$WRITE, DRIVE, 18H, .DIRBUF);
        CALL CLRBUF(.DIRBUF);

        DIRBUFW(2) = 1AH;
        DO I = 2 TO 1;
            DIRBUFW(I + 1) = DIRBUFW(I) + 1;
        END;
        CALL ABSIO(DCMD$WRITE, DRIVE, 19H, .DIRBUF);
        CALL CLRBUF(.DIRBUF);

        DIRBUFW(2) = 102H;
        DO I = 2 TO 25;
            DIRBUFW(I + 1) = DIRBUFW(I) + 1;
        END;
        CALL ABSIO(DCMD$WRITE, DRIVE, 101H, .DIRBUF);
        CALL CLRBUF(.DIRBUF);

        DIRBUFW(2) = 202H;
        DO I = 2 TO 2;
            DIRBUFW(I + 1) = DIRBUFW(I) + 1;
        END;
        CALL ABSIO(DCMD$WRITE, DRIVE, 201H, .DIRBUF);
        CALL CLRBUF(.DIRBUF);

        CALL ABSIO(DCMD$WRITE, DRIVE, 204H, .DIRBUF);

        CALL CLRBUF(.DIRBUF);

        CALL MOVE(.DIR0(1), .DISISDIR, 9);
        DIR0W(6) = 19H;
        DIR0W(7) = 101H;
        DIR0(0) = 0;
        DIR0(10) = 1;
        DIR0(11) = 80H;

        CALL MOVE(.DIR1(1), .DISISMAP, 9);
        DIR1W(6) = 2H;
        DIR1W(7) = 201H;
        DIR1(0) = 0;
        DIR1(10) = 1;
        DIR1(11) = 80H;

        CALL MOVE(.DIR2(1), .DISIST0, 9);
        DIR2W(6) = 17H;
        DIR2W(7) = 18H;
        DIR2(0) = 0;
        DIR2(10) = 1;
        DIR2(11) = 80H;

        CALL MOVE(.DIR3(1), .DISISLAB, 9);
        DIR3W(6) = 1H;
        DIR3W(7) = 19H;
        DIR3(0) = 0;
        DIR3(10) = 1;
        DIR3(11) = 80H;

        CALL MOVE(.DIR4(1), .DISISBIN, 9);
        DIR4W(6) = 0;
        DIR4W(7) = 204H;
        DIR4(0) = 0;
        DIR4(10) = 1 OR 2;
        DIR4(11) = 80H;

        DO I = 5 TO 7;
            DIRBUF(I * 16) = 7FH;
        END;

        CALL ABSIO(DCMD$WRITE, DRIVE, 102H, .DIRBUF);
        CALL CLRBUF(.DIRBUF);

        DO I = 0 TO 7;
            DIRBUF(I * 16) = 7FH;
        END;

        DO I = 2 TO 25;
            CALL ABSIO(DCMD$WRITE, DRIVE, 102H - 1 + I, .DIRBUF);
        END;

        CALL SETBLOCK(101H);
        DO JJ = 102H TO 25 + 102H - 1;
            CALL SETBLOCK(JJ);
        END;

        CALL SETBLOCK(201H);
        DO JJ = 202H TO 2 + 202H - 1;
            CALL SETBLOCK(JJ);
        END;

        CALL SETBLOCK(18H);
        DO JJ = 1 TO 1 + 17H - 1;
            CALL SETBLOCK(JJ);
        END; 

        CALL SETBLOCK(19H);
        DO JJ = 1AH TO 1AH + 1 - 1;
            CALL SETBLOCK(JJ);
        END; 

        CALL SETBLOCK(204H);

        CALL ABSIO(DCMD$WRITE, DRIVE, 202H, .BITMAP);
        CALL ABSIO(DCMD$WRITE, DRIVE, 202H + 1, .BITMAP(128));


    END;


    DECLARE FULLNAME(15) BYTE;
    DECLARE DEVICENAMES(21) ADDRESS INITIAL (
        'F0','F1','TI','TO','VI','VO','I1','O1','TR','HR',
        'R1','R2','TP','HP','P1','P2','LP','L1','CI','CO','BB');
    DECLARE (PN, PN2) (10) BYTE;

    CANON: PROCEDURE(FILENAME, INTFN$P) BYTE;
        DECLARE (FILENAME, INTFN$P) ADDRESS;
        DECLARE PATHCH BASED FILENAME BYTE; /* CHAR OF FILENAME POINTS TO */
        DECLARE PATHCHARS BASED FILENAME (1) BYTE;
        DECLARE INTFN BASED INTFN$P (10) BYTE;  /* BYTE VERSION OF INTFN  */
        DECLARE STARTNAME ADDRESS, STARTCH BASED STARTNAME BYTE;
        DECLARE DEVPAIR(0) ADDRESS, (SECOND, FIRST) BYTE;
        DECLARE (J, I) BYTE;


        ALPHANUM: PROCEDURE BOOLEAN;
            RETURN (PATHCH >= 'A' AND PATHCH <= 'Z')
                OR (PATHCH >= '0' AND PATHCH <= '9');
        END;


        DO I = 0 TO LAST(INTFN);    /* CLEAR INTFN */
            INTFN(I) = 0;
        END;
        DO WHILE PATHCH = ' ';  /* SKIP LEADING SPACE */
            FILENAME = FILENAME + 1;
        END;
        STARTNAME = FILENAME;
        IF PATHCH = ':' THEN
        DO;
            INTFN(0) = 0FFH;
            FIRST = PATHCHARS(1);
            SECOND = PATHCHARS(2);
            IF PATHCHARS(3) <> ':' THEN
                RETURN BAD$PATH;

            DO I =  0 TO LAST(DEVICENAMES);
                IF DEVICENAMES(I) = DEVPAIR(0) THEN 
                    INTFN(0) = I;   /* SAVE DEVICE NUMBER */
            END;
            IF INTFN(0) = 0FFH THEN
                RETURN BAD$DEVICE;
            FILENAME = FILENAME + 4;
        END;

        FIRST = 0;
        DO I = 1 TO 6;
            IF ALPHANUM THEN
            DO;
                INTFN(I) = PATHCH;
                FIRST = 1;
                FILENAME = FILENAME + 1;
            END;
        END;
        IF PATHCH = '.' THEN
        DO;
            FILENAME = FILENAME + 1;
            DO I = 7 TO 9;
                IF ALPHANUM THEN
                DO;
                    INTFN(I) = PATHCH;
                    FILENAME = FILENAME + 1;
                END;
            END;
        END;
        IF INTFN(0) <= F1DEV AND FIRST = 0 THEN
            RETURN NULL$FILENAME;
        J =  -1;
        DO WHILE STARTNAME < FILENAME;
            J = J + 1;
            FULLNAME(J) = STARTCH;
            STARTNAME = STARTNAME + 1;
        END;
        IF FULLNAME(J) = '.' THEN
            RETURN NULL$EXTENSION;
        FULLNAME(J + 1) = ' ';
        IF ALPHANUM  OR PATHCH = '.' OR PATHCH = ':' THEN
            RETURN BAD$PATH;
        RETURN OK;
    END;


    UNPATH: PROCEDURE(DIR$P, FILENAME$P);
        DECLARE (DIR$P, FILENAME$p) ADDRESS;
        DECLARE FILENAME BASED FILENAME$P (1) BYTE;
        DECLARE DIR BASED DIR$P (1) BYTE;
        DECLARE I BYTE;

        FILENAME(0) = ':';
        FILENAME(1) = 'F';
        FILENAME(3) = ':';
        IF DIR(0) = 0 THEN
            FILENAME(2) = '0';
        ELSE
            FILENAME(2) = '1';
        FILENAME$P = FILENAME$P + 4;
        DO I = 0 TO 5;
            if (FILENAME(0) := DIR(I + 1)) <> 0 THEN
                FILENAME$P = FILENAME$P + 1;
        END;
        IF DIR(7) <> 0 THEN DO;
            FILENAME(0) = '.';
            FILENAME$P = FILENAME$P + 1;
        END; 
        DO I = 0 TO 2;
            if (FILENAME(0) := DIR(I + 7)) <> 0 THEN
                FILENAME$P = FILENAME$P + 1;
        END;
        FILENAME(0) = ' ';
    END; 

    DECLARE CHAR BASED BUFFER$PTR BYTE;
 
MAIN:
    COPYALL = FALSE;
    SYSTEM = FALSE;
	CALL READ(1, .BUFFER, 128, .ACTUAL, .STATUS);
    CALL CHECKERROR(ABORT, STATUS);
	BUFFER$PTR = DEBLANK(.BUFFER);
    IF CHAR = ':' THEN
        CALL CHECKERROR(ABORT, 0CEH);   /* ILLEGAL DISKETTE LABEL */

    STATUS = CANON(BUFFERPTR, .PN);
    CALL CHECKERROR(ABORT, STATUS);

	BUFFERPTR = DEBLANK(DELIMIT(DEBLANK(.BUFFER)));
    
    DO WHILE CHAR = '$';
        BUFFERPTR = BUFFERPTR + 1;
        IF CHAR = 'S' THEN DO;
            BUFFERPTR = DELIMIT(BUFFERPTR);
            SYSTEM = TRUE;
        END;
        ELSE IF CHAR = 'A' THEN DO;
            BUFFERPTR = DELIMIT(BUFFERPTR);
            COPYALL = TRUE;
        END;
        ELSE DO;
            CALL CHECKERROR(ABORT, 0C9H);
            CALL EXIT;
        END;
        BUFFERPTR = DEBLANK(BUFFERPTR);
    END;
    IF CHAR <> CR THEN DO;
        CALL CHECKERROR(ABORT, 0CBH);
        CALL EXIT;
    END;

    DO II = 0 TO 76;
        CALL FORMATTRACK(1, II, II, FMTTABLE(II)); 
    END;

    CALL WRITEDIRECTORY(1);
    /* WRITE THE LABEL NAME */
    CALL OPEN(.AFTOUT, .ISISLAB, 3, 0, .STATUS);
    CALL CHECKERROR(ABORT, STATUS);
    CALL WRITE(AFTOUT, .PN + 1, 9, .STATUS);
    CALL CHECKERROR(ABORT, STATUS);
    /* FILL IN REST OF LABEL */
    DO II = 1 TO 128 - 11 - 77;
        CALL WRITE(AFTOUT, .(0), 1, .STATUS);
        CALL CHECKERROR(ABORT, STATUS);
    END;
    CALL WRITE(AFTOUT, .(CR, LF), 2, .STATUS);
    CALL CHECKERROR(ABORT, STATUS);
    DO II = 0 TO 76;
        JJ = FMTTABLE(II) + '0';
        CALL WRITE(AFTOUT, .JJ, 1, .STATUS);
        CALL CHECKERROR(ABORT, STATUS);
    END; 
    CALL CLOSE(AFTOUT, .STATUS);
    CALL CHECKERROR(ABORT, STATUS);

	IF SYSTEM OR COPYALL THEN DO;
		IF COPYALL THEN
			CALL WRITE(0, .('COPYING ALL FILES', CR, LF), 19, .STATUS);
        ELSE
			CALL WRITE(0, .('COPYING SYSTEM FILES', CR, LF), 22, .STATUS);

		MEMSIZE = (MEMCK - .MEMORY) AND 0FFF8H;

        CALL OPEN(.AFTOUT, .ISIST0, 3, 0, .STATUS);
        CALL CHECKERROR(ABORT, STATUS);
        CALL OPEN(.AFTIN, .('ISIS.T0 '), 1, 0, .STATUS);
        CALL CHECKERROR(ABORT, STATUS);

        ACTUAL = 1;
        DO WHILE ACTUAL <> 0;
            CALL READ(AFTIN, .MEMORY, MEMSIZE, .ACTUAL, .STATUS);
            CALL CHECKERROR(ABORT, STATUS);
            CALL WRITE(AFTOUT, .MEMORY, ACTUAL, .STATUS);
            CALL CHECKERROR(ABORT, STATUS);
            IF ACTUAL < MEMSIZE THEN
                ACTUAL = 0;
        END;
        CALL CLOSE(AFTOUT, .STATUS);
        CALL CHECKERROR(ABORT, STATUS);
        CALL CLOSE(AFTIN, .STATUS);
        CALL CHECKERROR(ABORT, STATUS);

        CALL OPEN(.AFTDIR, .('ISIS.DIR'), 1, 0, .STATUS);
        CALL CHECKERROR(ABORT, STATUS);

        DIRECT(0) = 0;
        DO WHILE DIRECT(0) <> 7FH;
            CALL READ(AFTDIR, .DIRECT, 16, .ACTUAL, .STATUS);
            CALL CHECKERROR(ABORT, STATUS);
            IF ACTUAL < 16 THEN
                DIRECT(0) = 7FH;
            ELSE IF NOT DIRECT(0) THEN DO;
                if (COPY := ((DIRECTATTR AND SYSTEM$A) <> 0 OR  COPYALL)
                       AND  (DIRECTATTR AND FORMAT$A) = 0) THEN DO;
                    DIRECT(0) = 0;
                    CALL UNPATH(.DIRECT, .SRCNAME);
                    DIRECT(0) = 1;
                    CALL UNPATH(.DIRECT, .DSTNAME);
                    CALL OPEN(.AFTOUT, .DSTNAME, 3, 0, .STATUS);
                    CALL CHECKERROR(ABORT, STATUS);
                    CALL OPEN(.AFTIN, .SRCNAME, 1, 0, .STATUS);
                    CALL CHECKERROR(ABORT, STATUS);
                    ACTUAL = 1;
                    DO WHILE ACTUAL <> 0;
                        CALL READ(AFTIN, .MEMORY, MEMSIZE, .ACTUAL, .STATUS);
                        CALL CHECKERROR(ABORT, STATUS);
                        CALL WRITE(AFTOUT, .MEMORY, ACTUAL, .STATUS);
                        CALL CHECKERROR(ABORT, STATUS);
                        IF ACTUAL < MEMSIZE THEN
                            ACTUAL = 0;
                    END;
                    CALL CLOSE(AFTOUT, .STATUS);
                    CALL CHECKERROR(ABORT, STATUS);
                    CALL CLOSE(AFTIN, .STATUS);
                    CALL CHECKERROR(ABORT, STATUS);

                    DO II = 0 TO 2;
                        IF (ATTRIBMAP(II) AND DIRECTATTR) <> 0 THEN DO;
                            CALL ATTRIB(.DSTNAME, II, 0FFH, .STATUS);
                            CALL CHECKERROR(ABORT, STATUS);
                        END;
                    END;
                    NAMELEN = DELIMIT(.SRCNAME + 4) - .SRCNAME - 4;
                    CALL WRITE(0, .SRCNAME + 4, NAMELEN, .STATUS);
                    CALL WRITE(0, .CRLF, 2, .STATUS);
                END;
            END;
        END;        
        CALL CLOSE(AFTDIR, .STATUS);
        CALL CHECKERROR(ABORT, STATUS);
        CALL ATTRIB(.ISIST0, 3, 0FFH, .STATUS);
        CALL CHECKERROR(ABORT, STATUS);
        CALL ATTRIB(.ISISBIN, 2, 0FFH, .STATUS);
        CALL CHECKERROR(ABORT, STATUS);
    END;
    ELSE DO;
        CALL WRITE(0, .('NON-SYSTEM DISKETTE', CR, LF), 21, .STATUS);
        CALL OPEN(.AFTOUT, .ISIST0, 3, 0, .STATUS);
        CALL CHECKERROR(ABORT, STATUS);
        CALL WRITE(AFTOUT, .CODEBLOCK, 58, .STATUS);
        CALL CHECKERROR(ABORT, STATUS);
        CALL CLOSE(AFTOUT, .STATUS);
        CALL CHECKERROR(ABORT, STATUS);
        CALL ATTRIB(.ISIST0, 3, 0FFH, .STATUS);
        CALL CHECKERROR(ABORT, STATUS);
        CALL DELETE(.ISISBIN, .STATUS);
        CALL CHECKERROR(ABORT, STATUS);
    END;

    CALL ATTRIB(.ISISDIR, 3, 0FFH, .STATUS);
    CALL CHECKERROR(ABORT, STATUS);
    CALL ATTRIB(.ISISLAB, 3, 0FFH, .STATUS);
    CALL CHECKERROR(ABORT, STATUS);
    CALL ATTRIB(.ISISMAP, 3, 0FFH, .STATUS);
    CALL CHECKERROR(ABORT, STATUS);
    CALL EXIT;
END;
EOF

hexbin.plm
3300H:
DO;
    DECLARE TRUE    LITERALLY '0FFH',
            FALSE   LITERALLY '0',
            CR      LITERALLY '0DH',
            LF      LITERALLY '0AH';

    DECLARE READMODE    LITERALLY '1',
            WRITEMODE   LITERALLY '2',
            UPDATEMODE  LITERALLY '3';

    /* ERROR CODES */
    DECLARE FILE$EXISTS LITERALLY '0BH',
            NO$SUCH$FILE LITERALLY '0DH',
            BAD$SWITCH  LITERALLY '0C9H',
            BAD$SYNTAX  LITERALLY '0CBH',
            EARLY$EOF   LITERALLY '0CCH';

    DECLARE VER DATA(1, 8);
    DECLARE COPYRIGNT DATA('(C) 1975,1976 INTEL CORP');

    MEMCHK: PROCEDURE ADDRESS;
        GOTO 0F81BH;
    END;

    ISIS: PROCEDURE(CMD, PARAM$P);
        DECLARE CMD BYTE, PARAM$P ADDRESS;
        GOTO 40H;
    END ISIS;

    READ: PROCEDURE(CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P) ADDRESS;

        CALL ISIS(3, .CONN);
    END;

    WRITE: PROCEDURE(CONN, BUFF$P, COUNT, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, STATUS$P) ADDRESS;

        CALL ISIS(4, .CONN);
    END;

    ERROR: PROCEDURE(ERROR$NUM);
        DECLARE (ERROR$NUM, STATUS) ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(12, .ERROR$NUM);
    END;

    EXIT: PROCEDURE;
        DECLARE STATUS ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(9, .STATUS);
    END;

    OPEN: PROCEDURE(CONN$P, PATH$P, ACCESS, ECHO, STATUS$P);
        DECLARE (CONN$P, PATH$P, ACCESS, ECHO, STATUS$P) ADDRESS;

        CALL ISIS(0, .CONN$P);
    END;

    CLOSE: PROCEDURE(CONN, STATUS$P);
        DECLARE (CONN, STATUS$P) ADDRESS;

        CALL ISIS(1, .CONN);
    END;

    DEBLANK: PROCEDURE(PTR) ADDRESS;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE (C = ' ');
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;

    DELIMIT: PROCEDURE(PTR) ADDRESS;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE (C = ':' OR C = '.' OR
                 ('0' <= C AND C <= '9') OR
                 ('A' <= C AND C <= 'Z'));
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;

    SEQ: PROCEDURE(S1, S2, CNT) BYTE;
        DECLARE (S1,S2) ADDRESS, CNT BYTE;
        DECLARE S1A BASED S1(1) BYTE;
        DECLARE S2A BASED S2(1) BYTE;
        DECLARE I BYTE;
        CNT = CNT - 1;
        DO I = 0 TO CNT;
            IF S1A(I) <> S2A(I) THEN
                RETURN 0;
        END;
        RETURN 0FFH;
    END;


    SCANINTEGER: PROCEDURE(PTRPTR) ADDRESS;
        DECLARE PTRPTR ADDRESS;
        DECLARE PTR BASED PTRPTR ADDRESS;
        DECLARE (SCANPTR, BINVAL, OCTVAL, DECVAL, HEXVAL) ADDRESS;
        DECLARE C BASED SCANPTR BYTE;
        DECLARE (I, CONTINUE) BYTE;
        DECLARE DIGITS(16) BYTE INITIAL('0123456789ABCDEF');

        BINVAL, OCTVAL, DECVAL, HEXVAL = 0;
        SCANPTR = PTR;

        DO WHILE C = ' ';
            SCANPTR = SCANPTR + 1;
        END;

        CONTINUE = TRUE;
        DO WHILE CONTINUE;
            CONTINUE = FALSE;
            DO I = 0 TO 15;
                IF C = DIGITS(I) THEN DO;
                    IF I < 2 THEN
                        BINVAL = BINVAL + BINVAL + I;
                    OCTVAL = SHL(OCTVAL, 3) + I;
                    IF I < 10 THEN
                        DECVAL = DECVAL * 10 + I;
                    HEXVAL = SHL(HEXVAL, 4) + I;
                    SCANPTR = SCANPTR + 1;
                    CONTINUE = TRUE;
                END; 
            END;
        END;
        PTR = SCANPTR + 1;
        IF C = 'H' THEN
            RETURN HEXVAL;
        IF C = 'O' OR C = 'Q' THEN
            RETURN OCTVAL;
        PTR = SCANPTR;
        SCANPTR = SCANPTR - 1;
        IF C = 'B' THEN
            RETURN BINVAL;
        RETURN DECVAL;

    END;



    NUMOUT: PROCEDURE(VALUE, BASE, LC, BUFADR, WIDTH);
        DECLARE (VALUE, BUFADR) ADDRESS, (BASE, LC, WIDTH) BYTE; 
        DECLARE DIGITS DATA('0123456789ABCDEF');
        DECLARE I BYTE;
        DECLARE BUF BASED BUFADR (1) BYTE;

        DO I = 1 TO WIDTH;
            BUF(WIDTH - I) = DIGITS(VALUE MOD BASE);
            VALUE = VALUE / BASE;   
        END;

        I = 0;
        DO WHILE BUF(I) = '0' AND I < WIDTH - 1;
            BUF(I) = LC;
            I = I + 1;
        END;
    END;

    REPORTERROR: PROCEDURE(ERRNUM);
        DECLARE ERRNUM ADDRESS;
        DECLARE NUMBERBUFFER(4) BYTE, I ADDRESS, STATUS ADDRESS;
     

        DECLARE ERRMSG DATA(0, 0,
            2, 'ILLEGAL AFTN ARGUMENT', 0,
            4, 'INCORRECTLY SPECIFIED FILE', 0,
            5, 'UNRECOGNIZED DEVICE NAME', 0,
            6, 'ATTEMPT TO WRITE TO INPUT DEVICE', 0,
            8, 'ATTEMPT TO READ FROM OUTPUT DEVICE', 0,
            9, 'DIRECTORY FULL', 0,
            0AH, 'NOT ON SAME DISK', 0,
            0BH, 'FILE ALREADY EXISTS', 0,
            0CH, 'FILE IS ALREADY OPEN', 0,
            0DH, 'NO SUCH FILE', 0,
            0EH, 'WRITE PROTECTED', 0,
            0FH, 'LOAD TOO LOW', 0,
            10H, 'BAD LOAD FORMAT', 0,
            11H, 'NOT A DISK FILE', 0,
            12H, 'ILLEGAL ISIS COMMAND', 0,
            13H, 'ATTEMPTED SEEK ON NON-DISK FILE', 0,
            14H, 'ATTEMPTED BACK SEEK TO FAR', 0,
            16H, 'ILLEGAL ACCESS MODE TO OPEN', 0,
            17H, 'MISSING FILENAME', 0,
            19H, 'ILLEGAL ECHO FILE', 0,
            1AH, 'ILLEGAL ATTRIBUTE IDENTIFIER', 0,
            1BH, 'ILLEGAL SEEK COMMAND', 0,
            1CH, 'MISSING EXTENSION', 0,
            1FH, 'CAN', 27H, 'T SEEK ON WRITE ONLY FILE', 0,
            20H, 'CAN', 27H, 'T DELETE OPEN FILE', 0,
            23H, 'SEEK PAST EOF', 0,
            0C9H, 'UNRECOGNIZED SWITCH', 0,
            0CAH, 'UNRECOGNIZED DELIMITER', 0,
            0CBH, 'INVALID SYNTAX', 0,
            0CCH, 'PREMATURE EOF', 0,
            0CEH, 'ILLEGAL DISKETTE LABEL', 0,
            0D0H, 'CHECKSUM ERROR', 0
        );

        IF ERRNUM <> 0 THEN
        DO;
            I = 0;
            DO WHILE I < LENGTH(ERRMSG);
                IF ERRNUM = ERRMSG(I) AND ERRMSG(I + 1) <> 0 THEN
                DO;
                    I = I + 1;
                    CALL WRITE(0, .(' '), 1, .STATUS);
                    DO WHILE ERRMSG(I) <> 0;
                        CALL WRITE(0, .ERRMSG(I), 1, .STATUS);
                        I = I + 1;
                    END;
                    CALL WRITE(0, .(0DH, 0AH), 2, .STATUS);
                    return;
                END;
                ELSE
                DO;
                    DO WHILE ERRMSG(I) <> 0;
                        I = I + 1;
                    END;
                    I = I + 1;
                END;
            end;
            CALL ERROR(ERRNUM);
        END;
    END;

    FILE$ERROR: PROCEDURE(STATUS, PTR, CALLEXIT);
        DECLARE (STATUS, PTR) ADDRESS, CALLEXIT BYTE;
        DECLARE ERR$STATUS ADDRESS;

        IF STATUS <> 0 THEN
        DO;
            PTR = DEBLANK(PTR);
            CALL WRITE(0, .(' '), 1, .ERR$STATUS);
            CALL WRITE(0, PTR, DELIMIT(PTR) - PTR, .ERR$STATUS);
            CALL WRITE(0, .(','), 1, .ERR$STATUS);
            CALL REPORTERROR(STATUS);
            IF CALLEXIT THEN
                CALL EXIT;
        END;
    END;


    DECLARE BUFFER$SIZE ADDRESS;
    DECLARE IBUF(3328) BYTE, IPTR ADDRESS;
    DECLARE BUFFER(128) BYTE;
    DECLARE (BUFFER$PTR, OUTPUT$PTR, INPUT$PTR) ADDRESS;
    DECLARE (ACTUAL, STATUS) ADDRESS;
    DECLARE (START, ENDFILE) BYTE;
    DECLARE (AFT$OUT, AFT$IN) ADDRESS;
    DECLARE (START$VALUE, RECORD$PTR, CONTENT$PTR, LEN$PTR) ADDRESS;
    DECLARE (ADDR$PTR, RECORD$ADDR) ADDRESS;
    DECLARE (RLEN, TMP, I, CHECKSUM) BYTE;
    DECLARE LEN BASED LEN$PTR ADDRESS;
    DECLARE ADDR BASED ADDR$PTR ADDRESS;
    DECLARE CONTENT BASED CONTENT$PTR BYTE;
    DECLARE CHAR BASED BUFFER$PTR BYTE;


    GNC: PROCEDURE BYTE;

        IF IPTR = LENGTH(IBUF) THEN
        DO;
            CALL READ(AFT$IN, .IBUF, LENGTH(IBUF), .ACTUAL, .STATUS);
            CALL FILEERROR(STATUS, INPUT$PTR, TRUE);
            IF ACTUAL = 0 THEN
            DO;
                CALL FILEERROR(EARLY$EOF, INPUT$PTR, TRUE);
                CALL EXIT;
            END;
            IPTR = 0;
        END;
        IPTR = IPTR + 1;
        RETURN IBUF(IPTR - 1) AND 7FH;
    END GNC;

    HEX: PROCEDURE BYTE;
        DECLARE CHAR BYTE;

        IF (CHAR := GNC) >= '0' AND CHAR <= '9' THEN RETURN CHAR - '0';
        IF CHAR >= 'A' AND CHAR <= 'F' THEN RETURN CHAR - 37H;
        RETURN 0FFH;
    END HEX;

    BYTES: PROCEDURE BYTE;
        DECLARE CHAR BYTE;

        CHAR = SHL(HEX, 4) + HEX;
        CHECKSUM = CHECKSUM + CHAR;
        RETURN CHAR;
    END BYTES;


MAIN:
    START, ENDFILE = FALSE;
    INPUT$PTR = .(':CI: ');
    CALL READ(1, .BUFFER, LENGTH(BUFFER), .ACTUAL, .STATUS);
    CALL FILEERROR(STATUS, INPUT$PTR, TRUE);
    INPUT$PTR,BUFFER$PTR  = DEBLANK(.BUFFER);
    CALL OPEN(.AFT$IN, INPUT$PTR, READ$MODE, 0, .STATUS);
    CALL FILEERROR(STATUS, INPUT$PTR, TRUE);
    BUFFER$PTR = DEBLANK(DELIMIT(BUFFER$PTR));
    IF SEQ(.('TO '), BUFFER$PTR, 3) THEN
    DO;
        OUTPUT$PTR,BUFFER$PTR = DEBLANK(BUFFER$PTR + 2);
        BUFFER$PTR = DEBLANK(DELIMIT(BUFFER$PTR));
    END;
    ELSE DO;
        CALL REPORTERROR(BAD$SYNTAX);
        CALL EXIT;
    END;

    BUFFER$PTR = DELIMIT(DEBLANK(BUFFER$PTR));
    DO WHILE CHAR = '$';
        BUFFER$PTR = BUFFER$PTR + 1;
        IF CHAR = 'S' THEN DO;
            START = TRUE;
            BUFFER$PTR = DEBLANK(BUFFER$PTR + 1);
            IF CHAR <> '=' THEN DO;
                CALL REPORTERROR(BAD$SYNTAX);
                CALL EXIT;
            END;
            BUFFER$PTR = BUFFER$PTR + 1;
            START$VALUE = SCANINTEGER(.BUFFER$PTR);
        END;
        ELSE DO;
            CALL REPORTERROR(BAD$SWITCH);
            CALL EXIT;
        END;
        BUFFER$PTR = DEBLANK(DELIMIT(BUFFER$PTR));
    END;

    IF CHAR <> CR THEN DO;
        CALL REPORTERROR(BAD$SYNTAX);
        CALL EXIT;
    END;
    CALL OPEN(.AFT$OUT, OUTPUT$PTR, WRITEMODE, 0, .STATUS);
    CALL FILEERROR(STATUS, OUTPUT$PTR, TRUE);
    BUFFER$SIZE = MEMCHK - .MEMORY - 64;
    LEN$PTR = .MEMORY;
    LEN = 0;
    ADDR$PTR = .MEMORY + 2;
    ADDR = 0;
    CONTENT$PTR = .MEMORY + 4;
    RECORD$PTR = 0;
    IPTR = LENGTH(IBUF); 
    RLEN = 1;
    DO WHILE RLEN <> 0;
        DO WHILE GNC <> ':';
        END;
        CHECKSUM = 0;
        IF (RLEN := BYTES) <> 0 THEN DO;
            RECORD$ADDR = BYTES * 256 + BYTES;
            IF RECORD$PTR <> RECORD$ADDR OR LEN > BUFFER$SIZE THEN DO;
                IF LEN <> 0 THEN DO;
                    CALL WRITE(AFT$OUT, .MEMORY, LEN + 4, .STATUS);
                    CALL FILEERROR(STATUS, OUTPUT$PTR, TRUE);
                END;
                LEN = 0;
                RECORD$PTR = RECORD$ADDR;
                CONTENT$PTR = .MEMORY  + 4;
                ADDR = RECORD$ADDR;
            END;
            TMP = BYTES;
            DO I = 1 TO RLEN;
                CONTENT = BYTES;
                CONTENT$PTR = CONTENT$PTR + 1;
                RECORD$PTR = RECORD$PTR + 1;
                LEN = LEN + 1;
            END;
            TMP = BYTES;
            IF CHECKSUM <> 0 THEN DO;
                CALL FILEERROR(0D0H, INPUT$PTR, TRUE);
                CALL EXIT;
            END;
        END;
        ELSE DO;
            IF LEN <> 0 THEN DO;
                CALL WRITE(AFT$OUT, .MEMORY, LEN + 4, .STATUS);
                CALL FILEERROR(STATUS, OUTPUT$PTR, TRUE);
            END;
            LEN = 0;
            ADDR = BYTES * 256 + BYTES;
            IF START THEN
                ADDR = START$VALUE;
            CALL WRITE(AFT$OUT, .MEMORY, 4, .STATUS);
            CALL FILEERROR(STATUS, OUTPUT$PTR, TRUE);
        END;
    END;
    CALL CLOSE(AFT$IN, .STATUS);
    CALL FILEERROR(STATUS, INPUT$PTR, TRUE);
    CALL CLOSE(AFT$OUT, .STATUS);
    CALL FILEERROR(STATUS, OUTPUT$PTR, TRUE);
    CALL EXIT;

END;
EOF
isis.bin.cfg
$*=1 A=2 N=1 H=8

isis.bin.plm
3BH: DO;
    DECLARE VER DATA(1,2);

/* COMMON CONTROL CHARACTERS */
DECLARE CONTROL$E LITERALLY '5';
DECLARE BELL LITERALLY '7';
DECLARE BS LITERALLY '8';
DECLARE CR LITERALLY '0DH';
DECLARE LF LITERALLY '0AH';
DECLARE HASH LITERALLY '23H';
DECLARE CARET LITERALLY '5EH';
DECLARE CONTROL$P LITERALLY '10H';
DECLARE CONTROL$Q LITERALLY '11H';
DECLARE CONTROL$R LITERALLY '12H';
DECLARE CONTROL$S LITERALLY '13H';
DECLARE CONTROL$X LITERALLY '18H';
DECLARE CONTROL$Z LITERALLY '1AH';
DECLARE ESC LITERALLY '1BH';
DECLARE DELKEY LITERALLY '7FH';

/* BOOLEAN LITERALS */
DECLARE BOOLEAN LITERALLY 'BYTE';
DECLARE TRUE LITERALLY '0FFH';
DECLARE FALSE LITERALLY '0';

/* CONSOLE LITERALS */
DECLARE AFT$CONSOL$IN LITERALLY '3';
DECLARE AFT$CONSOL$OUT LITERALLY '2';
DECLARE READ$MODE LITERALLY '1';
DECLARE WRITE$MODE LITERALLY '2';
DECLARE UPDATE$MODE LITERALLY '3';

/* SEEK OPTIONS */
DECLARE SEEK$RETURN LITERALLY '0';
DECLARE SEEK$BACKWARD LITERALLY '1';
DECLARE SEEK$ABS LITERALLY '2';
DECLARE SEEK$FORWARD LITERALLY '3';
DECLARE SEEK$EOF LITERALLY '4';

/* ERROR CODES */
DECLARE OK LITERALLY '0';
DECLARE NO$FREE$BUFFER LITERALLY '1';
DECLARE BAD$AFT$NO LITERALLY '2';

DECLARE AFT$FULL LITERALLY '3';
DECLARE BAD$PATH LITERALLY '4';
DECLARE BAD$DEVICE LITERALLY '5';
DECLARE CANT$WRITE LITERALLY '6';
DECLARE DISK$FULL LITERALLY '7';
DECLARE CANT$READ LITERALLY '8';
DECLARE DIRECTORY$FULL LITERALLY '9';
DECLARE DIFFERENT$DISK LITERALLY '10';
DECLARE MULTIDEFINED LITERALLY '11';
DECLARE ALREADY$OPEN LITERALLY '12';
DECLARE NO$SUCH$FILE LITERALLY '13';
DECLARE WRITE$PROTECT LITERALLY '14';
DECLARE ISIS$OVERWRITE LITERALLY '15';
DECLARE BAD$LOAD$FORMAT LITERALLY '16';
DECLARE NON$DISK$FILE LITERALLY '17';
DECLARE BAD$COMMAND LITERALLY '18';
DECLARE NON$DISK$SEEK LITERALLY '19';
DECLARE LONG$BACK$SEEK LITERALLY '20';
DECLARE CANT$RESCAN LITERALLY '21';
DECLARE BAD$ACCESS LITERALLY '22';
DECLARE NULL$FILENAME LITERALLY '23';
DECLARE DISK$IO$ERROR LITERALLY '24';
DECLARE BAD$ECHO LITERALLY '25';
DECLARE BAD$ATTRIB LITERALLY '26';
DECLARE BAD$SEEK$ARG LITERALLY '27';
DECLARE NULL$EXTENSION LITERALLY '28';
DECLARE CONSOLE$EOF LITERALLY '29';
DECLARE DRIVE$NOT$READY LITERALLY '30';
DECLARE SEEK$ON$WRITE LITERALLY '31';
DECLARE CANT$DELETE LITERALLY '32';
DECLARE BAD$PARAMETER LITERALLY '33';
DECLARE BAD$RETSW LITERALLY '34';
DECLARE SEEK$PAST$EOF LITERALLY '35';

DECLARE WARNING LITERALLY '0';
DECLARE MESSAGE LITERALLY '1';
DECLARE ABORT LITERALLY '2';
DECLARE CMSK LITERALLY '0FCH';

/* ATTRIBUTES */
DECLARE INVISIBLE$ATTRIBUTE LITERALLY '1';
DECLARE SYSTEM$ATTRIBUTE LITERALLY '2';
DECLARE WRITEP$ATTRIBUTE LITERALLY '4';
DECLARE FORMAT$ATTRIBUTE LITERALLY '80H';

/* ACCESS MODE */
DECLARE ACCESS$READ LITERALLY '1';
DECLARE ACCESS$WRITE LITERALLY '2';

/* OMF RECORD TYPES */
DECLARE R$MODHDR LITERALLY '2';
DECLARE R$MODEND LITERALLY '4';
DECLARE R$CONTENT LITERALLY '6';
DECLARE R$RELOC LITERALLY '22H';

DECLARE AFT$BOTTOM LITERALLY '2';
DECLARE AFT$FIRST LITERALLY   '4';
DECLARE AFT$LAST LITERALLY '9';
DECLARE F1DEV LITERALLY '1';
DECLARE CIDEV LITERALLY '18';
DECLARE CODEV LITERALLY '19';
DECLARE BBDEV LITERALLY '20';

DECLARE BLINK LITERALLY '0';
DECLARE FLINK LITERALLY '1';

DECLARE CMD$RECAL LITERALLY '3';
DECLARE CMD$READ LITERALLY '4';
DECLARE CMD$WRITE LITERALLY '6';

DECLARE MDSMON LITERALLY '0';
DECLARE BTSTRP LITERALLY '8';

ISIS: PROCEDURE(COMMAND, PARAMETER$BLOCK);
    DECLARE COMMAND BYTE, PARAMETER$BLOCK ADDRESS;
    DECLARE PARAM BASED PARAMETER$BLOCK (5) ADDRESS;
    DECLARE COPYRIGHT DATA('(C) 1975,1976 INTEL CORP');
    DECLARE I BYTE;
    DECLARE SYSPARAM(0) ADDRESS;
    DECLARE USERSTATUS$P ADDRESS, USERSTATUS BASED USERSTATUS$P ADDRESS;
    DECLARE (PARAM1, PARAM2, PARAM3, PARAM4, PARAM5) ADDRESS;
    DECLARE RETPARAMIDX(14) BYTE INITIAL( 5, 2, 2, 5, 4, 5, 5, 3,
                                         3, 1, 4, 2, 2, 3);
    DECLARE PARAMTYPE(5) ADDRESS INITIAL(
                111110001010B,    /* BIT SET IF PARAMETER NEEDS TO CHECK FOR */
                111001100111110B,    /* ADDRESS BELOW MEMORY (3000H) */
                100001101000000B,
                100001110000B,
                11010010B);

    DECLARE COLD$START$FLAG BOOLEAN INITIAL (TRUE);
    DECLARE USERSP ADDRESS;
    DECLARE USRSTK(64) BYTE INITIAL(0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,
                                    0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,
                                    0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,
                                    0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,
                                    0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,
                                    0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,
                                    0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,
                                    0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,0C7H);
    DECLARE TOPSTACK(0) BYTE;

    CI: PROCEDURE BYTE;
        GOTO 0F803H;
    END;

    RI: PROCEDURE BYTE;
        GOTO 0F806H;
    END;

    CO: PROCEDURE(CH);
        DECLARE CH BYTE;
        GOTO 0F809H;
    END;

    PO: PROCEDURE(CH);
        DECLARE CH BYTE;
        GOTO 0F80CH;
    END;

    LO: PROCEDURE(CH);
        DECLARE CH BYTE;
        GOTO 0F80FH;
    END;

    IOCHK: PROCEDURE BYTE;
        GOTO 0F815H;
    END;

    IOSET: PROCEDURE(CH);
        DECLARE CH BYTE;
        GOTO 0F818H;
    END;

    MEMCK: PROCEDURE ADDRESS;
        GOTO 0F81BH;
    END;

    BINASC: PROCEDURE(VALUE, BASE, LC, BUFADR, WIDTH);
        DECLARE (VALUE, BUFADR) ADDRESS, (BASE, LC, WIDTH) BYTE;
        DECLARE DIGITS DATA('0123456789ABCDEF');
        DECLARE I BYTE;
        DECLARE BUF BASED BUFADR (1) BYTE;

        DO I = 1 TO WIDTH;
            BUF(WIDTH - I) = DIGITS(VALUE MOD BASE);
            VALUE = VALUE / BASE;
        END;

        I = 0;
        DO WHILE BUF(I) = '0' AND I < WIDTH - 1;
            BUF(I) = LC;
            I = I + 1;
        END;
    END;

    DECLARE STATUS ADDRESS;
    DECLARE DEBUG$TOGGLE BYTE INITIAL(0);
    DECLARE GLOBAL$SEVERITY BYTE INITIAL(0);
    DECLARE FDCC$ERROR$TYPE ADDRESS INITIAL(0);
    DECLARE INITIO$BASE ADDRESS INITIAL(6), INITIO BASED INITIO$BASE BYTE;
    /*
       THE ERR PROCEDURE IS USED TO HANDLE ERROR CONDIITONS.
           AN ERROR MESSAGE IS ISSUED TO THE CONSOLE, WHICH FOR
           DISK ERRORS HAS EXTENDED CONTENT
       CONTROL THEN PASSES TO THE MDS MONITOR

       ERROR$TYPE IS THE ERROR NUMBER WHICH IDENTIFIES THE PARTICUALAR
              TYPE OF ERROR, SUCH AS DISK I/O ERROR
    */
    ERR: PROCEDURE(SEVERITY, ERROR$TYPE);
        DECLARE (SEVERITY, ERROR$TYPE, I, IMAX) BYTE;
        DECLARE PC BASED USER$SP ADDRESS;
        DECLARE MSG1(8) BYTE INITIAL(CR, LF, 'ERROR '),
                MSG2(3) BYTE INITIAL(0, 0, 0), /* ERROR NUMBER GOES HERE */
                MSG3(9) BYTE INITIAL(' USER PC '),
                MSG4(4) BYTE INITIAL(0,0,0,0), /* USER PC IN HEX GOES HERE */
                MSG5(2) BYTE INITIAL(CR, LF),
                MSG6(5) BYTE INITIAL('FDCC='),
                MSG7(4) BYTE INITIAL(0,0,0,0), /* FDCC ERROR DATA GOES HERE */
                MSG8(2) BYTE INITIAL(CR, LF);

        IF (SEVERITY := SEVERITY OR GLOBAL$SEVERITY) <> WARNING THEN
        DO;
            CALL BINASC(ERROR$TYPE, 10, 0, .MSG2, 3);
            CALL BINASC(PC,16,'0',.MSG4,4);
            CALL IOSET((IOCHK AND CMSK) OR (INITIO AND 3));
            IMAX = 25;  /* NUMBER OF CHARACTERS IN NORMAL ERROR MESSAGE */
            IF ERROR$TYPE = DISK$IO$ERROR THEN
            DO;
                IMAX = 36;
                CALL BINASC(FDCC$ERROR$TYPE, 16, '0', .MSG7, 4);
            END;
            DO I = 0 TO IMAX;
                CALL CO(MSG1(I));
            END;
        END;
        ELSE
        DO;
            USER$STATUS = ERROR$TYPE;
            STACKPTR = USER$SP;
        END;
        IF SEVERITY >= ABORT THEN
        DO;
            IF DEBUG$TOGGLE THEN
                GOTO MDSMON;    /* EXIT VIA MONITOR */
            GOTO BTSTRP;        /* EXIT VIA SOFTWARE BOOTSTRAP */
        END;
    END;

    DECLARE BUFFER$TABLE(19) BYTE INITIAL(0,0,0,0,0,0,0,0,0,0,
                             0,0,0,0,0,0,0,0,0);

    CLRBUF: PROCEDURE(BUFFER$P);
        DECLARE BUFFER$P ADDRESS;
        DECLARE BUFFER BASED BUFFER$P (128) BYTE;
        DECLARE I BYTE;

        DO I = 0 TO 127;
            BUFFER(I) = 0;
        END;
    END;


    FREEBUF: PROCEDURE(BUFFER);
        DECLARE BUFFER ADDRESS;

        BUFFER$TABLE(SHR(BUFFER - .MEMORY, 7)) = 0;
    END;

    GETBUF: PROCEDURE ADDRESS;
        DECLARE I BYTE;

        DO I = 0 TO LAST(BUFFER$TABLE);
            IF BUFFER$TABLE(I) = 0 THEN
            DO;
                BUFFER$TABLE(I) = 2;
                RETURN .MEMORY + SHL(DOUBLE(I), 7);
            END;
        END;
        CALL ERR(ABORT, NO$FREE$BUFFER);
    END;

    /* THE AFT TABLES AND POINTERS TO CURRENTLY SELECTED ENTRY */
    DECLARE AFT$CURRENT BYTE INITIAL(0FFH);
    DECLARE POINTER$BASE ADDRESS, LINKS BASED POINTER$BASE (64) ADDRESS;
    DECLARE DATUM$BASE ADDRESS, DATUM BASED DATUM$BASE (128) BYTE;
    DECLARE CLOSED$P ADDRESS, CUR$CLOSED BASED CLOSED$P BYTE;
    DECLARE DEVICE$P ADDRESS, CUR$DEVICE BASED DEVICE$P BYTE;
    DECLARE ACCESS$P ADDRESS, CUR$ACCESS BASED ACCESS$P BYTE;
    DECLARE ECHOAFT$P ADDRESS, CUR$ECHOAFT BASED ECHOAFT$P BYTE;
    DECLARE EBUF$P ADDRESS, CUR$EBUF BASED EBUF$P ADDRESS;
    DECLARE DBUF$P ADDRESS, CUR$DBUF BASED DBUF$P ADDRESS;
    DECLARE BYTENO$P ADDRESS, CUR$BYTENO BASED BYTENO$P BYTE;
    DECLARE DNUM$P ADDRESS, CUR$DNUM BASED DNUM$P ADDRESS;
    DECLARE LBUF$P ADDRESS, CUR$LBUF BASED LBUF$P ADDRESS;
    DECLARE DPTR$P ADDRESS, CUR$DPTR BASED DPTR$P BYTE;
    DECLARE LASTBYTE$P ADDRESS, CUR$LASTBYTE BASED LASTBYTE$P BYTE;
    DECLARE ALLOC$P ADDRESS, CUR$ALLOC BASED ALLOC$P BYTE;
    DECLARE DMOD$P ADDRESS, CUR$DMOD BASED DMOD$P BYTE;
    DECLARE BLKCNT$P ADDRESS, CUR$BLKCNT BASED BLKCNT$P ADDRESS;
    DECLARE BLKNO$P ADDRESS, CUR$BLKNO BASED BLKNO$P ADDRESS;
    DECLARE LADDR$P ADDRESS, CUR$LADDR BASED LADDR$P ADDRESS;
    DECLARE L1ADDR$P ADDRESS, CUR$L1ADDR BASED L1ADDR$P ADDRESS;
    DECLARE DADDR$P ADDRESS, CUR$DADDR BASED DADDR$P ADDRESS;


    DECLARE CLOSED(10) BYTE INITIAL(0, 0, 0FFH, 0FFH, 0FFH, 0FFH,
                                    0FFH, 0FFH, 0FFH, 0FFH);
    DECLARE DEVICE(10) BYTE INITIAL(0, 1, 0, 0, 0, 0, 0, 0, 0, 0);
    DECLARE ACCESS(10) BYTE INITIAL(3, 3, 0, 0, 0, 0, 0, 0, 0, 0);
    DECLARE ECHOAFT(10) BYTE INITIAL(0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    DECLARE EBUF(10) ADDRESS INITIAL(0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    DECLARE DBUF(10) ADDRESS INITIAL(0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    DECLARE BYTENO(10) BYTE INITIAL(128, 128, 0, 0, 0, 0, 0, 0, 0, 0);
    DECLARE DNUM(10) ADDRESS INITIAL(0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    DECLARE LBUF(10) ADDRESS INITIAL(0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    DECLARE DPTR(10) BYTE INITIAL(0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    DECLARE LASTBYTE(10) BYTE INITIAL(128, 128, 0, 0, 0, 0, 0, 0, 0, 0);
    DECLARE ALLOC(10) BYTE INITIAL(0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    DECLARE DMOD(10) BYTE INITIAL(0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    DECLARE BLKCNT(10) ADDRESS INITIAL(25, 25, 0, 0, 0, 0, 0, 0, 0, 0);
    DECLARE BLKNO(10) ADDRESS INITIAL(0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    DECLARE LADDR(10) ADDRESS INITIAL(101H, 101H, 0, 0, 0, 0, 0, 0, 0, 0);
    DECLARE L1ADDR(10) ADDRESS INITIAL(101H, 101H, 0, 0, 0, 0, 0, 0, 0, 0);
    DECLARE DADDR(10) ADDRESS INITIAL(102H, 102H, 0, 0, 0, 0, 0, 0, 0, 0);


    SETTABS: PROCEDURE(AFT);
        DECLARE AFT BYTE;

        IF AFT$CURRENT <> AFT THEN
        DO;
            AFT$CURRENT = AFT;
            CLOSED$P = .CLOSED(AFT);
            DEVICE$P = .DEVICE(AFT);
            ACCESS$P = .ACCESS(AFT);
            ECHOAFT$P = .ECHOAFT(AFT);
            EBUF$P = .EBUF(AFT);
            BYTENO$P = .BYTENO(AFT);
            DNUM$P = .DNUM(AFT);
            DPTR$P = .DPTR(AFT);
            LASTBYTE$P = .LASTBYTE(AFT);
            BLKNO$P = .BLKNO(AFT);
            ALLOC$P = .ALLOC(AFT);
            DMOD$P = .DMOD(AFT);
            BLKCNT$P = .BLKCNT(AFT);
            LADDR$P = .LADDR(AFT);
            L1ADDR$P = .L1ADDR(AFT);
            DADDR$P = .DADDR(AFT);
        END;
        LBUF$P = .LBUF(AFT);
        DBUF$P = .DBUF(AFT);
        POINTER$BASE = CUR$LBUF;
        DATUM$BASE = CUR$DBUF;
    END;

    GETAFT: PROCEDURE BYTE;
        DECLARE I BYTE;

        DO I = AFT$BOTTOM TO AFT$LAST;
            IF CLOSED(I) THEN
                RETURN I;
        END;
        CALL ERR(ABORT, AFT$FULL);
    END;

    PACKBUFS: PROCEDURE ADDRESS;
        DECLARE I BYTE, BUFFER$TOP ADDRESS;

        LOWBUF: PROCEDURE(BUFPTR);
            DECLARE BUFPTR ADDRESS;
            DECLARE (NEWBUF, OLDBUF) ADDRESS, I BYTE;
            DECLARE BUFFER BASED BUFPTR ADDRESS,
                    NBUF BASED NEWBUF (128) BYTE,
                    OBUF BASED OLDBUF (128) BYTE;

            I = SHR(BUFFER - .MEMORY, 7);
            IF BUFFER$TABLE(I) <> 2 THEN
                RETURN;
            OLDBUF = BUFFER;
            CALL FREEBUF(OLDBUF);
            NEWBUF = GETBUF;
            IF BUFFER$TOP < NEWBUF THEN
                BUFFER$TOP = NEWBUF;
            IF NEWBUF = OLDBUF THEN
                RETURN;
            DO I = 0 TO 127;
                NBUF(I) = OBUF(I);
            END;
            BUFFER = NEWBUF;
        END;

        BUFFER$TOP = .MEMORY;
        DO I = AFT$BOTTOM TO AFT$LAST;
            CALL LOWBUF(.LBUF(I));
            CALL LOWBUF(.DBUF(I));
            CALL LOWBUF(.EBUF(I));
        END;
        RETURN BUFFER$TOP + 128;
    END;

    /*
       XEQIOPB PROVIDES ACCESS TO THE FDCC
       CONTROLLER 1 = BASE ADDRESS 78H (DRIVES 0, 1 FOR SD)

       DRIVE: AN INTEGER 0-1, SPECIFYING THE DISK TO BE ACCESSED
       IOPB:  THE ADDRESS OF A PARAMETER BLOCK TO BE SENT TO THE
          FDCC CONTROLLER. THIS PARAMETER MUST BE SET UP
          AS IF IT WERE FOR DRIVE 0; IF 'DRIVE' SELECTS
          ANOTHER DRIVE, 'DISKIO' WILL SET ALL THE NECESSARY
          BITS

       THE CALLER PROVIDES A PARAMETER BLOCK SPECIFYING SOME
       VALID DISK OPERATION ON DRIVE 0 AND AN INTEGER DRIVE SELECT VALUE
       IN THIS BOOT CODE ONLY READ AND RECAL ARE USED
       THE PROCEDURE WAITS FOR THE CONTROLLER TO GO UNBUSY, THEN
       PERFORMS THE DESIRED ACTION. IN CASE OF A CONTROLLER ERROR,
       THE DISK DRIVE IS RECALIBRATED AND THE ACTION IS TRIED AGAIN.
       IF SUCCESSFUL COMPLETION CANNOT BE OBTAINED AFTER 'MAX$RETRIES'
       ATTEMPTS, A FATAL ERROR OCCURS, OTHERWISE A NORMAL RETURN IS MADE

    */
        DECLARE FDCC$STATUS$0   LITERALLY   '78H',
                RESULT$TYPE$0   LITERALLY   '79H',
                RESULT$BYTE$0   LITERALLY   '7BH',
                LOW$ADDRESS$0   LITERALLY   '79H',
                HIGH$ADDRESS$0  LITERALLY   '7AH';

        DECLARE MAX$RETRIES     LITERALLY   '10',
                DISK$DONE       LITERALLY   '4',
                READ$COMMAND    LITERALLY   '4',
                WRITE$COMMAND   LITERALLY   '6',
                RECALIBRATE     LITERALLY   '3';

        DECLARE IOCW    LITERALLY '0',      /* IOPB OFFSETS */
                IOINS   LITERALLY '1',
                NSEC    LITERALLY '2',
                TADR    LITERALLY '3',
                SADR    LITERALLY '4',
                BUFLO   LITERALLY '5',
                BUFHI   LITERALLY '6';


    XEQIOPB: PROCEDURE(DRIVE, IOPB);
        /* THIS PROCEDURE ISSUES THE IOPB TO THE DISK CONTROLLER, IN THE */
        /* CASE OF THE 8271 IT ALSO TRANSFERS THE DATA BYTE BY BYTE */
        DECLARE DRIVE BYTE; /* DRIVE NUMBER: ASSUMES VALUE 0,1 */
        DECLARE IOPB ADDRESS;   /* POINTER TO THE PARAMATER BLOCK NAMED DCB */
        DECLARE DCB BASED IOPB (7) BYTE;

        DECLARE TEMPA(0) ADDRESS;
        DECLARE (TEMP2, TEMP1) BYTE;

        /* RECALIBRATE COMMAND */
        DECLARE RECAL$PB(5) BYTE INITIAL(80H, RECALIBRATE, 0, 0, 0);

        DECLARE I BYTE;     /* INDEX VARIABLE IN FOR STATEMENTS */

        DISABLE;
        RECAL$PB(IOINS) = RECALIBRATE;
        RECAL$PB(SADR) = 0;
        IF DRIVE THEN   /* TRUE IF DRIVE 1 */
        DO;
            DCB(IOINS) = DCB(IOINS) OR 30H;
            DCB(SADR) = DCB(SADR) OR 20H;
            RECAL$PB(IOINS) = RECALIBRATE OR 30H;
            RECAL$PB(SADR) = 20H;
        END;

        DO I = 0 TO MAX$RETRIES;
            DO WHILE (INPUT(FDCC$STATUS$0) AND DISK$DONE) <> 0;
                TEMP1 = INPUT(RESULT$TYPE$0);
                TEMP1 = INPUT(RESULT$BYTE$0);
            END;
            /* IF DISK DRIVE NOT READY, GIVE FATAL ERROR */
            IF (INPUT(FDCC$STATUS$0) AND (DRIVE + 1)) = 0 THEN
                CALL ERR(ABORT, DRIVE$NOT$READY);
            /* START IO */
            OUTPUT(LOW$ADDRESS$0) = LOW(IOPB);
            OUTPUT(HIGH$ADDRESS$0) = HIGH(IOPB);

            DO WHILE (INPUT(FDCC$STATUS$0) AND DISK$DONE) = 0;
                ;
            END;
            TEMP1 = INPUT(RESULT$TYPE$0);
            IF (TEMP2 := INPUT(RESULT$BYTE$0)) = 0 THEN
            DO;
                ENABLE;
                RETURN;
            END;

            OUTPUT(LOW$ADDRESS$0) = LOW(.RECAL$PB);
            OUTPUT(HIGH$ADDRESS$0) = HIGH(.RECAL$PB);

            DO WHILE (INPUT(FDCC$STATUS$0) AND DISK$DONE) = 0;
                ;
            END;
        END;
        FDCC$ERROR$TYPE = TEMPA;
        CALL ERR(ABORT, DISK$IO$ERROR);
    END;


    XIO: PROCEDURE(OPCODE, DRIVE, TRKSEC, BUFFER);
        DECLARE (OPCODE, DRIVE) BYTE, (TRKSEC, BUFFER) ADDRESS;
        DECLARE DCB(10) BYTE INITIAL(80H, 0, 0, 0, 0, 0, 0, 0, 0, 0);

        DCB(IOINS) = OPCODE;
        DCB(NSEC) = 1;
        DCB(TADR) = HIGH(TRKSEC);
        DCB(SADR) = LOW(TRKSEC);
        DCB(BUFLO) = LOW(BUFFER);
        DCB(BUFHI) = HIGH(BUFFER);
        CALL XEQIOPB(DRIVE, .DCB);
    END;

    RDSEC: PROCEDURE(TRKSEC, BUFFER);
         DECLARE (TRKSEC, BUFFER) ADDRESS;
         CALL XIO(CMD$READ, CUR$DEVICE, TRKSEC, BUFFER);
    END;

    WRSEC: PROCEDURE(TRKSEC, BUFFER);
        DECLARE (TRKSEC, BUFFER) ADDRESS;
        CALL XIO(CMD$WRITE, CUR$DEVICE, TRKSEC, BUFFER);
    END;

    DECLARE DEVICENAMES(21) ADDRESS INITIAL (
        'F0','F1','TI','TO','VI','VO','I1','O1','TR','HR',
        'R1','R2','TP','HP','P1','P2','LP','L1','CI','CO','BB');
    DECLARE FULLNAME(15) BYTE;
    DECLARE (PN, PN2) (10) BYTE;

    CANON: PROCEDURE(FILENAME, INTFN$P) BYTE;
        DECLARE (FILENAME, INTFN$P) ADDRESS;
        DECLARE PATHCH BASED FILENAME BYTE; /* CHAR OF FILENAME POINTS TO */
        DECLARE PATHCHARS BASED FILENAME (1) BYTE;
        DECLARE INTFN BASED INTFN$P (10) BYTE;  /* BYTE VERSION OF INTFN  */
        DECLARE STARTNAME ADDRESS, STARTCH BASED STARTNAME BYTE;
        DECLARE DEVPAIR(0) ADDRESS, (SECOND, FIRST) BYTE;
        DECLARE (J, I) BYTE;


        ALPHANUM: PROCEDURE BOOLEAN;
            RETURN (PATHCH >= 'A' AND PATHCH <= 'Z')
                OR (PATHCH >= '0' AND PATHCH <= '9');
        END;


        DO I = 0 TO LAST(INTFN);    /* CLEAR INTFN */
            INTFN(I) = 0;
        END;
        DO WHILE PATHCH = ' ';  /* SKIP LEADING SPACE */
            FILENAME = FILENAME + 1;
        END;
        STARTNAME = FILENAME;
        IF PATHCH = ':' THEN
        DO;
            INTFN(0) = 0FFH;
            FIRST = PATHCHARS(1);
            SECOND = PATHCHARS(2);
            IF PATHCHARS(3) <> ':' THEN
                RETURN BAD$PATH;

            DO I =  0 TO LAST(DEVICENAMES);
                IF DEVICENAMES(I) = DEVPAIR(0) THEN 
                    INTFN(0) = I;   /* SAVE DEVICE NUMBER */
            END;
            IF INTFN(0) = 0FFH THEN
                RETURN BAD$DEVICE;
            FILENAME = FILENAME + 4;
        END;

        FIRST = 0;
        DO I = 1 TO 6;
            IF ALPHANUM THEN
            DO;
                INTFN(I) = PATHCH;
                FIRST = 1;
                FILENAME = FILENAME + 1;
            END;
        END;
        IF PATHCH = '.' THEN
        DO;
            FILENAME = FILENAME + 1;
            DO I = 7 TO 9;
                IF ALPHANUM THEN
                DO;
                    INTFN(I) = PATHCH;
                    FILENAME = FILENAME + 1;
                END;
            END;
        END;
        IF INTFN(0) <= F1DEV AND FIRST = 0 THEN
            RETURN NULL$FILENAME;
        J =  -1;
        DO WHILE STARTNAME < FILENAME;
            J = J + 1;
            FULLNAME(J) = STARTCH;
            STARTNAME = STARTNAME + 1;
        END;
        IF FULLNAME(J) = '.' THEN
            RETURN NULL$EXTENSION;
        FULLNAME(J + 1) = ' ';
        IF ALPHANUM  OR PATHCH = '.' OR PATHCH = ':' THEN
            RETURN BAD$PATH;
        RETURN OK;
    END;

    GETFN: PROCEDURE(FILENAME, INTFN$P);
        DECLARE (FILENAME, INTFN$P) ADDRESS;

        IF (STATUS := CANON(FILENAME, INTFN$P)) <> 0 THEN
            CALL ERR(WARNING, STATUS);
    END;


    DECLARE BITMAPBUFFER(256) BYTE,
        CURRENT$BITMAP BYTE INITIAL(0FFH),
        MAP$CHANGE BYTE INITIAL(FALSE),
        BASETRKSEC(0) ADDRESS, (BASESECTOR, BASETRACK) BYTE,
        BITMAPINDEX ADDRESS,
        MAP$DCB(10) BYTE INITIAL(80H, 0, 2, 2, 2, 0, 0, 0, 0, 0),
        BITMASK(8) BYTE INITIAL(80H, 40H, 20H, 10H, 8, 4, 2, 1);

    RWMAP: PROCEDURE(DRIVE, OPCD);
        DECLARE (DRIVE, OPCD) BYTE;

        OPMAP: PROCEDURE;
            MAP$CHANGE = FALSE;
            BITMAPINDEX = 0;
            BASETRKSEC = 1;
            MAP$DCB(IOINS) = OPCD;
            MAP$DCB(BUFLO) = LOW(.BITMAPBUFFER);
            MAP$DCB(BUFHI) = HIGH(.BITMAPBUFFER);
            CALL XEQIOPB(DRIVE, .MAP$DCB);

        END;

        IF DRIVE <> CURRENT$BITMAP THEN
        DO;
            IF OPCD = CMD$WRITE THEN
                RETURN;
            IF CURRENT$BITMAP <> 0FFH AND MAP$CHANGE THEN
            DO;
                OPCD = CMD$WRITE;
                DRIVE = 1 - DRIVE;
                CALL OPMAP;
                OPCD = CMD$READ;
                DRIVE = 1 - DRIVE;
            END;
            CURRENT$BITMAP = DRIVE;
            CALL OPMAP;
        END;
        ELSE IF OPCD = CMD$WRITE THEN
            CALL OPMAP;
    END;


    ALLOCATE: PROCEDURE(DRIVE) ADDRESS;
        DECLARE DRIVE BYTE;
        DECLARE BITNO BYTE;
        DECLARE TRKSEC(0) ADDRESS, (SECTOR, TRACK) BYTE;
        DECLARE BITMAPBYTE$P ADDRESS, BITMAPBYTE BASED BITMAPBYTE$P BYTE;

        CALL RWMAP(DRIVE, CMD$READ);

        DO TRACK = BASETRACK TO 76;
            DO SECTOR = BASESECTOR TO 26;
                BITNO = LOW(BITMAPINDEX) AND 7;
                BITMAPBYTE$P = .BITMAPBUFFER + SHR(BITMAPINDEX, 3);
                IF (BITMASK(BITNO) AND BITMAPBYTE) = 0 THEN /* FOUND A SLOT */
                    DO;
                        MAP$CHANGE = TRUE;
                        BITMAPBYTE = BITMAPBYTE OR BITMASK(BITNO);
                        BASETRKSEC = TRKSEC;
                        RETURN TRKSEC;
                    END;
                BITMAPINDEX = BITMAPINDEX + 1;
            END;
            BASESECTOR = 1;
        END;
        CALL ERR(ABORT, DISK$FULL);
    END;

    DEALLOC: PROCEDURE(DRIVE, TRKSEC);
        DECLARE DRIVE BYTE, TRKSEC ADDRESS;
        DECLARE BITMAPBYTE$P ADDRESS, BITMAPBYTE BASED BITMAPBYTE$P BYTE;
        DECLARE BITNO BYTE;

        CALL RWMAP(DRIVE, CMD$READ);
        IF (BITMAPBYTE$P := HIGH(TRKSEC) * 26 + LOW(TRKSEC) - 1) <
                                                        BITMAPINDEX THEN
        DO;
            BITMAPINDEX = BITMAPBYTE$P;
            BASETRKSEC = TRKSEC;
        END;
        BITNO = LOW(BITMAPBYTE$P) AND 7;
        BITMAPBYTE$P = .BITMAPBUFFER + SHR(BITMAPBYTE$P, 3);
        BITMAPBYTE = BITMAPBYTE AND NOT BITMASK(BITNO);
        MAP$CHANGE = TRUE;
    END;


    DECLARE MAXLL   LITERALLY   '122';  /* MAXIMUM LINE LENGTH */

    DECLARE IOBYTEMASKS DATA(0FFH, 0FFH, 0FCH, 0FCH, 0FCH, 0FCH, 0FCH, 0FCH, 0F3H,
                             0F3H, 0F3H, 0F3H, 0CFH, 0CFH, 0CFH, 0CFH, 3FH, 3FH);

    DECLARE IOBYTEFLAGS DATA(0, 0, 0, 0, 1, 1, 3, 3, 0,
                             4, 8, 0Ch, 0, 10h, 20h,  30h,  80h, 0C0h);

    SIZECK: PROCEDURE;
        IF CUR$BLKNO = CUR$BLKCNT AND CUR$LASTBYTE < CUR$BYTENO THEN
            CUR$LASTBYTE = CUR$BYTENO;
        IF CUR$BLKNO > CUR$BLKCNT THEN
        DO;
            CUR$BLKCNT = CUR$BLKNO;
            CUR$LASTBYTE = CUR$BYTENO;
        END;
    END;


    FIO: PROCEDURE(AFTN, BUFFER, COUNT, ACTUAL$P, READFLAG);
        DECLARE AFTN BYTE, (BUFFER, COUNT, ACTUAL$P) ADDRESS, READFLAG BYTE;
        DECLARE ACTUAL BASED ACTUAL$P ADDRESS;
        DECLARE NEEDWRITE BYTE, (WORK$BUF, NEWLINKS$P) ADDRESS;
        DECLARE NEWLINKS BASED NEWLINKS$P (64) ADDRESS;
        DECLARE BUFCH BASED BUFFER BYTE;

        GETD: PROCEDURE;
            IF CUR$DADDR <> 0 THEN
                RETURN;

            CUR$ALLOC = TRUE;

            CUR$BLKNO = CUR$BLKNO - 1;
            LINKS(CUR$DPTR), CUR$DADDR = ALLOCATE(CUR$DEVICE);
            CUR$BLKNO = CUR$BLKNO + 1;

            IF CUR$ACCESS = 3 THEN
            DO;
                CALL CLRBUF(CUR$DBUF);
                CALL WRSEC(CUR$DADDR, CUR$DBUF);
            END;
        END;


        ACTUAL = 0;

        DO WHILE COUNT > ACTUAL;
            IF CUR$BLKCNT <= CUR$BLKNO AND READFLAG
              AND CUR$BYTENO = CUR$LASTBYTE THEN
                RETURN;
            IF CUR$BYTENO = 128 THEN
            DO;
                CUR$BYTENO = 0;
                IF CUR$DMOD THEN
                DO;
                    CALL WRSEC(CUR$DADDR, CUR$DBUF);
                    CUR$DMOD = FALSE;
                END;
                IF (CUR$DPTR := CUR$DPTR + 1) = 64 THEN
                DO;
                    IF LINKS(FLINK) = 0 THEN
                    DO;
                        LINKS(FLINK) = ALLOCATE(CUR$DEVICE);
                        CUR$ALLOC = TRUE;
                        CALL CLRBUF(CUR$DBUF);
                        NEWLINKS$P = CUR$DBUF;
                        NEWLINKS(0) = CUR$LADDR;    /* SAVE FORWARD LINK */
                        CALL RWMAP(CUR$DEVICE, CMD$WRITE);
                        CALL WRSEC(LINKS(FLINK), CUR$DBUF);
                    END;

                    IF CUR$ALLOC THEN
                    DO;
                        CALL RWMAP(CUR$DEVICE, CMD$WRITE);
                        CALL WRSEC(CUR$LADDR, CUR$LBUF);
                        CUR$ALLOC = FALSE;
                    END;
                    CUR$LADDR = LINKS(FLINK);
                    CALL RDSEC(CUR$LADDR, CUR$LBUF);
                    CUR$DPTR = 2;
                END;

                CUR$BLKNO = CUR$BLKNO + 1;
                CUR$DADDR = LINKS(CUR$DPTR);

                IF (NEEDWRITE := COUNT - ACTUAL >= 128 AND
                   (NOT READFLAG OR CUR$BLKNO < CUR$BLKCNT)) THEN
                DO;
                    ACTUAL = ACTUAL + (CUR$BYTENO := 128);
                    WORK$BUF = BUFFER;
                    BUFFER = BUFFER + 128;
                END;
                ELSE
                    WORK$BUF = CUR$DBUF;

                IF READFLAG THEN
                DO;
                    IF CUR$DADDR = 0 THEN
                        CALL CLRBUF(WORK$BUF);
                    ELSE
                        CALL RDSEC(CUR$DADDR, WORK$BUF);
                END;
                ELSE
                DO;
                    CALL GETD;
                    IF NEEDWRITE THEN
                        CALL WRSEC(CUR$DADDR, WORK$BUF);
                    ELSE IF CUR$ACCESS = UPDATE$MODE THEN
                        CALL RDSEC(CUR$DADDR, WORK$BUF);
                END;
            END;

            IF CUR$BYTENO <> 128 THEN
            DO;
                IF READFLAG THEN
                    BUFCH = DATUM(CUR$BYTENO);
                ELSE
                DO;
                    CALL GETD;
                    DATUM(CUR$BYTENO) = BUFCH;
                    CUR$DMOD = TRUE;
                END;
                CUR$BYTENO = CUR$BYTENO + 1;
                BUFFER = BUFFER + 1;
                ACTUAL = ACTUAL + 1;
            END;
        END; /* OF DO WHILE */
        CALL SIZECK;
    END;


    SETDEV: PROCEDURE;
        /*
           SET LOGICAL FILE ASSIGNMENTS TO USE MONITOR ROUTINES
           FOR DOING BYTE AT A TIME I/O DEVICES
        */
        CALL IOSET((IOCHK AND IOBYTEMASKS(CUR$DEVICE))
                    OR IOBYTEFLAGS(CUR$DEVICE));
    END;


    READ: PROCEDURE(AFT, BUFFER, COUNT, ACTUAL$P) ;
        DECLARE AFT BYTE, (BUFFER, COUNT, ACTUAL$P) ADDRESS;
        DECLARE ACTUAL BASED ACTUAL$P ADDRESS;
        DECLARE CH BASED BUFFER BYTE;
        DECLARE READCASE(18) BYTE INITIAL(0, 0, 1, 0FFH, 1, 0FFH, 1,
                          0FFH, 2, 2, 2, 2, 0FFH, 0FFH, 0FFH, 0FFH, 0FFH, 0FFH);

        ACTUAL = 0;
        CALL SETTABS(AFT);

        IF (CUR$ACCESS AND 1) = 0 THEN    /* NOT READ */
            CALL ERR(WARNING, CANT$READ);

        CALL SETDEV;
        IF CUR$DEVICE <= F1DEV THEN
            CALL FIO(AFT, BUFFER, COUNT, ACTUAL$P, TRUE);
        ELSE
        DO WHILE 1;
            IF ACTUAL = COUNT THEN
                RETURN;
            IF READCASE(CUR$DEVICE) THEN
                CH = CI;
            ELSE
            DO;
                CH = RI;
                IF CARRY THEN
                    RETURN;
            END;
            BUFFER = BUFFER + 1;
            ACTUAL = ACTUAL + 1;
        END;
    END;

    WRITE: PROCEDURE(AFT, BUFFER, COUNT);
        DECLARE AFT BYTE, (BUFFER, COUNT) ADDRESS;
        DECLARE CH BASED BUFFER BYTE;
        DECLARE ACTUAL ADDRESS;
        DECLARE WRITECASE(18) BYTE INITIAL(0, 0, 0FFH, 1, 0FFH, 1,
                                      0FFH, 1, 0FFH, 0FFH, 0FFH, 0FFH, 2, 2,
                                      2, 2, 3, 3);

        IF AFT = 0FFH THEN
            RETURN;
        CALL SETTABS(AFT);
        IF (CUR$ACCESS AND 2) = 0 OR CUR$CLOSED THEN
            CALL ERR(WARNING, CANT$WRITE);

        CALL SETDEV;

        DO WHILE COUNT <> 0;
            DO CASE WRITECASE(CUR$DEVICE);
            DO;     /* CASE 0 */
                CALL FIO(AFT, BUFFER, COUNT, .ACTUAL, FALSE);
                RETURN;
            END;
            DO;     /* CASE 1 */
                CALL CO(CH);
            END;
            CALL PO(CH);        /* CASE 2 */
            CALL LO(CH);        /* CASE 3 */
            END;

            COUNT = COUNT - 1;
            BUFFER = BUFFER + 1;
        END;
    END;



    EDIT: PROCEDURE(AFT, BUFFER, COUNT, ACTUAL$P);
        DECLARE AFT BYTE, (BUFFER, COUNT, ACTUAL$P) ADDRESS;
        DECLARE ACTUAL BASED ACTUAL$P ADDRESS;
        DECLARE LINE$P ADDRESS,
            IN$MODE BYTE,
            LPTR BYTE,
            CHAR BYTE,
            I BYTE,     /* NOTE READ CLOBBERS SELECTOR AS WELL */
            SELECTOR BYTE;
        DECLARE OBUF BASED BUFFER (1) BYTE;
        DECLARE BYTES BASED LINE$P (128) BYTE;
        DECLARE ADDR BASED LINE$P (64) ADDRESS;
        DECLARE SPECIALCHARS(8) BYTE INITIAL(0, DELKEY, CONTROL$Z, CONTROL$R,
                                 CONTROL$X, CR, LF, ESC);


        ECHO: PROCEDURE(CHAR);      /* NESTED SUB OF EDIT */
            DECLARE CHAR BYTE;
            CALL WRITE(CUR$ECHOAFT, .CHAR, 1);
            CALL SETTABS(AFT);
        END;

        LINE$P = EBUF(AFT);
        LPTR = BYTES(126);
        IN$MODE = BYTES(127);

        DO WHILE IN$MODE;
            CALL READ(AFT, .CHAR, 1, .I);
            BYTES(125) = FALSE;
            CHAR = CHAR AND 7FH;
            IF I = 0 THEN
            DO;
                IF AFT = AFT$CONSOL$IN THEN
                    CALL ERR(ABORT, CONSOLE$EOF);
                CHAR = CONTROL$Z;
            END;
            IF CHAR <> LF THEN
                CALL ECHO(BYTES(LPTR) := CHAR);

            SELECTOR = 0;
            DO I = 0 TO LAST(SPECIALCHARS);
                IF CHAR = SPECIALCHARS(I) THEN
                    SELECTOR = I;
            END;
            DO CASE SELECTOR;
                LPTR = LPTR + 1;    /* CASE 0 - NORMAL */
                DO;         /* CASE 1, RUBOUT */
                    IF LPTR <> 0 THEN
                    DO;
                        CALL ECHO(BYTES(LPTR := LPTR - 1));
                    END;
                    ELSE
                        CALL ECHO(BELL);
                END;
                DO;         /* CASE 2 - CONTROL-Z */
                    ACTUAL = 0;
                    BYTES(125) = TRUE;
                    ADDR(63) = 0FF00H;
                    CALL ECHO(CR);
                    CALL ECHO(LF);
                    RETURN;
                END;
                DO;         /* CASE 3 - CONTROL-R */
                    CALL ECHO(CR);
                    CALL ECHO(LF);
                    CALL WRITE(ECHOAFT(AFT), LINE$P, LPTR);
                END;
                DO;         /* CASE 4 - CONTROL-X */
                    LPTR = 0;
                    CALL ECHO(HASH);
                    CALL ECHO(CR);
                    CALL ECHO(LF);
                END;
                DO;         /* CASE 5 - CR */
                    BYTES(LPTR := LPTR + 1) = LF;
                    CALL ECHO(LF);
                    IN$MODE = FALSE;
                    LPTR = 0;
                END;
                DO;         /* CASE 6 - LF */
                    IF LPTR <> 0 THEN
                    DO;
                        CALL ECHO(BYTES(LPTR) := CHAR);
                        IN$MODE = FALSE;
                        LPTR = 0;
                    END;
                END;
                DO;         /* CASE 7 -  ESC */
                    CALL ECHO(0);
                    CALL ECHO('$');
                    IN$MODE = FALSE;
                    LPTR = 0;
                END;
            END; /* OF CASE */
            IF LPTR = 122 THEN
            DO;
                IN$MODE = FALSE;
                LPTR = 0;
            END;
        END;

        ACTUAL = 0;
        DO WHILE ACTUAL < COUNT AND NOT IN$MODE;
            IF LPTR < MAXLL THEN    /* 122 */
            DO;
                IF (OBUF(ACTUAL) := BYTES(LPTR)) = LF OR BYTES(LPTR) = ESC THEN
                DO;
                    IN$MODE = TRUE;
                    LPTR = -1;
                END;

                ACTUAL = ACTUAL + 1;
                LPTR = LPTR + 1;
            END;
            ELSE
            DO;
                IN$MODE = TRUE;
                LPTR = 0;
            END;
        END;
        BYTES(126) = LPTR;
        BYTES(127) = IN$MODE;
    END;


    RESCAN: PROCEDURE(AFTN);
        DECLARE AFTN BYTE;
        DECLARE BUF$P ADDRESS, BYTES BASED BUF$P(128) BYTE,
                      ADDR BASED BUF$P(64) ADDRESS;

        CALL SETTABS(AFTN);
        BUF$P = CUR$EBUF;
        IF CUR$ECHOAFT = 0 OR BYTES(125) THEN
            CALL ERR(WARNING, CANT$RESCAN);
        ADDR(63) = 0;   /* LPTR = 0, IN$MODE = FALSE */
    END;

    REWIND: PROCEDURE;
        CUR$BYTENO = 128;
        CUR$DPTR = 1;
        CUR$BLKNO = 0;
        CUR$ALLOC = 0;
        CUR$DMOD = 0;
        CUR$DADDR = 0;
        CALL RDSEC(CUR$LADDR := CUR$L1ADDR, CUR$LBUF);
    END;




    SEEK: PROCEDURE(AFT, MODE, BLOCKNO$P, BYTENO$P);
        DECLARE AFT BYTE, (MODE, BLOCKNO$P, BYTENO$P) ADDRESS;
        DECLARE BLOCKNO BASED BLOCKNO$P ADDRESS, BYTENO BASED BYTENO$P ADDRESS;
        DECLARE LOWMODE BYTE, BYTLO(0) BYTE, (BYT, BLK) ADDRESS;
        DECLARE BACKWARDS BYTE;
        DECLARE BYTENOSTEP(2) BYTE INITIAL(128, 1);
        DECLARE BLKNOSTEP(2) ADDRESS INITIAL(1, 0FFFFH);
        DECLARE NEXT ADDRESS;

        OFFEND: PROCEDURE(BLKNUMA, BLKNUMB, BYTENUMA, BYTENUMB) BOOLEAN;
            DECLARE (BLKNUMA, BLKNUMB) ADDRESS, (BYTENUMA, BYTENUMB) BYTE;

            BYTENUMA = BYTENUMA + LOW(BYT);
            BLKNUMA = (ROL(BYTENUMA, 1) AND 1) + BLK + BLKNUMA;
            BYTENUMA = BYTENUMA AND 7FH;
            BLKNUMB = BLKNUMB + (ROL(BYTENUMB, 1) AND 1);
            BYTENUMB = BYTENUMB AND 7FH;
            IF BLKNUMA <> BLKNUMB THEN
                RETURN BLKNUMB < BLKNUMA;
            RETURN BYTENUMB < BYTENUMA;

        END;

        BYT = BYTENO;
        BLK = BLOCKNO;

        IF MODE > SEEK$EOF THEN
            CALL ERR(WARNING, BAD$SEEK$ARG);

        CALL SETTABS(AFT);

        IF CUR$DEVICE > F1DEV THEN
            CALL ERR(WARNING, NON$DISK$SEEK);

        IF CUR$ACCESS = WRITE$MODE THEN
            CALL ERR(WARNING, SEEK$ON$WRITE);

        IF (LOWMODE := MODE) = SEEK$RETURN THEN
        DO;
            BYTENO = CUR$BYTENO;
            IF (BLOCKNO := CUR$BLKNO - 1) = 0FFFFH THEN
            DO;
                BLOCKNO, BYTENO = 0;
            END;
            RETURN;
        END;

        IF CUR$DMOD THEN
            CALL WRSEC(CUR$DADDR, CUR$DBUF);

        IF CUR$ALLOC THEN
        DO;
            CALL RWMAP(CUR$DEVICE, CMD$WRITE);
            CALL WRSEC(CUR$LADDR, CUR$LBUF);
        END;

        CUR$DMOD = 0;
        CUR$ALLOC = 0;

        IF LOWMODE = SEEK$EOF THEN
        DO;
            LOWMODE = SEEK$ABS;
            BYT = CUR$LASTBYTE;
            IF (BLK := CUR$BLKCNT - 1) = 0FFFFH THEN
                BLK, BYT = 0;
        END;
        IF LOWMODE = SEEK$ABS THEN
            CALL REWIND;

        BACKWARDS = (LOWMODE = 1) AND 1;
        BLK = (BLK AND 07FFFH) + SHR(BYT, 7);
        BYTLO = (BYTLO AND 7FH);
        IF NOT BACKWARDS THEN
        DO;
            IF (CUR$ACCESS = 1) AND OFFEND(CUR$BLKNO, CUR$BLKCNT,
                                         CUR$BYTENO, CUR$LASTBYTE) THEN
                CALL ERR(WARNING, SEEK$PAST$EOF);
        END;
        ELSE IF OFFEND(1, CUR$BLKNO, 0, CUR$BYTENO) THEN
                CALL ERR(WARNING, LONG$BACK$SEEK);

        DO WHILE BYTLO > 0;
            BYTLO = BYTLO - 1;
            IF CUR$BYTENO = BYTENOSTEP(BACKWARDS) THEN
            DO;
                CUR$BYTENO = BYTENOSTEP(1 - BACKWARDS);
                BLK = BLK + 1;
            END;
            ELSE
            DO;
                CUR$BYTENO = CUR$BYTENO + BLKNOSTEP(BACKWARDS);
            END;
            IF NOT BACKWARDS THEN
                CALL SIZECK;
        END;
        DO WHILE BLK > 0;
            BLK = BLK - 1;
            IF NOT BACKWARDS THEN
            DO;
                IF CUR$DPTR = 63 THEN
                DO;
                    CUR$DPTR = 1;
                    IF (NEXT := LINKS(FLINK)) = 0 THEN
                    DO;
                        LINKS(FLINK), NEXT = ALLOCATE(CUR$DEVICE);
                        CALL RWMAP(CUR$DEVICE, CMD$WRITE);
                        CALL WRSEC(CUR$LADDR, CUR$LBUF);
                        CALL CLRBUF(CUR$LBUF);
                        LINKS(BLINK) = CUR$LADDR;
                        CALL WRSEC(NEXT, CUR$LBUF);
                        CUR$LADDR = NEXT;
                    END;
                    ELSE
                        CALL RDSEC((CUR$LADDR := NEXT), CUR$LBUF);
                END;
                CUR$DPTR = CUR$DPTR + 1;
            END;
            ELSE IF (CUR$DPTR := CUR$DPTR - 1) < 2 THEN
                IF LINKS(BLINK) <> 0 THEN
                DO;
                    CUR$DPTR = 63;
                    CALL RDSEC(CUR$LADDR := LINKS(BLINK), CUR$LBUF);
                END;
            CUR$BLKNO = CUR$BLKNO + BLKNOSTEP(BACKWARDS);
        END;
        IF CUR$DADDR <> LINKS(CUR$DPTR) THEN
            IF (CUR$DADDR := LINKS(CUR$DPTR)) = 0 THEN
                CALL CLRBUF(CUR$DBUF);
            ELSE
                CALL RDSEC(CUR$DADDR, CUR$DBUF);
        CALL SIZECK;
    END;

    SYNC: PROCEDURE;
        CALL WRSEC(CUR$DADDR, CUR$DBUF);
    END;

    DECLARE DIRECT$EMPTY BYTE, DIRECT$FILE(9) BYTE, DIRECT$ATTRIB BYTE,
            DIRECT$EOF$COUNT BYTE, DIRECT$BLK ADDRESS, DIRECT$HDR$BLK ADDRESS;
    DECLARE DIRECT$INO BYTE;

    SEARCH: PROCEDURE(INTFN$P) BOOLEAN;
        DECLARE INTFN$P ADDRESS;
        DECLARE INTFN BASED INTFN$P (12) BYTE;
        DECLARE RCOUNT ADDRESS;
        DECLARE BLOCKNO ADDRESS INITIAL(0);
        DECLARE BYTENO ADDRESS;
        DECLARE (I, AFT) BYTE;
        DECLARE DNUM ADDRESS;
        DECLARE RETURN$VALUE BOOLEAN;
        /*
          THIS PROCEDURE IS USED TO LOOKUP A FILE NAME IN A
          DISK DIRECTORY. THE DEVICE NUMBER OF THE DISK
          IS CONTAINED IN FN(0), THE SIX CHARACTERS OF THE
          FILE NAME ARE IN FN(1) THROUGH FN(6), AND THE
          THREE CHARACTERS OF THE FILE EXTENSION ARE IN
          FN(7) THROUGH FN(9)

          THE PROCEDURE RETURNS 'TRUE' IF THE FILE IS FOUND,
          WITH DIRECT$I$NO POINTING TO THE ENTRY OF THE FILE IN THE
          DIRECTORY

          OTHERWISE, THE PROCEDURE RETURNS 'FALSE', AND DIRECT$I$NO POINTS
          AT A BLANK SLOT IN THE DIRECTORY. THE DIRECTORY MARKER IS
          ADJUSTED SO TAHT IT POINTS AT THE BEGINNING OF THE ENTRY
          POINTED TO BY DIRECT$I$NO.

          IF THE DIRECTORY IS FULL, DIRECT$I$NO = 0FFH
        */
        DBUF(AFT := CUR$DEVICE + 0) = GETBUF;
        LBUF(AFT) = GETBUF;
        CALL SETTABS(AFT);
        CALL REWIND;
        DIRECT$I$NO = 0FFH;
        DNUM = 0;
        RCOUNT = 1;
        DIRECT$EMPTY, RETURN$VALUE = 0;

        DO WHILE RCOUNT <> 0 AND DIRECT$EMPTY <> 7FH;
            CALL READ(AFT, .DIRECT$EMPTY, 16, .RCOUNT);
            IF DIRECT$EMPTY THEN
            DO;
                IF DIRECT$I$NO = 0FFH THEN
                    DIRECT$I$NO = DNUM;
            END;
            ELSE
            DO;
                DO I = 1 TO 9;
                    IF INTFN(I) <> DIRECT$FILE(I - 1) THEN
                    GOTO SKIP;
                END;
                DIRECT$I$NO = DNUM;
                RETURN$VALUE = 0FFH;
                RCOUNT = 0;
            END;
    SKIP:
            DNUM = DNUM + 1;
        END;

        IF DIRECT$I$NO <> 0FFH THEN
        DO;
            BYTENO = DIRECT$I$NO * 16;      /* SIZE OF DIRECT ENTRY */
            CALL SEEK(AFT, SEEK$ABS, .BLOCKNO, .BYTENO);
        END;
        CALL FREE$BUF(CUR$DBUF);
        CALL FREE$BUF(CUR$LBUF);
        RETURN RETURN$VALUE;
    END;


    ATTRIB: PROCEDURE(FILENAME, SWID, VALUE);
        DECLARE (FILENAME, SWID) ADDRESS, VALUE BYTE;
        DECLARE MASK(4) BYTE INITIAL(INVISIBLE$ATTRIBUTE,
                                       SYSTEM$ATTRIBUTE,
                                       WRITEP$ATTRIBUTE,
                                       FORMAT$ATTRIBUTE);

        IF SWID > 3 THEN
            CALL ERR(WARNING, BAD$ATTRIB);
        CALL GETFN(FILENAME, .PN);
        IF PN(0) > F1DEV THEN
            CALL ERR(WARNING, BAD$PATH);
        CALL SETTABS(PN(0));
        IF NOT SEARCH(.PN) THEN
            CALL ERR(WARNING, NO$SUCH$FILE);

        DIRECT$ATTRIB = DIRECT$ATTRIB OR MASK(LOW(SWID));
        IF NOT VALUE THEN
            DIRECT$ATTRIB = DIRECT$ATTRIB AND (NOT MASK(LOW(SWID)));
        CALL WRITE(PN(0), .DIRECT$EMPTY, 16);
        CALL SYNC;
    END;


    CLOSE: PROCEDURE(AFT);
        DECLARE AFT BYTE;
        DECLARE BLKZERO ADDRESS INITIAL(0), BYTNO ADDRESS INITIAL(0);
        DECLARE I BYTE;   /* READ RETURNS AN ADDRESS BUT HIGH BYTE WILL BE 0 */
        DECLARE CLOSECASE(21) BYTE INITIAL(0,0,       /* F0-F1 */
              1,2,1,2,1,2,1,1,1,1,  /* TI, TO, VI, VO, I1, O1, TR, HR, R1, R2 */
              3,3,3,3,4,4,0,0,0);   /* TP, HP, P1, P2, LP, L1, CI, CO, BB */

        CALL SETTABS(AFT);
        IF CUR$CLOSED THEN
            RETURN;
        IF CUR$ECHOAFT <> 0 THEN
            CALL FREE$BUF(CUR$EBUF);
        DO CASE CLOSECASE(CUR$DEVICE);
            DO; /* 0 - DISK OR CI,CO,BB */
                IF CUR$DMOD THEN
                    CALL WRSEC(CUR$DADDR, CUR$DBUF);
                IF CUR$ALLOC THEN
                    CALL WRSEC(CUR$LADDR, CUR$LBUF);

                CALL FREE$BUF(CUR$LBUF);
                CALL FREE$BUF(CUR$DBUF);
                IF CUR$ACCESS >= 2 THEN
                DO;
                    CALL SIZECK;
                    BLKZERO = 0;
                    CALL RWMAP(CUR$DEVICE, CMD$WRITE);
                    /* LET DEVICE USE RETURNED BUFFERS */
                    DBUF(CUR$DEVICE) = CUR$DBUF;
                    LBUF(CUR$DEVICE) = CUR$LBUF;
                    CALL SETTABS(CUR$DEVICE);
                    CALL REWIND;                 /* GET TO DIR HEADER */
                    BYTNO = 16 * DNUM(AFT);
                    /* SEEK TO FILE ENTRY */
                    CALL SEEK(CUR$DEVICE, SEEK$ABS, .BLKZERO, .BYTNO);
                    /* READ THE DIR ENTRY */
                    CALL READ(CUR$DEVICE, .DIRECT$EMPTY, 16, .I);
                    DIRECT$EOF$COUNT = LASTBYTE(AFT);
                    DIRECT$BLK = BLKCNT(AFT);
                    BYTNO = 16;
                    CALL SEEK(CUR$DEVICE, 1, .BLKZERO, .BYTNO);
                    CALL WRITE(CUR$DEVICE, .DIRECT$EMPTY, 16);
                    CALL SYNC;
                END;
            END;
            ;   /* 1 */
            CALL WRITE(AFT, .(CR, LF), 2);   /* 2 */
            DO I = 0 TO 119;    /* 3 OUTPUT 120 NULLS */
                CALL WRITE(AFT, .(0), 1);
            END;
            ;   /* 4 */
        END;
        CLOSED(AFT) = TRUE;
    END;


    RENAME: PROCEDURE(OLD$NAME, NEW$NAME);
        DECLARE (OLD$NAME, NEW$NAME) ADDRESS;
        DECLARE I BYTE;
        DECLARE ALREADY$EXISTS BOOLEAN;


        CALL GETFN(OLD$NAME, .PN2);
        CALL GETFN(NEW$NAME, .PN);
        IF PN(0) > F1DEV THEN
            CALL ERR(WARNING, NON$DISK$FILE);
        IF PN(0) <> PN2(0) THEN
            CALL ERR(WARNING, DIFFERENT$DISK);
        CALL SETTABS(PN(0));
        /* IF NEW$NAME ALREADY EXISTS AND OLD$NAME DOES NOT EXISTI,
           THEN WE WANT OT GIVE THE OLD$NAME ERROR MESSAGE.
           HOWEVER, SEARCH(NEW$NAME) SHOULD PRECEDE SEARCH(OLD$NAME)
           THIS IS BECAUSE POINTER VARIABLES SHOULD BE LEFT POINTING TO
           THE OLD FILE UPON EXIT FROM THIS PROCEDURE */
        ALREADY$EXISTS = SEARCH(.PN);
        IF NOT SEARCH(.PN2) THEN
            CALL ERR(WARNING, NO$SUCH$FILE);
        IF (DIRECT$ATTRIB AND (WRITEP$ATTRIBUTE OR FORMAT$ATTRIBUTE)) <> 0 THEN
            CALL ERR(WARNING, WRITE$PROTECT);
        IF ALREADY$EXISTS THEN
            CALL ERR(WARNING, MULTIDEFINED);
        DO I = 0 TO 8;
            DIRECT$FILE(I) = PN(I + 1);
        END;
        CALL WRITE(CUR$DEVICE + 0, .DIRECT$EMPTY, 16);
        CALL SYNC;
    END;

    SCRATCH: PROCEDURE(DRIVE);
        DECLARE DRIVE BYTE;
        DECLARE (AFT, I) BYTE;
        DECLARE BLOCKNO ADDRESS INITIAL (0);
        DECLARE BYTENO ADDRESS INITIAL(16 /* SIZE DIRECTORY ENTRY */);
        DECLARE LINKBUF$P ADDRESS, LINKBUF BASED LINKBUF$P (64) ADDRESS;

        /* INTERNAL DELETE ROUTING
        DRIVE = F0DEV .. F1DEV
        DIRECT MUST CONTAIN THE DIRECTORY ENTRY FOR AN EXISTING FILE OR DISK.
        AFT SLOT FOR THE APPROPRIATE DIRECTORY MUST HAVE BUFFERS;
        AND THESE BUFFERS MUST BE SETUP FOR DIRECTORY READING AND
        WRITING. THESE BUFFERS WILL BE CLOBBERED
        */
        DIRECT$EMPTY = TRUE;
        CALL SETTABS(AFT := DRIVE + 0);
        CALL WRITE(AFT, .DIRECT$EMPTY, 16);
        CALL XIO(CMD$WRITE, DRIVE, CUR$DADDR, CUR$DBUF);
        CALL SEEK(AFT, SEEK$BACKWARD, .BLOCKNO, .BYTENO);
        LINKBUF$P = CUR$DBUF;    /* LIST OF BLOCKS TO DELETE */
        DO WHILE DIRECT$HDR$BLK <> 0;
            CALL DEALLOC(DRIVE, DIRECT$HDR$BLK);
            CALL XIO(CMD$READ, DRIVE, DIRECT$HDR$BLK, LINKBUF$P);
            DIRECT$HDR$BLK = LINKBUF(FLINK);
            DO I = 2 TO 63;
                IF LINKBUF(I) <> 0 THEN
                    CALL DEALLOC(DRIVE, LINKBUF(I));
            END;
        END;
        CALL XIO(CMD$READ, DRIVE, CUR$DADDR, CUR$DBUF);
        CALL RWMAP(DRIVE, CMD$WRITE);
    END;


    DELETE: PROCEDURE(FILENAME);
        DECLARE FILENAME ADDRESS;
        DECLARE I BYTE;

        CALL GETFN(FILENAME, .PN);
        IF PN(0) > F1DEV THEN
            CALL ERR(WARNING, NON$DISK$FILE);
        ELSE
            CALL SETTABS(PN(0));
        IF SEARCH(.PN) THEN
        DO;
            IF (DIRECT$ATTRIB
              AND (WRITEP$ATTRIBUTE OR FORMAT$ATTRIBUTE)) = 0 THEN
            DO;
                DO I = AFT$BOTTOM TO AFT$LAST;
                    IF (NOT CLOSED(I))
                        AND (DEVICE(I) = PN(0)) AND (DNUM(I) = DIRECT$INO) THEN
                        CALL ERR(WARNING, CANT$DELETE);
                END;
                CALL SCRATCH(PN(0));
            END;
            ELSE
                CALL ERR(WARNING, WRITE$PROTECT);
        END;
        ELSE
            CALL ERR(WARNING, NO$SUCH$FILE);
    END;

    DECLARE ACCESS$SUPPORT DATA(3, 3, 1, 2, 1, 2,
                                1, 2, 1, 1, 1, 1, 2, 2,
                                2, 2, 2, 2, 1, 2);
    OPEN: PROCEDURE(FILENAME, INACCESS, ECHOAFT) BYTE;
        DECLARE (FILENAME, INACCESS, ECHOAFT) ADDRESS;
        DECLARE (AFT, REQACCESS, FOUND, TEMP, I) BYTE;
        DECLARE BUF$P ADDRESS, BYTES BASED BUF$P (128) BYTE,
                              ADDR BASED BUF$P (64) ADDRESS;

        FREE1: PROCEDURE(ERRNUM);
            DECLARE ERRNUM BYTE;

            IF CUR$ECHOAFT <> 0 THEN
                CALL FREE$BUF(CUR$EBUF);
            CALL ERR(WARNING, ERRNUM);
        END;

        FREE3: PROCEDURE(ERRNUM);
            DECLARE ERRNUM BYTE;

            CALL FREE$BUF(CUR$DBUF);
            CALL FREE$BUF(CUR$LBUF);
            CALL FREE1(ERRNUM);
        END;

        IF INACCESS > 3 OR (REQACCESS := INACCESS) = 0 THEN
            CALL ERR(WARNING, BAD$ACCESS);
        CALL GETFN(FILENAME, .PN);
        IF PN(0) = 20 THEN
            RETURN 0FFH;
        IF PN(0) = 0FFH THEN
                CALL ERR(WARNING, BAD$DEVICE);
        IF (ACCESS$SUPPORT(PN(0)) AND REQACCESS) = 0 THEN
                CALL ERR(WARNING, BAD$ACCESS);

        IF PN(0) = CIDEV THEN
            RETURN AFT$CONSOL$IN - AFT$BOTTOM;
        IF PN(0) = CODEV THEN
            RETURN AFT$CONSOL$OUT - AFT$BOTTOM;

        CALL SETTABS(AFT := GETAFT);
        CUR$ACCESS = REQACCESS;
        CUR$ECHOAFT = 0;
        IF ECHOAFT <> 0 THEN
        DO;
            CUR$ECHOAFT = AFT$BOTTOM + LOW(ECHOAFT);
            IF CUR$ECHOAFT < 2 THEN
                CUR$ECHOAFT = 0FFH;
            ELSE IF ACCESS(CUR$ECHOAFT) <> WRITE$MODE
              OR (CUR$ECHOAFT  >  10) THEN
                CALL ERR(WARNING, BAD$ECHO);

            BUF$P, CUR$EBUF = GET$BUF;
            BYTES(0) = LF;
            ADDR(63) = 0FF00H;
            BYTES(125) = TRUE;
        END;

        IF (CUR$DEVICE := PN(0)) <= F1DEV THEN
        DO;
            FOUND = SEARCH(.PN);
            CALL SETTABS(AFT);
            IF FOUND THEN
                DO I = AFT$BOTTOM TO AFT$LAST;
                    IF NOT CLOSED(I) THEN
                        IF DNUM(I) = DIRECT$I$NO AND DEVICE(I) = PN(0) THEN
                            CALL FREE1(ALREADY$OPEN);
                END;
            CUR$DNUM = DIRECT$I$NO;
            CUR$DBUF = GET$BUF;
            CUR$LBUF = GET$BUF;
            IF REQACCESS = 1 THEN
            DO;
                IF NOT FOUND THEN
                    CALL FREE3(NO$SUCH$FILE);
                CUR$L1ADDR = DIRECT$HDR$BLK;
                CUR$BLKCNT = DIRECT$BLK;
                CUR$LASTBYTE = DIRECT$EOF$COUNT;
                CALL REWIND;
            END;
            ELSE
            DO;
                IF NOT FOUND THEN
                DO;
                    IF DIRECT$I$NO = 0FFH THEN
                        CALL FREE3(DIRECTORY$FULL);
                    DIRECT$BLK = 0;
                    DIRECT$EOF$COUNT = 128;
                    DIRECT$ATTRIB = 0;
                END;
                IF (DIRECT$ATTRIB AND (WRITEP$ATTRIBUTE
                                       OR FORMAT$ATTRIBUTE)) <> 0 THEN
                    CALL FREE3(WRITE$PROTECT);

                IF REQACCESS = 2 AND FOUND THEN
                DO;
                    CALL SCRATCH(CUR$DEVICE);
                    CALL SETTABS(AFT);
                    DIRECT$BLK = 0;
                    DIRECT$EOF$COUNT = 128;
                END;
                CUR$LASTBYTE = DIRECT$EOF$COUNT;
                CUR$BLKCNT = DIRECT$BLK;
                IF NOT (TEMP := REQACCESS = 3 AND FOUND) THEN
                DO;
                    DIRECT$HDR$BLK = ALLOCATE(CUR$DEVICE);
                END;
                CUR$L1ADDR = DIRECT$HDR$BLK;
                DIRECT$EMPTY = 0;
                DO I = 0 TO 8;
                    DIRECT$FILE(I) = PN(I + 1);
                END;
                IF REQACCESS = 3 AND NOT FOUND THEN
                    DIRECT$ATTRIB = 0;
                CALL WRITE(CUR$DEVICE, .DIRECT$EMPTY, 16);
                CALL SYNC;

                CALL SETTABS(AFT);
                CALL REWIND;
                IF NOT TEMP THEN
                DO;
                    CALL CLRBUF(CUR$LBUF);
                    CALL RWMAP(CUR$DEVICE, CMD$WRITE);
                    CALL WRSEC(CUR$L1ADDR, CUR$LBUF);
                END;
            END;
        END;
        ELSE
        DO;
            DO I = AFT$BOTTOM TO AFT$LAST;
                IF NOT CLOSED(I) THEN
                    IF CUR$DEVICE = DEVICE(I) THEN
                        CALL FREE1(ALREADY$OPEN);
            END;
            IF CUR$DEVICE >= 12 AND CUR$DEVICE <= 15 THEN
                DO I = 1 TO 120;
                    CUR$CLOSED = FALSE;
                    CALL WRITE(AFT, .(0), 1);
                END;
        END;
        CUR$CLOSED = FALSE;
        RETURN AFT - AFT$BOTTOM;
    END;



    DECLARE CUR$CONSOL$IN(15) BYTE,
            CUR$CONSOL$OUT(15) BYTE;



    CONSOL: PROCEDURE(INFILE, OUTFILE);
        DECLARE (INFILE, OUTFILE) ADDRESS;
        DECLARE INSTRING BASED INFILE BYTE,
            OUTSTRING BASED OUTFILE BYTE;
        DECLARE COLD$CONSOL$IN(5)  BYTE INITIAL(': I: '),
                COLD$CONSOL$OUT(5) BYTE INITIAL(': O: ');
        DECLARE TEMP BYTE;
        DECLARE TDRV(2) BYTE INITIAL('TV'); /* T OR V IS 1ST LETTER OF NAME */

        IF COLD$START$FLAG THEN
        DO;
          COLD$START$FLAG = FALSE;
          COLD$CONSOL$IN(1), COLD$CONSOL$OUT(1) = TDRV(INITIO AND 1);
          INFILE = .COLD$CONSOL$IN;
          OUTFILE = .COLD$CONSOL$OUT;
        END;

        GLOBAL$SEVERITY = ABORT;
        CALL GETFN(OUTFILE, .PN);
        IF PN(0) = BBDEV THEN
            CALL ERR(WARNING, BAD$ECHO);
        IF PN(0) <> CODEV THEN
        DO;
            CALL CLOSE(AFT$CONSOL$OUT);
            TEMP = OPEN(OUTFILE, WRITE$MODE, FALSE);
            DO TEMP = 0 TO 14;
                CUR$CONSOL$OUT(TEMP) = FULLNAME(TEMP);
            END;
        END;
        CALL GETFN(INFILE, .PN);
        IF PN(0) = BBDEV THEN
            CALL ERR(ABORT, CONSOLE$EOF);
        IF PN(0) <> CIDEV THEN
        DO;
            CALL CLOSE(AFT$CONSOL$IN);
            TEMP = OPEN(INFILE, READ$MODE, 100H);
            DO TEMP = 0 TO 14;
                CUR$CONSOL$IN(TEMP) = FULLNAME(TEMP);
            END;
        END;
    END;


    WHOCON: PROCEDURE(AFT, BUFFER$P);
        DECLARE AFT BYTE;
        DECLARE BUFFER$P ADDRESS, BUFFER BASED BUFFER$P (1) BYTE;
        DECLARE NAME$P ADDRESS, NAME BASED NAME$P (1) BYTE;
        DECLARE I BYTE;

        IF AFT THEN
            NAME$P = .CUR$CONSOL$IN;
        ELSE
            NAME$P = .CUR$CONSOL$OUT;
        DO I = 0 TO 14;
            BUFFER(I) = NAME(I);
        END;
    END;


    LOAD: PROCEDURE(PATHNAME, BIAS, RETSW, ENTRY$P);
        DECLARE (PATHNAME, BIAS, RETSW, ENTRY$P) ADDRESS;
        DECLARE ENTRY BASED ENTRY$P ADDRESS;
        DECLARE PAD1 BYTE;
        DECLARE (AFT, I, RETSW$B) BYTE;
        DECLARE RECORD$LEN ADDRESS, RECORD$LOAD$ADDR ADDRESS;
        DECLARE ACTUAL ADDRESS,
                USER$BOTTOM ADDRESS INITIAL(0FFFFH), BUFFER$TOP ADDRESS;

        IF RETSW > 2 THEN
            CALL ERR(WARNING, BAD$RETSW);

        AFT = AFT$BOTTOM +  OPEN(PATHNAME, 1, 0);   /* OPEN$READ */

        IF (RETSW$B := RETSW) <> 0 THEN
            USER$BOTTOM = MEMCK;
        BUFFER$TOP = PACKBUFS;
        RECORD$LEN = 1;
        DO WHILE RECORD$LEN <> 0;
            /* READ THE LEN AND LOAD ADDRESS */
            CALL READ(AFT, .RECORD$LEN, 4, .ACTUAL);
            /* SHORT, RELOCATE OR ODD TYPE */
            IF ACTUAL < 4 THEN
                CALL ERR(ABORT, BAD$LOAD$FORMAT);
            RECORD$LOAD$ADDR = RECORD$LOAD$ADDR + BIAS;
            IF RECORD$LOAD$ADDR >= 18H AND RECORD$LOAD$ADDR <= 3FH
                  AND RECORD$LOAD$ADDR + RECORD$LEN <= 40H THEN
                ;
            ELSE
            DO;
                IF USER$BOTTOM > RECORD$LOAD$ADDR THEN
                /* FIRST ADDRESS WILL UPDATE THIS IF APPLICABLE */
                    USER$BOTTOM = RECORD$LOAD$ADDR; 
                IF BUFFER$TOP > RECORD$LOAD$ADDR
                  OR RECORD$LOAD$ADDR + RECORD$LEN  < RECORD$LOAD$ADDR THEN
                    CALL ERR(ABORT, ISIS$OVERWRITE);
            END;
            CALL READ(AFT, RECORD$LOAD$ADDR, RECORD$LEN, .ACTUAL);
            IF ACTUAL < RECORD$LEN THEN
                CALL ERR(ABORT, BAD$LOAD$FORMAT);
        END;
        CALL CLOSE(AFT);
        USER$BOTTOM = USER$BOTTOM AND 0FFF8H;
        DO I = 0 TO 18;
            IF .MEMORY + SHL(DOUBLE(I), 7) >= USER$BOTTOM THEN
                BUFFER$TABLE(I) = 1;
            ELSE
                BUFFER$TABLE(I) = BUFFER$TABLE(I) AND 0FEH;
        END;
        IF RETSW$B = 0 THEN
        DO;
            ENTRY = RECORD$LOAD$ADDR;
            RETURN;
        END;
        STACKPTR = USERSP;
        IF RETSW$B = 1 THEN
        DO;
            DEBUG$TOGGLE = FALSE;
            STACKPTR = STACKPTR + 2;
            GOTO RECORD$LOAD$ADDR;
        END;
        ENTRY$P = STACKPTR;
        ENTRY = RECORD$LOAD$ADDR;
        DEBUG$TOGGLE = TRUE;
        GOTO 0;
    END;

    EXIT: PROCEDURE;
        DECLARE I BYTE;
        DO I = AFT$FIRST TO AFT$LAST;
            CALL CLOSE(I);
        END;
        IF MAP$CHANGE THEN
            CALL RWMAP(CURRENT$BITMAP, CMD$WRITE);
        CURRENT$BITMAP = 0FFH;
        CALL LOAD(.('ISIS.CLI '), 0, 1, 0);
    END EXIT;

    DECLARE BOOTLOAD DATA(80H, 4, 26, 0, 1, 0, 30H);   /* 3000H -> MEMORY */

    REBOOT: PROCEDURE INTERRUPT 1;
        DECLARE I BYTE;
        STACKPTR = .TOPSTACK;
        DO I = AFT$BOTTOM TO AFT$LAST;
            CALL CLOSE(I);
        END;
        CALL XEQIOPB(0, .BOOTLOAD);
        GOTO 3000H;
    END;

    AFT$CHK: PROCEDURE;
        IF PARAM1 = 0FFH THEN
            CALL ERR(WARNING, OK); 
        IF (PARAM1 := PARAM1 + AFT$BOTTOM) >= 10 /* AFT$LAST + 1 */
                                         OR CLOSED(PARAM1) OR PARAM1 < AFT$BOTTOM THEN
            CALL ERR(WARNING, BAD$AFT$NO);
    END;

    /* ISIS */
    USERSP = STACKPTR;
    STACKPTR = .TOPSTACK;

    IF COMMAND = 'D' AND PARAM(0) = 'SK' THEN
        CALL XEQIOPB(PARAM(1), PARAM(2));
    ELSE
    DO;
        DO I = 0 TO 4;
            /* CHECK IF AN ADDRESS PARAMETER */
            IF SHR(PARAMTYPE(I), COMMAND + 1) THEN
                IF (PARAM(I) < .MEMORY) THEN
                    CALL ERR(ABORT, BAD$PARAMETER);
            SYSPARAM(I+1) = PARAM(I);
        END;

        /* GET THE RETURN STATUS ADDRESS */
        USERSTATUS$P = SYSPARAM(RETPARAMIDX(COMMAND));
        USERSTATUS = 0;
        GLOBAL$SEVERITY = 0;
        IF COMMAND < 14 THEN       /* MAX$COMMAND */
            DO CASE COMMAND;
            DO;     /* 0 - OPEN */
                DECLARE AFT BASED PARAM1 ADDRESS;
                AFT = OPEN(PARAM2, PARAM3, PARAM4);  /* FILE, ACCESS, MODE */
            END;
            DO;     /* 1 - CLOSE */
                CALL AFT$CHK;
                IF PARAM1 >= 4 THEN
                    CALL CLOSE(PARAM1);
            END;
            CALL DELETE(PARAM1);    /* 2 - DELETE - FILE */
            DO;         /* 3 - READ */
                DECLARE PARAM4VAL BASED PARAM4 ADDRESS;
                PARAM4VAL = 0;
                CALL AFT$CHK;
                IF ECHOAFT(PARAM1) = 0 THEN
                    /* AFTN, BUFFER, COUNT, ACTUAL */
                    CALL READ(PARAM1, PARAM2, PARAM3, PARAM4);
                ELSE
                    /* AFTN, BUFFER, COUNT, ACTUAL */
                    CALL EDIT(PARAM1, PARAM2, PARAM3, PARAM4);
            END;
            DO;         /* 4 - WRITE */
                CALL AFT$CHK;
                CALL WRITE(PARAM1, PARAM2, PARAM3); /* AFTN, BUFFER, COUNT */
            END;
            DO;         /* 5 - SEEK */
                CALL AFT$CHK;
                /* AFTN, BUFFER, COUNT, ACTUAL */
                CALL SEEK(PARAM1, PARAM2, PARAM3, PARAM4);
            END;
            /* 6 - LOAD - FILE, BASE, RETSW, ENTRY */
            CALL LOAD(PARAM1, PARAM2, PARAM3, PARAM4);
            CALL RENAME(PARAM1, PARAM2);      /* 7 - RENAME - FILE1, FILE2 */
            DO;                               /* 8 - CONSOLE - FILE1, FILE2 */
                GLOBAL$SEVERITY = 2;
                CALL CONSOL(PARAM1, PARAM2);
            END;
            CALL EXIT;                        /* 9 - EXIT */
            /* 10 - ATTRIB - FILE, SWID, SWVALUE */
            CALL ATTRIB(PARAM1, PARAM2, PARAM3);
            DO;         /* 11 - RESCAN */
                CALL AFT$CHK;
                CALL RESCAN(PARAM1);        /* AFTN */
            END;
            CALL ERR(MESSAGE, PARAM1);  /* 12 - ERROR - MESSAGE, ERRNUM */
            CALL WHOCON(PARAM1, PARAM2);    /* 13 - WHOCON - AFTN, BUFFER */
            END;
        ELSE
            CALL ERR(WARNING, BAD$COMMAND);
    END;
    STACKPTR = USERSP;
END;
END;
EOF

isis.bin_1.2.patch
TARGET=ISISBIN SOURCE=HEX START=0000 LOAD=0008

isis.cli.plm
/*
    THE SOURCE BELOW NEEDS TO BE COMPILED WITH THE FORTRAN CROSS COMPILER
    UNFORTUNATELY INTEL SEEM TO HAVE USED A LATER VERSION THAT SUPPORTED
    'AT' AND DID NOT FILL UNINITIALISED DATA WITH ZEROS

*/
3200H: DO; 
    DECLARE BOOLEAN LITERALLY 'BYTE';
    DECLARE TRUE    LITERALLY '0FFH';
    DECLARE FALSE   LITERALLY '0';
    DECLARE CR  LITERALLY '0DH',
            LF  LITERALLY '0AH';

    DECLARE BTSTRP LITERALLY '8';
    DECLARE MDSMON LITERALLY '0';

    DECLARE CVER DATA(1, 17);     /* ISIS.CLI VERSION */
    DECLARE COPYRIGHT DATA('(C) 1975,1976 INTEL CORP');

    ISIS: PROCEDURE(CMD, PARAM$P);
        DECLARE CMD BYTE, PARAM$P ADDRESS;
        GOTO 40H;
    END ISIS;

    READ: PROCEDURE(CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P) ADDRESS;

        CALL ISIS(3, .CONN);
    END;

    WRITE: PROCEDURE(CONN, BUFF$P, COUNT, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, STATUS$P) ADDRESS;

        CALL ISIS(4, .CONN);
    END;


    LOAD: PROCEDURE(PATH$P, LOAD$OFFSET, RETSW, ENTRY$P, STATUS$P);
        DECLARE (PATH$P, LOAD$OFFSET, RETSW, ENTRY$P, STATUS$P) ADDRESS;

        CALL ISIS(6, .PATH$P);
    END;
    
    RESCAN: PROCEDURE(CONN, STATUS$P);
        DECLARE (CONN, STATUS$P) ADDRESS;

        CALL ISIS(11, .CONN);
    END;

    ERROR: PROCEDURE(ERROR$NUM);
        DECLARE (ERROR$NUM, STATUS) ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(12, .ERROR$NUM);
    END;

    EXIT: PROCEDURE;
        DECLARE STATUS ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(9, .STATUS);
    END;

    DEBLANK: PROCEDURE(PTR) ADDRESS;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE (C = ' ');
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;

    DELIMIT: PROCEDURE(PTR) ADDRESS;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE (C = ':' OR C = '.' OR
                 ('0' <= C AND C <= '9') OR
                 ('A' <= C AND C <= 'Z'));
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;

    MEMCK: PROCEDURE ADDRESS;
        GOTO 0F81BH;
    END;


    SEQ: PROCEDURE(S1, S2, CNT) BYTE;
        DECLARE (S1,S2) ADDRESS, CNT BYTE;
        DECLARE S1A BASED S1(1) BYTE;
        DECLARE S2A BASED S2(1) BYTE;
        DECLARE I BYTE;
        CNT = CNT - 1;
        DO I = 0 TO CNT;
            IF S1A(I) <> S2A(I) THEN
                RETURN 0;
        END;
        RETURN 0FFH;
    END;

    /* NOT ACTUALLY USED */
    NUMOUT: PROCEDURE(VALUE, BASE, LC, BUFADR, WIDTH);
        DECLARE (VALUE, BUFADR) ADDRESS, (BASE, LC, WIDTH) BYTE; 
        DECLARE DIGITS DATA('0123456789ABCDEF');
        DECLARE I BYTE;
        DECLARE BUF BASED BUFADR (1) BYTE;

        DO I = 1 TO WIDTH;
            BUF(WIDTH - I) = DIGITS(VALUE MOD BASE);
            VALUE = VALUE / BASE;   
        END;

        I = 0;
        DO WHILE BUF(I) = '0' AND I < WIDTH - 1;
            BUF(I) = LC;
            I = I + 1;
        END;
    END;

    REPORTERROR: PROCEDURE(ERRNUM);
        DECLARE ERRNUM ADDRESS;
        DECLARE NUMBERBUFFER(3) BYTE, I ADDRESS, STATUS ADDRESS;
     

        DECLARE ERRMSG DATA(0, 0,
            2, 'ILLEGAL AFTN ARGUMENT', 0,
            4, 'INCORRECTLY SPECIFIED FILE', 0,
            5, 'UNRECOGNIZED DEVICE NAME', 0,
            6, 'ATTEMPT TO WRITE TO INPUT DEVICE', 0,
            8, 'ATTEMPT TO READ FROM OUTPUT DEVICE', 0,
            9, 'DIRECTORY FULL', 0,
            0AH, 'NOT ON SAME DISK', 0,
            0BH, 'FILE ALREADY EXISTS', 0,
            0CH, 'FILE IS ALREADY OPEN', 0,
            0DH, 'NO SUCH FILE', 0,
            0EH, 'WRITE PROTECTED', 0,
            0FH, 'LOAD TOO LOW', 0,
            10H, 'BAD LOAD FORMAT', 0,
            11H, 'NOT A DISK FILE', 0,
            12H, 'ILLEGAL ISIS COMMAND', 0,
            13H, 'ATTEMPTED SEEK ON NON-DISK FILE', 0,
            14H, 'ATTEMPTED BACK SEEK TO FAR', 0,
            16H, 'ILLEGAL ACCESS MODE TO OPEN', 0,
            17H, 'MISSING FILENAME', 0,
            19H, 'ILLEGAL ECHO FILE', 0,
            1AH, 'ILLEGAL ATTRIBUTE IDENTIFIER', 0,
            1BH, 'ILLEGAL SEEK COMMAND', 0,
            1CH, 'MISSING EXTENSION', 0,
            1FH, 'CAN', 27H, 'T SEEK ON WRITE ONLY FILE', 0,
            20H, 'CAN', 27H, 'T DELETE OPEN FILE', 0,
            23H, 'SEEK PAST EOF', 0,
            0C9H, 'UNRECOGNIZED SWITCH', 0,
            0CAH, 'UNRECOGNIZED DELIMITER', 0,
            0CBH, 'INVALID SYNTAX', 0,
            0CCH, 'PREMATURE EOF', 0,
            0CEH, 'ILLEGAL DISKETTE LABEL', 0,
            0D0H, 'CHECKSUM ERROR', 0
        );



        IF ERRNUM <> 0 THEN
        DO;
            I = 0;
            DO WHILE I < LENGTH(ERRMSG);
                IF ERRNUM = ERRMSG(I) AND ERRMSG(I + 1) <> 0 THEN
                DO;
                    I = I + 1;
                    CALL WRITE(0, .(' '), 1, .STATUS);
                    DO WHILE ERRMSG(I) <> 0;
                        CALL WRITE(0, .ERRMSG(I), 1, .STATUS);
                        I = I + 1;
                    END;
                    CALL WRITE(0, .(0DH, 0AH), 2, .STATUS);
                    return;
                END;
                ELSE
                DO;
                    DO WHILE ERRMSG(I) <> 0;
                        I = I + 1;
                    END;
                    I = I + 1;
                END;
            end;
            CALL ERROR(ERRNUM);
        END;
    END;


    FILE$ERROR: PROCEDURE(STATUS, PTR, CALLEXIT);
        DECLARE (STATUS, PTR) ADDRESS, CALLEXIT BYTE;
        DECLARE ERR$STATUS ADDRESS;

        IF STATUS <> 0 THEN
        DO;
            PTR = DEBLANK(PTR);
            CALL WRITE(0, .(' '), 1, .ERR$STATUS);
            CALL WRITE(0, PTR, DELIMIT(PTR) - PTR, .ERR$STATUS);
            CALL WRITE(0, .(','), 1, .ERR$STATUS);
            CALL REPORTERROR(STATUS);
            IF CALLEXIT THEN
                CALL EXIT;
        END;
    END;

MAIN:

    DECLARE BUFFER(128) BYTE;
    DECLARE DEBUG BOOLEAN;
    DECLARE BUFFER$PTR ADDRESS, CHAR BASED BUFFER$PTR BYTE;
    DECLARE (PATHNAME$PTR,ACTUAL,STATUS,ENTRY,RETSW) ADDRESS;
    DECLARE TOPSTACK ADDRESS, STACKWORD BASED TOPSTACK ADDRESS;


    STACKPTR = MEMCK;
    OUTPUT(0FCH) = 0FCH; /* ENABLE CONSOLE INTERRUPTS 0 AHD 1 */
    ENABLE;
    OUTPUT(0FDH) = 20H; /* SEND END OF INTERRUPT COMMAND */
    BUFFER$PTR = .(':CI: ');
    CALL RESCAN(1,.STATUS);
    IF STATUS = 0 THEN
    DO;
      CALL READ(1,.BUFFER,LENGTH(BUFFER),.ACTUAL,.STATUS);
      CALL FILE$ERROR(STATUS,BUFFER$PTR,TRUE);
    END;
    DO WHILE TRUE;
      CALL WRITE(0,.('-'),1,.STATUS);
      CALL REPORTERROR(STATUS);
      CALL READ(1,.BUFFER,LENGTH(BUFFER),.ACTUAL,.STATUS);
      CALL FILE$ERROR(STATUS,BUFFER$PTR,TRUE);
      BUFFER(ACTUAL) = CR;
      BUFFER$PTR = DEBLANK(.BUFFER);
      IF CHAR <> CR THEN
      DO;
        /* NOW CHECK FDR DEBUG MODE (PATHNAHE PRECEDED BY 'DEBUG' */
        DEBUG = FALSE; /* ASSUME NORMAL CASE, NOT DEBUGGING */
        IF SEQ(.('DEBUG'),BUFFER$PTR,5)
        AND (DELIMIT(BUFFER$PTR)=BUFFER$PTR+5) THEN
        DO;
          BUFFER$PTR = DEBLANK(DELIMIT(BUFFER$PTR+5));
          DEBUG = TRUE;
          IF CHAR = CR THEN DO;
            TOPSTACK = STACKPTR;
            STACKWORD = BTSTRP;
            GOTO MDSMON;
          END;
        END;
        PATHNAME$PTR = BUFFER$PTR;
        BUFFER$PTR = DELIMIT(DEBLANK(BUFFER$PTR));
        CALL RESCAN(1,.STATUS);
        CALL REPORTERROR(STATUS);
        CALL READ(1,.BUFFER,BUFFER$PTR-.BUFFER,.ACTUAL,.STATUS);
        CALL REPORTERROR(STATUS);
        IF DEBUG THEN RETSW = 2; ELSE RETSW = 1;
        CALL LOAD(PATHNAME$PTR,0,RETSW,.ENTRY,.STATUS);
        CALL FILE$ERROR(STATUS,PATHNAME$PTR,FALSE);
        CALL READ(1,.BUFFER,LENGTH(BUFFER),.ACTUAL,.STATUS);
        CALL REPORTERROR(STATUS);
      END;
    END;
END;
EOF
isis.t0.plm
/*
    THE SOURCE BELOW NEEDS TO BE COMPILED WITH THE FORTRAN CROSS COMPILER
*/
3000H: DO; 

    DECLARE BOOLEAN LITERALLY 'BYTE';
    DECLARE TRUE    LITERALLY '0FFH';
    DECLARE CMSK    LITERALLY '0FCH';
    DECLARE CR  LITERALLY '0DH',
            LF  LITERALLY '0AH';

    DECLARE T0VER DATA(1, 9);     /* ISIS.T0 VERSION ? */
    DECLARE COPYRIGHT DATA('(C) 1975,1976 INTEL CORP');

    DECLARE VERSION$LEVEL   LITERALLY   'BYTE$AT(3EH)',
            EDIT$LEVEL      LITERALLY   'BYTE$AT(3FH)';

    /* ALTHOUGH THE VARIABLES BELOW COULD HAVE BEEN
       EXPLICITLY FILLED WITH JUNK DATA TO MATCH THE ISIS.T0
       FILE. I USE THE PATCH CAPABILITY TO DO THIS INSTEAD
       AS THERE ARE OTHER HIDDEN LOCATIONS THAT NEED PATCHING
       WITH JUNK ('9') ANYWAY
    */
    DECLARE (USER$STATUS, USER$SP, START$ADDR) ADDRESS;

    DECLARE A$DEVICE BYTE INITIAL(0);
    DECLARE MEMBASE ADDRESS INITIAL(0);
    DECLARE BYTE$AT BASED MEMBASE (1) BYTE;

    DECLARE TEMP BYTE INITIAL(0);
    DECLARE ISIS$SIGNON(9) BYTE INITIAL(CR, LF, 'ISIS, V'),
            SIGN$V(2) BYTE INITIAL(0, 0), /* VERSION NUMBER */
            SIGN$DOT(1) BYTE INITIAL('.'),
            SIGN$E(2) BYTE INITIAL(0, 0),  /* EDIT NUMBER */
            SIGN$CRLF(2) BYTE INITIAL (CR, LF);


    ISIS: PROCEDURE(CMD, PARAM$P);
        DECLARE CMD BYTE, PARAM$P ADDRESS;
        GOTO 40H;
    END ISIS;

    READ: PROCEDURE(CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P) ADDRESS;

        CALL ISIS(3, .CONN);
    END;

    WRITE: PROCEDURE(CONN, BUFF$P, COUNT, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, STATUS$P) ADDRESS;

        CALL ISIS(4, .CONN);
    END;

    EXIT: PROCEDURE;
        DECLARE STATUS ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(9, .STATUS);
    END;

    CONSOL: PROCEDURE(CI$P, CO$P, STATUS$P);
        DECLARE (CI$P, CO$P,  STATUS$P) ADDRESS;

        CALL ISIS(8, .CI$P);
    END;

    NUMOUT: PROCEDURE(VALUE, BASE, LC, BUFADR, WIDTH);
        DECLARE (VALUE, BUFADR) ADDRESS, (BASE, LC, WIDTH) BYTE; 
        DECLARE DIGITS DATA('0123456789ABCDEF');
        DECLARE I BYTE;
        DECLARE BUF BASED BUFADR (1) BYTE;

        DO I = 1 TO WIDTH;
            BUF(WIDTH - I) = DIGITS(VALUE MOD BASE);
            VALUE = VALUE / BASE;   
        END;

        I = 0;
        DO WHILE BUF(I) = '0' AND I < WIDTH - 1;
            BUF(I) = LC;
            I = I + 1;
        END;
    END;



    /* THE FOLLOWING VARIABLES ARE USED IN THE ERR PROCEDURE */
    DECLARE STATUS ADDRESS INITIAL(0);
    DECLARE DEBUG$TOGGLE BYTE INITIAL(0);
    DECLARE GLOBAL$SEVERITY BYTE INITIAL(0);
    DECLARE FDCC$ERROR$TYPE ADDRESS INITIAL(0);
                                    /* HAS DATA ON DISK I/O ERRORS */
    /* USEFUL LITERALS */
    DECLARE WARNING LITERALLY '0',
            MESSAGE LITERALLY '1',
            ABORT   LITERALLY '2';

    DECLARE DISK$IO$ERROR   LITERALLY   '18H',
            DRIVE$NOT$READY LITERALLY   '1EH';

    DECLARE ISIS$HDR$BLK LITERALLY   '204H';


    DECLARE RTC LITERALLY '0FFH';   /* REAL TIME CLOCK */
    DECLARE BOOT LITERALLY '2';
    /* INPUT FROM RTC IS A BYTE. THE SECOND BIT FROM THE RIGHT
       CORRESPONDS TO THE BOOT SWITCH. IF THIS BIT IS 1 THE SWITCH IS
       ON, AND IF IT IS 0 THE  SWITCH IS OFF.
    */

    DECLARE MDSMON  LITERALLY   '0',
            BTSTRP  LITERALLY   '8';


    CI: PROCEDURE BYTE;
        GOTO 0F803H;
    END;

    RI: PROCEDURE BYTE;
        GOTO 0F806H;
    END;

    CO: PROCEDURE(C);
        DECLARE C BYTE;
        GOTO 0F809H;
    END;

    PO: PROCEDURE(C);
        DECLARE C BYTE;
        GOTO 0F80CH;
    END;

    LO: PROCEDURE(C);
        DECLARE C BYTE;
        GOTO 0F80FH;
    END;

    IOCHK: PROCEDURE BYTE;
        GOTO 0F815H;
    END;

    IOSET: PROCEDURE(C);
        DECLARE C BYTE;
        GOTO 0F818H;
    END;


    
    DECLARE INITIO$BASE ADDRESS INITIAL(6), INITIO BASED INITIO$BASE BYTE;

    /*
       THE ERR PROCEDURE IS USED TO HANDLE ERROR CONDIITONS.
           AN ERROR MESSAGE IS ISSUED TO THE CONSOLE, WHICH FOR
           DISK ERRORS HAS EXTENDED CONTENT
       CONTROL THEN PASSES TO THE MDS MONITOR

       ERROR$TYPE IS THE ERROR NUMBER WHICH IDENTIFIES THE PARTICUALAR
              TYPE OF ERROR, SUCH AS DISK I/O ERROR
    */

    ERR: PROCEDURE(SEVERITY, ERROR$TYPE);
        DECLARE (SEVERITY, ERROR$TYPE, I, IMAX) BYTE;
        DECLARE PC BASED USER$SP ADDRESS;
        DECLARE MSG1(8) BYTE INITIAL(CR, LF, 'ERROR '),
                MSG2(3) BYTE INITIAL(0, 0, 0), /* ERROR NUMBER GOES HERE */
                MSG3(9) BYTE INITIAL(' USER PC '),
                MSG4(4) BYTE INITIAL(0,0,0,0), /* USER PC IN HEX GOES HERE */
                MSG5(2) BYTE INITIAL(CR, LF),
                MSG6(5) BYTE INITIAL('FDCC='),
                MSG7(4) BYTE INITIAL(0,0,0,0), /* FDCC ERROR DATA GOES HERE */
                MSG8(2) BYTE INITIAL(CR, LF);

        IF (SEVERITY := SEVERITY OR GLOBAL$SEVERITY) <> WARNING THEN
        DO;
            CALL NUMOUT(ERROR$TYPE, 10, 0, .MSG2, 3);
            CALL NUMOUT(PC,16,'0',.MSG4,4);
            CALL IOSET((IOCHK AND CMSK) OR (INITIO AND 3));
            IMAX = 25;  /* NUMBER OF CHARACTERS IN NORMAL ERROR MESSAGE */
            IF ERROR$TYPE = DISK$IO$ERROR THEN
            DO;
                IMAX = 36;
                CALL NUMOUT(FDCC$ERROR$TYPE, 16, '0', .MSG7, 4);
            END;
            DO I = 0 TO IMAX;
                CALL CO(MSG1(I));
            END;
        END;
        ELSE
        DO;
            USER$STATUS = ERROR$TYPE;
            STACKPTR = USER$SP;
        END;
        IF SEVERITY >= ABORT THEN
        DO;
            IF DEBUG$TOGGLE THEN
                GOTO MDSMON;    /* EXIT VIA MONITOR */
            GOTO BTSTRP;        /* EXIT VIA SOFTWARE BOOTSTRAP */
        END;
    END;

    /*
       XEQIOPB PROVIDES ACCESS TO THE FDCC
       CONTROLLER 1 = BASE ADDRESS 78H (DRIVES 0, 1 FOR SD)

       DRIVE: AN INTEGER 0-1, SPECIFYING THE DISK TO BE ACCESSED
       IOPB:  THE ADDRESS OF A PARAMETER BLOCK TO BE SENT TO THE
          FDCC CONTROLLER. THIS PARAMETER MUST BE SET UP
          AS IF IT WERE FOR DRIVE 0; IF 'DRIVE' SELECTS
          ANOTHER DRIVE, 'DISKIO' WILL SET ALL THE NECESSARY
          BITS

       THE CALLER PROVIDES A PARAMETER BLOCK SPECIFYING SOME
       VALID DISK OPERATION ON DRIVE 0 AND AN INTEGER DRIVE SELECT VALUE
       IN THIS BOOT CODE ONLY READ AND RECAL ARE USED
       THE PROCEDURE WAITS FOR THE CONTROLLER TO GO UNBUSY, THEN
       PERFORMS THE DESIRED ACTION. IN CASE OF A CONTROLLER ERROR,
       THE DISK DRIVE IS RECALIBRATED AND THE ACTION IS TRIED AGAIN.
       IF SUCCESSFUL COMPLETION CANNOT BE OBTAINED AFTER 'MAX$RETRIES'
       ATTEMPTS, A FATAL ERROR OCCURS, OTHERWISE A NORMAL RETURN IS MADE

    */
        DECLARE FDCC$STATUS$0   LITERALLY   '78H',
                RESULT$TYPE$0   LITERALLY   '79H',
                RESULT$BYTE$0   LITERALLY   '7BH',
                LOW$ADDRESS$0   LITERALLY   '79H',
                HIGH$ADDRESS$0  LITERALLY   '7AH';

        DECLARE MAX$RETRIES     LITERALLY   '10',
                DISK$DONE       LITERALLY   '4',
                READ$COMMAND    LITERALLY   '4',
                WRITE$COMMAND   LITERALLY   '6',
                RECALIBRATE     LITERALLY   '3';

        DECLARE IOCW    LITERALLY '0',      /* IOPB OFFSETS */
                IOINS   LITERALLY '1',
                NSEC    LITERALLY '2',
                TADR    LITERALLY '3',
                SADR    LITERALLY '4',
                BUFLO   LITERALLY '5',
                BUFHI   LITERALLY '6';


    XEQIOPB: PROCEDURE(DRIVE, IOPB);
        /* THIS PROCEDURE ISSUES THE IOPB TO THE DISK CONTROLLER, IN THE */
        /* CASE OF THE 8271 IT ALSO TRANSFERS THE DATA BYTE BY BYTE */
        DECLARE DRIVE BYTE; /* DRIVE NUMBER: ASSUMES VALUE 0,1 */
        DECLARE IOPB ADDRESS;   /* POINTER TO THE PARAMATER BLOCK NAMED DCB */
        DECLARE DCB BASED IOPB (7) BYTE;

        DECLARE TEMPA(0) ADDRESS, (TEMP2, TEMP1) BYTE;

        /* RECALIBRATE COMMAND */
        DECLARE RECAL$PB(5) BYTE INITIAL(80H, RECALIBRATE, 0, 0, 0);

        DECLARE I BYTE;     /* INDEX VARIABLE IN FOR STATEMENTS */

        DISABLE;
        RECAL$PB(IOINS) = RECALIBRATE;
        RECAL$PB(SADR) = 0;
        IF DRIVE THEN   /* TRUE IF DRIVE 1 */
        DO;
            DCB(IOINS) = DCB(IOINS) OR 30H;
            DCB(SADR) = DCB(SADR) OR 20H;
            RECAL$PB(IOINS) = RECALIBRATE OR 30H;
            RECAL$PB(SADR) = 20H;
        END;

        DO I = 0 TO MAX$RETRIES;
            DO WHILE (INPUT(FDCC$STATUS$0) AND DISK$DONE) <> 0;
                TEMP1 = INPUT(RESULT$TYPE$0);
                TEMP1 = INPUT(RESULT$BYTE$0);
            END;
            /* IF DISK DRIVE NOT READY, GIVE FATAL ERROR */
            IF (INPUT(FDCC$STATUS$0) AND (DRIVE + 1)) = 0 THEN
                CALL ERR(ABORT, DRIVE$NOT$READY);
            /* START IO */
            OUTPUT(LOW$ADDRESS$0) = LOW(IOPB);
            OUTPUT(HIGH$ADDRESS$0) = HIGH(IOPB);

            DO WHILE (INPUT(FDCC$STATUS$0) AND DISK$DONE) = 0;
                ;
            END;
            TEMP1 = INPUT(RESULT$TYPE$0);
            IF (TEMP2 := INPUT(RESULT$BYTE$0)) = 0 THEN
            DO;
                ENABLE;
                RETURN;
            END;

            OUTPUT(LOW$ADDRESS$0) = LOW(.RECAL$PB);
            OUTPUT(HIGH$ADDRESS$0) = HIGH(.RECAL$PB);

            DO WHILE (INPUT(FDCC$STATUS$0) AND DISK$DONE) = 0;
                ;
            END;
        END;
        FDCC$ERROR$TYPE = TEMPA;
        CALL ERR(ABORT, DISK$IO$ERROR);
    END;

    XIO: PROCEDURE(OPCODE, DRIVE, TRKSEC, BUFFER);
        DECLARE (OPCODE, DRIVE) BYTE, (TRKSEC, BUFFER) ADDRESS;
        DECLARE DCB(10) BYTE INITIAL(80H);

        DCB(IOINS) = OPCODE;
        DCB(NSEC) = 1;
        DCB(TADR) = HIGH(TRKSEC);
        DCB(SADR) = LOW(TRKSEC);
        DCB(BUFLO) = LOW(BUFFER);
        DCB(BUFHI) = HIGH(BUFFER);
        CALL XEQIOPB(DRIVE, .DCB);
    END;

    RDSEC: PROCEDURE(TRKSEC, BUFFER);
         DECLARE (TRKSEC, BUFFER) ADDRESS;
         CALL XIO(READ$COMMAND, A$DEVICE, TRKSEC, BUFFER);
    END;

    WRSEC: PROCEDURE(TRKSEC, BUFFER);
        DECLARE (TRKSEC, BUFFER) ADDRESS;
        CALL XIO(WRITE$COMMAND, A$DEVICE, TRKSEC, BUFFER);
    END;

    /*

        ALDADR LOADS THE ABSOLUTE ISIS FILE INTO MEMORY
        HDRBLK - LOCATION OF ISIS FILE

        RETURNS - ADDRESS WHERE FILE IS LOADED
        THE FORMAT OF THE FILE IS BASICALLY THE CONTENT RECORDS
        FROM AN NORMAL ISIS EXECUTABLE WITH THE RECORD TYPE, SEGMENT ID AND CRC REMOVED
    */

    ALDADR: PROCEDURE(HDRBLK) ADDRESS;
        /* LOAD INTO MEMORY THE ABS LOAD FILE AT 'HDRBLK' */
        DECLARE HDRBLK ADDRESS;
        DECLARE BUF(128) BYTE, BUFPTR BYTE;
        DECLARE POINTERS(64) ADDRESS, PTRPTR BYTE;
        DECLARE LOADADR ADDRESS, TARGET BASED LOADADR BYTE;
        DECLARE LENGTH ADDRESS;

        DECLARE FLINK   LITERALLY   '1';    /* INDEXES INTO THE POINTERS ARRAY */

        L1B: PROCEDURE; /* LOAD 1 BYTE FROM BUFFER INTO MEMORY */
            TARGET = BUF(BUFPTR);   
            BUFPTR = BUFPTR + 1;
            LENGTH = LENGTH - 1;
            LOADADR = LOADADR + 1;
        END;

        G128B: PROCEDURE(BUFADR); /* GET 128 BYTES INTO BUFFER AT BUFADR */
            DECLARE BUFADR ADDRESS;

            IF (PTRPTR := PTRPTR + 1) = 64 THEN
            DO;
                IF POINTERS(FLINK) = 0 THEN
                    GOTO MDSMON;
                CALL XIO(READ$COMMAND, 0, POINTERS(FLINK), .POINTERS);
                PTRPTR = 2;
            END;
            IF POINTERS(PTRPTR) = 0 THEN
                GOTO MDSMON;
            CALL XIO(READ$COMMAND, 0, POINTERS(PTRPTR), BUFADR);
        END;

        G1B: PROCEDURE BYTE;    /* GET 1 BYTE */
            IF (BUFPTR AND 7FH) = 0 THEN
            DO;
                CALL G128B(.BUF);
                BUFPTR = 0;
            END;    
            BUFPTR = BUFPTR + 1;
            RETURN BUF(BUFPTR - 1);
        END;

        G2B: PROCEDURE ADDRESS; /* GET 2 BYTES */
            RETURN G1B + (256 * G1B);
        END;




        POINTERS(FLINK) = HDRBLK;   /* INITIALISZE G128B */
        PTRPTR = 63;
        BUFPTR = 0;

    START$LOADING$NEXT$RECORD:
        DO WHILE TRUE;
            LENGTH = G2B;
            LOADADR = G2B;
            IF LENGTH = 0 THEN
                RETURN LOADADR;
            DO WHILE BUFPTR <> 128;
                IF LENGTH > 0 THEN
                    CALL L1B;
                ELSE
                    GOTO START$LOADING$NEXT$RECORD;
            END;
            DO WHILE LENGTH >= 128;
                CALL G128B(LOADADR);
                LOADADR = LOADADR + 128;
                LENGTH = LENGTH - 128;
            END;
            
            BUFPTR = 0;
            IF LENGTH <> 0 THEN DO;
                CALL G128B(.BUF);
                DO WHILE LENGTH > 0;
                    CALL L1B;
                END;
            END;
        END;
        /* CANNOT REACH HERE !! */
    END; 


    T0BOOT:
    TEMP = INPUT(RESULT$TYPE$0);
    TEMP = INPUT(RESULT$BYTE$0);
    ENABLE;
    DO WHILE (INPUT(RTC) AND BOOT) <> 0;
        ;
    END;
    GLOBAL$SEVERITY = 0;
    DEBUG$TOGGLE = TRUE;
    START$ADDR = ALDADR(ISIS$HDR$BLK);
    IF START$ADDR <> 0 THEN
        GOTO START$ADDR;
    CALL CONSOL(.MEMORY, .MEMORY, .USERSTATUS);
    CALL NUMOUT(VERSION$LEVEL, 16, 0, .SIGN$V, 2);
    CALL NUMOUT(EDIT$LEVEL, 16, 0, .SIGN$E, 2);
    CALL WRITE(0, .ISIS$SIGNON, 16, .USERSTATUS);
    CALL EXIT;


END;
EOF;
isis.t0_1.2.patch
TARGET=IMAGE SOURCE=HEX START=3000 LOAD=3000
; UNIITIALISED - RANDOM DATA
363C 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
364F 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
3662 39

APPEND
 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
 00 39 00 39 00

load.asm
        name load
        aseg
        org 3200h

; isis calls
ISIS    equ     40h
READ    equ     3
LOAD    equ     6
ERROR   equ     12
EXIT    equ     9

CR      equ     0dh

start:  lxi     sp,start
        mvi     c,READ
        lxi     d,rdprm
        call    ISIS    ; read the cmd line
        lda     status
        ora     a
        jnz     failed
        lxi     h,rdbuf

scan:   inx     h       ; skip filename
        mov     a,m
        cpi     ' '
        jz      scan1
        cpi     ','
        jz      scan1
        cpi     CR
        jnz     scan
        mvi     m, ' '
        lxi     h,0
        shld    offset
        jmp     nosw
        
scan1:  lxi     d,0
        xchg

scan2:  shld    offset
        xchg

scan3:  inx     h
        mov     a,m
        cpi     CR
        jz      nosw
        cpi     ' '
        jz      scan5
        cpi     ','
        jz      scan5
        cpi     'H'     ; ignore H
        jz      scan3
        cpi     '0'     ; bad if not hex digit
        jc      badcmd
        cpi     '9' + 1
        jc      scan4
        cpi     'A'
        jc      badcmd
        cpi     'F' + 1
        jnc     badcmd
        sui     7       ; adjust for A-F

scan4:  sui     '0'     ; convert to 0-15 
        xchg
; the code below is needlessly complex
; shorter code would be
;       dad h
;       dad h
;       dad h
;       dad h
;       ora l
;       mov l,a
        push    psw
        mov     a,h
        ani     0Fh
        rlc
        rlc
        rlc
        rlc
        mov     h,a
        mov     a,l
        ani     0F0h
        rlc
        rlc
        rlc
        rlc
        ora     h
        mov     h,a
        mov     a,l
        ani     0Fh
        rlc
        rlc
        rlc
        rlc
        mov     l,a
        pop     psw
        ora     l
        mov     l,a
        jmp     scan2

scan5:  inx     h
        mov     a,m
        cpi     'M'
        jnz     nosw
        lxi     h,2

setsw:  shld    switch
        mvi     c,LOAD
        lxi     d,lodprm
        call    ISIS
        lda     status
        ora     a
        jnz     failed

done:   mvi     c,EXIT
        lxi     d,extprm
        call    ISIS

failed: lhld    status
        shld    errprm  ; save error code
        mvi     c,ERROR
        lxi     d,errprm
        call    ISIS
        jmp     done

nosw:   lxi     h,0
        jmp     setsw

badcmd:
        lxi     h,101h
        shld    status
        jmp     failed

; the isis parameter blocks
rdprm:
        dw      1       ; read console
        dw      rdbuf
        dw      32
        dw      actual
        dw      status   

lodprm: dw      rdbuf   ; file name
offset: ds      2
switch: ds      2
        dw      entry
        dw      status

errprm: ds      2       ; error code
        dw      status

extprm: dw      status

actual: ds      2
status: ds      2
entry:  ds      2
rdbuf:  
        end     start
        
        
rename.plm
3200H:
DO;
    DECLARE TRUE    LITERALLY '0FFH',
            FALSE   LITERALLY '0',
            CR      LITERALLY '0DH',
            LF      LITERALLY '0AH';

    DECLARE VER DATA(1, 8);
    DECLARE COPYRIGNT DATA('(C) 1975,1976 INTEL CORP');

    ISIS: PROCEDURE(CMD, PARAM$P);
        DECLARE CMD BYTE, PARAM$P ADDRESS;
        GOTO 40H;
    END ISIS;

    READ: PROCEDURE(CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P) ADDRESS;

        CALL ISIS(3, .CONN);
    END;

    WRITE: PROCEDURE(CONN, BUFF$P, COUNT, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, STATUS$P) ADDRESS;

        CALL ISIS(4, .CONN);
    END;

	RENAME: PROCEDURE(OLD$P, NEW$P, STATUS$P);
    	DECLARE (OLD$P, NEW$P, STATUS$P) ADDRESS;
    	
    	CALL ISIS(7, .OLD$P);
	END;

    ERROR: PROCEDURE(ERROR$NUM);
        DECLARE (ERROR$NUM, STATUS) ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(12, .ERROR$NUM);
    END;

    EXIT: PROCEDURE;
        DECLARE STATUS ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(9, .STATUS);
    END;

    DELETE: PROCEDURE (PATH$P, STATUS$P);
        DECLARE (PATH$P, STATUS$P) ADDRESS;

        CALL ISIS(2, .PATH$P);
    END DELETE;

    DEBLANK: PROCEDURE(PTR) ADDRESS;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE (C = ' ');
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;

    DELIMIT: PROCEDURE(PTR) ADDRESS;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE (C = ':' OR C = '.' OR
                 ('0' <= C AND C <= '9') OR
                 ('A' <= C AND C <= 'Z'));
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;

    SEQ: PROCEDURE(S1, S2, CNT) BYTE;
        DECLARE (S1,S2) ADDRESS, CNT BYTE;
        DECLARE S1A BASED S1(1) BYTE;
        DECLARE S2A BASED S2(1) BYTE;
        DECLARE I BYTE;
        CNT = CNT - 1;
        DO I = 0 TO CNT;
            IF S1A(I) <> S2A(I) THEN
                RETURN 0;
        END;
        RETURN 0FFH;
    END;

    NUMOUT: PROCEDURE(VALUE, BASE, LC, BUFADR, WIDTH);
        DECLARE (VALUE, BUFADR) ADDRESS, (BASE, LC, WIDTH) BYTE; 
        DECLARE DIGITS DATA('0123456789ABCDEF');
        DECLARE I BYTE;
        DECLARE BUF BASED BUFADR (1) BYTE;

        DO I = 1 TO WIDTH;
            BUF(WIDTH - I) = DIGITS(VALUE MOD BASE);
            VALUE = VALUE / BASE;   
        END;

        I = 0;
        DO WHILE BUF(I) = '0' AND I < WIDTH - 1;
            BUF(I) = LC;
            I = I + 1;
        END;
    END;

    REPORTERROR: PROCEDURE(ERRNUM);
        DECLARE ERRNUM ADDRESS;
        DECLARE NUMBERBUFFER(4) BYTE, I ADDRESS, STATUS ADDRESS;
     

        DECLARE ERRMSG DATA(0, 0,
            2, 'ILLEGAL AFTN ARGUMENT', 0,
            4, 'INCORRECTLY SPECIFIED FILE', 0,
            5, 'UNRECOGNIZED DEVICE NAME', 0,
            6, 'ATTEMPT TO WRITE TO INPUT DEVICE', 0,
            8, 'ATTEMPT TO READ FROM OUTPUT DEVICE', 0,
            9, 'DIRECTORY FULL', 0,
            0AH, 'NOT ON SAME DISK', 0,
            0BH, 'FILE ALREADY EXISTS', 0,
            0CH, 'FILE IS ALREADY OPEN', 0,
            0DH, 'NO SUCH FILE', 0,
            0EH, 'WRITE PROTECTED', 0,
            0FH, 'LOAD TOO LOW', 0,
            10H, 'BAD LOAD FORMAT', 0,
            11H, 'NOT A DISK FILE', 0,
            12H, 'ILLEGAL ISIS COMMAND', 0,
            13H, 'ATTEMPTED SEEK ON NON-DISK FILE', 0,
            14H, 'ATTEMPTED BACK SEEK TO FAR', 0,
            16H, 'ILLEGAL ACCESS MODE TO OPEN', 0,
            17H, 'MISSING FILENAME', 0,
            19H, 'ILLEGAL ECHO FILE', 0,
            1AH, 'ILLEGAL ATTRIBUTE IDENTIFIER', 0,
            1BH, 'ILLEGAL SEEK COMMAND', 0,
            1CH, 'MISSING EXTENSION', 0,
            1FH, 'CAN', 27H, 'T SEEK ON WRITE ONLY FILE', 0,
            20H, 'CAN', 27H, 'T DELETE OPEN FILE', 0,
            23H, 'SEEK PAST EOF', 0,
            0C9H, 'UNRECOGNIZED SWITCH', 0,
            0CAH, 'UNRECOGNIZED DELIMITER', 0,
            0CBH, 'INVALID SYNTAX', 0,
            0CCH, 'PREMATURE EOF', 0,
            0CEH, 'ILLEGAL DISKETTE LABEL', 0,
            0D0H, 'CHECKSUM ERROR', 0
        );



        IF ERRNUM <> 0 THEN
        DO;
            I = 0;
            DO WHILE I < LENGTH(ERRMSG);
                IF ERRNUM = ERRMSG(I) AND ERRMSG(I + 1) <> 0 THEN
                DO;
                    I = I + 1;
                    CALL WRITE(0, .(' '), 1, .STATUS);
                    DO WHILE ERRMSG(I) <> 0;
                        CALL WRITE(0, .ERRMSG(I), 1, .STATUS);
                        I = I + 1;
                    END;
                    CALL WRITE(0, .(0DH, 0AH), 2, .STATUS);
                    return;
                END;
                ELSE
                DO;
                    DO WHILE ERRMSG(I) <> 0;
                        I = I + 1;
                    END;
                    I = I + 1;
                END;
            end;
            CALL ERROR(ERRNUM);
        END;
    END;

    FILE$ERROR: PROCEDURE(STATUS, PTR, CALLEXIT);
        DECLARE (STATUS, PTR) ADDRESS, CALLEXIT BYTE;
        DECLARE ERR$STATUS ADDRESS;

        IF STATUS <> 0 THEN
        DO;
            PTR = DEBLANK(PTR);
            CALL WRITE(0, .(' '), 1, .ERR$STATUS);
            CALL WRITE(0, PTR, DELIMIT(PTR) - PTR, .ERR$STATUS);
            CALL WRITE(0, .(','), 1, .ERR$STATUS);
            CALL REPORTERROR(STATUS);
            IF CALLEXIT THEN
                CALL EXIT;
        END;
    END;


    DECLARE (ACTUAL, STATUS) ADDRESS;
    DECLARE BUFFER(128) BYTE;
    DECLARE BUFPTR ADDRESS;

    DECLARE BADCMD DATA('CANNOT READ COMMAND LINE.', CR, LF);
MAIN:
    CALL READ(1, .BUFFER, 128, .ACTUAL, .STATUS);
    IF STATUS <> 0 THEN DO;
        CALL REPORTERROR(STATUS);
        CALL WRITE(0, .BADCMD, 27, .STATUS);
        CALL EXIT;
    END;

    BUFPTR = DEBLANK(DELIMIT(DEBLANK(.BUFFER)));
    IF SEQ(.('TO '), BUFPTR, 3) THEN DO;
        BUFPTR = BUFPTR + 3;
        CALL RENAME(.BUFFER, .BUFFER, .STATUS);
        IF STATUS <> 0BH THEN
            CALL FILEERROR(STATUS, .BUFFER, TRUE);
        CALL RENAME(.BUFFER, BUFPTR, .STATUS);
        IF STATUS = 0BH THEN DO;
            CALL WRITE(0, .(' '), 1, .STATUS);
            CALL WRITE(0, BUFPTR, DELIMIT(BUFPTR) - BUFPTR, .STATUS);
            CALL WRITE(0, .(', ALREADY EXISTS, DELETE', 3FH, ' '), 26, .STATUS);
            CALL READ(1, .MEMORY, 128, .ACTUAL, .STATUS);
            IF MEMORY(0) = 'Y' OR MEMORY(0) = 'Y' + 20H THEN DO;
                CALL DELETE(BUFPTR, .STATUS);
                CALL FILEERROR(STATUS, BUFPTR, TRUE);
                CALL RENAME(.BUFFER, BUFPTR, .STATUS);
            END;
            ELSE
                CALL EXIT;
        END;
        IF STATUS <> 0 THEN
            CALL FILEERROR(STATUS, BUFPTR, TRUE);
    END;
    ELSE
            CALL REPORTERROR(0CBH);
    CALL EXIT;
END;
EOF
type.asm
    name type
    aseg
    org 3200h

CONSOL  equ     8
EXIT    equ     9
ISIS    equ     40h


start:  lxi     sp,stk
        mvi     c,CONSOL
        lxi     d,conprm
        call    ISIS
        mvi     c,EXIT
        lxi     d,extprm
        call    ISIS

; ISIS parameters
conprm: dw      ti
        dw      to
        dw      status

extprm: dw      status

ti:     db      ':TI: '
to:     db      ':TO: '
status: ds      2
        ds      4
stk:
        end     start
upm.plm
3200H:

    DECLARE LIT LITERALLY 'LITERALLY',
            CR LIT '0DH',
            LF LIT '0AH',
            DQUOTE LIT '22H',
            AMPERSAND LIT '26H',
            ATSIGN LIT '40H',
            HASH LIT '23H';

    DECLARE TRUE LIT '0FFH',
            FALSE LIT '0';

    DECLARE ERR$SYNTAX LIT '1',
            ERR$BADSIZE LIT '2',
            ERR$WORDTOOLONG LIT '13',
            ERR$NOFORMAT LIT '14';

    DECLARE SIGNON DATA('ISIS PROM MAPPER V1.1(C) 1976 INTEL CORP');
    DECLARE XDIGITS DATA('0123456789ABCDEF');
    DECLARE ERRSTR DATA(8CH, 'SYSTEM ERROR',        /* 0 */
                        8CH, 'SYNTAX ERROR',
                        95H, 'BAD LOGICAL WORD SIZE',
                        8BH, 'STORE FAILS',
                        8DH, 'KEYWORD ERROR',
                        11H, 'MISSING PARAMETER',   /* 5 */
                        0CH, 'BAD HEX DATA',
                        0DH, 'BAD BNPF DATA',
                        0FH, 'PROM READ ERROR',
                        12H, 'NO PROM PROGRAMMER',
                        0BH, 'STORE FAILS',         /* 10 */
                        13H, 'CANNOT REDO PROGRAM',
                        96H, 'BAD COMPOUND WORD SIZE',
                        15H, 'LOGICAL WORD TOO LONG',
                        09H, 'NO FORMAT',
                        0DH, 'LINE TOO LONG',       /* 15 */
                        11H, 'UPP ADDRESS ERROR',
                        14H, 'WRONG LOGICAL LENGTH',
                        0BH, 'START NOT 0',
                        13H, 'MEMORY LIMITS WRONG',
                        15H, 'UPP BOARD SENSE ERROR', /* 20 */
                        14H, 'UPP HARDWARE FAILURE',
                        8FH, 'TOO MANY FIELDS');

    DECLARE BA33BF DATA(0, 8, 8, 4, 4, 8, 8);
    DECLARE BA33C6 DATA(0, 0, 4, 0, 0, 0, 0, 3,
                        2, 0, 0, 4, 0, 0, 0, 2,
                        2, 1, 0, 0, 0, 2, 1, 2,
                        2, 5);
    DECLARE KEYWORDS DATA(6, 'CHANGE',
                          7, 'COMPARE',
                          4, 'DATA',
                          7, 'DISPLAY',
                          4, 'EXIT',
                          6, 'FORMAT',
                          6, 'HEADER',
                          7, 'LOGICAL',
                          6, 'OFFSET',
                          7, 'PROGRAM',
                          4, 'READ',
                          6, 'SOCKET',
                          8, 'TRANSFER',
                          4, 'TYPE',
                          5, 'WRITE',
                          4, 'FROM',
                          2, 'TO',
                          6, 'BINARY',
                          3, 'HEX',
                          4, 'NULL',
                          3, 'EOF',
                          5, 'START',
                          4, 'BNPF',
                          4, 'INTO',
                          5, 'UNTIL',
                          4, 'FILE');
    DECLARE BA347D DATA(3, 3, 1, 3, 3, 3, 3, 0,
                       3, 3, 3, 2, 3, 3, 3, 3,
                       3, 3, 3, 3, 3, 3, 3, 3,
                       3, 3);
    DECLARE PROMNAMES DATA(5, ' NONE',
                           5, '1702A',
                           4, '2708',
                           4, '3601',
                           4, '3602',
                           4, '3604',
                           4, '8048');

    DECLARE B61F9 BYTE;
    DECLARE DATAEOF BYTE;
    DECLARE AFT BYTE;
    DECLARE B61FC BYTE;
    DECLARE ISINTELHEX BYTE;
    DECLARE B61FE BYTE;
    DECLARE B61FF BYTE;
    DECLARE LINELEN BYTE;
    DECLARE PAD6201 BYTE;
    DECLARE B6202 BYTE;
    DECLARE (B6203, B6204) BYTE;
    DECLARE DATA$BYTE BYTE;
    DECLARE B6206 BYTE;
    DECLARE B6207 BYTE;
    DECLARE STATUS BYTE;    /* WARNING B6209 WILL BE OVERWRITTEN */
    DECLARE B6209 BYTE;
    DECLARE LEN$IN BYTE;
    DECLARE CRC$IN BYTE;
    DECLARE B620C BYTE;
    DECLARE B620D BYTE;
    DECLARE B620E BYTE;
    DECLARE B620F BYTE;
    DECLARE W6210 ADDRESS;
    DECLARE W6212 ADDRESS;
    DECLARE W6214 ADDRESS;
    DECLARE RECLEN ADDRESS;
    DECLARE W6218 ADDRESS;
    DECLARE LINEIDX ADDRESS;
    DECLARE LOADADDR ADDRESS;
    DECLARE W621E ADDRESS;
    DECLARE W6220 ADDRESS;
    DECLARE W6222 ADDRESS;
    DECLARE W6224 ADDRESS;
    DECLARE WA6226(16) ADDRESS INITIAL(8000H, 4000H, 2000H, 1000H, 800H, 400H, 200H, 100H,
                                      80H,   40H,   20H,   10H,   8,    4,    2,    1);
    DECLARE W6246(4) ADDRESS INITIAL(0FFFEh, 0, 0, 0);
    DECLARE WA624E(8) ADDRESS;
    DECLARE BA625E(8) BYTE;
    DECLARE LINE(256) BYTE;
    DECLARE WA6366(25) ADDRESS;
    DECLARE U6398 ADDRESS;
    DECLARE BITMASKS(16) ADDRESS INITIAL(1, 3, 7, 0Fh, 1Fh, 3Fh, 7Fh,
                                0FFh, 1FFh, 3FFh, 7FFh, 0FFFh, 1FFFh, 3FFFh, 7FFFh, 0FFFFh);
    DECLARE UNKNOWN(8) ADDRESS;
    DECLARE PAD63CA BYTE;
    DECLARE RECDATA(128) BYTE;

    DECLARE RESTART LABEL; 

    ISIS: PROCEDURE(CMD, PARAM$P);
        DECLARE CMD BYTE, PARAM$P ADDRESS;
        GOTO 40H;
    END ISIS;

    OPEN: PROCEDURE(CONN$P, PATH$P, ACCESS, ECHO, STATUS$P);
        DECLARE (CONN$P, PATH$P, ACCESS, ECHO, STATUS$P) ADDRESS;

        CALL ISIS(0, .CONN$P);
    END;

    READ: PROCEDURE(CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P) ADDRESS;

        CALL ISIS(3, .CONN);
    END;

    WRITE: PROCEDURE(CONN, BUFF$P, COUNT, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, STATUS$P) ADDRESS;

        CALL ISIS(4, .CONN);
    END;

    CLOSE: PROCEDURE(CONN, STATUS$P);
        DECLARE (CONN, STATUS$P) ADDRESS;

        CALL ISIS(1, .CONN);
    END;

    ERROR: PROCEDURE(ERROR$NUM);
        DECLARE (ERROR$NUM, STATUS) ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(12, .ERROR$NUM);
    END;

    EXIT: PROCEDURE;
        DECLARE STATUS ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(9, .STATUS);
    END;

    DEBLANK: PROCEDURE(PTR) ADDRESS;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE (C = ' ');
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;

    DELIMIT: PROCEDURE(PTR) ADDRESS;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE (C = ':' OR C = '.' OR
                 ('0' <= C AND C <= '9') OR
                 ('A' <= C AND C <= 'Z'));
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;

    REPORTERROR: PROCEDURE(ERRNUM);
        DECLARE ERRNUM ADDRESS;
        DECLARE NUMBERBUFFER(3) BYTE, I ADDRESS, STATUS ADDRESS;
     

        DECLARE ERRMSG DATA(0, 0,
            2, 'ILLEGAL AFTN ARGUMENT', 0,
            4, 'INCORRECTLY SPECIFIED FILE', 0,
            5, 'UNRECOGNIZED DEVICE NAME', 0,
            6, 'ATTEMPT TO WRITE TO INPUT DEVICE', 0,
            8, 'ATTEMPT TO READ FROM OUTPUT DEVICE', 0,
            9, 'DIRECTORY FULL', 0,
            0AH, 'NOT ON SAME DISK', 0,
            0BH, 'FILE ALREADY EXISTS', 0,
            0CH, 'FILE IS ALREADY OPEN', 0,
            0DH, 'NO SUCH FILE', 0,
            0EH, 'WRITE PROTECTED', 0,
            0FH, 'LOAD TOO LOW', 0,
            10H, 'BAD LOAD FORMAT', 0,
            11H, 'NOT A DISK FILE', 0,
            12H, 'ILLEGAL ISIS COMMAND', 0,
            13H, 'ATTEMPTED SEEK ON NON-DISK FILE', 0,
            14H, 'ATTEMPTED BACK SEEK TO FAR', 0,
            16H, 'ILLEGAL ACCESS MODE TO OPEN', 0,
            17H, 'MISSING FILENAME', 0,
            19H, 'ILLEGAL ECHO FILE', 0,
            1AH, 'ILLEGAL ATTRIBUTE IDENTIFIER', 0,
            1BH, 'ILLEGAL SEEK COMMAND', 0,
            1CH, 'MISSING EXTENSION', 0,
            1FH, 'CAN''T SEEK ON WRITE ONLY FILE', 0,
            20H, 'CAN''T DELETE OPEN FILE', 0,
            23H, 'SEEK PAST EOF', 0,
            0C9H, 'UNRECOGNIZED SWITCH', 0,
            0CAH, 'UNRECOGNIZED DELIMITER', 0,
            0CBH, 'INVALID SYNTAX', 0,
            0CCH, 'PREMATURE EOF', 0,
            0CEH, 'ILLEGAL DISKETTE LABEL', 0,
            0D0H, 'CHECKSUM ERROR', 0,
            0D1H, 'RELO FILE SEQUENCE ERROR', 0,
            0D2H, 'TOO MANY CONTIGS', 0
        );

        IF ERRNUM <> 0 THEN
        DO;
            I = 0;
            DO WHILE I < LENGTH(ERRMSG);
                IF ERRNUM = ERRMSG(I) AND ERRMSG(I + 1) <> 0 THEN
                DO;
                    I = I + 1;
                    CALL WRITE(0, .(' '), 1, .STATUS);
                    DO WHILE ERRMSG(I) <> 0;
                        CALL WRITE(0, .ERRMSG(I), 1, .STATUS);
                        I = I + 1;
                    END;
                    CALL WRITE(0, .(0DH, 0AH), 2, .STATUS);
                    RETURN;
                END;
                ELSE
                DO;
                    DO WHILE ERRMSG(I) <> 0;
                        I = I + 1;
                    END;
                    I = I + 1;
                END;
            END;
            CALL ERROR(ERRNUM);
        END;
    END;

    WRITE$CO: PROCEDURE(C);
        DECLARE C BYTE;
        CALL WRITE(0, .C, 1, .STATUS);
    END;

    CO$CH: PROCEDURE(CH);
        DECLARE CH BYTE;
        CALL WRITE$CO(CH);
    END;

    CO$CRLF: PROCEDURE;
        CALL CO$CH(CR);
        CALL CO$CH(LF);
    END;

    CO$BUF: PROCEDURE(BUF$P, CNT);
        DECLARE BUF$P ADDRESS, CNT BYTE;
        DECLARE CH BASED BUF$P BYTE;
        DECLARE I BYTE;

        DO I = 1 TO CNT;
            CALL CO$CH(CH);
            BUF$P = BUF$P + 1;
        END;
    END;

    SHOWERROR: PROCEDURE(ERR);
        DECLARE ERR BYTE;

        CO$LINE: PROCEDURE;
            CALL CO$BUF(.LINE, LINELEN + 1);
            IF LINE(LINELEN) = CR THEN
                CALL CO$CH(LF);
        END;

        ERRSTROFFSET: PROCEDURE(ERR) ADDRESS;
            DECLARE ERR BYTE;
    `       DECLARE I BYTE, IDX ADDRESS;

            IDX = 0;
            DO I = 1 TO ERR;
                IDX = (ERRSTR(IDX) AND 7FH) + IDX + 1;
            END;
            RETURN IDX;
        END;

        CO$ERROR: PROCEDURE;
            GETERRSTR: PROCEDURE(ERR) ADDRESS;
                DECLARE ERR BYTE;
                RETURN .ERRSTR(ERRSTROFFSET(ERR) + 1);
            END;

            ERRSTRLEN: PROCEDURE(ERR) BYTE;
                DECLARE ERR BYTE;
                RETURN ERRSTR(ERRSTROFFSET(ERR)) AND 7FH;
            END;

            CALL CO$BUF(GETERRSTR(ERR), ERRSTRLEN(ERR));
            CALL CO$CRLF;
        END;

        CHKSHOWLINE: PROCEDURE(ERR) BYTE;
            DECLARE ERR BYTE;
            RETURN ROL(ERRSTR(ERRSTROFFSET(ERR)), 1);
        END;
         
        IF CHKSHOWLINE(ERR) THEN
            CALL CO$LINE;
        CALL CO$CH(HASH);
        CALL CO$CRLF;
        CALL CO$ERROR;
        CALL CLOSE(AFT, .STATUS);
        GOTO RESTART;
    END;

    CHKSTATUS: PROCEDURE(STATUS);
        DECLARE STATUS ADDRESS;

        IF STATUS <> 0 THEN DO;
            CALL REPORTERROR(STATUS);
            GOTO RESTART;
        END;
    END;
            
    BACKUP: PROCEDURE(CNT);
        DECLARE CNT BYTE, I BYTE;
      
        DO I = 1 TO CNT; 
            LINEIDX = LINEIDX - 1;
            IF LINE(LINEIDX) = CR AND W6214 - 1 <> LINEIDX THEN DO;
                DO WHILE LINE(LINEIDX := LINEIDX - 1) = ' ';
                END;
                LINEIDX = LINEIDX - 1;
            END; 
        END;
    END;


    GETBOOL: PROCEDURE(CH) BYTE;
        DECLARE CH BYTE;

        IF CH = 'T' THEN
            RETURN TRUE;
        ELSE IF CH = 'F' THEN
            RETURN FALSE;
        CALL SHOWERROR(ERR$SYNTAX);
    END;

    MASKBITS: PROCEDURE(VALUE, BITCNT) ADDRESS;
        DECLARE VALUE ADDRESS, BITCNT BYTE;
        RETURN BITMASKS(BITCNT - 1) AND VALUE;
    END;

    S3B9B: PROCEDURE(N) BYTE;
        DECLARE N BYTE;
        RETURN ROL(BA625E(N), 1);
    END;
    

    S3BA8: PROCEDURE(N) BYTE;
        DECLARE N BYTE;
        RETURN BA625E(N) AND 7FH;
    END;

    S3BB6: PROCEDURE BYTE;
        DECLARE (CH, IDX) BYTE;
        IF W6214 < LINEIDX THEN
            CALL SHOWERROR(ERR$SYNTAX);
        IF (CH: = LINE(LINEIDX)) = AMPERSAND THEN DO;
            IDX = LINEIDX;
            DO WHILE LINE(LINEIDX := LINEIDX + 1) = ' ';
            END;
            IF LINE(LINEIDX) = CR THEN
                CH = LINE(LINEIDX := LINEIDX + 2);
            ELSE
                LINEIDX = IDX;
        END;
        IF LINELEN < LINEIDX THEN
            LINELEN = LINEIDX;
        LINEIDX = LINEIDX + 1;
        RETURN CH;
    END;


    TOHEXNIBBLE: PROCEDURE(CH) BYTE;
        DECLARE CH BYTE;
        IF (CH := CH - '0') > 9 THEN
            RETURN CH - 7;
        ELSE
            RETURN CH;
    END;

    S3C63: PROCEDURE BYTE;
        IF LINEIDX < W6214 THEN
            RETURN TRUE;
        ELSE
            RETURN FALSE;
    END;

    S3C79: PROCEDURE(N) BYTE;
        DECLARE N BYTE;
        IF 0 < N AND N <= 16 THEN
            RETURN N;
        CALL SHOWERROR(ERR$BADSIZE);
    END;

    S3C93: PROCEDURE;
        IF B61FC THEN DO;
            IF B6202 > 8 THEN 
                CALL SHOWERROR(ERR$WORDTOOLONG);
            IF B6204 = 0 THEN
                CALL SHOWERROR(ERR$NOFORMAT);
        END;
        ELSE IF B620D > 8 THEN
            CALL SHOWERROR(ERR$WORDTOOLONG);
    END;

    OUT$CH: PROCEDURE(CH);
        DECLARE CH BYTE;
        CALL WRITE(AFT, .CH, 1, .STATUS);
        CALL CHKSTATUS(STATUS);
    END;

    IN$CH: PROCEDURE(BUFF$P) BYTE;
        DECLARE BUFF$P ADDRESS;
        DECLARE C BASED BUFF$P BYTE;
        DECLARE (CH, ACTUAL) BYTE;  /* WARNING SYSCALL: ACTUAL OVERWRITES 2 BYTES */ 

        ACTUAL = 1;
        CALL READ(AFT, .CH, 1, .ACTUAL, .STATUS);
        CALL CHKSTATUS(STATUS);
        C = CH AND 07FH;
        IF ACTUAL <> 0 THEN
            RETURN TRUE;
        ELSE
            RETURN FALSE;
    END;

    ROLCH: PROCEDURE(CH$P, CNT);
        DECLARE CH$P ADDRESS, CNT BYTE;
        DECLARE CH BASED CH$P BYTE;
        IF CNT <> 0 THEN
            CH = ROL(CH, CNT);
    END;


    RORCH: PROCEDURE(CH$P, CNT);
        DECLARE CH$P ADDRESS, CNT BYTE;
        DECLARE CH BASED CH$P BYTE;
        IF CNT <> 0 THEN
            CH = ROR(CH, CNT);
    END;


    ROLWRD: PROCEDURE(WRD$P, CNT);
        DECLARE WRD$P ADDRESS, CNT BYTE;
        DECLARE WRD BASED WRD$P ADDRESS;
        DECLARE I BYTE;
        IF CNT = 0 THEN
            RETURN;
        DO I = 1 TO CNT;
            WRD = SCL(WRD, 1);
            IF CARRY THEN
                WRD = WRD OR 1;
            ELSE
                WRD = WRD AND 0FFFEH;
        END;
    END;

    RORWRD: PROCEDURE(WRD$P, CNT);
        DECLARE WRD$P ADDRESS, CNT BYTE;
        IF CNT = 0 THEN
            RETURN;
        CALL ROLWRD(WRD$P, 16 - CNT);
    END;

    CK1OR2: PROCEDURE(CH) BYTE;
        DECLARE CH BYTE;
        IF CH = '1' OR CH = '2' THEN
            RETURN CH;
        CALL SHOWERROR(ERR$SYNTAX);
    END;

    S3E0D: PROCEDURE;
        IF W6224 < W6218 THEN
            W6224 = W6218;
    END;

    CO$NUM: PROCEDURE(VAL, BITCNT);
        DECLARE VAL ADDRESS, BITCNT BYTE;
        DECLARE I BYTE;

        VAL = MASKBITS(VAL, BITCNT);
        CALL RORWRD(.VAL, (BITCNT - 1) AND 0FCH);
        X:  /* FORCE LXI LOAD OF I */
        DO I = 1 TO (BITCNT + 3) / 4;
            CALL CO$CH(XDIGITS(MASKBITS(VAL, 4)));
            CALL ROLWRD(.VAL, 4);
            Y: /* FORCE LXI LOAD IF I */
        END;
    END;

    S3EC0: PROCEDURE;
        DO WHILE S3BB6 = ' ';
        END;
        CALL BACKUP(1);
    END;


    CO$BINARY: PROCEDURE(VAL, BITCNT);
        DECLARE VAL ADDRESS, BITCNT BYTE;
        DECLARE (I, J) BYTE;
        IF BITCNT <> 16 THEN
            VAL = SHL(VAL, 16 - BITCNT);

        DO WHILE BITCNT <> 0;
            IF (J := BITCNT AND 3) = 0 THEN
                J = 4;
            DO I = 1 TO J;
                VAL = SCL(VAL, 1);
                IF CARRY THEN
                    CALL CO$CH('1');
                ELSE
                    CALL CO$CH('0');
            END;
            IF (BITCNT := BITCNT - J) <> 0 THEN
                CALL CO$CH('$');
        END;
    END;

    S3F50: PROCEDURE(VAL, MVAL, PROMVAL);
        DECLARE (VAL, MVAL, PROMVAL) ADDRESS;
        CALL CO$NUM(VAL, 16);
        CALL CO$BUF(.(' M='), 3);
        CALL CO$NUM(MVAL, B620D);
        CALL CO$BUF(.(' PROM='), 6);
        CALL CO$NUM(PROMVAL, B620D);
        CALL CO$CRLF;
    END;


    CHKNAME: PROCEDURE(NAME, NAMELEN) BYTE;
        DECLARE NAME ADDRESS, NAMELEN BYTE;
        DECLARE NCH BASED NAME BYTE;
        DECLARE (I, J, CH) BYTE;
        I = 0;
        CALL S3EC0;
        DO J = 1 TO NAMELEN;
            I = I + 1;
            IF NCH <> S3BB6 THEN DO;
                CALL BACKUP(I);
                RETURN FALSE;
            END;
            NAME = NAME + 1;
        END;
        IF ((CH := S3BB6) < 'A' OR CH > 'Z') AND (CH < '0' OR CH > '9') THEN DO;
            CALL BACKUP(1);
            RETURN TRUE;
        END;
        ELSE DO;
            CALL BACKUP(I + 1);
            RETURN FALSE;
        END;
    END;


    S401B: PROCEDURE(FLAG) BYTE;
        DECLARE FLAG BYTE;
        DECLARE (I, PAD) BYTE, ACTUAL ADDRESS;

        IF FLAG THEN DO;
            LINEIDX = 0;
            W6212 = 0;
        END;
        ELSE
            W6212 = LINEIDX;
        IF LINEIDX + 128 > 255 THEN
            I = 255 - LINEIDX + 1;
        ELSE
            I = 128;
        CALL READ(1, .LINE + LINEIDX, I, .ACTUAL, .STATUS);
        CALL CHKSTATUS(STATUS);
        LINEIDX = LINEIDX + ACTUAL;
        IF 255 < LINEIDX AND LINE((W6214 := LINEIDX - 1)) <> LF THEN DO;
            CALL READ(1, .LINE, 255, .ACTUAL, .STATUS);
            CALL SHOWERROR(15);
        END;
        IF LINE(W6214) <> LF THEN
            CALL CO$CRLF;
        RETURN TRUE;
    END;

    S4102: PROCEDURE(WRD$P) BYTE;
        DECLARE WRD$P ADDRESS;
        DECLARE WRD BASED WRD$P ADDRESS;
        DECLARE (B64D4, B64D5, CH, NUMTYPE, U64D8) BYTE;

        S410B: PROCEDURE(B0, B1, B2, B3) BYTE;
            DECLARE (B0, B1, B2, B3) BYTE;
            DECLARE I BYTE, TMP ADDRESS;
            WRD = 0;
            DO I = 1 TO B64D4;
                IF (CH := S3BB6) < '0' OR (B0 < CH AND CH < B1) OR B2 < CH THEN
                    RETURN FALSE;
                WRD = SHL(WRD, B3);
                IF NUMTYPE = 2 THEN DO;
                    TMP = WRD;                   /* *5 */
                    WRD = SHL(WRD, 2) + TMP;
                END;
                WRD = WRD + TOHEXNIBBLE(CH); 
            END;
            RETURN TRUE;
        END;

        IF NOT S3C63 THEN
            RETURN FALSE;

        CALL S3EC0;
        IF (CH := S3BB6) < '0' OR CH > '9' THEN
            RETURN FALSE;
        B64D4 = 1;
        B64D5 = CH;
        
        CH = S3BB6;
        DO WHILE (CH >= '0' AND CH <= '9') OR (CH >= 'A' AND CH <= 'Z');
            B64D5 = CH;
            B64D4 = B64D4 + 1;
            CH = S3BB6;
        END;
        CALL BACKUP(B64D4 + 1);
        IF B64D5 >= 'A' THEN DO;
            B64D4 = B64D4 - 1;
            IF B64D5 = 'B' THEN
                NUMTYPE = 0;
            ELSE DO;
                IF B64D5 = 'O' OR B64D5 = 'Q' THEN
                    NUMTYPE = 1;
                ELSE IF B64D5 = 'D' THEN
                    NUMTYPE = 2;
                ELSE IF B64D5 = 'H' THEN
                    NUMTYPE = 3;
                ELSE
                    RETURN FALSE;
            END;
        END;
        ELSE
            NUMTYPE = 2;
        DO CASE NUMTYPE;
            DO;     /* BINARY */
                IF NOT S410B('1', '1', '1', 1) THEN
                    RETURN FALSE;
            END;
            DO;     /* OCTAL */
                IF NOT S410B('7', '7', '7', 3) THEN
                    RETURN FALSE;
            END;
            DO;     /* DECIMAL */
                IF NOT S410B('9', '9', '9', 1) THEN
                    RETURN FALSE;
            END;
            DO;     /* HEX */
                IF NOT S410B('9', 'A', 'F', 4) THEN
                    RETURN FALSE;
            END;
        END;
        IF B64D5 >= 'A' THEN
            CH = S3BB6;
        RETURN TRUE;
    END;


    S4303: PROCEDURE(N) BYTE;
        DECLARE N BYTE;
        CALL S3EC0;
        IF S3BB6 = N THEN
            RETURN TRUE;
        ELSE DO;
            CALL BACKUP(1);
            RETURN FALSE;
        END;
    END;

    S431E: PROCEDURE(VAL, BITCNT, DST);
        DECLARE VAL ADDRESS, (BITCNT, DST) BYTE;
        IF DST THEN
            CALL CO$NUM(VAL, BITCNT);
        ELSE
            CALL CO$BINARY(VAL, BITCNT);
    END;

    S4341: PROCEDURE;
        IF NOT S4303(13) THEN
            CALL SHOWERROR(ERR$SYNTAX);
    END;

    PROMNAMEOFFSET: PROCEDURE(PROMID) ADDRESS;
        DECLARE PROMID BYTE, I BYTE, IDX ADDRESS;
        IDX = 0;
        DO I = 1 TO PROMID;
            IDX = IDX + PROMNAMES(IDX) + 1;
        END;
        RETURN IDX;
    END;


    S4389: PROCEDURE(PROM$P) BYTE;
        DECLARE PROM$P ADDRESS, PROMID BASED PROM$P BYTE;
        DECLARE I BYTE;

        PROMNAMELEN: PROCEDURE(PROMID) BYTE;
            DECLARE PROMID BYTE;
            RETURN PROMNAMES(PROMNAMEOFFSET(PROMID));
        END;

        PROMNAME: PROCEDURE(PROMID) ADDRESS;
            DECLARE PROMID BYTE;
            RETURN .PROMNAMES(PROMNAMEOFFSET(PROMID) + 1);
        END;

        CALL S3EC0;
        DO I = 0 TO 7 - 1;
            IF CHKNAME(PROMNAME(I), PROMNAMELEN(I)) THEN DO;
                PROMID = I;
                RETURN TRUE;
            END;
        END;
        RETURN FALSE;
    END;

    S43F1: PROCEDURE(N);
        DECLARE N BYTE, VAL ADDRESS;

        S43F8: PROCEDURE;
            CALL CO$BUF(.PROMNAMES(PROMNAMEOFFSET(B620F) + 1), PROMNAMES(PROMNAMEOFFSET(B620F)));
        END; 
        IF S4303('=') THEN DO;
            DO CASE N;
                VAL = S3BB6;
                IF NOT S4102(.VAL) THEN
                    CALL SHOWERROR(1);
                IF NOT S4102(.VAL) THEN
                    CALL SHOWERROR(1);
                VAL = S3BB6;
                IF NOT S4389(.VAL) THEN
                    CALL SHOWERROR(1);
            END; 
            CALL S4341;
            B6206 = 0;
            DO CASE N;
                B61F9 = GETBOOL(VAL);
                B61FE = S3C79(VAL);
                W6220 = VAL;
                B6207 = CK1OR2(VAL);
                B61FE = BA33BF(B620F := LOW(VAL));
            END;
        END;
        ELSE DO;
            CALL S4341;
            DO CASE N;
                IF B61F9 THEN       /* 0 */
                    CALL CO$CH('T');
                ELSE
                    CALL CO$CH('F');
                CALL CO$NUM(B61FE, 5);  /* 1 */
                CALL CO$NUM(W6220, 16); /* 2 */
                CALL CO$CH(B6207);      /* 3 */
                CALL S43F8;             /* 4 */
            END;
            CALL CO$CRLF;
        END;
    END;


    S456C: PROCEDURE(BUF$P, IDX, BITCNT) BYTE;
        DECLARE (BUF$P, IDX) ADDRESS, BITCNT BYTE;
        DECLARE PTR ADDRESS;
        DECLARE N BASED PTR BYTE;
        PTR = IDX + BUF$P;
        RETURN MASKBITS(N, BITCNT);
    END;

    S458D: PROCEDURE(VALB, BASE, IDX, BITCNT);
        DECLARE (VALB, BITCNT) BYTE, (BASE, IDX) ADDRESS;
        DECLARE PTR ADDRESS, N BASED PTR BYTE;
        PTR = IDX + BASE;
        N = MASKBITS(VALB, BITCNT);
        IF S456C(BASE, IDX, BITCNT) <> MASKBITS(VALB, BITCNT) THEN
            CALL SHOWERROR(B6209);
    END;

    S45EC: PROCEDURE(BASE);
        DECLARE BASE ADDRESS;
        DECLARE (B6506, B6507) BYTE;
        B6506 = 0;
        DATA$BYTE = 0;
        B6507 = B6203;

        DO WHILE B6507 > 0;
            CALL ROLCH(.DATA$BYTE, S3BA8(B6506));
            IF NOT S3B9B(B6506) THEN DO;
                DATA$BYTE = DATA$BYTE OR S456C(BASE, WA624E(B6506), S3BA8(B6506));
            END;
            B6507 = B6507 - 1;
            B6506 = B6506 + 1;
        END;
    END;


    S465A: PROCEDURE(WRD);
        DECLARE WRD ADDRESS, (B650B, B650C) BYTE;
        B650C = B6203;
        B650B = B61FF;

        DO WHILE B650C > 0;
            IF NOT S3B9B(B650B) THEN DO;
                CALL S458D(MASKBITS(DATA$BYTE, S3BA8(B650B)), 
                    WRD, WA624E(B650B) , S3BA8(B650B));
            END;
            CALL RORCH(.DATA$BYTE, S3BA8(B650B));
            B650B = B650B - 1;
            B650C = B650C - 1;
        END;
    END;

    S46D8: PROCEDURE(N) BYTE;
        DECLARE N BYTE;
        RETURN ROL(BA33C6(N), 1);
    END;


    S46E5: PROCEDURE(N, FLAG);
        DECLARE (N, FLAG) BYTE;
        IF FLAG THEN
            BA33C6(N) = BA33C6(N) OR 80H;
        ELSE
            BA33C6(N) = BA33C6(N) AND 7FH;
    END;

    S4724: PROCEDURE(PARRAYW, PBYTE) BYTE;
        DECLARE (PARRAYW, PBYTE) ADDRESS;
        DECLARE CH BASED PBYTE BYTE;
        DECLARE (I, J, K) BYTE;

        S4731: PROCEDURE;
            GETKWDSTROFFSET: PROCEDURE(ID) ADDRESS;
                DECLARE ID BYTE;
                DECLARE I BYTE, IDX ADDRESS;
                IDX = 0;
                DO I = 1 TO ID;
                    IDX = IDX + KEYWORDS(IDX) + 1;
                END;                    
                RETURN IDX;
            END;

            GETKEYWRDCHAR: PROCEDURE(ID, OFF) BYTE;
                DECLARE (ID, OFF) BYTE;
                RETURN KEYWORDS(GETKWDSTROFFSET(ID) + 1 + OFF);
            END;

            GETKEYWRDLEN: PROCEDURE(ID) BYTE;
                DECLARE ID BYTE;
                RETURN KEYWORDS(GETKWDSTROFFSET(ID));
            END;

            DO K = 0 TO 26 - 1;
                IF S46D8(K) THEN DO;
                    IF GETKEYWRDLEN(K) > J THEN DO;
                        IF GETKEYWRDCHAR(K, J) <> I THEN
                            CALL S46E5(K, 0);
                    END;
                    ELSE
                        CALL S46E5(K, 0);
                END;
            END;
        END;

        S47E9: PROCEDURE BYTE;
            DECLARE I BYTE;
            DO I = 0 TO 26 - 1;
                IF S46D8(I) THEN
                    RETURN I;
            END;
            RETURN 0;
        END;

        S480F: PROCEDURE;
            DECLARE I BYTE;

            S4812: PROCEDURE(WRD$P, N) BYTE;
                DECLARE WRD$P ADDRESS, N BYTE;
                DECLARE WRD BASED WRD$P ADDRESS, JUNK BYTE;
                IF (N := N + 1) > 16 THEN DO;
                    WRD$P = WRD$P + 2;
                    N = N - 16;
                END;
                JUNK = SCL(WRD, N); 
                IF CARRY THEN
                    RETURN TRUE;
                ELSE
                    RETURN FALSE;
            END;

            DO I = 0 TO 26 - 1;
                CALL S46E5(I, S4812(PARRAYW, I));
            END;
        END;

        S487D: PROCEDURE BYTE;
            DECLARE (I, J) BYTE;
            J = 0;
            DO I = 0 TO 26 - 1;
                IF S46D8(I) THEN
                    J = J + 1;
                IF J >= 2 THEN
                    RETURN TRUE;
            END;
            RETURN FALSE;
        END;

        S48AF: PROCEDURE BYTE;
            DECLARE I BYTE;
            DO I = 0 TO 26 - 1;
                IF S46D8(I) THEN
                    RETURN FALSE;
            END;
            RETURN TRUE;
        END;

        CALL S480F;
        CALL S3EC0;
        I = S3BB6;
        J = 0;
        DO WHILE ('A' <= I AND I <= 'Z') OR ('0' <= I AND I <= '9');
            CALL S4731;
            IF S48AF THEN DO;
                CALL BACKUP(J + 1);
                RETURN FALSE;
            END;
            I = S3BB6;
            J = J + 1;
        END;
        IF S487D OR J = 0 THEN DO;
            CALL BACKUP(J + 1);
            RETURN FALSE;
        END;
        CALL BACKUP(1);
        CH = S47E9;
        RETURN TRUE;
    END;

    S494D: PROCEDURE BYTE;
        DECLARE I BYTE;
        IF S4724(.W6246, .I) THEN
            RETURN I;
        CALL SHOWERROR(4);
    END;

    S4965: PROCEDURE(WRD$P);
        DECLARE WRD$P ADDRESS, (B3, U4, B5) BYTE,
                (W6, W8, W10) ADDRESS, WA12(2) ADDRESS, WA16(2) ADDRESS, W20 ADDRESS;
        DECLARE WRD BASED WRD$P ADDRESS;
        DECLARE BVAL BASED W6 BYTE, WVAL BASED W6 ADDRESS;;

        S496E: PROCEDURE;
            WA12(B3) = WA12(B3) AND (W20 := NOT WA6226(B5));
            WA16(B3) = WA16(B3) AND W20;
            IF B5 = 2 OR B5 = 1 OR B5 = 6 THEN DO;
                WA12(B3) = WA12(B3) AND 9DFFH;
                WA16(B3) = WA16(B3) AND 9DFFH;
            END;
            ELSE IF B5 = 5 OR B5 = 8 THEN DO;
                WA12(B3) = WA12(B3) AND 0FB7FH;
                WA16(B3) = WA16(B3) AND 0FB7FH;
            END;
        END;

        S4A88: PROCEDURE(N) BYTE;
            DECLARE N BYTE;
            RETURN BA33C6(N) AND 7FH;
        END;

        S4A96: PROCEDURE;
            DO CASE BA347D(B5);
                W8 = S3C79(W8);     /* 0 */
                W8 = GETBOOL(W8);   /* 1 */
                W8 = CK1OR2(W8);    /* 2 */
                ;                   /* 3 */
            END;
        END;

        WA12(0) = WRD;
        WRD$P = WRD$P + 2;
        WA12(1) = WRD;
        WRD$P = WRD$P + 2;
        WA16(0) = WRD;
        WRD$P = WRD$P + 2;
        WA16(1) = WRD;

        DO WHILE NOT S4303(CR);
            IF S4724(.WA12, .B5) THEN DO;
                W6 = WA6366(B5);
                DO CASE S4A88(B5);
                    BVAL = TRUE;    /* 0 */
                    BVAL = FALSE;   /* 1 */
                    DO;             /* 2 */
                        IF NOT S4102(.W8) THEN
                            CALL SHOWERROR(1);
                        CALL S4A96;
                        WVAL = W8;
                    END;
                    DO;             /* 3 */
                        IF NOT S4102(.W8) THEN
                            CALL SHOWERROR(1);
                        CALL S4A96;
                        BVAL = LOW(W8);
                    END;
                    DO;             /* 4 */
                        CALL S3EC0;
                        W8 = S3BB6;
                        CALL S4A96;
                        BVAL = LOW(W8);
                    END;
                    DO;             /* 5 */
                        W10 = .LINE + LINEIDX;
                        CALL OPEN(.AFT, W10, W6210, 0, .STATUS);
                        CALL CHKSTATUS(STATUS);
                        W10 = DELIMIT(DEBLANK(W10));
                        LINEIDX = W10 - .LINE;
                    END;
                END;
                IF B5 < 16 THEN
                    B3 = 0;
                ELSE DO;
                    B5 = B5 - 16;
                    B3 = 1;
                END;
                CALL S496E;
            END;
            ELSE
                CALL SHOWERROR(4);
        END;
        IF WA16(0) + WA16(1) <> 0 THEN
            CALL SHOWERROR(5);
    END;

    S4CA7: PROCEDURE BYTE;
        DECLARE B6541 BYTE, B6542(5) BYTE INITIAL(0, 1, 0, 0, 0);
        RETURN S4724(.B6542, .B6541);
    END;


    S4CB1: PROCEDURE BYTE;
        DECLARE B6547 BYTE, B6548(5) BYTE INITIAL(80H, 0, 0, 0, 0);
        RETURN S4724(.B6548, .B6547);
    END;

    GET$DATA$BYTE: PROCEDURE;

        GET$DATA$CHUNK: PROCEDURE;

            GET$BNPF: PROCEDURE;
                DECLARE CH BYTE, UNUSED(3) BYTE;
                DATA$BYTE = 0;
                CH = 0;
                DO WHILE CH <> 'B';
                    IF NOT IN$CH(.CH) THEN DO;
                        DATAEOF = TRUE;
                        RETURN;
                    END; 
                END;
                IF NOT IN$CH(.CH) THEN
                    CALL SHOWERROR(7); 
                DO WHILE CH <> 'F';
                    DATA$BYTE = SHL(DATA$BYTE, 1);
                    IF CH = 'P' THEN
                        DATA$BYTE = DATA$BYTE OR 1;
                    ELSE IF CH <> 'N' THEN
                        CALL SHOWERROR(7);
                
                    IF NOT IN$CH(.CH) THEN
                        CALL SHOWERROR(7);
                END;
            END;

            GET$HEX: PROCEDURE;
                DECLARE (CH, N, I) BYTE;

                IN$HEX2: PROCEDURE BYTE;
                    DECLARE (CH, N, I) BYTE;
                    DO I = 1 TO 2;
                        IF NOT IN$CH(.CH) THEN
                            CALL SHOWERROR(6);
                        IF (CH < 'A' OR 'F' < CH) AND (CH < '0' OR '9' < CH) THEN
                            CALL SHOWERROR(6); 
                        N = SHL(N, 4) OR TOHEXNIBBLE(CH);
                    END;
                    RETURN N;
                END;

                RECLEN = 0;
                CRC$IN = 0;
                CH = 0;

                DO WHILE CH <> ':';
                    IF NOT IN$CH(.CH) THEN DO;
                        DATAEOF = TRUE;
                        RETURN;
                    END;
                END; 
                
                LEN$IN = IN$HEX2;
                LOADADDR = IN$HEX2;
                LOADADDR = SHL(LOADADDR, 8) + IN$HEX2;
                CRC$IN = CRC$IN + LEN$IN + HIGH(LOADADDR) + LOW(LOADADDR);
                N = IN$HEX2;
                CRC$IN = CRC$IN + N;
                IF LEN$IN = 0 OR N = 1 THEN DO; /* END RECORD */
                    DATAEOF = TRUE;
                    RETURN;
                END;

                IF LEN$IN <= 128 THEN DO;
                    DO I = 1 TO LEN$IN;
                        RECDATA(RECLEN) = IN$HEX2;
                        CRC$IN = CRC$IN + RECDATA(RECLEN);
                        RECLEN = RECLEN + 1;
                    END;
                    IF IN$HEX2 + CRC$IN <> 0 THEN
                        CALL SHOWERROR(6);
                END;
                ELSE
                    CALL SHOWERROR(6);
            END;

            IF ISINTELHEX THEN
                CALL GET$HEX;
            ELSE
                CALL GET$BNPF;
            RECLEN = 0;
        END;

        IF ISINTELHEX THEN DO;
            IF RECLEN >= LEN$IN THEN
                CALL GET$DATA$CHUNK; 
            IF DATAEOF THEN
                RETURN;
            DATA$BYTE = RECDATA(RECLEN);
            RECLEN = RECLEN + 1;
        END;
        ELSE
            CALL GET$DATA$CHUNK;
    END;

    S4EF0: PROCEDURE(N);
        DECLARE N BYTE, U6558 ADDRESS;

        S4EF7: PROCEDURE;
            S4EFA: PROCEDURE;
                DECLARE B655B BYTE;
                CALL OUT$CH(' ');
                CALL OUT$CH('B');
                DO B655B = 1 TO 8;
                    DATA$BYTE = SCL(DATA$BYTE, 1);
                    IF CARRY THEN
                        CALL OUT$CH('P');
                    ELSE
                        CALL OUT$CH('N');
                END;
                CALL OUT$CH('F');
                CALL OUT$CH(CR);
                CALL OUT$CH(LF);
            END;

            OUT$HEXREC: PROCEDURE;
                DECLARE (B655C, B655D, RECCRC) BYTE;

                OUT$HEX2: PROCEDURE(CH);
                    DECLARE CH BYTE;
                    CALL OUT$CH(XDIGITS(SHR(CH, 4)));
                    CALL OUT$CH(XDIGITS(CH AND 0FH));
                END;

                IF RECLEN < 16 AND NOT N THEN DO;
                    RECDATA(RECLEN) = DATA$BYTE;
                    RECLEN = RECLEN + 1;
                    RETURN;
                END;
                
                B655C = 0;
                DO WHILE B655C < RECLEN;
                    CALL OUT$CH(' ');
                    CALL OUT$CH(':');
                    CALL OUT$HEX2(RECLEN);
                    CALL OUT$HEX2(HIGH(LOADADDR));
                    CALL OUT$HEX2(LOW(LOADADDR));
                    CALL OUT$CH('0');
                    CALL OUT$CH('0');
                    RECCRC = RECLEN + HIGH(LOADADDR) + LOW(LOADADDR);
                    DO B655D = 1 TO RECLEN;
                        CALL OUT$HEX2(RECDATA(B655C));
                        RECCRC = RECCRC + RECDATA(B655C);
                        B655C = B655C + 1;
                    END;
                    RECCRC = 0 - RECCRC;
                    CALL OUT$HEX2(RECCRC);
                    CALL OUT$CH(CR);
                    CALL OUT$CH(LF);
                    LOADADDR = LOADADDR + 16;
                END;

                IF NOT N THEN DO;
                    RECDATA(0) = DATA$BYTE;
                    RECLEN = 1;
                END;
            END;

            IF ISINTELHEX THEN
                CALL OUT$HEXREC;
            ELSE
                CALL S4EFA;
        END;

        IF N AND ISINTELHEX THEN DO;
            IF RECLEN > 0 THEN
                CALL S4EF7;
            RETURN;
        END;
        ELSE IF NOT ISINTELHEX AND N THEN
            RETURN;
        CALL S4EF7;
    END;

    OUT$HEXEND: PROCEDURE;
        DECLARE I BYTE;
        CALL OUT$CH(' ');
        CALL OUT$CH(':');
        DO I = 1 TO 7;
            CALL OUT$CH('0');
        END;
        CALL OUT$CH('1');
        CALL OUT$CH('F');
        CALL OUT$CH('F');
        CALL OUT$CH(CR);
        CALL OUT$CH(LF);
    END;

    SHOW$UPP$ERR: PROCEDURE(UPP$STATUS, UPP$ERROR);
        DECLARE UPP$STATUS BYTE, UPP$ERROR ADDRESS;

        IF UPP$STATUS = 40H THEN
            CALL SHOWERROR(20);
        ELSE IF UPP$STATUS = 20H THEN
            CALL SHOWERROR(21);
        ELSE IF UPP$STATUS = 10H THEN
            CALL SHOWERROR(16);
        ELSE DO;
            CALL CO$CH(HASH);
            CALL CO$CRLF;
            CALL CO$NUM(UPP$ERROR, 16);
            CALL CO$BUF(.(' UPP ERROR - STATUS '), 20);
            CALL CO$NUM(UPP$STATUS, 8);
            CALL CO$CRLF;
        END;
    END;

    UPP$READY: PROCEDURE;
        DO WHILE INPUT(0F1H);
        END;
    END;


    GET$UPP$STATUS: PROCEDURE BYTE;
        RETURN NOT INPUT(0F1H);
    END;

    S5163: PROCEDURE(UPP$CMD, ARG2B) BYTE;
        DECLARE UPP$CMD ADDRESS, ARG2B BYTE;
        DECLARE BVAL BYTE, (B6568, B6569) BYTE;

        CALL UPP$READY;
        OUTPUT(0F2H) = UPP$CMD;
        IF ARG2B = '1' THEN
            BVAL = 20H;
        ELSE
            BVAL = 0;
        OUTPUT(0F1H) = (HIGH(UPP$CMD) AND 0FH) OR BVAL;
        B6568 = INPUT(0F0H);
        B6569 = INPUT(0F1H);
        IF (B6569 AND 2) = 0 THEN
            CALL SHOW$UPP$ERR(B6569, UPP$CMD);
        ELSE
            RETURN B6568;
    END;

    S51B3: PROCEDURE(W0, B1, B2, W3) BYTE;
        DECLARE W0 ADDRESS, (B1, B2) BYTE, W3 ADDRESS;
        DECLARE BVAL BYTE, RESULT BASED W3 BYTE;

        CALL UPP$READY;
        IF B1 = '1' THEN
            BVAL = 20H;
        ELSE
            BVAL = 0;

        OUTPUT(0F1H) = (HIGH(W0) AND 0FH) OR BVAL;
        OUTPUT(0F2H) = LOW(W0);
        OUTPUT(0F0H) = B2;
        CALL UPP$READY;
        IF ((RESULT := INPUT(0F1H)) AND 2) = 0 THEN
            RETURN FALSE;
        ELSE
            RETURN TRUE;
    END;
        
    S5200: PROCEDURE;
        DECLARE (W6572, U6574, W6576) ADDRESS;

        S5203: PROCEDURE BYTE;
            DECLARE B6579 BYTE, B657A(2) ADDRESS INITIAL(400H, 0);
            RETURN S4724(.B657A, .B6579);
        END;

        IF NOT S4102(.W6572) THEN
            CALL SHOWERROR(1);

        IF S4CB1 THEN DO;
            IF NOT S4102(.W6576) THEN
                CALL SHOWERROR(1);

            W6222 = W6576;
        END;
        ELSE IF S5203 THEN
            B61FC = TRUE;

        IF NOT S4303('=') THEN
            CALL SHOWERROR(1);

        DO WHILE S3C63;
            IF NOT S4102(.DATA$BYTE) THEN
                CALL SHOWERROR(1);
            IF NOT B61FC THEN
                CALL S458D(DATA$BYTE, W6572, W6222, B620D);
            ELSE
                CALL S465A(W6572);

            IF NOT (S4303(',') OR S4303(CR)) THEN
                CALL SHOWERROR(1);
            W6572 = W6572 + 1;
        END;
    END;

    S52CD: PROCEDURE(B0, B1, W2, B3, W4, W5, W6);
        DECLARE (B0, B1, B3) BYTE, (W2, W4, W5, W6) ADDRESS;
        DECLARE VAL ADDRESS;

        DO WHILE W5 >= W4;
            VAL = S5163(W6, B0);
            IF NOT B1 THEN
                VAL = NOT VAL;
            IF B3 THEN
                CALL S45EC(W4);
            ELSE DO;
                DATA$BYTE = S456C(W4, W2, B620D);
            END;
            IF (VAL := MASKBITS(VAL, B620D)) <> DATA$BYTE THEN
                CALL S3F50(W6, DATA$BYTE, VAL);
            
            W6 = W6 + 1;
            IF (W4 := W4 + 1) = 0 THEN
                RETURN;
        END;
    END;

    S5390: PROCEDURE;
        DECLARE WA658C(4) ADDRESS INITIAL(2491H, 8000H, 1, 8000H);

        CALL S4965(.WA658C);
        CALL S3E0D;
        IF NOT GET$UPP$STATUS THEN
            CALL SHOWERROR(9);

        IF B6204 = 0 AND B61FC THEN
            CALL SHOWERROR(14);
        CALL S52CD(B620E, B620C, W6222, B61FC, W6218, W6224, 0);
    END;

    S53FA: PROCEDURE;
        CALL S43F1(0);
    END;

    S5400: PROCEDURE;
        DECLARE WA6594(4) ADDRESS INITIAL(481H, 0E000H, 1, 8000H);
        DECLARE (B659D, B659E, B659F) BYTE;

        ISINTELHEX = TRUE;
        CALL S4965(.WA6594);
        CALL S3E0D;
        IF B61FC THEN 
            B659F = B6202;
        ELSE
            B659F = B620D;

        IF B6204 = 0 AND B61FC THEN
            CALL SHOWERROR(0Eh);
        IF ISINTELHEX THEN
            B659E = 15;
        ELSE
            B659E = 3;

        DO WHILE W6224 >= W6218;
            CALL CO$NUM(W6218, 16);
            CALL CO$CH(' ');
            B659D = TRUE;
            DO WHILE W6224 >= W6218 AND ((W6218 AND B659E) <> 0 OR B659D);
                CALL CO$CH(' ');
                B659D = FALSE;
                IF B61FC THEN
                    CALL S45EC(W6218);
                ELSE
                    DATA$BYTE = S456C(W6218, W6222, B620D);

                CALL S431E(DATA$BYTE, B659F, ISINTELHEX);
                IF (W6218 := W6218 + 1) = 0 THEN DO;
                    CALL CO$CRLF;
                    RETURN;
                END;
            END;
            CALL CO$CRLF;
        END;
    END;

    S5514: PROCEDURE;
        CALL EXIT;
    END;

    S5518: PROCEDURE;
        DECLARE W65A0 ADDRESS, B65A3 BYTE;

        S551B: PROCEDURE;
            DECLARE I BYTE;
            I = 0;
            DO WHILE I <= B61FF;
                IF NOT S3B9B(I) THEN DO;
                    CALL CO$CH(ATSIGN);
                    CALL CO$NUM(WA624E(I), 16);
                END;
                ELSE
                    CALL CO$BUF(.('NULL'), 4);

                CALL CO$CH(',');
                CALL CO$NUM(S3BA8(I), 5);
                I = I + 1;
                IF I <= B61FF THEN
                    CALL CO$CH(';');
            END;
            CALL CO$CRLF;
        END;

        S558B: PROCEDURE BYTE;
            DECLARE B65A5 BYTE, BA65A6(5) BYTE INITIAL(0, 0, 0, 10H, 0);
            RETURN S4724(.BA65A6, .B65A5);
        END;

        S5595: PROCEDURE(IDX, VALUE);
            DECLARE VALUE ADDRESS, IDX BYTE;
            WA624E(IDX) = VALUE;
        END;

        S55B4: PROCEDURE(IDX, FLAG);
            DECLARE (IDX, FLAG) BYTE;

            IF FLAG THEN
                BA625E(IDX) = BA625E(IDX) OR 80H;
            ELSE
                BA625E(IDX) = BA625E(IDX) AND 7FH;
        END;

        S55F3: PROCEDURE(IDX, BVAL);
            DECLARE (IDX, BVAL) BYTE;

            BA625E(IDX) = BA625E(IDX) AND 80H;
            BA625E(IDX) = BA625E(IDX) OR MASKBITS(BVAL, 7);
        END;

        IF NOT S4303(CR) THEN DO;
            B6202 = 0;
            B65A3 = 0;
            B6204 = 0;
            B6203 = 0;
            B6206 = 0;

            DO WHILE S3C63;
                IF B65A3 >= 8 THEN
                    CALL SHOWERROR(22);
                IF S4CB1 THEN DO;
                    IF S4102(.W65A0) THEN
                        CALL S5595(B65A3, W65A0);
                    ELSE
                        CALL SHOWERROR(1);
                    CALL S55B4(B65A3, FALSE);
                    B6204 = B6204 + 1;
                END;
                ELSE IF S558B THEN
                    CALL S55B4(B65A3, TRUE);
                ELSE
                    CALL SHOWERROR(1);

                IF S4CA7 THEN DO;
                    IF S4102(.W65A0) THEN DO;
                        IF (B6202 := B6202 + S3C79(W65A0)) > 8 THEN
                            CALL SHOWERROR(0Ch);
                        CALL S55F3(B65A3, S3C79(W65A0));
                    END;
                    ELSE
                        CALL SHOWERROR(1);
                END;
                ELSE
                    CALL SHOWERROR(1);

                IF NOT (S4303(',') OR S4303(CR)) THEN
                    CALL SHOWERROR(1);

                B65A3 = B65A3 + 1;
                B6203 = B6203 + 1;
            END;
            B61FF = B65A3 - 1;
        END;
        ELSE DO;
            IF B6203 = 0 THEN
                CALL SHOWERROR(0Eh);
            CALL S551B;
        END;
    END;

    S5748: PROCEDURE;
        CALL S43F1(1);
    END;

    S574E: PROCEDURE;
        CALL S43F1(2);
    END;

    DECLARE WA65B2(4) ADDRESS INITIAL(2491H, 8400H, 1, 8400H);
    DECLARE (B65BB, B65BC, B65BD) BYTE,
            (W65BE, W65C0, W65C2, W65C4, W65C6, W65C8) ADDRESS;
    DECLARE (B65CA, B65CB, B65CC, B65CD) BYTE;
    DECLARE (W65CE, W65D0, W65D2, W65D4, W65D6) ADDRESS;
    DECLARE B65D9 BYTE;
    DECLARE WA65DA(4) ADDRESS INITIAL(2581H, 0A240H, 1, 8040H);
    DECLARE WA65E2(5) ADDRESS INITIAL(2580H, 23C0H, 0, 140H, 0);
    DECLARE WA65EC(4) ADDRESS INITIAL(2491H, 8000H, 1, 8000H);

    S5754: PROCEDURE;
        
        S5757: PROCEDURE;
            IF (B620D <> 8 AND NOT B65BD) OR (B6202 > 8 AND B65BD) THEN
                CALL SHOWERROR(17);
            W65C6 = W65C2;
            W65C8 = W65BE;

            DO WHILE W65C8 <= W65C0;
                IF B65BD THEN
                    CALL S45EC(W65C8);
                ELSE DO;
                    DATA$BYTE = S456C(W65C8, W65C4, B620D);
                END;
                IF NOT B65BC THEN
                    DATA$BYTE = NOT DATA$BYTE;
                IF NOT S51B3(W65C6, B65BB, DATA$BYTE, .B65CA) THEN
                    CALL SHOW$UPP$ERR(B65CA, W65C6);
                W65C6 = W65C6 + 1;
                IF (W65C8 := W65C8 + 1) = 0 THEN
                    GOTO DONE;
            END;
        DONE:
            CALL S52CD(B65BB, B65BC, W65C4, B65BD, W65BE, W65C0, W65C2);
        END;

        S585E: PROCEDURE;
            IF (B620D <> 8 AND NOT B65BD) OR (B6202 > 8 AND B65BD) THEN
                CALL SHOWERROR(17);
            IF W65C2 <> 0 THEN
                CALL SHOWERROR(18);
            W65D2 = W65C0 - W65BE + 1;
            IF W65D2 <> 512 AND W65D2 <> 1024 THEN
                CALL SHOWERROR(19);
            DO B65CC = 1 TO 100;
                W65CE = 0;
                W65D0 = W65BE;
                DO WHILE W65C0 >= W65D0;
                    IF B65BD THEN
                        CALL S45EC(W65D0);
                    ELSE DO;
                        DATA$BYTE = S456C(W65D0, W65C4, B620D);
                    END;
                    IF NOT B65BC THEN
                        DATA$BYTE = NOT DATA$BYTE;        
                    B65CD = S51B3(W65CE, B65BB, DATA$BYTE, .B65CB);
                    W65CE = W65CE + 1;
                    IF (W65D0 := W65D0 + 1) = 0 THEN
                        GOTO BREAK;
                END;
        BREAK:
            END;
            CALL S52CD(B65BB, B65BC, W65C4, B65BD, W65BE, W65C0, 0);
        END;


        S59BA: PROCEDURE;
            IF (B620D <> 4 AND NOT B65BD) OR (B6202 > 4 AND B65BD) THEN
                CALL SHOWERROR(17);
            W65D4 = W65C2;
            W65D6 = W65BE;
            DO WHILE W65C0 >= W65D6;
                IF B65BD THEN
                    CALL S45EC(W65D6);
                ELSE
                    DATA$BYTE = S456C(W65D6, W65C4, B620D);

                IF NOT B65BC THEN
                    DATA$BYTE = NOT DATA$BYTE;
                IF NOT S51B3(W65D4, B65BB, DATA$BYTE, .B65D9) THEN
                    CALL SHOW$UPP$ERR(B65D9, W65D4);
                W65D4 = W65D4 + 1;
                IF (W65D6 := W65D6 + 1) = 0 THEN
                    GOTO BREAK;
            END;
        BREAK:
            CALL S52CD(B65BB, B65BC, W65C4, B65BD, W65BE, W65C0, W65C2);
        END; 

        /* S5757 */
        IF NOT S4303(DQUOTE) THEN DO;
            CALL S4965(.WA65B2);
            CALL S3E0D;
            W65BE = W6218;
            W65C0 = W6224;
            W65C2 = W621E;
            W65C4 = W6222;
            B65BB = B620E;
            B65BC = B620C;
            B65BD = B61FC;
            B6206 = TRUE;
        END;
        ELSE DO;
            CALL S4341;
            IF NOT B6206 THEN
                CALL SHOWERROR(11);
        END;
        IF NOT GET$UPP$STATUS THEN
            CALL SHOWERROR(9);
        IF B6204 = 0 AND B65BD THEN
            CALL SHOWERROR(14);
        DO CASE B620F;
            ;              /* 0 */
            CALL S5757;    /* 1 */
            CALL S585E;    /* 2 */
            CALL S59BA;    /* 3 */
            CALL S59BA;    /* 4 */
            CALL S5757;    /* 5 */
            CALL S5757;    /* 6 */
        END;
    END;

    S5B9C: PROCEDURE;

        W6210 = 2;
        RECLEN = 0;
        ISINTELHEX = TRUE;
        CALL S4965(.WA65DA);
        CALL S3E0D;
        CALL S3C93;
        LOADADDR = W6218;
        IF B6204 = 0 AND B61FC THEN
            CALL SHOWERROR(14);

        DO WHILE W6224 >= W6218;
            IF NOT B61FC THEN DO;
                DATA$BYTE = S456C(W6218, W6222, B620D);
            END;
            ELSE
                CALL S45EC(W6218);

            IF NOT B620C THEN
                DATA$BYTE = NOT DATA$BYTE;

            CALL S4EF0(0);
            IF (W6218 := W6218 + 1) = 0 THEN
                GOTO BREAK;
        END;
    BREAK:
        CALL S4EF0(TRUE);
        CALL CLOSE(AFT, .STATUS);
    END;

    S5C5A: PROCEDURE;
        W6210 = 1;
        LEN$IN = 0;
        CRC$IN = 0;
        W6224 = 0FFFFH;
        ISINTELHEX = TRUE;
        DATAEOF = FALSE;
        LOADADDR = 0;
        CALL S4965(.WA65E2);
        CALL S3E0D;
        CALL S3C93;
        IF B6204 = 0 AND B61FC THEN
            CALL SHOWERROR(14);
        DO WHILE (NOT (W6224 < LOADADDR) OR ISINTELHEX) AND NOT DATAEOF;
            CALL GET$DATA$BYTE;
            IF NOT DATA$EOF THEN DO;
                IF NOT B620C THEN
                    DATA$BYTE = NOT DATA$BYTE;
                IF NOT B61FC THEN
                    CALL S458D(MASKBITS(DATA$BYTE, B620D), W6218 + LOADADDR, W6222, B620D); 
                ELSE
                    CALL S465A(W6218 + LOADADDR);
            END;
            IF (LOADADDR := LOADADDR + 1) = 0 THEN DO;
                CALL CLOSE(AFT, .STATUS);
                RETURN;
            END;
        END;
        CALL CLOSE(AFT, .STATUS);
    END;

    S5D4D: PROCEDURE;
        CALL S43F1(3);
    END;


    S5D53: PROCEDURE;
        DECLARE W65F4 ADDRESS, PAD ADDRESS;
        CALL S4965(.WA65EC);
        CALL S3E0D;
        IF NOT GET$UPP$STATUS THEN
            CALL SHOWERROR(9);
        w65F4 = 0;
        IF B6204 = 0 and B61FC THEN
            CALL SHOWERROR(14);
        DO WHILE W6224 >= W6218;
            DATA$BYTE = S5163(W65F4, b620E);
            IF NOT B620C THEN
                DATA$BYTE = NOT DATA$BYTE;
            IF B61FC THEN DO;
                IF B6204 = 0 THEN
                    CALL SHOWERROR(14);
                CALL S465A(W6218);
            END;
            ELSE
                CALL S458D(DATA$BYTE, W6218, W6222, B620D);
            W65F4 = W65F4 + 1;
            IF (W6218 := W6218 + 1) = 0 THEN
                RETURN;
        END;
    END;

    S5E13: PROCEDURE;
        CALL S43F1(4);
    END;

    S5E19: PROCEDURE BYTE;

        S5E1C: PROCEDURE BYTE;
            DECLARE II ADDRESS;
            II = W6212;
            DO WHILE II <= W6214;
                IF LINE(II) = AMPERSAND THEN DO;
                    DO WHILE LINE(II := II + 1) = ' ';
                    END;
                    IF LINE(II) = CR THEN
                        RETURN TRUE;
                    ELSE
                        II = II - 1;
                END;
                II = II + 1;
            END;
            RETURN FALSE;
        END;

        W6222 = W6220;
        B620D = B61FE;
        B620C = B61F9;
        B620E = B6207;
        B61FC = 0;
        ISINTELHEX = TRUE;
        B6209 = LF;
        CALL CO$CH('*');
        DO WHILE NOT S401B(TRUE);
            CALL CO$CH('*');
        END;

        DO WHILE S5E1C;
            CALL CO$BUF(.('**'), 2);
            DO WHILE NOT S401B(FALSE);
                CALL CO$BUF(.('**'), 2);
            END;
        END;
        LINELEN = 0;
        LINEIDX = 0;
        RETURN S494D;
    END;


    INIT: PROCEDURE;
        DECLARE (I, J) BYTE, (ACTUAL, U65FE) ADDRESS;
        S5F07: PROCEDURE;
            DO WHILE NOT S401B(TRUE);
                CALL CO$CH('*');
            END;
            LINEIDX = 0;
            LINELEN = 0;
        END;

        CALL READ(1, .LINE, 255, .ACTUAL, .STATUS);
        B6204 = 0;
        B6203 = 0;
        B6202 = 0;
        B6206 = 0;
        DO J = 0 TO 26 - 1;
            WA6366(J) = 0;
        END;
        WA6366(2) = .B620C;
        WA6366(5) = .B61FC;
        WA6366(7) = .B620D;
        WA6366(8) = .W6222;
        WA6366(11) = .B620E;
        WA6366(15) = .W6218;
        WA6366(16) = .W6224;
        WA6366(17) = .ISINTELHEX;
        WA6366(18) = .ISINTELHEX;
        WA6366(21) = .W621E;
        WA6366(22) = .ISINTELHEX;
        WA6366(23) = .W6218;
        WA6366(24) = .W6224;
        CALL CO$BUF(.SIGNON, 21);
        CALL CO$CRLF;
        B620F = 0;
        W6220 = .MEMORY;
        B6207 = '1';
        B61F9 = TRUE;
        I = 255;
        DO WHILE I;
            CALL CO$BUF(.('TYPE* '), 6);
            CALL S5F07;
            IF S4389(.J) THEN DO;
                IF S4303(CR) THEN DO;
                    B61FE = BA33BF(B620F := J);
                    I = FALSE;
                END;
            END;
        END;
    END;

/* MAIN */
    CALL INIT;
RESTART:
    DO WHILE 1;
        DO CASE S5E19;
            DO;             /* 0 */
                B6209 = 3;
                CALL S5200;
            END;
            CALL S5390;     /* 1 */
            CALL S53FA;     /* 2 */
            CALL S5400;     /* 3 */ 
            CALL S5514;     /* 4 */
            CALL S5518;     /* 5 */
            CALL SHOWERROR(4); /* 6 */
            CALL S5748;     /* 7 */
            CALL S574E;     /* 8 */
            CALL S5754;     /* 9 */
            CALL S5C5A;     /* 10 */
            CALL S5D4D;     /* 11 */
            CALL S5D53;     /* 12 */
            CALL S5E13;     /* 13 */
            CALL S5B9C;     /* 14 */
        END;
    END;
EOF
