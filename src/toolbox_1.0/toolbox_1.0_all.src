csd/chklod.csd
;----------------------------CHKLOD.GSD-----------------------------;

PLM80 :F1:CHKLOD.SRC
PLM80 :F1:CINVOK.SRC
PLM80 :F1:CMOVEM.SRC
PLM80 :F1:CGREAT.SRC
PLM80 :F1:CDIREC.SRC

ASM80 :F1:CSORT2.SRC

LINK   :F1:CHKLOD.OBJ, :F1:CINVOK.OBJ, :F1:CMOVEM.OBJ, &
       :F1:CGREAT.OBJ, :F1:CSORT2.OBJ, :F1:CDIREC.OBJ, &
       :F1:FNAMES.LIB, :F1:UTIL2.LIB ,:F1:SYS2.LIB, &
       :F1:ISIS3.LIB,  :F0:PLM80.LIB                   &
    TO :F1:CHKLOD.LNK

LOCATE :F1:CHKLOD.LNK TO :F1:CHKLOD PURGE

;--------------------------END CHKLOD.GSD---------------------------;
csd/clean.csd
;---------------------------CLEAN.GSD---------------------------;

PLM80 :F1:CLEAN.SRC

LINK :F1:CLEAN.OBJ,:F1:ISIS3.LIB,          &
    :F1:CUSP3.LIB,:F1:SYS1.LIB,:F1:UTIL3.LIB, &
    PLM80.LIB                          &
    TO :F1:CLEAN.LNK

LOCATE :F1:CLEAN.LNK TO :F1:CLEAN PURGE

;-------------------------END CLEAN.GSD-------------------------;
csd/compar.csd
;----------------------------COMPAR.GSD--------------------------;

PLM80 :F1:COMPAR.SRC DEBUG XREF
PLM80 :F1:TAIL.SRC DEBUG XREF
PLM80 :F1:OUT.SRC DEBUG XREF

ASM80 :F1:M3.SRC
ASM80 :F1:DIVIDE.SRC

LINK :F1:COMPAR.OBJ,:F1:TAIL.OBJ,:F1:OUT.OBJ,&
     :F1:M3.OBJ,:F1:DIVIDE.OBJ,                  &
     :F0:SYSTEM.LIB,PLM80.LIB TO :F1:COMPAR.LNK &
     MAP PRINT(:F1:COMPAR.MP1)

LOCATE :F1:COMPAR.LNK TO :F1:COMPAR &
       MAP PRINT(:F1:COMPAR.MP2) PURGE

;--------------------------END COMPAR.GSD------------------------;
csd/consol.csd
;------------------------CONSOL.CSD------------------------;

PLM80 :F1:CONSOL.SRC DEBUG XREF

LINK :F1:CONSOL.OBJ,:F1:CUSP4.LIB,PLM80.LIB,:F0:SYSTEM.LIB &
    TO :F1:CONSOL.LNK MAP PRINT(:F1:CONSOL.MP1)

LOCATE :F1:CONSOL.LNK TO :F1:CONSOL PURGE &
    MAP LINES SYMBOLS PUBLICS PRINT(:F1:CONSOL.MP2)

;----------------------END CONSOL.CSD----------------------;
csd/dcopy.csd
;---------------------------DCOPY.CSD---------------------------;

PLM80 :F1:DCOPY.SRC DEBUG XREF

LINK :F1:DCOPY.OBJ,:F0:SYSTEM.LIB,&
    :F1:CUSP5.LIB,PLM80.LIB TO :F1:DCOPY.LNK MAP PRINT(:F1:DCOPY.MP1)

LOCATE :F1:DCOPY.LNK LINES SYMBOLS PRINT(:F1:DCOPY.MP2) PURGE

;-------------------------END DCOPY.CSD-------------------------;
csd/delete.csd
;----------------------------DELETE.CSD---------------------------;

FG
DELETE :F1:*.BAK,:F1:*.OBJ,:F1:*.LNK,:F1:*.CS,:F1:*.TMP,:F1:*.LST
BG

;--------------------------END DELETE.CSD-------------------------;
ENDJOB
csd/dsort.csd
;-----------------------------DSORT.GSD-------------------------------;

PLM80 :F1:DSORT.SRC

LINK :F1:DSORT.OBJ, :F1:CUSP6.LIB,:F1:CUSP3.LIB,&
     :F0:SYSTEM.LIB,PLM80.LIB                 &
  TO :F1:DSORT.LNK                                &
                    MAP PRINT(:F1:DSORT.MP1)

LOCATE :F1:DSORT.LNK TO :F1:DSORT PURGE

;---------------------------END DSORT.GSD-----------------------------;
csd/else.csd
;----------------------------ELSE.GSD----------------------------;

ASM80 :F1:SEQ.SRC
PLM80 :F1:ELSE.SRC

LINK :F1:ELSE.OBJ,:F1:SEQ.OBJ,:F1:CUSP7.LIB,    &
     :F0:SYSTEM.LIB,:F0:PLM80.LIB               &
  TO :F1:ELSE.LNK

LOCATE :F1:ELSE.LNK TO :F1:ELSE &
    PURGE

;--------------------------END ELSE.GSD--------------------------;
csd/endif.csd
;---------------------------ENDIF.CSD---------------------------;

PLM80 :F1:ENDIF.SRC XREF

LINK :F1:ENDIF.OBJ,:F0:SYSTEM.LIB,PLM80.LIB TO :F1:ENDIF.LNK &
    MAP PRINT(:F1:ENDIF.MP1)

LOCATE :F1:ENDIF.LNK TO :F1:ENDIF PURGE &
    MAP PRINT(:F1:ENDIF.MP2)

;-------------------------END ENDIF.CSD-------------------------;
csd/errs.csd
;---------------------------ERRS.CSD---------------------------;

PLM80 :F1:ERRS.SRC XREF

LINK :F1:ERRS.OBJ,:F1:CUSP2.LIB,:F1:UTIL2.LIB,         &
    :F1:SYS2.LIB,:F0:SYSTEM.LIB,PLM80.LIB            &
    TO :F1:ERRS.LNK                                          &
    MAP PRINT(:F1:ERRS.MP1)

LOCATE :F1:ERRS.LNK TO :F1:ERRS &
    MAP PRINT(:F1:ERRS.MP2)       &
    PURGE

;-------------------------END ERRS.CSD-------------------------;
csd/exit.csd
;----------------------------EXIT.GSD----------------------------;

PLM80 :F1:EXIT.SRC

LINK :F1:EXIT.OBJ,:F1:CUSP7.LIB,:F0:SYSTEM.LIB, &
     :F0:PLM80.LIB                              &
  TO :F1:EXIT.LNK

LOCATE :F1:EXIT.LNK TO :F1:EXIT &
    PURGE

;--------------------------END EXIT.GSD--------------------------;
csd/ganef.csd
;---------------------------GANEF.CSD---------------------------;

PLM80 :F1:GANEF.SRC XREF

LINK :F1:GANEF.OBJ,:F1:CUSP2.LIB,:F1:UTIL2.LIB,         &
    :F1:SYS2.LIB,:F0:SYSTEM.LIB,PLM80.LIB            &
    TO :F1:GANEF.LNK                                          &
    MAP PRINT(:F1:GANEF.MP1)

LOCATE :F1:GANEF.LNK TO :F1:GANEF &
    MAP PRINT(:F1:GANEF.MP2)       &
    PURGE

;-------------------------END GANEF.CSD-------------------------;
csd/goto.csd
;----------------------------GOTO.GSD----------------------------;

ASM80 :F1:SEQ.SRC
PLM80 :F1:GOTO.SRC

LINK :F1:GOTO.OBJ,:F1:SEQ.OBJ,:F1:CUSP7.LIB,    &
     :F0:SYSTEM.LIB,:F0:PLM80.LIB               &
  TO :F1:GOTO.LNK

LOCATE :F1:GOTO.LNK TO :F1:GOTO &
     PURGE

;--------------------------END GOTO.GSD--------------------------;
csd/hdback.csd
;-------------------------HDBACK.CSD--------------------------;

PLM80 :F1:HDBACK.SRC DEBUG XREF
PLM80 :F1:FILES.SRC DEBUG XREF
PLM80 :F1:COPY.SRC DEBUG XREF

LINK :F1:HDBACK.OBJ,:F1:FILES.OBJ,&
    :F1:CUSP2.LIB,PLM80.LIB,     &
    :F0:SYSTEM.LIB TO :F1:HDBACK.LNK  &
    MAP PRINT(:F1:HDBACK.MP1)

LOCATE :F1:HDBACK.LNK PURGE       &
    MAP PRINT(:F1:HDBACK.MP2) PUBLICS SYMBOLS

;-----------------------END HDBACK.CSD------------------------;
csd/if.csd
;----------------------------IF.GSD----------------------------;

ASM80 :F1:SEQ.SRC
PLM80 :F1:IF.SRC

LINK :F1:IF.OBJ,:F1:SEQ.OBJ,:F1:CUSP7.LIB, &
     :F0:SYSTEM.LIB, :F0:PLM80.LIB         &
  TO :F1:IF.LNK

LOCATE :F1:IF.LNK TO :F1:IF &
    PURGE

;--------------------------END IF.GSD--------------------------;
csd/last.csd
;---------------------------LAST.CSD---------------------------;

PLM80 :F1:LAST.SRC XREF

LINK :F1:LAST.OBJ,:F1:CUSP2.LIB,:F1:UTIL2.LIB,:F1:SYS2.LIB, &
    :F0:SYSTEM.LIB,PLM80.LIB            &
    TO :F1:LAST.LNK                                          &
    MAP PRINT(:F1:LAST.MP1)

LOCATE :F1:LAST.LNK TO :F1:LAST &
    MAP PRINT(:F1:LAST.MP2)       &
    PURGE

;-------------------------END LAST.CSD-------------------------;
csd/latest.csd
;---------------------------LATEST.GSD---------------------------;

PLM80 :F1:LATEST.SRC

LINK :F1:LATEST.OBJ,      :F1:CUSP3.LIB,   &
         :F1:UTIL3.LIB,    :F1:SYS1.LIB,    &
         :F1:ISIS3.LIB,   PLM80.LIB   &
      TO :F1:LATEST.LNK

LOCATE :F1:LATEST.LNK TO :F1:LATEST PURGE

;-------------------------END LATEST.GSD-------------------------;
csd/loop.csd
;-------------------------LOOP.CSD---------------------------;

PLM80 :F1:LOOP.SRC

LINK  :F1:LOOP.OBJ,:F1:PFF.LIB,:F0:SYSTEM.LIB,&
    PLM80.LIB TO :F1:LOOP.LNK

LOCATE :F1:LOOP.LNK TO :F1:LOOP PURGE

;-----------------------END LOOP.CSD-------------------------;
csd/lower.csd
;---------------------------LOWER.CSD---------------------------;

PLM80 :F1:LOWER.SRC XREF

LINK :F1:LOWER.OBJ,:F1:CUSP3.LIB,:F1:SYS1.LIB,:F1:UTIL3.LIB,&
    :F1:UNIXIO.LIB,:F0:SYSTEM.LIB,PLM80.LIB              &
    TO :F1:LOWER.LNK                                         &
    MAP PRINT(:F1:LOWER.MP1)

LOCATE :F1:LOWER.LNK TO :F1:LOWER      &
    MAP PRINT(:F1:LOWER.MP2) PURGE

;-------------------------END LOWER.CSD-------------------------;
csd/merg80.csd
;---------------------------MERG80.CSD---------------------------;

PLM80 :F1:MERG80.SRC XREF

LINK :F1:MERG80.OBJ,:F1:BLTSYM.OBJ,:F1:SORT2.OBJ,           &
    :F1:CUSP2.LIB,:F1:UTIL2.LIB,                             &
    :F1:SYS2.LIB,:F0:SYSTEM.LIB,PLM80.LIB,:F1:FNAMES.LIB &
    TO :F1:MERG80.LNK                                           &
    MAP PRINT(:F1:MERG80.MP1)

LOCATE :F1:MERG80.LNK TO :F1:MERG80 &
    MAP PRINT(:F1:MERG80.MP2)       &
    PURGE

;-------------------------END MERG80.CSD-------------------------;
csd/merg86.csd
;----------------------------MERG86.GSD--------------------------;

ASM80 :F1:BSYM86.SRC            TITLE('BSYM86')
ASM80 :F1:SORT2.SRC             TITLE('SORT')
PLM80 :F1:MERG86.SRC DEBUG XREF TITLE('MERG86')

LINK :F1:MERG86.OBJ,:F1:BSYM86.OBJ,:F1:FNAMES.LIB,:F1:SORT2.OBJ, &
     :F1:UTIL2.LIB,:F1:SYS2.LIB,PLM80.LIB TO :F1:MERG86.LNK

LOCATE :F1:MERG86.LNK PRINT(:F1:MERG86.MP2) PURGE

;--------------------------END MERG86.GSD------------------------;
csd/mrkobj.csd
;---------------------------MRKOBJ.GSD------------------------------;

PLM80 :F1:MRKOBJ.SRC
PLM80 :F1:MINVOK.SRC
PLM80 :F1:MFILER.SRC

LINK :F1:MRKOBJ.OBJ,:F1:MINVOK.OBJ,:F1:MFILER.OBJ, &
    :F1:FNAMES.LIB,:F1:UTIL2.LIB,:F1:SYS2.LIB,PLM80.LIB  &
    TO :F1:MRKOBJ.LNK  &
    MAP PRINT(:F1:MRKOBJ.MP1)

LOCATE :F1:MRKOBJ.LNK TO :F1:MRKOBJ &
    MAP PRINT(:F1:MRKOBJ.MP2) PURGE

;-------------------------END MRKOBJ.GSD----------------------------;
csd/note.csd
;----------------------------NOTE.GSD----------------------------;

PLM80 :F1:NOTE.SRC

LINK :F1:NOTE.OBJ,:F1:CUSP7.LIB,:F0:SYSTEM.LIB, &
     :F0:PLM80.LIB                              &
  TO :F1:NOTE.LNK

LOCATE :F1:NOTE.LNK TO :F1:NOTE PURGE

;--------------------------END NOTE.GSD--------------------------;
csd/pack.csd
;---------------------------PACK.CSD------------------------;

PLM80 :F1:PACK.SRC TITLE('BLANK COMPRESSION UTILITY') XREF
PLM80 :F1:PACKER.SRC TITLE('BLANK COMPRESSOR') XREF

LINK :F1:PACK.OBJ,:F1:PACKER.OBJ,:F1:CUSP6.LIB,PLM80.LIB,&
    :F0:SYSTEM.LIB TO :F1:PACK.LNK &
    MAP PRINT(:F1:PACK.MP1)

LOCATE :F1:PACK.LNK PURGE &
    MAP PRINT(:F1:PACK.MP2)

;-------------------------END PACK.CSD----------------------;
csd/passif.csd
;-------------------------PASSIF.GSD------------------------;

PLM80  :F1:CLI.SRC
PLM80  :F1:ERRMSG.SRC
PLM80  :F1:FUNC.SRC
PLM80  :F1:MAIN.SRC PRINT(:F1:PASSIF.LST)
PLM80  :F1:REPORT.SRC
PLM80  :F1:TOKENS.SRC

LINK   :F1:MAIN.OBJ,:F1:CLI.OBJ,:F1:ERRMSG.OBJ,   &
       :F1:FUNC.OBJ,:F1:REPORT.OBJ,:F1:TOKENS.OBJ,&
       :F1:UTIL3.LIB,:F0:SYSTEM.LIB,PLM80.LIB     &
    TO :F1:PASSIF.LNK                             &
       MAP PRINT(:F1:PASSIF.MP1)

LOCATE :F1:PASSIF.LNK TO :F1:PASSIF PURGE

;-----------------------END PASSIF.GSD----------------------;
csd/pause.csd
;---------------------------PAUSE.GSD---------------------------;

PLM80 :F1:PAUSE.SRC XREF

LINK :F1:PAUSE.OBJ,:F1:CUSP2.LIB,:F1:UTIL2.LIB,         &
    :F1:PFF.LIB,                                              &
    :F1:SYS2.LIB,:F0:SYSTEM.LIB,:F0:PLM80.LIB               &
    TO :F1:PAUSE.LNK                                          &
    MAP PRINT(:F1:PAUSE.MP1)

LOCATE :F1:PAUSE.LNK TO :F1:PAUSE &
    MAP PRINT(:F1:PAUSE.MP2)       &
    PURGE

;-------------------------END PAUSE.GSD-------------------------;
csd/relab.csd
;-------------------------RELAB.CSD---------------------------;

PLM80 :F1:RELAB.SRC XREF DEBUG

LINK  :F1:RELAB.OBJ,:F1:PFF.LIB,:F0:SYSTEM.LIB,&
    PLM80.LIB TO :F1:RELAB.LNK                 &
    MAP PRINT(:F1:RELAB.MP1)

LOCATE :F1:RELAB.LNK TO :F1:RELAB PURGE MAP &
    PRINT(:F1:RELAB.MP2) LINES SYMBOLS PUBLICS

;-----------------------END RELAB.CSD-------------------------;
csd/rescan.csd
;---------------------------RESCAN.CSD---------------------------;

PLM80 :F1:RESCAN.SRC XREF

LINK :F1:RESCAN.OBJ,:F0:PLM80.LIB,:F0:SYSTEM.LIB &
  TO :F1:RESCAN.LNK                              &
     MAP PRINT(:F1:RESCAN.MP1)

LOCATE :F1:RESCAN.LNK TO :F1:RESCAN &
       MAP PRINT(:F1:RESCAN.MP2)       &
       PURGE

;-------------------------END RESCAN.CSD-------------------------;
csd/return.csd
;----------------------------RETURN.GSD----------------------------;

PLM80 :F1:RETURN.SRC

LINK :F1:RETURN.OBJ,:F1:CUSP7.LIB,:F0:SYSTEM.LIB, &
     :F0:PLM80.LIB                              &
  TO :F1:RETURN.LNK

LOCATE :F1:RETURN.LNK TO :F1:RETURN &
    PURGE

;--------------------------END RETURN.GSD--------------------------;
csd/sort.csd
;---------------------------SORT.CSD---------------------------;

PLM80 :F1:SORT.SRC XREF

LINK :F1:SORT.OBJ,:F1:CUSP3.LIB,:F1:SYS1.LIB,  &
    :F1:UTIL3.LIB,:F0:SYSTEM.LIB,PLM80.LIB TO &
    :F1:SORT.LNK &
    MAP PRINT(:F1:SORT.MP1)

LOCATE :F1:SORT.LNK TO :F1:SORT &
    MAP PRINT(:F1:SORT.MP2) PURGE

;-------------------------END SORT.CSD-------------------------;
csd/stopif.csd
;---------------------------STOPIF.GSD---------------------------;

PLM80 :F1:STOPIF.SRC XREF

LINK  :F1:STOPIF.OBJ,:F1:CUSP2.LIB,:F1:UTIL2.LIB,         &
      :F1:SYS2.LIB,:F0:SYSTEM.LIB,:F0:PLM80.LIB            &
   TO :F1:STOPIF.LNK                                          &
      MAP PRINT(:F1:STOPIF.MP1)

LOCATE :F1:STOPIF.LNK TO :F1:STOPIF &
       MAP PRINT(:F1:STOPIF.MP2)       &
       PURGE

;-------------------------END STOPIF.GSD-------------------------;
csd/unpack.csd
;--------------------------UNPACK.CSD------------------------;

PLM80 :F1:UNPACK.SRC XREF TITLE('BLANK DECOMPRESSION UTILITY')
PLM80 :F1:UNPAKR.SRC XREF TITLE('BLANK DECOMPRESSOR')

LINK :F1:UNPACK.OBJ,:F1:UNPAKR.OBJ,:F1:CUSP6.LIB,PLM80.LIB,&
    :F0:SYSTEM.LIB TO :F1:UNPACK.LNK &
    MAP PRINT(:F1:UNPACK.MP1)

LOCATE :F1:UNPACK.LNK PURGE &
    MAP PRINT(:F1:UNPACK.MP2)

;------------------------END UNPACK.CSD----------------------;
csd/upper.csd
;---------------------------UPPER.CSD---------------------------;

PLM80 :F1:UPPER.SRC XREF

LINK :F1:UPPER.OBJ,:F1:CUSP6.LIB,:F1:UTIL3.LIB,:F1:SYS1.LIB, &
    :F0:SYSTEM.LIB,PLM80.LIB            &
    TO :F1:UPPER.LNK                                          &
    MAP PRINT(:F1:UPPER.MP1)

LOCATE :F1:UPPER.LNK TO :F1:UPPER &
    MAP PRINT(:F1:UPPER.MP2)       &
    PURGE

;-------------------------END UPPER.CSD-------------------------;
csd/wait.csd
;----------------------------WAIT.GSD----------------------------;

PLM80 :F1:WAIT.SRC

LINK :F1:WAIT.OBJ,:F1:CUSP7.LIB,:F0:SYSTEM.LIB, &
     :F0:PLM80.LIB                              &
  TO :F1:WAIT.LNK

LOCATE :F1:WAIT.LNK TO :F1:WAIT &
    PURGE

;--------------------------END WAIT.GSD--------------------------;
csd/which.csd
;-----------------------WHICH.GSD---------------------------;

PLM80 :F1:WHICH.SRC

LINK :F1:WHICH.OBJ,  &
         :F1:ISIS3.LIB,   &
         :F1:SYS1.LIB,    &
         :F1:CUSP3.LIB,   &
         :F1:UTIL3.LIB,   &
         PLM80.LIB   &
      TO :F1:WHICH.LNK

LOCATE :F1:WHICH.LNK TO :F1:WHICH PURGE

;---------------------END WHICH.GSD-------------------------;
csd/xlate2.csd
;-------------------------------XLATE2.GSD----------------------------;

PLM80 :F1:XLATE2.SRC

LINK :F1:XLATE2.OBJ,  :F1:UTIL2.LIB,  :F1:SYS2.LIB,  &
     :F1:ISIS3.LIB,   :F0:PLM80.LIB                  &
  TO :F1:XLATE2.LNK

LOCATE :F1:XLATE2.LNK TO :F1:XLATE2 PURGE

;-----------------------------END XLATE2.GSD--------------------------;
cusp1/cusp1_all.src
?cpyrit.plm
/* b1=01, b2=31, CODE(0H) byte, DATA(0H) byte, STACK(0H) byte, MEMORY(0H) byte,*/
COPYRIGHT: DO;
end;

?dblank.plm
/* b1=01, b2=31, CODE(1DH) byte, DATA(2H) byte, STACK(0H) byte, MEMORY(0H) byte,*/
DEBLANK: DO;

deblank: procedure(ptr) address public;
	declare ptr address;
	declare c based ptr byte;

	do while (c = ' ');
		ptr = ptr + 1;
	end;
	return ptr;
end;

end;
?dlimit.plm
/* b1=01, b2=31, CODE(4FH) byte, DATA(2H) byte, STACK(4H) byte, MEMORY(0H) byte,*/
DELIMIT: DO;

delimit: procedure(ptr) address public;
	declare ptr address;
	declare c based ptr byte;

	do while (c = ':' or c = '.' or ('0' <= c and c <= '9') or ('A' <= c and c <= 'Z'));
		ptr = ptr + 1;
	end;
	return ptr;
end;
end;
?dmeq.plm
/* b1=01, b2=31, CODE(A3H) byte, DATA(12H) byte, STACK(8H) byte, MEMORY(0H) byte,*/
DMEQ: DO;
declare TRUE	literally '0FFH',
	FALSE	literally '0';

read: procedure (conn, buff$p, count, actual$p, status$p) external;
    declare (conn, buff$p, count, actual$p, status$p) address;
end read;

seek: procedure (conn, mode, block$p, byte$p, status$p) external;
    declare (conn, mode, block$p, byte$p, status$p) address;
end seek;

meq: procedure(A, B) byte external ; declare (A,B) address; end;

dmeq: procedure (dir$aftn, search$arg, initial$i$no, dir$entry) byte public;
    declare (dir$aftn, search$arg, initial$i$no, dir$entry) address;
    declare (byteNo, blockNo, actual, status) address;
    declare (pastDir, searching) byte;
    declare dirFlag based dir$entry byte;

	blockNo = 0;
	byteNo = initial$i$no * 16;
	call seek(dir$aftn, 2, .blockNo, .byteNo, .status);

	searching = TRUE;
	do while searching;
		call read(dir$aftn, dir$entry, 16, .actual, .status);
		searching = not meq(search$arg, dir$entry);
		initial$i$no = initial$i$no + 1;
		if dirFlag = 7Fh or actual = 0 then
		do;
			initial$i$no = 201;
			searching = FALSE;
		end;
	end;
		
	return initial$i$no;
end;
end;
?filerr.plm
FILEERROR: DO;
/* b1=01, b2=31, CODE(7CH) byte, DATA(7H) byte, STACK(6H) byte, MEMORY(0H) byte,*/

write: procedure (conn, buff$p, count, actual$p) external;
    declare (conn, buff$p, count, actual$p) address;
end write;

exit: procedure external;
end exit;

deblank: procedure(str) address external; declare str address; end;
wdelimit: procedure(ptr) address external; declare ptr address; end;
reporterror: procedure(status) external; declare status address; end;

fileerror: procedure(status, ptr, callExit) public;
	declare (status, ptr) address, callExit byte;
	declare lStatus address;

	if status <> 0 then
	do;
		ptr = deblank(ptr);
		call write(0, .(' '), 1, .lStatus);
		call write(0, ptr, wdelimit(ptr) - ptr, .lStatus);
		call write(0, .(','), 1, .lStatus);
		call reporterror(status);
		if callExit then
			call exit;
	end;
end;
end;
?forupp.plm
FORCEUPPER: DO;
/* b1=01, b2=31, CODE(25H) byte, DATA(2H) byte, STACK(2H) byte, MEMORY(0H) byte,*/
declare CR literally '0DH';

uppercase: procedure(ch) byte external; declare ch byte; end;

forceupper: procedure(bufferPtr) public;
	declare bufferPtr address, ch based bufferPtr byte;

	do while ch <> CR;
		ch = uppercase(ch);
		bufferPtr = bufferPtr + 1;
	end;
end;
end;
?meq.plm
/* b1=01, b2=31, CODE(76H) byte, DATA(5H) byte, STACK(2H) byte, MEMORY(0H) byte,*/
MEQ: DO;

meq: procedure(mPtr, fptr) byte public;
	declare (mPtr, fptr) address;
	declare m based mPtr (10) byte;
	declare f based fptr (10) byte;
	declare i byte;

	do i = 0 to 9;
		if m(i) = '?' then
		do;
			if f(i) = 0 then
				return 0;
		end;
		else if m(i) <> '*' then
		do;
			if m(i) <> f(i) then
				return 0;
		end;
	end;
	return 0ffh;
end;
end;

?numout.plm
NUMOUT: DO;
/* b1=01, b2=31, CODE(AAH) byte, DATA(8H) byte, STACK(6H) byte, MEMORY(0H) byte,*/

declare digits(*) byte data('0123456789ABCDEF');

numout: procedure(val, base, lc, bufAdr, width) public;
	declare (val, bufAdr) address, (base, lc, width) byte; 
	declare i byte;
	declare buf based bufAdr (1) byte;

	do i = 1 to width;
		buf(width - i) = digits(val mod base);
		val = val / base;	
	end;

	i = 0;
	do while buf(i) = '0' and i < width - 1;
		buf(i) = lc;
		i = i + 1;
	end;
end;
end;
?popula.plm
POPULATION: DO;
/* b1=01, b2=31, CODE(87H) byte, DATA(CH) byte, STACK(2H) byte, MEMORY(0H) byte,*/

declare bitCnt(*) byte data(0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4);


population: procedure(bufferLoc, length) address public;
	declare (bufferLoc, length) address;
	declare total address, (lowNibble, highNibble) byte,
		(i, lastByte) address;
	declare buffer based bufferLoc (1) byte;

	total = 0;
	lastByte = length - 1;
	do i = 0 to lastByte;
		lowNibble = buffer(i) and 0fh;		
		highNibble = ror(buffer(i), 4) and 0fh;
		total = total + bitCnt(lowNibble) + bitCnt(highNibble);
	end;
	return total;
end;
end;
?reperr.plm
/* b1=01, b2=31, CODE(473H) byte, DATA(9H) byte, STACK(6H) byte, MEMORY(0H) byte,*/
REPORTERROR: DO;
error: procedure(errNum) external; declare errNum address; end;

write: procedure(aftn, buf$ptr, len, status$ptr) external;
   declare (aftn, buf$ptr, len, status$ptr) address;
end write;

numout: procedure(val, base, lead, buf$ptr, len) external;
	declare (val, buf$ptr) address, (base, lead, len) byte; 
end numout;

declare msg(*) byte DATA(0, 0,
	2, 'ILLEGAL AFTN ARGUMENT', 0,
	4, 'INCORRECTLY SPECIFIED FILE', 0,
	5, 'UNRECOGNIZED DEVICE NAME', 0,
	6, 'ATTEMPT TO WRITE TO INPUT DEVICE', 0,
	8, 'ATTEMPT TO READ FROM OUTPUT DEVICE', 0,
	9, 'DISK DIRECTORY FULL', 0,
	0AH, 'NOT ON SAME DISK', 0,
	0BH, 'FILE ALREADY EXISTS', 0,
	0CH, 'FILE IS ALREADY OPEN', 0,
	0DH, 'NO SUCH FILE', 0,
	0EH, 'WRITE PROTECTED', 0,
	11H, 'NOT A DISK FILE', 0,
	12H, 'ILLEGAL ISIS COMMAND', 0,
	13H, 'ATTEMPTED SEEK ON NON-DISK FILE', 0,
	14H, 'ATTEMPTED BACK SEEK TOO FAR', 0,
	15H, 'CAN', 27H, 'T RESCAN', 0,
	16H, 'ILLEGAL ACCESS MODE TO OPEN', 0,
	17H, 'MISSING FILENAME', 0,
	19H, 'ILLEGAL ECHO FILE', 0,
	1AH, 'ILLEGAL ATTRIBUTE IDENTIFIER', 0,
	1BH, 'ILLEGAL SEEK COMMAND', 0,
	1CH, 'MISSING EXTENSION', 0,
	1FH, 'CAN', 27H, 'T SEEK ON WRITE ONLY FILE', 0,
	20H, 'CAN', 27H, 'T DELETE OPEN FILE', 0,
	23H, 'SEEK PAST EOF', 0,
	0C9H, 'UNRECOGNIZED SWITCH', 0,
	0CAH, 'UNRECOGNIZED DELIMITER', 0,
	0CBH, 'INVALID SYNTAX', 0,
	0CCH, 'PREMATURE EOF', 0,
	0CEH, 'ILLEGAL DISKETTE LABEL', 0,
	0D0H, 'CHECKSUM ERROR', 0,
	0D1H, 'RELO FILE SEQUENCE ERROR', 0,
	0D2H, 'INSUFFICIENT MEMORY', 0,
	0D3H, 'RECORD TOO LONG', 0,
	0D4H, 'ILLEGAL RELO RECORD', 0,
	0D5H, 'FIXUP BOUNDS ERROR', 0,
	0D6H, 'ILLEGAL SUBMIT PARAMETER', 0,
	0D7H, 'ARGUMENT TOO LONG', 0,
	0D8H, 'TOO MANY PARAMETERS', 0,
	0D9H, 'OBJECT RECORD TOO SHORT', 0,
	0DAH, 'ILLEGAL RECORD FORMAT', 0,
	0DBH, 'PHASE ERROR', 0
	);

reporterror: procedure(errNum) public;
	declare errNum address;
	declare numberBuffer(3) byte, i address, status address;
 

	if errNum <> 0 then
	do;
		i = 0;
		do while i < size(msg);
			if errNum = msg(i) and msg(i + 1) <> 0 then
			do;
				i = i + 1;
				call write(0, .(' '), 1, .status);
				do while msg(i) <> 0;
					call write(0, .msg(i), 1, .status);
					i = i + 1;
				end;
				call write(0, .(0dh, 0ah), 2, .status);
				return;
			end;
			else
			do;
				do while msg(i) <> 0;
					i = i + 1;
				end;
				i = i + 1;
			end;
		end;
	call error(errNum);
	end;
end;
end;

?scanin.plm
SCANIN: DO;
/* b1=01, b2=31, CODE(17AH) byte, DATA(FH) byte, STACK(4H) byte, MEMORY(0H) byte,*/

declare digits(*) byte data('0123456789ABCDEF');

scanInteger: procedure(ptrPtr) address public;
	declare ptrPtr address;
	declare ptr based ptrPtr address;
	declare (scanPtr, updatePtr, stopPtr) address;
	declare (i, radix, increment) byte;
	declare (nVal, oVal) address;
	declare c based scanPtr byte;

	scanPtr = ptr;	
	do while c = ' ';
		scanPtr = scanPtr + 1;
	end;
	ptr = scanPtr;
	do while '0' <= c and c <= '9' or 'A' <= c and c <= 'F';
		scanPtr = scanPtr + 1;
	end;

	stopPtr = scanPtr;
	updatePtr = scanPtr + 1;
	if c = 'H' then
		radix = 16;
	else if c = 'O' or c = 'Q' then
		radix = 8;
	else
	do;
		updatePtr = scanPtr;
		stopPtr, scanPtr = scanPtr - 1;
		if c = 'B' then
			radix = 2;
		else
		do;
			radix = 10;
			if c <> 'D' then	/* include last increment */
				stopPtr = stopPtr + 1;
		end;
	end;
	scanPtr = ptr;
	nVal, oVal = 0;	
	do while scanPtr < stopPtr;
		do i = 0 to 15;
			if c = digits(i) then
				increment = i;
		end;
		if increment >= radix then
			return 0;
		nVal = oVal * radix + increment;
		if nVal < oVal then
			return 0;
		oVal = nVal;
		scanPtr = scanPtr + 1;
	end;		
	ptr = updatePtr;
	return nVal;
end;
end;

?seq.plm
SEQ: DO;
/* b1=01, b2=31, CODE(48H) byte, DATA(6H) byte, STACK(2H) byte, MEMORY(0H) byte,*/
seq: procedure(s1, s2, cnt) byte public;
	declare (s1,s2) address, cnt byte;
	declare s1a based s1(1) byte;
	declare s2a based s2(1) byte;
	declare i byte;
	cnt = cnt - 1;
	do i = 0 to cnt;
		if s1a(i) <> s2a(i) then
			return 0;
	end;
	return 0ffh;
end;
end;

?tabwrt.plm
TABWRITE: DO;
/* b1=01, b2=31, CODE(A7H) byte, DATA(DH) byte, STACK(6H) byte, MEMORY(0H) byte,*/

declare TAB	literally '9',
	CR	literally '0dh';

write: procedure (aft, buff$p, count, status) external;
    declare (aft, buff$p, count, status) address;
end write;

tabwrite: procedure(columnPtr, aft, bufferPtr, count, status) public;
	declare (columnPtr, aft, bufferPtr, count, status) address;
	declare (printChar, i, j) byte;
	declare column based columnPtr byte;
	declare ch based bufferPtr byte;

	do while count <> 0;
		i = ch = TAB and (7 - (column and 7));
		printChar = ch;
		bufferPtr = bufferPtr + 1;
		count = count - 1;
		if printChar = TAB then
			printChar = ' ';
		do j = 0 to i;
			if ch = CR then
				column = 0;
			if ch >= ' ' then
				column = column + 1;
			call write(aft, .printChar, 1, status);
		end;
	end;
end;
end;

?unpath.plm
UNPATH: DO;
/* b1=01, b2=31, CODE(108H) byte, DATA(5H) byte, STACK(2H) byte, MEMORY(0H) byte,*/

declare devTab(*) byte data('F0F1F2F3F4F5TITO',
			     'VIVOI1O1TRHRR1R2',
			     'TPHPP1P2LPL1BBCICO');

unpath:	procedure(int, ext) public;
	declare (int, ext) address;
	declare i byte;
	declare intName based int (1) byte;
	declare extName based ext (1) byte;

	extName(0) = ':';
	extName(1) = devTab(intName(0) + intName(0));
	extName(2) = devTab(intName(0) + intName(0) + 1);
	extName(3) = ':';	
	ext = ext + 4;
	do i = 0 to 5;
		if (extName(0) := intName(i + 1)) <> 0 then
			ext = ext + 1; 
	end;
	if intName(7) <> 0 then
	do;
		extName(0) = '.';
		ext = ext + 1;
	end;
	do i = 0 to 2;
		if (extName(0) := intName(i + 7)) <> 0 then
			ext = ext + 1; 

	end;
	extName(0) = ' ';
end;
end;
?upcase.plm
UPPERCASE: DO;
/* b1=01, b2=31, CODE(23H) byte, DATA(1H) byte, STACK(0H) byte, MEMORY(0H) byte,*/
uppercase: procedure(char) byte public;
	declare char byte;
	if char < 'a' then
		return char;
	if char > 'z' then
		return char;
	return char and 0dfh;
end;
end;

?wdlmt.plm
WDELIMIT: DO;
/* b1=01, b2=31, CODE(63H) byte, DATA(2H) byte, STACK(4H) byte, MEMORY(0H) byte,*/
wdelimit: procedure(ptr) address public;
	declare ptr address;
	declare ch based ptr byte;

	do while (ch = ':' or ch = '.' or ch = '*' or ch = '?' or
		  ('0' <= ch and ch <= '9') or ('A' <= ch and ch <= 'Z'));
		ptr = ptr + 1;
	end;
	return ptr;
end;
end;

?wpath.plm
WPATH: DO;
/* b1=01, b2=31, CODE(298H) byte, DATA(1CH) byte, STACK(6H) byte, MEMORY(0H) byte,*/

uppercase: procedure(sch) byte external; declare sch byte; end;

declare TRUE literally '0ffh',
	FALSE literally '0';

declare	devTab(*) byte data ('F0F1F2F3F4F5TITO',
			      'VIVOI1O1TRHRR1R2',
			      'TPHPP1P2LPL1BBCI',
			      'CO');

declare lastPathnameParsed(15) byte;

wpath: procedure(pathnamePtr, pn) byte public;
	declare (pathnamePtr, pn) address;
	declare (ptr, addr, devPtr) address,
		(lo, hi) byte at (.addr),
		devPair based devPtr address;
	declare	(nullName, pl, i) byte;
	declare path based pn(1) byte;
	declare sch based pathnamePtr byte;
	declare s based pathnamePtr(1) byte;
	declare tch based ptr byte;

	nonTerminator: procedure byte;
		return 'A' <= sch and sch <= 'Z' or
		   '0' <= sch and sch <= '9' or
		    sch = '?' or sch = '*' or
		   'a' <= sch and sch <= 'z';
	end;

	devPtr = .devTab;
	do i = 0 to 9;
		path(i) = 0;
	end;
	do while sch = ' ';
		pathnamePtr = pathnamePtr + 1;
	end;
	ptr = pathnamePtr;
	if sch = ':' then
	do;
		path(0) = TRUE;
		if s(3) <> ':' then
			return 4;
		pathnamePtr = pathnamePtr + 1;
		lo = uppercase(sch);
		pathnamePtr = pathnamePtr + 1;
		hi = uppercase(sch);
		pathnamePtr = pathnamePtr + 2;

		i = 0;
		do while i < last(devTab);
			if devPair = addr then
				path(0) = shr(i, 1);
			i = i + 2;
			devPtr = devPtr + 2;
		end;
		if path(0) = 255 then
			return 5;
	end;

	nullName = TRUE;
	i = 1;
	do while i < 7;
		if nonTerminator then
		do;
			path(i) = uppercase(sch);
			if sch = '*' then
				do while i < 7;
					path(i) = '*';
					i = i + 1;
				end;
			pathnamePtr = pathnamePtr + 1;
			nullName = FALSE;
		end;
		i = i + 1;
	end;
	if sch = '.' then
	do;
		pathnamePtr = pathnamePtr + 1;
		i = 7;
		do while i < 10;
			if nonTerminator then
			do;
				path(i) = uppercase(sch);
				if sch = '*' then
					do while i < 10;
						path(i) = '*';
						i = i + 1;
					end;
				pathnamePtr = pathnamePtr + 1;
			end;
			i = i + 1;
		end;	
	end;
	if path(0) <= 5 and nullName then
		return 17h;
	pl = 255;
	do while ptr < pathnamePtr;
		lastPathnameParsed(pl := pl + 1) = tch;
		ptr = ptr + 1;
	end;
	if lastPathnameParsed(pl) = '.' then
		return 1ch;
	lastPathnameParsed(pl + 1) = ' ';	
	if nonTerminator or sch = '.' or sch = ':' then
		return 4;
	return 0;
end;
end;

cusp1/makefile
# common makefile info
ROOT=../../..
TARGETS=cusp1.lib
unexport ISIS_F1

include $(ROOT)/tools/isis.mk

REF := $(call ipath,toolbox,1.0)

PLM80 = 3.1

PLMFLAGS=code optimize

OBJS=	dblank.obj dlimit.obj dmeq.obj filerr.obj forupp.obj meq.obj numout.obj\
	reperr.obj scanin.obj seq.obj tabwrt.obj upcase.obj unpath.obj wdlmt.obj\
	wpath.obj cpyrit.obj popula.obj 

all::
	$(MAKE) $(TARGETS)

cusp1.lib: $(OBJS)
	$(call lib,$@,$^)

cusp2/cusp2_all.src
?absio.plm
ABSIO: DO;
/* b1=01, b2=10, CODE(3DH) byte, DATA(DH) byte, STACK(4H) byte, MEMORY(0H) byte,*/
DECLARE DCB$T LITERALLY 'STRUCTURE (iocw BYTE, ioins BYTE, nsec BYTE, tadr BYTE, sadr BYTE, buf ADDRESS)';

diskio: procedure(disk, dcb$ptr) external; declare (disk, dcb$ptr) address; end;

absio: procedure(cmd, disk, block, buffer) public;
	declare (cmd, disk) byte, (block, buffer) address;
	declare dcb DCB$T;

	dcb.iocw = 80H;
	dcb.ioins = cmd;
	dcb.nsec = 1;
	dcb.tadr = high(block);
	dcb.sadr = low(block);
	dcb.buf = buffer;
	call diskio(disk, .dcb);
end;
end;
?alloc.plm
ALLOC: DO;
/* b1=01, b2=10, CODE(8H) byte, DATA(10DH) byte, STACK(0H) byte, MEMORY(0H) byte,*/
DECLARE DCB$T LITERALLY 'STRUCTURE (iocw BYTE, ioins BYTE, nsec BYTE, tadr BYTE, sadr BYTE, buf ADDRESS)';

declare
	bitmap(256) byte public,
	currentBitmap byte public initial(0ffh),
	mapChange byte public initial(0),
	lastBlock address public,
	(lastSector, lastTrack) byte public at (.lastBlock),
	lastCounter address public,
	mapDcb DCB$T initial(80H, 0, 2, 2, 2, 0),	/* I suspect this should be public */
	maskArray(*) byte public data(80H, 40H, 20H, 10H, 8, 4, 2, 1);
end;

?clrbuf.plm
CLEARBUF: DO;
/* b1=01, b2=10, CODE(28H) byte, DATA(3H) byte, STACK(0H) byte, MEMORY(0H) byte,*/

clearbuf: procedure(buf$ptr) public;
	declare buf$ptr address, i byte,
		buf based buf$ptr (1) byte;

	do i = 0 to 127;
		buf(i) = 0;
	end;
end;
end;

?d.plm
D: DO;
/* b1=01, b2=10, CODE(595H) byte, DATA(133H) byte, STACK(8H) byte, MEMORY(0H) byte,*/
open: procedure (conn$p, path$p, access, echo, status$p) external;
    declare (conn$p, path$p, access, echo, status$p) address;
end open;

read: procedure (conn, buff$p, count, actual$p, status$p) external;
    declare (conn, buff$p, count, actual$p, status$p) address;
end read;

write: procedure (conn, buff$p, count, status$p) external;
    declare (conn, buff$p, count, status$p) address;
end write;

close: procedure (conn, status$p) external;
    declare (conn, status$p) address;
end close;

delimit: procedure(ptr) address external; declare ptr address; end;

numout: procedure(val, base, lc, bufAdr, width) external;
	declare (val, bufAdr) address, (base, lc, width) byte;
end;

meq: procedure(mPtr, fPtr) byte external ; declare (mPtr,fPtr) address; end;
unpath:	procedure(int, ext) external; declare (int, ext) address; end;
deblank: procedure(ptr) address external; declare ptr address; end;

declare direct structure(status byte, name(6) byte, ext(3) byte, attributes byte,
			 byte$in$lastblk byte, blksUsed address,
			 linkSec byte, linkTrk byte) external;
declare directIno address external;

population: procedure(bufferLoc, cnt) address external;
	declare bufferLoc address, cnt byte;
end;

declare isisMapFile(*) byte data(':F :ISIS.MAP '),
	mapDrive byte at (.isisMapFile(2)),
	isisLabFile(*) byte data(':F :ISIS.LAB '),
	labDrive byte at (.isisLabFile(2)),
	isisDirFile(*) byte data(':F :ISIS.DIR '),
	dirDrive byte at (.isisDirFile(2)),
	CRLF(*) byte data(0DH, 0AH),
	blksUsedMsg(*) byte data('XXXX/2002 BLOCKS USED', 0DH, 0AH),
	dirOfMsg(*) byte data('DIRECTORY OF '),
	dirHeader(*) byte data('NAME  .EXT BLKS   LENGTH ATTR', 0DH, 0AH);

D: procedure(drive, conn, arg3b, arg4b, arg5w) public;
	declare (drive, conn, arg3b, arg4b) byte, arg5w address;
	declare	(dconn, status, actual, unused)	address,
		(sectUsed, highFileSize, lowFileSize) address,
		totalSectUsed address,
		mapBuf(251) byte,
		strbuf(15) byte,
		path(15) byte,
		(i, j) byte;

	bigAdd: procedure(arg1w);
		declare arg1w address;
		lowFileSize = lowFileSize + arg1w;
		if lowFileSize > 9999 then
		do;
			lowFileSize = lowFileSize - 10000;
			highFileSize = highFileSize + 1;
		end;
	end;	


	totalSectUsed = 0;
	mapDrive, labDrive, dirDrive = drive + '0';
	call open(.dconn, .isisLabFile, 1, 0, .status);
	strbuf(0) = drive;
	call read(dconn, .strbuf(1), 9, .actual, .status);
	call write(conn, .dirOfMsg, size(dirOfMsg), .status);
	call unpath(.strbuf, .path);
	i = delimit(.path) - .path;
	call write(conn, .path, i, .status);
	call write(conn, .CRLF, 2, .status);
	call close(dconn, .status);
	if (not arg3b) + 0 then	/* + 0 to trick the optimiser */
		call write(conn, .dirHeader, size(dirHeader), .status);
	call open(.dconn, .isisDirFile, 1, 0, .status);
	actual = 16;
	direct.status = actual;
	do while actual = double(16) and direct.status <> 07FH;
		call read(dconn, .direct, 16, .actual, .status);
		if actual = double(16) and (not direct.status) and
		   ((direct.attributes and 1) = 0 or arg4b) and
		   meq(arg5w, .direct) then
		   do;
			do i = 0 to 8;
				if direct.name(i) = 0 then
					direct.name(i) = ' ';
			end;
			i = 9;
			if arg3b then	
				do while direct.name(i - 1) = ' ';
					i = i - 1;
				end;
			if not arg3b or i > 6 then
				j = 6;
			else
				j = i;	
			call write(conn, .direct.name, j, .status);
			if arg3b then
			do;
				if i > 6 then
				do;
					call write(conn, .('.'), 1, .status);
					call write(conn, .direct.ext, i - 6, .status);
				end;
			end;
			else
			do;
				if direct.ext(0) <> ' ' then
					call write(conn, .('.'), 1, .status);
				call write(conn, .direct.ext, 3, .status);
				if direct.ext(0) = ' ' then
					call write(conn, .(' '), 1, .status); 
				sectUsed = direct.blksUsed;
x: /* force optimiser to reload sectUsed */
				if sectUsed > 0 then	/* add in link sectors used */
					sectUsed = sectUsed + (sectUsed + 61) / 62;
				else
					sectUsed = 1;	/* has at least one link sector */
				totalSectUsed = totalSectUsed + sectUsed;
				call numout(sectUsed, 10, ' ', .strbuf, 5);
				call write(conn, .strbuf, 5, .status);
				sectUsed = direct.blksUsed;
				lowFileSize, highFileSize = 0;
				if sectUsed > 0 then
				do;
					sectUsed = sectUsed - 1;
					call bigAdd(direct.byte$in$lastblk);
					do while sectUsed > 0;
						sectUsed = sectUsed - 1;
						call bigAdd(128);
					end;
				end;
				if highFileSize <> 0 then
				do;
					call numout(highFileSize, 10, ' ', .strbuf, 5);
					call numout(lowFileSize, 10, '0', .strbuf(5), 4);
				end;
				else
					call numout(lowFileSize, 10, ' ', .strbuf, 9);
				call write(conn, .strbuf, 9, .status);
				if direct.attributes <> 0 then
				do;
					do i = 0 to 4;
						strbuf(i) = ' ';
					end;
					if (direct.attributes and 4) <> 0 then
						strbuf(1) = 'W';
					if (direct.attributes and 2) <> 0 then
						strbuf(2) = 'S';
					if (direct.attributes and 1) <> 0 then
						strbuf(3) = 'I';
					if (direct.attributes and 80h) <> 0 then
						strbuf(4) = 'F';
					call write(conn, .strbuf, 5, .status);
				end;
			end;
			call write(conn, .CRLF, 2, .status);
		end;
	end;

	call close(dconn, .status);
	if (not arg3b) + 0 then
	do;
		call numout(totalSectUsed, 10, ' ', .strbuf, 15);
		call write(conn, .strbuf, 15, .status);
		call write(conn, .CRLF, 2, .status);
	end;
	call open(.dconn, .isisMapFile, 1, 0, .status);
	call read(dconn, .mapBuf, 251, .actual, .status);
	call numout(population(.mapBuf, 251), 10, 0, .blksUsedMsg, 4);
	call write(conn, .blksUsedMsg, 23, .status);
	call close(conn, .status);
end;
end;

?dblank.plm
DEBLANK: DO;
/* b1=01, b2=10, CODE(1DH) byte, DATA(2H) byte, STACK(0H) byte, MEMORY(0H) byte,*/
deblank: procedure(str) address public;
	declare str address;
	declare c based str byte;

	do while (c = ' ');
		str = str + 1;
	end;
	return str;
end;

end;
?direct.plm
DIRECT: DO;
/* b1=01, b2=10, CODE(0H) byte, DATA(11H) byte, STACK(0H) byte, MEMORY(0H) byte,*/
declare	DIRECT(16) byte public,
	DIRECTINO byte public;
end;


?diskio.plm
DISKIO: DO;
/* b1=01, b2=10, CODE(1FH) byte, DATA(8H) byte, STACK(2H) byte, MEMORY(0H) byte,*/
isis: procedure(syscmd, param$p) external; declare syscmd byte, param$p address; end;

diskio: procedure(disk, dcb$p) public;
	declare (disk, dcb$p) address; 
	declare param structure(disk address, dcb$p address);
	
	param.disk = disk;
	param.dcb$p = dcb$p;
	call isis(44H, .param);
end;
end;
?dlimit.plm
DELIMIT: DO;
/* b1=01, b2=10, CODE(4FH) byte, DATA(2H) byte, STACK(4H) byte, MEMORY(0H) byte,*/
delimit: procedure(ptr) address public;
	declare ptr address, ch based ptr byte;

	do while ch = ':' or ch = '.' or
		 ('0' <= ch and ch <= '9') or
		 ('A' <= ch and ch <= 'Z');
		ptr = ptr + 1;
	end;
	return ptr;
end;
end;
?dmeq.plm
DMEQ: DO;
/* b1=01, b2=10, CODE(B0H) byte, DATA(11H) byte, STACK(8H) byte, MEMORY(0H) byte,*/
declare TRUE	literally '0FFH',
	FALSE	literally '0';

read: procedure (conn, buff$p, count, actual$p, status$p) external;
    declare (conn, buff$p, count, actual$p, status$p) address;
end read;

seek: procedure (conn, mode, block$p, byte$p, status$p) external;
    declare (conn, mode, block$p, byte$p, status$p) address;
end seek;

meq: procedure(A, B) byte external ; declare (A,B) address; end;

dmeq: procedure (dir$aftn, search$arg, initial$i$no, dir$entry) byte public;
    declare dir$aftn byte, (search$arg, initial$i$no, dir$entry) address;
    declare (byteNo, blockNo, actual, status) address;
    declare (pad, searching) byte;
    declare dirFlag based dir$entry byte;

	blockNo = 0;
	byteNo = initial$i$no * 16;
	call seek(dir$aftn, 2, .blockNo, .byteNo, .status);

	searching = TRUE;
	do while searching;
		call read(dir$aftn, dir$entry, 16, .actual, .status);
		searching = not meq(search$arg, dir$entry);
		initial$i$no = initial$i$no + 1;
		if dirFlag = 7Fh or actual = 0 then
		do;
			initial$i$no = 201;
			searching = FALSE;
		end;
	end;
		
	return initial$i$no;
end;
/* native plm80 v1.0 inlines @P0101 here */
end;
?filerr.plm
FILEERROR: DO;

/* b1=01, b2=10, CODE(8EH) byte, DATA(7H) byte, STACK(6H) byte, MEMORY(0H) byte,*/
write: procedure (conn, buff$p, count, actual$p) external;
    declare (conn, buff$p, count, actual$p) address;
end write;

exit: procedure external; end exit;

deblank: procedure(str) address external; declare str address; end;
scanblank: procedure(ptr) address external; declare ptr address; end;
reporterror: procedure(status) external; declare status address; end;

fileerror: procedure(status, ptr, callExit) public;
	declare (status, ptr) address, callExit byte;
	declare actual address;

	if status <> 0 then
	do;
		ptr = deblank(ptr);
		call write(0, .(' '), 1, .actual);
		call write(0, ptr, scanblank(ptr) - ptr, .actual);
		call write(0, .(','), 1, .actual);
		call reporterror(status);
		if callExit then
			call exit;
	end;
end;
/* native plm v1.0 inlines @P0095 and @P0101 here */ 
end;
?fmttrk.plm
FORMATTRACK: DO;
/* b1=01, b2=10, CODE(128H) byte, DATA(42H) byte, STACK(4H) byte, MEMORY(0H) byte,*/

diskio: procedure(disk, dcb$p) external; declare disk address, dcb$p address; end;

formatTrack: procedure(disk,sTrack,eTrack,interleave) public;
	declare (disk,sTrack,eTrack,interleave) byte;
	declare (i,j,k) byte, trackBuf(52) byte,
	dcb structure(iocw byte, ioins byte, nsec byte, tadr byte, sadr byte, buf address);


	dcb.iocw = 0c0h;
	dcb.ioins = 2;
	
	do i = 1 to 51 by 2;
		trackBuf(i) = 0c7h;	
	end;
	j = 0;
	do k = sTrack to eTrack;
		do i = 0 to 51 by 2;
			trackBuf(i) = 0;
		end;
		do i = 1 to 26;
			j = (j + interleave) mod 26;
			do while trackBuf(j + j) <> 0;
				j = (j + 1) mod 26;
			end;
			trackBuf(j + j) = i;
		end;
		dcb.tadr = k;
		dcb.buf = .trackBuf;
		call diskio(disk, .dcb);
	end;
end;
/* native plm80 v1.0 inlines @P0029 here */
end;
?forupp.plm
FORCEUPPER: DO;
/* b1=01, b2=10, CODE(25H) byte, DATA(2H) byte, STACK(2H) byte, MEMORY(0H) byte,*/
declare CR literally '0DH';

uppercase: procedure(ch) byte external; declare ch byte; end;

forceupper: procedure(bufferPtr) public;
	declare bufferPtr address, ch based bufferPtr byte;

	do while ch <> CR;
		ch = uppercase(ch);
		bufferPtr = bufferPtr + 1;
	end;
end;
end;
?meq.plm
MEQ: DO;
/* b1=01, b2=10, CODE(50H) byte, DATA(5H) byte, STACK(2H) byte, MEMORY(0H) byte,*/

meq: procedure(mPtr, fptr) byte public;
	declare (mPtr, fptr) address;
	declare m based mPtr (10) byte;
	declare f based fptr (10) byte;
	declare i byte;

	do i = 0 to 9;
		if m(i) <> '?' then
		do;
			if f(i) <> m(i) then
				return 0;
		end;
	end;
	return 0ffh;
end;
end;

?monitr.plm
MONITOR: DO;
/* b1=01, b2=10, CODE(28H) byte, DATA(2H) byte, STACK(0H) byte, MEMORY(0H) byte,*/
MONITOR: procedure public;
	declare sp address, wrd based sp address;
	sp = STACKPTR;
x: /* force reload of sp */
	wrd = 8;	
	STACKPTR = STACKPTR  - 2;
	sp = STACKPTR;
y: /* force reload of sp */
	wrd = 0;
end;
end;
?mvasci.plm
MOVEASCII: DO;
/* b1=01, b2=10, CODE(3FH) byte, DATA(6H) byte, STACK(2H) byte, MEMORY(0H) byte,*/
moveascii: procedure(dst, src, cnt) public;
	declare (dst, src) address, cnt byte, i byte;
	declare dch based dst (1) byte, sch based src (1) byte;

	do i = 0 to cnt - 1;
		dch(i) = sch(i);
	end;
end;
end;
?numout.plm
NUMOUT: DO;
/* b1=01, b2=10, CODE(C9H) byte, DATA(8H) byte, STACK(6H) byte, MEMORY(0H) byte,*/

declare digits(*) byte data('0123456789ABCDEF');

numout: procedure(val, base, lc, bufAdr, width) public;
	declare (val, bufAdr) address, (base, lc, width) byte; 
	declare i byte;
	declare buf based bufAdr (1) byte;

	do i = 1 to width;
		buf(width - i) = digits(val mod base);
		val = val / base;	
	end;

	i = 0;
	do while buf(i) = '0' and i < width - 1;
		buf(i) = lc;
		i = i + 1;
	end;
end;
/* native plm80 v1.0 inlines @0029 here */
end;
?path.plm
PATH: DO;
/* b1=01, b2=10, CODE(245H) byte, DATA(1CH) byte, STACK(6H) byte, MEMORY(0H) byte,*/

uppercase: procedure(sch) byte external; declare sch byte; end;

declare devTab(*) byte data('F0F1F2F3TITOVIVOI1O1TRHRR1R2TPHPP1P2LPL1BBCICO');
declare lastpath(15) byte;

declare TRUE	literally '0ffh',
	FALSE	literally '0';

PATH: procedure(filename, pn) byte public;
	declare (filename, pn) address;
	declare pathPtr address, devPair address, (loByte, hiByte) byte at (.devPair),
		devPtr address, (noName, pl, i) byte;
	declare pnByte based pn (10) byte;
	declare fileChar based filename (1) byte, pathChar based pathPtr (1) byte;
	declare devTabPair based devPtr address;

	isFileNameChar: procedure byte;
		return 'A' <= fileChar(0) and fileChar(0) <= 'Z' or
		   '0' <= fileChar(0) and fileChar(0) <= '9' or
		   'a' <= fileChar(0) and fileChar(0) <= 'z';
	end;


	devPtr = .devTab;
	do i = 0 to 9;
		pnByte(i) = 0;
	end;
	do while fileChar(0) = ' ';
		filename = filename + 1;
	end;

	pathptr = filename;
	if pathChar(0) = ':' then
	do;
		pnByte(0) = 255;
		if fileChar(3) <> ':' then
			return 4;
		filename = filename + 1;
		loByte = uppercase(fileChar(0));
		filename = filename + 1;
		hiByte = uppercase(fileChar(0));
		filename = filename + 2;
		i = 0;
		do while i < last(devTab);
			if devTabPair =  devPair then
				pnByte(0) = shr(i, 1);
			i = i + 2;
			devPtr = devPtr + 2;
		end;
		if pnByte(0) = 255 then
			return 5;
	end;
	noName = TRUE;
	i = 1;
	do while i < 7;
		if isFileNameChar then
		do;
			pnByte(i) = uppercase(fileChar(0));
			filename = filename + 1;
			noName = FALSE;
		end;
		i = i + 1;
	end;
	if fileChar(0) = '.' then
	do;
		filename = filename + 1;
		i = 7;
		do while i < 10;
			if isFileNameChar then
			do;
				pnByte(i) = uppercase(fileChar(0));
				filename = filename + 1;
			end;
			i = i + 1;
		end;
	end;
	if pnByte(0) <= 3 and noName then
		return 17h;
	
	pl = 255;
	do while pathPtr < filename;
		lastpath(pl := pl + 1) = pathChar(0);
		pathPtr = pathPtr + 1;
	end;
	if lastpath(pl) = '.' then
		return 1ch;
	lastpath(pl + 1) = ' ';
	if isFileNameChar or fileChar(0) = '.' or fileChar(0) = ':' then
		return 4;
	return 0;
end;
/* native plm80 v1.0 inlines @P0098 and @P0099 here */
end;

?popula.plm
POPULATION: DO;
/* b1=01, b2=10, CODE(81H) byte, DATA(9H) byte, STACK(2H) byte, MEMORY(0H) byte,*/

declare bitCnt(*) byte data(0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4);


population: procedure(bufferLoc, cnt) address public;
	declare bufferLoc address, cnt byte;
	declare total address, lowNibble byte, highNibble byte,
		(i, lastByte) byte;
	declare buffer based bufferLoc (1) byte;

	total = 0;
	lastByte = cnt - 1;
	do i = 0 to lastByte;
		lowNibble = buffer(i) and 0fh;		
		highNibble = ror(buffer(i), 4) and 0fh;
x: /* force optimiser to reload highNibble */
		total = total + bitCnt(lowNibble) + bitCnt(highNibble);
	end;
	return total;
end;
end;

?reperr.plm
REPORTERROR: DO;
/* b1=01, b2=10, CODE(471H) byte, DATA(9H) byte, STACK(6H) byte, MEMORY(0H) byte,*/
error: procedure(errNum) external; declare errNum address; end;

write: procedure(aftn, buf$ptr, len, status$ptr) external;
   declare (aftn, buf$ptr, len, status$ptr) address;
end write;

numout: procedure(val, base, lead, buf$ptr, len) external;
	declare (val, buf$ptr) address, (base, lead, len) byte; 
end numout;

declare msg(*) byte DATA(0, 0,
	2, 'ILLEGAL AFTN ARGUMENT', 0,
	4, 'INCORRECTLY SPECIFIED FILE', 0,
	5, 'UNRECOGNIZED DEVICE NAME', 0,
	6, 'ATTEMPT TO WRITE TO INPUT DEVICE', 0,
	8, 'ATTEMPT TO READ FROM OUTPUT DEVICE', 0,
	0AH, 'NOT ON SAME DISK', 0,
	0BH, 'FILE ALREADY EXISTS', 0,
	0CH, 'FILE IS ALREADY OPEN', 0,
	0DH, 'NO SUCH FILE', 0,
	0EH, 'WRITE PROTECTED', 0,
	11H, 'NOT A DISK FILE', 0,
	12H, 'ILLEGAL ISIS COMMAND', 0,
	13H, 'ATTEMPTED SEEK ON NON-DISK FILE', 0,
	14H, 'ATTEMPTED BACK SEEK TOO FAR', 0,
	15H, 'CAN''T RESCAN', 0,
	16H, 'ILLEGAL ACCESS MODE TO OPEN', 0,
	17H, 'MISSING FILENAME', 0,
	19H, 'ILLEGAL ECHO FILE', 0,
	1AH, 'ILLEGAL ATTRIBUTE IDENTIFIER', 0,
	1BH, 'ILLEGAL SEEK COMMAND', 0,
	1CH, 'MISSING EXTENSION', 0,
	1FH, 'CAN''T SEEK ON WRITE ONLY FILE', 0,
	20H, 'CAN''T DELETE OPEN FILE', 0,
	23H, 'SEEK PAST EOF', 0,
	0C9H, 'UNRECOGNIZED SWITCH', 0,
	0CAH, 'UNRECOGNIZED DELIMITER', 0,
	0CBH, 'INVALID SYNTAX', 0,
	0CCH, 'PREMATURE EOF', 0,
	0CEH, 'ILLEGAL DISKETTE LABEL', 0,
	0D0H, 'CHECKSUM ERROR', 0,
	0D1H, 'RELO FILE SEQUENCE ERROR', 0,
	0D2H, 'INSUFFICIENT MEMORY', 0,
	0D3H, 'RECORD TOO LONG', 0,
	0D4H, 'ILLEGAL RELO RECORD', 0,
	0D5H, 'FIXUP BOUNDS ERROR', 0,
	0D6H, 'ILLEGAL SUBMIT PARAMETER', 0,
	0D7H, 'ARGUMENT TOO LONG', 0,
	0D8H, 'TOO MANY PARAMETERS', 0,
	0D9H, 'OBJECT RECORD TOO SHORT', 0,
	0DAH, 'ILLEGAL RECORD FORMAT', 0,
	0DBH, 'PHASE ERROR', 0
	);

reporterror: procedure(errNum) public;
	declare errNum address;
	declare numberBuffer(3) byte, i address, status address;
 

	if errNum <> 0 then
	do;
		i = 0;
		do while i < size(msg);
			if errNum = msg(i) and msg(i + 1) <> 0 then
			do;
				i = i + 1;
				call write(0, .(' '), 1, .status);
				do while msg(i) <> 0;
					call write(0, .msg(i), 1, .status);
					i = i + 1;
				end;
				call write(0, .(0dh, 0ah), 2, .status);
				return;
			end;
			else
			do;
				do while msg(i) <> 0;
					i = i + 1;
				end;
				i = i + 1;
			end;
		end;
	call error(errNum);
	end;
end;
/* native plm80 v1.0 inlines @0101 here */
end;
?scanin.plm
/* b1=01, b2=10, CODE(1A0H) byte, DATA(FH) byte, STACK(4H) byte, MEMORY(0H) byte,*/
SCANIN: do;
declare hexDigits(*) byte data('0123456789ABCDEF');

scanInteger: procedure(buf$p) address public;
	declare buf$p address;
	declare buf based buf$p address;
	declare (s, pastNum$p, endNum$p) address;
	declare (i, radix, digit) byte;
	declare (newValue, curValue) address;
	declare c based s byte;

	s = buf;	
	do while c = ' ';
		s = s + 1;
	end;
	buf = s;
	do while '0' <= c and c <= '9' or 'A' <= c and c <= 'F';
		s = s + 1;
	end;

	endNum$p = s;
	pastNum$p = s + 1;
	if c = 'H' then
		radix = 16;
	else if c = 'O' or c = 'Q' then
		radix = 8;
	else
	do;
		pastNum$p = s;
		endNum$p, s = s - 1;
x:		if c = 'B' then		/* force reload of s */
			radix = 2;
		else
		do;
			radix = 10;
			if c <> 'D' then	/* include last digit */
				endNum$p = endNum$p + 1;
		end;
	end;
	s = buf;
	newValue, curValue = 0;	
	do while s < endNum$p;
		do i = 0 to 15;
			if c = hexdigits(i) then
				digit = i;
		end;
		if digit >= radix then
			return 0;
		newValue = curValue * radix + digit;
y:		if newValue < curValue then	/* force reload of newValue */
			return 0;
		curValue = newValue;
		s = s + 1;
	end;		
	buf = pastNum$p;
	return newValue;
end;
/* native plm80 v1.0 inlines @P0034 and @P0098 here */
end;
?scnblk.plm
SCANBLANK: DO;
/* b1=01, b2=10, CODE(3AH) byte, DATA(2H) byte, STACK(2H) byte, MEMORY(0H) byte,*/
delimit: procedure(ptr) address external; declare ptr address; end;

scanblank: procedure(ptr) address public;
	declare ptr address, ch based ptr byte;

	do while (1);
		ptr = delimit(ptr);
		if ch = '*' or ch = '?' then
			ptr = ptr + 1;
		else
			return ptr;
	end;
end;
end;
?seq.plm
SEQ: DO;
/* b1=01, b2=10, CODE(48H) byte, DATA(6H) byte, STACK(2H) byte, MEMORY(0H) byte,*/
seq: procedure(s1, s2, cnt) byte public;
	declare (s1,s2) address, cnt byte;
	declare s1a based s1(1) byte;
	declare s2a based s2(1) byte;
	declare i byte;
	cnt = cnt - 1;
	do i = 0 to cnt;
		if s1a(i) <> s2a(i) then
			return 0;
	end;
	return 0ffh;
end;
end;
?setblk.plm
SETBLOCK: DO;
/* b1=01, b2=10, CODE(6AH) byte, DATA(3H) byte, STACK(2H) byte, MEMORY(0H) byte,*/
declare bitmap(1) byte external,
	maskArray(1) byte external; /* 80h, 40h, 20h, 10h, 8, 4, 2, 1 */

declare	currentBitMap byte external,
	mapChange byte external,
	lastBlock address external,
	lastSector byte external,
	lastTrack byte external,
	lastCounter byte external,
	mapDcb(1) byte external;

setblock: procedure(blk) public;
	declare blk address;
	declare idx byte;

	
	blk = high(blk) * 26 + low(blk) - 1;
x:	idx = shr(blk, 3);
/* native plm80 v1.0 generates code using bc to index into bitmap. later versions use de */
/* code difference is:
	v1.0		later versions
	mov c,m				; e already contains m so saves 1 byte
	mvi b,0		mvi d,0
	lxi h,BITMAP	lxi h,BITMAP
	dad b		dad d
*/
	bitmap(idx) = bitmap(idx) or maskArray(low(blk) and 7);

end;
/* native plm80 v1.0 inlines @P0034 and @P0091 here */
end;
?tabwrt.plm
TABWRITE: DO;
/* b1=01, b2=10, CODE(B5H) byte, DATA(DH) byte, STACK(6H) byte, MEMORY(0H) byte,*/

declare TAB	literally '9',
	CR	literally '0dh';

write: procedure (conn, buff$p, count, status$p) external;
    declare (conn, buff$p, count, status$p) address;
end write;

tabwrite: procedure(col$p, conn, buf$p, len, status$p) public;
	declare (col$p, conn, buf$p, len, status$p) address;
	declare (outchar, spcs, i) byte;
	declare col based col$p byte;
	declare ch based buf$p byte;

	do while len <> 0;
		spcs = ch = TAB and (7 - (col and 7));
		outchar = ch;
		buf$p = buf$p + 1;
		len = len - 1;
x:		if outchar = TAB then
			outchar = ' ';
		do i = 0 to spcs;
			if ch = CR then
				col = 0;
			if ch >= ' ' then
				col = col + 1;
			call write(conn, .outchar, 1, status$p);
		end;
	end;
end;
end;
?unpath.plm
UNPATH: DO;
/* b1=01, b2=10, CODE(104H) byte, DATA(5H) byte, STACK(2H) byte, MEMORY(0H) byte,*/

declare devTab(*) byte data('F0F1F2F3TITO',
			     'VIVOI1O1TRHRR1R2',
			     'TPHPP1P2LPL1BBCICO');

unpath:	procedure(int, ext) public;
	declare (int, ext) address;
	declare i byte;
	declare intName based int (1) byte;
	declare extName based ext (1) byte;

	extName(0) = ':';
	extName(1) = devTab(intName(0) + intName(0));
	extName(2) = devTab(intName(0) + intName(0) + 1);
	extName(3) = ':';	
	ext = ext + 4;
	do i = 0 to 5;
		if (extName(0) := intName(i + 1)) <> 0 then
			ext = ext + 1; 
	end;
	if intName(7) <> 0 then
	do;
		extName(0) = '.';
		ext = ext + 1;
	end;
	do i = 0 to 2;
		if (extName(0) := intName(i + 7)) <> 0 then
			ext = ext + 1; 

	end;
	extName(0) = ' ';
end;
end;
?upcase.plm
UPPERCASE: DO;
/* b1=01, b2=10, CODE(23H) byte, DATA(1H) byte, STACK(0H) byte, MEMORY(0H) byte,*/
uppercase: procedure(char) byte public;
	declare char byte;
	if char < 'a' then
		return char;
	if char > 'z' then
		return char;
	return char and 0dfh;
end;
end;
?wpath.plm
wpath: DO;
/* b1=01, b2=10, CODE(2A1H) byte, DATA(1CH) byte, STACK(6H) byte, MEMORY(0H) byte,*/

uppercase: procedure(sch) byte external; declare sch byte; end;

declare TRUE literally '0ffh',
	FALSE literally '0';

declare	devTab(*) byte data ('F0F1F2F3TITOVIVOI1O1TRHRR1R2TPHPP1P2LPL1BBCICO');

declare lastPathnameParsed(15) byte;

wpath: procedure(pathnamePtr, pn) byte public;
	declare (pathnamePtr, pn) address;
	declare (ptr, addr, devPtr) address,
		(lo, hi) byte at (.addr),
		devPair based devPtr address;
	declare	(nullName, pl, i) byte;
	declare path based pn(1) byte;
	declare sch based pathnamePtr byte;
	declare s based pathnamePtr(1) byte;
	declare tch based ptr byte;

	nonTerminator: procedure byte;
		return 'A' <= sch and sch <= 'Z' or
		   '0' <= sch and sch <= '9' or
		    sch = '?' or sch = '*' or
		   'a' <= sch and sch <= 'z';
	end;

	devPtr = .devTab;
	do i = 0 to 9;
		path(i) = 0;
	end;
	do while sch = ' ';
		pathnamePtr = pathnamePtr + 1;
	end;
	ptr = pathnamePtr;
	if sch = ':' then
	do;
		path(0) = TRUE;
		if s(3) <> ':' then
			return 4;
		pathnamePtr = pathnamePtr + 1;
		lo = uppercase(sch);
		pathnamePtr = pathnamePtr + 1;
		hi = uppercase(sch);
		pathnamePtr = pathnamePtr + 2;

		i = 0;
		do while i < last(devTab);
			if devPair = addr then
				path(0) = shr(i, 1);
			i = i + 2;
			devPtr = devPtr + 2;
		end;
		if path(0) = 255 then
			return 5;
	end;

	nullName = TRUE;
	i = 1;
	do while i < 7;
		if nonTerminator then
		do;
			path(i) = uppercase(sch);
			if sch = '*' then
				do while i < 7;
					path(i) = '?';
					i = i + 1;
				end;
			pathnamePtr = pathnamePtr + 1;
			nullName = FALSE;
		end;
		i = i + 1;
	end;
	if sch = '.' then
	do;
		pathnamePtr = pathnamePtr + 1;
		i = 7;
		do while i < 10;
			if nonTerminator then
			do;
				path(i) = uppercase(sch);
				if sch = '*' then
					do while i < 10;
						path(i) = '?';
						i = i + 1;
					end;
				pathnamePtr = pathnamePtr + 1;
			end;
			i = i + 1;
		end;	
	end;
	if path(0) <= 3 and nullName then
		return 17h;
	pl = 255;
	do while ptr < pathnamePtr;
		lastPathnameParsed(pl := pl + 1) = tch;
		ptr = ptr + 1;
	end;
	if lastPathnameParsed(pl) = '.' then
		return 1ch;
	lastPathnameParsed(pl + 1) = ' ';	
	if nonTerminator or sch = '.' or sch = ':' then
		return 4;
	return 0;
end;
/* native plm80 v1.0 inlines @P0098 and @P0099 here */
end;
?wrtdir.plm
WRITEDIRECTORY: DO;
/* b1=01, b2=10, CODE(3CEH) byte, DATA(104H) byte, STACK(6H) byte, MEMORY(0H) byte,*/
absio: procedure(cmd, disk, block, buffer) external;
	declare (cmd, disk) byte, (block, buffer) address;
end;
clearbuf: procedure(buf$ptr) external;
	declare buf$ptr address;
end;
moveascii: procedure(dst, src, cnt) external;
	declare (dst, src) address, cnt byte;
end;
setblock: procedure(adr) external; declare adr address; end;

declare bitmap(1) byte external;
/* following are declared but not used */
declare	currentBitMap byte external,
	mapChange byte external,
	lastBlock address external,
	lastSector byte external,
	lastTrack byte external,
	lastCounter byte external,
	mapDcb(1) byte external,
	maskArray(1) byte external;

declare	dirFile(*) byte data('ISIS', 0, 0, 'DIR'),
	mapFile(*) byte data('ISIS', 0, 0, 'MAP'),
	t0File(*) byte data('ISIS', 0, 0, 'T0', 0),
	binFile(*) byte data('ISIS', 0, 0, 'BIN'),
	labFile(*) byte data('ISIS', 0, 0, 'LAB');

writeDirectory: procedure(disk) public;
	declare	disk byte, i byte, jj address, dirBuf(64) address,
		direct(8) structure(empty byte, file(9) byte, attrib byte,
				    eof$count byte, blk address, hdrBlk address);

	do i = 0 to 255;
		bitmap(i) = 0;
	end;
	call clearbuf(.dirBuf);
	dirbuf(2) = 1;
	do i = 2 to 23;
		dirBuf(i + 1) = dirBuf(i) + 1;
	end;
	call absio(6, disk, 24, .dirBuf);
	call clearbuf(.dirBuf);
	dirbuf(2) = 26;
	do i = 2 to 1;	/* ??? */
		dirBuf(i + 1) = dirBuf(i) + 1;
	end;
	call absio(6, disk, 25, .dirBuf);
	call clearbuf(.dirBuf);
	dirBuf(2) = 102h;
	do i = 2 to 25;
		dirBuf(i + 1) = dirBuf(i) + 1;
	end;
	call absio(6, disk, 101h, .dirBuf);
	call clearbuf(.dirBuf);
	dirBuf(2) = 202h;
	do i = 2 to 2;
		dirBuf(i + 1) = dirBuf(i) + 1; 
	end;
	call absio(6, disk, 201h, .dirBuf);
	call clearbuf(.dirBuf);
	call absio(6, disk, 204h, .dirBuf);
	call clearBuf(.direct);
	call moveAscii(.direct(0).file, .dirFile, 9);
	direct(0).blk = 25;
	direct(0).hdrBlk = 101h;
	direct(0).empty = 0;
	direct(0).attrib = 1;
	direct(0).eof$count = 80h;
	call moveAscii(.direct(1).file, .mapFile, 9);
	direct(1).blk = 2;
	direct(1).hdrBlk = 201h;
	direct(1).empty = 0;
	direct(1).attrib = 1;
	direct(1).eof$count = 80h;
	call moveAscii(.direct(2).file, .t0File, 9);
	direct(2).blk = 23;
	direct(2).hdrBlk = 18h;
	direct(2).empty = 0;
	direct(2).attrib = 1;
	direct(2).eof$count = 80h;
	call moveAscii(.direct(3).file, .labFile, 9);
	direct(3).blk = 1;
	direct(3).hdrBlk = 19h;
	direct(3).empty = 0;
	direct(3).attrib = 1;
	direct(3).eof$count = 80h;
	call moveAscii(.direct(4).file, .binFile, 9);
	direct(4).blk = 0;
	direct(4).hdrBlk = 204h;
	direct(4).empty = 0;
	direct(4).attrib = 3;
	direct(4).eof$count = 80h;
	do i = 5 to 7;
		direct(i).empty = 7fh;
	end;
	call absio(6, disk, 102h, .direct);	
	call clearBuf(.direct);
	do i = 0 to 7;
		direct(i).empty = 7fh;
	end;
	do i = 2 to 25;
		call absio(6, disk, 101h + i, .direct);
	end;
	call setblock(101h);
	do jj = 102h to 11ah;
		call setblock(jj);
	end;
	call setblock(201h);
	do jj = 202h to 203h;
		call setblock(jj);
	end;
	call setblock(18h);
	do jj = 1 to 17h;
		call setblock(jj);
	end;
	call setblock(19h);
	do jj = 1ah to 1ah;
		call setblock(jj);
	end;
	call setblock(204h);
	call absio(6, disk, 202h, .bitmap);
	call absio(6, disk, 203h, .bitmap +  80h);
end;
/* native plm80 v1.0 inlines @P0103 and @P0104 here */
end;
cusp2/makefile
# common makefile info
ROOT=../../..
TARGETS=cusp2.lib
unexport ISIS_F1

include $(ROOT)/tools/isis.mk

REF = $(call ipath,toolbox,1.0)

PLM80 = 3.1

PLMFLAGS=code
ASMFLAGS=


OBJS= alloc.obj direct.obj absio.obj clrbuf.obj d.obj dblank.obj \
	diskio.obj dlimit.obj dmeq.obj filerr.obj fmttrk.obj \
	forupp.obj mvasci.obj monitr.obj meq.obj numout.obj path.obj \
	popula.obj reperr.obj scnblk.obj scanin.obj seq.obj setblk.obj \
	tabwrt.obj upcase.obj unpath.obj wrtdir.obj wpath.obj

# verify will throw up errors due to different behaviour with plm v1.0
# see source code for known differences
.IGNORE: verify

all::
	$(MAKE) $(TARGETS)

cusp2.lib: $(OBJS)
	$(call lib,$@, $^)

cusp3/cusp3_all.src
?absio.plm
ABSIO: DO;
DECLARE DCB$T LITERALLY 'STRUCTURE (iocw BYTE, ioins BYTE, nsec BYTE, tadr BYTE, sadr BYTE, buf ADDRESS)';

diskio: procedure(disk, dcb$ptr) external; declare (disk, dcb$ptr) address; end;

absio: procedure(cmd, disk, block, buffer) public;
	declare (cmd, disk) byte, (block, buffer) address;
	declare dcb DCB$T;

	dcb.iocw = 80H;
	dcb.ioins = cmd;
	dcb.nsec = 1;
	dcb.tadr = high(block);
	dcb.sadr = low(block);
	dcb.buf = buffer;
	call diskio(disk, .dcb);
end;
end;
?alloc.plm
ALLOC: DO;
DECLARE DCB$T LITERALLY 'STRUCTURE (iocw BYTE, ioins BYTE, nsec BYTE, tadr BYTE, sadr BYTE, buf ADDRESS)';

declare
	bitmap(512) byte public,
	currentBitmap byte public initial(0ffh),
	mapChange byte public initial(0),
	lastBlock address public,
	(lastSector, lastTrack) byte public at (.lastBlock),
	lastCounter address public,
	mapDcb DCB$T initial(80H, 0, 4, 2, 2, 0),	/* I suspect this should be public */
	maskArray(*) byte public data(80H, 40H, 20H, 10H, 8, 4, 2, 1);
end;
?clrbuf.plm
CLEARBUF: DO;

clearbuf: procedure(buf$ptr) public;
	declare buf$ptr address, i byte,
		buf based buf$ptr (1) byte;

	do i = 0 to 127;
		buf(i) = 0;
	end;
end;
end;
?d.plm
D: DO;
	open: procedure (conn$p, path$p, access, echo, status$p) external;
	    declare (conn$p, path$p, access, echo, status$p) address;
	end open;

	read: procedure (conn, buff$p, count, actual$p, status$p) external;
	    declare (conn, buff$p, count, actual$p, status$p) address;
	end read;

	write: procedure (conn, buff$p, count, status$p) external;
	    declare (conn, buff$p, count, status$p) address;
	end write;

	close: procedure (conn, status$p) external;
	    declare (conn, status$p) address;
	end close;

	delimit: procedure(ptr) address external;
		declare ptr address, ch based ptr byte;
	end;

	NumOut: procedure(value, base, lc, bufAdr, width) external;
		declare (value, bufAdr) address, (base, lc, width) byte;
	end;

	meq: procedure(mPtr, fptr) byte external;
		declare (mPtr, fptr) address;
	end;

	unpath:	procedure(int, ext) external;
		declare (int, ext) address;
	end;

	deblank: procedure(ptr) address external;
		declare ptr address;
	end;

	declare direct structure(status byte, name(6) byte, ext(3) byte, attrib byte, eof$count byte,
				 blk address, hdrBlk address) external;
	declare directIno address external;

	Population: procedure(bufferLoc, len) address external;
		declare (bufferLoc, len) address;
	end;

declare isisMapFile(*) byte initial(':F :ISIS.MAP '),
	isisLabFile(*) byte initial(':F :ISIS.LAB '),
	isisDirFile(*) byte initial(':F :ISIS.DIR '),
	crlf(2) byte data(0DH, 0AH),
	blksUsedMsg(*) byte data('XXXX/YYYY BLOCKS USED', 0DH, 0AH),
	dirOfMsg(*) byte data('DIRECTORY OF '),
	dirHeader(*) byte data('NAME  .EXT BLKS   LENGTH ATTR', 0DH, 0AH);

D: procedure(drive, conn, arg3b, arg4b, arg5w) public;
	declare (drive, conn, arg3b, arg4b) byte, arg5w address;
	declare (dconn, status, actual, unused) address,
		(sectUsed, highFileSize, lowFileSize) address,
		totalSectUsed address,
		mapBuf(512) byte,
		strBuf(15) byte,
		path(15) byte,
		(i, j) byte,
		mapBufSize address;

	bigAdd: procedure(n);
		declare n address;
		lowFileSize = lowFileSize + n;
		if lowFileSize > 9999 then
		do;
			lowFileSize = lowFileSize - 10000;
			highFileSize = highFileSize + 1;
		end;
	end;	


	do i = 0 to last(mapBuf);
		mapBuf(i) = 0;
	end;
	
	totalSectUsed = 0;
	isisMapFile(2), isisLabFile(2), isisDirFile(2) = drive + '0';
	call Open(.dconn, .isisLabFile, 1, 0, .status);
	strBuf(0) = drive;
	call Read(dconn, .strBuf(1), 9, .actual, .status);
	call Write(conn, .dirOfMsg, 13, .status);
	call Unpath(.strBuf, .path);
	i = Delimit(.path) - .path;
	call Write(conn, .path, i, .status);
	call Write(conn, .crlf, 2, .status);
	call close(dconn, .status);
	if (not arg3b) then
		call Write(conn, .dirHeader, size(dirHeader), .status);
	call Open(.dconn, .isisDirFile, 1, 0, .status);
	actual = 16;
	direct.status = actual;
	do while actual = size(direct) and direct.status <> 07fh;
		call read(dconn, .direct, 16, .actual, .status);
		if actual = size(direct) and (not direct.status) and
		   ((direct.attrib and 1) = 0 or arg4b) and
		   meq(arg5w, .direct) then
		   do;
			do i = 0 to 8;
				if direct.name(i) = 0 then
					direct.name(i) = ' ';
			end;
			i = 9;
			if arg3b then	
				do while direct.name(i - 1) = ' ';
					i = i - 1;
				end;
			if not arg3b or i > 6 then
				j = 6;
			else	
				j = i;
			call Write(conn, .direct.name, j, .status);
			if arg3b then
			do;
				if i > 6 then
				do;
					call Write(conn, .('.'), 1, .status);
					call Write(conn, .direct.ext, i - 6, .status);
				end;
			end;
			else
			do;
				if direct.ext(0) <> ' ' then
					call Write(conn, .('.'), 1, .status);
				call Write(conn, .direct.ext, 3, .status);
				if direct.ext(0) = ' ' then
					call Write(conn, .(' '), 1, .status);
				sectUsed = direct.blk;
				if sectUsed > 0 then
					sectUsed = sectUsed + (sectUsed + 61) / 62;
				else
					sectUsed = 1;
				totalSectUsed = totalSectUsed + sectUsed;
				call NumOut(sectUsed, 10, ' ', .strBuf, 5);
				call Write(conn, .strBuf, 5, .status);
				sectUsed = direct.blk;
				lowFileSize, highFileSize = 0;
				if sectUsed > 0 then
				do;
					sectUsed = sectUsed - 1;
					call bigAdd(direct.eof$count);
					do while sectUsed > 0;
						sectUsed = sectUsed - 1;
						call bigAdd(128);
					end;
				end;

				if highFileSize <> 0 then
				do;
					call NumOut(highFileSize, 10, ' ', .strBuf, 5);
					call NumOut(lowFileSize, 10, '0', .strBuf(5), 4);
				end;
				else
					call NumOut(lowFileSize, 10, ' ', .strBuf, 9);
				call Write(conn, .strBuf, 9, .status);
				if direct.attrib <> 0 then
				do;
					do i = 0 to 4;
						strbuf(i) = ' ';
					end;
					if (direct.attrib and 4) <> 0 then
						strbuf(1) = 'W';
					if (direct.attrib and 2) <> 0 then
						strbuf(2) = 'S';
					if (direct.attrib and 1) <> 0 then
						strbuf(3) = 'I';
					if (direct.attrib and 80h) <> 0 then
						strbuf(4) = 'F';
					call write(conn, .strbuf, 5, .status);
				end;
			end;
			call Write(conn, .crlf, 2, .status);
		end;	
	end;
	call Close(dconn, .status);
	if not arg3b then
	do;
		call NumOut(totalSectUsed, 10, ' ', .strBuf, 15);
		call Write(conn, .strBuf, 15, .status);
		call Write(conn, .crlf, 2, .status);
	end;
	call Open(.dconn, .isisMapFile, 1, 0, .status);	
	if drive <= 3 then
		mapBufSize = 512;
	else
		mapBufSize = 256;
	call Read(dconn, .mapBuf, mapBufSize, .actual, .status);
	call NumOut(Population(.mapBuf, mapBufSize), 10, 0, .blksUsedMsg, 4);
	if drive <= 3 then
		call NumOut(4004, 10, 0, .blksUsedMsg + 5, 4);
	else
		call NumOut(2002, 10, 0, .blksUsedMsg + 5, 4);
	call Write(conn, .blksUsedMsg, length(blksUsedMsg), .status);
	call Close(conn, .status);
	return;
end;
end;
?dblank.plm
DEBLANK: DO;
deblank: procedure(str) address public;
	declare str address;
	declare c based str byte;

	do while (c = ' ');
		str = str + 1;
	end;
	return str;
end;

end;
?direct.plm
DIRECT: DO;
declare	DIRECT(16) byte public,
	DIRECTINO byte public;
end;
?diskio.plm
DISKIO: DO;
isis: procedure(syscmd, param$p) external; declare syscmd byte, param$p address; end;

diskio: procedure(disk, dcb$p) public;
	declare (disk, dcb$p) address; 
	declare param structure(disk address, dcb$p address);
	
	param.disk = disk;
	param.dcb$p = dcb$p;
	call isis(44H, .param);
end;
end;
?dlimit.plm
DELIMIT: DO;
delimit: procedure(ptr) address public;
	declare ptr address, ch based ptr byte;

	do while ch = ':' or ch = '.' or
		 ('0' <= ch and ch <= '9') or
		 ('A' <= ch and ch <= 'Z');
		ptr = ptr + 1;
	end;
	return ptr;
end;
end;
?dmeq.plm
DMEQ: DO;
/* b1=01, b2=10, CODE(B0H) byte, DATA(11H) byte, STACK(8H) byte, MEMORY(0H) byte,*/
declare TRUE	literally '0FFH',
	FALSE	literally '0';

read: procedure (conn, buff$p, count, actual$p, status$p) external;
    declare (conn, buff$p, count, actual$p, status$p) address;
end read;

seek: procedure (conn, mode, block$p, byte$p, status$p) external;
    declare (conn, mode, block$p, byte$p, status$p) address;
end seek;

meq: procedure(A, B) byte external ; declare (A,B) address; end;

dmeq: procedure (dir$aftn, search$arg, initial$i$no, dir$entry) byte public;
    declare dir$aftn byte, (search$arg, initial$i$no, dir$entry) address;
    declare (byteNo, blockNo, actual, status) address;
    declare (pad, searching) byte;
    declare dirFlag based dir$entry byte;

	blockNo = 0;
	byteNo = initial$i$no * 16;
	call seek(dir$aftn, 2, .blockNo, .byteNo, .status);

	searching = TRUE;
	do while searching;
		call read(dir$aftn, dir$entry, 16, .actual, .status);
		searching = not meq(search$arg, dir$entry);
		initial$i$no = initial$i$no + 1;
		if dirFlag = 7Fh or actual = 0 then
		do;
			initial$i$no = 201;
			searching = FALSE;
		end;
	end;
		
	return initial$i$no;
end;
end;

?filerr.plm
FILEERROR: DO;

write: procedure (conn, buff$p, count, actual$p) external;
    declare (conn, buff$p, count, actual$p) address;
end write;

exit: procedure external; end exit;

deblank: procedure(str) address external; declare str address; end;
scanblank: procedure(ptr) address external; declare ptr address; end;
reporterror: procedure(status) external; declare status address; end;

fileerror: procedure(status, ptr, callExit) public;
	declare (status, ptr) address, callExit byte;
	declare actual address;

	if status <> 0 then
	do;
		ptr = deblank(ptr);
		call write(0, .(' '), 1, .actual);
		call write(0, ptr, scanblank(ptr) - ptr, .actual);
		call write(0, .(','), 1, .actual);
		call reporterror(status);
		if callExit then
			call exit;
	end;
end;
end;
?fmttrk.plm
FORMATTRACK: DO;

diskio: procedure(disk, dcb$p) external; declare disk address, dcb$p address; end;

declare spt(*) byte data(52, 52, 52, 52, 26, 26);
declare tbufLast(*) byte data(103, 103, 103, 103, 51, 51);


formatTrack: procedure(disk,sTrack,eTrack,interleave) public;
	declare (disk,sTrack,eTrack,interleave) byte;
	declare (i,j,k) byte, trackBuf(104) byte,
	dcb structure(iocw byte, ioins byte, nsec byte, tadr byte, sadr byte, buf address);


	dcb.iocw = 0c0h;
	dcb.ioins = 2;
	
	do i = 1 to tBufLast(disk) by 2;
		trackBuf(i) = 0c7h;	
	end;
	j = 0;
	do k = sTrack to eTrack;
		do i = 0 to tbufLast(disk) by 2;
			trackBuf(i) = 0;
		end;
		do i = 1 to spt(disk);
			j = (j + interleave) mod spt(disk);
			do while trackBuf(j + j) <> 0;
				j = (j + 1) mod spt(disk);
			end;
			trackBuf(j + j) = i;
		end;
		dcb.tadr = k;
		dcb.buf = .trackBuf;
		call diskio(disk, .dcb);
	end;
end;
end;
?forupp.plm
FORCEUPPER: DO;
/* b1=01, b2=10, CODE(25H) byte, DATA(2H) byte, STACK(2H) byte, MEMORY(0H) byte,*/
declare CR literally '0DH';

uppercase: procedure(ch) byte external; declare ch byte; end;

forceupper: procedure(bufferPtr) public;
	declare bufferPtr address, ch based bufferPtr byte;

	do while ch <> CR;
		ch = uppercase(ch);
		bufferPtr = bufferPtr + 1;
	end;
end;
end;
?meq.plm
MEQ: DO;

meq: procedure(mPtr, fptr) byte public;
	declare (mPtr, fptr) address;
	declare m based mPtr (10) byte;
	declare f based fptr (10) byte;
	declare i byte;

	do i = 0 to 9;
		if m(i) <> '?' then
		do;
			if m(i) <> f(i) then
				return 0;
		end;
	end;
	return 0ffh;
end;
end;
?monitr.plm
MONITOR: DO;
MONITOR: procedure public;
	declare sp address, wrd based sp address;
	sp = STACKPTR;
	wrd = 8;	
	STACKPTR = STACKPTR  - 2;
	sp = STACKPTR;
	wrd = 0;
end;
end;
?mvasci.plm
MOVEASCII: DO;
moveascii: procedure(dst, src, cnt) public;
	declare (dst, src) address, cnt byte, i byte;
	declare dch based dst (1) byte, sch based src (1) byte;

	do i = 0 to cnt - 1;
		dch(i) = sch(i);
	end;
end;
end;
?numout.plm
NUMOUT: DO;

declare digits(*) byte data('0123456789ABCDEF');

numout: procedure(val, base, lc, bufAdr, width) public;
	declare (val, bufAdr) address, (base, lc, width) byte; 
	declare i byte;
	declare buf based bufAdr (1) byte;

	do i = 1 to width;
		buf(width - i) = digits(val mod base);
		val = val / base;	
	end;

	i = 0;
	do while buf(i) = '0' and i < width - 1;
		buf(i) = lc;
		i = i + 1;
	end;
end;
end;
?path.plm
PATH: DO;

uppercase: procedure(sch) byte external; declare sch byte; end;

declare devTab(*) byte data('F0F1F2F3F4F5TITO',
			    'VIVOI1O1TRHRR1R2',
			    'TPHPP1P2LPL1BBCICO');
declare lastpath(15) byte;

declare TRUE	literally '0ffh',
	FALSE	literally '0';

PATH: procedure(filename, pn) byte public;
	declare (filename, pn) address;
	declare pathPtr address, devPair address, (loByte, hiByte) byte at (.devPair),
		devPtr address, (noName, pl, i) byte;
	declare pnByte based pn (10) byte;
	declare fileChar based filename (1) byte, pathChar based pathPtr (1) byte;
	declare devTabPair based devPtr address;

	isFileNameChar: procedure byte;
		return 'A' <= fileChar(0) and fileChar(0) <= 'Z' or
		   '0' <= fileChar(0) and fileChar(0) <= '9' or
		   'a' <= fileChar(0) and fileChar(0) <= 'z';
	end;


	devPtr = .devTab;
	do i = 0 to 9;
		pnByte(i) = 0;
	end;
	do while fileChar(0) = ' ';
		filename = filename + 1;
	end;

	pathptr = filename;
	if pathChar(0) = ':' then
	do;
		pnByte(0) = 255;
		if fileChar(3) <> ':' then
			return 4;
		filename = filename + 1;
		loByte = uppercase(fileChar(0));
		filename = filename + 1;
		hiByte = uppercase(fileChar(0));
		filename = filename + 2;
		i = 0;
		do while i < last(devTab);
			if devTabPair =  devPair then
				pnByte(0) = shr(i, 1);
			i = i + 2;
			devPtr = devPtr + 2;
		end;
		if pnByte(0) = 255 then
			return 5;
	end;
	noName = TRUE;
	i = 1;
	do while i < 7;
		if isFileNameChar then
		do;
			pnByte(i) = uppercase(fileChar(0));
			filename = filename + 1;
			noName = FALSE;
		end;
		i = i + 1;
	end;
	if fileChar(0) = '.' then
	do;
		filename = filename + 1;
		i = 7;
		do while i < 10;
			if isFileNameChar then
			do;
				pnByte(i) = uppercase(fileChar(0));
				filename = filename + 1;
			end;
			i = i + 1;
		end;
	end;
	if pnByte(0) <= 5 and noName then
		return 17h;
	
	pl = 255;
	do while pathPtr < filename;
		lastpath(pl := pl + 1) = pathChar(0);
		pathPtr = pathPtr + 1;
	end;
	if lastpath(pl) = '.' then
		return 1ch;
	lastpath(pl + 1) = ' ';
	if isFileNameChar or fileChar(0) = '.' or fileChar(0) = ':' then
		return 4;
	return 0;
end;
end;
?popula.plm
POPULATION: DO;

declare bitCnt(*) byte data(0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4);


population: procedure(bufferLoc, length) address public;
	declare (bufferLoc, length) address;
	declare total address, (lowNibble, highNibble) byte,
		(i, lastByte) address;
	declare buffer based bufferLoc (1) byte;

	total = 0;
	lastByte = length - 1;
	do i = 0 to lastByte;
		lowNibble = buffer(i) and 0fh;		
		highNibble = ror(buffer(i), 4) and 0fh;
		total = total + bitCnt(lowNibble) + bitCnt(highNibble);
	end;
	return total;
end;
end;
?reperr.plm
REPORTERROR: DO;

error: procedure(errNum) external; declare errNum address; end;

write: procedure(aftn, buf$ptr, len, status$ptr) external;
   declare (aftn, buf$ptr, len, status$ptr) address;
end write;

numout: procedure(val, base, lead, buf$ptr, len) external;
	declare (val, buf$ptr) address, (base, lead, len) byte; 
end numout;

declare msg(*) byte DATA(0, 0,
	2, 'ILLEGAL AFTN ARGUMENT', 0,
	4, 'INCORRECTLY SPECIFIED FILE', 0,
	5, 'UNRECOGNIZED DEVICE NAME', 0,
	6, 'ATTEMPT TO WRITE TO INPUT DEVICE', 0,
	8, 'ATTEMPT TO READ FROM OUTPUT DEVICE', 0,
	0AH, 'NOT ON SAME DISK', 0,
	0BH, 'FILE ALREADY EXISTS', 0,
	0CH, 'FILE IS ALREADY OPEN', 0,
	0DH, 'NO SUCH FILE', 0,
	0EH, 'WRITE PROTECTED', 0,
	11H, 'NOT A DISK FILE', 0,
	12H, 'ILLEGAL ISIS COMMAND', 0,
	13H, 'ATTEMPTED SEEK ON NON-DISK FILE', 0,
	14H, 'ATTEMPTED BACK SEEK TOO FAR', 0,
	15H, 'CAN''T RESCAN', 0,
	16H, 'ILLEGAL ACCESS MODE TO OPEN', 0,
	17H, 'MISSING FILENAME', 0,
	19H, 'ILLEGAL ECHO FILE', 0,
	1AH, 'ILLEGAL ATTRIBUTE IDENTIFIER', 0,
	1BH, 'ILLEGAL SEEK COMMAND', 0,
	1CH, 'MISSING EXTENSION', 0,
	1FH, 'CAN''T SEEK ON WRITE ONLY FILE', 0,
	20H, 'CAN''T DELETE OPEN FILE', 0,
	23H, 'SEEK PAST EOF', 0,
	0C9H, 'UNRECOGNIZED SWITCH', 0,
	0CAH, 'UNRECOGNIZED DELIMITER', 0,
	0CBH, 'INVALID SYNTAX', 0,
	0CCH, 'PREMATURE EOF', 0,
	0CEH, 'ILLEGAL DISKETTE LABEL', 0,
	0D0H, 'CHECKSUM ERROR', 0,
	0D1H, 'RELO FILE SEQUENCE ERROR', 0,
	0D2H, 'INSUFFICIENT MEMORY', 0,
	0D3H, 'RECORD TOO LONG', 0,
	0D4H, 'ILLEGAL RELO RECORD', 0,
	0D5H, 'FIXUP BOUNDS ERROR', 0,
	0D6H, 'ILLEGAL SUBMIT PARAMETER', 0,
	0D7H, 'ARGUMENT TOO LONG', 0,
	0D8H, 'TOO MANY PARAMETERS', 0,
	0D9H, 'OBJECT RECORD TOO SHORT', 0,
	0DAH, 'ILLEGAL RECORD FORMAT', 0,
	0DBH, 'PHASE ERROR', 0
	);

reporterror: procedure(errNum) public;
	declare errNum address;
	declare numberBuffer(3) byte, i address, status address;
 

	if errNum <> 0 then
	do;
		i = 0;
		do while i < size(msg);
			if errNum = msg(i) and msg(i + 1) <> 0 then
			do;
				i = i + 1;
				call write(0, .(' '), 1, .status);
				do while msg(i) <> 0;
					call write(0, .msg(i), 1, .status);
					i = i + 1;
				end;
				call write(0, .(0dh, 0ah), 2, .status);
				return;
			end;
			else
			do;
				do while msg(i) <> 0;
					i = i + 1;
				end;
				i = i + 1;
			end;
		end;
	call error(errNum);
	end;
end;
end;

?scanin.plm
scanIn: do;

declare digits(*) byte data('0123456789ABCDEF');

ScanInteger: procedure(ptrPtr) address public;
	declare ptrPtr address;
	declare ptr based ptrPtr address;
	declare (scanPtr, updatePtr, stopPtr) address;
	declare (i, radix, increment) byte;
	declare (nVal, oVal) address;
	declare c based scanPtr byte;

	scanPtr = ptr;
	do while c = ' ';
		scanPtr = scanPtr + 1;
	end;
	ptr = scanPtr;
	do while '0' <= c and c <= '9' or 'A' <= c and c <= 'F';
		scanPtr = scanPtr + 1;
	end;

	stopPtr = scanPtr;
	updatePtr = scanPtr + 1;
	if c = 'H' then
		radix = 16;
	else if c = 'O' or c = 'Q' then
		radix = 8;
	else
	do;
		updatePtr = scanPtr;
		stopPtr, scanPtr = scanPtr - 1;
		if c = 'B' then
			radix = 2;
		else
		do;
			radix = 10;
			if c <> 'D' then	/* include last increment */
				stopPtr = stopPtr + 1;
		end;
	end;
	scanPtr = ptr;
	nVal, oVal = 0;
	do while scanPtr < stopPtr;
		do i = 0 to 15;
			if c = digits(i) then
				increment = i;
		end;
		if increment >= radix then
			return 0;
		nVal = oVal * radix + increment;
		if nVal < oVal then
			return 0;
		oVal = nVal;
		scanPtr = scanPtr + 1;
	end;
	ptr = updatePtr;
	return nVal;
end;
end;
?scnblk.plm
SCANBLANK: DO;

delimit: procedure(ptr) address external; declare ptr address; end;

scanblank: procedure(ptr) address public;
	declare ptr address, ch based ptr byte;

	do while (1);
		ptr = delimit(ptr);
		if ch = '*' or ch = '?' then
			ptr = ptr + 1;
		else
			return ptr;
	end;
end;
end;
?seq.plm
SEQ: DO;
seq: procedure(s1, s2, cnt) byte public;
	declare (s1,s2) address, cnt byte;
	declare s1a based s1(1) byte;
	declare s2a based s2(1) byte;
	declare i byte;
	cnt = cnt - 1;
	do i = 0 to cnt;
		if s1a(i) <> s2a(i) then
			return 0;
	end;
	return 0ffh;
end;
end;
?setblk.plm
SETBLOCK: DO;

declare bitmap(1) byte external,
	currentBitmap byte external,
	mapChange byte external,
	lastBlock address external,
	lastSector byte external,
	lastTrack byte external,
	lastCounter address external,
	mapDcb structure(iocw BYTE, ioins BYTE, nsec BYTE, tadr BYTE, sadr BYTE, buf ADDRESS) external,
	maskArray(1) byte external;

declare spt(*) byte data(52, 52, 52, 52, 26, 26);

setBlock: procedure(adr) public;
	declare adr address;
	declare (bit, byt) address;

	bit = high(adr) * spt(currentBitMap) + low(adr) - 1;
	byt = shr(bit, 3);
x: /* force reload of byt */
	bitmap(byt) = bitmap(byt) or maskArray(low(bit) and 7);
end;
end;
?tabwrt.plm
TABWRITE: DO;
declare TAB	literally '9',
	CR	literally '0dh';

write: procedure (aft, buff$p, count, status) external;
    declare (aft, buff$p, count, status) address;
end write;

tabwrite: procedure(columnPtr, aft, bufferPtr, count, status) public;
	declare (columnPtr, aft, bufferPtr, count, status) address;
	declare (printChar, i, j) byte;
	declare column based columnPtr byte;
	declare ch based bufferPtr byte;

	do while count <> 0;
		i = ch = TAB and (7 - (column and 7));
		printChar = ch;
		bufferPtr = bufferPtr + 1;
		count = count - 1;
		if printChar = TAB then
			printChar = ' ';
		do j = 0 to i;
			if ch = CR then
				column = 0;
			if ch >= ' ' then
				column = column + 1;
			call write(aft, .printChar, 1, status);
		end;
	end;
end;
end;
?unpath.plm
UNPATH: DO;

declare devTab(*) byte data('F0F1F2F3F4F5TITO',
			     'VIVOI1O1TRHRR1R2',
			     'TPHPP1P2LPL1BBCICO');

unpath:	procedure(int, ext) public;
	declare (int, ext) address;
	declare i byte;
	declare intName based int (1) byte;
	declare extName based ext (1) byte;

	extName(0) = ':';
	extName(1) = devTab(intName(0) + intName(0));
	extName(2) = devTab(intName(0) + intName(0) + 1);
	extName(3) = ':';	
	ext = ext + 4;
	do i = 0 to 5;
		if (extName(0) := intName(i + 1)) <> 0 then
			ext = ext + 1; 
	end;
	if intName(7) <> 0 then
	do;
		extName(0) = '.';
		ext = ext + 1;
	end;
	do i = 0 to 2;
		if (extName(0) := intName(i + 7)) <> 0 then
			ext = ext + 1; 

	end;
	extName(0) = ' ';
end;
end;
?upcase.plm
UPPERCASE: DO;
uppercase: procedure(char) byte public;
	declare char byte;
	if char < 'a' then
		return char;
	if char > 'z' then
		return char;
	return char and 0dfh;
end;
end;
?wpath.plm
WPATH: DO;

uppercase: procedure(sch) byte external; declare sch byte; end;

declare TRUE literally '0ffh',
	FALSE literally '0';

declare	devTab(*) byte data ('F0F1F2F3F4F5TITO',
			      'VIVOI1O1TRHRR1R2',
			      'TPHPP1P2LPL1BBCI',
			      'CO');

declare lastPathnameParsed(15) byte;

wpath: procedure(pathnamePtr, pn) byte public;
	declare (pathnamePtr, pn) address;
	declare (ptr, addr, devPtr) address,
		(lo, hi) byte at (.addr),
		devPair based devPtr address;
	declare	(nullName, pl, i) byte;
	declare path based pn(1) byte;
	declare sch based pathnamePtr byte;
	declare s based pathnamePtr(1) byte;
	declare tch based ptr byte;

	nonTerminator: procedure byte;
		return 'A' <= sch and sch <= 'Z' or
		   '0' <= sch and sch <= '9' or
		    sch = '?' or sch = '*' or
		   'a' <= sch and sch <= 'z';
	end;

	devPtr = .devTab;
	do i = 0 to 9;
		path(i) = 0;
	end;
	do while sch = ' ';
		pathnamePtr = pathnamePtr + 1;
	end;
	ptr = pathnamePtr;
	if sch = ':' then
	do;
		path(0) = TRUE;
		if s(3) <> ':' then
			return 4;
		pathnamePtr = pathnamePtr + 1;
		lo = uppercase(sch);
		pathnamePtr = pathnamePtr + 1;
		hi = uppercase(sch);
		pathnamePtr = pathnamePtr + 2;

		i = 0;
		do while i < last(devTab);
			if devPair = addr then
				path(0) = shr(i, 1);
			i = i + 2;
			devPtr = devPtr + 2;
		end;
		if path(0) = 255 then
			return 5;
	end;

	nullName = TRUE;
	i = 1;
	do while i < 7;
		if nonTerminator then
		do;
			path(i) = uppercase(sch);
			if sch = '*' then
				do while i < 7;
					path(i) = '?';
					i = i + 1;
				end;
			pathnamePtr = pathnamePtr + 1;
			nullName = FALSE;
		end;
		i = i + 1;
	end;
	if sch = '.' then
	do;
		pathnamePtr = pathnamePtr + 1;
		i = 7;
		do while i < 10;
			if nonTerminator then
			do;
				path(i) = uppercase(sch);
				if sch = '*' then
					do while i < 10;
						path(i) = '?';
						i = i + 1;
					end;
				pathnamePtr = pathnamePtr + 1;
			end;
			i = i + 1;
		end;	
	end;
	if path(0) <= 5 and nullName then
		return 17h;
	pl = 255;
	do while ptr < pathnamePtr;
		lastPathnameParsed(pl := pl + 1) = tch;
		ptr = ptr + 1;
	end;
	if lastPathnameParsed(pl) = '.' then
		return 1ch;
	lastPathnameParsed(pl + 1) = ' ';	
	if nonTerminator or sch = '.' or sch = ':' then
		return 4;
	return 0;
end;
end;

?wrtdir.plm
WRITEDIRECTORY: DO;

declare bitmap(512) byte external;
/* following are declared but not used */
declare	currentBitMap byte external,
	mapChange byte external,
	lastBlock address external,
	lastSector byte external,
	lastTrack byte external,
	lastCounter byte external,
	mapDcb(1) byte external,
	maskArray(1) byte external;

setblock: procedure(adr) external; declare adr address; end;

clearbuf: procedure(buf$ptr) external;
	declare buf$ptr address;
end;

absio: procedure(cmd, disk, block, buffer) external;
	declare (cmd, disk) byte, (block, buffer) address;
end;
moveascii: procedure(dst, src, cnt) external;
	declare (dst, src) address, cnt byte;
end;


declare	dirFile(*) byte data('ISIS', 0, 0, 'DIR'),
	mapFile(*) byte data('ISIS', 0, 0, 'MAP'),
	t0File(*) byte data('ISIS', 0, 0, 'T0', 0),
	binFile(*) byte data('ISIS', 0, 0, 'BIN'),
	labFile(*) byte data('ISIS', 0, 0, 'LAB');

writeDirectory: procedure(disk) public;
	declare	disk byte, i byte, jj address, dirBuf(64) address,
		direct(8) structure(empty byte, file(9) byte, attrib byte,
				    eof$count byte, blk address, hdrBlk address);
	declare countBitMapSectors byte, binHdrBlk address;

	if (currentBitmap := disk) < 4 then
	do;
		countBitMapSectors = 4;
		binHdrBlk = 206h;
	end;
	else
	do;
		countBitMapSectors = 2;
		binHdrBlk = 204h;
	end;
	do jj = 0 to last(bitmap);
		bitmap(jj) = 0;
	end;

	call clearbuf(.dirBuf);
	dirbuf(2) = 1;
	do i = 2 to 23;
		dirBuf(i + 1) = dirBuf(i) + 1;
	end;
	call absio(6, disk, 24, .dirBuf);
	call clearbuf(.dirBuf);
	dirbuf(2) = 26;
	if disk < 4 then
	do;
		do i = 2 to 27;
			dirBuf(i + 1) = dirBuf(i) + 1;
		end;
		dirBuf(29) = 11Bh;
		do i = 2 to 26;
			dirBuf(i + 27 + 1) = dirbuf(i + 27) + 1;
		end;	
	end;
	call absio(6, disk, 25, .dirBuf);
	call clearbuf(.dirBuf);

	dirBuf(2) = 102h;
	do i = 2 to 25;
		dirBuf(i + 1) = dirBuf(i) + 1;
	end;
	call absio(6, disk, 101h, .dirBuf);
	call clearbuf(.dirBuf);

	dirBuf(2) = 202h;
	do i = 2 to countBitMapSectors;
		dirBuf(i + 1) = dirBuf(i) + 1; 
	end;
	call absio(6, disk, 201h, .dirBuf);
	call clearbuf(.dirBuf);

	call absio(6, disk, binHdrBlk, .dirBuf);
	call clearBuf(.direct);

	call moveAscii(.direct(0).file, .dirFile, 9);
	direct(0).blk = 25;
	direct(0).hdrBlk = 101h;
	direct(0).empty = 0;
	direct(0).attrib = 1;
	direct(0).eof$count = 80h;

	call moveAscii(.direct(1).file, .mapFile, 9);
	direct(1).blk = countBitMapSectors;
	direct(1).hdrBlk = 201h;
	direct(1).empty = 0;
	direct(1).attrib = 1;
	direct(1).eof$count = 80h;

	call moveAscii(.direct(2).file, .t0File, 9);
	direct(2).blk = 23;
	direct(2).hdrBlk = 18h;
	direct(2).empty = 0;
	direct(2).attrib = 1;
	direct(2).eof$count = 80h;

	call moveAscii(.direct(3).file, .labFile, 9);
	if disk < 4 then
		direct(3).blk = 53;
	else
		direct(3).blk = 1;
	direct(3).hdrBlk = 19h;
	direct(3).empty = 0;
	direct(3).attrib = 1;
	direct(3).eof$count = 80h;

	call moveAscii(.direct(4).file, .binFile, 9);
	direct(4).blk = 0;
	direct(4).hdrBlk = binHdrBlk;
	direct(4).empty = 0;
	direct(4).attrib = 3;
	direct(4).eof$count = 80h;

	do i = 5 to 7;
		direct(i).empty = 7fh;
	end;
	call absio(6, disk, 102h, .direct);	
	call clearBuf(.direct);
	do i = 0 to 7;
		direct(i).empty = 7fh;
	end;
	do i = 2 to 25;
		call absio(6, disk, 101h + i, .direct);
	end;
	call setblock(101h);
	do jj = 102h to 11ah;
		call setblock(jj);
	end;
	call setblock(201h);
	do jj = 202h to 202h +  countBitMapSectors - 1;
		call setblock(jj);
	end;
	call setblock(18h);
	do jj = 1 to 17h;
		call setblock(jj);
	end;
	call setblock(19h);
	if disk < 4 then
	do;
		do jj = 1ah to 34h;
			call setblock(jj);
		end;
		do jj = 11bh to 134h;
			call setblock(jj);
		end;
	end;
	else
		call setblock(1ah);
	call setblock(binHdrBlk);
	call absio(6, disk, 202h, .bitmap);
	call absio(6, disk, 203h, .bitmap +  80h);
	if disk < 4 then
	do;
		call absio(6, disk, 204h, .bitmap + 100h);
		call absio(6, disk, 205h, .bitmap + 180h);
	end;
end;
end;
cusp3/makefile
ROOT = ../../..
TARGETS = cusp3.lib
unexport ISIS_F1
include $(ROOT)/tools/isis.mk

REF = $(call ipath,toolbox,1.0)

PLM80 = 3.0
PLMFLAGS = code

OBJS = alloc.obj direct.obj absio.obj clrbuf.obj d.obj dblank.obj diskio.obj\
       dlimit.obj dmeq.obj filerr.obj fmttrk.obj forupp.obj mvasci.obj\
       monitr.obj meq.obj numout.obj path.obj popula.obj reperr.obj scnblk.obj\
       scanin.obj seq.obj setblk.obj tabwrt.obj upcase.obj unpath.obj\
       wrtdir.obj wpath.obj

all::
	$(MAKE) $(TARGETS)

cusp3.lib: $(OBJS)
	$(call lib,$@,$^)

cusp4/cusp4_all.src
?absio.plm
ABSIO: DO;
DECLARE DCB$T LITERALLY 'STRUCTURE (iocw BYTE, ioins BYTE, nsec BYTE, tadr BYTE, sadr BYTE, buf ADDRESS)';

diskio: procedure(disk, dcb$ptr) external; declare (disk, dcb$ptr) address; end;

absio: procedure(cmd, disk, block, buffer) public;
	declare (cmd, disk) byte, (block, buffer) address;
	declare dcb DCB$T;

	dcb.iocw = 80H;
	dcb.ioins = cmd;
	dcb.nsec = 1;
	dcb.tadr = high(block);
	dcb.sadr = low(block);
	dcb.buf = buffer;
	call diskio(disk, .dcb);
end;
end;
?alloc.plm
ALLOC: DO;
DECLARE DCB$T LITERALLY 'STRUCTURE (iocw BYTE, ioins BYTE, nsec BYTE, tadr BYTE, sadr BYTE, buf ADDRESS)';

declare
	bitmap(512) byte public,
	currentBitmap byte public initial(0ffh),
	mapChange byte public initial(0),
	lastBlock address public,
	(lastSector, lastTrack) byte public at (.lastBlock),
	lastCounter address public,
	mapDcb DCB$T initial(80H, 0, 4, 2, 2, 0),	/* I suspect this should be public */
	maskArray(*) byte public data(80H, 40H, 20H, 10H, 8, 4, 2, 1);
end;
?chklab.plm
CHECKLABEL: DO;

write: procedure (conn, buff$p, count, status$p) external;
    declare (conn, buff$p, count, status$p) address;
end write;

getDisk: procedure(arg1b) external;
	declare arg1b byte;
end;

getLabel: procedure(lab, device) external;
	declare lab address, device byte;
end;

seq: procedure(s1, s2, cnt) byte external;
	declare (s1,s2) address, cnt byte;
end;

CHECKLABEL: procedure(arg1w, arg2b, arg3b) public;
	declare arg1w address, (arg2b, arg3b) byte;
	declare status address, lab(11) byte;

	do while (1);
		call GETDISK(arg3b);
		if arg2b > 5 then
			return;
		call GETLABEL(.lab, arg2b);
		if SEQ(arg1w, .lab, 9) then
			return;
		lab(0) = arg2b + '0';
		call WRITE(0, .('WRONG DISKETTE IN DRIVE '), 24, .status);
		call WRITE(0, lab(0), 1, .status);	/* bug? should be .lab */
		call WRITE(0, .(0DH, 0AH), 2, .status);
	end;
end;

end;
?clrbuf.plm
CLEARBUF: DO;

clearbuf: procedure(buf$ptr) public;
	declare buf$ptr address, i byte,
		buf based buf$ptr (1) byte;

	do i = 0 to 127;
		buf(i) = 0;
	end;
end;
end;
?d.plm
D: DO;
	open: procedure (conn$p, path$p, access, echo, status$p) external;
	    declare (conn$p, path$p, access, echo, status$p) address;
	end open;

	read: procedure (conn, buff$p, count, actual$p, status$p) external;
	    declare (conn, buff$p, count, actual$p, status$p) address;
	end read;

	write: procedure (conn, buff$p, count, status$p) external;
	    declare (conn, buff$p, count, status$p) address;
	end write;

	close: procedure (conn, status$p) external;
	    declare (conn, status$p) address;
	end close;

	delimit: procedure(ptr) address external;
		declare ptr address, ch based ptr byte;
	end;

	NumOut: procedure(value, base, lc, bufAdr, width) external;
		declare (value, bufAdr) address, (base, lc, width) byte;
	end;

	meq: procedure(mPtr, fptr) byte external;
		declare (mPtr, fptr) address;
	end;

	unpath:	procedure(int, ext) external;
		declare (int, ext) address;
	end;

	deblank: procedure(ptr) address external;
		declare ptr address;
	end;

	spath: procedure (path$p, info$p) byte external;
	    declare (path$p, info$p) address;
	end spath;

	declare direct structure(status byte, name(6) byte, ext(3) byte, attrib byte, eof$count byte,
				 blk address, hdrBlk address) external;
	declare directIno address external;

	Population: procedure(bufferLoc, len) address external;
		declare (bufferLoc, len) address;
	end;

declare isisDrive(*) byte initial(':FX:', 0),
	isisMapFile(*) byte initial(':F :ISIS.MAP '),
	isisLabFile(*) byte initial(':F :ISIS.LAB '),
	isisDirFile(*) byte initial(':F :ISIS.DIR ');

declare	crlf(2) byte data(0DH, 0AH),
	blksUsedMsg(*) byte data('XXXX/YYYY BLOCKS USED', 0DH, 0AH),
	dirOfMsg(*) byte data('DIRECTORY OF '),
	dirHeader(*) byte data('NAME  .EXT BLKS   LENGTH ATTR', 0DH, 0AH);

D: procedure(drive, conn, arg3b, arg4b, arg5w) public;
	declare (drive, conn, arg3b, arg4b) byte, arg5w address;
	declare (dconn, status, actual, unused) address,
		(sectUsed, highFileSize, lowFileSize) address,
		totalSectUsed address,
		mapBuf(512) byte,
		strBuf(15) byte,
		path(15) byte,
		(i, j) byte,
		mapBufSize address,
		driveType byte;

	bigAdd: procedure(n);
		declare n address;
		lowFileSize = lowFileSize + n;
		if lowFileSize > 9999 then
		do;
			lowFileSize = lowFileSize - 10000;
			highFileSize = highFileSize + 1;
		end;
	end;	

	isisDrive(2) = drive + '0';

	status = Spath(.isisDrive, .mapBuf);
	if mapBuf(11) = 1 then	/* driveType */
		driveType = 0ffh;	/* DD */
	else
		driveType = 0;	/* SD */
		
	do i = 0 to last(mapBuf);
		mapBuf(i) = 0;
	end;
	
	totalSectUsed = 0;
	isisMapFile(2), isisLabFile(2), isisDirFile(2) = drive + '0';
	call Open(.dconn, .isisLabFile, 1, 0, .status);
	strBuf(0) = drive;
	call Read(dconn, .strBuf(1), 9, .actual, .status);
	call Write(conn, .dirOfMsg, 13, .status);
	call Unpath(.strBuf, .path);
	i = Delimit(.path) - .path;
	call Write(conn, .path, i, .status);
	call Write(conn, .crlf, 2, .status);
	call close(dconn, .status);
	if (not arg3b) then
		call Write(conn, .dirHeader, size(dirHeader), .status);
	call Open(.dconn, .isisDirFile, 1, 0, .status);
	actual = size(direct);
	direct.status = actual;
	do while actual = size(direct) and direct.status <> 07fh;
		call read(dconn, .direct, size(direct), .actual, .status);
		if actual = size(direct) and (not direct.status) and
		   ((direct.attrib and 1) = 0 or arg4b) and
		   meq(arg5w, .direct) then
		   do;
			do i = 0 to 8;
				if direct.name(i) = 0 then
					direct.name(i) = ' ';
			end;
			i = 9;
			if arg3b then	
				do while direct.name(i - 1) = ' ';
					i = i - 1;
				end;
			if not arg3b or i > 6 then
				j = 6;
			else	
				j = i;
			call Write(conn, .direct.name, j, .status);
			if arg3b then
			do;
				if i > 6 then
				do;
					call Write(conn, .('.'), 1, .status);
					call Write(conn, .direct.ext, i - 6, .status);
				end;
			end;
			else
			do;
				if direct.ext(0) <> ' ' then
					call Write(conn, .('.'), 1, .status);
				call Write(conn, .direct.ext, 3, .status);
				if direct.ext(0) = ' ' then
					call Write(conn, .(' '), 1, .status);
				sectUsed = direct.blk;
				if sectUsed > 0 then
					sectUsed = sectUsed + (sectUsed + 61) / 62;
				else
					sectUsed = 1;
				totalSectUsed = totalSectUsed + sectUsed;
				call NumOut(sectUsed, 10, ' ', .strBuf, 5);
				call Write(conn, .strBuf, 5, .status);
				sectUsed = direct.blk;
				lowFileSize, highFileSize = 0;
				if sectUsed > 0 then
				do;
					sectUsed = sectUsed - 1;
					call bigAdd(direct.eof$count);
					do while sectUsed > 0;
						sectUsed = sectUsed - 1;
						call bigAdd(128);
					end;
				end;

				if highFileSize <> 0 then
				do;
					call NumOut(highFileSize, 10, ' ', .strBuf, 5);
					call NumOut(lowFileSize, 10, '0', .strBuf(5), 4);
				end;
				else
					call NumOut(lowFileSize, 10, ' ', .strBuf, 9);
				call Write(conn, .strBuf, 9, .status);
				if direct.attrib <> 0 then
				do;
					do i = 0 to 4;
						strbuf(i) = ' ';
					end;
					if (direct.attrib and 4) <> 0 then
						strbuf(1) = 'W';
					if (direct.attrib and 2) <> 0 then
						strbuf(2) = 'S';
					if (direct.attrib and 1) <> 0 then
						strbuf(3) = 'I';
					if (direct.attrib and 80h) <> 0 then
						strbuf(4) = 'F';
					call write(conn, .strbuf, 5, .status);
				end;
			end;
			call Write(conn, .crlf, 2, .status);
		end;	
	end;
	call Close(dconn, .status);
	if not arg3b then
	do;
		call NumOut(totalSectUsed, 10, ' ', .strBuf, 15);
		call Write(conn, .strBuf, 15, .status);
		call Write(conn, .crlf, 2, .status);
	end;
	call Open(.dconn, .isisMapFile, 1, 0, .status);	
	if driveType then
		mapBufSize = 512;
	else
		mapBufSize = 256;
	call Read(dconn, .mapBuf, mapBufSize, .actual, .status);
	call NumOut(Population(.mapBuf, mapBufSize), 10, 0, .blksUsedMsg, 4);
	if driveType then
		call NumOut(4004, 10, 0, .blksUsedMsg + 5, 4);
	else
		call NumOut(2002, 10, 0, .blksUsedMsg + 5, 4);
	call Write(conn, .blksUsedMsg, length(blksUsedMsg), .status);
	call Close(conn, .status);
	return;
end;
end;
?dblank.plm
DEBLANK: DO;
deblank: procedure(str) address public;
	declare str address;
	declare c based str byte;

	do while (c = ' ');
		str = str + 1;
	end;
	return str;
end;

end;
?direct.plm
DIRECT: DO;
declare	DIRECT(16) byte public,
	DIRECTINO byte public;
end;
?diskio.plm
DISKIO: DO;
isis: procedure(syscmd, param$p) external; declare syscmd byte, param$p address; end;

diskio: procedure(disk, dcb$p) public;
	declare (disk, dcb$p) address; 
	declare param structure(disk address, dcb$p address);
	
	param.disk = disk;
	param.dcb$p = dcb$p;
	call isis(44H, .param);
end;
end;
?dlimit.plm
DELIMIT: DO;
delimit: procedure(ptr) address public;
	declare ptr address, ch based ptr byte;

	do while ch = ':' or ch = '.' or
		 ('0' <= ch and ch <= '9') or
		 ('A' <= ch and ch <= 'Z');
		ptr = ptr + 1;
	end;
	return ptr;
end;
end;
?dmeq.plm
/* b1=01, b2=31, CODE(A3H) byte, DATA(12H) byte, STACK(8H) byte, MEMORY(0H) byte,*/
DMEQ: DO;
declare TRUE	literally '0FFH',
	FALSE	literally '0';

read: procedure (conn, buff$p, count, actual$p, status$p) external;
    declare (conn, buff$p, count, actual$p, status$p) address;
end read;

seek: procedure (conn, mode, block$p, byte$p, status$p) external;
    declare (conn, mode, block$p, byte$p, status$p) address;
end seek;

meq: procedure(A, B) byte external ; declare (A,B) address; end;

dmeq: procedure (dir$aftn, search$arg, initial$i$no, dir$entry) byte public;
    declare (dir$aftn, search$arg, initial$i$no, dir$entry) address;
    declare (byteNo, blockNo, actual, status) address;
    declare (pastDir, searching) byte;
    declare dirFlag based dir$entry byte;

	blockNo = 0;
	byteNo = initial$i$no * 16;
	call seek(dir$aftn, 2, .blockNo, .byteNo, .status);

	searching = TRUE;
	do while searching;
		call read(dir$aftn, dir$entry, 16, .actual, .status);
		searching = not meq(search$arg, dir$entry);
		initial$i$no = initial$i$no + 1;
		if dirFlag = 7Fh or actual = 0 then
		do;
			initial$i$no = 201;
			searching = FALSE;
		end;
	end;
		
	return initial$i$no;
end;
end;
?ferror.plm
FILEERROR: DO;

write: procedure (conn, buff$p, count, actual$p) external;
    declare (conn, buff$p, count, actual$p) address;
end write;

exit: procedure external; end exit;

deblank: procedure(str) address external; declare str address; end;
WDelimit: procedure(ptr) address external; declare ptr address; end;
reporterror: procedure(status) external; declare status address; end;

fileerror: procedure(status, ptr, callExit) public;
	declare (status, ptr) address, callExit byte;
	declare actual address;

	if status <> 0 then
	do;
		ptr = deblank(ptr);
		call write(0, .(' '), 1, .actual);
		call write(0, ptr, WDelimit(ptr) - ptr, .actual);
		call write(0, .(','), 1, .actual);
		call reporterror(status);
		if callExit then
			call exit;
	end;
end;
end;
?fmttrk.plm
FORMATTRACK: DO;

diskio: procedure(disk, dcb$p) external; declare disk address, dcb$p address; end;
declare diskType byte external;


formatTrack: procedure(disk,sTrack,eTrack,interleave) public;
	declare (disk,sTrack,eTrack,interleave) byte;
	declare (i,j,k) byte, trackBuf(104) byte,
	dcb structure(iocw byte, ioins byte, nsec byte, tadr byte, sadr byte, buf address),
	spt byte, tbufLast byte;

	if diskType then
	do;
		spt = 52;
		tBufLast = 103;		
	end;
	else
	do;
		spt = 26;
		tBufLast = 51;
	end;

	dcb.iocw = 0c0h;
	dcb.ioins = 2;
	
	do i = 1 to tBufLast by 2;
		trackBuf(i) = 0c7h;	
	end;
	j = 0;
	do k = sTrack to eTrack;
		do i = 0 to tbufLast by 2;
			trackBuf(i) = 0;
		end;
		do i = 1 to spt;
			j = (j + interleave) mod spt;
			do while trackBuf(j + j) <> 0;
				j = (j + 1) mod spt;
			end;
			trackBuf(j + j) = i;
		end;
		dcb.tadr = k;
		dcb.buf = .trackBuf;
		call diskio(disk, .dcb);
	end;
end;
end;
?forupp.plm
FORCEUPPER: DO;
/* b1=01, b2=10, CODE(25H) byte, DATA(2H) byte, STACK(2H) byte, MEMORY(0H) byte,*/
declare CR literally '0DH';

uppercase: procedure(ch) byte external; declare ch byte; end;

forceupper: procedure(bufferPtr) public;
	declare bufferPtr address, ch based bufferPtr byte;

	do while ch <> CR;
		ch = uppercase(ch);
		bufferPtr = bufferPtr + 1;
	end;
end;
end;
?getdsk.plm
GetDisk: do;

Write: procedure(conn, buff$p, count, status$p) external;
         declare conn address, buff$p address, count address, status$p address; end;

Read: procedure(conn, buff$p, count, actual$p, status$p) external;
        declare conn address, buff$p address, count address, actual$p address, status$p address; end;


declare source(3) structure(name(6) byte) data('SYSTEM', 'SOURCE', 'OUTPUT');

GetDisk: procedure(n) public;
	declare n byte;
	declare buf(128) byte, status address, junk address, actual address;

	call Write(0, .('LOAD '), 5, .status);
	call Write(0, .source(n), 6, .status);
	call Write(0, .(' DISKETTE, THEN TYPE (CR)'), 25, .status);
	call Read(1, .buf, 128, .actual, .status);
end;
end;
?getlab.plm
GETLABEL: DO;

read: procedure (conn, buff$p, count, actual$p, status$p) external;
    declare (conn, buff$p, count, actual$p, status$p) address;
end read;

open: procedure (conn$p, path$p, access, echo, status$p) external;
    declare (conn$p, path$p, access, echo, status$p) address;
end open;

close: procedure (conn, status$p) external;
    declare (conn, status$p) address;
end close;

SFileError: procedure(status, name$p) external;
	declare (status, name$p) address;
end;

declare isisLabFile(*) byte initial(':FX:ISIS.LAB', 0);

GetLabel: procedure(labBuf, drive) public;
	declare labBuf address, drive byte;
	declare (status, actual, conn) address;

	if drive <= 5 then
	do;
		isisLabFile(2) = drive + '0';
		call Open(.conn, .isisLabFile, 1, 0, .status);
		call SFileError(status, .isisLabFile);
		call Read(conn, labBuf, 9, .actual, .status);
		call SFileError(status, .isisLabFile);
		call Close(conn, .status);
		call SFileError(status, .isisLabFile);
	end;
end;
end;
?meq.plm
/* b1=01, b2=31, CODE(76H) byte, DATA(5H) byte, STACK(2H) byte, MEMORY(0H) byte,*/
MEQ: DO;

meq: procedure(mPtr, fptr) byte public;
	declare (mPtr, fptr) address;
	declare m based mPtr (10) byte;
	declare f based fptr (10) byte;
	declare i byte;

	do i = 0 to 9;
		if m(i) = '?' then
		do;
			if f(i) = 0 then
				return 0;
		end;
		else if m(i) <> '*' then
		do;
			if m(i) <> f(i) then
				return 0;
		end;
	end;
	return 0ffh;
end;
end;

?monitr.plm
MONITOR: DO;
MONITOR: procedure public;
	declare sp address, wrd based sp address;
	sp = STACKPTR;
	wrd = 8;	
	STACKPTR = STACKPTR  - 2;
	sp = STACKPTR;
	wrd = 0;
end;
end;
?mvasci.plm
MOVEASCII: DO;
moveascii: procedure(dst, src, cnt) public;
	declare (dst, src) address, cnt byte, i byte;
	declare dch based dst (1) byte, sch based src (1) byte;

	do i = 0 to cnt - 1;
		dch(i) = sch(i);
	end;
end;
end;
?numout.plm
NUMOUT: DO;

declare digits(*) byte data('0123456789ABCDEF');

numout: procedure(val, base, lc, bufAdr, width) public;
	declare (val, bufAdr) address, (base, lc, width) byte; 
	declare i byte;
	declare buf based bufAdr (1) byte;

	do i = 1 to width;
		buf(width - i) = digits(val mod base);
		val = val / base;	
	end;

	i = 0;
	do while buf(i) = '0' and i < width - 1;
		buf(i) = lc;
		i = i + 1;
	end;
end;
end;
?path.plm
PATH: DO;
moveascii: procedure(dst, src, cnt) external;
	declare (dst, src) address, cnt byte;
end;

Spath: procedure(filename, info$p) byte external;
	declare (filename, info$p) address;
end;

PATH: procedure(filename, pn) byte public;
	declare (filename, pn) address;
	declare info(12) byte, status byte;

	status = Spath(filename, .info);
	call MoveAscii(pn, .info, 10);
	return status;
end;
end;
?popula.plm
POPULATION: DO;

declare bitCnt(*) byte data(0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4);


population: procedure(bufferLoc, length) address public;
	declare (bufferLoc, length) address;
	declare total address, (lowNibble, highNibble) byte,
		(i, lastByte) address;
	declare buffer based bufferLoc (1) byte;

	total = 0;
	lastByte = length - 1;
	do i = 0 to lastByte;
		lowNibble = buffer(i) and 0fh;		
		highNibble = ror(buffer(i), 4) and 0fh;
		total = total + bitCnt(lowNibble) + bitCnt(highNibble);
	end;
	return total;
end;
end;
?reperr.plm
REPORTERROR: DO;

error: procedure(errNum) external; declare errNum address; end;

write: procedure(aftn, buf$ptr, len, status$ptr) external;
   declare (aftn, buf$ptr, len, status$ptr) address;
end write;

numout: procedure(val, base, lead, buf$ptr, len) external;
	declare (val, buf$ptr) address, (base, lead, len) byte; 
end numout;

declare msg(*) byte DATA(0, 0,
	2, 'ILLEGAL AFTN ARGUMENT', 0,
	4, 'INCORRECTLY SPECIFIED FILE', 0,
	5, 'UNRECOGNIZED DEVICE NAME', 0,
	6, 'ATTEMPT TO WRITE TO INPUT DEVICE', 0,
	8, 'ATTEMPT TO READ FROM OUTPUT DEVICE', 0,
	0AH, 'NOT ON SAME DISK', 0,
	0BH, 'FILE ALREADY EXISTS', 0,
	0CH, 'FILE IS ALREADY OPEN', 0,
	0DH, 'NO SUCH FILE', 0,
	0EH, 'WRITE PROTECTED', 0,
	11H, 'NOT A DISK FILE', 0,
	12H, 'ILLEGAL ISIS COMMAND', 0,
	13H, 'ATTEMPTED SEEK ON NON-DISK FILE', 0,
	14H, 'ATTEMPTED BACK SEEK TOO FAR', 0,
	15H, 'CAN''T RESCAN', 0,
	16H, 'ILLEGAL ACCESS MODE TO OPEN', 0,
	17H, 'MISSING FILENAME', 0,
	19H, 'ILLEGAL ECHO FILE', 0,
	1AH, 'ILLEGAL ATTRIBUTE IDENTIFIER', 0,
	1BH, 'ILLEGAL SEEK COMMAND', 0,
	1CH, 'MISSING EXTENSION', 0,
	1FH, 'CAN''T SEEK ON WRITE ONLY FILE', 0,
	20H, 'CAN''T DELETE OPEN FILE', 0,
	23H, 'SEEK PAST EOF', 0,
	0C9H, 'UNRECOGNIZED SWITCH', 0,
	0CAH, 'UNRECOGNIZED DELIMITER', 0,
	0CBH, 'INVALID SYNTAX', 0,
	0CCH, 'PREMATURE EOF', 0,
	0CEH, 'ILLEGAL DISKETTE LABEL', 0,
	0D0H, 'CHECKSUM ERROR', 0,
	0D1H, 'RELO FILE SEQUENCE ERROR', 0,
	0D2H, 'INSUFFICIENT MEMORY', 0,
	0D3H, 'RECORD TOO LONG', 0,
	0D4H, 'ILLEGAL RELO RECORD', 0,
	0D5H, 'FIXUP BOUNDS ERROR', 0,
	0D6H, 'ILLEGAL SUBMIT PARAMETER', 0,
	0D7H, 'ARGUMENT TOO LONG', 0,
	0D8H, 'TOO MANY PARAMETERS', 0,
	0D9H, 'OBJECT RECORD TOO SHORT', 0,
	0DAH, 'ILLEGAL RECORD FORMAT', 0,
	0DBH, 'PHASE ERROR', 0
	);

reporterror: procedure(errNum) public;
	declare errNum address;
	declare numberBuffer(3) byte, i address, status address;
 

	if errNum <> 0 then
	do;
		i = 0;
		do while i < size(msg);
			if errNum = msg(i) and msg(i + 1) <> 0 then
			do;
				i = i + 1;
				call write(0, .(' '), 1, .status);
				do while msg(i) <> 0;
					call write(0, .msg(i), 1, .status);
					i = i + 1;
				end;
				call write(0, .(0dh, 0ah), 2, .status);
				return;
			end;
			else
			do;
				do while msg(i) <> 0;
					i = i + 1;
				end;
				i = i + 1;
			end;
		end;
	call error(errNum);
	end;
end;
end;
?scanin.plm
scanIn: do;

declare digits(*) byte data('0123456789ABCDEF');

ScanInteger: procedure(ptrPtr) address public;
	declare ptrPtr address;
	declare ptr based ptrPtr address;
	declare (scanPtr, updatePtr, stopPtr) address;
	declare (i, radix, increment) byte;
	declare (nVal, oVal) address;
	declare c based scanPtr byte;

	scanPtr = ptr;
	do while c = ' ';
		scanPtr = scanPtr + 1;
	end;
	ptr = scanPtr;
	do while '0' <= c and c <= '9' or 'A' <= c and c <= 'F';
		scanPtr = scanPtr + 1;
	end;

	stopPtr = scanPtr;
	updatePtr = scanPtr + 1;
	if c = 'H' then
		radix = 16;
	else if c = 'O' or c = 'Q' then
		radix = 8;
	else
	do;
		updatePtr = scanPtr;
		stopPtr, scanPtr = scanPtr - 1;
		if c = 'B' then
			radix = 2;
		else
		do;
			radix = 10;
			if c <> 'D' then	/* include last increment */
				stopPtr = stopPtr + 1;
		end;
	end;
	scanPtr = ptr;
	nVal, oVal = 0;
	do while scanPtr < stopPtr;
		do i = 0 to 15;
			if c = digits(i) then
				increment = i;
		end;
		if increment >= radix then
			return 0;
		nVal = oVal * radix + increment;
		if nVal < oVal then
			return 0;
		oVal = nVal;
		scanPtr = scanPtr + 1;
	end;
	ptr = updatePtr;
	return nVal;
end;
end;
?seq.plm
SEQ: DO;
seq: procedure(s1, s2, cnt) byte public;
	declare (s1,s2) address, cnt byte;
	declare s1a based s1(1) byte;
	declare s2a based s2(1) byte;
	declare i byte;
	cnt = cnt - 1;
	do i = 0 to cnt;
		if s1a(i) <> s2a(i) then
			return 0;
	end;
	return 0ffh;
end;
end;
?serror.plm
SFileError: do;
declare boolean literally 'byte';

Write: procedure(conn, buff$p, count, status$p) external;
         declare conn address, buff$p address, count address, status$p address; end;

Exit: procedure external; end;

deblank: procedure(ptr) address external; declare ptr address; end;

WDelimit: procedure(ptr) address external; declare ptr address; end;

GetDisk: procedure(n) external; declare n byte; end;

ReportError: procedure(errNum) external; declare errNum address; end;

declare singleDrive boolean external;

SFileError: procedure(status, name$p) public;
	declare (status, name$p) address;
	declare lStatus address;

	if status <> 0 then
	do;
		if singleDrive then
			call GetDisk(0);
		name$p = Deblank(name$p);
		call Write(0, .(' '), 1, .lStatus);
		call Write(0, name$p, WDelimit(name$p) - name$p, .lStatus);
		call Write(0, .(','), 1, .lStatus);
		call ReportError(status);
		call Exit;
	end;
end;
end;
?setblk.plm
SETBLOCK: DO;

declare bitmap(1) byte external,
	currentBitmap byte external,
	mapChange byte external,
	lastBlock address external,
	lastSector byte external,
	lastTrack byte external,
	lastCounter address external,
	maskArray(1) byte external,
	diskType byte external;

setBlock: procedure(adr) public;
	declare adr address;
	declare (bit, byt) address;
	declare spt byte;

	if diskType then
		spt = 52;
	else
		spt = 26;

	bit = high(adr) * spt + low(adr) - 1;
	byt = shr(bit, 3);
x: /* force reload of byt */
	bitmap(byt) = bitmap(byt) or maskArray(low(bit) and 7);
end;
end;
?tabwrt.plm
TABWRITE: DO;
/* b1=01, b2=31, CODE(A7H) byte, DATA(DH) byte, STACK(6H) byte, MEMORY(0H) byte,*/

declare TAB	literally '9',
	CR	literally '0dh';

write: procedure (aft, buff$p, count, status) external;
    declare (aft, buff$p, count, status) address;
end write;

tabwrite: procedure(columnPtr, aft, bufferPtr, count, status) public;
	declare (columnPtr, aft, bufferPtr, count, status) address;
	declare (printChar, i, j) byte;
	declare column based columnPtr byte;
	declare ch based bufferPtr byte;

	do while count <> 0;
		i = ch = TAB and (7 - (column and 7));
		printChar = ch;
		bufferPtr = bufferPtr + 1;
		count = count - 1;
		if printChar = TAB then
			printChar = ' ';
		do j = 0 to i;
			if ch = CR then
				column = 0;
			if ch >= ' ' then
				column = column + 1;
			call write(aft, .printChar, 1, status);
		end;
	end;
end;
end;

?unpath.plm
UNPATH: DO;

declare devTab(*) byte data('F0F1F2F3F4F5TITO',
			     'VIVOI1O1TRHRR1R2',
			     'TPHPP1P2LPL1BBCICO');

unpath:	procedure(int, ext) public;
	declare (int, ext) address;
	declare i byte;
	declare intName based int (1) byte;
	declare extName based ext (1) byte;

	extName(0) = ':';
	extName(1) = devTab(intName(0) + intName(0));
	extName(2) = devTab(intName(0) + intName(0) + 1);
	extName(3) = ':';	
	ext = ext + 4;
	do i = 0 to 5;
		if (extName(0) := intName(i + 1)) <> 0 then
			ext = ext + 1; 
	end;
	if intName(7) <> 0 then
	do;
		extName(0) = '.';
		ext = ext + 1;
	end;
	do i = 0 to 2;
		if (extName(0) := intName(i + 7)) <> 0 then
			ext = ext + 1; 

	end;
	extName(0) = ' ';
end;
end;
?upcase.plm
UPPERCASE: DO;
uppercase: procedure(char) byte public;
	declare char byte;
	if char < 'a' then
		return char;
	if char > 'z' then
		return char;
	return char and 0dfh;
end;
end;
?wdlmt.plm
WDELIMIT: DO;
/* b1=01, b2=31, CODE(63H) byte, DATA(2H) byte, STACK(4H) byte, MEMORY(0H) byte,*/
wdelimit: procedure(ptr) address public;
	declare ptr address;
	declare ch based ptr byte;

	do while (ch = ':' or ch = '.' or ch = '*' or ch = '?' or
		  ('0' <= ch and ch <= '9') or ('A' <= ch and ch <= 'Z'));
		ptr = ptr + 1;
	end;
	return ptr;
end;
end;

?wpath.plm
WPATH: DO;

uppercase: procedure(sch) byte external; declare sch byte; end;

declare TRUE literally '0ffh',
	FALSE literally '0';

declare	devTab(*) byte data ('F0F1F2F3F4F5TITO',
			      'VIVOI1O1TRHRR1R2',
			      'TPHPP1P2LPL1BBCI',
			      'CO');

declare lastPathnameParsed(15) byte;

wpath: procedure(pathnamePtr, pn) byte public;
	declare (pathnamePtr, pn) address;
	declare (ptr, addr, devPtr) address,
		(lo, hi) byte at (.addr),
		devPair based devPtr address;
	declare	(nullName, pl, i) byte;
	declare path based pn(1) byte;
	declare sch based pathnamePtr byte;
	declare s based pathnamePtr(1) byte;
	declare tch based ptr byte;

	nonTerminator: procedure byte;
		return 'A' <= sch and sch <= 'Z' or
		   '0' <= sch and sch <= '9' or
		    sch = '?' or sch = '*' or
		   'a' <= sch and sch <= 'z';
	end;

	devPtr = .devTab;
	do i = 0 to 9;
		path(i) = 0;
	end;
	do while sch = ' ';
		pathnamePtr = pathnamePtr + 1;
	end;
	ptr = pathnamePtr;
	if sch = ':' then
	do;
		path(0) = TRUE;
		if s(3) <> ':' then
			return 4;
		pathnamePtr = pathnamePtr + 1;
		lo = uppercase(sch);
		pathnamePtr = pathnamePtr + 1;
		hi = uppercase(sch);
		pathnamePtr = pathnamePtr + 2;

		i = 0;
		do while i < last(devTab);
			if devPair = addr then
				path(0) = shr(i, 1);
			i = i + 2;
			devPtr = devPtr + 2;
		end;
		if path(0) = 255 then
			return 5;
	end;

	nullName = TRUE;
	i = 1;
	do while i < 7;
		if nonTerminator then
		do;
			path(i) = uppercase(sch);
			if sch = '*' then
				do while i < 7;
					path(i) = '*';
					i = i + 1;
				end;
			pathnamePtr = pathnamePtr + 1;
			nullName = FALSE;
		end;
		i = i + 1;
	end;
	if sch = '.' then
	do;
		pathnamePtr = pathnamePtr + 1;
		i = 7;
		do while i < 10;
			if nonTerminator then
			do;
				path(i) = uppercase(sch);
				if sch = '*' then
					do while i < 10;
						path(i) = '*';
						i = i + 1;
					end;
				pathnamePtr = pathnamePtr + 1;
			end;
			i = i + 1;
		end;	
	end;
	if path(0) <= 5 and nullName then
		return 17h;
	pl = 255;
	do while ptr < pathnamePtr;
		lastPathnameParsed(pl := pl + 1) = tch;
		ptr = ptr + 1;
	end;
	if lastPathnameParsed(pl) = '.' then
		return 1ch;
	lastPathnameParsed(pl + 1) = ' ';	
	if nonTerminator or sch = '.' or sch = ':' then
		return 4;
	return 0;
end;
end;

?wrtdir.plm

WRITEDIRECTORY: DO;

declare bitmap(512) byte external;
/* following are declared but not used */
declare	currentBitMap byte external,
	mapChange byte external,
	lastBlock address external,
	lastSector byte external,
	lastTrack byte external,
	lastCounter byte external,
	maskArray(1) byte external;

setblock: procedure(adr) external; declare adr address; end;

clearbuf: procedure(buf$ptr) external;
	declare buf$ptr address;
end;

absio: procedure(cmd, disk, block, buffer) external;
	declare (cmd, disk) byte, (block, buffer) address;
end;
moveascii: procedure(dst, src, cnt) external;
	declare (dst, src) address, cnt byte;
end;

declare diskType byte external;

declare	dirFile(*) byte data('ISIS', 0, 0, 'DIR'),
	mapFile(*) byte data('ISIS', 0, 0, 'MAP'),
	t0File(*) byte data('ISIS', 0, 0, 'T0', 0),
	binFile(*) byte data('ISIS', 0, 0, 'BIN'),
	labFile(*) byte data('ISIS', 0, 0, 'LAB');

writeDirectory: procedure(disk) public;
	declare	disk byte, i byte, jj address, dirBuf(64) address,
		direct(8) structure(empty byte, file(9) byte, attrib byte,
				    eof$count byte, blk address, hdrBlk address);
	declare countBitMapSectors byte, binHdrBlk address;

	currentBitmap = disk;
	if diskType then
	do;
		countBitMapSectors = 4;
		binHdrBlk = 206h;
	end;
	else
	do;
		countBitMapSectors = 2;
		binHdrBlk = 204h;
	end;
	do jj = 0 to last(bitmap);
		bitmap(jj) = 0;
	end;

	call clearbuf(.dirBuf);
	dirbuf(2) = 1;
	do i = 2 to 23;
		dirBuf(i + 1) = dirBuf(i) + 1;
	end;
	call absio(6, disk, 24, .dirBuf);
	call clearbuf(.dirBuf);
	dirbuf(2) = 26;
	if diskType then
	do;
		do i = 2 to 27;
			dirBuf(i + 1) = dirBuf(i) + 1;
		end;
		dirBuf(29) = 11Bh;
		do i = 2 to 26;
			dirBuf(i + 27 + 1) = dirbuf(i + 27) + 1;
		end;	
	end;
	call absio(6, disk, 25, .dirBuf);
	call clearbuf(.dirBuf);

	dirBuf(2) = 102h;
	do i = 2 to 25;
		dirBuf(i + 1) = dirBuf(i) + 1;
	end;
	call absio(6, disk, 101h, .dirBuf);
	call clearbuf(.dirBuf);

	dirBuf(2) = 202h;
	do i = 2 to countBitMapSectors;
		dirBuf(i + 1) = dirBuf(i) + 1; 
	end;
	call absio(6, disk, 201h, .dirBuf);
	call clearbuf(.dirBuf);

	call absio(6, disk, binHdrBlk, .dirBuf);
	call clearBuf(.direct);

	call moveAscii(.direct(0).file, .dirFile, 9);
	direct(0).blk = 25;
	direct(0).hdrBlk = 101h;
	direct(0).empty = 0;
	direct(0).attrib = 1;
	direct(0).eof$count = 80h;

	call moveAscii(.direct(1).file, .mapFile, 9);
	direct(1).blk = countBitMapSectors;
	direct(1).hdrBlk = 201h;
	direct(1).empty = 0;
	direct(1).attrib = 1;
	direct(1).eof$count = 80h;

	call moveAscii(.direct(2).file, .t0File, 9);
	direct(2).blk = 23;
	direct(2).hdrBlk = 18h;
	direct(2).empty = 0;
	direct(2).attrib = 1;
	direct(2).eof$count = 80h;

	call moveAscii(.direct(3).file, .labFile, 9);
	if diskType then
		direct(3).blk = 53;
	else
		direct(3).blk = 1;
	direct(3).hdrBlk = 19h;
	direct(3).empty = 0;
	direct(3).attrib = 1;
	direct(3).eof$count = 80h;

	call moveAscii(.direct(4).file, .binFile, 9);
	direct(4).blk = 0;
	direct(4).hdrBlk = binHdrBlk;
	direct(4).empty = 0;
	direct(4).attrib = 3;
	direct(4).eof$count = 80h;

	do i = 5 to 7;
		direct(i).empty = 7fh;
	end;
	call absio(6, disk, 102h, .direct);	
	call clearBuf(.direct);
	do i = 0 to 7;
		direct(i).empty = 7fh;
	end;
	do i = 2 to 25;
		call absio(6, disk, 101h + i, .direct);
	end;
	call setblock(101h);
	do jj = 102h to 11ah;
		call setblock(jj);
	end;
	call setblock(201h);
	do jj = 202h to 202h +  countBitMapSectors - 1;
		call setblock(jj);
	end;
	call setblock(18h);
	do jj = 1 to 17h;
		call setblock(jj);
	end;
	call setblock(19h);
	if diskType then
	do;
		do jj = 1ah to 34h;
			call setblock(jj);
		end;
		do jj = 11bh to 134h;
			call setblock(jj);
		end;
	end;
	else
		call setblock(1ah);
	call setblock(binHdrBlk);
	call absio(6, disk, 202h, .bitmap);
	call absio(6, disk, 203h, .bitmap +  80h);
	if diskType then
	do;
		call absio(6, disk, 204h, .bitmap + 100h);
		call absio(6, disk, 205h, .bitmap + 180h);
	end;
end;
end;
cusp4/makefile
ROOT = ../../..
TARGETS = cusp4.lib
unexport ISIS_F1

include $(ROOT)/tools/isis.mk

REF = $(call ipath,toolbox,1.0)

OBJS = alloc.obj direct.obj absio.obj clrbuf.obj chklab.obj d.obj dblank.obj\
       diskio.obj dlimit.obj dmeq.obj ferror.obj fmttrk.obj forupp.obj\
       getdsk.obj getlab.obj mvasci.obj monitr.obj meq.obj numout.obj path.obj\
       popula.obj reperr.obj scanin.obj serror.obj seq.obj setblk.obj\
       tabwrt.obj upcase.obj unpath.obj wrtdir.obj wdlmt.obj wpath.obj

PLMFLAGS = code
PLM80 = 3.1
all::
	$(MAKE) $(TARGETS)


cusp4.lib: $(OBJS)
	$(call lib,$@,$^)

cusp5/cusp5_all.src
?absio.plm
ABSIO: DO;
DECLARE DCB$T LITERALLY 'STRUCTURE (iocw BYTE, ioins BYTE, nsec BYTE, tadr BYTE, sadr BYTE, buf ADDRESS)';

diskio: procedure(disk, dcb$ptr) external; declare (disk, dcb$ptr) address; end;

absio: procedure(cmd, disk, block, buffer) public;
	declare (cmd, disk) byte, (block, buffer) address;
	declare dcb DCB$T;

	dcb.iocw = 80H;
	dcb.ioins = cmd;
	dcb.nsec = 1;
	dcb.tadr = high(block);
	dcb.sadr = low(block);
	dcb.buf = buffer;
	call diskio(disk, .dcb);
end;
end;
?alloc.plm
ALLOC: DO;
DECLARE DCB$T LITERALLY 'STRUCTURE (iocw BYTE, ioins BYTE, nsec BYTE, tadr BYTE, sadr BYTE, buf ADDRESS)';

declare
	bitmap(512) byte public,
	currentBitmap byte public initial(0ffh),
	mapChange byte public initial(0),
	lastBlock address public,
	(lastSector, lastTrack) byte public at (.lastBlock),
	lastCounter address public,
	mapDcb DCB$T initial(80H, 0, 4, 2, 2, 0),	/* I suspect this should be public */
	maskArray(*) byte public data(80H, 40H, 20H, 10H, 8, 4, 2, 1);
end;
?chklab.plm
CHECKLABEL: DO;

write: procedure (conn, buff$p, count, status$p) external;
    declare (conn, buff$p, count, status$p) address;
end write;

getDisk: procedure(arg1b) external;
	declare arg1b byte;
end;

getLabel: procedure(lab, device) external;
	declare lab address, device byte;
end;

seq: procedure(s1, s2, cnt) byte external;
	declare (s1,s2) address, cnt byte;
end;

CHECKLABEL: procedure(arg1w, arg2b, arg3b) public;
	declare arg1w address, (arg2b, arg3b) byte;
	declare status address, lab(11) byte;

	do while (1);
		call GETDISK(arg3b);
		if arg2b > 5 then
			return;
		call GETLABEL(.lab, arg2b);
		if SEQ(arg1w, .lab, 9) then
			return;
		lab(0) = arg2b + '0';
		call WRITE(0, .('WRONG DISKETTE IN DRIVE '), 24, .status);
		call WRITE(0, .lab, 1, .status);
		call WRITE(0, .(0DH, 0AH), 2, .status);
	end;
end;

end;
?clrbuf.plm
CLEARBUF: DO;

clearbuf: procedure(buf$ptr) public;
	declare buf$ptr address, i byte,
		buf based buf$ptr (1) byte;

	do i = 0 to 127;
		buf(i) = 0;
	end;
end;
end;
?cpyrit.plm
COPYRIGHT: DO;
end;
?d.plm
D: DO;
sFileError: procedure(status, filename) external;
	declare (status, filename) address;
end;
open: procedure (conn$p, path$p, access, echo, status$p) external;
    declare (conn$p, path$p, access, echo, status$p) address;
end open;

read: procedure (conn, buff$p, count, actual$p, status$p) external;
    declare (conn, buff$p, count, actual$p, status$p) address;
end read;

write: procedure (conn, buff$p, count, status$p) external;
    declare (conn, buff$p, count, status$p) address;
end write;

close: procedure (conn, status$p) external;
    declare (conn, status$p) address;
end close;

delimit: procedure(ptr) address external;
	declare ptr address, ch based ptr byte;
end;

NumOut: procedure(value, base, lc, bufAdr, width) external;
	declare (value, bufAdr) address, (base, lc, width) byte;
end;

meq: procedure(mPtr, fptr) byte external;
	declare (mPtr, fptr) address;
end;

unpath:	procedure(int, ext) external;
	declare (int, ext) address;
end;

deblank: procedure(ptr) address external;
	declare ptr address;
end;

spath: procedure (path$p, info$p, status$p) external;
    declare (path$p, info$p, status$p) address;
end spath;

declare direct structure(status byte, name(6) byte, ext(3) byte, attrib byte, eof$count byte,
			 blk address, hdrBlk address) external;
declare directIno address external;

Population: procedure(bufferLoc, len) address external;
	declare (bufferLoc, len) address;
end;

declare singleDrive byte external;

declare isisDrive(*) byte initial(':FX:', 0),
	isisMapFile(*) byte initial(':F :ISIS.MAP '),
	isisLabFile(*) byte initial(':F :ISIS.LAB '),
	isisDirFile(*) byte initial(':F :ISIS.DIR ');

declare	crlf(2) byte data(0DH, 0AH),
	blksUsedMsg(*) byte data('XXXX/YYYY BLOCKS USED', 0DH, 0AH),
	dirOfMsg(*) byte data('DIRECTORY OF '),
	dirHeader(*) byte data('NAME  .EXT BLKS   LENGTH ATTR', 0DH, 0AH);

D: procedure(drive, conn, arg3b, arg4b, arg5w) public;
	declare (drive, conn, arg3b, arg4b) byte, arg5w address;
	declare (dconn, status, actual, unused) address,
		(sectUsed, highFileSize, lowFileSize) address,
		totalSectUsed address,
		mapBuf(512) byte,
		strBuf(15) byte,
		path(15) byte,
		(i, j) byte,
		mapBufSize address,
		driveType byte;

	bigAdd: procedure(n);
		declare n address;
		lowFileSize = lowFileSize + n;
		if lowFileSize > 9999 then
		do;
			lowFileSize = lowFileSize - 10000;
			highFileSize = highFileSize + 1;
		end;
	end;	

	isisDrive(2) = drive + '0';

	call Spath(.isisDrive, .mapBuf, .status);
	if mapBuf(11) = 1 then	/* driveType */
		driveType = 0ffh;	/* DD */
	else
		driveType = 0;	/* SD */
		
	do i = 0 to last(mapBuf);
		mapBuf(i) = 0;
	end;
	
	totalSectUsed = 0;
	isisMapFile(2), isisLabFile(2), isisDirFile(2) = drive + '0';
	call Open(.dconn, .isisLabFile, 1, 0, .status);
	call sFileError(status, .isisLabFile);
	strBuf(0) = drive;
	call Read(dconn, .strBuf(1), 9, .actual, .status);
	call Write(conn, .dirOfMsg, 13, .status);
	call Unpath(.strBuf, .path);
	i = Delimit(.path) - .path;
	call Write(conn, .path, i, .status);
	call Write(conn, .crlf, 2, .status);
	call close(dconn, .status);
	if (not arg3b) then
		call Write(conn, .dirHeader, size(dirHeader), .status);
	call Open(.dconn, .isisDirFile, 1, 0, .status);
	actual = size(direct);
	direct.status = actual;
	do while actual = size(direct) and direct.status <> 07fh;
		call read(dconn, .direct, size(direct), .actual, .status);
		if actual = size(direct) and (not direct.status) and
		   ((direct.attrib and 1) = 0 or arg4b) and
		   meq(arg5w, .direct) then
		   do;
			do i = 0 to 8;
				if direct.name(i) = 0 then
					direct.name(i) = ' ';
			end;
			i = 9;
			if arg3b then	
				do while direct.name(i - 1) = ' ';
					i = i - 1;
				end;
			if not arg3b or i > 6 then
				j = 6;
			else	
				j = i;
			call Write(conn, .direct.name, j, .status);
			if arg3b then
			do;
				if i > 6 then
				do;
					call Write(conn, .('.'), 1, .status);
					call Write(conn, .direct.ext, i - 6, .status);
				end;
			end;
			else
			do;
				if direct.ext(0) <> ' ' then
					call Write(conn, .('.'), 1, .status);
				call Write(conn, .direct.ext, 3, .status);
				if direct.ext(0) = ' ' then
					call Write(conn, .(' '), 1, .status);
				sectUsed = direct.blk;
				if sectUsed > 0 then
					sectUsed = sectUsed + (sectUsed + 61) / 62;
				else
					sectUsed = 1;
				totalSectUsed = totalSectUsed + sectUsed;
				call NumOut(sectUsed, 10, ' ', .strBuf, 5);
				call Write(conn, .strBuf, 5, .status);
				sectUsed = direct.blk;
				lowFileSize, highFileSize = 0;
				if sectUsed > 0 then
				do;
					sectUsed = sectUsed - 1;
					call bigAdd(direct.eof$count);
					do while sectUsed > 0;
						sectUsed = sectUsed - 1;
						call bigAdd(128);
					end;
				end;

				if highFileSize <> 0 then
				do;
					call NumOut(highFileSize, 10, ' ', .strBuf, 5);
					call NumOut(lowFileSize, 10, '0', .strBuf(5), 4);
				end;
				else
					call NumOut(lowFileSize, 10, ' ', .strBuf, 9);
				call Write(conn, .strBuf, 9, .status);
				if direct.attrib <> 0 then
				do;
					do i = 0 to 4;
						strbuf(i) = ' ';
					end;
					if (direct.attrib and 4) <> 0 then
						strbuf(1) = 'W';
					if (direct.attrib and 2) <> 0 then
						strbuf(2) = 'S';
					if (direct.attrib and 1) <> 0 then
						strbuf(3) = 'I';
					if (direct.attrib and 80h) <> 0 then
						strbuf(4) = 'F';
					call write(conn, .strbuf, 5, .status);
				end;
			end;
			call Write(conn, .crlf, 2, .status);
		end;	
	end;
	call Close(dconn, .status);
	if not arg3b then
	do;
		call NumOut(totalSectUsed, 10, ' ', .strBuf, 15);
		call Write(conn, .strBuf, 15, .status);
		call Write(conn, .crlf, 2, .status);
	end;
	call Open(.dconn, .isisMapFile, 1, 0, .status);	
	if driveType then
		mapBufSize = 512;
	else
		mapBufSize = 256;
	call Read(dconn, .mapBuf, mapBufSize, .actual, .status);
	call NumOut(Population(.mapBuf, mapBufSize), 10, 0, .blksUsedMsg, 4);
	if driveType then
		call NumOut(4004, 10, 0, .blksUsedMsg + 5, 4);
	else
		call NumOut(2002, 10, 0, .blksUsedMsg + 5, 4);
	call Write(conn, .blksUsedMsg, length(blksUsedMsg), .status);
	call Close(conn, .status);
	return;
end;
end;
?dblank.plm
DEBLANK: DO;
deblank: procedure(str) address public;
	declare str address;
	declare c based str byte;

	do while (c = ' ');
		str = str + 1;
	end;
	return str;
end;

end;
?direct.plm
DIRECT: DO;
declare	DIRECT(16) byte public,
	DIRECTINO byte public;
end;
?diskio.plm
DISKIO: DO;
isis: procedure(syscmd, param$p) external; declare syscmd byte, param$p address; end;

diskio: procedure(disk, dcb$p) public;
	declare (disk, dcb$p) address; 
	declare param structure(disk address, dcb$p address);
	
	param.disk = disk;
	param.dcb$p = dcb$p;
	call isis(44H, .param);
end;
end;
?dlimit.plm
DELIMIT: DO;
delimit: procedure(ptr) address public;
	declare ptr address, ch based ptr byte;

	do while ch = ':' or ch = '.' or
		 ('0' <= ch and ch <= '9') or
		 ('A' <= ch and ch <= 'Z');
		ptr = ptr + 1;
	end;
	return ptr;
end;
end;
?dmeq.plm
/* b1=01, b2=31, CODE(A3H) byte, DATA(12H) byte, STACK(8H) byte, MEMORY(0H) byte,*/
DMEQ: DO;
declare TRUE	literally '0FFH',
	FALSE	literally '0';

read: procedure (conn, buff$p, count, actual$p, status$p) external;
    declare (conn, buff$p, count, actual$p, status$p) address;
end read;

seek: procedure (conn, mode, block$p, byte$p, status$p) external;
    declare (conn, mode, block$p, byte$p, status$p) address;
end seek;

meq: procedure(A, B) byte external ; declare (A,B) address; end;

dmeq: procedure (dir$aftn, search$arg, initial$i$no, dir$entry) byte public;
    declare (dir$aftn, search$arg, initial$i$no, dir$entry) address;
    declare (byteNo, blockNo, actual, status) address;
    declare (pastDir, searching) byte;
    declare dirFlag based dir$entry byte;

	blockNo = 0;
	byteNo = initial$i$no * 16;
	call seek(dir$aftn, 2, .blockNo, .byteNo, .status);

	searching = TRUE;
	do while searching;
		call read(dir$aftn, dir$entry, 16, .actual, .status);
		searching = not meq(search$arg, dir$entry);
		initial$i$no = initial$i$no + 1;
		if dirFlag = 7Fh or actual = 0 then
		do;
			initial$i$no = 201;
			searching = FALSE;
		end;
	end;
		
	return initial$i$no;
end;
end;
?ferror.plm
FILEERROR: DO;

write: procedure (conn, buff$p, count, actual$p) external;
    declare (conn, buff$p, count, actual$p) address;
end write;

exit: procedure external; end exit;

deblank: procedure(str) address external; declare str address; end;
WDelimit: procedure(ptr) address external; declare ptr address; end;
reporterror: procedure(status) external; declare status address; end;

fileerror: procedure(status, ptr, callExit) public;
	declare (status, ptr) address, callExit byte;
	declare actual address;

	if status <> 0 then
	do;
		ptr = deblank(ptr);
		call write(0, .(' '), 1, .actual);
		call write(0, ptr, WDelimit(ptr) - ptr, .actual);
		call write(0, .(','), 1, .actual);
		call reporterror(status);
		if callExit then
			call exit;
	end;
end;
end;
?fmttrk.plm
FORMATTRACK: DO;

diskio: procedure(disk, dcb$p) external; declare disk address, dcb$p address; end;
declare diskType byte external;


formatTrack: procedure(disk,sTrack,eTrack,interleave) public;
	declare (disk,sTrack,eTrack,interleave) byte;
	declare (i,j,k) byte, trackBuf(104) byte,
	dcb structure(iocw byte, ioins byte, nsec byte, tadr byte, sadr byte, buf address),
	spt byte, tbufLast byte;

	if diskType then
	do;
		spt = 52;
		tBufLast = 103;		
	end;
	else
	do;
		spt = 26;
		tBufLast = 51;
	end;

	dcb.iocw = 0c0h;
	dcb.ioins = 2;
	
	do i = 1 to tBufLast by 2;
		trackBuf(i) = 0c7h;	
	end;
	j = 0;
	do k = sTrack to eTrack;
		do i = 0 to tbufLast by 2;
			trackBuf(i) = 0;
		end;
		do i = 1 to spt;
			j = (j + interleave) mod spt;
			do while trackBuf(j + j) <> 0;
				j = (j + 1) mod spt;
			end;
			trackBuf(j + j) = i;
		end;
		dcb.tadr = k;
		dcb.buf = .trackBuf;
		call diskio(disk, .dcb);
	end;
end;
end;
?forupp.plm
FORCEUPPER: DO;
/* b1=01, b2=10, CODE(25H) byte, DATA(2H) byte, STACK(2H) byte, MEMORY(0H) byte,*/
declare CR literally '0DH';

uppercase: procedure(ch) byte external; declare ch byte; end;

forceupper: procedure(bufferPtr) public;
	declare bufferPtr address, ch based bufferPtr byte;

	do while ch <> CR;
		ch = uppercase(ch);
		bufferPtr = bufferPtr + 1;
	end;
end;
end;
?getdsk.plm
GetDisk: do;

Write: procedure(conn, buff$p, count, status$p) external;
         declare conn address, buff$p address, count address, status$p address; end;

Read: procedure(conn, buff$p, count, actual$p, status$p) external;
        declare conn address, buff$p address, count address, actual$p address, status$p address; end;


declare source(3) structure(name(6) byte) data('SYSTEM', 'SOURCE', 'OUTPUT');

GetDisk: procedure(n) public;
	declare n byte;
	declare buf(128) byte, status address, junk address, actual address;

	call Write(0, .('LOAD '), 5, .status);
	call Write(0, .source(n), 6, .status);
	call Write(0, .(' DISKETTE, THEN TYPE (CR)'), 25, .status);
	call Read(1, .buf, 128, .actual, .status);
end;
end;
?getlab.plm
GETLABEL: DO;

read: procedure (conn, buff$p, count, actual$p, status$p) external;
    declare (conn, buff$p, count, actual$p, status$p) address;
end read;

open: procedure (conn$p, path$p, access, echo, status$p) external;
    declare (conn$p, path$p, access, echo, status$p) address;
end open;

close: procedure (conn, status$p) external;
    declare (conn, status$p) address;
end close;

SFileError: procedure(status, name$p) external;
	declare (status, name$p) address;
end;

declare isisLabFile(*) byte initial(':FX:ISIS.LAB', 0);

GetLabel: procedure(labBuf, drive) public;
	declare labBuf address, drive byte;
	declare (status, actual, conn) address;

	if drive <= 5 then
	do;
		isisLabFile(2) = drive + '0';
		call Open(.conn, .isisLabFile, 1, 0, .status);
		call SFileError(status, .isisLabFile);
		call Read(conn, labBuf, 9, .actual, .status);
		call SFileError(status, .isisLabFile);
		call Close(conn, .status);
		call SFileError(status, .isisLabFile);
	end;
end;
end;
?meq.plm
/* b1=01, b2=31, CODE(76H) byte, DATA(5H) byte, STACK(2H) byte, MEMORY(0H) byte,*/
MEQ: DO;

meq: procedure(mPtr, fptr) byte public;
	declare (mPtr, fptr) address;
	declare m based mPtr (10) byte;
	declare f based fptr (10) byte;
	declare i byte;

	do i = 0 to 9;
		if m(i) = '?' then
		do;
			if f(i) = 0 then
				return 0;
		end;
		else if m(i) <> '*' then
		do;
			if m(i) <> f(i) then
				return 0;
		end;
	end;
	return 0ffh;
end;
end;

?monitr.plm
MONITOR: DO;
MONITOR: procedure public;
	declare sp address, wrd based sp  address;

	sp = STACKPTR;
	wrd = 8;	
	STACKPTR = STACKPTR - 2;
	sp = STACKPTR;
	wrd = 0;
end;
end;
?mvasci.plm
MOVEASCII: DO;
moveascii: procedure(dst, src, cnt) public;
	declare (dst, src) address, cnt byte, i byte;
	declare dch based dst (1) byte, sch based src (1) byte;

	do i = 0 to cnt - 1;
		dch(i) = sch(i);
	end;
end;
end;
?numout.plm
NUMOUT: DO;

declare digits(*) byte data('0123456789ABCDEF');

numout: procedure(val, base, lc, bufAdr, width) public;
	declare (val, bufAdr) address, (base, lc, width) byte; 
	declare i byte;
	declare buf based bufAdr (1) byte;

	do i = 1 to width;
		buf(width - i) = digits(val mod base);
		val = val / base;	
	end;

	i = 0;
	do while buf(i) = '0' and i < width - 1;
		buf(i) = lc;
		i = i + 1;
	end;
end;
end;
?path.plm
PATH: DO;
moveascii: procedure(dst, src, cnt) external;
	declare (dst, src) address, cnt byte;
end;

Spath: procedure(filename, info$p, status$p) external;
	declare (filename, info$p, status$p) address;
end;

PATH: procedure(filename, pn) byte public;
	declare (filename, pn) address;
	declare info(12) byte, status byte;

	call Spath(filename, .info, .status);	/* bug? status only a byte */
	call MoveAscii(pn, .info, 10);
	return status;
end;
end;
?popula.plm
POPULATION: DO;

declare bitCnt(*) byte data(0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4);


population: procedure(bufferLoc, length) address public;
	declare (bufferLoc, length) address;
	declare total address, (lowNibble, highNibble) byte,
		(i, lastByte) address;
	declare buffer based bufferLoc (1) byte;

	total = 0;
	lastByte = length - 1;
	do i = 0 to lastByte;
		lowNibble = buffer(i) and 0fh;		
		highNibble = ror(buffer(i), 4) and 0fh;
		total = total + bitCnt(lowNibble) + bitCnt(highNibble);
	end;
	return total;
end;
end;
?reperr.plm
REPORTERROR: DO;

error: procedure(errNum) external; declare errNum address; end;

write: procedure(aftn, buf$ptr, len, status$ptr) external;
   declare (aftn, buf$ptr, len, status$ptr) address;
end write;

numout: procedure(val, base, lead, buf$ptr, len) external;
	declare (val, buf$ptr) address, (base, lead, len) byte; 
end numout;

declare msg(*) byte DATA(0, 0,
	2, 'ILLEGAL AFTN ARGUMENT', 0,
	4, 'INCORRECTLY SPECIFIED FILE', 0,
	5, 'UNRECOGNIZED DEVICE NAME', 0,
	6, 'ATTEMPT TO WRITE TO INPUT DEVICE', 0,
	8, 'ATTEMPT TO READ FROM OUTPUT DEVICE', 0,
	9, 'DISK DIRECTORY FULL', 0,
	0AH, 'NOT ON SAME DISK', 0,
	0BH, 'FILE ALREADY EXISTS', 0,
	0CH, 'FILE IS ALREADY OPEN', 0,
	0DH, 'NO SUCH FILE', 0,
	0EH, 'WRITE PROTECTED', 0,
	11H, 'NOT A DISK FILE', 0,
	12H, 'ILLEGAL ISIS COMMAND', 0,
	13H, 'ATTEMPTED SEEK ON NON-DISK FILE', 0,
	14H, 'ATTEMPTED BACK SEEK TOO FAR', 0,
	15H, 'CAN''T RESCAN', 0,
	16H, 'ILLEGAL ACCESS MODE TO OPEN', 0,
	17H, 'MISSING FILENAME', 0,
	19H, 'ILLEGAL ECHO FILE', 0,
	1AH, 'ILLEGAL ATTRIBUTE IDENTIFIER', 0,
	1BH, 'ILLEGAL SEEK COMMAND', 0,
	1CH, 'MISSING EXTENSION', 0,
	1FH, 'CAN''T SEEK ON WRITE ONLY FILE', 0,
	20H, 'CAN''T DELETE OPEN FILE', 0,
	23H, 'SEEK PAST EOF', 0,
	0C9H, 'UNRECOGNIZED SWITCH', 0,
	0CAH, 'UNRECOGNIZED DELIMITER', 0,
	0CBH, 'INVALID SYNTAX', 0,
	0CCH, 'PREMATURE EOF', 0,
	0CEH, 'ILLEGAL DISKETTE LABEL', 0,
	0D0H, 'CHECKSUM ERROR', 0,
	0D1H, 'RELO FILE SEQUENCE ERROR', 0,
	0D2H, 'INSUFFICIENT MEMORY', 0,
	0D3H, 'RECORD TOO LONG', 0,
	0D4H, 'ILLEGAL RELO RECORD', 0,
	0D5H, 'FIXUP BOUNDS ERROR', 0,
	0D6H, 'ILLEGAL SUBMIT PARAMETER', 0,
	0D7H, 'ARGUMENT TOO LONG', 0,
	0D8H, 'TOO MANY PARAMETERS', 0,
	0D9H, 'OBJECT RECORD TOO SHORT', 0,
	0DAH, 'ILLEGAL RECORD FORMAT', 0,
	0DBH, 'PHASE ERROR', 0
	);

reporterror: procedure(errNum) public;
	declare errNum address;
	declare numberBuffer(3) byte, i address, status address;
 

	if errNum <> 0 then
	do;
		i = 0;
		do while i < size(msg);
			if errNum = msg(i) and msg(i + 1) <> 0 then
			do;
				i = i + 1;
				call write(0, .(' '), 1, .status);
				do while msg(i) <> 0;
					call write(0, .msg(i), 1, .status);
					i = i + 1;
				end;
				call write(0, .(0dh, 0ah), 2, .status);
				return;
			end;
			else
			do;
				do while msg(i) <> 0;
					i = i + 1;
				end;
				i = i + 1;
			end;
		end;
	call error(errNum);
	end;
end;
end;
?scanin.plm
scanIn: do;

declare digits(*) byte data('0123456789ABCDEF');

ScanInteger: procedure(ptrPtr) address public;
	declare ptrPtr address;
	declare ptr based ptrPtr address;
	declare (scanPtr, updatePtr, stopPtr) address;
	declare (i, radix, increment) byte;
	declare (nVal, oVal) address;
	declare c based scanPtr byte;

	scanPtr = ptr;
	do while c = ' ';
		scanPtr = scanPtr + 1;
	end;
	ptr = scanPtr;
	do while '0' <= c and c <= '9' or 'A' <= c and c <= 'F';
		scanPtr = scanPtr + 1;
	end;

	stopPtr = scanPtr;
	updatePtr = scanPtr + 1;
	if c = 'H' then
		radix = 16;
	else if c = 'O' or c = 'Q' then
		radix = 8;
	else
	do;
		updatePtr = scanPtr;
		stopPtr, scanPtr = scanPtr - 1;
		if c = 'B' then
			radix = 2;
		else
		do;
			radix = 10;
			if c <> 'D' then	/* include last increment */
				stopPtr = stopPtr + 1;
		end;
	end;
	scanPtr = ptr;
	nVal, oVal = 0;
	do while scanPtr < stopPtr;
		do i = 0 to 15;
			if c = digits(i) then
				increment = i;
		end;
		if increment >= radix then
			return 0;
		nVal = oVal * radix + increment;
		if nVal < oVal then
			return 0;
		oVal = nVal;
		scanPtr = scanPtr + 1;
	end;
	ptr = updatePtr;
	return nVal;
end;
end;
?seq.plm
SEQ: DO;
seq: procedure(s1, s2, cnt) byte public;
	declare (s1,s2) address, cnt byte;
	declare s1a based s1(1) byte;
	declare s2a based s2(1) byte;
	declare i byte;
	cnt = cnt - 1;
	do i = 0 to cnt;
		if s1a(i) <> s2a(i) then
			return 0;
	end;
	return 0ffh;
end;
end;
?serror.plm
SFileError: do;
declare boolean literally 'byte';

Write: procedure(conn, buff$p, count, status$p) external;
         declare conn address, buff$p address, count address, status$p address; end;

Exit: procedure external; end;

deblank: procedure(ptr) address external; declare ptr address; end;

WDelimit: procedure(ptr) address external; declare ptr address; end;

GetDisk: procedure(n) external; declare n byte; end;

ReportError: procedure(errNum) external; declare errNum address; end;

declare singleDrive boolean external;

SFileError: procedure(status, name$p) public;
	declare (status, name$p) address;
	declare lStatus address;

	if status <> 0 then
	do;
		if singleDrive then
			call GetDisk(0);
		name$p = Deblank(name$p);
		call Write(0, .(' '), 1, .lStatus);
		call Write(0, name$p, WDelimit(name$p) - name$p, .lStatus);
		call Write(0, .(','), 1, .lStatus);
		call ReportError(status);
		call Exit;
	end;
end;
end;
?setblk.plm
SETBLOCK: DO;

declare bitmap(1) byte external,
	currentBitmap byte external,
	mapChange byte external,
	lastBlock address external,
	lastSector byte external,
	lastTrack byte external,
	lastCounter address external,
	maskArray(1) byte external,
	diskType byte external;

setBlock: procedure(adr) public;
	declare adr address;
	declare (bit, byt) address;
	declare spt byte;

	if diskType then
		spt = 52;
	else
		spt = 26;

	bit = high(adr) * spt + low(adr) - 1;
	byt = shr(bit, 3);
x: /* force reload of byt */
	bitmap(byt) = bitmap(byt) or maskArray(low(bit) and 7);
end;
end;
?tabwrt.plm
TABWRITE: DO;
/* b1=01, b2=31, CODE(A7H) byte, DATA(DH) byte, STACK(6H) byte, MEMORY(0H) byte,*/

declare TAB	literally '9',
	CR	literally '0dh';

write: procedure (aft, buff$p, count, status) external;
    declare (aft, buff$p, count, status) address;
end write;

tabwrite: procedure(columnPtr, aft, bufferPtr, count, status) public;
	declare (columnPtr, aft, bufferPtr, count, status) address;
	declare (printChar, i, j) byte;
	declare column based columnPtr byte;
	declare ch based bufferPtr byte;

	do while count <> 0;
		i = ch = TAB and (7 - (column and 7));
		printChar = ch;
		bufferPtr = bufferPtr + 1;
		count = count - 1;
		if printChar = TAB then
			printChar = ' ';
		do j = 0 to i;
			if ch = CR then
				column = 0;
			if ch >= ' ' then
				column = column + 1;
			call write(aft, .printChar, 1, status);
		end;
	end;
end;
end;

?unpath.plm
UNPATH: DO;

declare devTab(*) byte data('F0F1F2F3F4F5TITO',
			     'VIVOI1O1TRHRR1R2',
			     'TPHPP1P2LPL1BBCICO');

unpath:	procedure(int, ext) public;
	declare (int, ext) address;
	declare i byte;
	declare intName based int (1) byte;
	declare extName based ext (1) byte;

	extName(0) = ':';
	extName(1) = devTab(intName(0) + intName(0));
	extName(2) = devTab(intName(0) + intName(0) + 1);
	extName(3) = ':';	
	ext = ext + 4;
	do i = 0 to 5;
		if (extName(0) := intName(i + 1)) <> 0 then
			ext = ext + 1; 
	end;
	if intName(7) <> 0 then
	do;
		extName(0) = '.';
		ext = ext + 1;
	end;
	do i = 0 to 2;
		if (extName(0) := intName(i + 7)) <> 0 then
			ext = ext + 1; 

	end;
	extName(0) = ' ';
end;
end;
?upcase.plm
UPPERCASE: DO;
uppercase: procedure(char) byte public;
	declare char byte;
	if char < 'a' then
		return char;
	if char > 'z' then
		return char;
	return char and 0dfh;
end;
end;
?wdlmt.plm
WDELIMIT: DO;
/* b1=01, b2=31, CODE(63H) byte, DATA(2H) byte, STACK(4H) byte, MEMORY(0H) byte,*/
wdelimit: procedure(ptr) address public;
	declare ptr address;
	declare ch based ptr byte;

	do while (ch = ':' or ch = '.' or ch = '*' or ch = '?' or
		  ('0' <= ch and ch <= '9') or ('A' <= ch and ch <= 'Z'));
		ptr = ptr + 1;
	end;
	return ptr;
end;
end;

?wpath.plm
WPATH: DO;

uppercase: procedure(sch) byte external; declare sch byte; end;

declare TRUE literally '0ffh',
	FALSE literally '0';

declare	devTab(*) byte data ('F0F1F2F3F4F5TITO',
			      'VIVOI1O1TRHRR1R2',
			      'TPHPP1P2LPL1BBCI',
			      'CO');

declare lastPathnameParsed(15) byte;

wpath: procedure(pathnamePtr, pn) byte public;
	declare (pathnamePtr, pn) address;
	declare (ptr, addr, devPtr) address,
		(lo, hi) byte at (.addr),
		devPair based devPtr address;
	declare	(nullName, pl, i) byte;
	declare path based pn(1) byte;
	declare sch based pathnamePtr byte;
	declare s based pathnamePtr(1) byte;
	declare tch based ptr byte;

	nonTerminator: procedure byte;
		return 'A' <= sch and sch <= 'Z' or
		   '0' <= sch and sch <= '9' or
		    sch = '?' or sch = '*' or
		   'a' <= sch and sch <= 'z';
	end;

	devPtr = .devTab;
	do i = 0 to 9;
		path(i) = 0;
	end;
	do while sch = ' ';
		pathnamePtr = pathnamePtr + 1;
	end;
	ptr = pathnamePtr;
	if sch = ':' then
	do;
		path(0) = TRUE;
		if s(3) <> ':' then
			return 4;
		pathnamePtr = pathnamePtr + 1;
		lo = uppercase(sch);
		pathnamePtr = pathnamePtr + 1;
		hi = uppercase(sch);
		pathnamePtr = pathnamePtr + 2;

		i = 0;
		do while i < last(devTab);
			if devPair = addr then
				path(0) = shr(i, 1);
			i = i + 2;
			devPtr = devPtr + 2;
		end;
		if path(0) = 255 then
			return 5;
	end;

	nullName = TRUE;
	i = 1;
	do while i < 7;
		if nonTerminator then
		do;
			path(i) = uppercase(sch);
			if sch = '*' then
				do while i < 7;
					path(i) = '*';
					i = i + 1;
				end;
			pathnamePtr = pathnamePtr + 1;
			nullName = FALSE;
		end;
		i = i + 1;
	end;
	if sch = '.' then
	do;
		pathnamePtr = pathnamePtr + 1;
		i = 7;
		do while i < 10;
			if nonTerminator then
			do;
				path(i) = uppercase(sch);
				if sch = '*' then
					do while i < 10;
						path(i) = '*';
						i = i + 1;
					end;
				pathnamePtr = pathnamePtr + 1;
			end;
			i = i + 1;
		end;	
	end;
	if path(0) <= 5 and nullName then
		return 17h;
	pl = 255;
	do while ptr < pathnamePtr;
		lastPathnameParsed(pl := pl + 1) = tch;
		ptr = ptr + 1;
	end;
	if lastPathnameParsed(pl) = '.' then
		return 1ch;
	lastPathnameParsed(pl + 1) = ' ';	
	if nonTerminator or sch = '.' or sch = ':' then
		return 4;
	return 0;
end;
end;

?wrtdir.plm

WRITEDIRECTORY: DO;

declare bitmap(512) byte external;
/* following are declared but not used */
declare	currentBitMap byte external,
	mapChange byte external,
	lastBlock address external,
	lastSector byte external,
	lastTrack byte external,
	lastCounter byte external,
	maskArray(1) byte external;

setblock: procedure(adr) external; declare adr address; end;

clearbuf: procedure(buf$ptr) external;
	declare buf$ptr address;
end;

absio: procedure(cmd, disk, block, buffer) external;
	declare (cmd, disk) byte, (block, buffer) address;
end;
moveascii: procedure(dst, src, cnt) external;
	declare (dst, src) address, cnt byte;
end;

declare diskType byte external;

declare	dirFile(*) byte data('ISIS', 0, 0, 'DIR'),
	mapFile(*) byte data('ISIS', 0, 0, 'MAP'),
	t0File(*) byte data('ISIS', 0, 0, 'T0', 0),
	binFile(*) byte data('ISIS', 0, 0, 'BIN'),
	labFile(*) byte data('ISIS', 0, 0, 'LAB');

writeDirectory: procedure(disk) public;
	declare	disk byte, i byte, jj address, dirBuf(64) address,
		direct(8) structure(empty byte, file(9) byte, attrib byte,
				    eof$count byte, blk address, hdrBlk address);
	declare countBitMapSectors byte, binHdrBlk address;

	currentBitmap = disk;
	if diskType then
	do;
		countBitMapSectors = 4;
		binHdrBlk = 206h;
	end;
	else
	do;
		countBitMapSectors = 2;
		binHdrBlk = 204h;
	end;
	do jj = 0 to last(bitmap);
		bitmap(jj) = 0;
	end;

	call clearbuf(.dirBuf);
	dirbuf(2) = 1;
	do i = 2 to 23;
		dirBuf(i + 1) = dirBuf(i) + 1;
	end;
	call absio(6, disk, 24, .dirBuf);
	call clearbuf(.dirBuf);
	dirbuf(2) = 26;
	if diskType then
	do;
		do i = 2 to 27;
			dirBuf(i + 1) = dirBuf(i) + 1;
		end;
		dirBuf(29) = 11Bh;
		do i = 2 to 26;
			dirBuf(i + 27 + 1) = dirbuf(i + 27) + 1;
		end;	
	end;
	call absio(6, disk, 25, .dirBuf);
	call clearbuf(.dirBuf);

	dirBuf(2) = 102h;
	do i = 2 to 25;
		dirBuf(i + 1) = dirBuf(i) + 1;
	end;
	call absio(6, disk, 101h, .dirBuf);
	call clearbuf(.dirBuf);

	dirBuf(2) = 202h;
	do i = 2 to countBitMapSectors;
		dirBuf(i + 1) = dirBuf(i) + 1; 
	end;
	call absio(6, disk, 201h, .dirBuf);
	call clearbuf(.dirBuf);

	call absio(6, disk, binHdrBlk, .dirBuf);
	call clearBuf(.direct);

	call moveAscii(.direct(0).file, .dirFile, 9);
	direct(0).blk = 25;
	direct(0).hdrBlk = 101h;
	direct(0).empty = 0;
	direct(0).attrib = 1;
	direct(0).eof$count = 80h;

	call moveAscii(.direct(1).file, .mapFile, 9);
	direct(1).blk = countBitMapSectors;
	direct(1).hdrBlk = 201h;
	direct(1).empty = 0;
	direct(1).attrib = 1;
	direct(1).eof$count = 80h;

	call moveAscii(.direct(2).file, .t0File, 9);
	direct(2).blk = 23;
	direct(2).hdrBlk = 18h;
	direct(2).empty = 0;
	direct(2).attrib = 1;
	direct(2).eof$count = 80h;

	call moveAscii(.direct(3).file, .labFile, 9);
	if diskType then
		direct(3).blk = 53;
	else
		direct(3).blk = 1;
	direct(3).hdrBlk = 19h;
	direct(3).empty = 0;
	direct(3).attrib = 1;
	direct(3).eof$count = 80h;

	call moveAscii(.direct(4).file, .binFile, 9);
	direct(4).blk = 0;
	direct(4).hdrBlk = binHdrBlk;
	direct(4).empty = 0;
	direct(4).attrib = 3;
	direct(4).eof$count = 80h;

	do i = 5 to 7;
		direct(i).empty = 7fh;
	end;
	call absio(6, disk, 102h, .direct);	
	call clearBuf(.direct);
	do i = 0 to 7;
		direct(i).empty = 7fh;
	end;
	do i = 2 to 25;
		call absio(6, disk, 101h + i, .direct);
	end;
	call setblock(101h);
	do jj = 102h to 11ah;
		call setblock(jj);
	end;
	call setblock(201h);
	do jj = 202h to 202h +  countBitMapSectors - 1;
		call setblock(jj);
	end;
	call setblock(18h);
	do jj = 1 to 17h;
		call setblock(jj);
	end;
	call setblock(19h);
	if diskType then
	do;
		do jj = 1ah to 34h;
			call setblock(jj);
		end;
		do jj = 11bh to 134h;
			call setblock(jj);
		end;
	end;
	else
		call setblock(1ah);
	call setblock(binHdrBlk);
	call absio(6, disk, 202h, .bitmap);
	call absio(6, disk, 203h, .bitmap +  80h);
	if diskType then
	do;
		call absio(6, disk, 204h, .bitmap + 100h);
		call absio(6, disk, 205h, .bitmap + 180h);
	end;
end;
end;
cusp5/makefile
ROOT := ../../..
TARGETS := cusp5.lib
unexport ISIS_F1

include $(ROOT)/tools/isis.mk

PLMFLAGS = code

OBJS = alloc.obj direct.obj absio.obj clrbuf.obj chklab.obj d.obj dblank.obj\
       diskio.obj dlimit.obj dmeq.obj ferror.obj fmttrk.obj forupp.obj\
       getdsk.obj getlab.obj mvasci.obj monitr.obj meq.obj numout.obj path.obj\
       popula.obj reperr.obj scanin.obj serror.obj seq.obj setblk.obj\
       tabwrt.obj upcase.obj unpath.obj wrtdir.obj wdlmt.obj wpath.obj\
       cpyrit.obj

REF = $(call ipath,toolbox,1.0)

PLMFLAGS = code
PLM80 = 3.1

all::
	$(MAKE) $(TARGETS)

# verify will fail due to module MONITOR
.IGNORE: verify

cusp5.lib: $(OBJS)
	$(call lib,$@,$^)

cusp6/cusp6_all.src
?absio.plm
ABSIO: DO;
/* b1=01, b2=10, CODE(3DH) byte, DATA(DH) byte, STACK(4H) byte, MEMORY(0H) byte,*/
DECLARE DCB$T LITERALLY 'STRUCTURE (iocw BYTE, ioins BYTE, nsec BYTE, tadr BYTE, sadr BYTE, buf ADDRESS)';

diskio: procedure(disk, dcb$ptr) external; declare (disk, dcb$ptr) address; end;

absio: procedure(cmd, disk, block, buffer) public;
	declare (cmd, disk) byte, (block, buffer) address;
	declare dcb DCB$T;

	dcb.iocw = 80H;
	dcb.ioins = cmd;
	dcb.nsec = 1;
	dcb.tadr = high(block);
	dcb.sadr = low(block);
	dcb.buf = buffer;
	call diskio(disk, .dcb);
end;
end;

?alloc.plm
ALLOC: DO;
declare	mapBase address public,
	maskArray(*) byte public data(80H, 40H, 20H, 10H, 8, 4, 2, 1);
end;
?chklab.plm
CHECKLABEL: DO;

write: procedure (conn, buff$p, count, status$p) external;
    declare (conn, buff$p, count, status$p) address;
end write;

getDisk: procedure(arg1b) external;
	declare arg1b byte;
end;

getLabel: procedure(lab, device) external;
	declare lab address, device byte;
end;

seq: procedure(s1, s2, cnt) byte external;
	declare (s1,s2) address, cnt byte;
end;

CHECKLABEL: procedure(matchLab, device, disk) public;
	declare matchLab address, (device, disk) byte;
	declare status address, lab(11) byte;

	if device >  9 then
		return;

	do while (1);
		call GETDISK(disk);
		
		call GETLABEL(.lab, device);
		if SEQ(matchLab, .lab, 9) then
			return;
		lab(0) = device + '0';
		call WRITE(0, .('WRONG DISKETTE IN DRIVE '), 24, .status);
		call WRITE(0, .lab, 1, .status);
		call WRITE(0, .(0DH, 0AH), 2, .status);
	end;
end;

end;
?clrbuf.plm
clearbuf: DO;

clearbuf: procedure(buf$ptr) public;
    declare buf$ptr address, i byte,
        buf based buf$ptr (1) byte;

    do i = 0 to 127;
        buf(i) = 0;
    end;
end;
end;
?cpyrit.plm
COPYRIGHT: DO;
end;
?d.plm
D: DO;
sFileError: procedure(status, filename) external;
    declare (status, filename) address;
end;
open: procedure (conn$p, path$p, access, echo, status$p) external;
    declare (conn$p, path$p, access, echo, status$p) address;
end open;

read: procedure (conn, buff$p, count, actual$p, status$p) external;
    declare (conn, buff$p, count, actual$p, status$p) address;
end read;

write: procedure (conn, buff$p, count, status$p) external;
    declare (conn, buff$p, count, status$p) address;
end write;

close: procedure (conn, status$p) external;
    declare (conn, status$p) address;
end close;

delimit: procedure(ptr) address external;
    declare ptr address, ch based ptr byte;
end;

NumOut: procedure(value, base, lc, bufAdr, width) external;
    declare (value, bufAdr) address, (base, lc, width) byte;
end;

YPath: procedure(int, ext) external;
    declare (int, ext) address;
end;

deblank: procedure(ptr) address external;
    declare ptr address;
end;

spath: procedure (path$p, info$p, status$p) external;
    declare (path$p, info$p, status$p) address;
end spath;

Population: procedure(bufferLoc, len) address external;
    declare (bufferLoc, len) address;
end;

meq: procedure(mPtr, fptr) byte external;
    declare (mPtr, fptr) address;
end;

memck: procedure address external; end;

declare diskType byte external;
declare wcUsed byte external;




declare isisMapFile(*) byte initial(':F :ISIS.MAP '),
    isisLabFile(*) byte initial(':F :ISIS.LAB '),
    isisDirFile(*) byte initial(':F :ISIS.DIR '),
    blksUsedMsg(*) byte initial('XXXXX/YYYYY BLOCKS USED', 0DH, 0AH),
    dirHeader(*) byte initial('NAME  .EXT  BLKS   LENGTH ATTR', 0DH, 0AH);

declare	crlf(2) byte data(0DH, 0AH),
    dirOfMsg(*) byte data('DIRECTORY OF ');

D: procedure(drive, conn, packedListing, attribMask, twoCol, summary, fNamePat) public;
    declare (drive, conn, packedListing, attribMask, twoCol, summary) byte, fNamePat address;
    declare (dconn, status, actual) address,
        (sectUsed, highFileSize, lowFileSize) address,
        totalSectUsed address,
        strBuf(15) byte,
        path(15) byte,
        (i, j) byte,
        maxDirectPtr address, maxDirCount address,
        (mapBufSize, maxBlocks, curDirCount) address,
        colTwo byte, directPtr address;

        
    declare direct based directPtr structure(status byte, name(6) byte, ext(3) byte,
                      attrib byte, eof$count byte, blk address, hdrBlk address);

    bigAdd: procedure(n);
        declare n address;
        lowFileSize = lowFileSize + n;
        if lowFileSize > 9999 then
        do;
            highFileSize = highFileSize + lowFileSize / 10000;
            lowFileSize = lowFileSize mod 10000;
        end;
    end;

    loadDir: procedure;
        declare i byte;

        directPtr = .MEMORY;
        do while directPtr < maxDirectPtr;
            call READ(dconn, directPtr, 128, .actual, .status);
            do i = 1 to 8;
                if not direct.status then
                do;
                    if (direct.attrib and not attribMask) or
                        not Meq(fNamePat, .direct) then
                       direct.status = 0ffh;
                    else if not wcUsed then
                    do;
                        curDirCount = maxDirCount;
                        MEMORY(directPtr - .MEMORY + size(direct)) = 7fh;
                        return;
                    end;
                end;
                else if direct.status = 7fh then
                do;
                    curDirCount = maxDirCount;
                    directPtr = .MEMORY;
                    return;
                end;
                directPtr = directPtr + size(direct);
            end;
            curDirCount = curDirCount + 8;
            if curDirCount = maxDirCount then
                maxDirectPtr = directPtr;
        end;
        direct.status = 7fh;
        directPtr = .MEMORY;
    end;





    maxDirCount = 200;
    mapBufSize = 251;
    maxBlocks = 2002;
    if diskType = 1 then	/* DD */
    do;
        mapBufSize = 501;
        maxBlocks = 4004;
    end;
    else if diskType = 4 then /* HD */
    do;
        maxDirCount = 992;
        mapBufSize = 3600;
        maxBlocks = 28800;
    end;

    isisMapFile(2), isisLabFile(2), isisDirFile(2) = drive + '0';
    call Open(.dconn, .isisLabFile, 1, 0, .status);
    call sFileError(status, .isisLabFile);
    strBuf(0) = drive;
    call Read(dconn, .strBuf(1), 9, .actual, .status);
    call Write(conn, .dirOfMsg, 13, .status);
    call Ypath(.strBuf, .path);
    i = Delimit(.path) - .path;
    call Write(conn, .path, i, .status);
    call Write(conn, .crlf, 2, .status);
    call close(dconn, .status);
    if summary then
	;
    else
    do;
        if not packedListing then
        do;
		if twoCol then
		do;
		    call Write(conn, .dirHeader, size(dirHeader) - 2, .status);
		    call Write(conn, .('      '), 6, .status);
		end;
		call Write(conn, .dirHeader, size(dirHeader), .status);
        end;
        call Open(.dconn, .isisDirFile, 1, 0, .status);
        totalSectUsed = 0;
        colTwo = 0ffh;
        maxDirectPtr = memck - 128;	/* make sure there is room for 1 last sector */
        curDirCount = 0;
        do while curDirCount <> maxDirCount;
            call loadDir;
            do while direct.status <> 7fh;
                if not direct.status then
                do;
                    if twoCol then
                        colTwo = not colTwo;
                    do i = 0 to 8;
                        if direct.name(i) = 0 then
                            direct.name(i) = ' ';
                    end;
                    i = 9;
                    if packedListing then	
                        do while direct.name(i - 1) = ' ';
                            i = i - 1;
                        end;
                    if not packedListing or i > 6 then
                        j = 6;
                    else	
                        j = i;
                    call Write(conn, .direct.name, j, .status);
                    if packedListing then
                    do;
                        if i > 6 then
                        do;
                            call Write(conn, .('.'), 1, .status);
                            call Write(conn, .direct.ext, i - 6, .status);
                            i = i + 1;
                        end;
                    end;
                    else
                    do;
                        if direct.ext(0) <> ' ' then
                            call Write(conn, .('.'), 1, .status);
                        call Write(conn, .direct.ext, 3, .status);
                        if direct.ext(0) = ' ' then
                            call Write(conn, .(' '), 1, .status);
                        sectUsed = direct.blk;
                        if sectUsed > 0 then
                            sectUsed = sectUsed + (sectUsed + 61) / 62;
                        else
                            sectUsed = 1;
                        totalSectUsed = totalSectUsed + sectUsed;
                        call NumOut(sectUsed, 10, ' ', .strBuf, 6);
                        call Write(conn, .strBuf, 6, .status);
                        sectUsed = direct.blk;
                        lowFileSize, highFileSize = 0;
                        if sectUsed > 0 then
                        do;
                            sectUsed = sectUsed - 1;
                            lowFileSize = direct.eof$count;
                            do while sectUsed >= 400;
                                sectUsed = sectUsed - 400;
                                call bigAdd(128 * 400);
                            end;
                        end;
                        call bigAdd(128 * sectUsed);
     
                        if highFileSize <> 0 then
                        do;
                            call NumOut(highFileSize, 10, ' ', .strBuf, 5);
                            call NumOut(lowFileSize, 10, '0', .strBuf(5), 4);
                        end;
                        else
                            call NumOut(lowFileSize, 10, ' ', .strBuf, 9);
                        call Write(conn, .strBuf, 9, .status);
                        if direct.attrib <> 0 or not colTwo then
                        do;
                            do i = 0 to 4;
                                strbuf(i) = ' ';
                            end;
                            if (direct.attrib and 4) <> 0 then
                                strbuf(1) = 'W';
                            if (direct.attrib and 2) <> 0 then
                                strbuf(2) = 'S';
                            if direct.attrib then
                                strbuf(3) = 'I';
                            if (direct.attrib and 80h) <> 0 then
                                strbuf(4) = 'F';
                            call write(conn, .strbuf, 5, .status);
                        end;
                        i = 10;
                    end;
                    if colTwo then
                        call Write(conn, .crlf, 2, .status);
                    else
                        call Write(conn, .('               '), 16 - i, .status);
                end;
                directPtr = directPtr + size(direct);
            end;
        end; 
        call Close(dconn, .status);
        if not colTwo then
            call Write(conn, .crlf, 2, .status);
    	if not packedListing then
    	do;
            if twoCol then
                i = 35;
            else
                i = 16;
            call NumOut(totalSectUsed, 10, ' ', .MEMORY, i);
            call Write(conn, .MEMORY, i, .status);
            call Write(conn, .crlf, 2, .status);
    	end;
    end; 
    call Open(.dconn, .isisMapFile, 1, 0, .status);
    call Read(dconn, .MEMORY, mapBufSize, .actual, .status);
    call NumOut(Population(.MEMORY, mapBufSize), 10, 0, .blksUsedMsg, 5);
    call NumOut(maxBlocks, 10, 0, .blksUsedMsg + 6, 5);
    call Write(conn, .blksUsedMsg, size(blksUsedMsg), .status);
    call Close(conn, .status);
end;
end;
?dblank.plm
DEBLANK: DO;
deblank: procedure(ptr) address public;
	declare ptr address, c based ptr byte;

	do while (c = ' ');
		ptr = ptr + 1;
	end;
	return ptr;
end;

end;
?direct.plm
DIRECT: DO;
declare DIRECT(16) byte public;
declare DIRECTINO address public;
end;
?diskio.plm
DISKIO: DO;
isis: procedure(syscmd, param$p) external; declare syscmd byte, param$p address; end;

diskio: procedure(disk, dcb$p) public;
	declare (disk, dcb$p) address; 
	declare param structure(disk address, dcb$p address);
	
	param.disk = disk;
	param.dcb$p = dcb$p;
	call isis(44H, .param);
end;
end;
?dlimit.plm
DELIMIT: DO;
delimit: procedure(ptr) address public;
	declare ptr address, ch based ptr byte;

	do while ch = ':' or ch = '.' or
		 ('0' <= ch and ch <= '9') or
		 ('A' <= ch and ch <= 'Z');
		ptr = ptr + 1;
	end;
	return ptr;
end;
end;
?dmeq.plm
DMEQ: DO;
declare TRUE	literally '0FFH',
	FALSE	literally '0';

read: procedure (conn, buff$p, count, actual$p, status$p) external;
    declare (conn, buff$p, count, actual$p, status$p) address;
end read;

seek: procedure (conn, mode, block$p, byte$p, status$p) external;
    declare (conn, mode, block$p, byte$p, status$p) address;
end seek;

meq: procedure(A, B) byte external ; declare (A,B) address; end;

ReportError: procedure(errNum) external;
	declare errNum address;
end;

declare diskType byte external;

dmeq: procedure (dirAftn, searchArg, initialINo, dirEntry) address public;
    declare (dirAftn, searchArg, initialINo, dirEntry) address;
    declare (byteNo, blockNo, actual, status) address;
    declare pastDir address, searching byte;
    declare dirFlag based dirEntry byte;

	blockNo = 0;
	byteNo = initialINo * 16;
	call seek(dirAftn, 2, .blockNo, .byteNo, .status);

	if status <> 0 then
		;
	if diskType = 4 then	/* hard disk */
		pastDir = 993;
	else
		pastDir = 201;
	
	searching = TRUE;
	do while searching;
		call read(dirAftn, dirEntry, 16, .actual, .status);
		if dirFlag = 7Fh or actual = 0 then
			return pastDir;
		searching = not meq(searchArg, dirEntry);
		initialINo = initialINo + 1;
	end;

	return initialINo;
end;
end;
?dtype.plm
DTYPE: DO;

Spath: procedure(path$p, info$p, status$p) external;
    declare (path$p, info$p, status$p) address;
end;

declare isisDrive(*) byte initial(':FX: ');

DType: procedure(drive) byte public;
    declare drive byte;
    declare status address, info(12) byte;

    if  drive > 9 then
        return 0;
    isisDrive(2) = drive + '0';
    call Spath(.isisDrive, .info, .status);
    return info(11);
end;
end;
?ferror.plm
FILEERROR: DO;

write: procedure (conn, buff$p, count, actual$p) external;
    declare (conn, buff$p, count, actual$p) address;
end write;

exit: procedure external; end exit;

deblank: procedure(str) address external; declare str address; end;
WDelimit: procedure(ptr) address external; declare ptr address; end;
reporterror: procedure(status) external; declare status address; end;

declare OK literally '0';

fileerror: procedure(status, ptr, callExit) public;
	declare (status, ptr) address;
	declare callExit byte;
	declare actual address;

	if status <> OK then
	do;
		ptr = deblank(ptr);
		call write(0, .(' '), 1, .actual);
		call write(0, ptr, WDelimit(ptr) - ptr, .actual);
		call write(0, .(','), 1, .actual);
		call reporterror(status);
		if callExit then
			call exit;
	end;
end;
end;
?fmttrk.plm
formatTrack: do;

declare DCB$T literally 'STRUCTURE (iocw BYTE, ioins BYTE, nsec BYTE, tadr BYTE, sadr BYTE, buf ADDRESS)';

Diskio: procedure(disk, dcb$p) external; declare disk address, dcb$p address; end;
declare diskType byte external;

FormatTrack: procedure(disk,sTrack,eTrack,interleave) public;
	declare (disk,interleave) byte, (sTrack, eTrack) address;
	declare curTrack address, (sectors, vTracks) byte;
	declare (i,j,interTrackSkew) byte, trackBuf(104) byte,
	dcb DCB$T;

	if diskType = 4 then	/* HD */
	do;
		sectors = 36;
		interTrackSkew = 17;
	end;
	else if diskType = 1 then	/* DD */
	do;
		sectors = 52;
		interTrackSkew = 7;
	end;
	else
	do;
		sectors = 26;
		interTrackSkew = 4;
	end;

	dcb.iocw = 0c0h;
	vTracks = sectors * 2 - 1;
	do i = 1 to vTracks by 2;
		trackBuf(i) = 0c7h;
	end;

	j = 0;

	if diskType = 4 then
	do;
		sTrack = sTrack * 4;
		eTrack = eTrack * 4 + 3;
	end;

	do curTrack = sTrack to eTrack;
		dcb.ioins = 2;
		do i = 0 to vTracks by 2;
			trackBuf(i) = 0;
		end;
		do i = 1 to sectors;
			j = (j + interleave) mod sectors;
			do while trackBuf(j * 2) <> 0;
				j = (j + 1) mod sectors;
			end;
			trackBuf(j + j) = i;
		end;
		if diskType <> 4 then
			dcb.tadr = curTrack;
		else
		do;
			dcb.tadr = curTrack / 4;
			dcb.sadr = (curTrack mod 4) * 36 + 1;
		end;
		dcb.buf = .trackBuf;
		call Diskio(disk, .dcb);
		j = j + interTrackSkew;
	end;
end;
end;
?forupp.plm
FORCEUPPER: DO;
declare CR literally '0DH';

uppercase: procedure(ch) byte external; declare ch byte; end;

forceupper: procedure(bufferPtr) public;
	declare bufferPtr address, ch based bufferPtr byte;

	do while ch <> CR;
		ch = uppercase(ch);
		bufferPtr = bufferPtr + 1;
	end;
end;
end;
?getdsk.plm
GetDisk: do;

Write: procedure(conn, buff$p, count, status$p) external;
         declare conn address, buff$p address, count address, status$p address; end;

Read: procedure(conn, buff$p, count, actual$p, status$p) external;
        declare conn address, buff$p address, count address, actual$p address, status$p address; end;


declare source(3) structure(name(6) byte) data('SYSTEM', 'SOURCE', 'OUTPUT');

GetDisk: procedure(n) public;
	declare n byte;
	declare buf(128) byte, status address, junk address, actual address;

	call Write(0, .('LOAD '), 5, .status);
	call Write(0, .source(n), 6, .status);
	call Write(0, .(' DISK, THEN TYPE (CR)'), 21, .status);
	call Read(1, .buf, 128, .actual, .status);
end;
end;
?getlab.plm
GETLABEL: DO;

read: procedure (conn, buff$p, count, actual$p, status$p) external;
    declare (conn, buff$p, count, actual$p, status$p) address;
end read;

open: procedure (conn$p, path$p, access, echo, status$p) external;
    declare (conn$p, path$p, access, echo, status$p) address;
end open;

close: procedure (conn, status$p) external;
    declare (conn, status$p) address;
end close;

SFileError: procedure(status, name$p) external;
	declare (status, name$p) address;
end;

declare isisLabFile(*) byte initial(':FX:ISIS.LAB', 0);

GetLabel: procedure(labBuf, device) public;
	declare labBuf address, device byte;
	declare (status, actual, conn) address;

	if device > 9 then
		return;
	isisLabFile(2) = device + '0';
	call Open(.conn, .isisLabFile, 1, 0, .status);
	call SFileError(status, .isisLabFile);
	call Read(conn, labBuf, 9, .actual, .status);
	call SFileError(status, .isisLabFile);
	call Close(conn, .status);
	call SFileError(status, .isisLabFile);
end;
end;
?meq.plm
MEQ: DO;
declare TRUE literally '0ffh';

meq: procedure(mPtr, fptr) byte public;
	declare (mPtr, fptr) address, i byte;
	declare m based mPtr (10) byte;
	declare f based fptr (10) byte;

	do i = 0 to 9;
		if m(i) = '?' then
		do;
			if f(i) = 0 then
				return 0;
		end;
		else if m(i) <> '*' then
		do;
			if m(i) <> f(i) then
				return not TRUE;
		end;
	end;
	return TRUE;
end;
end;

?monitr.plm
MONITOR: DO;
MONITOR: procedure public;
	declare sp address, wrd based sp  address;

	sp = STACKPTR;
	wrd = 8;	
	STACKPTR = STACKPTR - 2;
	sp = STACKPTR;
	wrd = 0;
end;
end;
?mvasci.plm
MOVEASCII: DO;
moveascii: procedure(dst, src, cnt) public;
	declare (dst, src) address, cnt byte, i byte;
	declare dch based dst (1) byte, sch based src (1) byte;

	do i = 0 to cnt - 1;
		dch(i) = sch(i);
	end;
end;
end;
?numout.plm
NUMOUT: DO;


numout: procedure(value, base, lc, bufAdr, width) public;
	declare (value, bufAdr) address, (base, lc, width) byte; 
	declare i byte;
	declare buf based bufAdr (1) byte;
	declare digits(*) byte data('0123456789ABCDEF');

	do i = 1 to width;
		buf(width - i) = digits(value mod base);
		value = value / base;	
	end;

	i = 0;
	do while buf(i) = '0' and i < width - 1;
		buf(i) = lc;
		i = i + 1;
	end;
end;
end;
?path.plm
PATH: DO;
moveascii: procedure(dst, src, cnt) external;
	declare (dst, src) address, cnt byte;
end;

Spath: procedure(filename, info$p, status$p) external;
	declare (filename, info$p, status$p) address;
end;

PATH: procedure(filename, pn) byte public;
	declare (filename, pn) address;
	declare info(12) byte, status byte;

	call Spath(filename, .info, .status);	/* bug? status only a byte */
	call MoveAscii(pn, .info, 10);
	return status;
end;
end;
?popula.plm
population: do;

declare bitCnt(*) byte initial(
	0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,
	1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
	1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
	1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
	3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
	1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
	3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
	3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
	3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
	4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8);

Population: procedure(bufferLoc, length) address public;
	declare (bufferLoc, length, total) address,
	(i, t, l) byte;
	declare buffer based bufferLoc (1) byte;

	total = 0;
	do while length > 31;
		t = 0;
		do i = 0 to 30;
			t = t + bitCnt(buffer(i));
		end;
		total = total + t;
		bufferLoc = bufferLoc + 31;
		length = length - 31;
	end;
	l = length - 1;
	t = 0;
	do i = 0 to l;
		t = t + bitCnt(buffer(i));
	end;
	return total + t;
end;
end;
?reperr.plm
REPORTERROR: DO;

error: procedure(errNum) external; declare errNum address; end;

write: procedure(aftn, buf$ptr, len, status$ptr) external;
   declare (aftn, buf$ptr, len, status$ptr) address;
end write;

declare CR	literally '0dh';
declare LF	literally '0ah';

reporterror: procedure(errNum) public;
	declare errNum address;
	declare numberBuffer(3) byte;
	declare (i, status) address;
 
	declare msg(*) byte DATA(0, 0,
		2, 'ILLEGAL AFTN ARGUMENT', 0,
		4, 'INCORRECTLY SPECIFIED FILE', 0,
		5, 'UNRECOGNIZED DEVICE NAME', 0,
		6, 'ATTEMPT TO WRITE TO INPUT DEVICE', 0,
		8, 'ATTEMPT TO READ FROM OUTPUT DEVICE', 0,
		9, 'DISK DIRECTORY FULL', 0,
		0AH, 'NOT ON SAME DISK', 0,
		0BH, 'FILE ALREADY EXISTS', 0,
		0CH, 'FILE IS ALREADY OPEN', 0,
		0DH, 'NO SUCH FILE', 0,
		0EH, 'WRITE PROTECTED', 0,
		11H, 'NOT A DISK FILE', 0,
		12H, 'ILLEGAL ISIS COMMAND', 0,
		13H, 'ATTEMPTED SEEK ON NON-DISK FILE', 0,
		14H, 'ATTEMPTED BACK SEEK TOO FAR', 0,
		15H, 'CAN''T RESCAN', 0,
		16H, 'ILLEGAL ACCESS MODE TO OPEN', 0,
		17H, 'MISSING FILENAME', 0,
		19H, 'ILLEGAL ECHO FILE', 0,
		1AH, 'ILLEGAL ATTRIBUTE IDENTIFIER', 0,
		1BH, 'ILLEGAL SEEK COMMAND', 0,
		1CH, 'MISSING EXTENSION', 0,
		1FH, 'CAN''T SEEK ON WRITE ONLY FILE', 0,
		20H, 'CAN''T DELETE OPEN FILE', 0,
		23H, 'SEEK PAST EOF', 0,
		0C9H, 'UNRECOGNIZED SWITCH', 0,
		0CAH, 'UNRECOGNIZED DELIMITER', 0,
		0CBH, 'INVALID SYNTAX', 0,
		0CCH, 'PREMATURE EOF', 0,
		0CEH, 'ILLEGAL DISKETTE LABEL', 0,
		0D0H, 'CHECKSUM ERROR', 0,
		0D1H, 'RELO FILE SEQUENCE ERROR', 0,
		0D2H, 'INSUFFICIENT MEMORY', 0,
		0D3H, 'RECORD TOO LONG', 0,
		0D4H, 'ILLEGAL RELO RECORD', 0,
		0D5H, 'FIXUP BOUNDS ERROR', 0,
		0D6H, 'ILLEGAL SUBMIT PARAMETER', 0,
		0D7H, 'ARGUMENT TOO LONG', 0,
		0D8H, 'TOO MANY PARAMETERS', 0,
		0D9H, 'OBJECT RECORD TOO SHORT', 0,
		0DAH, 'ILLEGAL RECORD FORMAT', 0,
		0DBH, 'PHASE ERROR', 0,
		0EAH, 'CANNOT FORMAT FROM TARGET DRIVE', 0,
		0EBH, 'NON-DISK DEVICE', 0
		);


	if errNum <> 0 then
	do;
		i = 0;
		do while i < size(msg);
			if errNum = msg(i) and msg(i + 1) <> 0 then
			do;
				i = i + 1;
				call write(0, .(' '), 1, .status);
				do while msg(i) <> 0;
					call write(0, .msg(i), 1, .status);
					i = i + 1;
				end;
				call write(0, .(CR, LF), 2, .status);
				return;
			end;
			else
			do;
				do while msg(i) <> 0;
					i = i + 1;
				end;
				i = i + 1;
			end;
		end;
	call error(errNum);
	end;
end;
end;
?scanin.plm
scanIn: do;

declare digits(*) byte data('0123456789ABCDEF');

ScanInteger: procedure(ptrPtr) address public;
	declare ptrPtr address;
	declare ptr based ptrPtr address;
	declare (scanPtr, updatePtr, stopPtr) address;
	declare (i, radix, increment) byte;
	declare (nVal, oVal) address;
	declare c based scanPtr byte;

	scanPtr = ptr;
	do while c = ' ';
		scanPtr = scanPtr + 1;
	end;
	ptr = scanPtr;
	do while '0' <= c and c <= '9' or 'A' <= c and c <= 'F';
		scanPtr = scanPtr + 1;
	end;

	stopPtr = scanPtr;
	updatePtr = scanPtr + 1;
	if c = 'H' then
		radix = 16;
	else if c = 'O' or c = 'Q' then
		radix = 8;
	else
	do;
		updatePtr = scanPtr;
		stopPtr, scanPtr = scanPtr - 1;
		if c = 'B' then
			radix = 2;
		else
		do;
			radix = 10;
			if c <> 'D' then	/* include last increment */
				stopPtr = stopPtr + 1;
		end;
	end;
	scanPtr = ptr;
	nVal, oVal = 0;
	do while scanPtr < stopPtr;
		do i = 0 to 15;
			if c = digits(i) then
				increment = i;
		end;
		if increment >= radix then
			return 0;
		nVal = oVal * radix + increment;
		if nVal < oVal then
			return 0;
		oVal = nVal;
		scanPtr = scanPtr + 1;
	end;
	ptr = updatePtr;
	return nVal;
end;
end;
?seq.plm
SEQ: DO;

declare TRUE literally '0ffh';

seq: procedure(s1, s2, len) byte public;
	declare (s1,s2) address, (len, i) byte;
	declare s1a based s1(1) byte;
	declare s2a based s2(1) byte;

	len = len - 1;
	do i = 0 to len;
		if s1a(i) <> s2a(i) then
			return not TRUE;
	end;
	return TRUE;
end;
end;
?serror.plm
SFileError: do;
declare boolean literally 'byte';

Write: procedure(conn, buff$p, count, status$p) external;
         declare conn address, buff$p address, count address, status$p address; end;

Exit: procedure external; end;

deblank: procedure(ptr) address external; declare ptr address; end;

WDelimit: procedure(ptr) address external; declare ptr address; end;

GetDisk: procedure(n) external; declare n byte; end;

ReportError: procedure(errNum) external; declare errNum address; end;

declare singleDrive boolean external;

SFileError: procedure(status, name$p) public;
	declare (status, name$p) address;
	declare lStatus address;

	if status <> 0 then
	do;
		if singleDrive then
			call GetDisk(0);
		name$p = Deblank(name$p);
		call Write(0, .(' '), 1, .lStatus);
		call Write(0, name$p, WDelimit(name$p) - name$p, .lStatus);
		call Write(0, .(','), 1, .lStatus);
		call ReportError(status);
		call Exit;
	end;
end;
end;
?setblk.plm
SetBlock: do;
declare mapBase address external;
declare maskArray(1) byte external;
declare diskType byte external;

SetBlock: procedure(adr) public;
	declare adr address;
	declare (bit, byt) address, spt byte;
	declare bitmap based mapBase (1) byte;

	if diskType = 4 then
		spt = 90h;
	else if diskType = 1 then
		spt = 34h;
	else
		spt = 1ah;

	bit = high(adr) * spt + low(adr) - 1;
	byt = shr(bit, 3);
	bitmap(byt) = bitmap(byt) or maskArray(low(bit) and 7);
end;
end;
?setmap.plm
SetupMap: do;
declare CR literally '0dh';
declare LF literally '0ah';

Write: procedure(conn, buff$p, count, status$p) external;
         declare conn address, buff$p address, count address, status$p address; end;

Exit: procedure external; end;

Absio: procedure(cmd, disk, block, buffer) external;
         declare cmd byte, disk byte, block address, buffer address; end;

numout: procedure(val, base, lc, bufAdr, width) external;
          declare val address, base byte, lc byte, bufAdr address, width byte; end;

SetBlock: procedure(adr) external; declare adr address; end;

declare mapBase address external;
declare maskArray(1) byte external;
declare diskType byte external;

declare fatalMsg(*) byte initial(' FATAL',
/* 6 */		               ' BAD SPOT AT LOGICAL ADDRESS ( ',
/* 37 */		       '***, ',
/* 42 */		       '*** ), STATUS = ',
/* 58 */		       '****', CR, LF);

declare trap0B structure(jmp byte, target address) at (0bh),
	trap0E address at (0eh);

declare trap0BCodeLocation address data(.SetupMap + 0DCh);
declare bitmap based mapBase (1) byte;

SetupMap: procedure(disk) address public;
	declare disk byte;
	declare logicalTrackSector address,
		(logicalSector, logicalTrack) byte at (.logicalTrackSector),
		(readBuf, savedSP) address,
		savedTrap0B structure(jmp byte, target address),
		(badSectorCount, headFixItemPtr, nextFixItemPtr, fixItemPtr) address,
		j byte, (i, bitmapLast, status) address;
	declare fixItem based fixItemPtr structure(sector byte, driveErr address, next address);

	ChkFixedSectors: procedure;
		if (logicalTrack = 0 and (logicalSector < 1Ch or logicalSector = 58h or logicalSector > 72h))
		  or (logicalTrack = 1 and (logicalSector < 40h or (48h < logicalSector and logicalSector < 88h)))
		  or (logicalTrack = 2 and logicalSector < 20h) then
		do;
			call NumOut(logicalTrack, 10, 0, .fatalMsg(37), 3);
			call NumOut(logicalSector, 10, 0, .fatalMsg(42), 3);
			call NumOut(trap0E, 16, 0, .fatalMsg(58), 4);
			call Write(0, .fatalMsg, 64, .status);
			call Exit;
		end;
	end;


	AddBadSector: procedure;
		declare (p, q) address;
		call ChkFixedSectors;
		call SetBlock(logicalTrackSector);
		fixItemPtr, p = headFixItemPtr;
		fixItemPtr = fixItem.next;

		/* look for insert point p->sector <  logicalsector and logicalsector <= *fixItemPtr */
		do while fixItem.sector < logicalSector;
			p = fixItemPtr;
			fixItemPtr = fixItem.next;
		end;
		if fixItem.sector = logicalSector then	/* already in list */
			return;

		q = fixItemPtr;				/* insert into list and set values */
		fixItemPtr = p;
		fixItem.next = nextFixItemPtr;
		fixItemPtr = nextFixItemPtr;
		fixItem.sector = logicalSector;
		fixItem.driveErr = trap0E;
		fixItem.next = q;
		nextFixItemPtr = nextFixItemPtr + size(fixItem);	/* set up next item */
	end;


	if diskType = 4 then	/* HD */
		bitmapLast = 3711;
	else if diskType = 1 then	/* DD */
		bitmapLast = 511;
	else
		bitmapLast = 255;	/* SD */

	do i = 0 to bitmapLast;
		bitmap(i) = 0;
	end;

	if diskType <> 4 then
		return 0;
	badSectorCount = 0;
	headFixItemPtr = (readBuf := mapBase + 3712) + 128;
	savedSP = STACKPTR;
	savedTrap0B.jmp = trap0B.jmp;
	trap0B.jmp = 0c3h;
	savedTrap0B.target = trap0B.target;
	trap0B.target = trap0BCodeLocation;
	logicalTrack = 0;

nextTrack:
	fixItemPtr = headFixItemPtr;
	fixItem.next = fixItemPtr + size(fixItem);
	fixItemPtr = headFixItemPtr + size(fixItem);
	fixItem.sector = 145;	/* max sector + 1 */
	nextFixItemPtr = fixItemPtr + size(fixItem);
	logicalSector = 1;

nextSector:
	call Absio(4, disk, logicalTrackSector, readBuf);
	goto skipTrap;

newTrap0B:
	STACKPTR = savedSP;
	trap0B.jmp = savedTrap0B.jmp;
	trap0B.target = savedTrap0B.target;
	if trap0E <> 1 and trap0E <> 10 then
		call AddBadSector;
	else
	do;
		/* mark all of the track under this head as bad. Note 4 heads per logical  track */
		logicalSector = (logicalSector - 1) - ((logicalSector - 1) mod 36);	/* first sector for head */
		do j = 1 to 36;
			logicalSector = logicalSector + 1;
			call AddBadSector;
		end;
	end;

	trap0B.jmp = 0c3h;
	trap0B.target = trap0BCodeLocation;

skipTrap:
	if (logicalSector := logicalSector + 1) < 145 then
		goto nextSector;

	fixItemPtr = headFixItemPtr;
	fixItemPtr = fixItem.next;

	do while fixItem.sector < 145;
		call NumOut(logicalTrack, 10, 0, .fatalMsg(37), 3);
		call NumOut(fixItem.sector, 10, 0, .fatalMsg(42), 3);
		call NumOut(fixItem.driveErr, 16, 0, .fatalMsg(58), 4);
		call Write(0, .fatalMsg(6), 58, .status);
		if logicalTrack > 1 then
			badSectorCount = badSectorCount + 1;
		fixItemPtr = fixItem.next;
	end;
	if (logicalTrack := logicalTrack + 1) < 200 then
		goto nextTrack;

	trap0B.jmp = savedTrap0B.jmp;
	trap0B.target = savedTrap0B.target;
	return badSectorCount;
end;
end;

?tabwrt.plm
TABWRITE: DO;

declare TAB	literally '9',
	CR	literally '0dh';

write: procedure (aft, buff$p, count, status) external;
    declare (aft, buff$p, count, status) address;
end write;

tabwrite: procedure(columnPtr, aft, bufferPtr, count, status) public;
	declare (columnPtr, aft, bufferPtr, count, status) address;
	declare (printChar, i, j) byte;
	declare column based columnPtr byte;
	declare ch based bufferPtr byte;

	do while count <> 0;
		i = ch = TAB and (7 - (column and 7));
		printChar = ch;
		bufferPtr = bufferPtr + 1;
		count = count - 1;
		if printChar = TAB then
			printChar = ' ';
		do j = 0 to i;
			if ch = CR then
				column = 0;
			if ch >= ' ' then
				column = column + 1;
			call write(aft, .printChar, 1, status);
		end;
	end;
end;
end;

?trange.plm
TESTRANGE: DO;

FileError: procedure(status, ptr, callExit) external;
	declare (status, ptr) address, callExit byte;
end;

ReportError: procedure(status) external; declare status address; end;

Exit: procedure external; end exit;

declare TRUE literally '0ffh';

TestRange: procedure(device, buffer$p) byte public;
	declare device byte, buffer$p address;

	if device >= 25 then	/* diskdrive 6-9 */
		device = device - 19;	/* bring disks together */
	else if device > 5 then		/* shift others above disks */
		device = device + 4;

	if device <=  9 or buffer$p = 1 then
		return device;
	if buffer$p <> 0 then
		call FileError(0EBh, buffer$p, TRUE);
	else
	do;
		call ReportError(0EBh);
		call exit;
	end;
end;
end;
?unpath.plm
UNPATH: DO;

declare devTab(*) byte data('F0F1F2F3F4F5TITO',
			     'VIVOI1O1TRHRR1R2',
			     'TPHPP1P2LPL1BBCICO',
			     'F6F7F8F9');

unpath:	procedure(int, ext) public;
	declare (int, ext) address;
	declare i byte;
	declare intName based int (1) byte;
	declare extName based ext (1) byte;

	extName(0) = ':';
	extName(1) = devTab(intName(0) + intName(0));
	extName(2) = devTab(intName(0) + intName(0) + 1);
	extName(3) = ':';	
	ext = ext + 4;
	do i = 0 to 5;
		if (extName(0) := intName(i + 1)) <> 0 then
			ext = ext + 1; 
	end;
	if intName(7) <> 0 then
	do;
		extName(0) = '.';
		ext = ext + 1;
	end;
	do i = 0 to 2;
		if (extName(0) := intName(i + 7)) <> 0 then
			ext = ext + 1; 

	end;
	extName(0) = ' ';
end;
end;
?upcase.plm
UPPERCASE: DO;
uppercase: procedure(char) byte public;
	declare char byte;
	if char < 'a' then
		return char;
	if char > 'z' then
		return char;
	return char and 0dfh;
end;
end;
?wdelim.plm
WDELIMIT: DO;
/* b1=01, b2=31, CODE(63H) byte, DATA(2H) byte, STACK(4H) byte, MEMORY(0H) byte,*/
.CODE
WDELIMIT:	; public
	lxi	h,D$0001
	mov	m,b
	dcx	h
	mov	m,c
L$0006:
	lhld	D$0000
	mov	a,m
	sui	3AH
	sui	1
	sbb	a
	push	psw
	mov	a,m
	sui	2EH
	sui	1
	sbb	a
	pop	b
	mov	c,b
	ora	c
	push	psw
	mov	a,m
	sui	2AH
	sui	1
	sbb	a
	pop	b
	mov	c,b
	ora	c
	push	psw
	mov	a,m
	sui	3FH
	sui	1
	sbb	a
	pop	b
	mov	c,b
	ora	c
	push	psw
	mov	a,m
	sui	30H
	sbb	a
	cma
	push	psw
	mvi	a,39H
	sub	m
	sbb	a
	cma
	pop	b
	mov	c,b
	ana	c
	pop	b
	mov	c,b
	ora	c
	push	psw
	mov	a,m
	sui	41H
	sbb	a
	cma
	push	psw
	mvi	a,5AH
	sub	m
	sbb	a
	cma
	pop	b
	mov	c,b
	ana	c
	pop	b
	mov	c,b
	ora	c
	rar
	jnc	L$005F
	lhld	D$0000
	inx	h
	shld	D$0000
	jmp	L$0006
L$005F:
	lhld	D$0000
	ret
.DATA
D$0000:
	BYTE(1)
D$0001:
	BYTE(1)
MODEND: CODE 0000

?wdlmt.plm
WDELIMIT: DO;
/* b1=01, b2=31, CODE(63H) byte, DATA(2H) byte, STACK(4H) byte, MEMORY(0H) byte,*/
wdelimit: procedure(ptr) address public;
	declare ptr address;
	declare ch based ptr byte;

	do while (ch = ':' or ch = '.' or ch = '*' or ch = '?' or
		  ('0' <= ch and ch <= '9') or ('A' <= ch and ch <= 'Z'));
		ptr = ptr + 1;
	end;
	return ptr;
end;
end;

?wpath.plm
WPATH: DO;
uppercase: procedure(char) byte external;
	declare char byte;
end;

TestRange: procedure(device, buffer$p) byte external;
	declare device byte, buffer$p address;
end;

declare FALSE literally '0';
declare TRUE literally '0FFh';


declare lastPathNameParsed(15) byte;

/* the error return codes */
declare BADFILESPEC	literally '4';
declare UNKNOWNDEV	literally '5';
declare MISSINGFNAME	literally '17h';
declare MISSINGEXT	literally '1ch';
declare NOERROR		literally '0';

declare devTab(*) byte data('F0F1F2F3F4F5TITOVIVOI1O1',
			    'TRHRR1R2TPHPP1P2LPL1BBCICOF6F7F8F9');

WPath: procedure(pathNamePtr, pn, wc) byte public;
	declare (pathNamePtr, pn, wc) address;
	declare ptr address;
	declare	addr address, (hi, lo) byte at (.addr);
	declare	devPtr address, (nullName, pl, i) byte;
	declare pathName based pathNamePtr (1) byte;
	declare pnStr based pn (1) byte;
	declare wcFlag based wc byte;
	declare dev based devPtr address;
	declare ch based ptr byte;
	
	NonTerminator: procedure byte;
		return ('A' <= pathName(0) and pathName(0) <= 'Z') or
		       ('0' <= pathName(0) and pathName(0) <= '9') or
		       pathName(0) = '?' or pathName(0) = '*' or
		       ('a' <= pathName(0) and pathName(0) <= 'z');
	end;
	wcFlag = FALSE;
	devPtr = .devTab;
	do i = 0 to 9;
		pnStr(i) = 0;
	end;
	do while pathName(0) = ' ';
		pathNamePtr = pathNamePtr + 1;
	end;

	ptr = pathNamePtr;
	if pathName(0) = ':' then
	do;
		if pathName(3) <> ':' then
			return BADFILESPEC;	/* incorrectly specified file */
		pathNamePtr = pathNamePtr + 1;
		hi = Uppercase(pathName(0));
		pathNamePtr = pathNamePtr + 1;
		lo = Uppercase(pathName(0));
		pathNamePtr = pathNamePtr + 2;
		pnStr(0) = 0FFh;
		i = 0;
		do while i < 57;
			if dev = addr then
				pnStr(0) = shr(i, 1);
			i = i + 2;
			devPtr = devPtr + 2;
		end;
		if pnStr(0) = 0FFh then
			return UNKNOWNDEV;	/* unrecognized device pathName */
	end;
	nullName = TRUE;
	i = 1;
	do while i < 7;
		if NonTerminator then
		do;
			pnStr(i) = Uppercase(pathName(0));
			if pathName(0) = '*' then
				do while i < 7;
					wcFlag = TRUE;
					pnStr(i) = '*';
					i = i + 1;
				end;
			else if pathName(0) = '?' then
				wcFlag = TRUE;
			pathNamePtr = pathNamePtr + 1;
			nullName = FALSE;
		end;
		i = i + 1;
	end;
	if pathName(0) = '.' then
	do;
		pathNamePtr = pathNamePtr + 1;
		i = 7;
		do while i < 10;
			if NonTerminator then
			do;
				pnStr(i) = Uppercase(pathName(0));
				if pathName(0) = '*' then
					do while i < 10;
						wcFlag = TRUE;
						pnStr(i) = '*';
						i = i + 1;
					end;
				else if pathName(0) = '?' then
					wcFlag = TRUE;
				pathNamePtr = pathNamePtr + 1;
			end;
			i = i + 1;
		end;
	end;
	if TestRange(pnStr(0), 1) <= 9 and nullName then
		return MISSINGFNAME;	/*  missing filename */
	pl = 0FFh;
	do while ptr < pathNamePtr;
		lastPathNameParsed(pl := pl + 1) = ch;
		ptr = ptr + 1;
	end;
	if lastPathNameParsed(pl) = '.' then
		return MISSINGEXT;	/* missing extension */
	lastPathNameParsed(pl + 1) = ' ';
	if NonTerminator or pathName(0) = '.' or pathName(0) = ':' then
		return BADFILESPEC;	/* incorrectly specified file */
	return NOERROR;
end;
end;
?wrtdir.plm
WriteDirectory: do;
declare mapBase address external;

declare maskArray(1) byte external;

SetBlock: procedure(adr) external; declare adr address; end;

ClearBuf: procedure(buf$ptr) external; declare buf$ptr address; end;

Absio: procedure(cmd, disk, block, buffer) external;
         declare cmd byte, disk byte, block address, buffer address; end;

MoveAscii: procedure(dst, src, cnt) external; declare dst address, src address, cnt byte; end;

declare diskType byte external;

declare bitmap based mapBase (1) byte;

declare dirFile(9) byte data ('ISIS',0,0,'DIR'),
	mapFile(9) byte data ('ISIS',0,0,'MAP'),
	t0File(9) byte data ('ISIS',0,0,'T0',0),
	binFile(9) byte data ('ISIS',0,0,'BIN'),
	labFile(9) byte data ('ISIS',0,0,'LAB'),
	badFile(9) byte data ('ISIS',0,0,'BAD');

WriteDirectory: procedure(disk) public;
	declare	disk byte, binIdx byte, i byte, jj address, dirBuf(64) address,
		direct(8) structure(empty byte, file(9) byte, attrib byte,
				    eof$count byte, blk address, hdrBlk address) at(.dirBuf),
		countBitMapSectors byte, binHdrBlk address, countDirSectors byte;

	SetLinks: procedure(start, count, firstBlock);
		declare (start, count, firstBlock, ii) address;

		do ii = 0 to count - 1;
			dirBuf(start + ii) = firstBlock + ii;
			call setBlock(firstBlock + ii);
		end;
	end;

	FlushBlock: procedure(adr);
		declare adr address;

		call Absio(6, disk, adr, .dirBuf);
		call SetBlock(adr);
		call ClearBuf(.dirBuf);
	end;

	countDirSectors =  25;
	if diskType = 1 then
	do;
		countBitMapSectors = 4;
		binHdrBlk = 206h;
	end;
	else if diskType = 4 then
	do;
		countBitMapSectors = 29;
		binHdrBlk = 21fh;
		countDirSectors = 62;
	end;
	else
	do;
		countBitMapSectors = 2;
		binHdrBlk = 204h;
	end;

	jj = .bitmap - 128;
	if diskType = 4 then
		do i = 0 to countBitMapSectors - 1;
			call Absio(6, disk, i + 74h, (jj := jj + 128));
		end;
	/* set linkage for isis.t0 */
	call ClearBuf(.dirBuf);
	call SetLinks(2, 23, 1);
	call FlushBlock(18h);		
	/* set linkage for isis.lab */
	if diskType = 4 then		/* hard disk */
	do;
		dirBuf(1) = 58h;	/* next linkage is sector 58h */
		call SetLinks(2, 3Eh, 1Ah);	/* first part of isis.lab */ 
	end;
	else if diskType = 1 then
	do;
		call SetLinks(2, 27, 1Ah);	/* allocate 53 blocks in 2 groups */
		call SetLinks(1Dh, 26, 11Bh);
	end;
	else
		call SetLinks(2, 1, 1Ah);	/* allocate 1 block */

	call FlushBlock(19h);		/* write label linkage */
	if diskType = 4 then
	do;
		dirBuf(0) = 19h;	/* link to previous */
		call SetLinks(2, 26, 59h);
		call SetLinks(1ch, 9, 140h);
		call SetLinks(25h, 9, 188h);
		call FlushBlock(58h);	/* write label linkage */
	end;
	/* set linkage for isis.bad for hd only */
	if diskType = 4 then
	do;
		call SetLinks(2, countBitMapSectors, 74h);
		call FlushBlock(73h);
	end;

	/* set linkage for isis.dir */
	call SetLinks(2, countDirSectors, 102h);
	if diskType = 4 then
		dirBuf(1) = 149h;	/* link to next */
	call FlushBlock(101h);
	if diskType = 4 then
	do;
		dirBuf(0) = 101h;	/* link to previous */
		call SetLinks(2, countDirSectors, 14Ah);
		call FlushBlock(149h);
	end;

	/* set linkage for isis.map */
	call SetLinks(2, countBitMapSectors, 202h);
	call FlushBlock(201h);
	call FlushBlock(binHdrBlk);

	/* isis.dir */
	call MoveAscii(.direct(0).file, .dirFile, 9);
	if diskType = 4 then
		direct(0).blk = 124;	/* larger size */
	else
		direct(0).blk = 25;

	direct(0).hdrBlk = 101h;	/* linkage at t1 s1 */
	direct(0).attrib = 1;
	direct(0).eof$count = 128;

	/* isis.map */
	call MoveAscii(.direct(1).file, .mapFile, 9);
	direct(1).blk = countBitMapSectors;
	direct(1).hdrBlk = 201h;	/* linkage at t2 s1 */
	direct(1).attrib = 1;
	direct(1).eof$count = 128;

	/* isis.t0 */
	call MoveAscii(.direct(2).file, .t0File, 9);
	direct(2).blk = 17h;
	direct(2).hdrBlk = 18h;		/* linkage at t0 s24 */
	direct(2).attrib = 1;
	direct(2).eof$count = 128;

	/* isis.lab */
	call MoveAscii(.direct(3).file, .labFile, 9);
	if diskType = 1 then
		direct(3).blk = 35h;
	else if diskType = 4 then
		direct(3).blk = 6Ah;
	else
		direct(3).blk = 1;
	direct(3).hdrBlk = 19h;		/* linkage at t0 s25 */
	direct(3).attrib = 1;
	direct(3).eof$count = 128;

	/* isis.bad */
	if diskType = 4 then
	do;
		call MoveAscii(.direct(4).file, .badFile, 9);
		direct(4).blk = countBitMapSectors;
		direct(4).hdrBlk = 73h;
		direct(4).attrib = 1;
		direct(4).eof$count = 128;
		binIdx = 5;
	end;
	else
		binIdx = 4;

	/* isis.bin */
	call MoveAscii(.direct(binIdx).file, .binFile, 9);
	direct(binIdx).hdrBlk = binHdrBlk;
	direct(binIdx).attrib = 3;
	direct(binIdx).eof$count = 128;

	/* flag as no further entries */
	do i = binIdx + 1 to 7;
		direct(i).empty = 7fh;
	end;

	call FlushBlock(102h);
	do i = 0 to 7;
		direct(i).empty = 7fh;
	end;

	do i = 1 to countDirSectors - 1;
		call Absio(6, disk, 102h + i, .dirBuf);
	end;

	if diskType = 4 then
		do i = 0 to countDirSectors - 1;
			call Absio(6, disk, 14Ah + i, .dirBuf);
		end;

	jj = .bitmap - 128;
	do i = 0 to countBitMapSectors - 1;
		call Absio(6, disk, 202h + i, (jj := jj + 128));
	end;
end;
end;

?ypath.plm
ypath: do;
declare devTab(*) byte data('F0F1F2F3F4F5TITOVIVO',
		            'I1O1TRHRR1R2TPHPP1P2',
			    'LPL1BBCICOF6F7F8F9');


ypath: procedure(int$p, ext$p) public;
	declare (int$p, ext$p) address;
	declare i byte;
	declare intName based int$p (1) byte,
		extName based ext$p (1) byte;

	extName(0) = ':';
	i = intName(0);
	/* map internal device to formal device index */
	if i > 9 then
		i = i - 4;
	else if i > 5 then
		i = i + 19;

	extName(1) = devTab(i + i);
	extName(2) = devTab(i + i + 1);
	extName(3) = ':';
	ext$p = ext$p + 4;

	do i = 0 to 5;
		if (extName(0) := intName(i + 1)) <> 0 then
			ext$p = ext$p + 1;
	end;
	if intName(7) <> 0 then
	do;
		extName(0) = '.';
		ext$p = ext$p + 1;
	end;
	do i = 0 to 2;
		if (extName(0) := intName(i + 7)) <> 0 then
			ext$p = ext$p + 1;
	end;
	extName(0) = ' ';
end;
end;

cusp6/makefile
# common makefile info
ROOT=../../..
TARGETS=cusp6.lib
unexport ISIS_F1

include $(ROOT)/tools/isis.mk
PLM80 = 3.1
PLMFLAGS = code
REF = $(call ipath,toolbox,1.0)

OBJS =	alloc.obj direct.obj absio.obj clrbuf.obj chklab.obj d.obj\
	dblank.obj diskio.obj dlimit.obj dmeq.obj dtype.obj ferror.obj\
	fmttrk.obj forupp.obj getdsk.obj getlab.obj mvasci.obj\
	monitr.obj meq.obj numout.obj path.obj popula.obj reperr.obj\
	scanin.obj serror.obj seq.obj setblk.obj setmap.obj\
	tabwrt.obj trange.obj upcase.obj unpath.obj wrtdir.obj\
	wdlmt.obj wpath.obj ypath.obj cpyrit.obj

all::
	$(MAKE) $(TARGETS)

# verify will fail due to module MONITOR

.IGNORE: verify
cusp6.lib: $(OBJS)
	$(call lib,$@,$^)

cusp7/cusp7_all.src
?cpyrit.plm
COPYRIGHT: DO;
end;
?dblank.plm
DEBLANK: DO;
deblank: procedure(ptr) address public;
	declare ptr address, c based ptr byte;

	do while (c = ' ');
		ptr = ptr + 1;
	end;
	return ptr;
end;

end;
?dlimit.plm
DELIMIT: DO;
delimit: procedure(ptr) address public;
	declare ptr address, ch based ptr byte;

	do while ch = ':' or ch = '.' or
		 ('0' <= ch and ch <= '9') or
		 ('A' <= ch and ch <= 'Z');
		ptr = ptr + 1;
	end;
	return ptr;
end;
end;
?dmeq.plm
DMEQ: DO;
declare TRUE	literally '0FFH',
	FALSE	literally '0';

read: procedure (conn, buff$p, count, actual$p, status$p) external;
    declare (conn, buff$p, count, actual$p, status$p) address;
end read;

seek: procedure (conn, mode, block$p, byte$p, status$p) external;
    declare (conn, mode, block$p, byte$p, status$p) address;
end seek;

meq: procedure(A, B) byte external ; declare (A,B) address; end;

ReportError: procedure(errNum) external;
	declare errNum address;
end;

declare diskType byte external;

declare DIRMAX	literally '201';
declare HDDIRMAX literally '993';
declare HDTYPE	literally '4';
declare DIRSIZE literally '16';
declare OK	literally '0';

dmeq: procedure (dirAftn, searchArg, initialINo, dirEntry) address public;
    declare (dirAftn, searchArg, initialINo, dirEntry) address;
    declare (byteNo, blockNo) address;
    declare (actual, status) address;
    declare pastDir address;
    declare searching byte;
    declare dirFlag based dirEntry byte;

	if diskType = HDTYPE then	/* hard disk */
		pastDir = HDDIRMAX;
	else
		pastDir = DIRMAX;
	if pastDir - 1 <= initialINo then
		return pastDir;
	blockNo = 0;
	byteNo = initialINo * DIRSIZE;
	call seek(dirAftn, 2, .blockNo, .byteNo, .status);

	if status <> OK then
		call ReportError(status);
	
	searching = TRUE;
	do while searching;
		call read(dirAftn, dirEntry, DIRSIZE, .actual, .status);
		if dirFlag = 7Fh or actual = 0 then
			return pastDir;
		searching = not meq(searchArg, dirEntry);
		initialINo = initialINo + 1;
	end;

	return initialINo;
end;
end;
?ferror.plm
FILEERROR: DO;

write: procedure (conn, buff$p, count, actual$p) external;
    declare (conn, buff$p, count, actual$p) address;
end write;

exit: procedure external; end exit;

deblank: procedure(str) address external; declare str address; end;
WDelimit: procedure(ptr) address external; declare ptr address; end;
reporterror: procedure(status) external; declare status address; end;

declare OK literally '0';

fileerror: procedure(status, ptr, callExit) public;
	declare (status, ptr) address;
	declare callExit byte;
	declare actual address;

	if status <> OK then
	do;
		ptr = deblank(ptr);
		call write(0, .(' '), 1, .actual);
		call write(0, ptr, WDelimit(ptr) - ptr, .actual);
		call write(0, .(','), 1, .actual);
		call reporterror(status);
		if callExit then
			call exit;
	end;
end;
end;
?forupp.plm
FORCEUPPER: DO;
declare CR literally '0DH';

uppercase: procedure(ch) byte external; declare ch byte; end;

forceupper: procedure(bufferPtr) public;
	declare bufferPtr address, ch based bufferPtr byte;

	do while ch <> CR;
		ch = uppercase(ch);
		bufferPtr = bufferPtr + 1;
	end;
end;
end;
?meq.plm
MEQ: DO;
declare TRUE literally '0ffh';

meq: procedure(mPtr, fptr) byte public;
	declare (mPtr, fptr) address, i byte;
	declare m based mPtr (10) byte;
	declare f based fptr (10) byte;

	do i = 0 to 9;
		if m(i) = '?' then
		do;
			if f(i) = 0 then
				return 0;
		end;
		else if m(i) <> '*' then
		do;
			if m(i) <> f(i) then
				return not TRUE;
		end;
	end;
	return TRUE;
end;
end;

?numout.plm
NUMOUT: DO;


numout: procedure(value, base, lc, bufAdr, width) public;
	declare (value, bufAdr) address, (base, lc, width) byte; 
	declare i byte;
	declare buf based bufAdr (1) byte;
	declare digits(*) byte data('0123456789ABCDEF');

	do i = 1 to width;
		buf(width - i) = digits(value mod base);
		value = value / base;	
	end;

	i = 0;
	do while buf(i) = '0' and i < width - 1;
		buf(i) = lc;
		i = i + 1;
	end;
end;
end;
?popula.plm
population: do;

declare bitCnt(*) byte initial(
	0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,
	1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
	1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
	1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
	3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
	1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
	3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
	3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
	3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
	4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8);

Population: procedure(bufferLoc, length) address public;
	declare (bufferLoc, length, total) address,
	(i, t, l) byte;
	declare buffer based bufferLoc (1) byte;

	total = 0;
	do while length > 31;
		t = 0;
		do i = 0 to 30;
			t = t + bitCnt(buffer(i));
		end;
		total = total + t;
		bufferLoc = bufferLoc + 31;
		length = length - 31;
	end;
	l = length - 1;
	t = 0;
	do i = 0 to l;
		t = t + bitCnt(buffer(i));
	end;
	return total + t;
end;
end;
?reperr.plm
REPORTERROR: DO;

error: procedure(errNum) external; declare errNum address; end;

write: procedure(aftn, buf$ptr, len, status$ptr) external;
   declare (aftn, buf$ptr, len, status$ptr) address;
end write;

declare CR	literally '0dh';
declare LF	literally '0ah';

reporterror: procedure(errNum) public;
	declare errNum address;
	declare numberBuffer(3) byte;
	declare (i, status) address;
 
	declare msg(*) byte DATA(0, 0,
		2, 'ILLEGAL AFTN ARGUMENT', 0,
		4, 'INCORRECTLY SPECIFIED FILE', 0,
		5, 'UNRECOGNIZED DEVICE NAME', 0,
		6, 'ATTEMPT TO WRITE TO INPUT DEVICE', 0,
		8, 'ATTEMPT TO READ FROM OUTPUT DEVICE', 0,
		9, 'DISK DIRECTORY FULL', 0,
		0AH, 'NOT ON SAME DISK', 0,
		0BH, 'FILE ALREADY EXISTS', 0,
		0CH, 'FILE IS ALREADY OPEN', 0,
		0DH, 'NO SUCH FILE', 0,
		0EH, 'WRITE PROTECTED', 0,
		11H, 'NOT A DISK FILE', 0,
		12H, 'ILLEGAL ISIS COMMAND', 0,
		13H, 'ATTEMPTED SEEK ON NON-DISK FILE', 0,
		14H, 'ATTEMPTED BACK SEEK TOO FAR', 0,
		15H, 'CAN''T RESCAN', 0,
		16H, 'ILLEGAL ACCESS MODE TO OPEN', 0,
		17H, 'MISSING FILENAME', 0,
		19H, 'ILLEGAL ECHO FILE', 0,
		1AH, 'ILLEGAL ATTRIBUTE IDENTIFIER', 0,
		1BH, 'ILLEGAL SEEK COMMAND', 0,
		1CH, 'MISSING EXTENSION', 0,
		1FH, 'CAN''T SEEK ON WRITE ONLY FILE', 0,
		20H, 'CAN''T DELETE OPEN FILE', 0,
		23H, 'SEEK PAST EOF', 0,
		0C9H, 'UNRECOGNIZED SWITCH', 0,
		0CAH, 'UNRECOGNIZED DELIMITER', 0,
		0CBH, 'INVALID SYNTAX', 0,
		0CCH, 'PREMATURE EOF', 0,
		0CEH, 'ILLEGAL DISKETTE LABEL', 0,
		0D0H, 'CHECKSUM ERROR', 0,
		0D1H, 'RELO FILE SEQUENCE ERROR', 0,
		0D2H, 'INSUFFICIENT MEMORY', 0,
		0D3H, 'RECORD TOO LONG', 0,
		0D4H, 'ILLEGAL RELO RECORD', 0,
		0D5H, 'FIXUP BOUNDS ERROR', 0,
		0D6H, 'ILLEGAL SUBMIT PARAMETER', 0,
		0D7H, 'ARGUMENT TOO LONG', 0,
		0D8H, 'TOO MANY PARAMETERS', 0,
		0D9H, 'OBJECT RECORD TOO SHORT', 0,
		0DAH, 'ILLEGAL RECORD FORMAT', 0,
		0DBH, 'PHASE ERROR', 0,
		0EAH, 'CANNOT FORMAT FROM TARGET DRIVE', 0,
		0EBH, 'NON-DISK DEVICE', 0
		);


	if errNum <> 0 then
	do;
		i = 0;
		do while i < size(msg);
			if errNum = msg(i) and msg(i + 1) <> 0 then
			do;
				i = i + 1;
				call write(0, .(' '), 1, .status);
				do while msg(i) <> 0;
					call write(0, .msg(i), 1, .status);
					i = i + 1;
				end;
				call write(0, .(CR, LF), 2, .status);
				return;
			end;
			else
			do;
				do while msg(i) <> 0;
					i = i + 1;
				end;
				i = i + 1;
			end;
		end;
	call error(errNum);
	end;
end;
end;
?scanin.plm
scanIn: do;


ScanInteger: procedure(ptrPtr) address public;
	declare ptrPtr address;
	declare ptr based ptrPtr address;
	declare (scanPtr, updatePtr, stopPtr) address;
	declare (i, radix, increment) byte;
	declare (nVal, oVal) address;
	declare c based scanPtr byte;
	declare digits(*) byte data('0123456789ABCDEF');

	scanPtr = ptr;
	do while c = ' ';
		scanPtr = scanPtr + 1;
	end;
	ptr = scanPtr;
	do while '0' <= c and c <= '9' or 'A' <= c and c <= 'F';
		scanPtr = scanPtr + 1;
	end;

	updatePtr = (stopPtr := scanPtr) + 1;
	if c = 'H' then
		radix = 16;
	else if c = 'O' or c = 'Q' then
		radix = 8;
	else
	do;
		stopPtr, scanPtr = (updatePtr := scanPtr) - 1;
		if c = 'B' then
			radix = 2;
		else
		do;
			radix = 10;
			if c <> 'D' then	/* include last increment */
				stopPtr = stopPtr + 1;
		end;
	end;
	scanPtr = ptr;
	nVal, oVal = 0;
	do while scanPtr < stopPtr;
		do i = 0 to 15;
			if c = digits(i) then
				increment = i;
		end;
		if increment >= radix then
			return 0;
		nVal = oVal * radix + increment;
		if nVal < oVal then
			return 0;
		oVal = nVal;
		scanPtr = scanPtr + 1;
	end;
	ptr = updatePtr;
	return nVal;
end;
end;
?seq.plm
SEQ: DO;

declare TRUE literally '0ffh';

seq: procedure(s1, s2, len) byte public;
	declare (s1,s2) address, (len, i) byte;
	declare s1a based s1(1) byte;
	declare s2a based s2(1) byte;

	len = len - 1;
	do i = 0 to len;
		if s1a(i) <> s2a(i) then
			return not TRUE;
	end;
	return TRUE;
end;
end;
?tabwrt.plm
TABWRITE: DO;

declare TAB	literally '9',
	CR	literally '0dh';

write: procedure (aft, buff$p, count, status) external;
    declare (aft, buff$p, count, status) address;
end write;

tabwrite: procedure(columnPtr, aft, bufferPtr, count, status) public;
	declare (columnPtr, aft, bufferPtr, count, status) address;
	declare (printChar, i, j) byte;
	declare column based columnPtr byte;
	declare ch based bufferPtr byte;

	do while count <> 0;
		i = ch = TAB and (7 - (column and 7));
		printChar = ch;
		bufferPtr = bufferPtr + 1;
		count = count - 1;
		if printChar = TAB then
			printChar = ' ';
		do j = 0 to i;
			if ch = CR then
				column = 0;
			if ch >= ' ' then
				column = column + 1;
			call write(aft, .printChar, 1, status);
		end;
	end;
end;
end;

?unpath.plm
UNPATH: DO;

declare devTab(*) byte data('F0F1F2F3F4F5TITO',
			    'VIVOI1O1TRHRR1R2',
			    'TPHPP1P2LPL1BBCICO',
			    'F6F7F8F9');

unpath:	procedure(int, ext) public;
	declare (int, ext) address, i byte;
	declare intName based int (1) byte;
	declare extName based ext (1) byte;

	extName(0) = ':';
	extName(1) = devTab(intName(0) + intName(0));
	extName(2) = devTab(intName(0) + intName(0) + 1);
	extName(3) = ':';	
	ext = ext + 4;
	do i = 0 to 5;
		if (extName(0) := intName(i + 1)) <> 0 then
			ext = ext + 1; 
	end;
	if intName(7) <> 0 then
	do;
		extName(0) = '.';
		ext = ext + 1;
	end;
	do i = 0 to 2;
		if (extName(0) := intName(i + 7)) <> 0 then
			ext = ext + 1; 

	end;
	extName(0) = ' ';
end;
end;
?upcase.plm
UPPERCASE: DO;
declare UCMASK literally '0dfh';

uppercase: procedure(char) byte public;
	declare char byte;
	if char < 'a' then
		return char;
	if char > 'z' then
		return char;
	return char and UCMASK;
end;
end;
?wdlmt.plm
WDELIMIT: DO;
/* b1=01, b2=31, CODE(63H) byte, DATA(2H) byte, STACK(4H) byte, MEMORY(0H) byte,*/
wdelimit: procedure(ptr) address public;
	declare ptr address, ch based ptr byte;

	do while (ch = ':' or ch = '.' or ch = '*' or ch = '?' or
		  ('0' <= ch and ch <= '9') or ('A' <= ch and ch <= 'Z'));
		ptr = ptr + 1;
	end;
	return ptr;
end;
end;

?wpath.plm
WPATH: DO;
uppercase: procedure(char) byte external;
	declare char byte;
end;

TestRange: procedure(device, buffer$p) byte external;
	declare device byte, buffer$p address;
end;

declare FALSE literally '0';
declare TRUE literally '0FFh';


declare lastPathNameParsed(15) byte;

/* the error return codes */
declare BADFILESPEC	literally '4';
declare UNKNOWNDEV	literally '5';
declare MISSINGFNAME	literally '17h';
declare MISSINGEXT	literally '1ch';
declare NOERROR		literally '0';

declare devTab(*) byte data('F0F1F2F3F4F5TITOVIVOI1O1',
			    'TRHRR1R2TPHPP1P2LPL1BBCICOF6F7F8F9');

WPath: procedure(pathNamePtr, pn, wc) byte public;
	declare (pathNamePtr, pn, wc) address;
	declare ptr address;
	declare	addr address, (hi, lo) byte at (.addr);
	declare	devPtr address, (nullName, pl, i) byte;
	declare pathName based pathNamePtr (1) byte;
	declare pnStr based pn (1) byte;
	declare wcFlag based wc byte;
	declare dev based devPtr address;
	declare ch based ptr byte;
	
	NonTerminator: procedure byte;
		return ('A' <= pathName(0) and pathName(0) <= 'Z') or
		       ('0' <= pathName(0) and pathName(0) <= '9') or
		       pathName(0) = '?' or pathName(0) = '*' or
		       ('a' <= pathName(0) and pathName(0) <= 'z');
	end;
	wcFlag = FALSE;
	devPtr = .devTab;
	do i = 0 to 9;
		pnStr(i) = 0;
	end;
	do while pathName(0) = ' ';
		pathNamePtr = pathNamePtr + 1;
	end;

	ptr = pathNamePtr;
	if pathName(0) = ':' then
	do;
		if pathName(3) <> ':' then
			return BADFILESPEC;	/* incorrectly specified file */
		pathNamePtr = pathNamePtr + 1;
		hi = Uppercase(pathName(0));
		pathNamePtr = pathNamePtr + 1;
		lo = Uppercase(pathName(0));
		pathNamePtr = pathNamePtr + 2;
		pnStr(0) = 0FFh;
		i = 0;
		do while i < 57;
			if dev = addr then
				pnStr(0) = shr(i, 1);
			i = i + 2;
			devPtr = devPtr + 2;
		end;
		if pnStr(0) = 0FFh then
			return UNKNOWNDEV;	/* unrecognized device pathName */
	end;
	nullName = TRUE;
	i = 1;
	do while i < 7;
		if NonTerminator then
		do;
			pnStr(i) = Uppercase(pathName(0));
			if pathName(0) = '*' then
				do while i < 7;
					wcFlag = TRUE;
					pnStr(i) = '*';
					i = i + 1;
				end;
			else if pathName(0) = '?' then
				wcFlag = TRUE;
			pathNamePtr = pathNamePtr + 1;
			nullName = FALSE;
		end;
		i = i + 1;
	end;
	if pathName(0) = '.' then
	do;
		pathNamePtr = pathNamePtr + 1;
		i = 7;
		do while i < 10;
			if NonTerminator then
			do;
				pnStr(i) = Uppercase(pathName(0));
				if pathName(0) = '*' then
					do while i < 10;
						wcFlag = TRUE;
						pnStr(i) = '*';
						i = i + 1;
					end;
				else if pathName(0) = '?' then
					wcFlag = TRUE;
				pathNamePtr = pathNamePtr + 1;
			end;
			i = i + 1;
		end;
	end;
	if TestRange(pnStr(0), 1) <= 9 and nullName then
		return MISSINGFNAME;	/*  missing filename */
	pl = 0FFh;
	do while ptr < pathNamePtr;
		lastPathNameParsed(pl := pl + 1) = ch;
		ptr = ptr + 1;
	end;
	if lastPathNameParsed(pl) = '.' then
		return MISSINGEXT;	/* missing extension */
	lastPathNameParsed(pl + 1) = ' ';
	if NonTerminator or pathName(0) = '.' or pathName(0) = ':' then
		return BADFILESPEC;	/* incorrectly specified file */
	return NOERROR;
end;
end;
cusp7/makefile
ROOT=../../..
TARGETS = cusp7.lib
unexport ISIS_F1

include $(ROOT)/tools/isis.mk

REF = $(call ipath,toolbox,1.0)
PLMFLAGS = CODE DEBUG
PLM80 = 3.1

OBJS = dblank.obj dlimit.obj dmeq.obj ferror.obj forupp.obj meq.obj numout.obj\
       popula.obj reperr.obj scanin.obj seq.obj tabwrt.obj upcase.obj\
       unpath.obj wdlmt.obj wpath.obj cpyrit.obj

all::
	$(MAKE) $(TARGETS)

cusp7.lib: $(OBJS)
	$(call lib,$@,$^)

fnames/fnames_all.src
?cons5.plm
CONS5: DO;
/* b1=01, b2=31, CODE(2FH) byte, DATA(4AH) byte, STACK(2H) byte, MEMORY(0H) byte,*/
SETOB: procedure(ZZ1) external; declare (ZZ1) address; end;
OUTFILENAME: procedure(ZZ1) external; declare (ZZ1) address; end;
OUTCHAR: procedure(ZZ1) external; declare (ZZ1) byte; end;
OUTBLANK: PROCEDURE external; end;
OUTPRINT: procedure(ZZ1) external; declare (ZZ1) address; end;
ERRORMESSAGE: procedure(ZZ1) external; declare (ZZ1) address; end;

DECLARE BUF(*) BYTE INITIAL('FILE ERROR, '),
	NAMEBUF(58) BYTE;

FILEERRORMESSAGE: PROCEDURE(MSG, FNAME) public;
	DECLARE (MSG, FNAME) ADDRESS;

	call SETOB(.NAMEBUF);
	call OUTFILENAME(FNAME);
	call OUTCHAR('-');
	call OUTBLANK;
	call OUTPRINT(MSG);
	call ERRORMESSAGE(.BUF);
end;
end;
?driven.plm
DRIVEN: DO;
/* b1=01, b2=31, CODE(28H) byte, DATA(0H) byte, STACK(2H) byte, MEMORY(0H) byte,*/

setsc: procedure(a) external; declare a address; end;
declare scanp address external;
forcup: procedure byte external; end;
bumpscanp: procedure external; end;

drivenumber: procedure byte public;
	call setsc(scanp);
	if forcup <> ':' then
		return '0';
	call bumpscanp;
	if forcup <> 'F' then
		return 0C8H;
	call bumpscanp;
	return forcup;
end;
end;

?exroot.plm
EXROOT: DO;
/* b1=01, b2=31, CODE(3BH) byte, DATA(2H) byte, STACK(2H) byte, MEMORY(0H) byte,*/

SETSC: PROCEDURE(W) external;
	DECLARE W ADDRESS;
END;
SETOB: PROCEDURE(W) external;
	DECLARE W ADDRESS;
END;

DECLARE SCANP ADDRESS external;

FORCUP: PROCEDURE BYTE external;
END;

LTNMCH: PROCEDURE BYTE external;
END;
OUTSCANBYTE: PROCEDURE external;
END;
OUTCHAR: PROCEDURE(CH) external;
	DECLARE CH byte;
end;

EXTRACTROOT: PROCEDURE(W) public;
	DECLARE W ADDRESS;

	CALL SETSC(SCANP);
	CALL SETOB(W);
	if FORCUP = ':' then
		SCANP = SCANP + 4;
	do while LTNMCH;
		call OUTSCANBYTE;
	end;
	call OUTCHAR(0);
end;
end;

?input1.plm
INPUT1: DO;
/* b1=01, b2=31, CODE(3BH) byte, DATA(4H) byte, STACK(2H) byte, MEMORY(0H) byte,*/
FILEERRORMESSAGE: procedure(MSG,FILE) external; declare (MSG,FILE) address; end;
READI: procedure(ZZ1,ZZ2) external; declare (ZZ1,ZZ2) address; end;
declare ACTUAL address external;
declare FNAMEI address external;

READIWITHLIMIT: PROCEDURE(AFTN, CNT) public;
	declare (AFTN, CNT) address;

	call READI(AFTN, CNT);
	if ACTUAL = CNT then
	    call FILEERRORMESSAGE(.('FILE TOO BIG', 0), FNAMEI);
end;
end;

?newext.plm
NEWEXT: DO;
SETSC: procedure(ZZ1) external; declare (ZZ1) address; end;
SETOB: procedure(ZZ1) external; declare (ZZ1) address; end;
declare SCANP address external;
FILECH: procedure byte external; end;
FORCUP: procedure byte external; end;
OUTSCANBYTE: procedure external; end;
OUTCHAR: procedure(ZZ1) external; declare (ZZ1) byte; end;
OUTPRINT: procedure(ZZ1) external; declare (ZZ1) address; end;

NEWEXTENSION: procedure(FILENAME,EXT) public;
	declare (FILENAME,EXT) address;
	call SETSC(SCANP);
	call SETOB(FILENAME);
	do while FILECH and FORCUP <> '.';
		call OUTSCANBYTE;
	end;
	call OUTCHAR('.');
	call OUTPRINT(EXT);
	call OUTCHAR(0);
end;
end;

?out5.plm
OUT5: DO;

SCANWHILEBLANKS: procedure external; end;
FILECH: procedure byte external; end;
OUTCHAR: procedure(ZZ1) external; declare (ZZ1) byte; end;
SETSC: procedure(ZZ1) external; declare (ZZ1) address; end;
declare SCANP address external;


OUTFILENAME: procedure(FILENAME) public;
	declare (FILENAME) address;
	declare CH based SCANP byte;

	call SETSC(FILENAME);
	call SCANWHILEBLANKS;
	do while FILECH;
		call OUTCHAR(CH);
		SCANP = SCANP + 1;
	end;
end;
end;

?scan4.plm
SCAN4: DO;
/* b1=01, b2=31, CODE(90H) byte, DATA(6H) byte, STACK(4H) byte, MEMORY(0H) byte,*/
SCANWHILEBLANKS: procedure external; end;
SCANWHILE: procedure(PATH) external; declare (PATH) address; end;
FILECH: procedure byte external; end;
FORCUP: procedure byte external; end;
BUMPSCANP: procedure external; end;
ERRORMESSAGE: procedure(PATH) external; declare (PATH) address; end;
SCANEXPECT: procedure(PATH) external; declare (PATH) address; end;

declare FILENAMELIMIT byte public initial(15);


MOVEFILENAME: procedure(PATH) public;
	declare (PATH) address;
	declare CH based PATH byte;
	declare CHLEFT byte;
	
	CHLEFT = FILENAMELIMIT + 1;
	call SCANWHILEBLANKS;
	do while FILECH and (CHLEFT := CHLEFT - 1) > 0;
		CH = FORCUP;
		call BUMPSCANP;
		PATH = PATH + 1;
	end;
	if CHLEFT = 0 then
	do;
		call ERRORMESSAGE(.('FILE NAME TOO LONG', 0));
		call SCANWHILE(.FILECH);
	end;
	call SCANWHILEBLANKS;
	CH = 0;
end;

MOVEPARENSFILENAME: procedure(PATH) public;
	declare PATH address;

	call SCANWHILEBLANKS;
	call SCANEXPECT(.('(',0));
	call MOVEFILENAME(PATH);
	call SCANEXPECT(.(')',0));
	call SCANWHILEBLANKS;
end;
end;
?scan8.plm
SCAN8: DO;
/* b1=01, b2=31, CODE(4EH) byte, DATA(2H) byte, STACK(2H) byte, MEMORY(0H) byte,*/
FILECH: procedure byte external; end;
SCANUNTIL: procedure(ZZ1) external; declare (ZZ1) address; end;
declare SCANP address external;
declare SCANENDED byte external;
ERRORMESSAGE: procedure(STR) external; declare STR address; end;
SCANWHILE: procedure(FUNC) external; declare FUNC address; end;

OPENSCAN: procedure(FUNC) public;
	declare FUNC ADDRESS;

	call SCANUNTIL(.FILECH);
	if SCANENDED THEN
	    call ERRORMESSAGE(.('SCAN ERROR: FILE NAME EXPECTED', 0));
	call FUNC(SCANP, 3);
	call SCANWHILE(.FILECH);
end OPENSCAN;

end;
fnames/makefile
# common makefile info
ROOT=../../..
TARGETS = fnames.lib
unexport ISIS_F1

include $(ROOT)/tools/isis.mk

REF = $(call ipath,toolbox,1.0)

PLM80 = 3.1

OBJS = driven.obj exroot.obj cons5.obj scan4.obj newext.obj scan8.obj out5.obj input1.obj

all::
	$(MAKE) $(TARGETS)

fnames.lib: $(OBJS)
	$(call lib,$@,$^)
isis3/isis3_all.src
?attrib.plm
ATTRIB: DO;
/* b1=01, b2=10, CODE(1FH) byte, DATA(8H) byte, STACK(4H) byte, MEMORY(0H) byte,*/

isis: procedure (type, parameter$ptr) external;
    declare type byte,
            parameter$ptr address;
end isis;

attrib: procedure (path$p, attrib, on$off, status$p) public;
    declare (path$p, attrib, on$off, status$p) address;

	call isis(10, .path$p);
end attrib;
end;

?ci.asm
	name 	CI
	public	CI
	aseg
CI	equ	0F803H
	end

?close.plm
CLOSE: DO;
/* b1=01, b2=10, CODE(13H) byte, DATA(4H) byte, STACK(2H) byte, MEMORY(0H) byte,*/
isis: procedure (type, parameter$ptr) external;
    declare type byte,
            parameter$ptr address;
end isis;

close: procedure (conn, status$p) public;
    declare (conn, status$p) address;

    call isis(1, .conn);

end close;
end;
?co.asm
	name 	CO
	public	CO
	aseg
CO	equ	0F809H
	end

?consol.plm
CONSOL: DO;
/* b1=01, b2=10, CODE(1AH) byte, DATA(6H) byte, STACK(2H) byte, MEMORY(0H) byte,*/
isis: procedure (type, parameter$ptr) external;
    declare type byte,
            parameter$ptr address;
end isis;

consol: procedure (ci$p, co$p, status$p) public;
    declare (ci$p, co$p, status$p) address;

	call isis(8, .ci$p);
end consol;
end;
?csts.asm
	name 	CSTS
	public	CSTS
	aseg
CSTS	equ	0F812H
	end
?delete.plm
DELETE: DO;
/* b1=01, b2=10, CODE(13H) byte, DATA(4H) byte, STACK(2H) byte, MEMORY(0H) byte,*/
isis: procedure (type, parameter$ptr) external;
    declare type byte,
            parameter$ptr address;
end isis;

delete: procedure (path$p, status$p) public;
    declare (path$p, status$p) address;

	call isis(2, .path$p);
end delete;
end;
?error.asm
	name	ERROR
	extrn	ISIS
	public	ERROR

;		error: procedure (error$num) external;
;		    declare (error$num) address;
;		end error;

	cseg
error:	mvi	a,12
	lxi	h,statpt
	dcx	h
	mov	m,b	; save error$num
	dcx	h
	mov	m,c
	mov	c,a
	xchg
	jmp	isis	; call isis(12, .error$num)

	dseg
status:	ds	4	; memory to store status + error$num
statpt:	dw	status	; status$p

	end	

?exit.plm
EXIT: DO;
/* b1=01, b2=10, CODE(FH) byte, DATA(2H) byte, STACK(2H) byte, MEMORY(0H) byte,*/
isis: procedure (type, parameter$ptr) external;
    declare type byte,
            parameter$ptr address;
end isis;

exit: procedure public;
    declare dummyParam address;
    dummyParam = .dummyParam;
    call isis(9, .dummyParam);
end exit;
end;
?getatt.asm
	name	GETATT
	extrn	ISIS
	public	GETATT

; getatt: procedure(file$p, attrib$p, status$p) public;
;	declare (file$p, attrib$p, status$p) address;
; end;
	cseg
getatt:	mvi	a,17
	lxi	h,param+6
	dcx	h
	mov	m,d
	dcx	h
	mov	m,e
	dcx	h
	mov	m,b
	dcx	h
	mov	m,c
	pop	b
	pop	d
	dcx	h
	mov	m,d
	dcx	h
	mov	m,e
	push	b
	mov	c,a
	xchg
	jmp	ISIS	; call isis(6, .firstParam)

	dseg
param:	ds	6
	end;

?getd.asm
	name	GETD
	public	GETD

; getd: procedure(did, con$p, count, actual$p, table$p) public;
; 	declare (did, con$p, count, actual$p, table$p) address;
; end;
	cseg
getd:	jmp	0E800H
	end;
?iochk.asm
	name	IOCHK
	public	IOCHK
	aseg
IOCHK	equ	0F815H
	end

?iodef.asm
	name	IODEF
	public	IODEF
	aseg
IODEF	equ	0F81EH
	end

?ioset.asm
	name IOSET
	public IOSET
IOSET	equ	0F818H
	end
?isis.asm
	name	ISIS
	public	ISIS
	aseg
ISIS	equ	40H
	end

?lo.asm
	name	LO
	public	LO
	aseg
LO	equ	0F80FH
	end

?load.plm
LOAD: DO;
/* b1=01, b2=10, CODE(24H) byte, DATA(AH) byte, STACK(6H) byte, MEMORY(0H) byte,*/
isis: procedure (type, parameter$ptr) external;
    declare type byte,
            parameter$ptr address;
end isis;

load: procedure (path$p, load$offset, switch, entry$p, status$p) public;
    declare (path$p, load$offset, switch, entry$p, status$p) address;

    call isis(6, .path$p);
end load;
end;
?memck.asm
	name	MEMCK
	public	MEMCK
	cseg

memck:	call	0F81BH
	mov	h,b
	mov	l,a
	ret
	end

?open.plm
OPEN: DO;
/* b1=01, b2=10, CODE(24H) byte, DATA(AH) byte, STACK(6H) byte, MEMORY(0H) byte,*/

isis: procedure (type, parameter$ptr) external;
    declare type byte,
            parameter$ptr address;
end isis;

open: procedure (conn$p, path$p, access, echo, status$p) public;
    declare (conn$p, path$p, access, echo, status$p) address;
    call isis(0, .conn$p);
end open;
end;
?po.asm
	name	PO
	public	PO
	aseg
PO	equ	0F80CH
	end

?read.plm
READ: DO;
/* b1=01, b2=10, CODE(24H) byte, DATA(AH) byte, STACK(6H) byte, MEMORY(0H) byte,*/
isis: procedure (type, parameter$ptr) external;
    declare type byte,
            parameter$ptr address;
end isis;

read: procedure (conn, buff$p, count, actual$p, status$p) public;
    declare (conn, buff$p, count, actual$p, status$p) address;
    call isis(3, .conn);
end read;
end;
?rename.plm
RENAME: DO;
/* b1=01, b2=10, CODE(1AH) byte, DATA(6H) byte, STACK(2H) byte, MEMORY(0H) byte,*/
isis: procedure (type, parameter$ptr) external;
    declare type byte,
            parameter$ptr address;
end isis;

rename: procedure (old$p, new$p, status$p) public;
    declare (old$p, new$p, status$p) address;
    call isis(7, .old$p);
end rename;
end;
?rescan.plm
RESCAN: DO;
/* b1=01, b2=10, CODE(13H) byte, DATA(4H) byte, STACK(2H) byte, MEMORY(0H) byte,*/
isis: procedure (type, parameter$ptr) external;
    declare type byte,
            parameter$ptr address;
end isis;

rescan: procedure (conn, status$p) public;
    declare (conn, status$p) address;
    call isis(11, .conn);
end rescan;
end;
?ri.asm
	name	RI
	public	RI
	aseg
RI	equ	0F806H
	end;

?seek.plm
SEEK: DO;
/* b1=01, b2=10, CODE(24H) byte, DATA(AH) byte, STACK(6H) byte, MEMORY(0H) byte,*/
isis: procedure (type, parameter$ptr) external;
    declare type byte,
            parameter$ptr address;
end isis;

seek: procedure (conn, mode, block$p, byte$p, status$p) public;
    declare (conn, mode, block$p, byte$p, status$p) address;
    call isis(5, .conn);
end seek;
end;

?spath.plm
SPATH: DO;
/* b1=01, b2=31, CODE(21H) byte, DATA(6H) byte, STACK(2H) byte, MEMORY(0H) byte,*/
declare isis address data(40h);

spath: procedure (path$p, info$p, status$p) public;
    declare (path$p, info$p, status$p) address;
    call isis(14, .path$p);
end spath;
end;

?ui.plm
UI: DO;
/* b1=01, b2=31, CODE(0H) byte, DATA(0H) byte, STACK(0H) byte, MEMORY(0H) byte,*/
declare ui address public at (0F826H);
end;
?uo.plm
UO: DO;
/* b1=01, b2=31, CODE(0H) byte, DATA(0H) byte, STACK(0H) byte, MEMORY(0H) byte,*/
declare UO address public at (0F829H);
end;
?upps.plm
UPPS: DO;
/* b1=01, b2=31, CODE(0H) byte, DATA(0H) byte, STACK(0H) byte, MEMORY(0H) byte,*/
declare upps address public at (0F82CH);
end;
?v1p3.plm
V1P3: DO;
/* b1=01, b2=31, CODE(18H) byte, DATA(0H) byte, STACK(0H) byte, MEMORY(0H) byte,*/
declare libId(*) byte data('ISIS SYSTEM LIBRARY V1.3');
end;

?whocon.plm
WHOCON: DO;
/* b1=01, b2=10, CODE(19H) byte, DATA(6H) byte, STACK(2H) byte, MEMORY(0H) byte,*/
isis: procedure (type, parameter$ptr) external;
    declare type byte,
            parameter$ptr address;
end isis;

whocon: procedure (conn, buff$p) public;
    declare (conn, buff$p, dummy) address;
    dummy = .dummy;
    call isis(13, .conn);
end whocon;
end;

?write.plm
WRITE: DO;
/* b1=01, b2=10, CODE(1FH) byte, DATA(8H) byte, STACK(4H) byte, MEMORY(0H) byte,*/
isis: procedure (type, parameter$ptr) external;
    declare type byte,
            parameter$ptr address;
end isis;

write: procedure (conn, buff$p, count, status$p) public;
    declare (conn, buff$p, count, status$p) address;
    call isis(4, .conn);
end write;

end;

isis3/makefile
# common makefile info
ROOT=../../..
unexport ISIS_F1

TARGETS=isis3.lib
include $(ROOT)/tools/isis.mk
REF = $(call ipath,toolbox,1.0)

PLM80 = 3.1

PLMFLAGS=code optimize
ASMFLAGS=
OBJS=	attrib.obj ci.obj close.obj co.obj consol.obj csts.obj delete.obj\
	exit.obj iochk.obj iodef.obj ioset.obj isis.obj lo.obj load.obj\
	memck.obj open.obj po.obj read.obj rename.obj rescan.obj ri.obj\
	seek.obj whocon.obj write.obj ui.obj uo.obj upps.obj spath.obj\
	error.obj getatt.obj getd.obj v1p3.obj

all::
	$(MAKE) $(TARGETS)

isis3.lib: $(OBJS)
	$(call lib,$@,$^)
pff/makefile
ROOT = ../../..
TARGETS = pff.lib
unexport ISIS_F1

include $(ROOT)/tools/isis.mk

REF = $(call ipath,toolbox,1.0)
PLM80 = 3.1
PLMFLAGS = code

OBJS = 802403.obj ckstat.obj decdig.obj forcup.obj iform.obj isterm.obj\
       lgfile.obj errext.obj


all::
	$(MAKE) $(TARGETS)

pff.lib: $(OBJS)
	$(call lib,$@,$^)

pff/pff_all.src
?802403.plm
MARCH24TH1980: DO;
end;
?ckstat.plm
CKSTATMOD: DO;
attrib: procedure (path$p, attrib, on$off, status$p) external;
    declare (path$p, attrib, on$off, status$p) address;
end attrib;

close: procedure (conn, status$p) external;
    declare (conn, status$p) address;
end close;

ci: procedure byte external;
end ci;

co: procedure (char) external;
    declare (char) byte;
end co;

consol: procedure (ci$p, co$p, status$p) external;
    declare (ci$p, co$p, status$p) address;
end consol;

delete: procedure (path$p, status$p) external;
    declare (path$p, status$p) address;
end delete;

error: procedure (error$num) external;
    declare (error$num) address;
end error;

exit: procedure external;
end exit;

iochk: procedure byte external;
end iochk;

iodef: procedure (type, entry) external;
    declare type byte,
            entry address;
end iodef;

ioset: procedure (value) external;
    declare value byte;
end ioset;

load: procedure (path$p, load$offset, switch, entry$p, status$p) external;
    declare (path$p, load$offset, switch, entry$p, status$p) address;
end load;

memck: procedure address external;
end memck;

open: procedure (conn$p, path$p, access, echo, status$p) external;
    declare (conn$p, path$p, access, echo, status$p) address;
end open;

read: procedure (conn, buff$p, count, actual$p, status$p) external;
    declare (conn, buff$p, count, actual$p, status$p) address;
end read;

rename: procedure (old$p, new$p, status$p) external;
    declare (old$p, new$p, status$p) address;
end rename;

rescan: procedure (conn, status$p) external;
    declare (conn, status$p) address;
end rescan;

seek: procedure (conn, mode, block$p, byte$p, status$p) external;
    declare (conn, mode, block$p, byte$p, status$p) address;
end seek;

spath: procedure (path$p, info$p, status$p) external;
    declare (path$p, info$p, status$p) address;
end spath;

whocon: procedure (conn, buff$p) external;
    declare (conn, buff$p) address;
end whocon;

write: procedure (conn, buff$p, count, status$p) external;
    declare (conn, buff$p, count, status$p) address;
end write;

declare status address external;

CheckStatus: procedure public;
	if status <> 0 then
	do;
		call Error(status);
		call Exit;
	end;
end;
end;

?decdig.plm
DECDIGMOD: DO;

DecimalDigit: procedure(ch) byte  public;
	declare ch byte;

	return '0' <= ch and ch <= '9';
end;
end;
?errext.plm
ERREXTMOD: DO;
attrib: procedure (path$p, attrib, on$off, status$p) external;
    declare (path$p, attrib, on$off, status$p) address;
end attrib;

close: procedure (conn, status$p) external;
    declare (conn, status$p) address;
end close;

ci: procedure byte external;
end ci;

co: procedure (char) external;
    declare (char) byte;
end co;

consol: procedure (ci$p, co$p, status$p) external;
    declare (ci$p, co$p, status$p) address;
end consol;

delete: procedure (path$p, status$p) external;
    declare (path$p, status$p) address;
end delete;

error: procedure (error$num) external;
    declare (error$num) address;
end error;

exit: procedure external;
end exit;

iochk: procedure byte external;
end iochk;

iodef: procedure (type, entry) external;
    declare type byte,
            entry address;
end iodef;

ioset: procedure (value) external;
    declare value byte;
end ioset;

load: procedure (path$p, load$offset, switch, entry$p, status$p) external;
    declare (path$p, load$offset, switch, entry$p, status$p) address;
end load;

memck: procedure address external;
end memck;

open: procedure (conn$p, path$p, access, echo, status$p) external;
    declare (conn$p, path$p, access, echo, status$p) address;
end open;

read: procedure (conn, buff$p, count, actual$p, status$p) external;
    declare (conn, buff$p, count, actual$p, status$p) address;
end read;

rename: procedure (old$p, new$p, status$p) external;
    declare (old$p, new$p, status$p) address;
end rename;

rescan: procedure (conn, status$p) external;
    declare (conn, status$p) address;
end rescan;

seek: procedure (conn, mode, block$p, byte$p, status$p) external;
    declare (conn, mode, block$p, byte$p, status$p) address;
end seek;

spath: procedure (path$p, info$p, status$p) external;
    declare (path$p, info$p, status$p) address;
end spath;

whocon: procedure (conn, buff$p) external;
    declare (conn, buff$p) address;
end whocon;

write: procedure (conn, buff$p, count, status$p) external;
    declare (conn, buff$p, count, status$p) address;
end write;

declare status address external;

CheckStatus: procedure external; end;
IsisTerminator: procedure(ch) byte external; declare ch byte; end;

declare junk1(4) byte,
	junk2 address initial(0),
	junk3 address initial(0),
	junk4(130) byte,
	junk5 address initial(.junk4);

Printable: procedure(ch) byte;
	declare ch byte;
	return ch > 1Fh and ch < 7Fh;
end;

ErrorExit: procedure(str) public;
	declare str address;
	declare chrs based str (1) byte;
	declare i address;

	i = 0;
	do while i < 255 and Printable(chrs(i));
		i = i + 1;
	end;
	call Write(0, str, i, .status);
	call CheckStatus;
end;
end;
?forcup.plm
FORCUPMOD: DO;

Forcup: procedure(ptr, cnt) public;
	declare (ptr, cnt, i) address;
	declare chrs based ptr (1) byte;

	do i = 1 to cnt;
		if 'a' <= chrs(i) and chrs(i) <= 'z' then
			chrs(i) = chrs(i) - 20h;
	end;
end;
end;
?iform.plm
IFORMMOD: DO;

IsisTerminator: procedure(ch) byte external; declare ch byte; end;

InternalForm: procedure(ptr1, ptr2) public;
	declare (ptr1, ptr2) address;
	declare chrs1 based ptr1 (1) byte;
	declare chrs2 based ptr2 (1) byte;

	declare (i, j) byte;

	copyCh: procedure;
		chrs2(j) = chrs1(i);
		i = i + 1;
		j = j + 1;
	end;

	j = 0;
	i = 0;

	do while chrs1(i) <> '.' and not IsisTerminator(chrs1(i));
		call copyCh;
	end;

	if chrs1(i) = '.' then
	do;
		i = i + 1;
		j = 6;
		do while not IsisTerminator(chrs1(i));
			call copyCh;
		end;
	
	end;
end;
end;

?isterm.plm
ISTERMMOD: DO;

IsisTerminator: procedure(ch) byte public;
	declare ch byte;

	return not ('A' <= ch and ch <= 'Z'
		 or 'a' <= ch and ch <= 'z'
		 or '0' <= ch and ch <= '9'
		 or ch = ':' or ch = '.');
end;
end;

?lgfile.plm
LGFILEMOD: DO;

DecimalDigit: procedure(ch) byte external; declare ch byte; end;

declare TRUE literally '0ffh',
	FALSE literally '0';

LegitFilename: procedure(ptr) byte public;
	declare ptr address;
	declare i address;
	declare chrs based ptr (1) byte;

	isDisk: procedure byte;
		return chrs(1) =  'F' and DecimalDigit(chrs(2)) and chrs(3) = ':';
	end;

	isValidFileCh: procedure(ch) byte;
		declare ch byte;

		return '0' <= ch and ch <= '9' or 'A' <= ch and ch <= 'Z';
	end;

	declare k address;

	if chrs(0) = ':' then
	do;
		if not isDisk then
			return 0;
		ptr = ptr + 4;
	end;	
	i = 0;
	do while isValidFileCh(chrs(i));
		i = i + 1;
	end;
	if i > 6 or i = 0 or chrs(i) = ':' then
		return FALSE;

	if chrs(i) = '.' then
	do;
		k = (i := i + 1);
		do while isValidFileCh(chrs(i));
			i = i + 1;
		end;
		if chrs(i) = '.' or chrs(i) = ':' or i - k = 0 or i - k > 3 then
			return 0;
	end;
	return TRUE;
end;
end;

src/bltsym.asm
        NAME BLTSYM

;      '(C) Intel Corporation 1981'.  All rights reserved.  No
;      part of this program or publication may be reproduced,
;      transmitted, transcribed, stored in a retrievel system, or
;      translated into any language or computer language, in any
;      form or by any means, electronic, mechanical, magnetic,
;      optical, chemical, manual or otherwise, without the prior
;      written permission of Intel Corporation, 3065 Bowers
;      Avenue, Santa Clara, California, 95051, Attn: Software
;      License Administration.

; BLTSYM: A "BC IS LESS THAN DE" ROUTINE WHICH WORKS
;  ON INTERNAL RECORDS PRODUCED BY THE MERGE PROGRAM.

        CSEG
        PUBLIC BLTSYM

BLTSYM:
        MOV H,B
        MOV L,C
        MOV C,M
        INX H
        MOV B,M
        XCHG
        MOV E,M
        INX H
        MOV D,M
        XCHG
        INX B
        INX B
        INX H
        INX H
CRUISE:
        LDAX B
        CMP M
        JC TRUE
        JNZ FALSE
        CPI 0
        INX H
        INX B
        JNZ CRUISE
        MOV A,C
        SUB L
        MOV A,B
        SBB H
        SBB A
        RET
TRUE:
        MVI A,0FFH
        RET
FALSE:
        SUB A
        RET

        END
src/bsym86.asm
        NAME BLTSYM

;      '(C) Intel Corporation 1981'.  All rights reserved.  No
;      part of this program or publication may be reproduced,
;      transmitted, transcribed, stored in a retrievel system, or
;      translated into any language or computer language, in any
;      form or by any means, electronic, mechanical, magnetic,
;      optical, chemical, manual or otherwise, without the prior
;      written permission of Intel Corporation, 3065 Bowers
;      Avenue, Santa Clara, California, 95051, Attn: Software
;      License Administration.

; BLTSYM: A "BC IS LESS THAN DE" ROUTINE WHICH WORKS
;  ON INTERNAL RECORDS PRODUCED BY THE MERGE PROGRAM.

        CSEG
        PUBLIC BLTSYM

BLTSYM:
        MOV H,B
        MOV L,C
        MOV C,M
        INX H
        MOV B,M
        XCHG
        MOV E,M
        INX H
        MOV D,M
        XCHG
        INX B
        INX B
        INX B
        INX B
        INX H
        INX H
        INX H
        INX H
CRUISE:
        LDAX B
        CMP M
        JC TRUE
        JNZ FALSE
        CPI 0
        INX H
        INX B
        JNZ CRUISE
        MOV A,C
        SUB L
        MOV A,B
        SBB H
        SBB A
        RET
TRUE:
        MVI A,0FFH
        RET
FALSE:
        SUB A
        RET

        END
src/cdirec.plm
$TITLE('==>  C D I R E C  <==  CHKLOD')

CDIREC:
DO;

/************************************************************************/
/*																		*/
/*      '(C) Intel Corporation 1981'.  All rights reserved.  No			*/
/*      part of this program or publication may be reproduced,			*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

/*******  EXTERNALS  *******/

/*  SYS.LIB  */

DECLARE actual ADDRESS EXTERNAL;
DECLARE status ADDRESS EXTERNAL;
closei: PROCEDURE EXTERNAL; END;
ex: PROCEDURE EXTERNAL; END;
loadov: PROCEDURE (file$name$ptr) EXTERNAL; DECLARE file$name$ptr ADDRESS; END;
openi: PROCEDURE (file$name$ptr) EXTERNAL; DECLARE file$name$ptr ADDRESS; END;
readi: PROCEDURE (dst,count) EXTERNAL; DECLARE (dst,count) ADDRESS; END;
writec: PROCEDURE (src,count) EXTERNAL; DECLARE (src,count) ADDRESS; END;

/* UTIL.LIB  */

DECLARE obuf$p ADDRESS EXTERNAL;
DECLARE scan$p ADDRESS EXTERNAL;
error$message: PROCEDURE (ptr) EXTERNAL; DECLARE ptr ADDRESS; END;
out$crlf: PROCEDURE EXTERNAL; END;
out$print: PROCEDURE (ptr) EXTERNAL; DECLARE ptr ADDRESS; END;
scan$match: PROCEDURE (ptr) BYTE EXTERNAL; DECLARE ptr ADDRESS; END;

/* SYSTEM.LIB */

getd: PROCEDURE (dir$id,conn$p,count,actual$p,table$p,status$p) EXTERNAL;
  DECLARE (dir$id,conn$p,count,actual$p,table$p,status$p) ADDRESS; END;

/* CHKLOD.P80 */

DECLARE marked$file$names$ptrs (512) ADDRESS EXTERNAL;
DECLARE top$of$ram ADDRESS EXTERNAL;

/* CINVOK.P80 */

DECLARE spath$file$info (12) BYTE EXTERNAL;
file$error$msg: PROCEDURE (file$name$ptr, msg$ptr) EXTERNAL;
  DECLARE (file$name$ptr, msg$ptr) ADDRESS; END;
spath$check: PROCEDURE (msg$ptr) EXTERNAL; DECLARE msg$ptr ADDRESS; END;

/* CGREAT.P80 */

DECLARE has$greatest$numeric$ext (512) BYTE EXTERNAL;
DECLARE last$index ADDRESS EXTERNAL;
DECLARE no$discrepancies$found BYTE EXTERNAL;
numeric$extension: PROCEDURE ADDRESS EXTERNAL; END;

/*******  END OF EXTERNALS  *******/

DECLARE true  LITERALLY '0FFH',
        false LITERALLY '0',
        null  LITERALLY '0',
        blank LITERALLY '20H',
        CR    LITERALLY '0DH',
        LF    LITERALLY '0AH';

DECLARE floppy$dir$size  LITERALLY '3200',
        hd$dir$size      LITERALLY '15782';

DECLARE isis$dir$string (*) BYTE INITIAL (':F?:ISIS.DIR',0),
        new$name$ptr        ADDRESS INITIAL (.memory),
        not$out$of$memory   BYTE INITIAL (true),
        first$time          BYTE INITIAL (true),
        getd$conn           ADDRESS,
        reading$remote      BYTE,
        last$dir$byte       ADDRESS,
        dir$ptr             ADDRESS,
        dir$byte BASED dir$ptr BYTE,
        name$ptr            ADDRESS,
        name$byte BASED name$ptr BYTE,
        new$name$byte BASED new$name$ptr BYTE,
        greatest$dir$ext    ADDRESS,
        load$name$ptr       ADDRESS,
        i                   ADDRESS;

enough$room: PROCEDURE (bytes$needed, last$usable$byte) BYTE;
  DECLARE bytes$needed ADDRESS,
          last$usable$byte ADDRESS;

  IF (last$usable$byte - new$name$ptr) > bytes$needed THEN  /* enough room */
    RETURN true;
  /*  else not enough room  */
  not$out$of$memory = false;
  CALL writec (.(' *** RAN OUT OF MEMORY ***',CR,LF), 28);
  RETURN false;
END enough$room;

read$regular: PROCEDURE (count);
  DECLARE count ADDRESS;

  CALL openi (.isis$dir$string);
  CALL readi (new$name$ptr, count);
  reading$remote = false;
  last$dir$byte = new$name$ptr + actual;
  CALL closei;
END read$regular;

read$in$directory: PROCEDURE (drive$no);
  DECLARE drive$no BYTE;

  isis$dir$string(2) = drive$no;  /* drive$no is ASCII digit */
  scan$p = .isis$dir$string;  /* scan$p points to file name for spath$check */
  CALL spath$check (.('IS A BAD DIRECTORY NAME',0));
  IF spath$file$info(10) = 3 THEN  /* random access device */
    DO;
      IF spath$file$info(11) = 5 THEN  /* NDS-I remote HD */
        DO;
          IF enough$room (hd$dir$size, 0E800H) THEN  /* 0E800H is load addr */
            DO;                                      /* of ISIS.OV0         */
              CALL loadov (.(':F0:ISIS.OV0',0));  /* overlay for getd */
              getd$conn = 0;  /* required by getd */
              /* getd requires binary drive number */
              CALL getd (drive$no-'0', .getd$conn, 1024, .actual, new$name$ptr, .status);
              IF (status <> 0) OR (actual >= 1024) THEN
                CALL file$error$msg (.isis$dir$string, .('GETD ERROR!?!',0));
              reading$remote = true;
              last$dir$byte = new$name$ptr + (actual * 16);  /* actual is # of entries */
            END;
        END;
      ELSE IF spath$file$info(11) = 4 THEN  /* regular hard disk */
        DO;
          IF enough$room (hd$dir$size, top$of$ram) THEN
            CALL read$regular (hd$dir$size);
        END;
      ELSE  /* floppy */
        DO;
          IF enough$room (floppy$dir$size, top$of$ram) THEN
            CALL read$regular (floppy$dir$size);
        END;
    END;
  ELSE
    CALL file$error$msg (.isis$dir$string, .('NOT RANDOM ACCESS??',0));
END read$in$directory;

reformat$dir$names: PROCEDURE;

  /* reformat$dir$names finds all names with numeric extensions
     and recopies them in same form as load module names      */

  check$blank$and$move$char: PROCEDURE;
    IF name$byte = null THEN  /* change it to blank */
      new$name$byte = blank;
    ELSE new$name$byte = name$byte;
    name$ptr = name$ptr + 1;
    new$name$ptr = new$name$ptr + 1;
  END;

  dir$ptr = new$name$ptr - 16;
next$one:
  IF (dir$ptr := dir$ptr + 16) >= last$dir$byte THEN  /* read it all */
    RETURN;
  IF NOT reading$remote THEN  /* check presence byte */
    DO;
      IF dir$byte <> 0 THEN  /* either end of entries or inactive */
        DO;
          IF dir$byte = 7FH THEN
            RETURN;
          GO TO next$one;  /* must have been inactive */
        END;
    END;
  /* now pointing at next active entry
     check for numeric extension  */
  scan$p = dir$ptr + 7;  /* points at extension */
  IF numeric$extension = 0FFFFH THEN  /* not numeric */
    GO TO next$one;
  /* have a numeric extension, save the name
     reformat name to XXXXXX0XXX0, change zeroes to blanks  */
  name$ptr = dir$ptr + 1;  /* past presence byte */
  DO i = 1 TO 6;
    CALL check$blank$and$move$char;
  END;
  new$name$byte = null;  /* null after file name part */
  new$name$ptr = new$name$ptr + 1;
  DO i = 1 TO 3;
    CALL check$blank$and$move$char;  /* we know ext chars are not nulls, but */
  END;                               /* use check$blank$and$move$char anyway */
  new$name$byte = null;
  new$name$ptr = new$name$ptr + 6;  /* to next slot */
  GO TO next$one;
END reformat$dir$names;

process$a$directory: PROCEDURE (drive$no) PUBLIC;
  DECLARE drive$no       BYTE;

  CALL read$in$directory (drive$no);
  IF not$out$of$memory THEN
    CALL reformat$dir$names;
  ELSE not$out$of$memory = true;
END process$a$directory;

find$dir$name: PROCEDURE ADDRESS;
  DECLARE current$name$ptr ADDRESS,
          return$name$ptr  ADDRESS,
          ext$val          ADDRESS;

  return$name$ptr = 0;
  current$name$ptr = .memory;  /* beginning of reformatted names */
  greatest$dir$ext = 0;
  DO WHILE current$name$ptr < new$name$ptr;
    scan$p = current$name$ptr;
    IF scan$match (load$name$ptr) THEN
      DO;
        scan$p = current$name$ptr + 7;  /* point at extension */
        /* we know all extensions are numeric,
           no need to check for 0FFFFH case  */
        IF (ext$val := numeric$extension) >= greatest$dir$ext THEN
          DO;
            greatest$dir$ext = ext$val;
            return$name$ptr = current$name$ptr;
          END;
      END;
    current$name$ptr = current$name$ptr + 16; /* to next name */
  END; /* while */
  RETURN return$name$ptr;
END find$dir$name;

compare$dir$names: PROCEDURE PUBLIC;
  DECLARE out$buffer$ptr ADDRESS;
  DECLARE dir$name$ptr   ADDRESS;
  DECLARE load$name$ext  ADDRESS;
  DECLARE top$of$buffer  ADDRESS;

  flush$dir$info: PROCEDURE;
    CALL writec (out$buffer$ptr, obuf$p - out$buffer$ptr);
  END flush$dir$info;

  write$name$and$extension: PROCEDURE (source$mod);
    DECLARE source$mod BYTE;

    no$discrepancies$found = false;
    IF first$time THEN
      DO;
        CALL out$print (.(CR,LF,'VERSION DISCREPANCIES FOUND',CR,LF,0));
        first$time = false;
      END;
    CALL out$print (.(CR,LF,'SOURCENAME:                  ',0));
    CALL out$print (load$name$ptr);
    CALL out$crlf;
    CALL out$print (.('LOAD MODULE VERSION LEVEL:      ',0));
    CALL out$print (load$name$ptr + 7);
    CALL out$crlf;
    CALL out$print (.('SOURCE MODULE VERSION LEVEL:    ',0));
    IF source$mod THEN
      CALL out$print (dir$name$ptr + 7);
    ELSE CALL out$print (.('NONE',0));
    CALL out$crlf;
    IF obuf$p > top$of$buffer THEN
      DO;
        CALL flush$dir$info;
        obuf$p = out$buffer$ptr;
      END;
  END write$name$and$extension;

  IF (top$of$buffer := top$of$ram - 100H) < new$name$ptr THEN
    DO;
      CALL error$message
            (.('NOT ENOUGH MEMORY TO BUFFER DISCREPANCY INFO',CR,LF,0));
      CALL ex;
    END;
  obuf$p,
  out$buffer$ptr = new$name$ptr;  /* points after last rewritten entry */
  DO i = 0 TO last$index;
    IF has$greatest$numeric$ext (i) THEN  /* find same names in directory */
      DO;
        load$name$ptr = marked$file$names$ptrs (i);
        IF (dir$name$ptr := find$dir$name) = 0 THEN  /* didn't find one */
          CALL write$name$and$extension (false);
        ELSE  /* found one */
          DO;
            scan$p = load$name$ptr + 7;
            IF (load$name$ext := numeric$extension) <> greatest$dir$ext THEN
              CALL write$name$and$extension (true);
          END;
      END;
  END;
  IF no$discrepancies$found THEN
    CALL out$print (.(CR,LF,'NO DISCREPANCIES FOUND',CR,LF,0));
  CALL flush$dir$info;
END compare$dir$names;

END;
src/cgreat.plm
$TITLE('==>  C G R E A T  <==  CHKLOD')

CGREAT:
DO;

/************************************************************************/
/*																		*/
/*      '(C) Intel Corporation 1981'.  All rights reserved.  No			*/
/*      part of this program or publication may be reproduced,			*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

/*******  EXTERNALS  *******/

/*  UTIL.LIB  */

DECLARE obuf$p ADDRESS EXTERNAL;
DECLARE scan$p ADDRESS EXTERNAL;
ddigch: PROCEDURE BYTE EXTERNAL; END;
decin: PROCEDURE ADDRESS EXTERNAL; END;
forcup$string: PROCEDURE EXTERNAL; END;
out$chars: PROCEDURE (count,char) EXTERNAL; DECLARE (count,char) BYTE; END;
out$crlf: PROCEDURE EXTERNAL; END;
out$print: PROCEDURE (ptr) EXTERNAL; DECLARE ptr ADDRESS; END;
scan$match: PROCEDURE (ptr) BYTE EXTERNAL; DECLARE ptr ADDRESS; END;
scan$while: PROCEDURE (proc$addr) EXTERNAL; DECLARE proc$addr ADDRESS; END;

/*   SYS.LIB  */

writec: PROCEDURE (src,count) EXTERNAL; DECLARE (src,count) ADDRESS; END;

/* CSORT2.A80 */

sort: PROCEDURE (ptr,count,proc$addr) EXTERNAL;
  DECLARE (ptr,count,proc$addr) ADDRESS;
END;

/* CHKLOD.P80 */

DECLARE marked$file$names$ptrs (512) ADDRESS EXTERNAL;
DECLARE mfn$counter ADDRESS EXTERNAL;

/* CMOVEM.P80 */

movem: PROCEDURE (c,s,d) EXTERNAL; DECLARE (c,s,d) ADDRESS; END;

/*******  END OF EXTERNALS  *******/

DECLARE true  LITERALLY '0FFH',
        false LITERALLY '0',
        null  LITERALLY '0',
        CR    LITERALLY '0DH',
        LF    LITERALLY '0AH';

/*******  PUBLICS  *******/

DECLARE has$greatest$numeric$ext (512) BYTE PUBLIC AT (.duplicate$flags);
DECLARE last$index ADDRESS PUBLIC;
DECLARE no$discrepancies$found BYTE PUBLIC INITIAL (true);

/*******  END OF PUBLICS  *******/

DECLARE name1 (15) BYTE,
        name2 (15) BYTE;

DECLARE duplicate$flags (512) ADDRESS;
DECLARE top  ADDRESS,
        next ADDRESS;

DECLARE we$have$a$duplicate BYTE INITIAL (false);
DECLARE warning$string  (*) BYTE INITIAL (CR,LF,
        'WARNING: respecification of source version information encountered',
         CR,LF,0);

greater$than: PROCEDURE (sptr1,sptr2) BYTE;
  DECLARE (sptr1,sptr2) ADDRESS;
  DECLARE ptr1 BASED sptr1 ADDRESS,
          ptr2 BASED sptr2 ADDRESS;
  DECLARE (nptr1,nptr2) ADDRESS;
  DECLARE i BYTE;

  /* the sptr's (from sort) point to the
     file name ptrs, which point to the file names
  */
  nptr1 = (nptr1 := ptr1) + 4;  /* ignore leading :f?: field */
  nptr2 = (nptr2 := ptr2) + 4;
  CALL movem (11, nptr1, (scan$p := .name1));
  CALL forcup$string;     /* uppercase name for comparison */
  CALL movem (11, nptr2, (scan$p := .name2));
  CALL forcup$string;
  i = 0;
  DO WHILE name1(i) = name2(i);
    IF (i := i + 1) > 9 THEN
      RETURN true;
  END;
  RETURN (name1(i) > name2(i));
END greater$than;

sort$names$for$listing: PROCEDURE PUBLIC;

  CALL sort (.marked$file$names$ptrs, mfn$counter, .greater$than);
END sort$names$for$listing;

check$duplicate$file$names: PROCEDURE PUBLIC;
  DECLARE dot$ptr  ADDRESS;
  DECLARE dot$byte BASED dot$ptr BYTE;

  CALL sort$names$for$listing;  /* must do this now,   */
  last$index = mfn$counter - 1; /* for get$greatest$numeric$exts' benefit */

  IF mfn$counter < 2 THEN  /* only one file name */
    RETURN;

  DO next = 0 TO last$index;  /* initialize array */
    duplicate$flags (next) = next;  /* each one duplicate of itself */
    /* reset name ptrs past :f?: part */
    scan$p,  /* for forcup$string */
    marked$file$names$ptrs (next) = marked$file$names$ptrs (next) + 4;
    dot$ptr = scan$p + 6;
    CALL forcup$string;  /* uppercase name and extension */
    dot$byte = null;     /* set dot to null */
  END;

  DO top = 0 TO last$index - 1;
    DO next = top + 1 TO last$index;
      IF duplicate$flags (next) = next THEN /* not same as anything else yet */
        DO;
          scan$p = marked$file$names$ptrs (next);
          IF scan$match (marked$file$names$ptrs(top)) THEN
            DO;
              duplicate$flags (next) = top;
              duplicate$flags (top) = 0FFFFH;
              we$have$a$duplicate = true;
            END;
        END;
    END;
  END;

  IF we$have$a$duplicate THEN
    DO;
      no$discrepancies$found = false;
      obuf$p = .memory;
      CALL out$print (.warning$string);
      DO top = 0 TO last$index - 1;
        IF duplicate$flags (top) = 0FFFFH THEN  /* this one same as others */
          DO;
            CALL out$print (.(CR,LF,'SOURCE PROGRAM NAME:     ',0));
            CALL out$print (marked$file$names$ptrs(top));  /* name part */
            CALL out$crlf;
            CALL out$print (.('LOAD MODULE VERSION LEVELS: ',0));
            CALL out$print (marked$file$names$ptrs(top) + 7); /* ext part */
            CALL out$crlf;
            DO next = top + 1 TO last$index;
              IF duplicate$flags (next) = top THEN
                DO;
                  CALL out$chars (28, ' ');
                  CALL out$print (marked$file$names$ptrs(next) + 7);
                  CALL out$crlf;
                END;
            END;
            CALL writec (.memory, obuf$p - .memory);
            obuf$p = .memory;
          END;
      END;
    END;
END check$duplicate$file$names;

numeric$extension: PROCEDURE ADDRESS PUBLIC;
  DECLARE start$scan ADDRESS;

  /*  assumes scan$p already pointing at extension chars
      returns 0FFFFH if not numeric extension
      otherwise returns decimal value             */

  start$scan = scan$p;
  CALL scan$while (.ddigch);
  IF (start$scan + 3) <> scan$p THEN
    RETURN 0FFFFH;
  ELSE
    DO;
      scan$p = start$scan;
      RETURN decin;
    END;
END numeric$extension;

get$greatest$numeric$exts: PROCEDURE PUBLIC;
  DECLARE last$name$equal$to$top ADDRESS,
          greatest$ext$val       ADDRESS,
          greatest$ext           ADDRESS,
          ext$val                ADDRESS;

  /*  initialize array that marks greatest extensions  */

  DO next = 0 TO last$index;
    has$greatest$numeric$ext (next) = 80H;  /* haven't looked at it yet */
  END;

  DO top = 0 TO last$index;
    IF has$greatest$numeric$ext (top) = 80H THEN
      DO;
        last$name$equal$to$top = top;
        /* now mark off all file names equal to top's name
           since they're sorted, just go down the list  */
        DO WHILE true;
          IF (next := last$name$equal$to$top + 1) > last$index THEN /* top is last */
            GO TO no$more$duplicates;
          scan$p = marked$file$names$ptrs (next);
          IF scan$match (marked$file$names$ptrs(top)) THEN /* duplicate */
            last$name$equal$to$top = next;
          ELSE  /* not duplicate, give up */
            GO TO no$more$duplicates;
        END;
no$more$duplicates:
        /* find the greatest numeric extension for the current file name */
        greatest$ext$val = 0;
        greatest$ext = 0FFFFH;
        DO next = top TO last$name$equal$to$top;
          scan$p = marked$file$names$ptrs (next) + 7;  /* point at extension */
          IF (ext$val := numeric$extension) <> 0FFFFH THEN  /* it's numeric */
            DO;
              IF ext$val >= greatest$ext$val THEN  /* save this one */
                DO;
                  greatest$ext$val = ext$val;
                  greatest$ext = next;
                END;
            END;
        END;
        DO next = top TO last$name$equal$to$top;
          has$greatest$numeric$ext (next) = (next = greatest$ext);
        END;
      END;
  END; /* top = 0 TO last$index */
END get$greatest$numeric$exts;

END;
src/chklod.plm
$TITLE('==>  C H K L O D  <==  CHKLOD')

CHKLOD:
DO;

/************************************************************************/
/*																		*/
/*      '(C) Intel Corporation 1981'.  All rights reserved.  No			*/
/*      part of this program or publication may be reproduced,			*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

DECLARE COPYRIGHT (*) BYTE DATA ('(C) INTEL CORP 1981');

DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.0',0);

/*******  EXTERNALS  *******/

/* FNAMES.LIB */

out$file$name: PROCEDURE (ptr) EXTERNAL; DECLARE ptr ADDRESS; END;

/*  SYS.LIB  */

DECLARE actual ADDRESS EXTERNAL;
closei: PROCEDURE EXTERNAL; END;
ex: PROCEDURE EXTERNAL; END;
memck: PROCEDURE ADDRESS EXTERNAL; END;
readi: PROCEDURE (dst,count) EXTERNAL; DECLARE (dst,count) ADDRESS; END;
writec: PROCEDURE (src,count) EXTERNAL; DECLARE (src,count) ADDRESS; END;
writeo: PROCEDURE (src,count) EXTERNAL; DECLARE (src,count) ADDRESS; END;

/* UTIL.LIB  */

DECLARE scan$p ADDRESS EXTERNAL;
DECLARE obuf$p ADDRESS EXTERNAL;
console$in: PROCEDURE EXTERNAL; END;
error$message: PROCEDURE (ptr) EXTERNAL; DECLARE ptr ADDRESS; END;
out$blank: PROCEDURE EXTERNAL; END;
out$crlf: PROCEDURE EXTERNAL; END;
out$print: PROCEDURE (ptr) EXTERNAL; DECLARE ptr ADDRESS; END;
out$scan$byte: PROCEDURE EXTERNAL; END;
scan$match: PROCEDURE (ptr) BYTE EXTERNAL; DECLARE ptr ADDRESS; END;

/* CINVOK.P80 */

DECLARE drive$specified BYTE EXTERNAL;
DECLARE dir$search (16) BYTE EXTERNAL;
DECLARE ds$index BYTE EXTERNAL;
DECLARE listing$file$name$ptr ADDRESS EXTERNAL;
DECLARE object$file$name$ptr ADDRESS EXTERNAL;
DECLARE listing BYTE EXTERNAL;
DECLARE sorting BYTE EXTERNAL;
process$invocation$line: PROCEDURE EXTERNAL; END;
file$error$msg: PROCEDURE (file$name$ptr, msg$ptr) EXTERNAL;
  DECLARE (file$name$ptr, msg$ptr) ADDRESS; END;

/* CMOVEM.P80 */

movem: PROCEDURE (count,src,dst) EXTERNAL;
  DECLARE (count,src,dst) ADDRESS; END;

/* CGREAT.P80 */

check$duplicate$file$names: PROCEDURE EXTERNAL; END;
get$greatest$numeric$exts: PROCEDURE EXTERNAL; END;
sort$names$for$listing: PROCEDURE EXTERNAL; END;

/* CDIREC.P80 */

compare$dir$names: PROCEDURE EXTERNAL; END;
process$a$directory: PROCEDURE (drive$no) EXTERNAL; DECLARE drive$no BYTE; END;

/*******  END OF EXTERNALS  *******/

/*******  PUBLICS  *******/

DECLARE marked$file$names$ptrs (512) ADDRESS PUBLIC;
DECLARE mfn$counter ADDRESS PUBLIC INITIAL (0);
DECLARE top$of$ram  ADDRESS PUBLIC;

/*******  END OF PUBLICS  *******/

DECLARE true  LITERALLY '0FFH',
        false LITERALLY '0',
        null  LITERALLY '0',
        CR    LITERALLY '0DH',
        LF    LITERALLY '0AH';

DECLARE default$drive LITERALLY '31H';  /* i.e. drive 1 */

DECLARE scan$byte BASED scan$p BYTE,
        scan$word BASED scan$p ADDRESS,
        obuf$byte BASED obuf$p BYTE;

DECLARE end$of$filled$buffer   ADDRESS,
        mod$end$rec$type       BYTE,
        mrk$obj$rec$type       BYTE,
        record$length          ADDRESS,
        doing$8080$object      BYTE,
        i                      BYTE;

DECLARE marked$file$names (512) STRUCTURE (
         name (15) BYTE ),
        mfn$index ADDRESS;

/* when looking at a comment or ancestor record,
   we've already gone past the type and record length fields,
   so the next two structures don't have them
*/
DECLARE arec$8080 BASED scan$p STRUCTURE (
         mnamlength      BYTE,
         mnamechksum (1) BYTE );

DECLARE crec$8086 BASED scan$p STRUCTURE (
         cclass            BYTE,
         cbits             BYTE,
         commentchksum (1) BYTE );

DECLARE could$be$marked$record BYTE INITIAL (false),
        first$buffer$byte      BYTE AT (.memory) INITIAL (0);

DECLARE source$file$string (*) BYTE INITIAL ('SOURCE_FILE=',0);
DECLARE blanks$and$null    (*) BYTE INITIAL ('              ',0);

DECLARE insert$source$msg (*) BYTE
         INITIAL (CR,LF,'insert source disk in drive ? and type <CR>...');

DECLARE no$marked$records$msg (*) BYTE
         INITIAL ('  NO SOURCE VERSION INFORMATION FOUND',0);

DECLARE library$msg  (*) BYTE INITIAL ('IS AN 808X LIBRARY',0),
        library$msg$type BYTE AT (.library$msg(9));
DECLARE not$obj$msg  (*) BYTE INITIAL ('IS NOT AN OBJECT MODULE',0);

its$a$library: PROCEDURE (type);
  DECLARE type BYTE;

  library$msg$type = type;
  CALL file$error$msg (object$file$name$ptr, .library$msg);
END its$a$library;

its$not$an$object$module: PROCEDURE;

  CALL file$error$msg (object$file$name$ptr, .not$obj$msg);
END its$not$an$object$module;

check$and$save$file$name: PROCEDURE;
  DECLARE saved$scan$p     ADDRESS;
  DECLARE mod$name$length  BYTE;
  DECLARE file$name$length BYTE;
  DECLARE chars$written    BYTE;

  could$be$marked$record = false;
  saved$scan$p = scan$p;
  IF doing$8080$object THEN
    DO;
      mod$name$length = arec$8080.mnamlength;
      scan$p = scan$p + 1;
      IF scan$match (.source$file$string) THEN  /* want this one */
        file$name$length = mod$name$length - 12;
      ELSE
        GO TO restore$scan$p;
    END;
  ELSE  /* 8086 */
    DO;
      IF crec$8086.cclass = 0FFH THEN
        IF crec$8086.cbits = 0 THEN  /* so far, so good */
          DO;
            scan$p = scan$p + 2;
            IF scan$match (.source$file$string) THEN  /* want this one */
              file$name$length = record$length - 15;
            ELSE
              GO TO restore$scan$p;
          END;
        ELSE GO TO restore$scan$p;
      ELSE GO TO restore$scan$p;
    END;
  mfn$index = mfn$counter;
  IF (mfn$counter := mfn$counter + 1) > 512 THEN
    CALL error$message (.('CANNOT PROCESS MORE THAN 512 MARKED FILE NAMES',0));
  obuf$p,
  marked$file$names$ptrs(mfn$index) = .marked$file$names(mfn$index);
  /* store file name in a directory listing style format */
  CALL movem (15, .blanks$and$null, obuf$p);  /* init storage area */
  IF scan$byte = ':' THEN  /* :f?: */
    DO;
      CALL out$scan$byte;
      CALL out$scan$byte;
      CALL out$scan$byte;
      CALL out$scan$byte;
      file$name$length = file$name$length - 4;
    END;
  ELSE  /* no leading file drive number, leave 4 blanks */
    obuf$p = obuf$p + 4;
  chars$written = 0;
  DO WHILE (scan$byte <> '.') AND (file$name$length > 0);
    CALL out$scan$byte;
    file$name$length = file$name$length - 1;
    chars$written = chars$written + 1;
  END;
  IF file$name$length = 0 THEN  /* no dot or extension, finished */
    GO TO restore$scan$p;
  /* otherwise, saw a dot, maybe less than 6 chars */
  obuf$p = obuf$p + (6 - chars$written);
  /* now just dump the rest */
  DO WHILE file$name$length > 0;
    CALL out$scan$byte;
    file$name$length = file$name$length - 1;
  END;

restore$scan$p:
  scan$p = saved$scan$p;
END check$and$save$file$name;

scan$whole$file: PROCEDURE;
  DECLARE new$scan$p ADDRESS;
  /* the whole file is in the buffer,
     just scan until modend record found */

  DO WHILE scan$byte <> mod$end$rec$type;
    IF scan$byte = mrk$obj$rec$type THEN
      could$be$marked$record = true;
    scan$p = scan$p + 1;
    record$length = scan$word;
    scan$p = scan$p + 2;
    IF could$be$marked$record THEN
      CALL check$and$save$file$name;
    /* check for possibility of missing modend record! */
    new$scan$p = scan$p + record$length;
    IF (new$scan$p >= end$of$filled$buffer)  /* but still less than 64K */
     OR (new$scan$p < scan$p) THEN  /* wrapped around 64K */
      CALL error$message (.('MISSING MODEND RECORD?!',0));
    scan$p = new$scan$p;
  END;
END scan$whole$file;

scan$and$buffer$file: PROCEDURE;
  DECLARE three$bytes$left$ptr ADDRESS,
          bytes$to$move        ADDRESS,
          bytes$left$in$buffer ADDRESS,
          too$much$file        ADDRESS;

  /* can't fit whole object file into buffer,
     must handle scanning to end of buffer, etc. */

  three$bytes$left$ptr = end$of$filled$buffer - 3;
  DO WHILE scan$byte <> mod$end$rec$type;
    IF scan$p >= three$bytes$left$ptr THEN  /* length field may not be here */
      DO;
        IF scan$p >= end$of$filled$buffer THEN  /* went too far, abort */
          DO;
            CALL error$message (.('UNABLE TO SCAN OBJECT FILE',0));
            CALL ex;
          END;
        /* OK here, move unscanned bytes to beginning and read again */
        bytes$to$move = end$of$filled$buffer - scan$p;
        CALL movem (bytes$to$move, scan$p, .memory);
        CALL readi (.memory + bytes$to$move, 7000H);
        scan$p = .memory;
        end$of$filled$buffer = .memory + bytes$to$move + actual;
        IF actual < 7000H THEN  /* all the rest of the file is in the buffer */
          DO;
            CALL scan$whole$file;  /* do it the easy way */
            RETURN;
          END;
        three$bytes$left$ptr = end$of$filled$buffer - 3;
      END;
    /* now OK to look at the record length */
    IF scan$byte = mrk$obj$rec$type THEN
      could$be$marked$record = true;
    scan$p = scan$p + 1;
    record$length = scan$word;
    scan$p = scan$p + 2;  /* bump past record field */
    /* record$length bytes may not have been read yet */
    bytes$left$in$buffer = end$of$filled$buffer - scan$p;
    IF could$be$marked$record THEN
      DO;
        IF bytes$left$in$buffer <= record$length THEN  /* get it all in */
          DO;
            CALL movem (bytes$left$in$buffer, scan$p, .memory);
            CALL readi (.memory + bytes$left$in$buffer, 7000H);
            scan$p = .memory;
            end$of$filled$buffer = .memory + bytes$left$in$buffer + actual;
            three$bytes$left$ptr = end$of$filled$buffer - 3;
          END;
        CALL check$and$save$file$name;
        IF actual < 7000H THEN
          DO;
            scan$p = scan$p + record$length;
            CALL scan$whole$file;
            RETURN;
          END;
      END;
    ELSE
      DO WHILE bytes$left$in$buffer <= record$length;
        CALL readi (.memory, 7000H);
        scan$p = .memory;
        end$of$filled$buffer = .memory + actual;
        record$length = record$length - bytes$left$in$buffer;
        IF actual < 7000H THEN
          DO;
            scan$p = scan$p + record$length;
            CALL scan$whole$file;
            RETURN;
          END;
        bytes$left$in$buffer = actual;
        three$bytes$left$ptr = end$of$filled$buffer - 3;
      END;
    /* whatever's left of this record is in the buffer now */
    scan$p = scan$p + record$length;
    /* now pointing at next record type byte */
  END;  /* WHILE scan$byte <> mod$end$rec$type */
  /* now we've found the modend record, but there's still more to read */
  bytes$to$move = end$of$filled$buffer - scan$p;
  CALL movem (bytes$to$move, scan$p, .memory);
  /* this is the last read, if it doesn't all fit, give up */
  too$much$file = 7000H - bytes$to$move + 1;
  CALL readi (.memory + bytes$to$move, too$much$file);
  IF actual = too$much$file THEN
    CALL error$message (.('CANNOT CHECK OBJECT MODULE SEQUENCE',0));
  scan$p = .memory;
  end$of$filled$buffer = .memory + bytes$to$move + actual;
END scan$and$buffer$file;

set$8080$rec$types: PROCEDURE;
  mod$end$rec$type = 004H;
  mrk$obj$rec$type = 010H;
  doing$8080$object = true;
END set$8080$rec$types;

set$8086$rec$types: PROCEDURE;
  mod$end$rec$type = 08AH;
  mrk$obj$rec$type = 088H;
  doing$8080$object = false;
END set$8086$rec$types;

/***************    MAINLINE CODE    ***************/

  CALL process$invocation$line;
  /* now object file has been opened for update */
  /* read the first byte to check for valid file */

  CALL readi (.memory, 1);
  IF first$buffer$byte = 002H THEN  /* 8080 module */
    CALL set$8080$rec$types;
  ELSE IF first$buffer$byte = 080H THEN  /* 8086 translator module */
    CALL set$8086$rec$types;
  ELSE IF first$buffer$byte = 082H THEN  /* 8086 linker module */
    CALL set$8086$rec$types;
  ELSE IF first$buffer$byte = 06EH THEN  /* 8086 locater module */
    CALL set$8086$rec$types;
  ELSE IF first$buffer$byte = 02CH THEN  /* 8080 library */
    CALL its$a$library('0');
  ELSE IF first$buffer$byte = 0A4H THEN  /* 8086 library */
    CALL its$a$library('6');
  ELSE CALL its$not$an$object$module;

  /* OK to read this object file, read it in */
  CALL readi (.memory + 1, 7000H);  /* 28K read */
  scan$p = .memory;
  end$of$filled$buffer = .memory + actual + 1;  /* points after last byte */
  IF actual < 7000H THEN  /* the whole file fit into the buffer */
    CALL scan$whole$file;
  ELSE  /* there's still more to read */
    CALL scan$and$buffer$file;

  /* done reading object file, close it */
  CALL closei;

  IF listing THEN
    DO;
      IF sorting THEN
        CALL sort$names$for$listing;
      obuf$p = .memory;
      CALL out$print (.(CR,LF,'LISTING OF ',0));
      CALL out$file$name (object$file$name$ptr);
      CALL out$crlf;
      CALL out$crlf;
      IF mfn$counter = 0 THEN
        DO;
          CALL out$print (.no$marked$records$msg);
          CALL out$crlf;
        END;
      ELSE
        DO mfn$index = 0 TO mfn$counter-1;
          CALL out$blank;
          CALL out$blank;
          CALL out$print (marked$file$names$ptrs(mfn$index));
          CALL out$crlf;
        END;
      CALL writeo (.memory, obuf$p - .memory);
      CALL ex;
    END;

  IF mfn$counter = 0 THEN  /* no point in doing anything else */
    DO;
      CALL error$message (.no$marked$records$msg(2));
      CALL ex;
    END;

  CALL check$duplicate$file$names;

  /* set up names for directory matches */

  CALL get$greatest$numeric$exts;

  top$of$ram = memck - 2;

  /* directory search stuff */

  IF NOT drive$specified THEN  /* only search default drive */
    DO;
      CALL process$a$directory (default$drive);
    END;
  ELSE  /* check all drives specified */
    DO;
      DO i = 0 TO ds$index - 1;
        insert$source$msg(30) = dir$search(i);
        CALL writec (.insert$source$msg, length(insert$source$msg));
        CALL console$in;
        CALL process$a$directory (dir$search(i));
      END;
    END;

  CALL compare$dir$names;

  CALL ex;

END;
src/cinvok.plm
$TITLE('==>  C I N V O K  <==  CHKLOD')

CINVOK:
DO;

/************************************************************************/
/*																		*/
/*      '(C) Intel Corporation 1981'.  All rights reserved.  No			*/
/*      part of this program or publication may be reproduced,			*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

/*******  EXTERNALS *******/

/* FNAMES.LIB */

out$file$name: PROCEDURE (ptr) EXTERNAL; DECLARE ptr ADDRESS; END;

/*  UTIL.LIB  */

DECLARE obuf$p ADDRESS EXTERNAL;
DECLARE scan$p ADDRESS EXTERNAL;
blnkch: PROCEDURE BYTE EXTERNAL; END;
console$in: PROCEDURE EXTERNAL; END;
ddigch: PROCEDURE BYTE EXTERNAL; END;
error$message: PROCEDURE (ptr) EXTERNAL; DECLARE ptr ADDRESS; END;
filech: PROCEDURE BYTE EXTERNAL; END;
out$blank: PROCEDURE EXTERNAL; END;
out$char: PROCEDURE (char) EXTERNAL; DECLARE char BYTE; END;
out$print: PROCEDURE (ptr) EXTERNAL; DECLARE ptr ADDRESS; END;
scan$match: PROCEDURE (ptr) BYTE EXTERNAL; DECLARE ptr ADDRESS; END;
scan$until: PROCEDURE (proc$addr) EXTERNAL; DECLARE proc$addr ADDRESS; END;
scan$while: PROCEDURE (proc$addr) EXTERNAL; DECLARE proc$addr ADDRESS; END;
scan$while$blanks: PROCEDURE EXTERNAL; END;
termch: PROCEDURE BYTE EXTERNAL; END;

/*  SYS.LIB   */

DECLARE fatal BYTE EXTERNAL;
DECLARE report BYTE EXTERNAL;
ex: PROCEDURE EXTERNAL; END;
isis$cl: PROCEDURE (proc$code,block$ptr) EXTERNAL;
  DECLARE proc$code BYTE, block$ptr ADDRESS; END;
open$i: PROCEDURE (file$name$ptr) EXTERNAL;
  DECLARE file$name$ptr ADDRESS; END;
open$o: PROCEDURE (file$name$ptr) EXTERNAL;
  DECLARE file$name$ptr ADDRESS; END;

/*******  END OF EXTERNALS  *******/

DECLARE spath$code LITERALLY '14',
        null       LITERALLY '0',
        true       LITERALLY '0FFH',
        false      LITERALLY '0';

/*******  PUBLICS  *******/

DECLARE object$file$name$ptr  ADDRESS PUBLIC,
        listing$file$name$ptr ADDRESS PUBLIC,
        token$error$ptr       ADDRESS PUBLIC;

DECLARE listing           BYTE PUBLIC INITIAL (false),
        sorting           BYTE PUBLIC INITIAL (true),
        its$a$token$error BYTE PUBLIC INITIAL (false),
        drive$specified   BYTE PUBLIC INITIAL (false),
        ds$index          BYTE PUBLIC INITIAL (0);

DECLARE dir$search      (16) BYTE PUBLIC;
DECLARE spath$file$info (12) BYTE PUBLIC;

/*******  END OF PUBLICS  *******/

DECLARE scan$byte BASED scan$p BYTE;

DECLARE spath$status ADDRESS,
        spath$block  STRUCTURE (
         file$name$ptr ADDRESS,
         file$info$ptr ADDRESS,
         status$ptr    ADDRESS) INITIAL (0, .spath$file$info, .spath$status);

DECLARE co$string         (*) BYTE INITIAL (':CO:',0);
DECLARE bad$file$name$msg (*) BYTE INITIAL ('IS A BAD FILE NAME',0);

file$error$msg: PROCEDURE (name$ptr, msg$ptr) PUBLIC;
  DECLARE (name$ptr, msg$ptr) ADDRESS;
  /*
    use free memory for building string,
    since we're going to exit anyways
  */
  obuf$p = .memory;
  IF its$a$token$error THEN
    CALL out$print (name$ptr);
  ELSE  /* file name */
    CALL out$file$name (name$ptr);
  CALL out$blank;
  CALL out$print (msg$ptr);
  CALL out$char (null);
  CALL error$message (.memory);
  CALL ex;
END file$error$msg;

end$of$line$char: PROCEDURE BYTE;
  /* returns true if scan$byte = termch or
     scan$byte = ';'
  */
  IF termch THEN
    RETURN true;
  IF scan$byte = ';' THEN
    RETURN true;
  RETURN false;
END end$of$line$char;

blank$or$term$or$null$char: PROCEDURE BYTE;
  /* returns true if scan$byte = blnkch OR scan$byte = termch
     OR scan$byte = null
  */
  IF blnkch THEN
    RETURN true;
  IF termch THEN
    RETURN true;
  IF scan$byte = null THEN
    RETURN true;
  RETURN false;
END blank$or$term$or$null$char;

spath$check: PROCEDURE (msg$ptr) PUBLIC;
  DECLARE msg$ptr ADDRESS;
  /*
    This checks for a valid file name, using SPATH,
    and advances scan$p past the token
  */
  spath$block.file$name$ptr = scan$p;
  CALL scan$while (.filech);   /* past file name */
  CALL isiscl (spath$code, .spath$block);
  IF spath$status <> 0 THEN  /* bad file name */
    CALL file$error$msg (spath$block.file$name$ptr, msg$ptr);
END spath$check;

bad$invok$token: PROCEDURE;

  token$error$ptr = scan$p;
  CALL scan$until (.blank$or$term$or$null$char);
  scan$byte = null;
  its$a$token$error = true;
  CALL file$error$msg (token$error$ptr,
                              .('IS AN INVALID COMMAND LINE TOKEN',0));
END bad$invok$token;

process$invocation$line: PROCEDURE PUBLIC;

  fatal,          /* all ISIS errors are fatal */
  report = TRUE;  /* automatic error reporting */

  CALL console$in;  /* read rest of line, set scan$p at the beginning */
  CALL scan$while$blanks;

  /* now should be pointing at the object file name */

  object$file$name$ptr = scan$p;
  CALL spath$check (.bad$file$name$msg);

  CALL scan$while$blanks;  /* to next token */

  IF scan$match (.('LISTING',0)) OR
     scan$match (.('LT',0)) THEN  /* wants listing, check for TO filename */
    DO;
      listing = true;
      CALL scan$while$blanks;
      IF scan$match (.('TO',0)) THEN  /* should be filename now */
        DO;
          CALL scan$while$blanks;
          listing$file$name$ptr = scan$p;
          CALL spath$check (.bad$file$name$msg);
        END;
      ELSE  /* no TO, list to :CO:  */
        listing$file$name$ptr = .co$string;
      CALL scan$while$blanks;
      /* now look for NOSORT */
      IF scan$match (.('NOSORT',0)) THEN
        sorting = false;
      CALL scan$while$blanks;
      /* nothing else allowed now */
      IF NOT end$of$line$char THEN
        CALL bad$invok$token;
    END;

    ELSE IF ddigch THEN  /* number for file directory search */
      DO;
        drive$specified = true;
        DO WHILE ddigch;
          IF ds$index > 15 THEN  /* already have limit of 16 drives */
            DO;
              CALL error$message (.('CANNOT SPECIFY MORE THAN 16 DRIVES',0));
              CALL ex;
            END;
          dir$search (ds$index) = scan$byte;  /* store ASCII digits */
          ds$index = ds$index + 1;
          scan$p = scan$p + 1;   /* past this number */
          CALL scan$while$blanks;
        END;
        /* nothing else allowed now */
        IF NOT end$of$line$char THEN
          CALL bad$invok$token;
      END;

    ELSE IF end$of$line$char THEN  /* end of line */
      GO TO no$more$tokens;

    ELSE  /* something bad */
      CALL bad$invok$token;

no$more$tokens:

  /* now open the files */

  CALL openi (object$file$name$ptr);
  IF listing THEN
    CALL openo (listing$file$name$ptr);

END process$invocation$line;

END;
src/clean.plm
$ TITLE('CLEAN -- NUMERIC SOURCE EXTENSION CLEANUP TOOL')

CLEAN$MOD:
DO;

/************************************************************************/
/*																		*/
/*      '(C) Intel Corporation 1981'.  All rights reserved.  No			*/
/*      part of this program or publication may be reproduced,			*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

DECLARE COPYRIGHT (*) BYTE DATA ('(C) INTEL CORP 1981');

DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.0',0);

		/* ISIS.INC */

CLOSE:
	PROCEDURE (AFTN,STATUS) EXTERNAL;
	DECLARE (AFTN,STATUS) ADDRESS;
	END
CLOSE;

CI:
	PROCEDURE BYTE EXTERNAL;
	END
CI;

CO:
	PROCEDURE (CHAR$CO) EXTERNAL;
	DECLARE CHAR$CO BYTE;
	END
CO;

CONSOL:
	PROCEDURE (CONSOLE$INPUT$FILE,CONSOL$OUTPUT$FILE,STATUS$CON) EXTERNAL;
	DECLARE (CONSOLE$INPUT$FILE,CONSOL$OUTPUT$FILE,STATUS$CON) ADDRESS;
	END
CONSOL;

DELETE:
	PROCEDURE (FILE$NAME$PTR,STATUS) EXTERNAL;
	DECLARE (FILE$NAME$PTR,STATUS) ADDRESS;
	END
DELETE;

ERROR:
	PROCEDURE  (ERROR$NUMBER) EXTERNAL;
	DECLARE ERROR$NUMBER ADDRESS;
	END
ERROR;

EXIT:
	PROCEDURE EXTERNAL;
	END
EXIT;

GETD:
    PROCEDURE (DRIVE$NO,CONNECTION,COUNT,ACTUAL$ENTRY,BUFFER,STATUS)EXTERNAL;
    DECLARE DRIVE$NO  BYTE;
    DECLARE (CONNECTION,COUNT,ACTUAL$ENTRY,BUFFER,STATUS) ADDRESS ;
    END
GETD;

IO$CHK:
	PROCEDURE BYTE EXTERNAL;
	END
IO$CHK;

IO$DEF:
	PROCEDURE (WHICH$DEVICE,ENTRY$POINT) EXTERNAL;
	DECLARE WHICH$DEVICE BYTE,
			ENTRY$POINT ADDRESS;
	END
IO$DEF;

IO$SET:
	PROCEDURE (CONFIGURATION$BYTE) EXTERNAL;
	DECLARE CONFIGURATION$BYTE BYTE;
	END
IO$SET;

LOAD:
	PROCEDURE (FILE,BIAS,CONTROL$OF$TRANSFER,ENTRY$POINT,STATUS) EXTERNAL;
	DECLARE (FILE,BIAS,CONTROL$OF$TRANSFER,ENTRY$POINT,STATUS) ADDRESS;
	END
LOAD;

MEMCK:
	PROCEDURE ADDRESS EXTERNAL;
	END
MEMCK;

OPEN:
	PROCEDURE(AFTN,FILENAME,ACCESS$MODE,LINE$EDIT$AFTN,ERROR) EXTERNAL;
	DECLARE (AFTN,FILENAME,ACCESS$MODE,LINE$EDIT$AFTN,ERROR) ADDRESS;
	END
OPEN;

READ:
	PROCEDURE (AFTN,BUFFER,COUNT,ACTUAL,STATUS) EXTERNAL;
	DECLARE (AFTN,BUFFER,COUNT,ACTUAL,STATUS) ADDRESS;
	END
READ;

RENAME:
	PROCEDURE (OLD$NAME,NEW$NAME,STATUS$R) EXTERNAL;
	DECLARE (OLD$NAME,NEW$NAME,STATUS$R) ADDRESS;
	END
RENAME;

RESCAN:
	PROCEDURE (AFTN,STATUS) EXTERNAL;
	DECLARE (AFTN,STATUS) ADDRESS;
	END
RESCAN;

SEEK:
	PROCEDURE (AFTN,MODE,BLOCKNO,BYTENO,STATUS) EXTERNAL;
	DECLARE (AFTN,MODE,BLOCKNO,BYTENO,STATUS) ADDRESS;
	END
SEEK;

SPATH:
	PROCEDURE (FILE,BUFFER,STATUS) EXTERNAL;
	DECLARE (FILE,BUFFER,STATUS) ADDRESS;
	END
SPATH;

WHOCON:
	PROCEDURE (AFTN,BUFFER) EXTERNAL;
	DECLARE (AFTN,BUFFER) ADDRESS;
	END
WHOCON;

WRITE:
	PROCEDURE (AFTN,BUFFER,COUNT,STATUS) EXTERNAL;
	DECLARE (AFTN,BUFFER,COUNT,STATUS) ADDRESS;
	END
WRITE;

		/* END ISIS.INC */

/*          LIT.INC          */

DECLARE					 LIT LITERALLY 'LITERALLY',
	BELL				 LIT '07H',				 /* plm */
	BLANK				 LIT '020H',			 /* plm */
    BOOLEAN				 LIT 'BYTE',			 /* plm */
	CHK					 LIT 'CALL CHECK$STATUS(STATUS)', /* plm */
    CO$ECHO$FILE		 LIT '0F00H',
	COLON			     LIT '03AH',			 /* plm */
    COMMA				 LIT '02CH',			 /* plm */
    CONSOLE$INPUT		 LIT  '1',
	CONSOLE$OUTPUT		 LIT '0',
	CONTROL$Z			 LIT  '01AH',			 /* plm */
	CR					 LIT '0DH',				 /* plm */
	CRLF				 LIT '0D0AH',			 /* plm */
	DOT					 LIT '02EH',				 /* plm */
    ENDDO				 LIT 'END',				 /* plm */
	ENDDOCASE			 LIT  'END',			 /* plm */
	ENDDOWHILE			 LIT  'END',			 /* plm */
    ENDIF				 LIT ' ',				 /* plm */
	END$LOOP			 LIT ' ',				 /* plm */
	EOF$CHAR			 LIT	 'CONTROL$Z',	 /* plm */
	ESC					 LIT		'01BH',		 /* plm */
	FALSE				 LIT '0H',				 /* plm */
	FOREVER 			 LIT 'WHILE 1',			 /* plm */
	GOTO$EOF			 LIT  '4',				 /* seek */
	LF					 LIT '0AH',				 /* plm */
	MOVE$BACKWARD		 LIT  '1',				 /* seek */
	NO$LINE$EDIT 		 LIT   '0',				 /* open */
	OPEN$FOR$READ		 LIT '1',				 /* open */
	OPEN$FOR$WRITE		 LIT '2',				 /* open */
	RETURN$POSITION		 LIT '0',				 /* seek */
    STRING 				 LIT '(*) BYTE DATA',	 /* seek */
	TAB					 LIT '09H',				 /* plm */
    TRANSFER$CONTROL	 LIT '1',				 /* load */
	TRUE				 LIT '0FFH',			 /* plm */
	USER$CI 			 LIT '0',
	ZERO				 LIT '30',				 /* plm */
    ZERO$BIAS			 LIT '0'				 /* load */ ;

/*        END LIT.INC        */
$ LIST
$ EJECT
/************************************************************/
/*															*/
/*			GLOBAL 					VARIABLES 				*/
/*															*/
/************************************************************/

/*	Based Structures. */

DECLARE DIR$ENTRY$PTR ADDRESS;
DECLARE DIR$ENTRY BASED DIR$ENTRY$PTR STRUCTURE
   (PRESENCE BYTE,
	FILENAME (6) BYTE,
	EXTENSION (3) BYTE,
	ATTRIBUTES BYTE,
	EOF$COUNT BYTE,
    NUMBER$DATA$BLOCKS ADDRESS,
	HEADER$BLOCK$POINTER ADDRESS);

DECLARE MEM$PTR ADDRESS;
DECLARE FILE BASED MEM$PTR STRUCTURE
     (NAME (6) BYTE,
	  LARGEST ADDRESS,
	  NEXT    ADDRESS,
	  EXT$PTR ADDRESS);

DECLARE EXT$PTR ADDRESS;
DECLARE EXTENSION BASED EXT$PTR STRUCTURE
	 (VALUE ADDRESS,
	  NEXT ADDRESS);

/* End of Based Structure Declarations. */

DECLARE BANNER STRING
	('ISIS-II NUMERIC SOURCE EXTENSION CLEANUP TOOL, V1.0',CR,LF,LF,0);

DECLARE (ACTUAL,STATUS) ADDRESS;
DECLARE MEM$TOP ADDRESS;
DECLARE MONITOR ADDRESS DATA (0);
DECLARE ASCII$DEVICE$NUMBER BYTE;
DECLARE CONNECTION ADDRESS INITIAL(0);
DECLARE END$OF$DIRECTORY ADDRESS;
DECLARE READING$REMOTE BYTE;

DECLARE BUCKET (256) ADDRESS;
DECLARE DIR$LENGTH ADDRESS;

DECLARE FREE$SPACE$BOTTOM ADDRESS;

$ EJECT

/************************************************************/
/*															*/
/*			UTILITY					PROCEDURES				*/
/*															*/
/************************************************************/

FIND$BLANK$OR$TAB:
	PROCEDURE (CHAR$PTR) ADDRESS PUBLIC;
	DECLARE CHAR$PTR ADDRESS,
		CHAR BASED CHAR$PTR BYTE;
	DO WHILE NOT ( CHAR = 20 OR CHAR = 9);
		CHAR$PTR = CHAR$PTR + 1;
	ENDDO;
	RETURN CHAR$PTR;
	END
FIND$BLANK$OR$TAB;

SKIP$BLANKS$N$TABS:
	PROCEDURE (CHAR$PTR) ADDRESS PUBLIC;
	DECLARE CHAR$PTR ADDRESS;
	DECLARE CHAR BASED CHAR$PTR BYTE;
	DO WHILE (CHAR=BLANK) OR (CHAR=TAB);
		CHAR$PTR = CHAR$PTR + 1;
	ENDDO;
	RETURN CHAR$PTR;
END SKIP$BLANKS$N$TABS;

FIND$CRLF:
	PROCEDURE (TEXT$PTR) ADDRESS PUBLIC;
	DECLARE TEXT$PTR ADDRESS,
			TEXT BASED TEXT$PTR ADDRESS;
	DO WHILE TEXT <> CRLF;
		TEXT$PTR = TEXT$PTR + 1;
	ENDDO;
	RETURN TEXT$PTR;
	END
FIND$CRLF;

FORCUP:
	PROCEDURE (START$PTR,NUM$CHAR);

	DECLARE START$PTR ADDRESS,
			NUM$CHAR BYTE,
			COUNT BYTE,
			CHAR BASED START$PTR BYTE;

	DO COUNT=1 TO NUM$CHAR;
		IF (CHAR>='a') AND (CHAR<='z') THEN
			CHAR = CHAR - 20H;
		ENDIF
		START$PTR = START$PTR + 1;
	ENDDO;
	END
FORCUP;

CHECK$STATUS:
	PROCEDURE (ISIS$STATUS) ;
	DECLARE ISIS$STATUS ADDRESS;
	IF ISIS$STATUS <> 0 THEN
		DO;
			CALL ERROR(ISIS$STATUS);
			CALL MONITOR;
		ENDDO;
	ENDIF
	END
CHECK$STATUS;

NUMERAL:
	PROCEDURE (A$CHAR) BOOLEAN;
	DECLARE A$CHAR BYTE;
	IF A$CHAR >= '0' AND A$CHAR <= '9' THEN
		RETURN TRUE;
	ELSE
		RETURN FALSE;
	ENDIF
	END
NUMERAL;

NUMERIC$EXTENSION:
	PROCEDURE (PTR) BOOLEAN;

	/*	Given a pointer into memory, this procedure determines
		whether the byte pointed to, and the next two contiguous
		bytes, constitute a wholly numeric ascii sequence.			*/

	DECLARE PTR ADDRESS,
			CHAR BASED PTR (10) BYTE;
	DECLARE L BYTE;
	DO L=0 TO 2;
		IF NOT NUMERAL(CHAR(L)) THEN
			RETURN FALSE;
		ENDIF
	ENDDO;
	RETURN TRUE;
	END
NUMERIC$EXTENSION;

ISIS$TERMINATOR:
	PROCEDURE (A$CHAR) BOOLEAN;
	DECLARE A$CHAR BYTE;
	RETURN NOT 					(
		( (A$CHAR >= 'A') AND (A$CHAR <= 'Z') )    OR
		( (A$CHAR >= '0') AND (A$CHAR <= '9') )    OR
		(A$CHAR = ':')                             OR
		 (A$CHAR = '.')
					);
	END
ISIS$TERMINATOR;

STOP$EVERYTHING:
	PROCEDURE (MSG$PTR) ;

	/*	This procedure is used if a fatal error is detected.  It
		receives a parameter which is a pointer to an error message.
        It prints the error message, rings a bell, and exits. */

	DECLARE MSG$PTR ADDRESS,
			MSG BASED MSG$PTR (256) BYTE;
    DECLARE MSG$LENGTH ADDRESS;

    MSG$LENGTH = 0;

    /*	Allow no message to be longer than 255 bytes.  This is a useful
    	check if the 0 has been left off the end of the message. */

    DO WHILE (MSG(MSG$LENGTH) <> 0) AND (MSG$LENGTH < 255);
    	MSG$LENGTH = MSG$LENGTH + 1;
    ENDDO;

    CALL WRITE(CONSOLE$OUTPUT,MSG$PTR,MSG$LENGTH,.STATUS); CHK;
	CALL CO(BELL);
	CALL EXIT;

    END
STOP$EVERYTHING;

LEGIT$DISK$DESIGNATION:
	PROCEDURE (PARSEE$PTR) BOOLEAN;
	DECLARE PARSEE$PTR ADDRESS,
		CHAR BASED PARSEE$PTR (4) BYTE;

	RETURN
		(CHAR(0) = ':') AND
        (CHAR(1) = 'F') AND
        ((CHAR(2) >= '0') AND (CHAR(2) <= '9')) AND
        (CHAR(3) = ':');
	END
LEGIT$DISK$DESIGNATION;

CONVERT$FILENAME:
	PROCEDURE (INT$FILNAM$PTR,DEVICE$DESIG$CHAR) ADDRESS;

	/*	This procedure takes an "internal filename" and converts it to
		the regular form. It takes a pointer to the internal filename
		as parameter, and returns a pointer to the resultant regular
		filename. */

	DECLARE INT$FILNAM$PTR ADDRESS;
	DECLARE DEVICE$DESIG$CHAR BYTE;
	DECLARE FILNAM$CHAR BASED INT$FILNAM$PTR (20) BYTE;

    DECLARE LONG$BUF (20) BYTE;
    DECLARE RESULT$BUFFER (11) BYTE AT (.LONG$BUF(4));

    DECLARE K BYTE;
	DECLARE E BYTE;

	DO K=0 TO LAST(LONG$BUF);
		LONG$BUF(K) = BLANK;
	ENDDO;

    LONG$BUF(0),LONG$BUF(3) = COLON;
    LONG$BUF(1) = 'F';
    LONG$BUF(2) = DEVICE$DESIG$CHAR;

    K = 0;
	DO WHILE (FILNAM$CHAR(K) <> 0) AND (K < 6);
    	RESULT$BUFFER(K) = FILNAM$CHAR(K);
    	K = K + 1;
    ENDDO;

    IF FILNAM$CHAR(6) <> 0 THEN
    	RESULT$BUFFER(K) = DOT;
    ENDIF

    K = K + 1;
    E = 6;
    DO WHILE (FILNAM$CHAR(E) <> 0) AND (E <= 8);
    	RESULT$BUFFER(K) = FILNAM$CHAR(E);
    	K = K + 1;
    	E = E + 1;
    ENDDO;

    LONG$BUF(LAST(LONG$BUF)-2) = COMMA;
    LONG$BUF(LAST(LONG$BUF)) = 0;

    RETURN (.LONG$BUF);
    END
CONVERT$FILENAME;

FILE$LENGTH:
	PROCEDURE (FILE$NAME$PTR) ADDRESS;

    DECLARE FILENAME$PTR ADDRESS;
	DECLARE TMP$AFTN ADDRESS;
	DECLARE (BYTE$NO,BLOCK$NO) ADDRESS;

    CALL OPEN(.TMP$AFTN,FILE$NAME$PTR,OPEN$FOR$READ,NO$LINE$EDIT,.STATUS); CHK;
    CALL SEEK(TMP$AFTN,GOTO$EOF,.BLOCK$NO,.BYTE$NO,.STATUS); CHK;
    CALL SEEK(TMP$AFTN,RETURN$POSITION,.BLOCK$NO,.BYTE$NO,.STATUS); CHK;
    CALL CLOSE(TMP$AFTN,.STATUS); CHK;

    RETURN ((128 * (BLOCK$NO MOD 32768)) + BYTE$NO);
	END
FILE$LENGTH;

FREE$SPACE$TOP:
	PROCEDURE ADDRESS;
	RETURN (DIR$ENTRY$PTR - 1);
    END
FREE$SPACE$TOP;

WRITE$CO:
	PROCEDURE (TEXT$PTR) ;
	/*	This procedure that the parameter passed to it points to a
		text string which is terminated by a 0.  If write$co does
		not find a 0 within 256 bytes of the beginning of the
		string, then only those 256 bytes are written out. */

    DECLARE TEXT$PTR ADDRESS,
    		TEXT BASED TEXT$PTR (256) BYTE;
    DECLARE T ADDRESS;

    T = 0;
    DO WHILE (TEXT(T) <> 0) AND (T<=255);
    	T = T + 1;
    ENDDO;
    CALL WRITE(CONSOLE$OUTPUT,TEXT$PTR,T,.STATUS); CHK;
    END
WRITE$CO;

$ EJECT

/****************************************************************/
/*																*/
/*				MAIN					PROCEDURES				*/
/*																*/
/****************************************************************/

INITIALIZE:
	PROCEDURE;

	DECLARE I ADDRESS;

    CALL WRITE$CO(.BANNER);

    DO I=0 TO 255;
		BUCKET(I) = 0;
    ENDDO;

	MEM$TOP = MEM$CK - 13;

    FREE$SPACE$BOTTOM = .MEMORY + 1;

    END
INITIALIZE;

PARSE$COMMAND$TAIL:
	PROCEDURE;

	DECLARE (COMMAND$TAIL,WHOLE$COMMAND$LINE) (140) BYTE;
    DECLARE CHAR$PTR ADDRESS,
    		CHAR BASED CHAR$PTR BYTE;

	CALL READ(CONSOLE$INPUT,.COMMAND$TAIL,SIZE(COMMAND$TAIL),
            .ACTUAL,.STATUS); CHK;
	CHAR$PTR = .COMMAND$TAIL;
	CHAR$PTR = SKIP$BLANKS$N$TABS(CHAR$PTR);

	IF NUMERAL(CHAR) THEN
		ASCII$DEVICE$NUMBER = CHAR;
	ELSE
		CALL STOP$EVERYTHING
			(.('Syntax is "CLEAN ?", where ? is a number 0-9.',CR,LF,0));
	ENDIF
    END
PARSE$COMMAND$TAIL;

READ$IN$DIRECTORY:
	PROCEDURE;

	DECLARE DIRECTORY$NAME STRING
		(':F?:ISIS.DIR ');
	DECLARE ASCII$DEVICE$CHAR BYTE AT (.DIRECTORY$NAME(2));
    DECLARE DIR$AFTN ADDRESS;
	DECLARE DIR$ACTUAL ADDRESS;
    DECLARE BUFFER(12) BYTE;
    DECLARE COUNT ADDRESS ;
    DECLARE FREE$SPACE ADDRESS;
    DECLARE ACTUAL$ENTRY ADDRESS;
    DECLARE ENTRY ADDRESS;

	ASCII$DEVICE$CHAR = ASCII$DEVICE$NUMBER;
	CALL SPATH(.DIRECTORY$NAME, .BUFFER, .STATUS); CHK;
      IF BUFFER(10) = 3  AND  BUFFER(11) = 5  THEN
         DO;
            IF MEM$TOP < 0E800H  THEN
               CALL STOP$EVERYTHING
                    (.('insufficient  memory ', CR, LF,0));
            ELSE
               DO;
                 FREE$SPACE = 0E800H - .MEMORY;
                 COUNT = FREE$SPACE/16;
                 CALL LOAD(.(':F0:ISIS.OV0 '),0,0,.ENTRY,.STATUS); CHK;
                 CALL GETD(ASCII$DEVICE$CHAR-'0',.CONNECTION,COUNT,
                          .ACTUAL$ENTRY,DIR$ENTRY$PTR,.STATUS); CHK;

                 IF ACTUAL$ENTRY >= COUNT  THEN
                    CALL STOP$EVERYTHING
                    (.('Remote directory too large.', CR,LF,0));
                 READING$REMOTE = TRUE;
                 END$OF$DIRECTORY = DIR$ENTRY$PTR + (ACTUAL$ENTRY * 16);
               END;
         END;
      ELSE
         DO;
            DIR$LENGTH = FILE$LENGTH(.DIRECTORY$NAME);
            DIR$ENTRY$PTR = MEM$TOP - DIR$LENGTH + 1;
            IF DIR$LENGTH > MEM$TOP - .MEMORY THEN /* error condition */
                CALL STOP$EVERYTHING
                 (.('Disk directory too large for available memory',CR,LF,0));
            ENDIF

            CALL OPEN(.DIR$AFTN,.DIRECTORY$NAME,OPEN$FOR$READ,NO$LINE$EDIT,
                      .STATUS);  CHK;
            CALL READ(DIR$AFTN,DIR$ENTRY$PTR,DIR$LENGTH,.DIR$ACTUAL,.STATUS);
                                 CHK;
            IF DIR$ACTUAL <> DIR$LENGTH THEN
              CALL STOP$EVERYTHING
            (.('Seek and Read imply different value for directory.',CR,LF,0));
            ENDIF
            READING$REMOTE = FALSE;
            END$OF$DIRECTORY = DIR$ENTRY$PTR + DIR$ACTUAL;
         END;
    END
READ$IN$DIRECTORY;

HASH:
	PROCEDURE BYTE;
	/*	This procedure returns a hash value for the name part of a particular
		directory entry. */
	DECLARE NAME BASED DIR$ENTRY$PTR (6) BYTE;
	DECLARE L BYTE,
		HASH$VALUE BYTE;

    HASH$VALUE = NAME(0);
    DO L=1 TO 5;
    	IF NAME(L) <> 0 THEN
    		HASH$VALUE = ROL(HASH$VALUE,1) XOR NAME(L);
        ELSE
        	RETURN HASH$VALUE;
        ENDIF
    ENDDO;
    RETURN HASH$VALUE;
	END
HASH;

GET$SPACE:
	PROCEDURE (SPACE$NEEDED) ADDRESS;
	DECLARE RESULT ADDRESS;
	DECLARE SPACE$NEEDED ADDRESS;

	IF (SPACE$NEEDED <= FREE$SPACE$TOP - FREE$SPACE$BOTTOM + 1) AND
	   (FREE$SPACE$TOP >= FREE$SPACE$BOTTOM)
	   												THEN
		DO;
			RESULT = FREE$SPACE$BOTTOM;
			FREE$SPACE$BOTTOM = FREE$SPACE$BOTTOM + SPACE$NEEDED;
			RETURN RESULT;
		ENDDO;
	ELSE
		/*	out of space. */
		CALL STOP$EVERYTHING
			(.('Not enough free memory to process directory.',CR,LF,0));
	ENDIF
	END
GET$SPACE;

VAL$OF$EXT:
	PROCEDURE  ADDRESS;

	DECLARE DIR$EXT$PTR ADDRESS;
    DECLARE EXT$MASK BASED DIR$EXT$PTR (3) BYTE;
	DECLARE EXT$VAL ADDRESS,
			M BYTE;

	DIR$EXT$PTR = .DIR$ENTRY.EXTENSION;

    EXT$VAL = 0;
	DO M=0 TO 2;
		EXT$VAL = (EXT$VAL * 10) + EXT$MASK(M) - '0';
	ENDDO;

	RETURN EXT$VAL;
	END
VAL$OF$EXT;

COPY$NAME$PART:
	PROCEDURE;
	DECLARE P BYTE;
	DO P=0 TO 5;
		FILE.NAME(P) = DIR$ENTRY.FILE$NAME(P);
	ENDDO;
	END
COPY$NAME$PART;

$ EJECT

ENTER$FILE:
	PROCEDURE;
	DECLARE HASH$VAL BYTE;

/*	Here follow embedded procedures. */

FILL$IN$ENTRIES:
	PROCEDURE;
    CALL COPY$NAME$PART;
    EXT$PTR = GET$SPACE(SIZE(EXTENSION));
    EXTENSION.VALUE = VAL$OF$EXT;
    FILE.NEXT,EXTENSION.NEXT = 0;
    END
FILL$IN$ENTRIES;

INITIALIZE$EXTENSION:
	PROCEDURE;
	EXT$PTR,FILE.EXT$PTR = GET$SPACE(SIZE(EXTENSION));
    EXTENSION.NEXT = 0;
	EXTENSION.VALUE,FILE.LARGEST = VAL$OF$EXT;
    END
INITIALIZE$EXTENSION;

INITIALIZE$HASH$BUCKET:
	PROCEDURE;
	BUCKET(HASH$VAL),MEM$PTR = GET$SPACE(SIZE(FILE));
	EXT$PTR,FILE.EXT$PTR =     GET$SPACE(SIZE(EXTENSION));
    EXTENSION.NEXT,FILE.NEXT = 0;
	CALL COPY$NAME$PART;
	EXTENSION.VALUE,FILE.LARGEST = VAL$OF$EXT;
    END
INITIALIZE$HASH$BUCKET;

ENTER$EXTENSION:
	PROCEDURE;

	/*		Enter extension at beginning of list of extensions. */
    EXT$PTR = GET$SPACE(SIZE(EXTENSION));

    EXTENSION.VALUE = VAL$OF$EXT;
    EXTENSION.NEXT  = FILE.EXT$PTR;
    FILE.EXT$PTR    = EXT$PTR;

	IF EXTENSION.VALUE > FILE.LARGEST THEN
		FILE.LARGEST = EXTENSION.VALUE;
	ENDIF

    END
ENTER$EXTENSION;

ENTER$NEW$NAME:
	PROCEDURE;
	MEM$PTR = GET$SPACE(SIZE(FILE));
	FILE.NEXT = BUCKET(HASH$VAL);
	BUCKET(HASH$VAL) = MEM$PTR;
	CALL COPY$NAME$PART;
	CALL INITIALIZE$EXTENSION;
	END
ENTER$NEW$NAME;

NAMES$MATCH:
	PROCEDURE BOOLEAN;
	DECLARE Q BYTE;
	DO Q=0 TO 5;
		IF DIR$ENTRY.FILENAME(Q) <> FILE.NAME(Q) THEN
			RETURN FALSE;
        ENDIF
    ENDDO;
    RETURN TRUE;
    END
NAMES$MATCH;

/* End of embedded procedures. */

	HASH$VAL = HASH;
	IF BUCKET(HASH$VAL) = 0 THEN
         CALL INITIALIZE$HASH$BUCKET;
    ELSE
    	DO;
    		MEM$PTR = BUCKET(HASH$VAL);
    		loop$begin:
    			IF NAMES$MATCH THEN
    				CALL ENTER$EXTENSION;
    			ELSE IF (FILE.NEXT=0) THEN
    				CALL ENTER$NEW$NAME;
    			ELSE
    				DO;
    					MEM$PTR = FILE.NEXT;
    					GO TO loop$begin;
    				ENDDO;
    			ENDIF
    		end$loop
    	ENDDO;
    ENDIF
	END
ENTER$FILE;

$ EJECT

DELETEABLE$EXTENSION:
	PROCEDURE BOOLEAN;

EXTENSIONS$MATCH:
	PROCEDURE (PTR$1,PTR$2) BOOLEAN;

	DECLARE PTR$1 ADDRESS,
			EXT$1 BASED PTR$1 (3) BYTE;

	DECLARE PTR$2 ADDRESS,
			EXT$2 BASED PTR$2 (3) BYTE;
	DECLARE R BYTE;

	DO R=0 TO 2;
		IF EXT$1(R) <> EXT$2(R) THEN
			RETURN FALSE;
		ENDIF
	ENDDO;
	RETURN TRUE;

	END
EXTENSIONS$MATCH;

	RETURN EXTENSIONS$MATCH(.('BAK'),.DIR$ENTRY.EXTENSION) OR
           EXTENSIONS$MATCH(.('TMP'),.DIR$ENTRY.EXTENSION)  ;

	END
DELETEABLE$EXTENSION;

NUM$OUT:
	PROCEDURE (AN$AFTN,A$NUMBER) ;
	DECLARE (AN$AFTN,A$NUMBER) ADDRESS;
	DECLARE TMP$BUF (5) BYTE;
	DECLARE J BYTE;

	DO J=0 TO 4;
		TMP$BUF(4-J) = (A$NUMBER MOD 10) + '0';
		A$NUMBER = A$NUMBER / 10;
    ENDDO;

    J = 0;
    DO WHILE TMP$BUF(J) = ZERO;
    	J = J + 1;
    ENDDO;

	CALL WRITE(AN$AFTN,.TMP$BUF(J-1),(SIZE(TMP$BUF)-J+1),.STATUS); CHK;
	END
NUM$OUT;

DELETE$IT:
	PROCEDURE (INT$FIL$PTR) ;
	/*	The parameter, received by this procedure, points to an
		"internal form" of the filename. */

    DECLARE INT$FIL$PTR ADDRESS;

    DECLARE X$STATUS ADDRESS,
    		ASCII$FIL$PTR ADDRESS;

    ASCII$FIL$PTR = CONVERT$FILENAME(INT$FIL$PTR,ASCII$DEVICE$NUMBER);
	CALL WRITE$CO(ASCII$FIL$PTR);
    CALL DELETE(ASCII$FIL$PTR,.X$STATUS);

	IF X$STATUS = 0 THEN
		CALL WRITE$CO(.('DELETED',CR,LF,0));
    ELSE IF (X$STATUS=14) THEN
        CALL WRITE$CO(.('WRITE PROTECTED',CR,LF,0));
    ELSE
        DO;
             CALL WRITE$CO(.('ISIS ERROR ',0));
             CALL NUM$OUT(CONSOLE$OUTPUT,X$STATUS);
             CALL WRITE$CO(.(CR,LF,0));
        ENDDO;
	ENDIF

    END
DELETE$IT;

PROCESS$ONE$ENTRY:
	PROCEDURE;
	IF DELETEABLE$EXTENSION THEN
		CALL DELETE$IT(.DIR$ENTRY.FILENAME);
	ELSE IF NUMERIC$EXTENSION(.DIR$ENTRY.EXTENSION) THEN
		CALL ENTER$FILE;
	ENDIF
	/*	Notice that if the filename has neither a deletetable,
		not a numeric extension, then it is ignored. */
	END
PROCESS$ONE$ENTRY;

PROCESS$DIRECTORY:
	PROCEDURE;

	/* Main Directory Processing Loop. */

	DO WHILE  DIR$ENTRY$PTR < END$OF$DIRECTORY;
	   IF NOT READING$REMOTE  THEN
	     DO;
	        IF DIR$ENTRY.PRESENCE = 7FH  THEN
	           GO TO no$more$dir;
	        IF DIR$ENTRY.PRESENCE = 0FFH  THEN
	           GO TO bump$ptr;
	     END;
	   CALL PROCESS$ONE$ENTRY;

	   bump$ptr:
	   DIR$ENTRY$PTR = DIR$ENTRY$PTR + 16;
    ENDDO;

 no$more$dir:
	END
PROCESS$DIRECTORY;

RECONSTITUTE$FILENAME:
	PROCEDURE (COMPACT$EXT) ADDRESS;

	DECLARE COMPACT$EXT ADDRESS;

    DECLARE BUF (9) BYTE;
	DECLARE Z BYTE;

	DO Z=0 TO 5;
		BUF(Z) = FILE.NAME(Z);
	ENDDO;

	DO Z=0 TO 2;
		BUF(LAST(BUF)-Z) = (COMPACT$EXT MOD 10) + '0';
        COMPACT$EXT      = COMPACT$EXT / 10;
	ENDDO;
	RETURN (.BUF);

	END
RECONSTITUTE$FILENAME;

DELETE$A$NAMEFUL:
	PROCEDURE;
	EXT$PTR = FILE.EXT$PTR;

	begin$loop:
		/*	Don't delete the file with the largest extension. */
        IF EXTENSION.VALUE < FILE.LARGEST THEN
        	CALL DELETE$IT(RECONSTITUTE$FILENAME(EXTENSION.VALUE));
		ENDIF
        IF EXTENSION.NEXT<>0 THEN
			DO;
				EXT$PTR = EXTENSION.NEXT;
				GOTO begin$loop;
			ENDDO;
		ENDIF
	end$loop
	END
DELETE$A$NAMEFUL;

DELETE$A$BUCKET$FUL:
	PROCEDURE (BUCKET$INDEX) ;
	DECLARE BUCKET$INDEX ADDRESS;

	MEM$PTR = BUCKET(BUCKET$INDEX);
    loop$label:
		CALL DELETE$A$NAMEFUL;
		IF FILE.NEXT<>0 THEN
			DO;
				MEM$PTR = FILE.NEXT;
				GOTO loop$label;
			ENDDO;
		ENDIF
	end$loop
	END
DELETE$A$BUCKET$FUL;

DELETE$FILES:
	PROCEDURE;
	DECLARE WHICH$BUCKET ADDRESS;

    DO WHICH$BUCKET=0 TO 255;
		IF BUCKET(WHICH$BUCKET)<>0 THEN
			CALL DELETE$A$BUCKET$FUL(WHICH$BUCKET);
    	ENDIF
    ENDDO;
	END
DELETE$FILES;

$ EJECT

/****************************************************************/
/*																*/
/*			MAIN		LINE			CODE					*/
/*																*/
/****************************************************************/

CALL INITIALIZE;
CALL PARSE$COMMAND$TAIL;
CALL READ$IN$DIRECTORY;
CALL PROCESS$DIRECTORY;
CALL DELETE$FILES;
CALL EXIT;

END
CLEAN$MOD;
EOF
src/cli.plm
$ TITLE ('==> PASSIF -- CLIMOD -- COMMAND LINE INTERPRETOR <==')

CLI$MOD:
DO;

/************************************************************************/
/*																		*/
/*      '(C) Intel Corporation 1981'.  All rights reserved.  No			*/
/*      part of this program or publication may be reproduced,			*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

$ NOLIST

/*         LIT.INC          */

DECLARE                 AS LITERALLY 'LITERALLY',              /* plm */
    AMPERSAND           AS '''&''',							   /* ??? */
    BELL                AS '07H',                              /* plm */
    BLANK               AS '020H',                             /* plm */
    BOOLEAN             AS 'BYTE',                             /* plm */
    CHK                 AS 'CALL CHECK$STATUS',	               /* plm */
    CLEAR$CHAR			AS '01CH',							   /* 1510 */
    CO$ECHO$FILE        AS '0F00H',                            /* open */
    COLON               AS ''':''',                            /* char */
    COMMA               AS '02CH',                       	   /* plm */
    CONSOLE$INPUT       AS '1',                                /* open */
    CONSOLE$OUTPUT      AS '0',                                /* open */
    CONTROL$Z           AS '01AH',                             /* plm */
    CR                  AS '0DH',                              /* plm */
    DOT                 AS '''.''',                            /* char */
    END$DO              AS 'END',                              /* plm */
    END$DO$CASE         AS 'END',                              /* plm */
    END$DO$WHILE        AS 'END',                              /* plm */
    END$IF              AS '   ',                              /* plm */
    END$ITERATED$DO		AS 'END',							   /* plm */
    END$LOOP            AS ' ',                                /* plm */
    EOF$CHAR            AS 'CONTROL$Z',                        /* plm */
    ESC                 AS '01BH',                             /* plm */
    FALSE               AS '0H',                               /* plm */
    FF					AS '0CH',							   /* ??? */
    FOREVER             AS 'WHILE 1',                          /* plm */
    FORMAT$ATTRIBUTE	AS '3',								   /* attrib */
    HASH$MARK			AS '''#''',							   /* plm */
    INIT$STG			AS '(*) BYTE INITIAL',				   /* plm */
    LEAD$IN$CHAR		AS '07EH',							   /*1510 */
    LF                  AS '0AH',                              /* plm */
    NO$LINE$EDIT        AS '0',                                /* open */
    NULL				AS '0FFFFH',						   /* ???  */
    OPEN$FOR$READ       AS '1',                                /* open */
    OPEN$FOR$WRITE      AS '2',                                /* open */
    OPEN$FOR$UPDATE		AS '3',								   /* open */
    PUB$STRING			AS '(*) BYTE PUBLIC DATA',             /* plm  */
    RESET				AS '0',								   /* attrib */
    RETURN$MARKER$POS   AS '0',                                /* seek */
    SEEK$2$EOF          AS '4',                                /* seek */
    SEEK$BACKWARD$BY$N  AS '1',                                /* seek */
    SEEK$FORWARD$BY$N	AS '3',								   /* seek */
    SEEK$2$N            AS '2',                                /* seek */
    SEMICOLON			AS ''';''',							   /* plm  */
    SET					AS '1',								   /* attrib */
    STRING              AS '(*) BYTE DATA',                    /* plm  */
    TAB                 AS '09H',                              /* plm */
    TRANSFER$CONTROL    AS '1',                                /* load */
    TRUE                AS '0FFH',                             /* plm */
    UNDERBAR			AS '''_''', 						   /* ??? */
    USER$CI             AS '0',                                /* ??? */
    WRITE$PROTECT$ATTRIBUTE 		AS '2',					   /* attrib */
    ZERO$BIAS           AS '0'                                 /* load */ ;

    /*        ENDLIT.INC        */

$ LIST
$ NOLIST

		/* ISIS.INC */

ATTRIB:
	PROCEDURE(FILE$NAME$PTR,WHICH$ATTRIBUTE,SET$OR$RESET,STATUS$PTR) EXTERNAL;
	DECLARE (FILE$NAME$PTR,WHICH$ATTRIBUTE,SET$OR$RESET,STATUS$PTR) ADDRESS;
	END
ATTRIB;

CLOSE:
	PROCEDURE (AFTN,STATUS) EXTERNAL;
	DECLARE (AFTN,STATUS) ADDRESS;
	END
CLOSE;

CI:
	PROCEDURE BYTE EXTERNAL;
	END
CI;

CO:
	PROCEDURE (CHAR$CO) EXTERNAL;
	DECLARE CHAR$CO BYTE;
	END
CO;

CONSOL:
	PROCEDURE (CONSOLE$INPUT$FILE,CONSOL$OUTPUT$FILE,STATUS$CON) EXTERNAL;
	DECLARE (CONSOLE$INPUT$FILE,CONSOL$OUTPUT$FILE,STATUS$CON) ADDRESS;
	END
CONSOL;

DELETE:
	PROCEDURE (FILE$NAME$PTR,STATUS) EXTERNAL;
	DECLARE (FILE$NAME$PTR,STATUS) ADDRESS;
	END
DELETE;

ERROR:
	PROCEDURE  (ERROR$NUMBER) EXTERNAL;
	DECLARE ERROR$NUMBER ADDRESS;
	END
ERROR;

EXIT:
	PROCEDURE EXTERNAL;
	END
EXIT;

IO$CHK:
	PROCEDURE BYTE EXTERNAL;
	END
IO$CHK;

IO$DEF:
	PROCEDURE (WHICH$DEVICE,ENTRY$POINT) EXTERNAL;
	DECLARE WHICH$DEVICE BYTE,
			ENTRY$POINT ADDRESS;
	END
IO$DEF;

IO$SET:
	PROCEDURE (CONFIGURATION$BYTE) EXTERNAL;
	DECLARE CONFIGURATION$BYTE BYTE;
	END
IO$SET;

LOAD:
	PROCEDURE (FILE,BIAS,CONTROL$OF$TRANSFER,ENTRY$POINT,STATUS) EXTERNAL;
	DECLARE (FILE,BIAS,CONTROL$OF$TRANSFER,ENTRY$POINT,STATUS) ADDRESS;
	END
LOAD;

MEMCK:
	PROCEDURE ADDRESS EXTERNAL;
	END
MEMCK;

OPEN:
	PROCEDURE(AFTN,FILENAME,ACCESS$MODE,LINE$EDIT$AFTN,ERROR) EXTERNAL;
	DECLARE (AFTN,FILENAME,ACCESS$MODE,LINE$EDIT$AFTN,ERROR) ADDRESS;
	END
OPEN;

READ:
	PROCEDURE (AFTN,BUFFER,COUNT,ACTUAL,STATUS) EXTERNAL;
	DECLARE (AFTN,BUFFER,COUNT,ACTUAL,STATUS) ADDRESS;
	END
READ;

RENAME:
	PROCEDURE (OLD$NAME,NEW$NAME,STATUS$R) EXTERNAL;
	DECLARE (OLD$NAME,NEW$NAME,STATUS$R) ADDRESS;
	END
RENAME;

RESCAN:
	PROCEDURE (AFTN,STATUS) EXTERNAL;
	DECLARE (AFTN,STATUS) ADDRESS;
	END
RESCAN;

SEEK:
	PROCEDURE (AFTN,MODE,BLOCKNO,BYTENO,STATUS) EXTERNAL;
	DECLARE (AFTN,MODE,BLOCKNO,BYTENO,STATUS) ADDRESS;
	END
SEEK;

SPATH:
	PROCEDURE (FILE,BUFFER,STATUS) EXTERNAL;
	DECLARE (FILE,BUFFER,STATUS) ADDRESS;
	END
SPATH;

WHOCON:
	PROCEDURE (AFTN,BUFFER) EXTERNAL;
	DECLARE (AFTN,BUFFER) ADDRESS;
	END
WHOCON;

WRITE:
	PROCEDURE (AFTN,BUFFER,COUNT,STATUS) EXTERNAL;
	DECLARE (AFTN,BUFFER,COUNT,STATUS) ADDRESS;
	END
WRITE;

		/* END ISIS.INC */
$ NOLIST

/************************************************************/
/*															*/
/*              LITERALLY'S UNIQUE TO PASSIF                */
/*															*/
/************************************************************/

DECLARE
    MINIMUM$ACCEPTABLE$BANNER$LENGTH 	AS 		'73',
    MAXIMUM$TOKEN$LENGTH				AS		'70',
    BI									AS		'CALL BOMB$IF(STATUS)',

	FIRST$FIELD							AS		'0',
    SECOND$FIELD						AS		'28',
    THIRD$FIELD							AS		'54',

    RIGHT$PARENTHESIS 					AS		''')''',
    LEFT$PARENTHESIS 					AS		'''(''',
    RI									AS		'CALL REPORT$IF',
    UNRECOGNIZED$SWITCH$ERR 			AS		'201',
    QUESTION$MARK						AS		'''?''';

$ LIST
$ NOLIST

/*	MAIN.INC  */

DECLARE
    ACTUAL ADDRESS EXTERNAL,
    AFTN ADDRESS EXTERNAL,
    COMMAND$TAIL$BUF (250) BYTE EXTERNAL,
    DELIMITER BYTE EXTERNAL,
    FIRST$BLOCK$BUF (128) BYTE EXTERNAL,
    FIRST$OUTPUT$MSG$PTR ADDRESS EXTERNAL,
    FIRST$TIME$THROUGH BOOLEAN EXTERNAL,
    INITIALIZED$BANNER (74) BYTE EXTERNAL,
    PRINT$HASH$MARK BOOLEAN EXTERNAL,
    REPORT$FILE$ACTUAL ADDRESS EXTERNAL,
    REPORT$FILE$AFTN ADDRESS EXTERNAL,
    REPORT$FILE$STRING$BEGINNING ADDRESS EXTERNAL,
    SECOND$OUTPUT$MSG$PTR ADDRESS EXTERNAL,
    STATUS ADDRESS EXTERNAL,
    TMP$FILE$AFTN ADDRESS EXTERNAL,
    TMP$FILE$NAME (15) BYTE EXTERNAL,
    TOK$BUF (80) BYTE EXTERNAL;

DECLARE
    KEY$WORDS (10) STRUCTURE
    (LENGTH							BYTE,
    KEY$WORD	(13)				BYTE,
    PROC$PTR						ADDRESS) EXTERNAL;

CO$IS$VO:
	PROCEDURE BOOLEAN EXTERNAL;
	END
CO$IS$VO;

EXIT$ROUTINE:
	PROCEDURE EXTERNAL;
	END
EXIT$ROUTINE;

RE$POSITION$CURSOR:
	PROCEDURE EXTERNAL;
	END
RE$POSITION$CURSOR;

MOVE:
	PROCEDURE (COUNT,SOURCE$PTR,DEST$PTR) EXTERNAL;
	DECLARE (COUNT,SOURCE$PTR,DEST$PTR) ADDRESS;
	END
MOVE;

/*	END MAIN.INC  */
$ LIST
$ NOLIST

/*	TOKENS.INC  */

GET$ARGUMENT:
	PROCEDURE (BUF$PTR,STATUS$PTR) BYTE EXTERNAL;
	DECLARE (BUF$PTR,STATUS$PTR) ADDRESS;
    END
GET$ARGUMENT;

/*	END TOKENS.INC  */
$ LIST
$ NOLIST

/*	ERRMSG.INC  */

DECLARE
	BAD$SYNTAX$MSG 				(29) 				BYTE		EXTERNAL,
	BOMB$IF$MSG$1    			(12) 				BYTE		EXTERNAL,
	BOMB$IF$MSG$2				(40) 				BYTE		EXTERNAL,
    DURING$ASSERTION$CHECK$MSG	(50)				BYTE		EXTERNAL,
    PASSIF$INVOKED$BY$MSG       (19)                BYTE        EXTERNAL,
    ZERO$LENGTH$FILE$MSG 		(40) 				BYTE		EXTERNAL;

/*	END ERRMSG.INC  */
$ LIST
$ NOLIST

/*	REPORT.INC  */

BOMB$IF:
	PROCEDURE (STATUS) EXTERNAL;
    DECLARE STATUS ADDRESS;
    END
BOMB$IF;

REPORT$SYNTAX$ERROR:
	PROCEDURE EXTERNAL;
	END
REPORT$SYNTAX$ERROR;

REPORT$ISIS$ERROR:
	PROCEDURE (STATUS) EXTERNAL;
	DECLARE STATUS ADDRESS;
	END
REPORT$ISIS$ERROR;

REPORT$ASSERTION$SUCCESS:
	PROCEDURE EXTERNAL;
	END
REPORT$ASSERTION$SUCCESS;

REPORT$ASSERTION$FAILURE:
	PROCEDURE EXTERNAL;
	END
REPORT$ASSERTION$FAILURE;

REPORT$ASSERTION$FAILURE$W$ISIS$ERR:
	PROCEDURE (STATUS) EXTERNAL;
	DECLARE STATUS ADDRESS;
    END
REPORT$ASSERTION$FAILURE$W$ISIS$ERR;

REPORT$ASSERTION$FAILURE$W$MSG:
	PROCEDURE (OLD$STYLE$MSG$PTR) EXTERNAL;
	DECLARE OLD$STYLE$MSG$PTR ADDRESS;
    END
REPORT$ASSERTION$FAILURE$W$MSG;

MSG$LENGTH:
	PROCEDURE (OLD$STYLE$MSG$PTR) BYTE EXTERNAL;
    DECLARE OLD$STYLE$MSG$PTR ADDRESS;
	END
MSG$LENGTH;

/*	END REPORT.INC  */
$ LIST
$ NOLIST

/*	FUNC.INC  */

FILE$EXISTS:
	PROCEDURE EXTERNAL;
	END
FILE$EXISTS;

FILE$ABSENT:
	PROCEDURE EXTERNAL;
	END
FILE$ABSENT;

FILES$MATCH:
	PROCEDURE EXTERNAL;
    END
FILES$MATCH;

STRING$FOUND:
	PROCEDURE EXTERNAL;
	END
STRING$FOUND;

STRING$ABSENT:
	PROCEDURE EXTERNAL;
	END
STRING$ABSENT;

/*	END FUNC.INC  */
$ LIST

$ EJECT

/************************************************************/
/*															*/
/*                        NOTES                             */
/*															*/
/************************************************************/

ENFORCE$DELIMITER:
	PROCEDURE(ENFORCEE) PUBLIC;
	DECLARE ENFORCEE BYTE;
    IF NOT DELIMITER=ENFORCEE THEN
		CALL REPORT$SYNTAX$ERROR;
	ENDIF
	END
ENFORCE$DELIMITER;

UDI$STRING$MATCH:
	PROCEDURE (STG$1$PTR,STG$2$PTR) BOOLEAN PUBLIC;

	/*	This procedure ascertains whether two UDI-type strings match. */

    DECLARE S BYTE;
    DECLARE (STG$1$PTR,STG$2$PTR) ADDRESS,
              STG$1		BASED STG$1$PTR			(100)		BYTE,
              STG$2		BASED STG$2$PTR			(100)		BYTE;

    DECLARE (STG$1$COUNT,STG$2$COUNT) BYTE;

	STG$1$COUNT = STG$1(0);
    STG$2$COUNT = STG$2(0);

    IF STG$1$COUNT <> STG$2$COUNT THEN
    	RETURN FALSE;
    ELSE
    	DO S=1 TO STG$1$COUNT;
			IF STG$1(S) <> STG$2(S) THEN
				RETURN FALSE;
			ENDIF
    	END$ITERATED$DO;
    ENDIF

    RETURN TRUE;
	END
UDI$STRING$MATCH;

$ EJECT

/************************************************************/
/*															*/
/*                      NEXT$ARG                            */
/*															*/
/************************************************************/

/*	The following variable will be equal to the number of bytes in
	command$tail$buf. */
DECLARE BUF$COUNT BYTE PUBLIC INITIAL (0);
DECLARE SINGLE$CHAR$UDI$STG (2) BYTE INITIAL (1,HASH$MARK);

NEXT$ARG:
	PROCEDURE PUBLIC;

	DECLARE BYTES$LEFT BYTE;

$ EJECT

    /************************************************************/
    /*														    */
    /*              PROCEDURES LOCAL TO  NEXT$ARG               */
    /*															*/
    /************************************************************/

    STUFF$COMMAND$TAIL$BUF$W$UDI$STG:
		PROCEDURE (UDI$STG$PTR);

        DECLARE UDI$STG$PTR ADDRESS,
        		UDI$STG BASED UDI$STG$PTR (100) BYTE;

        BYTES$LEFT = SIZE(COMMAND$TAIL$BUF) - BUF$COUNT;
        IF UDI$STG(0)<=BYTES$LEFT THEN
            DO;
                /*	Move data into command tail buffer. */
                CALL MOVE(/*count*/				UDI$STG(0),
                          /*source*/			.UDI$STG(1),
                          /*destination*/		.COMMAND$TAIL$BUF(BUF$COUNT));
                BUF$COUNT = BUF$COUNT + UDI$STG(0);
            ENDDO;
        ELSE
            DO;
                /*	Error condition  --  command tail buffer overflow. */
                CALL MOVE(/*count*/				BYTES$LEFT,
                          /*source*/			.UDI$STG(1),
                          /*destination*/		.COMMAND$TAIL$BUF(BUF$COUNT));
                BUF$COUNT = BUF$COUNT + BYTES$LEFT;
                CALL REPORT$SYNTAX$ERROR;
            ENDDO;
        ENDIF
    	END
    STUFF$COMMAND$TAIL$BUF$W$UDI$STG;

    ADD$CHAR$TO$ARG:
    	PROCEDURE (ADDEE);
		DECLARE ADDEE BYTE;
        SINGLE$CHAR$UDI$STG (1) = ADDEE;
		CALL STUFF$COMMAND$TAIL$BUF$W$UDI$STG(.SINGLE$CHAR$UDI$STG);
        END
    ADD$CHAR$TO$ARG;

$ EJECT

    /************************************************************/
    /*														    */
    /*         FIRST EXECUTABLE IN PROCEDURE NEXT$ARG           */
    /*															*/
    /************************************************************/

    /*	First, get the argument. */
    DELIMITER = GET$ARGUMENT(.TOK$BUF,.STATUS);

	/*	Set the byte following the last byte of the string to 0
		so that, when the token consists of an isis filename, it
		will be delimited. */
    TOK$BUF(TOK$BUF(0)+1) = 0;

    /*	Don't check status yet.  Wait until whatever string
		was returned has been moved in the argument buffer,
		so that a more complete error message is returned. */

    /*	Move the string to the command tail buffer. */
    CALL STUFF$COMMAND$TAIL$BUF$W$UDI$STG(.TOK$BUF);

    /*	Move the delimiter into the token buffer. */
    CALL ADD$CHAR$TO$ARG(DELIMITER);

    /*	Append a line-feed, if necessary. */
    IF DELIMITER = CR THEN
    	CALL ADD$CHAR$TO$ARG(LF);
    ENDIF

    IF STATUS<>0 THEN
		CALL REPORT$SYNTAX$ERROR;
	ENDIF

    END
NEXT$ARG;

$ EJECT

/************************************************************/
/*															*/
/*                INTERPRET$COMMAND$LINE                    */
/*															*/
/************************************************************/

DECLARE THE$STRING INIT$STG (1,BLANK);

INTERPRET$COMMAND$LINE:
	PROCEDURE PUBLIC;

	DECLARE INDEX BYTE;
    DECLARE SIGN$ON$MSG STRING
    	('ISIS-II ASSERTION CHECKING UTILITY, V1.0',CR,LF);

    SHOULDNT$HAVE$GOTTEN$THIS$FAR:
    	PROCEDURE;
        STATUS = UNRECOGNIZED$SWITCH$ERR;
        CALL REPORT$ASSERTION$FAILURE$W$ISIS$ERR(STATUS);
    	END
    SHOULDNT$HAVE$GOTTEN$THIS$FAR;

	UDI$CHAR:
		PROCEDURE (A$CHAR) ADDRESS;
        DECLARE A$CHAR BYTE;
		THE$STRING(1) = A$CHAR;
		RETURN (.THE$STRING);
		END
    UDI$CHAR;

    SIGN$ON$AND$EXIT:
		PROCEDURE;
        CALL WRITE(CONSOLE$OUTPUT,.SIGN$ON$MSG,SIZE(SIGN$ON$MSG),.STATUS);
        CALL EXIT;
		END
    SIGN$ON$AND$EXIT;

$ EJECT

    /************************************************************/
    /*															*/
    /*       FIRST EXECUTABLE IN INTERPRET$COMMAND$LINE         */
    /*															*/
    /************************************************************/

	/*	The first call to next$arg should return the name of the
		load module, which normally will be PASSIF.  The delimiter
		returned by this first call should be a blank.

		A legal exception to the above rule is if the PASSIF delimiter
		is a question mark. */

    CALL NEXT$ARG;
    IF DELIMITER=QUESTION$MARK THEN
    	CALL SIGN$ON$AND$EXIT;
    ELSE
        CALL ENFORCE$DELIMITER(BLANK);
    ENDIF

    /*	This next call to next$arg should pick up a Passif keyword,
    	which will tell Passif what assertion checking function it is
    	to perform.  It is legal, however, for the next token to be
    	a question mark.  If it is, then Passif prints an identification
    	message and exits. */
    CALL NEXT$ARG;

    IF UDI$STRING$MATCH (UDI$CHAR(QUESTION$MARK),.TOK$BUF(0)) THEN
    	CALL SIGN$ON$AND$EXIT;
    ENDIF

    /*	All legal Passif command tails must have the first keyword
    	delimited by a parenthesis. */
    CALL ENFORCE$DELIMITER(LEFT$PARENTHESIS);

    DO INDEX=0 TO LAST(KEY$WORDS);
        IF UDI$STRING$MATCH(.TOK$BUF(0),.KEY$WORDS(INDEX).LENGTH) THEN
            DO;
                DECLARE AN$ADDRESS$SCALAR ADDRESS;
                AN$ADDRESS$SCALAR = KEY$WORDS(INDEX).PROC$PTR;
        		CALL AN$ADDRESS$SCALAR;
            ENDDO;
        ENDIF
    END$ITERATED$DO;

    /*	If any of the keywords matched, and the procedure was called, then
    	the program wouldn't have gotten this far, so the token in the
        command tail must not have matched any of the keywords. So. . .*/
    CALL SHOULDNT$HAVE$GOTTEN$THIS$FAR;

	END
INTERPRET$COMMAND$LINE;

END
CLI$MOD;
src/close.pex
close: procedure (conn, status$p) external;
    declare (conn, status$p) address;
end close;
src/cmovem.plm
$TITLE('==>  C M O V E M  <==  CHKLOD')

CMOVEM:
DO;

/************************************************************************/
/*																		*/
/*      '(C) Intel Corporation 1981'.  All rights reserved.  No			*/
/*      part of this program or publication may be reproduced,			*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

movem: PROCEDURE (count,src,dst) PUBLIC;
  DECLARE (count,src,dst) ADDRESS;

  IF count <> 0 THEN
    CALL move (count, src, dst);
END movem;

END;
src/compar.plm
COMPAR: DO;

/************************************************************************/
/*																		*/
/*      '(C) Intel Corporation 1981'.  All rights reserved.  No			*/
/*      part of this program or publication may be reproduced,			*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

DECLARE COPYRIGHT (*) BYTE DATA ('(C) INTEL CORP 1981');

DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.0',0);
    

/*  SOURCE COMPARE PROGRAM */
/* COMMAND SYNTAX: COMPAR <FILE1> TO <FILE2> [PRINT( <OUTFILE>)] &  */
/*                   [ SYNC( <NUMBER>)]                            */

/* EXTERNAL PROCEDURE DECLARATIONS */

MEMCK: PROCEDURE ADDRESS EXTERNAL;
END MEMCK;

CONVND: PROCEDURE(NUMBER,DIGITS) EXTERNAL;
  DECLARE (NUMBER,DIGITS) ADDRESS;
END CONVND;

READ:PROCEDURE(AFTN,BUFFER,LEN,ACTUAL,STATUS)EXTERNAL;
  DECLARE(AFTN,BUFFER,LEN,ACTUAL,STATUS) ADDRESS;
END READ;

EXIT: PROCEDURE EXTERNAL;
END EXIT;

CHECK$STATUS: PROCEDURE EXTERNAL;
END CHECK$STATUS;

COMMAND: PROCEDURE EXTERNAL;
END COMMAND;

DISPLAY: PROCEDURE(LEN,BUFFER) EXTERNAL;
  DECLARE
    LEN BYTE,
    BUFFER ADDRESS;
END DISPLAY;

NEW$LINE: PROCEDURE EXTERNAL;
END NEW$LINE;

BLANKS: PROCEDURE(LEN) EXTERNAL;
  DECLARE LEN BYTE;
END BLANKS;

DUMP: PROCEDURE EXTERNAL;
END DUMP;

/* LOCAL DECLARATIONS */

DECLARE
  SYNCPARM BYTE PUBLIC,
  POINTER LITERALLY 'ADDRESS',    /* WHEN USED AS POINTER */
  INDEX LITERALLY 'ADDRESS',    /* WHEN USED AS INDEX INTO BUFS */
  BOOLEAN LITERALLY 'BYTE',
  TRUE LITERALLY '0FFH',
  FALSE LITERALLY '0',
  CR LITERALLY '0DH',    /* ASCII */
  LF LITERALLY '0AH',    /* ASCII */

  OUT$AFTN ADDRESS PUBLIC,    /* AFTN OF LIST FILE */
  IDENTICAL BOOLEAN,    /* IF FILES COMPLETELY THE SAME */
  ACTUAL ADDRESS EXTERNAL,    /* RETURNED BY ISIS */
  STATUS ADDRESS EXTERNAL,    /* RETURNED BY ISIS */
  BUF$LENGTH ADDRESS,    /* AS LARGE AS POSSIBLE - I.E. (MEMCK-.MEMORY)/4 */

  FILE$NAME$0 (15) BYTE PUBLIC INITIAL('               '),
  FILE$NAME$1 (15) BYTE PUBLIC INITIAL('               '),
  RCD0 BYTE, /* INDEX IN QUEUE0 OF RECORD DESCRIPTOR */
  RCD1 BYTE, /* INDEX IN QUEUE1 OF RECORD DESCRIPTOR */
  NOMATCH BOOLEAN, /* FLAG USED IN SYNCRONIZATION */

  QUEUE0 STRUCTURE(    /* ONE QUEUE FOR EACH INPUT FILE */
                       /* RECORDS OLDEST -> NEXTH-1 ARE IN HASH TABLE */
                       /* RECORDS NEXTH -> NEXT-1 HAVE BEEN SCANNED BUT */
                       /* ARE NOT IN HASH TABLE.  NOTE THAT THE QUEUE WRAPS */
                       /* AROUND MOD 255.  255 = 0FFH IS THE NULL ADDRESS */
    OLDEST BYTE, /* OLDEST RECORD IN HASH TABLE */
    HCOUNT BYTE, /* NUMBER OF RECORDS IN HASH TABLE */
    NEXTH BYTE,  /* NEXT RECORD TO BE PLACED IN HASH TABLE */
    UCOUNT BYTE, /* NUMBER OF UNHASHED RECORDS IN QUEUE */
    NEXT BYTE,   /* NEXT AVAILABLE SLOT IN QUEUE */
    RECNUM ADDRESS, /* RECORD NUMBER OF OLDEST IN QUEUE */
    BUFA ADDRESS, /* ADDRESS OF BUFFER DESCRIPTOR FOR FILE USING */
                  /* USING THIS QUEUE */
    AFTN ADDRESS, /* AFTN OF FILE USING THIS QUEUE */

    /* THE FOLLOWING IDENTIFIERS REFER TO INDIVIDUAL RECORDS */

    ADDR(255) ADDRESS, /* ADDRESS OF INDIVIDUAL RECORD */
    LEN(255) BYTE, /* LENGTH OF RECCORD */
    CYCLE(255) BYTE, /* HASH ADDRESS OF RECORD */
    HLINK(255) BYTE, /* LINK FOR THE HASH TABLE BUCKETS */

    /* THE FOLLOWING ARRAY IS THE HASH TABLE, STORING UNMATCHED RECORDS */

    HTABLE(256) BYTE
    ),
  QUEUE1 STRUCTURE(    /* ONE QUEUE FOR EACH INPUT FILE */
                       /* RECORDS OLDEST -> NEXTH-1 ARE IN HASH TABLE */
                       /* RECORDS NEXTH -> NEXT-1 HAVE BEEN SCANNED BUT */
                       /* ARE NOT IN HASH TABLE.  NOTE THAT THE QUEUE WRAPS */
                       /* AROUND MOD 255.  255 = 0FFH IS THE NULL ADDRESS */
    OLDEST BYTE, /* OLDEST RECORD IN HASH TABLE */
    HCOUNT BYTE, /* NUMBER OF RECORDS IN HASH TABLE */
    NEXTH BYTE,  /* NEXT RECORD TO BE PLACED IN HASH TABLE */
    UCOUNT BYTE, /* NUMBER OF UNHASHED RECORDS IN QUEUE */
    NEXT BYTE,   /* NEXT AVAILABLE SLOT IN QUEUE */
    RECNUM ADDRESS, /* RECORD NUMBER OF OLDEST IN QUEUE */
    BUFA ADDRESS, /* ADDRESS OF BUFFER DESCRIPTOR FOR FILE USING */
                  /* USING THIS QUEUE */
    AFTN ADDRESS, /* AFTN OF FILE USING THIS QUEUE */

    /* THE FOLLOWING IDENTIFIERS REFER TO INDIVIDUAL RECORDS */

    ADDR(255) ADDRESS, /* ADDRESS OF INDIVIDUAL RECORD */
    LEN(255) BYTE, /* LENGTH OF RECCORD */
    CYCLE(255) BYTE, /* HASH ADDRESS OF RECORD */
    HLINK(255) BYTE, /* LINK FOR THE HASH TABLE BUCKETS */

    /* THE FOLLOWING ARRAY IS THE HASH TABLE, STORING UNMATCHED RECORDS */

    HTABLE(256) BYTE
    ),

  BUF$DSPTR(4) STRUCTURE (
    LOW$ADDR ADDRESS, /* ADDRESS OF BUFFER */
    HIGH$ADDR ADDRESS, /* HIGHEST ADDRESS IN BUFFER */
    NEXT$DSPTR ADDRESS, /* ADDRESS OF DSPTR OF FOLLOWING BUFFFER */
    PTR ADDRESS, /* CURRENT SCANNING POSITION */
    EOD ADDRESS /* END OF DATA IN BUFFER, NOT NECESSARILY END OF FILE */
    ),
  AFTN0 ADDRESS PUBLIC AT(.QUEUE0.AFTN), /* TO COMMUNICATE WITH COMMAND */
  AFTN1 ADDRESS PUBLIC AT(.QUEUE1.AFTN);

SPACEFAIL: PROCEDURE;

  /* CALLED WHEN THE PROGRAM RUNS OUT OF BUFFER OR QUEUE SPACE */

  CALL DISPLAY(45,.('***** NOT ENOUGH SPACE TO SYNCHRONIZE *****',CR,LF));
  CALL DUMP;
  CALL EXIT;

END SPACEFAIL;

HASH$INSERT: PROCEDURE(QA);

  /* PROCEDURE TO INSERT THE LAST RECORD RETURNED BY READRECORD */
  /* INTO THE HASH TABLE */

  DECLARE
    QA ADDRESS, /* POINTER TO BASE THE QUEUE */
    Q BASED QA STRUCTURE( /* THE LOCAL COPY OF THE QUEUE */
                       /* RECORDS OLDEST -> NEXTH-1 ARE IN HASH TABLE */
                       /* RECORDS NEXTH -> NEXT-1 HAVE BEEN SCANNED BUT */
                       /* ARE NOT IN HASH TABLE.  NOTE THAT THE QUEUE WRAPS */
                       /* AROUND MOD 255.  255 = 0FFH IS THE NULL ADDRESS */
      OLDEST BYTE, /* OLDEST RECORD IN HASH TABLE */
      HCOUNT BYTE, /* NUMBER OF RECORDS IN HASH TABLE */
      NEXTH BYTE,  /* NEXT RECORD TO BE PLACED IN HASH TABLE */
      UCOUNT BYTE, /* NUMBER OF UNHASHED RECORDS IN QUEUE */
      NEXT BYTE,   /* NEXT AVAILABLE SLOT IN QUEUE */
      RECNUM ADDRESS, /* RECORD NUMBER OF OLDEST IN QUEUE */
      BUFA ADDRESS, /* ADDRESS OF BUFFER DESCRIPTOR FOR FILE USING */
                    /* USING THIS QUEUE */
      AFTN ADDRESS, /* AFTN OF FILE USING THIS QUEUE */

      /* THE FOLLOWING IDENTIFIERS REFER TO INDIVIDUAL RECORDS */

      ADDR(255) ADDRESS, /* ADDRESS OF INDIVIDUAL RECORD */
      LEN(255) BYTE, /* LENGTH OF RECCORD */
      CYCLE(255) BYTE, /* HASH ADDRESS OF RECORD */
      HLINK(255) BYTE, /* LINK FOR THE HASH TABLE BUCKETS */

      /* THE FOLLOWING ARRAY IS THE HASH TABLE, STORING UNMATCHED RECORDS */

      HTABLE(256) BYTE
      ),
    RCD BYTE, /* RECORD TO BE PLACED IN HASH TABLE */
    CYCLE BYTE; /* HASH ADDRESS OF RCD */

  /* INCREMENT NEXTH */
  IF (RCD := Q.NEXTH) = 0FEH
  THEN Q.NEXTH = 0;
  ELSE Q.NEXTH = RCD + 1;

  /* REMOVE RECORD FROM READ SECTION OF QUEUE */
  Q.UCOUNT = Q.UCOUNT - 1;
  Q.HCOUNT = Q.HCOUNT + 1;

  CYCLE = Q.CYCLE(RCD);
  /* ADD RCD TO HTABLE(CYCLE)'S BUCKET */
  Q.HLINK(RCD) = Q.HTABLE(CYCLE);
  Q.HTABLE(CYCLE) = RCD;

END HASH$INSERT;

READRECORD: PROCEDURE(QA) BYTE;

/* THIS PROCEDURE RETURNS THE INDEX OF THE DESCRIPTOR IN THE QUEUE(FILE) */
/* OF THE NEXT RECORD */

  DECLARE
    QA ADDRESS, /* POINTER TO Q */
    Q BASED QA STRUCTURE ( /* THIS IS THE LOCAL VERSION OF QUEUE IN MAIN DO */
                           /* ONE QUEUE FOR EACH INPUT FILE */
                           /* RECORDS OLDEST -> NEXTH-1 ARE IN HASH TABLE */
                           /* RECORDS NEXTH -> NEXT-1 HAVE BEEN SCANNED BUT */
                        /* ARE NOT IN HASH TABLE.  NOTE THAT THE QUEUE WRAPS */
                        /* AROUND MOD 255.  255 = 0FFH IS THE NULL ADDRESS */
    OLDEST BYTE, /* OLDEST RECORD IN HASH TABLE */
    HCOUNT BYTE, /* NUMBER OF RECORDS IN HASH TABLE */
    NEXTH BYTE,  /* NEXT RECORD TO BE PLACED IN HASH TABLE */
    UCOUNT BYTE, /* NUMBER OF UNHASHED RECORDS IN QUEUE */
    NEXT BYTE,   /* NEXT AVAILABLE SLOT IN QUEUE */
    RECNUM ADDRESS, /* RECORD NUMBER OF OLDEST IN QUEUE */
    BUFA ADDRESS, /* ADDRESS OF BUFFER DESCRIPTOR FOR FILE USING */
                  /* USING THIS QUEUE */
    AFTN ADDRESS, /* AFTN OF FILE USING THIS QUEUE */

    /* THE FOLLOWING IDENTIFIERS REFER TO INDIVIDUAL RECORDS */

    ADDR(255) ADDRESS, /* ADDRESS OF INDIVIDUAL RECORD */
    LEN(255) BYTE, /* LENGTH OF RECCORD */
    CYCLE(255) BYTE, /* HASH ADDRESS OF RECORD */
    HLINK(255) BYTE, /* LINK FOR THE HASH TABLE BUCKETS */

    /* THE FOLLOWING ARRAY IS THE HASH TABLE, STORING UNMATCHED RECORDS */

    HTABLE(256) BYTE
    ),
   BUFA ADDRESS, /* ADDRESS OF BUFFER DESCRIPTOR */
    BUF BASED BUFA STRUCTURE( /* LOCAL COPY OF BUF$DSPTR */
      LOW$ADDR ADDRESS,
      HIGH$ADDR ADDRESS,
      NEXT$DSPTR ADDRESS,
      PTR ADDRESS,
      EOD ADDRESS),
    NEWBUFA ADDRESS, /* ADDRESS OF NEW BUFFER DESCRIPTOR */
    NEWBUF BASED NEWBUFA STRUCTURE( /* ANOTHER LOCAL COPY OF BUF$DSPTR */
      LOW$ADDR ADDRESS,
      HIGH$ADDR ADDRESS,
      NEXT$DSPTR ADDRESS,
      PTR ADDRESS,
      EOD ADDRESS),
    PTR ADDRESS, /* CURSOR POSITION FOR BUFFER SCAN */
    CHAR BASED PTR BYTE, /* CHARACTER IN INPUT BUFFER */
    EOD ADDRESS, /* END OF DATA IN BUFFER, NOT NECESSARILY END OF FILE */
    LEN BYTE, /* LENGTH OF RECORD */
    CYCLE BYTE, /* TO BE USED AS HASH ADDRESS, XOR OF BYTES OF RECORD */
    RCD BYTE; /* RECORD BEING RETURNED */
  IF /* THERE ARE RECORDS WAITING IN STORAGE */ Q.UCOUNT<>0
  THEN RETURN( Q.NEXTH );

  IF /* THERE IS NO ROOM IN THE QUEUE */ Q.HCOUNT = 0FFH
  THEN CALL SPACEFAIL;

  /* SCAN BUFFER */
  RCD = Q.NEXTH;
  BUFA = Q.BUFA;
  PTR = BUF.PTR;
  LEN = 0FFH; /* -1 */
  CYCLE = 0;
  EOD = BUF.EOD;
  DO WHILE PTR = EOD; /* NO MORE DATA IN BUFFER */
    IF EOD <= BUF.HIGH$ADDR /* TRUE END OF FILE */
    THEN RETURN(0FFH);
    /* READ IN SOME DATA */
    Q.BUFA = ( BUFA := BUF.NEXT$DSPTR );
    /* IF BUF NOT EMPTY ABORT */
    IF Q.HCOUNT <> 0
    THEN IF Q.ADDR(Q.OLDEST) >= BUF.LOW$ADDR
            AND Q.ADDR(Q.OLDEST) <= BUF.HIGH$ADDR
         THEN CALL SPACEFAIL;
    PTR = ( BUF.PTR := BUF.LOW$ADDR );
    CALL READ(Q.AFTN,PTR,BUF$LENGTH,.ACTUAL,.STATUS);
    CALL CHECK$STATUS;
    EOD = (BUF.EOD := PTR + ACTUAL);
  END;

  /* INCREMENT NEXT MOD 255 */
  IF Q.NEXT = 0FEH
  THEN Q.NEXT = 0;
  ELSE Q.NEXT = Q.NEXT + 1;
  Q.UCOUNT = 1;

  DO WHILE CHAR <> LF;
    LEN = LEN + 1;
    CYCLE = CYCLE XOR CHAR;
    PTR = PTR + 1;
    DO WHILE PTR = EOD; /* RUN OFF DATA IN BUFFER */
      IF PTR <= BUF.HIGH$ADDR /* END OF FILE */
      THEN DO;
        Q.ADDR(RCD) = BUF.PTR;
        BUF.PTR = PTR;
        PTR = PTR - 1;
        IF CHAR = CR
        THEN DO;
          Q.CYCLE(RCD) = CYCLE;
          Q.LEN(RCD) = LEN;
          END;
        ELSE DO;
          Q.CYCLE(RCD) = CYCLE XOR CR;
          Q.LEN(RCD) = LEN + 1;
          END;
        RETURN(RCD);
      END;
      NEWBUFA = BUF.NEXT$DSPTR;
      /* IF NEWBUF NOT EMPTY THEN ABORT */
      IF Q.HCOUNT <> 0
      THEN IF Q.ADDR(Q.OLDEST) >= NEWBUF.LOW$ADDR
              AND Q.ADDR(Q.OLDEST) <= NEWBUF.HIGH$ADDR
           THEN CALL SPACEFAIL;
      /* MOVE RECORD INTO NEWBUF */
      CALL MOVE(LEN+1,BUF.PTR,NEWBUF.LOW$ADDR);
      Q.BUFA  = ( BUFA := NEWBUFA );
      PTR  = (BUF.PTR := BUF.LOW$ADDR) + LEN + 1;
      CALL READ(Q.AFTN,PTR,BUF$LENGTH-LEN-1,.ACTUAL,.STATUS);
      CALL CHECK$STATUS;
      EOD = (BUF.EOD := PTR + ACTUAL);
    END;
  END;
  Q.ADDR(RCD) = BUF.PTR;
  BUF.PTR = PTR + 1;
  IF LEN = -1 /* ADJUST LENGTH FOR MISSING CARRIAGE RETURN */
  THEN Q.LEN(RCD) = 0;
  ELSE Q.LEN(RCD) = LEN;
  Q.CYCLE(RCD) = CYCLE;
  RETURN(RCD);
END READRECORD;

INITILIZE: PROCEDURE;

/* INITILIZE QUEUES, BUFFERS, AND HASH TABLES */

  DECLARE
    PLACE ADDRESS, /* USED FOR COMPUTING BUFFER ADDRESSES */
    I BYTE; /* LOOP INDEX */

  PLACE = .MEMORY + 2048;
  BUF$LENGTH = (MEMCK - PLACE)/4;

  DO I = 0 TO 3;
    BUF$DSPTR(I).LOW$ADDR = PLACE;
    PLACE = PLACE + BUF$LENGTH;
    BUF$DSPTR(I).PTR, BUF$DSPTR(I).EOD = PLACE;
    BUF$DSPTR(I).HIGH$ADDR = PLACE - 1;
  END;

  DO I = 0 TO 0FFH;
    QUEUE0.HTABLE(I) = 0FFH;
    QUEUE1.HTABLE(I) = 0FFH;
  END;

  QUEUE0.RECNUM, QUEUE1.RECNUM = 1;
  QUEUE0.OLDEST, QUEUE1.OLDEST, QUEUE0.HCOUNT, QUEUE1.HCOUNT, QUEUE0.NEXTH,
  QUEUE1.NEXTH, QUEUE0.UCOUNT, QUEUE1.UCOUNT, QUEUE0.NEXT, QUEUE1.NEXT = 0;

  BUF$DSPTR(0).NEXT$DSPTR, QUEUE0.BUFA = .BUF$DSPTR(1);
  BUF$DSPTR(1).NEXT$DSPTR = .BUF$DSPTR(0);
  BUF$DSPTR(2).NEXT$DSPTR, QUEUE1.BUFA = .BUF$DSPTR(3);
  BUF$DSPTR(3).NEXT$DSPTR = .BUF$DSPTR(2);

END INITILIZE;

PRINT: PROCEDURE(QA,PREFIX,DISP);

/* PRINT OUT THE RECORDS IN THE QUEUE UPTO RCD */
/* DELETE THESE RECORDS AND ALSO WIPE OUT THE HASH TABLE */

  DECLARE
    RCD BYTE, /* RECORD WHICH HAS BEEN MATCHED */
    QA ADDRESS, /* BASE FOR Q BELOW */
    Q BASED QA STRUCTURE( /* LOCAL COPY OF THE QUEUE */
                       /* RECORDS OLDEST -> NEXTH-1 ARE IN HASH TABLE */
                       /* RECORDS NEXTH -> NEXT-1 HAVE BEEN SCANNED BUT */
                       /* ARE NOT IN HASH TABLE.  NOTE THAT THE QUEUE WRAPS */
                       /* AROUND MOD 255.  255 = 0FFH IS THE NULL ADDRESS */
    OLDEST BYTE, /* OLDEST RECORD IN HASH TABLE */
    HCOUNT BYTE, /* NUMBER OF RECORDS IN HASH TABLE */
    NEXTH BYTE,  /* NEXT RECORD TO BE PLACED IN HASH TABLE */
    UCOUNT BYTE, /* NUMBER OF UNHASHED RECORDS IN QUEUE */
    NEXT BYTE,   /* NEXT AVAILABLE SLOT IN QUEUE */
    RECNUM ADDRESS, /* RECORD NUMBER OF OLDEST IN QUEUE */
    BUFA ADDRESS, /* ADDRESS OF BUFFER DESCRIPTOR FOR FILE USING */
                  /* USING THIS QUEUE */
    AFTN ADDRESS, /* AFTN OF FILE USING THIS QUEUE */

    /* THE FOLLOWING IDENTIFIERS REFER TO INDIVIDUAL RECORDS */

    ADDR(255) ADDRESS, /* ADDRESS OF INDIVIDUAL RECORD */
    LEN(255) BYTE, /* LENGTH OF RECCORD */
    CYCLE(255) BYTE, /* HASH ADDRESS OF RECORD */
    HLINK(255) BYTE, /* LINK FOR THE HASH TABLE BUCKETS */

    /* THE FOLLOWING ARRAY IS THE HASH TABLE, STORING UNMATCHED RECORDS */

    HTABLE(256) BYTE
    ),
    COUNT BYTE, /* COUNT OF MISMATCHED RECORDS PRINTED */
    PLACE BYTE, /* INDEX INTO QUEUE */
    DIGITS(6) BYTE, /* STORAGE FOR THE DIGITS OF Q.RECNUM */
    PREFIX ADDRESS, /* BASE FOR '#1:' OR '#2:' */
    FIRSTCH BASED PREFIX BYTE, /* FIRST CHARACTER OF PREFIX */
    DISP BYTE; /* POSITION OF FIRST MISMATCHED CHARACTER IN FIRST RECORD */

  PRINTLINE: PROCEDURE;
    CALL DISPLAY(3,PREFIX);
    CALL CONVND(Q.RECNUM,.DIGITS);
    CALL DISPLAY(6,.DIGITS);
    CALL DISPLAY(Q.LEN(PLACE),Q.ADDR(PLACE));
    CALL NEW$LINE;
    IF COUNT = 0
    THEN DO; /* PRINT OUT UP ARROW MARKING FIRST MISMATCHING CHARACTER */
      CALL BLANKS(DISP + 9);
      CALL DISPLAY(1, .('^'));
      CALL NEWLINE;
    END;
    IF PLACE = 0FEH
    THEN PLACE = 0;
    ELSE PLACE = PLACE + 1;
  END PRINTLINE;

  PLACE = Q.OLDEST;
  RCD = Q.NEXTH;
  COUNT = 0;
  IF RCD <> PLACE /* NO MISMATCHED LINES */
  THEN DO;
    FIRSTCH = '#';
    CALL PRINTLINE; /* PRINT FIRST LINE */
    Q.RECNUM = Q.RECNUM + 1;
    COUNT = 1;
    FIRSTCH = ' ';
    DO WHILE PLACE <> RCD; /* PRINT SUBSEQUENT MISMATCHED LINES */
      CALL PRINTLINE;
      Q.RECNUM = Q.RECNUM + 1;
      COUNT = COUNT + 1;
    END;
  END;
  FIRSTCH = '='; /* PRINT FIRST SYNC LINE */
  CALL PRINTLINE;

  /* DELETE PRINTED RECORDS FROM QUEUE */
  Q.UCOUNT = Q.UCOUNT + Q.HCOUNT - COUNT;
  Q.HCOUNT = 0;
  Q.OLDEST = Q.NEXTH;

  /* ZAP OUT HASH TABLE */
  DO PLACE = 0 TO 0FFH;
    Q.HTABLE(PLACE) = 0FFH;
  END;

END PRINT;

CLEANUP: PROCEDURE;

/* PROCEDURE TO PRINT OUT UNMATCHED RECORDS.  THE UNMATCHED RECORDS */
/* ARE DELETED FROM THE QUEUES IN THE PROCESS */

  DECLARE
    DIGITS(6) BYTE, /* DIGITS OF RECORD NUMBER FOR PRINTING */
    DISP BYTE, /* POSITION OF FIRST MISMATCHED CHARACTER OF :/
               /* OF FIRST LINE */
    LINE0A ADDRESS, /* BASE FOR LINE0 */
    LINE1A ADDRESS, /* BASE FOR LINE1 */
    LINE0 BASED LINE0A(1) BYTE, /* FIRST MISMATCHED LINE IN QUEUE0 */
    LINE1 BASED LINE1A(1) BYTE; /* FIRST MISMATCHED LINE IN QUEUE1 */

  /* FIND FIRST MISMATCHED CHARACTER OF FIRST LINES */
  DISP = 0;
  LINE0A = QUEUE0.ADDR(QUEUE0.OLDEST);
  LINE1A = QUEUE1.ADDR(QUEUE1.OLDEST);
  DO WHILE LINE0(DISP) = LINE1(DISP);
    DISP = DISP + 1;
  END;
  CALL DISPLAY(34,.('########## MISMATCH AT RECORD NO. '));
  CALL CONVND(QUEUE0.RECNUM,.DIGITS);
  CALL DISPLAY(5,.DIGITS);
  CALL DISPLAY(8,.(' FILE1: '));
  CALL DISPLAY(15,.FILE$NAME$0);
  CALL NEWLINE;
  CALL DISPLAY(34,.('##########          AT RECORD NO. '));
  CALL CONVND(QUEUE1.RECNUM,.DIGITS);
  CALL DISPLAY(5,.DIGITS);
  CALL DISPLAY(8,.(' FILE2: '));
  CALL DISPLAY(15,.FILE$NAME$1);
  CALL NEWLINE;
  CALL NEWLINE;
  CALL PRINT(.QUEUE0,.('#1:'),DISP);
  CALL DISPLAY(75,.(CR,LF,
'----------------------------------------------------------------------',
CR,LF,LF));
  CALL PRINT(.QUEUE1,.('#2:'),DISP);
  CALL DISPLAY(75,.(CR,LF,
'======================================================================',
CR,LF,LF));

CALL DUMP;

IDENTICAL = FALSE; /* FOR FINAL MESSAGE */

END CLEANUP;

FINISH: PROCEDURE(QA);

/* PROCEDURE TO FINIISH UP READING A FILE */
/* WHEN ALL OTHER PROCESSING IS DONE */

  DECLARE
    QA ADDRESS, /* BASE FOR QUEUE */
    Q BASED QA STRUCTURE( /* LOCAL COPY OF THE QUEUE */
                       /* RECORDS OLDEST -> NEXTH-1 ARE IN HASH TABLE */
                       /* RECORDS NEXTH -> NEXT-1 HAVE BEEN SCANNED BUT */
                       /* ARE NOT IN HASH TABLE.  NOTE THAT THE QUEUE WRAPS */
                       /* AROUND MOD 255.  255 = 0FFH IS THE NULL ADDRESS */
    OLDEST BYTE, /* OLDEST RECORD IN HASH TABLE */
    HCOUNT BYTE, /* NUMBER OF RECORDS IN HASH TABLE */
    NEXTH BYTE,  /* NEXT RECORD TO BE PLACED IN HASH TABLE */
    UCOUNT BYTE, /* NUMBER OF UNHASHED RECORDS IN QUEUE */
    NEXT BYTE,   /* NEXT AVAILABLE SLOT IN QUEUE */
    RECNUM ADDRESS, /* RECORD NUMBER OF OLDEST IN QUEUE */
    BUFA ADDRESS, /* ADDRESS OF BUFFER DESCRIPTOR FOR FILE USING */
                  /* USING THIS QUEUE */
    AFTN ADDRESS, /* AFTN OF FILE USING THIS QUEUE */

    /* THE FOLLOWING IDENTIFIERS REFER TO INDIVIDUAL RECORDS */

    ADDR(255) ADDRESS, /* ADDRESS OF INDIVIDUAL RECORD */
    LEN(255) BYTE, /* LENGTH OF RECCORD */
    CYCLE(255) BYTE, /* HASH ADDRESS OF RECORD */
    HLINK(255) BYTE, /* LINK FOR THE HASH TABLE BUCKETS */

    /* THE FOLLOWING ARRAY IS THE HASH TABLE, STORING UNMATCHED RECORDS */

    HTABLE(256) BYTE
    ),
    RCD BYTE; /* RECORD TO BE READ IN */

  /* CLEAR READ PORTION OF QUEUE */
  Q.HCOUNT = Q.HCOUNT + Q.UCOUNT;
  Q.UCOUNT = 0;
  Q.NEXTH = Q.NEXT;

  /* READ REST OF FILE */
  RCD = READRECORD(QA);
  DO WHILE RCD <> 0FFH AND Q.HCOUNT <> 0FFH;
    Q.UCOUNT = 0;
    Q.HCOUNT = Q.HCOUNT + 1;
    Q.NEXTH = Q.NEXT;
    RCD = READRECORD(QA);
  END;

  IF Q.HCOUNT = 0FFH THEN CALL SPACEFAIL;

  /* SEE TO IT THAT FINAL MATCH READS '^Z' */
  Q.ADDR(Q.NEXT) = .('^Z');
  Q.LEN(Q.NEXT) = 2;
  Q.NEXTH = Q.NEXT;

END FINISH;

TERMINATE: PROCEDURE;

/* TAKE ALL TERMINAL ACTIONS */
/* COMPLETE READING FILES */
/* SEE THAT ANY UNMATCHED RECORDS ARE PRINTED */
/* PRINT OUT FINAL MESSAGE */

  CALL FINISH(.QUEUE0); /* FINISH READING FILE1 */
  CALL FINISH(.QUEUE1); /* FINISH READING FILE2 */
  IF QUEUE0.HCOUNT <> 0 OR QUEUE1.HCOUNT <> 0
  THEN CALL CLEANUP;

  /* PRINT OUT FINAL MESSAGE */

  IF IDENTICAL
  THEN CALL DISPLAY(20,.(CR,LF,'FILES IDENTICAL',CR,LF,LF));
  ELSE CALL DISPLAY(17,.(CR,LF,'FILES DIFFER',CR,LF,LF));
  CALL DUMP;
  CALL EXIT;

END TERMINATE;

COMPARE: PROCEDURE(RCD0,Q0A,RCD1,Q1A)BYTE;

/* PROCEDURE TO COMPARE TWO RECORD */
/* THE ARGUMENTS ARE RCD0 -> QUEUE0 */
/*                   RCD1 -> QUEUE1 */

  DECLARE
    RCD0 BYTE, /* RECORD NUMBER IN QUEUE0 */
    RCD1 BYTE, /* RECORD NUMBER IN QUEUE1 */
    Q0A ADDRESS, /* POINTER TO Q0 TO BASE STRUCTURE */
    Q0 BASED Q0A STRUCTURE(/* ONE QUEUE FOR EACH INPUT FILE */
                       /* RECORDS OLDEST -> NEXTH-1 ARE IN HASH TABLE */
                       /* RECORDS NEXTH -> NEXT-1 HAVE BEEN SCANNED BUT */
                       /* ARE NOT IN HASH TABLE.  NOTE THAT THE QUEUE WRAPS */
                       /* AROUND MOD 255.  255 = 0FFH IS THE NULL ADDRESS */
    OLDEST BYTE, /* OLDEST RECORD IN HASH TABLE */
    HCOUNT BYTE, /* NUMBER OF RECORDS IN HASH TABLE */
    NEXTH BYTE,  /* NEXT RECORD TO BE PLACED IN HASH TABLE */
    UCOUNT BYTE, /* NUMBER OF UNHASHED RECORDS IN QUEUE */
    NEXT BYTE,   /* NEXT AVAILABLE SLOT IN QUEUE */
    RECNUM ADDRESS, /* RECORD NUMBER OF OLDEST IN QUEUE */
    BUFA ADDRESS, /* ADDRESS OF BUFFER DESCRIPTOR FOR FILE USING */
                  /* USING THIS QUEUE */
    AFTN ADDRESS, /* AFTN OF FILE USING THIS QUEUE */

    /* THE FOLLOWING IDENTIFIERS REFER TO INDIVIDUAL RECORDS */

    ADDR(255) ADDRESS, /* ADDRESS OF INDIVIDUAL RECORD */
    LEN(255) BYTE, /* LENGTH OF RECCORD */
    CYCLE(255) BYTE, /* HASH ADDRESS OF RECORD */
    HLINK(255) BYTE, /* LINK FOR THE HASH TABLE BUCKETS */

    /* THE FOLLOWING ARRAY IS THE HASH TABLE, STORING UNMATCHED RECORDS */

    HTABLE(256) BYTE
    ),
    Q1A ADDRESS, /* POINTER TO Q1 TO BASE STRUCTURE */
    Q1 BASED Q1A STRUCTURE( /* ONE QUEUE FOR EACH INPUT FILE */
                       /* RECORDS OLDEST -> NEXTH-1 ARE IN HASH TABLE */
                       /* RECORDS NEXTH -> NEXT-1 HAVE BEEN SCANNED BUT */
                       /* ARE NOT IN HASH TABLE.  NOTE THAT THE QUEUE WRAPS */
                       /* AROUND MOD 255.  255 = 0FFH IS THE NULL ADDRESS */
    OLDEST BYTE, /* OLDEST RECORD IN HASH TABLE */
    HCOUNT BYTE, /* NUMBER OF RECORDS IN HASH TABLE */
    NEXTH BYTE,  /* NEXT RECORD TO BE PLACED IN HASH TABLE */
    UCOUNT BYTE, /* NUMBER OF UNHASHED RECORDS IN QUEUE */
    NEXT BYTE,   /* NEXT AVAILABLE SLOT IN QUEUE */
    RECNUM ADDRESS, /* RECORD NUMBER OF OLDEST IN QUEUE */
    BUFA ADDRESS, /* ADDRESS OF BUFFER DESCRIPTOR FOR FILE USING */
                  /* USING THIS QUEUE */
    AFTN ADDRESS, /* AFTN OF FILE USING THIS QUEUE */

    /* THE FOLLOWING IDENTIFIERS REFER TO INDIVIDUAL RECORDS */

    ADDR(255) ADDRESS, /* ADDRESS OF INDIVIDUAL RECORD */
    LEN(255) BYTE, /* LENGTH OF RECCORD */
    CYCLE(255) BYTE, /* HASH ADDRESS OF RECORD */
    HLINK(255) BYTE, /* LINK FOR THE HASH TABLE BUCKETS */

    /* THE FOLLOWING ARRAY IS THE HASH TABLE, STORING UNMATCHED RECORDS */

    HTABLE(256) BYTE
    ),
    PTR0 ADDRESS, /* TO SCAN RECORD0 */
    PTR1 ADDRESS, /* TO SCAN RECORD1 */
    CHAR0 BASED PTR0 BYTE, /* IN RECORD0 */
    CHAR1 BASED PTR1 BYTE, /* IN RECORD1 */
    LEN BYTE, /* RECORD LENGTH */
    I BYTE; /* LOOP INDEX */

  PTR0 = Q0.ADDR(RCD0);
  PTR1 = Q1.ADDR(RCD1);

  IF Q0.CYCLE(RCD0) <> Q1.CYCLE(RCD1)
  THEN RETURN(FALSE);

  IF (LEN := Q0.LEN(RCD0) ) <> Q1.LEN(RCD1)
  THEN RETURN(FALSE);

  DO I = 1 TO LEN;
    IF CHAR0 <> CHAR1 THEN RETURN(FALSE);
    PTR0 = PTR0 + 1;
    PTR1 = PTR1 + 1;
  END;

  RETURN(TRUE);

END COMPARE;

MATCH: PROCEDURE(RCD,Q0A,Q1A) BYTE;

/* PROCEDURE TO DETERMINE IF SYNCPARM RECORDS IN Q0, LAST ONE RCD */
/* MATCH A GROUP OF RECORDS IN Q1. */
/* REFERENCE TO THE HASH TABLE IS MADE.  IF NO MATCH IS FOUND */
/* FALSE IS RETURNED. OTHERWIZE TRUE IS RETURNED */
/* Q0.NEXTH AND Q1.NEXTH ARE ADJUSTED TO POINT TO THE FIRST RECORDS */
/* OF THE MATCHED BLOCK FOR THE CONVENIENCE OF PRINT */

  DECLARE
    Q0A ADDRESS, /* BASE FOR Q0 */
    Q0 BASED Q0A STRUCTURE( /* FIRST LOCAL COPY OF QUEUE */
                       /* RECORDS OLDEST -> NEXTH-1 ARE IN HASH TABLE */
                       /* RECORDS NEXTH -> NEXT-1 HAVE BEEN SCANNED BUT */
                       /* ARE NOT IN HASH TABLE.  NOTE THAT THE QUEUE WRAPS */
                       /* AROUND MOD 255.  255 = 0FFH IS THE NULL ADDRESS */
    OLDEST BYTE, /* OLDEST RECORD IN HASH TABLE */
    HCOUNT BYTE, /* NUMBER OF RECORDS IN HASH TABLE */
    NEXTH BYTE,  /* NEXT RECORD TO BE PLACED IN HASH TABLE */
    UCOUNT BYTE, /* NUMBER OF UNHASHED RECORDS IN QUEUE */
    NEXT BYTE,   /* NEXT AVAILABLE SLOT IN QUEUE */

   RECNUM ADDRESS, /* RECORD NUMBER OF OLDEST IN QUEUE */
    BUFA ADDRESS, /* ADDRESS OF BUFFER DESCRIPTOR FOR FILE USING */
                  /* USING THIS QUEUE */
    AFTN ADDRESS, /* AFTN OF FILE USING THIS QUEUE */

    /* THE FOLLOWING IDENTIFIERS REFER TO INDIVIDUAL RECORDS */

    ADDR(255) ADDRESS, /* ADDRESS OF INDIVIDUAL RECORD */
    LEN(255) BYTE, /* LENGTH OF RECCORD */
    CYCLE(255) BYTE, /* HASH ADDRESS OF RECORD */
    HLINK(255) BYTE, /* LINK FOR THE HASH TABLE BUCKETS */

    /* THE FOLLOWING ARRAY IS THE HASH TABLE, STORING UNMATCHED RECORDS */

    HTABLE(256) BYTE
    ),
    Q1A ADDRESS, /* BASE FOR Q1 */
    Q1 BASED Q1A STRUCTURE( /* SECOND LOCAL COPY OF QUEUE */
                       /* RECORDS OLDEST -> NEXTH-1 ARE IN HASH TABLE */
                       /* RECORDS NEXTH -> NEXT-1 HAVE BEEN SCANNED BUT */
                       /* ARE NOT IN HASH TABLE.  NOTE THAT THE QUEUE WRAPS */
                       /* AROUND MOD 255.  255 = 0FFH IS THE NULL ADDRESS */
    OLDEST BYTE, /* OLDEST RECORD IN HASH TABLE */
    HCOUNT BYTE, /* NUMBER OF RECORDS IN HASH TABLE */
    NEXTH BYTE,  /* NEXT RECORD TO BE PLACED IN HASH TABLE */
    UCOUNT BYTE, /* NUMBER OF UNHASHED RECORDS IN QUEUE */
    NEXT BYTE,   /* NEXT AVAILABLE SLOT IN QUEUE */
    RECNUM ADDRESS, /* RECORD NUMBER OF OLDEST IN QUEUE */
    BUFA ADDRESS, /* ADDRESS OF BUFFER DESCRIPTOR FOR FILE USING */
                  /* USING THIS QUEUE */
    AFTN ADDRESS, /* AFTN OF FILE USING THIS QUEUE */

    /* THE FOLLOWING IDENTIFIERS REFER TO INDIVIDUAL RECORDS */

    ADDR(255) ADDRESS, /* ADDRESS OF INDIVIDUAL RECORD */
    LEN(255) BYTE, /* LENGTH OF RECCORD */
    CYCLE(255) BYTE, /* HASH ADDRESS OF RECORD */
    HLINK(255) BYTE, /* LINK FOR THE HASH TABLE BUCKETS */

    /* THE FOLLOWING ARRAY IS THE HASH TABLE, STORING UNMATCHED RECORDS */

    HTABLE(256) BYTE
    ),
    RCD BYTE, /* RECORD TO BE MATCHED */
    TEST BYTE, /* RECORD TO BE COMPARED AGAINST RCD */
    ANSWER BYTE, /* THE ANSWER IN BOOLEAN */
    ANSWER0 BYTE, /* FIRST MATCHED RECORD IN Q0 */
    ANSWER1 BYTE, /* FIRST MATCHED RECORD IN Q1 */
    SIZE BYTE, /* SIZE OF Q1 BELOW TEST */
    RCD0 BYTE, /* TEMPORARIES RCD0 AND RCD1 */
    RCD1 BYTE,
    COUNT BYTE; /* LOOP INDEX */

  /* NO MATCH YET */
  ANSWER = FALSE;

  /* IF Q0 DOESN'T HAVE SYNCPARM ENTRIES THEN GIVE UP */
  IF Q0.HCOUNT + 1 < SYNCPARM
  THEN RETURN(FALSE);

  /* SEARCH HASH TABLE */
  TEST = Q1.HTABLE(Q0.CYCLE(RCD));
  DO WHILE TEST <> 0FFH;
    /* COMPUTE SIZE OF QUEUE1 BELOW TEST BY WIERD MODULO ARITHMETIC */
    IF TEST >= Q1.OLDEST
    THEN SIZE = TEST - Q1.OLDEST + 1;
    ELSE SIZE = TEST - Q1.OLDEST;

    IF SIZE < SYNCPARM /* NO ROOM TO SYNC.  NOTE THAT THERE ISN'T ANY */
                       /* ROOM EITHER FOR ANY OTHER RECORD DOWN */
                       /* THE BUCKET */
    THEN GOTO DONE;

    /* COMPARE SYNCPARM RECORDS */
    IF NOT COMPARE(RCD,Q0A,TEST,Q1A)
    THEN GOTO DECEND;
    RCD0 = RCD;
    RCD1 = TEST;
    DO COUNT = 2 TO SYNCPARM;
      /* DECREMENT RCD0 AND RCD1 MODULO 0FEH */
      IF RCD0 = 0
      THEN RCD0 = 0FEH;
      ELSE RCD0 = RCD0 - 1;
      IF RCD1 = 0
      THEN RCD1 = 0FEH;
      ELSE RCD1 = RCD1 - 1;

      IF NOT COMPARE(RCD0,Q0A,RCD1,Q1A)
      THEN GOTO DECEND;
    END;
    /* WE HAVE A MATCH BUT THERE STILL CAN BE A LOWER MATCH */
    ANSWER = TRUE;
    ANSWER0 = RCD0;
    ANSWER1 = RCD1;
    DECEND:
    TEST = Q1.HLINK(TEST); /* DECEND THROUGH BUCKET */
  END;

  DONE:
  IF ANSWER /* THEN ADJUST NEXTH'S FOR PRINT */
  THEN DO;
    Q0.NEXTH = ANSWER0;
    Q1.NEXTH = ANSWER1;
  END;
  RETURN(ANSWER);

END MATCH;

DELETE1: PROCEDURE(QA);
  DECLARE QA ADDRESS, /* POINTER TO QUEUE */
    Q BASED QA STRUCTURE ( /* LOCAL COPY OF QUEUE */
      OLDEST BYTE,
      HCOUNT BYTE,
      NEXTH BYTE,
      UCOUNT BYTE,
      NEXT BYTE,
      RECNUM ADDRESS,
      BUFA ADDRESS,
      AFTN ADDRESS,
      ADDR(255) ADDRESS,
      LEN(255) BYTE,
      CYCLE(255) BYTE,
      HLINK(255) BYTE,
      HTABLE(255) BYTE);

  Q.RECNUM = Q.RECNUM + 1;
  Q.UCOUNT = Q.UCOUNT - 1;
  IF Q.OLDEST = 0FEH
  THEN Q.OLDEST = 0;
  ELSE Q.OLDEST = Q.OLDEST + 1;
  Q.NEXTH = Q.OLDEST;

END DELETE1;

/* MAIN START */

CALL COMMAND; /* READ IN COMMAND LINE AND OPEN FILES */
CALL INITILIZE; /* INITILIZE BUFFERS, QUEUES, HASH TABLES */

IDENTICAL = TRUE;    /* FILES IDENTICAL SO FAR */

/* MAIN LOOP */
DO WHILE TRUE;
  RCD0 = READRECORD(.QUEUE0);
  IF RCD0 = 0FFH /* EOF */
  THEN CALL TERMINATE;
  RCD1 = READRECORD(.QUEUE1);
  IF RCD1 = 0FFH /* EOF */
  THEN CALL TERMINATE;
  IF COMPARE(RCD0,.QUEUE0,RCD1,.QUEUE1)
  THEN DO;
    CALL DELETE1(.QUEUE0);
    CALL DELETE1(.QUEUE1);
    END;
  ELSE DO; /* TRY TO RESYNC */
    CALL HASH$INSERT(.QUEUE0); /* INSERT RCD0 AND RCD1 IN THEIR */
    CALL HASH$INSERT(.QUEUE1); /* RESPECTIVE HASH TABLES */
    NOMATCH = TRUE; /* FLAG TO SIGNAL WHEN MATCH TAKES PLACE */
    DO WHILE NOMATCH;
      RCD0 = READRECORD(.QUEUE0);
      IF RCD0 <> 0FFH /* EOF */
      THEN IF MATCH(RCD0,.QUEUE0,.QUEUE1)
           THEN DO;
             CALL CLEANUP;
             NOMATCH = FALSE;
             END;
           ELSE CALL HASH$INSERT(.QUEUE0);
      IF NOMATCH
      THEN DO;
        RCD1 = READRECORD(.QUEUE1);
        IF RCD1 = 0FFH /* EOF */
        THEN IF RCD0 = 0FFH /* EOF FOR BOTH FILES */
             THEN CALL TERMINATE;
             ELSE;
        ELSE IF MATCH(RCD1,.QUEUE1,.QUEUE0)
             THEN DO;
               CALL CLEANUP;
               NOMATCH = FALSE;
               END;
             ELSE CALL HASH$INSERT(.QUEUE1);
      END;
    END;
  END;
END;
END COMPAR;
src/consol.plm
CONSOLE:
DO;

/************************************************************************/
/*																		*/
/*      '(C) Intel Corporation 1981'.  All rights reserved.  No			*/
/*      part of this program or publication may be reproduced,			*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

DECLARE COPYRIGHT (*) BYTE DATA ('(C) INTEL CORP 1981');

DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V2.0',0);
    
DECLARE VERSION$LEVEL LITERALLY '02H',
        EDIT$LEVEL LITERALLY '00H';

DECLARE VERSION (*) BYTE DATA (VERSION$LEVEL,EDIT$LEVEL);

$NOLIST
DECLARE TRUE LITERALLY '0FFH';
DECLARE FALSE LITERALLY '00H';
DECLARE BOOLEAN LITERALLY 'BYTE';
DECLARE FOREVER LITERALLY 'WHILE 1';

DECLARE
  NULL          LITERALLY '00H',
  CONTROL$C     LITERALLY '03H',
  CONTROL$E     LITERALLY '05H',
  BELL          LITERALLY '07H',
  TAB           LITERALLY '09H',
  LF            LITERALLY '0AH',
  VT            LITERALLY '0BH',
  FF            LITERALLY '0CH',
  CR            LITERALLY '0DH',
  CONTROL$P     LITERALLY '10H',
  CONTROL$Q     LITERALLY '11H',
  CONTROL$R     LITERALLY '12H',
  CONTROL$S     LITERALLY '13H',
  CONTROL$X     LITERALLY '18H',
  CONTROL$Z     LITERALLY '1AH',
  ESC           LITERALLY '1BH',
  QUOTE         LITERALLY '22H',
  LCA           LITERALLY '61H',
  LCZ           LITERALLY '7AH',
  ALT$MODE      LITERALLY '7DH',
  RUBOUT        LITERALLY '7FH';

    DECLARE WARNING         LITERALLY  '0',
            MESSAGE         LITERALLY  '1',
            ABORT           LITERALLY  '2';

    DECLARE OK              LITERALLY  '0'
    ,       NO$FREE$BUFFER  LITERALLY  '1'
    ,       BAD$AFT$NO      LITERALLY  '2'
    ,       AFT$FULL        LITERALLY  '3'
    ,       BAD$PATH        LITERALLY  '4'
    ,       BAD$DEVICE      LITERALLY  '5'
    ,       CANT$WRITE      LITERALLY  '6'
    ,       DISK$FULL       LITERALLY  '7'
    ,       CANT$READ       LITERALLY  '8'
    ,       DIRECTORY$FULL  LITERALLY  '9'
    ,       DIFFERENT$DISK  LITERALLY  '10'
    ,       MULTIDEFINED    LITERALLY  '11'
    ,       ALREADY$OPEN    LITERALLY  '12'
    ,       NO$SUCH$FILE    LITERALLY  '13'
    ,       WRITE$PROTECT   LITERALLY  '14'
    ,       ISIS$OVERWRITE  LITERALLY  '15'
    ,       BAD$LOAD$FORMAT LITERALLY  '16'
    ,       NON$DISK$FILE   LITERALLY  '17'
    ,       BAD$COMMAND     LITERALLY  '18'
    ,       NON$DISK$SEEK   LITERALLY  '19'
    ,       LONG$BACK$SEEK  LITERALLY  '20'
    ,       CANT$RESCAN     LITERALLY  '21'
    ,       ILLEGAL$ACCESS  LITERALLY  '22'
    ,       NULL$FILENAME   LITERALLY  '23'
    ,       DISK$IO$ERROR   LITERALLY  '24'
    ,       BAD$ECHO        LITERALLY  '25'
    ,       BAD$ATTRIB      LITERALLY  '26'
    ,       BAD$SEEK$ARG    LITERALLY  '27'
    ,       NULL$EXTENSION  LITERALLY  '28'
    ,       CONSOLE$EOF     LITERALLY  '29'
    ,       DRIVE$NOT$READY LITERALLY  '30'
    ,       SEEK$ON$WRITE   LITERALLY  '31'
    ,       CANT$DELETE     LITERALLY  '32'
    ,       ILLEGAL$PARAM   LITERALLY  '33'
    ,       BAD$RETSW       LITERALLY  '34'
    ,       SEEK$PAST$EOF   LITERALLY  '35'
    ,       UNRECOG$SWITCH  LITERALLY '201'
    ,       UNRECOG$DELIM   LITERALLY '202'
    ,       INVALID$SYNTAX  LITERALLY '203'
    ,       EARLY$EOF       LITERALLY '204'
    ,       BAD$LABEL       LITERALLY '206'
    ,       NO$END$STAT     LITERALLY '207'
    ,       CHECKSUM$ERROR  LITERALLY '208'
    ,       RELO$SEQ$ERR    LITERALLY '209'
    ,       INSUFF$MEMORY   LITERALLY '210'
    ,       REC$TOO$LONG    LITERALLY '211'
    ,       BAD$REC$TYP     LITERALLY '212'
    ,       FIXUP$BOUNDS    LITERALLY '213'
    ,       BAD$PARAM       LITERALLY '214'
    ,       ARG$TOO$LONG    LITERALLY '215'
    ,       TOO$MANY$PARAMS LITERALLY '216'
    ,       REC$TOO$SHORT   LITERALLY '217'
    ,       ILL$REC$FMT     LITERALLY '218'
    ,       PHASE$ERROR     LITERALLY '219'
    ,       NO$EOF          LITERALLY '220'
    ,       SEG$OVERFLOW    LITERALLY '221'
    ,       UNRECOG$REC     LITERALLY '222'
    ,       FIXUP$ERROR     LITERALLY '223'
    ,       ILL$REC$SEQ     LITERALLY '224'
    ,       BAD$MOD$NAME    LITERALLY '225'
    ,       LONG$MOD$NAME   LITERALLY '226'
    ,       NO$L$PAREN      LITERALLY '227'
    ,       NO$R$PAREN      LITERALLY '228'
    ,       UNRECOG$CONTROL LITERALLY '229'
    ,       DUP$SYMBOL      LITERALLY '230'
    ,       FILE$EXISTS     LITERALLY '231'
    ,       UNRECOG$COM     LITERALLY '232'
    ,       NO$TO           LITERALLY '233'
    ,       DUP$FILE$NAME   LITERALLY '234'
    ,       NOT$LIB$FILE    LITERALLY '235'
    ,       TOO$MANY$CMNS   LITERALLY '236'
    ,       MISSING$COMMON  LITERALLY '237'
    ,       STACK$CONTENT   LITERALLY '238'
    ,       NO$MODHDR       LITERALLY '239'
    ,       OUT$OF$RANGE    LITERALLY '240'
    ,       INV$OBJ$FILE    LITERALLY '241'
    ;

READ:
  PROCEDURE (AFT,BUFFER,COUNT,ACTUAL,STATUS) EXTERNAL;
    DECLARE (AFT,BUFFER,COUNT,ACTUAL,STATUS) ADDRESS;

  END READ;

FILE$ERROR:
	PROCEDURE (A,B,C) EXTERNAL;
    DECLARE (A,C) ADDRESS;
    DECLARE B BYTE;
    END
FILE$ERROR;

DEBLANK:
  PROCEDURE (PTR) ADDRESS EXTERNAL;
    DECLARE PTR ADDRESS;

  END DEBLANK;

DELIMIT:
  PROCEDURE (PTR) ADDRESS EXTERNAL;
    DECLARE PTR ADDRESS;

  END DELIMIT;

CONSOL:
	PROCEDURE (A,B,C) EXTERNAL;
	DECLARE (A,B,C) ADDRESS;
	END
CONSOL;

FORCE$UPPER:
	PROCEDURE (ADDR) EXTERNAL;
	DECLARE ADDR ADDRESS;
	END
FORCE$UPPER;
EXIT:
  PROCEDURE EXTERNAL;

  END EXIT;
$LIST

DECLARE BUFFER(128) BYTE;
DECLARE (BUFFER$PTR,INPUT$PTR,OUTPUT$PTR) ADDRESS;
DECLARE CHAR BASED BUFFER$PTR BYTE;
DECLARE (ACTUAL,STATUS) ADDRESS;

CALL READ(1,.BUFFER,LENGTH(BUFFER),.ACTUAL,.STATUS);
BUFFER(ACTUAL) = CR;
CALL FORCE$UPPER(.BUFFER);
BUFFER$PTR = DEBLANK(.BUFFER);
INPUT$PTR = .(':CI: ');
OUTPUT$PTR = .(':CO: ');
IF CHAR <> ',' THEN
DO;
  INPUT$PTR = BUFFER$PTR;
  BUFFER$PTR = DEBLANK(DELIMIT(BUFFER$PTR));
END;
IF CHAR <> CR THEN
DO;
  IF CHAR <> ',' THEN CALL FILE$ERROR(INVALID$SYNTAX,BUFFER$PTR,TRUE);
  BUFFER$PTR,OUTPUT$PTR = DEBLANK(BUFFER$PTR+1);
  BUFFER$PTR = DEBLANK(DELIMIT(BUFFER$PTR));
  IF CHAR <> CR THEN CALL FILE$ERROR(INVALID$SYNTAX,BUFFER$PTR,TRUE);
END;
CALL CONSOL(INPUT$PTR,OUTPUT$PTR,.STATUS);
CALL FILE$ERROR(STATUS,.BUFFER,TRUE);
CALL EXIT;
END;

EOF
src/copy.plm
copy$a$file:  DO;


/************************************************************************/
/*																		*/
/*      '(C) Intel Corporation 1981'.  All rights reserved.  No			*/
/*      part of this program or publication may be reproduced,			*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

      
/* this procedure is used to copy a file to :f1: */
open:
	procedure(aftn,buffer,access,mode,status) external;
	Declare(aftn,buffer,access,mode,status) address;
end;

read:
	procedure(aftn,buffer,toread,actual,status) external;
	Declare(aftn,buffer,toread,actual,status) address;
End;

write:
	procedure(aftn,buffer,towrite,status) external;
	Declare (aftn,buffer,towrite,status) address;
end;

close:
	procedure(aftn,status) external;
	Declare (aftn,status) address;
end;

file$error:
	Procedure(status,file$ptr,callexit) external;
	Declare (status,file$ptr) address;
	Declare callexit byte;
End;

copy:
	Procedure(str1$ptr,len1,str2$ptr,len2) public;

	Declare (str1$ptr,len1,str2$ptr,len2) address;
	Declare buffer(25600) byte;
	Declare filename(15) byte;
	Declare (inaftn,outaftn,status,actual) address;

	filename(14)=' ';
	Call move(4,str1$ptr,.filename);
	Call move(10,str2$ptr,.filename(4));
	Call open(.inaftn,.filename,1,0,.status);
	Call file$error(status,.filename(4),0);
	If status <> 0 then return;
	Call move(4,.(':f1:'),.filename);
	Call open(.outaftn,.file$name,2,0,.status);
	Call file$error(status,.file$name(4),0);
	If status <> 0 then return;

	Call read(inaftn,.buffer,12800,.actual,.status);
	Do while actual <> 0;

		Call write(outaftn,.buffer,actual,.status);
		call read(inaftn,.buffer,12800,.actual,.status);
	End;

	Call close(inaftn,.status);
	Call close(outaftn,.status);

	return;
End copy;

End copy$a$file;
src/csort.asm
$TITLE('==>  C S O R T 2  <==  CHKLOD')
$DEBUG
$MACROFILE NOGEN

;      '(C) Intel Corporation 1981'.  All rights reserved.  No
;      part of this program or publication may be reproduced,
;      transmitted, transcribed, stored in a retrievel system, or
;      translated into any language or computer language, in any
;      form or by any means, electronic, mechanical, magnetic,
;      optical, chemical, manual or otherwise, without the prior
;      written permission of Intel Corporation, 3065 Bowers
;      Avenue, Santa Clara, California, 95051, Attn: Software
;      License Administration.

; SORT: PROCEDURE (PTR,COUNT,PROC$ADDR) EXTERNAL;
;   DECLARE (PTR,COUNT,PROC$ADDR) ADDRESS;
; END;
;
; SORT ACCEPTS AN ARRAY OF POINTERS AND SORTS THE POINTERS.
;   "COUNT" IS THE NUMBER OF POINTERS.
;   "PTR" IS THE LOCATION OF THE POINTERS
;   "PROC$ADDR" IS THE ADDRESS OF THE FOLLOWING PROCEDURE:
;
; GREATER$THAN: PROCEDURE (PTR1,PTR2);
;   DECLARE (PTR1,PTR2) ADDRESS;
;   ...
; END;
;
; "GREATER$THAN" ACCEPTS AS INPUT TWO POINTERS INTO THE ARRAY
;   OF POINTERS.  IT RETURNS TRUE IFF THE RECORD ASSOCIATED
;   WITH PTR1 IS GREATER THAN THE RECORD ASSOCIATED WITH PTR2.
;
; SORT SORTS THE POINTERS SO THAT THE ASSOCIATED RECORDS ARE IN
;   INCREASING ORDER.
$EJECT
        NAME SORT
        CSEG
        PUBLIC SORT

        MIDPOINT MACRO  ;; LOCATE POINTER IN THE MIDDLE OF THE ARRAY
        MOV A,L
        ADD E
        MOV C,A
        MOV A,H
        ADC D           ;; AC NOW EQUALS (HL+DE) -- NOW DIVIDE BY 2
        RAR
        MOV B,A
        MOV A,C
        RAR             ;; BA NOW EQUALS (HL+DE)/2 -- NOW INSURE THAT IT
                        ;;   HAS THE SAME PARITY AS ALL THE OTHER POINTERS
        XRA L
        ANI 0FEH
        XRA L
        MOV C,A         ;; BC IS THE ANSWER.
        ENDM

        CENTER MACRO    ;;SET HA TO (HL+BC)/2
        DAD B
        MOV A,H
        RAR
        MOV H,A
        MOV A,L
        RAR
        ENDM

        JFALSE MACRO PARAM    ;; JUMP IF BCGTDE WAS FALSE I.E. IF BC <= DE
        JNC PARAM
        ENDM

        SKIP1 MACRO        ;; SKIP NEXT 1 INSTRUCTION BYTE  -- WIPES OUT A
        DB (MVI A,0)
        ENDM

        SKIP2 MACRO        ;; SKIP NEXT 2 INSTRUCTION BYTES  -- WIPES OUT HL
        DB (LXI H,0)
        ENDM

        IFCROSS MACRO ADR  ;; JUMP TO ADR IF BC AND DE HAVE CROSSED.
        MOV A,E
        SUB C
        MOV A,D
        SBB B
        JC ADR
        ENDM
$EJECT
SORT:                 ; BC=COUNT   DE=PROC$ADDR   HL=???   S1=RET   S2=PTR
        XCHG
        SHLD PADDR    ; BC=COUNT   DE=???   HL=PROC$ADDR
        POP H
        XTHL          ; BC=COUNT   DE=???   HL=PTR
        MOV D,H
        MOV E,L       ; BC=COUNT   DE=START$PTR   HL=START$PTR
        DAD B
        DAD B
        DCX H
        DCX H
        XCHG          ; BC=COUNT   DE=END$PTR   HL=START$PTR

HDSORT:                ; INTERIOR SORT ROUTINE WHICH IS CALLED RECURSIVELY.
                      ; SORTS POINTERS AT HL THRU DE.     A,B,C IGNORED.

        MOV A,E
        SUB L
        MOV C,A
        MOV A,D
        SBB H
        RC            ; RETURN IF END$PTR < START$PTR
        ORA C
        RZ            ;   ...OR IF END$PTR = START$PTR
$EJECT
; THE TOPMOST POINTER IS GOING TO BE SWITCHED INTO ITS FINAL POSITION ON
; THE NEXT PAGE.  ON THIS PAGE, WE INCREASE THE PROBABILITY THAT THAT
; FINAL POSITION IS NEAR THE MIDDLE.  THIS SPEEDS THINGS UP.  WE DO SO
; BY LOOKING AT THE BOTTOM, MID, AND TOP POINTERS, AND SWITCHING THE
; SECOND HIGHEST OF THE THREE TO THE TOP POSITION.

                      ; POINTER ARRAY LOOKS LIKE THIS:
                      ; HL . . .    . . . DE
        PUSH H        ; S1 . . .    . . . DE
        MIDPOINT      ; S1 . . . BC . . . DE
        CALL BCGTDE
        CC SWITCH     ; GUARANTEES MID < TOP
        POP H         ; HL . . . BC . . . DE
        PUSH B        ; HL . . . S1 . . . DE
        MOV B,H
        MOV C,L       ; BC . . . S1 . . . DE
        CALL BCGTDE   ; BOTTOM > TOP?
        POP H         ; BC . . . HL . . . DE
        JC ALLSET     ; IF SO THEN TOP IS ALREADY GOOD
        XCHG          ; BC . . . DE . . . HL
        PUSH H        ; BC . . . DE . . . S1
        CALL BCGTDE
        CNC SWITCH    ; GUARANTEES TOP > BOTTOM > MID
        POP D         ; BC . . .    . . . DE
        CALL SWITCH   ; NOW BOTTOM > TOP > MID   SO TOP IS GOOD.
ALLSET:
        PUSH B
        PUSH D        ; S2=BC . . . . . . S1=DE
$EJECT
; IN THIS STAGE, SWITCHES OF POINTERS ARE MADE UNTIL THERE IS A
; SINGLE POINTER IN ITS FINAL POSITION, WITH ALL LESSER POINTERS
; TO THE LEFT AND ALL GREATER POINTERS TO THE RIGHT.

CMPF:
        CALL BCGTDE
        JFALSE CRUZF
        CALL SWITCH
CRUZB:
        DCX D
        DCX D
        IFCROSS RCURS2
CMPB:
        CALL BCGTDE
        JFALSE CRUZB
        CALL SWITCH
CRUZF:
        INX B
        INX B
        IFCROSS RCURS1

        JMP CMPF
$EJECT
; NOW WE CAN SPLIT THE SORT INTO TWO HALF SORTS AND DO THE HALF SORTS
; BY RECURSION.
; AN ADJUSTMENT OF BC OR DE MUST FIRST BE MADE, DEPENDING ON THE ENTRY POINT.

RCURS1:                  ; S2 . . . . . DE BC . . . . . S1
                         ;             GOOD
        DCX D
        DCX D
        SKIP2
RCURS2:                  ; S2 . . . . . DE BC . . . . . S1
                         ;                GOOD
        INX B
        INX B

; NOW COMPUTE WHICH HALF IS SMALLER AND DO IT FIRST.

RCURS:                   ; S2 . . . . . DE GOOD BC . . . . . S1
        MOV H,B
        MOV L,C
        POP B            ; S1 . . . . . DE      HL . . . . . BC
        XTHL             ; HL . . . . . DE      S1 . . . . . BC
        PUSH H           ; S1 . . . . . DE      S2 . . . . . BC
        CENTER
        SUB E
        MOV A,H
        SBB D
        POP H            ; HL . . . . . DE      S1 . . . . . BC
        JNC LEFT
RIGHT:
        XTHL             ; S1 . . . . . . DE   HL . . . BC
        PUSH D           ; S2 . . . . . . S1   HL . . . BC
        MOV D,B
        MOV E,C          ; S2 . . . . . . S1   HL . . . DE
        SKIP1
LEFT:
        PUSH B           ; HL . . . DE   S2 . . . . . . S1

        CALL HDSORT       ; SORT THE FIRST HALF
        POP D
        POP H            ; POP OFF THE POINTERS TO THE OTHER HALF
        JMP HDSORT        ; SORT THE OTHER HALF
$EJECT

SWITCH:           ; SWITCH WORD POINTED AT BY BC WITH WORD POINTED AT BY DE
                  ; SAVE B,C,D,E

        MOV H,B
        MOV L,C
        LDAX D
        MOV C,M
        MOV M,A
        XCHG
        MOV M,C
        INX H
        INX D
        LDAX D
        MOV C,M
        MOV M,A
        XCHG
        MOV M,C
        DCX D
        DCX H
        MOV C,L
        RET

        DSEG
BCGTDE:                  ; CALL EXTERNALLY-PASSED "BC GREATER THAN DE"
                         ; ROUTINE SO AS TO PRESERVE B,C,D,E AND RETURN
                         ; THE ANSWER IN THE CARRY FLAG (CARRY=TRUE)

        PUSH B
        PUSH D
        DB (CALL 0)
PADDR:
        DW 0
        RAR
        POP D
        POP B
        RET

        STKLN 100

$EJECT
        END
src/csort2.asm
$TITLE('==>  C S O R T 2  <==  CHKLOD')
$DEBUG
$MACROFILE NOGEN

;      '(C) Intel Corporation 1981'.  All rights reserved.  No
;      part of this program or publication may be reproduced,
;      transmitted, transcribed, stored in a retrievel system, or
;      translated into any language or computer language, in any
;      form or by any means, electronic, mechanical, magnetic,
;      optical, chemical, manual or otherwise, without the prior
;      written permission of Intel Corporation, 3065 Bowers
;      Avenue, Santa Clara, California, 95051, Attn: Software
;      License Administration.

; SORT: PROCEDURE (PTR,COUNT,PROC$ADDR) EXTERNAL;
;   DECLARE (PTR,COUNT,PROC$ADDR) ADDRESS;
; END;
;
; SORT ACCEPTS AN ARRAY OF POINTERS AND SORTS THE POINTERS.
;   "COUNT" IS THE NUMBER OF POINTERS.
;   "PTR" IS THE LOCATION OF THE POINTERS
;   "PROC$ADDR" IS THE ADDRESS OF THE FOLLOWING PROCEDURE:
;
; GREATER$THAN: PROCEDURE (PTR1,PTR2);
;   DECLARE (PTR1,PTR2) ADDRESS;
;   ...
; END;
;
; "GREATER$THAN" ACCEPTS AS INPUT TWO POINTERS INTO THE ARRAY
;   OF POINTERS.  IT RETURNS TRUE IFF THE RECORD ASSOCIATED
;   WITH PTR1 IS GREATER THAN THE RECORD ASSOCIATED WITH PTR2.
;
; SORT SORTS THE POINTERS SO THAT THE ASSOCIATED RECORDS ARE IN
;   INCREASING ORDER.
$EJECT
        NAME SORT
        CSEG
        PUBLIC SORT

        MIDPOINT MACRO  ;; LOCATE POINTER IN THE MIDDLE OF THE ARRAY
        MOV A,L
        ADD E
        MOV C,A
        MOV A,H
        ADC D           ;; AC NOW EQUALS (HL+DE) -- NOW DIVIDE BY 2
        RAR
        MOV B,A
        MOV A,C
        RAR             ;; BA NOW EQUALS (HL+DE)/2 -- NOW INSURE THAT IT
                        ;;   HAS THE SAME PARITY AS ALL THE OTHER POINTERS
        XRA L
        ANI 0FEH
        XRA L
        MOV C,A         ;; BC IS THE ANSWER.
        ENDM

        CENTER MACRO    ;;SET HA TO (HL+BC)/2
        DAD B
        MOV A,H
        RAR
        MOV H,A
        MOV A,L
        RAR
        ENDM

        JFALSE MACRO PARAM    ;; JUMP IF BCGTDE WAS FALSE I.E. IF BC <= DE
        JNC PARAM
        ENDM

        SKIP1 MACRO        ;; SKIP NEXT 1 INSTRUCTION BYTE  -- WIPES OUT A
        DB (MVI A,0)
        ENDM

        SKIP2 MACRO        ;; SKIP NEXT 2 INSTRUCTION BYTES  -- WIPES OUT HL
        DB (LXI H,0)
        ENDM

        IFCROSS MACRO ADR  ;; JUMP TO ADR IF BC AND DE HAVE CROSSED.
        MOV A,E
        SUB C
        MOV A,D
        SBB B
        JC ADR
        ENDM
$EJECT
SORT:                 ; BC=COUNT   DE=PROC$ADDR   HL=???   S1=RET   S2=PTR
        XCHG
        SHLD PADDR    ; BC=COUNT   DE=???   HL=PROC$ADDR
        POP H
        XTHL          ; BC=COUNT   DE=???   HL=PTR
        MOV D,H
        MOV E,L       ; BC=COUNT   DE=START$PTR   HL=START$PTR
        DAD B
        DAD B
        DCX H
        DCX H
        XCHG          ; BC=COUNT   DE=END$PTR   HL=START$PTR

HDSORT:                ; INTERIOR SORT ROUTINE WHICH IS CALLED RECURSIVELY.
                      ; SORTS POINTERS AT HL THRU DE.     A,B,C IGNORED.

        MOV A,E
        SUB L
        MOV C,A
        MOV A,D
        SBB H
        RC            ; RETURN IF END$PTR < START$PTR
        ORA C
        RZ            ;   ...OR IF END$PTR = START$PTR
$EJECT
; THE TOPMOST POINTER IS GOING TO BE SWITCHED INTO ITS FINAL POSITION ON
; THE NEXT PAGE.  ON THIS PAGE, WE INCREASE THE PROBABILITY THAT THAT
; FINAL POSITION IS NEAR THE MIDDLE.  THIS SPEEDS THINGS UP.  WE DO SO
; BY LOOKING AT THE BOTTOM, MID, AND TOP POINTERS, AND SWITCHING THE
; SECOND HIGHEST OF THE THREE TO THE TOP POSITION.

                      ; POINTER ARRAY LOOKS LIKE THIS:
                      ; HL . . .    . . . DE
        PUSH H        ; S1 . . .    . . . DE
        MIDPOINT      ; S1 . . . BC . . . DE
        CALL BCGTDE
        CC SWITCH     ; GUARANTEES MID < TOP
        POP H         ; HL . . . BC . . . DE
        PUSH B        ; HL . . . S1 . . . DE
        MOV B,H
        MOV C,L       ; BC . . . S1 . . . DE
        CALL BCGTDE   ; BOTTOM > TOP?
        POP H         ; BC . . . HL . . . DE
        JC ALLSET     ; IF SO THEN TOP IS ALREADY GOOD
        XCHG          ; BC . . . DE . . . HL
        PUSH H        ; BC . . . DE . . . S1
        CALL BCGTDE
        CNC SWITCH    ; GUARANTEES TOP > BOTTOM > MID
        POP D         ; BC . . .    . . . DE
        CALL SWITCH   ; NOW BOTTOM > TOP > MID   SO TOP IS GOOD.
ALLSET:
        PUSH B
        PUSH D        ; S2=BC . . . . . . S1=DE
$EJECT
; IN THIS STAGE, SWITCHES OF POINTERS ARE MADE UNTIL THERE IS A
; SINGLE POINTER IN ITS FINAL POSITION, WITH ALL LESSER POINTERS
; TO THE LEFT AND ALL GREATER POINTERS TO THE RIGHT.

CMPF:
        CALL BCGTDE
        JFALSE CRUZF
        CALL SWITCH
CRUZB:
        DCX D
        DCX D
        IFCROSS RCURS2
CMPB:
        CALL BCGTDE
        JFALSE CRUZB
        CALL SWITCH
CRUZF:
        INX B
        INX B
        IFCROSS RCURS1

        JMP CMPF
$EJECT
; NOW WE CAN SPLIT THE SORT INTO TWO HALF SORTS AND DO THE HALF SORTS
; BY RECURSION.
; AN ADJUSTMENT OF BC OR DE MUST FIRST BE MADE, DEPENDING ON THE ENTRY POINT.

RCURS1:                  ; S2 . . . . . DE BC . . . . . S1
                         ;             GOOD
        DCX D
        DCX D
        SKIP2
RCURS2:                  ; S2 . . . . . DE BC . . . . . S1
                         ;                GOOD
        INX B
        INX B

; NOW COMPUTE WHICH HALF IS SMALLER AND DO IT FIRST.

RCURS:                   ; S2 . . . . . DE GOOD BC . . . . . S1
        MOV H,B
        MOV L,C
        POP B            ; S1 . . . . . DE      HL . . . . . BC
        XTHL             ; HL . . . . . DE      S1 . . . . . BC
        PUSH H           ; S1 . . . . . DE      S2 . . . . . BC
        CENTER
        SUB E
        MOV A,H
        SBB D
        POP H            ; HL . . . . . DE      S1 . . . . . BC
        JNC LEFT
RIGHT:
        XTHL             ; S1 . . . . . . DE   HL . . . BC
        PUSH D           ; S2 . . . . . . S1   HL . . . BC
        MOV D,B
        MOV E,C          ; S2 . . . . . . S1   HL . . . DE
        SKIP1
LEFT:
        PUSH B           ; HL . . . DE   S2 . . . . . . S1

        CALL HDSORT       ; SORT THE FIRST HALF
        POP D
        POP H            ; POP OFF THE POINTERS TO THE OTHER HALF
        JMP HDSORT        ; SORT THE OTHER HALF
$EJECT

SWITCH:           ; SWITCH WORD POINTED AT BY BC WITH WORD POINTED AT BY DE
                  ; SAVE B,C,D,E

        MOV H,B
        MOV L,C
        LDAX D
        MOV C,M
        MOV M,A
        XCHG
        MOV M,C
        INX H
        INX D
        LDAX D
        MOV C,M
        MOV M,A
        XCHG
        MOV M,C
        DCX D
        DCX H
        MOV C,L
        RET

        DSEG
BCGTDE:                  ; CALL EXTERNALLY-PASSED "BC GREATER THAN DE"
                         ; ROUTINE SO AS TO PRESERVE B,C,D,E AND RETURN
                         ; THE ANSWER IN THE CARRY FLAG (CARRY=TRUE)

        PUSH B
        PUSH D
        DB (CALL 0)
PADDR:
        DW 0
        RAR
        POP D
        POP B
        RET

        STKLN 100

$EJECT
        END
src/dcopy.plm
DCOPY: 
DO;

/************************************************************************/
/*																		*/
/*      '(C) Intel Corporation 1981'.  All rights reserved.  No			*/
/*      part of this program or publication may be reproduced,			*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

DECLARE COPYRIGHT (*) BYTE DATA ('(C) INTEL CORP 1981');

DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V2.1',0);
    
/* LAST CHANGED 21-NOV-1978 */

DECLARE VERSION$LEVEL LITERALLY '02H',
           EDIT$LEVEL LITERALLY '19H';

DECLARE TRUE LITERALLY '0FFH';
DECLARE FALSE LITERALLY '00H';
DECLARE BOOLEAN LITERALLY 'BYTE';
DECLARE FOREVER LITERALLY 'WHILE 1';

/* SPECIAL ASCII CHARACTERS */

DECLARE
  NULL          LITERALLY '00H',
  CONTROL$C     LITERALLY '03H',
  CONTROL$E     LITERALLY '05H',
  BELL          LITERALLY '07H',
  TAB           LITERALLY '09H',
  LF            LITERALLY '0AH',
  VT            LITERALLY '0BH',
  FF            LITERALLY '0CH',
  CR            LITERALLY '0DH',
  CONTROL$P     LITERALLY '10H',
  CONTROL$Q     LITERALLY '11H',
  CONTROL$R     LITERALLY '12H',
  CONTROL$S     LITERALLY '13H',
  CONTROL$X     LITERALLY '18H',
  CONTROL$Z     LITERALLY '1AH',
  ESC           LITERALLY '1BH',
  QUOTE         LITERALLY '22H',
  LCA           LITERALLY '61H',
  LCZ           LITERALLY '7AH',
  ALT$MODE      LITERALLY '7DH',
  RUBOUT        LITERALLY '7FH';

    /* PREDECLARED DISK SECTORS. */

    /* PREDECLARED DISK SECTORS. */

    DECLARE
      T0$HDR$BLK     LITERALLY '0018H',
      T0$DATA$BLK0   LITERALLY '0001H',
      T0$DATA$BLKS   LITERALLY '23',
      LAB$HDR$BLK    LITERALLY '0019H',
      LAB$DATA$BLK0  LITERALLY '001AH',
      LAB$DATA$BLKS  LITERALLY '1',
      DIR$HDR$BLK    LITERALLY '0101H',
      DIR$DATA$BLK0  LITERALLY '0102H',
      DIR$DATA$BLKS  LITERALLY '25',
      MAP$HDR$BLK    LITERALLY '0201H',
      MAP$DATA$BLK0  LITERALLY '0202H',
      MAP$DATA$BLKS  LITERALLY '2',
      ISIS$HDR$BLK   LITERALLY '0204H';

    DECLARE
      FLINK LITERALLY '1',
      BLINK LITERALLY '0';

DECLARE MAX$RETRIES LITERALLY '10'; /* MAX FDCC ERROR RETRIES */

/* DISK CONTROLLER CONSTANTS. */

/* OUTPUT PORTS */

DECLARE LOW$ADDRESS$0   LITERALLY '79H',
        LOW$ADDRESS$1   LITERALLY '89H',
        HIGH$ADDRESS$0  LITERALLY '7AH',
        HIGH$ADDRESS$1  LITERALLY '8AH',
        STOP$DISK$0     LITERALLY '7BH',
        STOP$DISK$1     LITERALLY '8BH',
        CHANNEL$RESET$0 LITERALLY '7FH',
        CHANNEL$RESET$1 LITERALLY '8FH',

/* INPUT PORTS */

        FDCC$STATUS$0   LITERALLY '78H',
        FDCC$STATUS$1   LITERALLY '88H',
        RESULT$TYPE$0   LITERALLY '79H',
        RESULT$TYPE$1   LITERALLY '89H',
        RESULT$BYTE$0   LITERALLY '7BH',
        RESULT$BYTE$1   LITERALLY '8BH',

/* STATUS BITS */

        DISK$DONE       LITERALLY '4';

DECLARE SEEK$COMMAND    LITERALLY '1',
        FORMAT$COMMAND  LITERALLY '2',
        RECALIBRATE     LITERALLY '3',
        READ$COMMAND    LITERALLY '4',
        VERIFY$COMMAND  LITERALLY '5',
        WRITE$COMMAND   LITERALLY '6',
        WRITE$DEL       LITERALLY '7';

DECLARE IOCW            LITERALLY '0', /* CHANNEL WORD */
        IOINS           LITERALLY '1', /* I/O INSTRUCTIONS */
        NSEC            LITERALLY '2', /* NUMBER OF SECTORS */
        TADR            LITERALLY '3', /* TRACK ADDRESS, 0 TO 76 */
        SADR            LITERALLY '4', /* SECTOR ADDRESS, 1 TO 26 */
        BUFL            LITERALLY '5', /* LOW(BUFFER) */
        BUFU            LITERALLY '6', /* HIGH(BUFFER) */
        BNUM            LITERALLY '7', /* BLOCK NUMBER */
        NXTL            LITERALLY '9', /* LOW(NEXT$DCB) */
        NXTU            LITERALLY '8'; /* HIGH(NEXT$DCB) */

DECLARE /* DEVICE ACCESS MODES. */
  READ$MODE       LITERALLY '1',
  WRITE$MODE      LITERALLY '2',
  UPDATE$MODE     LITERALLY '3';

DECLARE VERSION(*) BYTE DATA (VERSION$LEVEL,EDIT$LEVEL);

DECLARE DCB(12) BYTE INITIAL (80H);
DECLARE DIGITS(16) BYTE INITIAL('0123456789ABCDEF');

MEMCK:
  PROCEDURE ADDRESS EXTERNAL;

  END MEMCK;

NUMOUT:
  PROCEDURE(VALUE,BASE,LC,BUFADR,WIDTH) EXTERNAL;
    DECLARE (VALUE,BUFADR) ADDRESS;
    DECLARE (BASE,LC,WIDTH) BYTE;

  END NUMOUT;

DEBLANK:
  PROCEDURE (PTR) ADDRESS EXTERNAL;
    DECLARE PTR ADDRESS;

  END DEBLANK;

FORCE$UPPER:
  PROCEDURE (BUFFER$PTR) EXTERNAL;
    DECLARE BUFFER$PTR ADDRESS;

  END FORCE$UPPER;

SCAN$INTEGER:
  PROCEDURE(PP) ADDRESS EXTERNAL;
    DECLARE PP ADDRESS;

  END SCAN$INTEGER;

OPEN:
  PROCEDURE (AFT,FILE,ACCESS,MODE,STATUS) EXTERNAL;
    DECLARE (AFT,FILE,ACCESS,MODE,STATUS) ADDRESS;

  END OPEN;

CLOSE:
  PROCEDURE (AFT,STATUS) EXTERNAL;
    DECLARE (AFT,STATUS) ADDRESS;

  END CLOSE;

READ:
  PROCEDURE (AFT,BUFFER,COUNT,ACTUAL,STATUS) EXTERNAL;
    DECLARE (AFT,BUFFER,COUNT,ACTUAL,STATUS) ADDRESS;

  END READ;

WRITE:
  PROCEDURE (AFT,BUFFER,COUNT,STATUS) EXTERNAL;
    DECLARE (AFT,BUFFER,COUNT,STATUS) ADDRESS;

  END WRITE;

ERROR:
  PROCEDURE (ERRNUM) EXTERNAL;
    DECLARE ERRNUM ADDRESS;

  END ERROR;

EXIT:
  PROCEDURE EXTERNAL;

  END EXIT;

DISKIO:
  PROCEDURE(DISK,IOPB) EXTERNAL;
    DECLARE (DISK,IOPB) ADDRESS;

  END DISKIO;

SPATH:
   PROCEDURE(FILE,BUFFER,STATUS) EXTERNAL;
     DECLARE (FILE,BUFFER,STATUS) ADDRESS;
   END SPATH;

ABSIO:
  PROCEDURE (COMMAND,DISK,BLOCK,BUFFER$PTR) EXTERNAL;
    DECLARE (COMMAND,DISK) BYTE;
    DECLARE (BLOCK,BUFFER$PTR) ADDRESS;

  END ABSIO;

DUMP:
  PROCEDURE;
    DECLARE (I,J,K) BYTE;
    DECLARE DIGITS(*) BYTE DATA ('0123456789ABCDEF');

    /* DISPLAY THE FIRST 128 BYTES OF "MEMORY" IN HEX AND ASCII */

    CO: PROCEDURE(C); DECLARE C BYTE;
      DECLARE STAT ADDRESS;
      CALL WRITE(0,.C,1,.STAT);
    END CO;
    DO I=0 TO 7;
      CALL CO(DIGITS(I));
      CALL CO(' ');
      DO J=I*16 TO (I*16)+15;
        CALL CO(' ');
        CALL CO(DIGITS(SHR(MEMORY(J),4)));
        CALL CO(DIGITS((MEMORY(J) AND 0FH)));
      END;
      CALL CO(' ');
      DO J=I*16 TO (I*16)+15;
        IF (K:=MEMORY(J)) >= ' ' AND K <= 7AH /* 'Z' */
        THEN CALL CO(K); ELSE CALL CO(' ');
      END;
      CALL CO(CR); /* CR */
      CALL CO(LF); /* LF */
    END;
  END DUMP;

JREAD:
  PROCEDURE(PTRPTR);
    DECLARE PTRPTR ADDRESS;
    DECLARE DISK BYTE;
    DECLARE (TRACK,SECTOR) ADDRESS;
     DECLARE READBUF (128) BYTE;

    TRACK = SCAN$INTEGER(.PTRPTR);
    SECTOR= SCAN$INTEGER(.PTRPTR);
    DISK = SCAN$INTEGER(.PTRPTR);
    CALL ABSIO(READ$COMMAND,DISK,TRACK*256+SECTOR,.READBUF);
  END JREAD;

DASH:
  PROCEDURE(LOTRAK);
  DECLARE (LOTRAK,TRACK) BYTE;
  CALL WRITE(0,.(CR,LF),2,.STAT);
  IF LOTRAK <> 0 THEN
  DO TRACK = 0 TO LOTRAK-1;
    IF (TRACK MOD 10) = 0 THEN CALL WRITE(0,.(' '),1,.STAT);
    CALL WRITE(0,.('-'),1,.STAT);
  END;
END DASH;

/* GENERATE PHYSICAL SECTOR TABLE FOR INTERLEAVE FACTOR */

GENSEC:
  PROCEDURE(INTLEAVE,NRSEC);
    DECLARE INTLEAVE BYTE;
    DECLARE NRSEC BYTE;
    DECLARE I BYTE;
    DECLARE INDEX BYTE;

    DO I = 0 TO NRSEC-1;
      SECTAB(I) = 0;
    END;
    INDEX = 0;
    DO I= 1 TO NRSEC;
      IF INDEX >= NRSEC THEN
      DO;
        INDEX = INDEX - NRSEC;
        DO WHILE SECTAB(INDEX) <> 0;
          INDEX = INDEX + 1;
        END;
      END;
      SECTAB(INDEX) = I;
      INDEX = INDEX + INTLEAVE;
    END;
  END GENSEC;

/*	FMTTRK.PEX */

FORMAT$TRACK:
	PROCEDURE (A,B,C,D) EXTERNAL;
    DECLARE (A,B,C,D) BYTE;
    END
FORMAT$TRACK;

/*	END  */
/*	FMTTRK.PEX */

DECLARE DISK$TYPE BYTE PUBLIC;
DECLARE BUF$IN(12) BYTE;
DECLARE STAT$IN ADDRESS;
DECLARE (TRACK,WLOTRAK,NTRAK,LOTRAK,HITRAK,SECTOR,NOUT) BYTE;
DECLARE (BUF0,BUF1,WBUF0,WBUF1) ADDRESS,
        CHAR0 BASED WBUF0 (1) BYTE, CHAR1 BASED WBUF1 (1) BYTE;
DECLARE (I,J) ADDRESS;
DECLARE MISCOMPARE BYTE;
DECLARE BUFPTR ADDRESS, CHAR BASED BUFPTR BYTE;
DECLARE TPTR ADDRESS;
DECLARE (ACTUAL,STAT) ADDRESS; /* FOR READ CALL */
DECLARE (COPY,VERIFY,FORMATSW,INTLEV$FLG) BOOLEAN;
DECLARE INTERLEAVE(77) BYTE;
DECLARE SOURCE LITERALLY '0', SINK LITERALLY '1';
DECLARE MSG(*) BYTE DATA(CR,LF,'LOAD DISKETTES AND TYPE ''CR''');
DECLARE UNIT BYTE; /* OUTPUT DEVICE */
DECLARE INPUT BYTE; /* INPUT DEVICE NUMBER, MASTER DISK LOCATION */
DECLARE OUTPUT(4) BYTE; /* OUTPUT DEVICE NUMBERS, 4 MAXIMUM FOR COPY DISK */
DECLARE OUTBUF(1) BYTE; /* BYTE TO HOLD ASCII CHAR FOR PRINTING
                             SOURCE DRIVE ON TERMINAL */
DECLARE TOBUF(5) BYTE; /* STRING CONTAINS DESTINATION DEVICES */
DECLARE TO$LENGTH BYTE;
DECLARE (VAR,DRV,L) BYTE ;
DECLARE SECTAB(52) BYTE;
DECLARE INDEX BYTE;
DECLARE INDEX$INCR BYTE;
DECLARE INDEX$RESET BYTE;
DECLARE MONITOR ADDRESS DATA (0); /* ENTRY POINT TO MONITOR */

/*
   ATTRIBUTE TABLE
  THE ATTRIBUTE TABLE IS USED AS TABLE LOOK UP FOR THE FORMAT, COPY
  AND VERIFY ATTRIBUTES
                 8      4     2       1
      2  1  0    FORMAT COPY  VERIFY  ERROR    TABLE ENTRY
  0                      X                      04H
  1         VO                   X              02H
  2      V               X       X              06H
  3      V  VO                          X       01H
  4   I             X    X                      0CH
  5   I     VO                          X       01H
  6   I  V          X    X       X              0EH
  7   I  V  VO                          X       01H

*/

DECLARE ATR(8) BYTE INITIAL(4,2,6,1,12,1,14,1);
DECLARE PATHNAME (15) BYTE INITIAL (':F0:ISIS.LAB   ');
DECLARE (MASK,TMASK) BYTE;

GOTO START; /* JUMP AROUND ERROR ROUTINE */
ERR:
  CALL WRITE(0,.('SYNTAX ERROR, REENTER COMMAND'),29,.STAT);
  CALL WRITE(0,.(CR,LF),2,.STAT);
  CALL WRITE(0,.('**'),2,.STAT);

START:

INPUT = 0; /* :F0: IS MASTER DRIVE , FOR DEFAULT*/
OUTPUT(0) = 1; /* :F1: IS COPY DRIVE, FOR DEFAULT*/
LOTRAK,HITRAK = 0FFH; /* SET FOR DEFAULT FLAG */
INTLEV$FLG = FALSE;
NOUT,MASK=0;

BUF0 = .MEMORY;
BUFPTR = BUF0;
CALL READ(1,BUF0,128,.ACTUAL,.STAT); /* CLEAR CONSOLE INPUT */
CALL FORCE$UPPER(BUF0);

/*
   COMMAND TAIL SCAN LOOP
*/

DO WHILE CHAR <> CR AND CHAR <>  LF;
  TPTR,BUFPTR = DEBLANK(BUFPTR);
  IF CHAR = ',' THEN GO TO ERR;
  IF CHAR = 'F' THEN
    DO;
      BUFPTR = DEBLANK(BUFPTR+1);
      IF CHAR = '=' THEN
      DO;
        BUFPTR = DEBLANK(BUFPTR+1);
        INPUT = SCAN$INTEGER(.BUFPTR);
      END;
    END;
  IF CHAR = 'T' THEN
  DO;
    BUFPTR = DEBLANK(BUFPTR+1);
    IF CHAR = '=' THEN
    DO;
      BUFPTR = BUFPTR+1;
      OUTPUT(NOUT) = SCAN$INTEGER(.BUFPTR);
      DO WHILE CHAR = ','; /* LOOK FOR OUTPUT DEVICE PARAMETERS */
        BUFPTR = DEBLANK(BUFPTR+1);
        NOUT = NOUT+1;
        IF NOUT = 4 THEN GOTO ERR;
        OUTPUT(NOUT) = SCAN$INTEGER(.BUFPTR);
      END;
    END;
  END;
  IF CHAR = '&' THEN
  DO;
    CALL WRITE(0,.('**'),2,.STAT);
    CALL READ(1,BUF0,128,.ACTUAL,.STAT);
    CALL FORCE$UPPER(BUF0);
    BUFPTR = BUF0;
  END;
  IF CHAR = 'V' THEN
  DO;
    TMASK = 2;
    BUFPTR = BUFPTR + 1;
    IF CHAR = 'O' THEN
    DO;
      TMASK = 1;
      BUFPTR = BUFPTR+1;
    END;
    MASK = MASK OR TMASK;
  END;
  IF CHAR = 'I' THEN
  DO;
    MASK = MASK OR 4;
    BUFPTR = DEBLANK(BUFPTR+1);
    IF CHAR = '=' THEN
    DO;
      INTLEV$FLG = TRUE; /* INTERLEAVE  PARAMETERS USER INPUT */
      BUFPTR = BUFPTR + 1;
      INTERLEAVE(0) = SCAN$INTEGER(.BUFPTR);
      I = 1;
      DO WHILE CHAR = ','; /* CHECK FOR INTERLEAVE PARAMETERS */
        BUFPTR = DEBLANK(BUFPTR+1);
        IF CHAR = '&' THEN
        DO;
          CALL WRITE(0,.('**'),2,.STAT);
          CALL READ(1,BUF0,128,.ACTUAL,.STAT);
          CALL FORCE$UPPER(BUF0);
          BUFPTR = BUF0;
        END;
        INTERLEAVE(I) = SCANINTEGER(.BUFPTR);
        I = I+1;
      END;

      J = I-1; /* INDEX OF LAST INTERLEAVE */
      DO I = I TO 76;
        INTERLEAVE(I) = INTERLEAVE(J);
      END;
    END;
  END;
  IF CHAR >= '0' AND CHAR <= '9' THEN
  DO;
    LOTRAK = SCAN$INTEGER(.BUFPTR);
    HITRAK = SCAN$INTEGER(.BUFPTR);
    IF HITRAK = 0 THEN HITRAK = LOTRAK; /* ONLY LOTRAK INPUT BY USER */
    IF LOTRAK < 0 OR HITRAK > 76 THEN GOTO ERR; /* ILLEGAL PARAMETER */
    IF HITRAK < LOTRAK THEN GOTO ERR;
  END;
IF TPTR=BUFPTR THEN BUFPTR = BUFPTR + 1;
END; /* END WHILE */

MASK = ATR(MASK); /* PROCESS ATTRIBUTES */
FORMAT$SW,COPY,VERIFY = TRUE; /* DEFAULT ATTRIBUTES */
IF (MASK AND 8) = 0 THEN FORMAT$SW = FALSE;
IF (MASK AND 4) = 0 THEN COPY = FALSE;
IF (MASK AND 2) = 0 THEN VERIFY = FALSE;
IF (MASK AND 1) = 1 THEN GOTO ERR;

IF LOTRAK = 0FFH THEN
DO;
  LOTRAK = 0;
  HITRAK = 76;
END;

CALL WRITE(0,.('DCOPY V2.1'),10,.STAT);
CALL WRITE(0,.(CR,LF),2,.STAT);

PATHNAME(2) = INPUT + '0'; /* SET DEVICE NAME */
CALL SPATH(.PATHNAME,.BUF$IN,.STAT$IN); /* DETERMINE DRIVE TYPE
                                         BUF$IN(11) CONTAINS 1H FOR
                                         DOUBLE OR 2H FOR SINGLE DENSITY */

VAR = 52; /* DOUBLE DENSITY */
DISK$TYPE = TRUE; /* DISK TYPE = DOUBLE DENSITY */
INDEX$INCR = 2;
IF BUF$IN(11) = 02H THEN
DO;
  VAR = 26; /* SINGLE DENSITY */
  DISK$TYPE = FALSE;
  INDEX$INCR = 2;
END;
NTRAK = 1; /* # OF TRACKS ABLE TO READ INTO MEM */
BUF1 = .MEMORY + (128*VAR*NTRAK);
OUTBUF(0) = INPUT + '0'; /* CONVERT SOURCE DRIVE # TO ASCII */
I = 0;
DO L = 0 TO NOUT; /* BUILD STRING CONTAINING DESTINATION DEVICE NUMBERS */
  TOBUF(I) = OUTPUT(L) + '0';
  TOBUF(I+1) = ',';
  I = I+2;
  TO$LENGTH = I-1; /* LENGTH OF DESTINATION DEVICE STRING */
END;

/*
  LOOP SO THAT 'DCOPY' DOES NOT NEED TO BE LOADED AFTER EACH
  DISK CREATION OR VERIFICATION
*/
LOOP:
IF FORMATSW THEN CALL WRITE(0,.('FORMAT '),7,.STAT);
IF COPY THEN CALL WRITE(0,.('COPY '),5,.STAT);
IF VERIFY THEN CALL WRITE(0,.('VERIFY'),6,.STAT);
CALL WRITE(0,.('  FROM = '),9,.STAT);
CALL WRITE(0,.OUTBUF,1,.STAT); /* WRITE INPUT DEVICE (FROM PARAMETER) */
CALL WRITE(0,.('  TO = '),7,.STAT);
CALL WRITE(0,.TOBUF,TO$LENGTH,.STAT); /* WRITE DESTINATION STRING */
CALL WRITE(0,.MSG,LENGTH(MSG),.STAT); /* LOAD DISKS, TYPE CR */
CALL READ(1,BUF0,122,.ACTUAL,.STAT); /* WAIT FOR HUMAN RESPONSE */
CALL FORCE$UPPER(BUF0);
BUFPTR = BUF0;
IF CHAR = 'E' THEN CALL EXIT; /* RETURN TO ISIS */
IF CHAR = 'E' THEN CALL MONITOR; /* ABOVE CALL EXECUTED BUT DRIVE 0
                                    IS NOT SYSTEM DISK, CALL MONITOR INSTEAD */
IF INTLEV$FLG = FALSE THEN
DO;
  CALL OPEN(.J,.PATHNAME,1,0,.I);
  IF I <>0 THEN DO; CALL ERROR(I); CALL EXIT; END;
  CALL READ(J,BUF1,128-77,.ACTUAL,.I);
  CALL READ(J,.INTERLEAVE,77,.ACTUAL,.I);
  CALL CLOSE(J,.I);
  DO I = 0 TO 76;
    INTERLEAVE(I) = INTERLEAVE(I) - '0';
  END;
END;
WLOTRAK = LOTRAK;

CALL DASH(LOTRAK);

/* COPY AND VERIFY LOOP */

DO TRACK = LOTRAK TO HITRAK ;
  IF (TRACK MOD 10) = 0 THEN CALL WRITE(0,.(' '),1,.STAT);
  CALL WRITE(0,.DIGITS(TRACK MOD 10),1,.STAT);
  IF TRACK = 39 THEN CALL WRITE(0,.(CR,LF),2,.STAT);

  /* ALWAYS READ IN 1 TRACK OF SOURCE */

  WBUF0 = BUF0;
  DCB(NSEC) = 1; /* READ 1 SEC AT A TIME */
  DCB(BNUM) = 0;
  DCB(IOINS) = READ$COMMAND;
  CALL GENSEC(INTERLEAVE(TRACK),VAR);
  DCB(TADR) = TRACK;
  INDEX = 0;
  INDEX$RESET = 1;
  DO I = 1 TO VAR;
    DCB(SADR) = SECTAB(INDEX);
    DCB(BUFL) = LOW(WBUF0);
    DCB(BUFU) = HIGH(WBUF0);
    CALL DISKIO(INPUT,.DCB); /* READ COMMAND */
    INDEX = INDEX + INDEX$INCR;
    IF INDEX >= VAR THEN
    DO;
      INDEX = INDEX$RESET;
      INDEX$RESET = INDEX$RESET + 1;
    END;
    WBUF0 = WBUF0 + 128;
  END;

  DO UNIT = 0 TO NOUT;
    /* TEST FOR SIMILIAR MEDIA TYPE */
    IF INPUT > 3 AND OUTPUT(UNIT) < 4 THEN GOTO ERR;
    IF INPUT < 4 AND OUTPUT(UNIT) > 3 THEN GOTO ERR;

    /* COPY TO OUTPUT(UNIT) IF COPY TRUE */
    IF COPY THEN
    DO;
      WBUF0 = BUF0;
      DCB(IOINS)= WRITE$COMMAND;
      DCB(TADR) = TRACK;
      INDEX = 0;
      INDEX$RESET = 1;
      IF FORMAT$SW THEN
      CALL FORMAT$TRACK(OUTPUT(UNIT),TRACK,TRACK,INTERLEAVE(TRACK));
      DO I = 1 TO VAR; /* WRITE A TRACK */
        DCB(SADR) = SECTAB(INDEX);
        DCB(BUFL) = LOW(WBUF0);
        DCB(BUFU) = HIGH(WBUF0);
        CALL DISKIO(OUTPUT(UNIT),.DCB);
        INDEX = INDEX + INDEX$INCR;
        IF INDEX >= VAR THEN
        DO;
          INDEX = INDEX$RESET;
          INDEX$RESET = INDEX$RESET + 1;
        END;
        WBUF0 = WBUF0 + 128;
      END;
    END;

    /* REREAD, IF VERIFY TRUE, FROM COPY DISK INTO WBUF1, VERIFY
       AGAINST WBUF0 */

    IF VERIFY THEN
    DO;
      WBUF1 = BUF1;
      DCB(TADR) = TRACK;
      DCB(IOINS) = READ$COMMAND;
      INDEX = 0;
      INDEX$RESET = 1;
      DO I = 1 TO VAR;
        DCB(SADR) = SECTAB(INDEX);
        DCB(BUFL) = LOW(WBUF1);
        DCB(BUFU) = HIGH(WBUF1);
        CALL DISKIO(OUTPUT(UNIT),.DCB); /* READ COMMAND */
        INDEX = INDEX + INDEX$INCR;
        IF INDEX >= VAR THEN
        DO;
          INDEX = INDEX$RESET;
          INDEX$RESET = INDEX$RESET + 1;
        END;
        WBUF1 = WBUF1 + 128;
      END;

      /* COMPARE MASTER TO REREAD OF WRITTEN DATA */

      MISCOMPARE = FALSE;
      WBUF0 = BUF0;
      WBUF1 = BUF1;
      DO SECTOR = 0 TO (VAR-1);
        J = 128*SECTOR + 127;
        DO I = J-127 TO J;
          IF CHAR0(I) <> CHAR1(I) THEN
          DO;
            MISCOMPARE = TRUE;
            I = J + 1; /* GO TO NEXT SECTOR */
            CALL WRITE(0,.(CR,LF),2,.STAT);
            CALL WRITE(0,.('DRIVE '),6,.STAT);
            DRV = OUTPUT(UNIT) + '0';
            CALL WRITE(0,.DRV,1,.STAT);
            CALL NUMOUT(TRACK,10,0,BUF1,4);
            CALL WRITE(0,.(' TRACK '),7,.STAT);
            CALL WRITE(0,BUF1,4,.STAT);
            CALL WRITE(0,.('  '),2,.STAT);
            CALL NUMOUT(SECTOR+1,16,'0',BUF1,4);
            CALL WRITE(0,BUF1,4,.STAT);
            CALL WRITE(0,.('H SECTOR MISCOMPARES'),20,.STAT);
          END;
        END;
      END;

      CHAR1(0) = 0;
      IF MISCOMPARE THEN
      DO WHILE CHAR1(0) <> 'C';
        CALL WRITE(0,.(CR,LF,'*'),3,.STAT);
        CALL READ(1,.CHAR1(0),128,.ACTUAL,.STAT);
        CALL FORCE$UPPER(.CHAR1(0));
        IF CHAR1(0) = 'E' THEN GOTO LOOP;
        IF CHAR1(0) >= 30H AND CHAR1(0) <= 39H THEN
        DO;
          CALL JREAD(.CHAR1(0));
          CALL DUMP;
        END;
      END;
      IF (CHAR1(0)='C') AND MISCOMPARE THEN
      DO;
        WLOTRAK = TRACK;
        IF UNIT = NOUT THEN WLOTRAK = WLOTRAK+1;
        CALL DASH(WLOTRAK);
        IF UNIT < NOUT THEN
        DO;
          IF (TRACK MOD 10) = 0 THEN CALL WRITE(0,.(' '),1,.STAT);
          CALL WRITE(0,.DIGITS(TRACK MOD 10),1,.STAT);
          IF TRACK = 39 THEN CALL WRITE(0,.(CR,LF),2,.STAT);
        END;
        GO TO RESTART;
      END;
    END; /* END IF VERIFY LOOP */

RESTART:
  END; /* END OF MULTIPLE OUTPUT DEVICE LOOP */
  END; /* END OF TRACK LOOP */
  IF HITRAK <> 76 THEN
  DO TRACK = HITRAK+1 TO 76;
    IF (TRACK MOD 10) = 0 THEN CALL WRITE(0,.(' '),1,.STAT);
    CALL WRITE(0,.('-'),1,.STAT);
    IF TRACK = 39 THEN CALL WRITE(0,.(CR,LF),2,.STAT);
  END;
  CALL WRITE(0,.(CR,LF),2,.STAT);

GO TO LOOP;

CALL EXIT;

END;
src/divide.asm
;      '(C) Intel Corporation 1981'.  All rights reserved.  No
;      part of this program or publication may be reproduced,
;      transmitted, transcribed, stored in a retrievel system, or
;      translated into any language or computer language, in any
;      form or by any means, electronic, mechanical, magnetic,
;      optical, chemical, manual or otherwise, without the prior
;      written permission of Intel Corporation, 3065 Bowers
;      Avenue, Santa Clara, California, 95051, Attn: Software
;      License Administration.
	CSEG
	PUBLIC DIVIDE
DIVIDE: PUSH PSW
	PUSH H
	LXI H,0 ; ANSWER = 0
	SHLD ANS
	LXI H,1 ;HL =1
; WHILE DE <= BC
LOOP1:  MOV A,D
	CMP B
	JC DN1
	JZ DN2
	JMP LOOP2
DN2:	MOV A,C
	CMP E
	JC LOOP2
DN1:	ANA A ; SHIFT HL RIGHT
	MOV A,L
	RAL
	MOV L,A
	MOV A,H
	RAL
	MOV H,A
	ANA A ; SHIFT DE LEFT
	MOV A,E
	RAL
	MOV E,A
	MOV A,D
	RAL
	MOV D,A
	JMP LOOP1
LOOP2:  ANA A ; SHIFT HL RIGHT
	MOV A,H
	RAR
	MOV H,A
	MOV A,L
	RAR
	MOV L,A
	JC RETURN ; IF HL = 0 RETURN
	ANA A ; SHIFT DE RIGHT
	MOV A,D
	RAR
	MOV D,A
	MOV A,E
	RAR
	MOV E,A
	MOV A,D ; IF DE <= BC
	CMP B
	JZ DIV3
	JNC LOOP2
	JMP DIV2
DIV3:	MOV A,C
	CMP E
	JC LOOP2
DIV2:   MOV A,C ; BC := BC - DE
	SUB E
	MOV C,A
	MOV A,B
	SBB D
	MOV B,A
	LDA ANS ; ANS := ANS + HL
	ADD H
	STA ANS
	LDA ANS + 1
	ADD L
	STA ANS + 1
	JMP LOOP2
RETURN: LHLD ANS
	MOV E,H
	MOV D,L
	POP H
	POP PSW
	RET
	
    DSEG
ANS:	DS 2 ; THE ANSWER IS ACCUMULATED HERE
CPYRT:	DB		'(C) INTEL CORP 1981'
    END
src/dsort.plm
DSORT:
DO;

/************************************************************************/
/*																		*/
/*      '(C) Intel Corporation 1981'.  All rights reserved.  No			*/
/*      part of this program or publication may be reproduced,			*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

DECLARE COPYRIGHT (*) BYTE DATA ('(C) INTEL CORP 1981');

DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V3.2',0);

  /*********************************************************************

                          DSORT V3.2

     THIS PROGRAM SORTS A DIRECTORY ON AN ISIS-II FLOPPY OR HARD DISK.
     IT ASSUMES THAT THE HEADER BLOCK FOR THE ISIS.DIR FILE STARTS ON
     TRACK 1, SECTOR 1.  IF THAT EVER CHANGES, THEN THIS PROGRAM MUST
     ALSO CHANGE.
     THE SORTING ALGORITHM USED IS 'HEAPSORT', GIVEN ON PAGE 146,
     VOLUME 3, THE ART OF COMPUTER PROGRAMMING, BY KNUTH.

     CAPABILITY ADDED FOR SORTING ON DIFFERENT FIELDS.

  **********************************************************************/

  READ:   PROCEDURE(A,B,C,D,E) EXTERNAL; DECLARE(A,B,C,D,E) ADDRESS; END;
  WRITE:  PROCEDURE(A,B,C,D)   EXTERNAL; DECLARE(A,B,C,D)   ADDRESS; END;
  SPATH:  PROCEDURE(A,B,C)     EXTERNAL; DECLARE(A,B,C)     ADDRESS; END;
  EXIT:   PROCEDURE            EXTERNAL;                             END;
  MEMCK:  PROCEDURE ADDRESS    EXTERNAL;                             END;
  DEBLANK:PROCEDURE(A) ADDRESS EXTERNAL; DECLARE(A)         ADDRESS; END;
  ABSIO:  PROCEDURE(A,B,C,D)   EXTERNAL; DECLARE(A,B) BYTE,(C,D) ADDRESS; END;

  DECLARE BOOLEAN LITERALLY 'BYTE', TRUE LITERALLY '0FFH', FALSE LITERALLY '0';
  DECLARE CR LITERALLY '0DH', LF LITERALLY '0AH';
  DECLARE DIR$ENTRY LITERALLY
    'STRUCTURE(FN(10) BYTE, ATTRIB BYTE, EOF$COUNT BYTE,
     BLK$COUNT ADDRESS, HDR$BLK$SEC BYTE, HDR$BLK$TRK BYTE)';
  
  DECLARE FOREVER LITERALLY 'WHILE 1';
  DECLARE ISIS$DIR$BLK LITERALLY '0101H';
  DECLARE DISK$READ LITERALLY '4';
  DECLARE DISK$WRITE LITERALLY '6';
  
  DECLARE SIGNON(*) BYTE DATA('ISIS-II Disk Directory Sorter V3.2', CR, LF);
  
  DECLARE SYNMSG(*) BYTE DATA(
  'Command error, syntax is: DSORT <drive no> <E | L | S>', CR, LF);
  
  DECLARE MEMMSG(*) BYTE DATA('Insufficient memory to hold directory', CR, LF);
  DECLARE ISIS$DIR(*) BYTE INITIAL (':Fx:ISIS.DIR ');
  DECLARE DIR(1) DIR$ENTRY AT (.MEMORY);
  DECLARE SAVE DIR$ENTRY AT (.MEMORY);
  DECLARE DIR$PTR ADDRESS;
  DECLARE PTR$BLK(64) ADDRESS;
  DECLARE DATA$BLK$INDEX BYTE;
  DECLARE DISK BYTE;
  DECLARE (ACTUAL, STATUS) ADDRESS;
  DECLARE (X, L, R, NUM$ENTRIES) ADDRESS;

  DECLARE (CHAR BASED X) BYTE;
  DECLARE CMP$RESULT BOOLEAN;
  DECLARE THE$COMPARE ADDRESS;		/* THE PARTICULAR COMPARISON TO DO */

  NORM$CMP: PROCEDURE(APTR, BPTR);
    /*
     * THE NORMAL DSORT COMPARISON -
     *   SET CMP$RESULT TRUE IF THE DIRECTORY ENTRY ASSOCIATED WITH APTR IS
     *   'LESS THAN' THE DIRECTORY ENTRY ASSOCIATED WITH BPTR
     */

    DECLARE (APTR, BPTR) ADDRESS;
    DECLARE (A BASED APTR) DIR$ENTRY;
    DECLARE (B BASED BPTR) DIR$ENTRY;
    DECLARE I BYTE;

    I = 0;
    DO WHILE (I < 9) AND (A.FN(I) = B.FN(I));   /* COMPARE FILE NAMES */
      I = I + 1;
    END;
    CMP$RESULT =  (A.FN(I) < B.FN(I));
  END NORM$CMP;

  EXT$CMP: PROCEDURE(APTR, BPTR);
    /*
     * THE EXTENSION DSORT COMPARISON -
     *   SETS CMP$RESULT TRUE IF THE EXTENSION OF THE DIRECTORY ENTRY
     *   ASSOCIATED WITH APTR IS 'LESS THAN' THE EXTENSION OF THE DIRECTORY
     *   ENTRY ASSOCIATED WITH BPTR
     */

    DECLARE (APTR, BPTR) ADDRESS;
    DECLARE (A BASED APTR) DIR$ENTRY;
    DECLARE (B BASED BPTR) DIR$ENTRY;
    DECLARE I BYTE;

    I = 7;
    DO WHILE (I < 9) AND (A.FN(I) = B.FN(I));   /* COMPARE EXTENSIONS */
      I = I + 1;
    END;
    IF (A.FN(I) = B.FN(I)) THEN CALL NORM$CMP(A$PTR,B$PTR);
    				/* EXTENSION IS SAME, SO COMPARE NORMALLY */
    ELSE CMP$RESULT = (A.FN(I) < B.FN(I));
  END EXT$CMP;

  SIZE$CMP: PROCEDURE(APTR, BPTR);
    /*
     * THE SIZE DSORT COMPARISON -
     *   SETS CMP$RESULT TRUE IF THE SIZE OF THE DIRECTORY ENTRY
     *   ASSOCIATED WITH APTR IS 'LESS THAN' THE SIZE OF THE DIRECTORY
     *   ENTRY ASSOCIATED WITH BPTR. THE COMPARISON CONSIDERS ONLY THE
     *   BLK$COUNT AND EOF$COUNT FIELDS OF THE DIRECTORY ENTRY.
     */

    DECLARE (APTR, BPTR) ADDRESS;
    DECLARE (A BASED APTR) DIR$ENTRY;
    DECLARE (B BASED BPTR) DIR$ENTRY;

    IF (A.BLK$COUNT = B.BLK$COUNT) THEN DO;
       IF (A.EOF$COUNT = B.EOF$COUNT) THEN
           CALL NORM$CMP(A$PTR,B$PTR);
    				/* SIZE IS SAME, SO COMPARE NORMALLY */
       ELSE CMP$RESULT = (A.EOF$COUNT < B.EOF$COUNT);
    END;
    ELSE CMP$RESULT = (A.BLK$COUNT < B.BLK$COUNT);
  END SIZE$CMP;

  LOC$CMP: PROCEDURE(APTR, BPTR);
    /*
     * THE LOCATION DSORT COMPARISON -
     *   SETS CMP$RESULT TRUE IF THE LOCATION OF THE DIRECTORY ENTRY
     *   ASSOCIATED WITH APTR IS 'LESS THAN' THE LOCATION OF THE DIRECTORY
     *   ENTRY ASSOCIATED WITH BPTR. THE COMPARISON CONSIDERS ONLY THE
     *   POINTER BLOCK OF THE FIRST DATA SECTOR.
     */

    DECLARE (APTR, BPTR) ADDRESS;
    DECLARE (A BASED APTR) DIR$ENTRY;
    DECLARE (B BASED BPTR) DIR$ENTRY;

    IF (A.HDR$BLK$TRK = B.HDR$BLK$TRK) THEN DO;
       IF (A.HDR$BLK$SEC = B.HDR$BLK$SEC) THEN
           CALL NORM$CMP(A$PTR,B$PTR);
    				/* LOCATION IS SAME, SO COMPARE NORMALLY */
       ELSE CMP$RESULT = (A.HDR$BLK$SEC < B.HDR$BLK$SEC);
    END;
    ELSE CMP$RESULT = (A.HDR$BLK$TRK < B.HDR$BLK$TRK);
  END LOC$CMP;

  A$LT$B: PROCEDURE(APTR, BPTR) BOOLEAN;
    /** RETURNS TRUE IF THE DIRECTORY ENTRY ASSOCIATED WITH APTR IS ***
    *** 'LESS THAN' THE DIRECTORY ENTRY ASSOCIATED WITH BPTR        **/

    DECLARE (APTR, BPTR) ADDRESS;
    DECLARE (A BASED APTR) DIR$ENTRY;
    DECLARE (B BASED BPTR) DIR$ENTRY;
    DECLARE (AFMT, BFMT) BOOLEAN;
    DECLARE I BYTE;

    AFMT = (A.ATTRIB AND 80H) <> 0;     /* AFMT := TRUE IFF FORMAT FILE */
    BFMT = (B.ATTRIB AND 80H) <> 0;     /* BFMT LIKEWISE */
    IF AFMT AND NOT BFMT THEN RETURN TRUE;
    IF BFMT AND NOT AFMT THEN RETURN FALSE;

    CALL THE$COMPARE(A$PTR,B$PTR);	/* DO THE COMPARE */
    RETURN (CMP$RESULT);
  END A$LT$B;

  MOVE$B$TO$A: PROCEDURE(APTR, BPTR);
    /** MOVES THE DIRECTORY ENTRY ASSOCIATED WITH APTR TO THE ***
    *** DIRECTORY ENTRY ASSOCIATED WITH BPTR                  **/

    DECLARE (APTR, BPTR) ADDRESS;
    DECLARE (A BASED APTR) DIR$ENTRY;
    DECLARE (B BASED BPTR) DIR$ENTRY;
    DECLARE I BYTE;

    A.FN(0) = B.FN(0);
    A.FN(1) = B.FN(1);
    A.FN(2) = B.FN(2);
    A.FN(3) = B.FN(3);
    A.FN(4) = B.FN(4);
    A.FN(5) = B.FN(5);
    A.FN(6) = B.FN(6);
    A.FN(7) = B.FN(7);
    A.FN(8) = B.FN(8);
    A.FN(9) = B.FN(9);
    A.ATTRIB = B.ATTRIB;
    A.EOF$COUNT = B.EOF$COUNT;
    A.BLK$COUNT = B.BLK$COUNT;
    A.HDR$BLK$SEC = B.HDR$BLK$SEC;
    A.HDR$BLK$TRK = B.HDR$BLK$TRK;
  END MOVE$B$TO$A;

  SIFT: PROCEDURE(J);
    /** SIFT THE DIRECTORY ENTRY STORED IN 'SAVE' DOWNWARDS TO ***
    *** ITS PROPER PLACE IN THE HEAP. BEGIN THE COMPARISONS    ***
    *** WITH THE ENTRY INDEXED BY J                            **/

    DECLARE (I, J) ADDRESS;

    DO FOREVER;
      I = J;
      J = J + J;
      IF J <= R THEN DO;
        IF J < R THEN DO;
          IF A$LT$B(.DIR(J), .DIR(J + 1)) THEN J = J + 1;
        END;
        IF A$LT$B(.SAVE, .DIR(J)) THEN
          CALL MOVE$B$TO$A(.DIR(I), .DIR(J));
        ELSE DO;
          CALL MOVE$B$TO$A(.DIR(I), .SAVE);
          RETURN;
        END;
      END;
      ELSE DO;  /* J > R */
        CALL MOVE$B$TO$A(.DIR(I), .SAVE);
        RETURN;
      END;
    END;     /* FOREVER LOOP */
  END SIFT;

  REWIND$DIR: PROCEDURE;
    CALL ABSIO(DISK$READ, DISK, ISIS$DIR$BLK, .PTR$BLK);
    DIR$PTR = .DIR(1);
    DATA$BLK$INDEX = 1;
  END REWIND$DIR;

  NEXT$SECTOR: PROCEDURE;
    DATA$BLK$INDEX = DATA$BLK$INDEX + 1;
    IF DATA$BLK$INDEX > LAST(PTR$BLK) THEN DO;  /* END OF POINTER BLOCK */
      DATA$BLK$INDEX = 2;
      IF PTR$BLK(1) = 0 THEN  /* END OF FILE */
        RETURN;
      CALL ABSIO(DISK$READ, DISK, PTR$BLK(1), .PTR$BLK);
    END;
  END NEXT$SECTOR;

  MORE$ENTRIES: PROCEDURE BOOLEAN;
    IF DIR(NUM$ENTRIES).FN(0) = 7FH THEN
      RETURN FALSE;
    CALL NEXT$SECTOR;
    RETURN PTR$BLK(DATA$BLK$INDEX) <> 0;
  END MORE$ENTRIES;

  CALL WRITE(0, .SIGNON, LENGTH(SIGNON), .STATUS);
  CALL READ(1, .MEMORY, 122, .ACTUAL, .STATUS);   /* READ COMMAND TAIL */
  THE$COMPARE = .NORM$CMP;
  X = DEBLANK(.MEMORY);
  ISIS$DIR(2) = CHAR;
  X = DEBLANK(X + 1);
  IF CHAR = 'E' OR CHAR = 'e' THEN THE$COMPARE = .EXT$CMP;
  IF CHAR = 'S' OR CHAR = 's' THEN THE$COMPARE = .SIZE$CMP;
  IF CHAR = 'L' OR CHAR = 'l' THEN THE$COMPARE = .LOC$CMP;
  CALL SPATH(.ISIS$DIR, .MEMORY, .STATUS);   /* VALIDATE DRIVE NUMBER */
  IF (STATUS <> 0) THEN DO;
    /* NO DRIVE SPECIFIED OR INVALID SPECIFICATION */
    CALL WRITE(0, .SYNMSG, LENGTH(SYNMSG), .STATUS);
    CALL EXIT;
  END;

  /* READ IN THE ISIS.DIR FILE */

  DISK = ISIS$DIR(2) - '0';

  NUM$ENTRIES = 0;
  DIR(0).FN(0) = 0;
  CALL REWIND$DIR;
  DO WHILE MORE$ENTRIES;
    CALL ABSIO(DISK$READ, DISK, PTR$BLK(DATA$BLK$INDEX), DIR$PTR);
    DIR$PTR = DIR$PTR + 128;
    IF DIR$PTR > MEMCK THEN DO;  /* OUT OF MEMORY */
      CALL WRITE(0, .MEMMSG, LENGTH(MEMMSG), .STATUS);
      CALL EXIT;
    END;
    NUM$ENTRIES = NUM$ENTRIES + 8;  /* COUNT ENTRIES */
  END;
  ACTUAL = DIR$PTR;
  DO WHILE DIR(NUM$ENTRIES).FN(0) = 7FH;
    NUM$ENTRIES = NUM$ENTRIES - 1;
  END;

  /* BEGIN HEAPSORT */

  L = (NUM$ENTRIES / 2) + 1;
  R = NUM$ENTRIES;

  DO WHILE L > 1;   /* FORM ARRAY INTO A HEAP */
    L = L - 1;
    CALL MOVE$B$TO$A(.SAVE, .DIR(L));
    CALL SIFT(L);
  END;

  DO WHILE R > 1;   /* CONSTRUCT SORTED ARRAY */
    CALL MOVE$B$TO$A(.SAVE, .DIR(R));
    CALL MOVE$B$TO$A(.DIR(R), .DIR(1));
    R = R - 1;
    CALL SIFT(1);
  END;

  /* DEALLOCATE THE DELETED FILES */
  DO WHILE DIR(NUM$ENTRIES).FN(0);
    DIR(NUM$ENTRIES).FN(0) = 7FH;
    NUM$ENTRIES = NUM$ENTRIES - 1;
  END;

  /* WRITE THE ISIS.DIR FILE OUT */
  CALL REWIND$DIR;
  DO WHILE DIR$PTR < ACTUAL;
    CALL NEXT$SECTOR;
    CALL ABSIO(DISK$WRITE, DISK, PTR$BLK(DATA$BLK$INDEX), DIR$PTR);
    DIR$PTR = DIR$PTR + 128;
  END;
  CALL EXIT;
END DSORT;
src/else.plm
ELSE$MOD: DO;

/************************************************************************/
/*																		*/
/*      '(C) Intel Corporation 1981'.  All rights reserved.  No			*/
/*      part of this program or publication may be reproduced,			*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

DECLARE COPYRIGHT (*) BYTE DATA ('(C) INTEL CORP 1981');

DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.0',0);

DECLARE	LIT		LITERALLY	'LITERALLY',
		DCL		LIT	'DECLARE',
		TRUE	LIT	'0FFH',
		FALSE	LIT	'000H',
		PROC	LIT	'PROCEDURE',
		PROCEND	LIT	'END',
		THENDO	LIT	'THEN DO;',
		ELSEIF	LIT	'END; ELSE IF',
		ELSEDO	LIT	'END; ELSE DO;',
		IFEND	LIT	'END',
		WHILEND	LIT	'END',
		CR		LIT	'0DH',
		LF		LIT	'0AH';

EXIT:	PROC EXTERNAL;											PROCEND;
READ:	PROC (A,B,C,D,E) EXTERNAL;	DCL (A,B,C,D,E) ADDRESS;	PROCEND;
WRITE:	PROC (A,B,C,D) EXTERNAL;	DCL (A,B,C,D) ADDRESS;		PROCEND;
SPATH:	PROC (A,B,C) EXTERNAL;		DCL (A,B,C) ADDRESS;		PROCEND;
DEBLANK:PROC (A) ADDRESS EXTERNAL;	DCL (A) ADDRESS;			PROCEND;
DELIMIT:PROC (A) ADDRESS EXTERNAL;	DCL (A) ADDRESS;			PROCEND;
SEQ:	PROC (A,B,C) BYTE EXTERNAL;	DCL (A,B,C) ADDRESS;		PROCEND;
FORCE$UPPER:	PROC(A) EXTERNAL;	DCL (A) ADDRESS;			PROCEND;

DCL (STATUS, ACTUAL, AFTN1, AFTN2) ADDRESS;
DCL (CMND, CMND$PTR) ADDRESS, (CMND$CH BASED CMND$PTR) (1) BYTE;
DCL (PN1) STRUCTURE
	(DEV BYTE, NAME (6) BYTE, EXT (3) BYTE, DEV$TYPE BYTE, DRIVE$TYPE BYTE);
DCL (NESTED$IF) ADDRESS;

CALL READ (1, .MEMORY, 128, .ACTUAL, .STATUS); /* Skip command tail. */
NESTED$IF = 0;
DO WHILE TRUE;
	CALL WRITE (0, .('#'), 1, .STATUS);
	CALL READ (1, .MEMORY, 128, .ACTUAL, .STATUS);
	IF (STATUS <> 0) OR (ACTUAL = 0) THENDO
		CALL EXIT; /* Probably hit the end of the command file. */
	IFEND;
	MEMORY (ACTUAL - 1) = CR;
	CALL FORCE$UPPER (.MEMORY);
	CMND$PTR = DEBLANK (.MEMORY);
	IF SEQ (CMND$PTR, .('DEBUG '), 6) THENDO
		CMND$PTR = DEBLANK (CMND$PTR + 5); /* Skip the DEBUG. */
	IFEND;
	CALL SPATH (CMND$PTR, .PN1, .STATUS);
	IF STATUS = 0 THENDO
		IF SEQ (.PN1.NAME, .('IF', 0, 0, 0, 0, 0, 0, 0), 9) THENDO
			NESTED$IF = NESTED$IF + 1;
		ELSEIF SEQ (.PN1.NAME, .('ENDIF', 0, 0, 0, 0), 9) THENDO
			IF NESTED$IF = 0 THENDO
				CALL EXIT; /* Continue with the ENDIF part. */
			IFEND;
			NESTED$IF = NESTED$IF - 1;
		IFEND;
	IFEND;
WHILEND;

END ELSE$MOD;
src/endif.plm
ENDIFMOD:DO;


/************************************************************************/
/*																		*/
/*      '(C) Intel Corporation 1981'.  All rights reserved.  No			*/
/*      part of this program or publication may be reproduced,			*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

      
DECLARE COPYRIGHT (*) BYTE DATA ('(C) INTEL CORP 1981');

DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.0',0);
    

EXIT:PROCEDURE EXTERNAL;END;
CALL EXIT;
END;
src/errmsg.plm
$ TITLE('==> PASSIF -- ERRMSGMOD -- ERROR MESSAGE MODULE <==')

ERR$MSG$MOD:
DO;

/************************************************************************/
/*																		*/
/*      '(C) Intel Corporation 1981'.  All rights reserved.  No			*/
/*      part of this program or publication may be reproduced,			*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

$ NOLIST

/*         LIT.INC          */

DECLARE                 AS LITERALLY 'LITERALLY',              /* plm */
    AMPERSAND           AS '''&''',							   /* ??? */
    BELL                AS '07H',                              /* plm */
    BLANK               AS '020H',                             /* plm */
    BOOLEAN             AS 'BYTE',                             /* plm */
    CHK                 AS 'CALL CHECK$STATUS',	               /* plm */
    CLEAR$CHAR			AS '01CH',							   /* 1510 */
    CO$ECHO$FILE        AS '0F00H',                            /* open */
    COLON               AS ''':''',                            /* char */
    COMMA               AS '02CH',                       	   /* plm */
    CONSOLE$INPUT       AS '1',                                /* open */
    CONSOLE$OUTPUT      AS '0',                                /* open */
    CONTROL$Z           AS '01AH',                             /* plm */
    CR                  AS '0DH',                              /* plm */
    DOT                 AS '''.''',                            /* char */
    END$DO              AS 'END',                              /* plm */
    END$DO$CASE         AS 'END',                              /* plm */
    END$DO$WHILE        AS 'END',                              /* plm */
    END$IF              AS '   ',                              /* plm */
    END$ITERATED$DO		AS 'END',							   /* plm */
    END$LOOP            AS ' ',                                /* plm */
    EOF$CHAR            AS 'CONTROL$Z',                        /* plm */
    ESC                 AS '01BH',                             /* plm */
    FALSE               AS '0H',                               /* plm */
    FF					AS '0CH',							   /* ??? */
    FOREVER             AS 'WHILE 1',                          /* plm */
    FORMAT$ATTRIBUTE	AS '3',								   /* attrib */
    HASH$MARK			AS '''#''',							   /* plm */
    INIT$STG			AS '(*) BYTE INITIAL',				   /* plm */
    LEAD$IN$CHAR		AS '07EH',							   /*1510 */
    LF                  AS '0AH',                              /* plm */
    NO$LINE$EDIT        AS '0',                                /* open */
    NULL				AS '0FFFFH',						   /* ???  */
    OPEN$FOR$READ       AS '1',                                /* open */
    OPEN$FOR$WRITE      AS '2',                                /* open */
    OPEN$FOR$UPDATE		AS '3',								   /* open */
    PUB$STRING			AS '(*) BYTE PUBLIC DATA',             /* plm  */
    RESET				AS '0',								   /* attrib */
    RETURN$MARKER$POS   AS '0',                                /* seek */
    SEEK$2$EOF          AS '4',                                /* seek */
    SEEK$BACKWARD$BY$N  AS '1',                                /* seek */
    SEEK$FORWARD$BY$N	AS '3',								   /* seek */
    SEEK$2$N            AS '2',                                /* seek */
    SEMICOLON			AS ''';''',							   /* plm  */
    SET					AS '1',								   /* attrib */
    STRING              AS '(*) BYTE DATA',                    /* plm  */
    TAB                 AS '09H',                              /* plm */
    TRANSFER$CONTROL    AS '1',                                /* load */
    TRUE                AS '0FFH',                             /* plm */
    UNDERBAR			AS '''_''', 						   /* ??? */
    USER$CI             AS '0',                                /* ??? */
    WRITE$PROTECT$ATTRIBUTE 		AS '2',					   /* attrib */
    ZERO$BIAS           AS '0'                                 /* load */ ;

    /*        ENDLIT.INC        */

$ LIST
$ NOLIST

		/* ISIS.INC */

ATTRIB:
	PROCEDURE(FILE$NAME$PTR,WHICH$ATTRIBUTE,SET$OR$RESET,STATUS$PTR) EXTERNAL;
	DECLARE (FILE$NAME$PTR,WHICH$ATTRIBUTE,SET$OR$RESET,STATUS$PTR) ADDRESS;
	END
ATTRIB;

CLOSE:
	PROCEDURE (AFTN,STATUS) EXTERNAL;
	DECLARE (AFTN,STATUS) ADDRESS;
	END
CLOSE;

CI:
	PROCEDURE BYTE EXTERNAL;
	END
CI;

CO:
	PROCEDURE (CHAR$CO) EXTERNAL;
	DECLARE CHAR$CO BYTE;
	END
CO;

CONSOL:
	PROCEDURE (CONSOLE$INPUT$FILE,CONSOL$OUTPUT$FILE,STATUS$CON) EXTERNAL;
	DECLARE (CONSOLE$INPUT$FILE,CONSOL$OUTPUT$FILE,STATUS$CON) ADDRESS;
	END
CONSOL;

DELETE:
	PROCEDURE (FILE$NAME$PTR,STATUS) EXTERNAL;
	DECLARE (FILE$NAME$PTR,STATUS) ADDRESS;
	END
DELETE;

ERROR:
	PROCEDURE  (ERROR$NUMBER) EXTERNAL;
	DECLARE ERROR$NUMBER ADDRESS;
	END
ERROR;

EXIT:
	PROCEDURE EXTERNAL;
	END
EXIT;

IO$CHK:
	PROCEDURE BYTE EXTERNAL;
	END
IO$CHK;

IO$DEF:
	PROCEDURE (WHICH$DEVICE,ENTRY$POINT) EXTERNAL;
	DECLARE WHICH$DEVICE BYTE,
			ENTRY$POINT ADDRESS;
	END
IO$DEF;

IO$SET:
	PROCEDURE (CONFIGURATION$BYTE) EXTERNAL;
	DECLARE CONFIGURATION$BYTE BYTE;
	END
IO$SET;

LOAD:
	PROCEDURE (FILE,BIAS,CONTROL$OF$TRANSFER,ENTRY$POINT,STATUS) EXTERNAL;
	DECLARE (FILE,BIAS,CONTROL$OF$TRANSFER,ENTRY$POINT,STATUS) ADDRESS;
	END
LOAD;

MEMCK:
	PROCEDURE ADDRESS EXTERNAL;
	END
MEMCK;

OPEN:
	PROCEDURE(AFTN,FILENAME,ACCESS$MODE,LINE$EDIT$AFTN,ERROR) EXTERNAL;
	DECLARE (AFTN,FILENAME,ACCESS$MODE,LINE$EDIT$AFTN,ERROR) ADDRESS;
	END
OPEN;

READ:
	PROCEDURE (AFTN,BUFFER,COUNT,ACTUAL,STATUS) EXTERNAL;
	DECLARE (AFTN,BUFFER,COUNT,ACTUAL,STATUS) ADDRESS;
	END
READ;

RENAME:
	PROCEDURE (OLD$NAME,NEW$NAME,STATUS$R) EXTERNAL;
	DECLARE (OLD$NAME,NEW$NAME,STATUS$R) ADDRESS;
	END
RENAME;

RESCAN:
	PROCEDURE (AFTN,STATUS) EXTERNAL;
	DECLARE (AFTN,STATUS) ADDRESS;
	END
RESCAN;

SEEK:
	PROCEDURE (AFTN,MODE,BLOCKNO,BYTENO,STATUS) EXTERNAL;
	DECLARE (AFTN,MODE,BLOCKNO,BYTENO,STATUS) ADDRESS;
	END
SEEK;

SPATH:
	PROCEDURE (FILE,BUFFER,STATUS) EXTERNAL;
	DECLARE (FILE,BUFFER,STATUS) ADDRESS;
	END
SPATH;

WHOCON:
	PROCEDURE (AFTN,BUFFER) EXTERNAL;
	DECLARE (AFTN,BUFFER) ADDRESS;
	END
WHOCON;

WRITE:
	PROCEDURE (AFTN,BUFFER,COUNT,STATUS) EXTERNAL;
	DECLARE (AFTN,BUFFER,COUNT,STATUS) ADDRESS;
	END
WRITE;

		/* END ISIS.INC */
$ NOLIST

/************************************************************/
/*															*/
/*              LITERALLY'S UNIQUE TO PASSIF                */
/*															*/
/************************************************************/

DECLARE
    MINIMUM$ACCEPTABLE$BANNER$LENGTH 	AS 		'73',
    MAXIMUM$TOKEN$LENGTH				AS		'70',
    BI									AS		'CALL BOMB$IF(STATUS)',

	FIRST$FIELD							AS		'0',
    SECOND$FIELD						AS		'28',
    THIRD$FIELD							AS		'54',

    RIGHT$PARENTHESIS 					AS		''')''',
    LEFT$PARENTHESIS 					AS		'''(''',
    RI									AS		'CALL REPORT$IF',
    UNRECOGNIZED$SWITCH$ERR 			AS		'201',
    QUESTION$MARK						AS		'''?''';

$ LIST
$ NOLIST

/*	TOKENS.INC  */

GET$ARGUMENT:
	PROCEDURE (BUF$PTR,STATUS$PTR) BYTE EXTERNAL;
	DECLARE (BUF$PTR,STATUS$PTR) ADDRESS;
    END
GET$ARGUMENT;

/*	END TOKENS.INC  */
$ LIST
$ NOLIST

/*	CLI.INC  */

DECLARE BUF$COUNT BYTE EXTERNAL;

UDI$STRING$MATCH:
	PROCEDURE (STG$1$PTR,STG$2$PTR) BOOLEAN EXTERNAL;
    DECLARE (STG$1$PTR,STG$2$PTR) ADDRESS;
	END
UDI$STRING$MATCH;

ENFORCE$DELIMITER:
	PROCEDURE(ENFORCEE) EXTERNAL;
	DECLARE ENFORCEE BYTE;
	END
ENFORCE$DELIMITER;

NEXT$ARG:
	PROCEDURE EXTERNAL;
	END
NEXT$ARG;

INTERPRET$COMMAND$LINE:
	PROCEDURE EXTERNAL;
	END
INTERPRET$COMMAND$LINE;

/*	END CLI.INC  */
$ LIST
$ NOLIST

/*	REPORT.INC  */

BOMB$IF:
	PROCEDURE (STATUS) EXTERNAL;
    DECLARE STATUS ADDRESS;
    END
BOMB$IF;

REPORT$SYNTAX$ERROR:
	PROCEDURE EXTERNAL;
	END
REPORT$SYNTAX$ERROR;

REPORT$ISIS$ERROR:
	PROCEDURE (STATUS) EXTERNAL;
	DECLARE STATUS ADDRESS;
	END
REPORT$ISIS$ERROR;

REPORT$ASSERTION$SUCCESS:
	PROCEDURE EXTERNAL;
	END
REPORT$ASSERTION$SUCCESS;

REPORT$ASSERTION$FAILURE:
	PROCEDURE EXTERNAL;
	END
REPORT$ASSERTION$FAILURE;

REPORT$ASSERTION$FAILURE$W$ISIS$ERR:
	PROCEDURE (STATUS) EXTERNAL;
	DECLARE STATUS ADDRESS;
    END
REPORT$ASSERTION$FAILURE$W$ISIS$ERR;

REPORT$ASSERTION$FAILURE$W$MSG:
	PROCEDURE (OLD$STYLE$MSG$PTR) EXTERNAL;
	DECLARE OLD$STYLE$MSG$PTR ADDRESS;
    END
REPORT$ASSERTION$FAILURE$W$MSG;

MSG$LENGTH:
	PROCEDURE (OLD$STYLE$MSG$PTR) BYTE EXTERNAL;
    DECLARE OLD$STYLE$MSG$PTR ADDRESS;
	END
MSG$LENGTH;

/*	END REPORT.INC  */
$ LIST
$ NOLIST

/*	FUNC.INC  */

FILE$EXISTS:
	PROCEDURE EXTERNAL;
	END
FILE$EXISTS;

FILE$ABSENT:
	PROCEDURE EXTERNAL;
	END
FILE$ABSENT;

FILES$MATCH:
	PROCEDURE EXTERNAL;
    END
FILES$MATCH;

STRING$FOUND:
	PROCEDURE EXTERNAL;
	END
STRING$FOUND;

STRING$ABSENT:
	PROCEDURE EXTERNAL;
	END
STRING$ABSENT;

/*	END FUNC.INC  */
$ LIST

$ EJECT

/************************************************************/
/*															*/
/*           ERROR                MESSAGES                  */
/*															*/
/************************************************************/

DECLARE

	BAD$SYNTAX$MSG PUB$STRING
		('syntax error in command tail',0),

    BOMB$IF$MSG$1 PUB$STRING
		('Isis error ',0),

    BOMB$IF$MSG$2 PUB$STRING
        (' detected while processing report file.',0),

    DURING$ASSERTION$CHECK$MSG PUB$STRING
    	(' encountered while performing assertion checking.',0),

    PASSIF$INVOKED$BY$MSG PUB$STRING
    	('Passif invoked by:',0),

    ZERO$LENGTH$FILE$MSG PUB$STRING
    	('illegal file of zero length encountered',0);

END
ERR$MSG$MOD;
src/error.pex
error: procedure (error$num) external;
    declare (error$num) address;
end error;
src/errs.plm
ERRS: DO;


/************************************************************************/
/*																		*/
/*      '(C) Intel Corporation 1981'.  All rights reserved.  No			*/
/*      part of this program or publication may be reproduced,			*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

      
DECLARE COPYRIGHT (*) BYTE DATA ('(C) INTEL CORP 1981');

DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.0',0);
    


$NOLIST
/* PEX */
DECLARE SCANP ADDRESS EXTERNAL;
DECLARE SCANBYTE BASED SCANP BYTE;
DECLARE OBUFP ADDRESS EXTERNAL;
DECLARE TARLEN BYTE EXTERNAL;
DECLARE GIVEUP ADDRESS EXTERNAL;
BUMPSCANP :PROCEDURE  EXTERNAL;END;
CONSOLEIN :PROCEDURE  EXTERNAL;END;
DDIGCH :PROCEDURE BYTE EXTERNAL;END;
FILECH :PROCEDURE BYTE EXTERNAL;END;
FMOVE :PROCEDURE (ZZ1,ZZ2,ZZ3) EXTERNAL;DECLARE (ZZ1,ZZ2,ZZ3)ADDRESS;END;
OUTCHAR :PROCEDURE (ZZ1) EXTERNAL;DECLARE (ZZ1)BYTE;END;
OUTSCANBYTE :PROCEDURE  EXTERNAL;END;
OUTSCANSTRING :PROCEDURE  EXTERNAL;END;
PRINT :PROCEDURE (ZZ1) EXTERNAL;DECLARE (ZZ1)ADDRESS;END;
SCANWHILEBLANKS :PROCEDURE  EXTERNAL;END;
SETSC :PROCEDURE (ZZ1) EXTERNAL;DECLARE (ZZ1)ADDRESS;END;
SFOUND :PROCEDURE BYTE EXTERNAL;END;
DECLARE FATAL BYTE EXTERNAL;
DECLARE ACTUAL ADDRESS EXTERNAL;
CI :PROCEDURE EXTERNAL;END;
EX :PROCEDURE  EXTERNAL;END;
MEMCK :PROCEDURE ADDRESS EXTERNAL;END;
OPENI :PROCEDURE (ZZ1) EXTERNAL;DECLARE (ZZ1)ADDRESS;END;
READI :PROCEDURE (ZZ1,ZZ2) EXTERNAL;DECLARE (ZZ1,ZZ2)ADDRESS;END;
WRITEC :PROCEDURE (ZZ1,ZZ2) EXTERNAL;DECLARE (ZZ1,ZZ2)ADDRESS;END;
DECLARE FALSE LITERALLY'0';
DECLARE TRUE LITERALLY'255';
LTNMCH :PROCEDURE BYTE EXTERNAL;END;
SCANUNTIL :PROCEDURE (ZZ1) EXTERNAL;DECLARE (ZZ1)ADDRESS;END;
/* ENDPEX */
$LIST

DECLARE NOT$FIRST$TIME BYTE INITIAL (FALSE);
DECLARE READ$FINISHED BYTE INITIAL (FALSE);
DECLARE FILE$BUF (16) BYTE INITIAL (':F3:');
DECLARE LST (*) BYTE DATA ('.LST',0);
DECLARE CLEAR$SCREEN (*) BYTE DATA (1DH,1FH,           /* DATAPOINT */
                                    1BH,'H',1BH,'M',   /* OMRON */
                                    7EH,1CH,           /* H-1510 */
                                    0CH,               /* H-1200 & VISITAR */
                                    1BH,'E',           /* BEEHIVE & EMDS */
                                    0DH,0AH,0);
DECLARE LINES BYTE;
DECLARE LINE$COUNT BYTE;
DECLARE TEMP ADDRESS;
DECLARE CAPACITY ADDRESS;
DECLARE TARGET(10) BYTE PUBLIC DATA ('*** ERROR');

WAIT: PROCEDURE;
  IF NOT$FIRST$TIME THEN CALL CI;
  NOT$FIRST$TIME = TRUE;
END;

BUMP$LINES: PROCEDURE;
  IF ((LINE$COUNT := LINE$COUNT + 1) = 80) OR
     SCAN$BYTE = 0AH THEN
   DO;
    LINE$COUNT = 0;
    LINES = LINES + 1;
   END;
END;

FLUSH: PROCEDURE;
  TEMP = .MEMORY + GIVEUP - SCAN$P;
  CALL FMOVE(GIVEUP - SCAN$P, SCAN$P, .MEMORY);
  CAPACITY = MEMCK - TEMP;
  CALL READI(TEMP,CAPACITY);
  READ$FINISHED = (ACTUAL < CAPACITY);
  SCAN$P = .MEMORY;
  GIVEUP = TEMP + ACTUAL;
END;

BACK$PTR: PROCEDURE ADDRESS;
  CALL SET$SC(SCAN$P);
  LINES = 0;
  LINE$COUNT = 0;
   DO WHILE LINES < 5;
    SCAN$P = SCAN$P - 1;
    CALL BUMP$LINES;
   END;
  RETURN SCAN$P;
END;

FORWARD$PTR: PROCEDURE;
  LINES = 0;
  LINE$COUNT = 0;
   DO WHILE LINES < 15;
    IF (SCAN$P := SCAN$P + 1) = GIVE$UP THEN RETURN;
    CALL BUMP$LINES;
   END;
END;

FATAL = TRUE;
CALL CONSOLE$IN;
CALL SCAN$WHILE$BLANKS;
IF SCAN$BYTE = ':' THEN SCAN$P = SCAN$P + 2;
OBUF$P = .FILE$BUF;
IF DDIGCH THEN
 DO;
  FILE$BUF(2) = SCAN$BYTE;
  OBUF$P = .FILE$BUF(4);
  CALL BUMP$SCAN$P;
  CALL SCAN$UNTIL(.LTNMCH);
 END;
ELSE OBUF$P = .FILE$BUF(4);
 DO WHILE LTNMCH;
  CALL OUT$SCAN$BYTE;
 END;
SCAN$P = .LST;
CALL OUT$SCAN$STRING;
CALL OUT$CHAR(' ');
CALL OPENI(.FILE$BUF);
GIVE$UP = (SCAN$P := .MEMORY);
TARLEN = 9;
 DO WHILE NOT READ$FINISHED;
  CALL FLUSH;
   DO WHILE SFOUND;
    CALL WAIT;
    CALL PRINT(.CLEAR$SCREEN);
    TEMP = BACK$PTR;
    CALL FORWARD$PTR;
    CALL WRITEC(TEMP, SCAN$P-TEMP);
    IF READ$FINISHED THEN
     DO;
      IF SCAN$P = GIVE$UP THEN CALL EX;
     END;
    ELSE IF SCAN$P  > GIVE$UP - 2048 THEN CALL FLUSH;
   END;
 END;
CALL WAIT;
CALL PRINT(.CLEAR$SCREEN);
CALL WRITEC(GIVEUP-223,223);
CALL EX;

END ERRS;
src/exit.pex
exit: procedure external;
end exit;
src/exit.plm
EXIT$MOD: DO;

/************************************************************************/
/*																		*/
/*      '(C) Intel Corporation 1981'.  All rights reserved.  No			*/
/*      part of this program or publication may be reproduced,			*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

DECLARE COPYRIGHT (*) BYTE DATA ('(C) INTEL CORP 1981');

DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.0',0);

DECLARE	LIT		LITERALLY	'LITERALLY',
		DCL		LIT	'DECLARE',
		TRUE	LIT	'0FFH',
		FALSE	LIT	'000H',
		PROC	LIT	'PROCEDURE',
		PROCEND	LIT	'END',
		THENDO	LIT	'THEN DO;',
		ELSEIF	LIT	'END; ELSE IF',
		ELSEDO	LIT	'END; ELSE DO;',
		IFEND	LIT	'END',
		WHILEND	LIT	'END',
		CR		LIT	'0DH',
		LF		LIT	'0AH';

EXIT:	PROC EXTERNAL;											PROCEND;
READ:	PROC (A,B,C,D,E) EXTERNAL;	DCL (A,B,C,D,E) ADDRESS;	PROCEND;
WRITE:	PROC (A,B,C,D) EXTERNAL;	DCL (A,B,C,D) ADDRESS;		PROCEND;
CONSOL:	PROC (A,B,C) EXTERNAL;		DCL (A,B,C) ADDRESS;		PROCEND;
IOCHK:	PROC BYTE EXTERNAL;										PROCEND;

DCL (STATUS, ACTUAL) ADDRESS;
DCL (FILE1, FILE2) (15) BYTE;
DCL (COLD$START$CO) BYTE;

CALL READ (1, .MEMORY, 128, .ACTUAL, .STATUS); /* Skip command tail. */
COLD$START$CO = IOCHK AND 3;
IF COLD$START$CO = 0 THENDO /* Cold start CONSOL is tty. */
	CALL MOVE (5, .(':TI: '), .FILE1);
	CALL MOVE (5, .(':TO: '), .FILE2);
	CALL CONSOL (.FILE1, .FILE2, .STATUS);
ELSEIF COLD$START$CO = 1 THENDO /* Cold start CONSOL is crt. */
	CALL MOVE (5, .(':VI: '), .FILE1);
	CALL MOVE (5, .(':VO: '), .FILE2);
	CALL CONSOL (.FILE1, .FILE2, .STATUS);
IFEND;
CALL EXIT;

END EXIT$MOD;
src/files.plm
BACKUP$DISK$FILES: DO;


/************************************************************************/
/*																		*/
/*      '(C) Intel Corporation 1981'.  All rights reserved.  No			*/
/*      part of this program or publication may be reproduced,			*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

      
DECLARE COPYRIGHT (*) BYTE DATA ('(C) INTEL CORP 1981');


/********************************************************************
 *                                                                  *
 * This module is responsible for validating the command line       *
 * syntax and performing the file copying.                          *
 *                                                                  *
 ********************************************************************/

/* The following literally declarations are used to map PLM80 into
   PLM86 code
*/

declare word literally 'address';
declare integer literally 'address';
declare pointer literally 'address';

declare as literally 'literally';
declare dcl as 'declare';

dcl boolean as 'byte';
dcl true as '0FFH';
dcl false as '0';
dcl ptr as 'word';
dcl nil as '0';
dcl character as 'byte';
dcl char2 as 'word';
dcl varying as '1';

dcl for as 'do';
dcl endfor as 'end';
dcl thenn as 'then do;';
dcl elseif as 'end; else if';
dcl elsee as 'end; else do;';
dcl endif as 'end';
dcl whilee as 'do while';
dcl endwhile as 'end';
dcl endproc as 'end';
dcl endmod as 'end';
dcl enddo as 'end';

dcl CR as '0DH';
dcl LF as '0AH';
dcl BEL as '07H';

ATTRIB: procedure(FILE$PTR, ATTR, ONOFF, STATUS$PTR) external;
   dcl (FILE$PTR, STATUS$PTR) pointer;
   dcl (ATTR, ONOFF) word;
endproc ATTRIB;

SPATH: procedure(FILE$PTR, BUFFER$PTR, STATUS$PTR) external;
   dcl (FILE$PTR,BUFFER$PTR,STATUS$PTR) pointer;
endproc SPATH;

NUMOUT: procedure(VAL, BASE, LEAD, BUF$PTR, LEN) external;
   dcl VAL word;
   dcl (BASE, LEN) byte;
   dcl LEAD character;
   dcl BUF$PTR pointer;
end NUMOUT;

OPEN: procedure(AFTN$PTR, FILE$PTR, ACCESS, MODE, STATUS$PTR) external;
   dcl (AFTN$PTR, FILE$PTR, STATUS$PTR) pointer;
   dcl (ACCESS,MODE) word;
endproc OPEN;

CLOSE: procedure(AFTN, STATUS$PTR) external;
   dcl AFTN word;
   dcl STATUS$PTR pointer;
endproc CLOSE;

DELETE: procedure(FILE$PTR, STATUS$PTR) external;
   dcl (FILE$PTR, STATUS$PTR) pointer;
endproc DELETE;

READ: procedure(AFTN, BUF$PTR, LEN, ACTUAL$PTR, STATUS$PTR) external;
   dcl (BUF$PTR, ACTUAL$PTR, STATUS$PTR) pointer;
   dcl (AFTN, LEN) word;
endproc READ;

WRITE: procedure(AFTN, BUF$PTR, LEN, STATUS$PTR) external;
   dcl (BUF$PTR, STATUS$PTR) pointer;
   dcl (AFTN, LEN) word;
endproc WRITE;

ERROR: procedure(ERR$NUM) external;
   dcl ERRNUM word;
endproc ERROR;

EXIT: procedure external;
endproc EXIT;

dcl DELETE$OPTION boolean external;

dcl ISIS$FILE$BLOCKS word;
dcl MAX$LIMIT word;
dcl MAX$FILES word;
dcl DIR$NAME structure(
   DEVICE(4) character,
   FILENAME(11) character) initial(':F0:ISIS.DIR   ');

dcl SPATH$BLOCK structure(
   DEVNO byte,
   FILE(6) character,
   EXT(3) character,
   DEV$TYPE byte,
   DRIVE$TYPE byte);
dcl DIR$AFTN word;
dcl DIR$BUF(1000) structure(
   PRESENCE byte,
   FILENAME(6) character,
   EXT(3) character,
   ATTRIBUTES byte,
   EOF$COUNT byte,
   NO$DATA$BLOCKS word,
   HEADER$BLOCK$PTR word);
dcl TARGET$DIR$BUF(10) structure(
   PRESENCE byte,
   FILENAME(6) character,
   EXT(3) character,
   ATTRIBUTES byte,
   EOF$COUNT byte,
   NO$DATA$BLOCKS word,
   HEADER$BLOCK$PTR word);
dcl COPY$BUFFER(16384) character;
dcl (ACTUAL, STATUS) word;
dcl OUTPUT$DEVICE(5) character initial(':F#: ');
dcl OUTPUT$LIST$INDEX byte;
dcl TEMP$FILE(*) character initial(':F#:TMP.TMP ');

UPPER$CASE: procedure(CHAR) character;
   dcl CHAR character;

   if CHAR >= 'a' and CHAR <= 'z' thenn
      return CHAR - ' ';
   elsee
      return CHAR;
   endif;
endproc UPPER$CASE;

UNPATH: procedure(FILENAME$PTR);
   dcl FILENAME$PTR pointer;
   dcl CHAR1 based FILENAME$PTR character;
   dcl (I,J) byte;
   dcl LOCAL$NAME(11) character;
   dcl STUFF$PTR pointer;

   STUFF$PTR = FILENAME$PTR;
   for I = 0 to last(LOCAL$NAME);
      LOCAL$NAME(I) = 0;
   endfor;
   /* process file part */
   for I = 0 to 5;
      if CHAR1 = '*' thenn
         for J = I to 5;
            LOCAL$NAME(J) = '*';
         endfor;
      elseif CHAR1 = 0 thenn
         go to UNDO;
      elsee
         for J = I to 5;
            LOCAL$NAME(J) = 0;
         endfor;
         LOCAL$NAME(I) = UPPER$CASE(CHAR1);
      endif;
      FILENAME$PTR = FILENAME$PTR + 1;
      if CHAR1 = '.' thenn
         go to UNDO;
      endif;
   endfor;
UNDO:
   if CHAR1 = '.' thenn
      FILENAME$PTR = FILE$NAME$PTR + 1;
   endif;
   if CHAR1 <> 0 thenn
      /* process extension */
      for I = 6 to 8;
         if CHAR1 = '*' thenn
            for J = I to 8;
               LOCAL$NAME(J) = '*';
            endfor;
         elsee
            if CHAR1 <> 0 thenn
               for J = I to 8;
                  LOCAL$NAME(J) = 0;
               endfor;
               LOCAL$NAME(I) = UPPER$CASE(CHAR1);
            endif;
         endif;
         FILENAME$PTR = FILENAME$PTR + 1;
      endfor;
   endif;
   call move(length(LOCAL$NAME), .LOCAL$NAME, STUFF$PTR);
endproc UNPATH;

MATCH$NAME: procedure(PTR1, PTR2) boolean;
   dcl (PTR1, PTR2) pointer;
   dcl CHR1 based PTR1 character;
   dcl CHR2 based PTR2 character;
   dcl I byte;

   for I = 0 to 8;
      if CHR1 <> CHR2 thenn
         if CHR2 = '?' thenn
            if CHR1 = 0 thenn
               return false;
            endif;
         elseif CHR2 <> '*' thenn
            return false;
         endif;
      endif;
      PTR1 = PTR1 + 1;
      PTR2 = PTR2 + 1;
   endfor;
   return true;
endproc MATCH$NAME;

dcl INVISIBLE$ATTR as '01H';
dcl SYSTEM$ATTR as '02H';
dcl WRITE$PROTECT$ATTR as '04H';
dcl FORMAT$ATTR as '80H';

MATCH$ATTRIBUTES: procedure(ATTR, W$ATTR, S$ATTR, I$ATTR) boolean;
   dcl ATTR byte;
   dcl (W$ATTR, S$ATTR, I$ATTR) boolean;

   if (ATTR and FORMAT$ATTR) <> 0 thenn
      return false;
   endif;
   if W$ATTR <> 0 thenn /* it has been set */
      if (W$ATTR xor ((ATTR and WRITE$PROTECT$ATTR) <> 0)) thenn
         return false;
      endif;
   endif;
   if S$ATTR <> 0 thenn
      if (S$ATTR xor ((ATTR and SYSTEM$ATTR) <> 0)) thenn
         return false;
      endif;
   endif;
   if I$ATTR <> 0 thenn
      if (I$ATTR xor ((ATTR and INVISIBLE$ATTR) <> 0)) thenn
         return false;
      endif;
   endif;
   return true;
endproc MATCH$ATTRIBUTES;

REQUIRED$SPACE: procedure(DIR$INDEX) word;
   dcl DIR$INDEX word;
   dcl EOF$BLOCK word;

   if DIR$BUF(DIR$INDEX).EOF$COUNT <> 0 thenn
      EOF$BLOCK = 1;
   elsee
      EOF$BLOCK = 0;
   endif;
   return DIR$BUF(DIR$INDEX).NO$DATA$BLOCKS +
          ((DIR$BUF(DIR$INDEX).NO$DATA$BLOCKS + 61)/62) + EOF$BLOCK;
endproc REQUIRED$SPACE;

TRANSFER$FILE: procedure(FROM$DEVICE$PTR, TO$DEVICE$PTR, NAME$PTR,
                         ATTR$W, ATTR$S, ATTR$I);
   dcl (FROM$DEVICE$PTR, TO$DEVICE$PTR, NAME$PTR) pointer;
   dcl (ATTR$W, ATTR$S, ATTR$I) byte;
   dcl OUT$NAME(15) character;
   dcl IN$NAME(15) character;
   dcl (OUT$AFTN, IN$AFTN) word;
   dcl NAME based NAME$PTR structure(
       FILE(6) character,
       EXT(3) character);
   dcl (I, INDEX) byte;
   dcl (ACTUAL, STATUS) word;
   dcl W$ATTR as '2';
   dcl S$ATTR as '1';
   dcl I$ATTR as '0';
   dcl ON as '1';
   dcl OFF as '0';

   call move(4,FROM$DEVICE$PTR, .IN$NAME);
   call move(4,TO$DEVICE$PTR, .OUT$NAME);
   INDEX = 4;
   for I = 0 to 5;
      if NAME.FILE(I) <> 0 thenn
         IN$NAME(INDEX), OUT$NAME(INDEX) = NAME.FILE(I);
         INDEX = INDEX + 1;
      endif;
   endfor;
   if not(NAME.EXT(0) = 0 or NAME.EXT(0) = ' ') thenn
      IN$NAME(INDEX), OUT$NAME(INDEX) = '.';
      INDEX = INDEX + 1;
      for I = 0 to 2;
         if NAME.EXT(I) <> 0 thenn
            OUT$NAME(INDEX), IN$NAME(INDEX) = NAME.EXT(I);
         elsee
            OUT$NAME(INDEX), IN$NAME(INDEX) = ' ';
         endif;
         INDEX = INDEX + 1;
      endfor;
   endif;
   IN$NAME(INDEX), OUT$NAME(INDEX) = ' ';
   INDEX = INDEX + 1;
   call WRITE(0,.('      '),6,.STATUS);
   call WRITE(0,.IN$NAME, INDEX, .STATUS);
   call WRITE(0,.('               '), (15 - INDEX), .STATUS);
   call OPEN(.IN$AFTN, .IN$NAME, 1, 0, .STATUS);
   if STATUS <> 0 thenn
      call ERROR(STATUS);
      return;
   endif;
   call OPEN(.OUT$AFTN, .OUT$NAME, 2, 0, .STATUS);
   if STATUS <> 0 thenn
      call ERROR(STATUS);
      call CLOSE(IN$AFTN, .STATUS);
      return;
   endif;
   /* copy file */

   call READ(IN$AFTN,.COPY$BUFFER, length(COPY$BUFFER), .ACTUAL, .STATUS);
   if STATUS <> 0 thenn
      call ERROR(STATUS);
      call CLOSE(IN$AFTN, .STATUS);
      call CLOSE(OUT$AFTN,.STATUS);
      return;
   endif;
   whilee ACTUAL <> 0;
      call WRITE(OUT$AFTN, .COPY$BUFFER, ACTUAL, .STATUS);
      if STATUS <> 0 thenn
         call ERROR(STATUS);
         call CLOSE(IN$AFTN, .STATUS);
         call CLOSE(OUT$AFTN,.STATUS);
         return;
      endif;
      if ACTUAL > 1 thenn
         call WRITE(0,.('.....'),(shr(ACTUAL-1, 12)+1),.STATUS);
      elsee
         call WRITE(0,.('.'),1,.STATUS);
      endif;
      call READ(IN$AFTN,.COPY$BUFFER, length(COPY$BUFFER), .ACTUAL, .STATUS);
      if STATUS <> 0 thenn
         call ERROR(STATUS);
         call CLOSE(IN$AFTN, .STATUS);
         call CLOSE(OUT$AFTN,.STATUS);
         return;
      endif;
   endwhile;
   call CLOSE(IN$AFTN, .STATUS);
   call CLOSE(OUT$AFTN,.STATUS);
   /* attribute input file if necessary */
   if ATTR$W <> 0 thenn
      call WRITE(0,.(' W'),2,.STATUS);
      if ATTR$W thenn
         call ATTRIB(.IN$NAME, W$ATTR, ON, .STATUS);
         call WRITE(0,.('1'),1,.STATUS);
      elsee
         call ATTRIB(.IN$NAME, W$ATTR, OFF, .STATUS);
         call WRITE(0,.('0'),1,.STATUS);
      endif;
      if STATUS <> 0 thenn
         call ERROR(STATUS);
      endif;
   endif;
   if ATTR$S <> 0 thenn
      call WRITE(0,.(' S'),2,.STATUS);
      if ATTR$S thenn
         call ATTRIB(.IN$NAME, S$ATTR, ON, .STATUS);
         call WRITE(0,.('1'),1,.STATUS);
      elsee
         call ATTRIB(.IN$NAME, S$ATTR, OFF, .STATUS);
         call WRITE(0,.('0'),1,.STATUS);
      endif;
      if STATUS <> 0 thenn
         call ERROR(STATUS);
      endif;
   endif;
   if ATTR$I <> 0 thenn
      call WRITE(0,.(' I'),2,.STATUS);
      if ATTR$I thenn
         call ATTRIB(.IN$NAME, I$ATTR, ON, .STATUS);
         call WRITE(0,.('1'),1,.STATUS);
      elsee
         call ATTRIB(.IN$NAME, I$ATTR, OFF, .STATUS);
         call WRITE(0,.('0'),1,.STATUS);
      endif;
      if STATUS <> 0 thenn
         call ERROR(STATUS);
      endif;
   endif;
   call WRITE(0,.(CR,LF), 2,.STATUS);
   return;
endproc TRANSFER$FILE;

dcl CHANGE$1$MESSAGE(*) character data(CR,LF,BEL,'CHANGE DISK IN DRIVE ');
dcl CHANGE$MESSAGE(*) character data(CR,LF,BEL,'CHANGE DISKS IN DRIVES ');
dcl CHANGE$MESSAGE$2(*) character
        data(' AND TYPE <ESC> TO LEAVE, <CR> TO CONTINUE');

SWITCH$DISKS: procedure(MAX$LIST, INPUT$NO, OUTPUT$LIST$PTR, SIZE$BOOL);
   dcl SIZE$BOOL boolean;
   dcl MAX$LIST word;
   dcl INPUT$NO character;
   dcl OUTPUT$LIST$PTR pointer;
   dcl OUTPUT$LIST based OUTPUT$LIST$PTR (4) character;
   dcl TEMP$AFTN word;
   dcl STATUS word;
   dcl BLKS(5) word data( 0, 4004, 2002, 2002, 28800);
   dcl ISIS$BLKS(5) word data( 0, 109, 55, 55, 318);
   dcl FILES(5) word data( 0, 196, 196, 196, 988);

   OUTPUT$LIST$INDEX = OUTPUT$LIST$INDEX + 1;
   if OUTPUT$LIST$INDEX > MAX$LIST thenn
      if SIZE$BOOL thenn
         if MAX$LIST = 0 thenn /* only one output device */
            call WRITE(0,.CHANGE$1$MESSAGE, length(CHANGE$1$MESSAGE), .STATUS);
            call WRITE(0,.OUTPUT$LIST(0),1,.STATUS);
         elsee
            call WRITE(0,.CHANGE$MESSAGE, length(CHANGE$MESSAGE),.STATUS);
            call WRITE(0,.OUTPUT$LIST(0),1,.STATUS);
            for OUTPUT$LIST$INDEX = 1 to MAX$LIST - 1;
               call WRITE(0,.(', '),2,.STATUS);
               call WRITE(0,.OUTPUT$LIST(OUTPUT$LIST$INDEX),1,.STATUS);
            endfor;
            call WRITE(0,.(' & '),3,.STATUS);
            call WRITE(0,.OUTPUT$LIST(MAX$LIST),1,.STATUS);
         endif;
         call WRITE(0,.CHANGE$MESSAGE$2, length(CHANGE$MESSAGE$2), .STATUS);
         call READ(1,.COPY$BUFFER,128,.ACTUAL,.STATUS);
         if ACTUAL = 1 thenn
            call WRITE(0,.(CR,LF),2,.STATUS);
            call EXIT;
         endif;
         if MAX$LIST = 0 thenn /* only one output device */
            /* clear ISIS bit-map by opening file on source drive */
            TEMP$FILE(2) = INPUT$NO;
            call OPEN(.TEMP$AFTN, .TEMP$FILE, 2, 0, .STATUS);
            if STATUS <> 0 thenn
               call ERROR(STATUS);
               call EXIT;
            endif;
            call CLOSE(TEMP$AFTN, .STATUS);
            if STATUS <> 0 thenn
               call ERROR(STATUS);
               call EXIT;
            endif;
            call DELETE(.TEMP$FILE, .STATUS);
            if STATUS <> 0 thenn
               call ERROR(STATUS);
               call EXIT;
            endif;
         endif;
      endif;
      OUTPUT$LIST$INDEX = 0;
   endif;
   DIR$NAME.DEVICE(2), OUTPUT$DEVICE(2) = OUTPUT$LIST(OUTPUT$LIST$INDEX);
   call SPATH(.OUTPUT$DEVICE, .SPATH$BLOCK, .STATUS);
   if SPATH$BLOCK.DEV$TYPE = 3 thenn
      MAX$LIMIT = BLKS(SPATH$BLOCK.DRIVE$TYPE);
      ISIS$FILE$BLOCKS = ISIS$BLKS(SPATH$BLOCK.DRIVE$TYPE);
      MAX$FILES = FILES(SPATH$BLOCK.DRIVE$TYPE);
   elsee /* non- disk device */
      MAX$LIMIT = 0FFFFH;
      ISIS$FILE$BLOCKS = 0;
      MAX$FILES = 0FFFFH;
   endif;
   if SIZE$BOOL thenn
      if DELETE$OPTION and (MAX$LIMIT <> 0FFFFH) thenn
         dcl (I, J, K, L, ACTUAL, STATUS) word;
         dcl FILENAME(15) byte;
         call OPEN(.DIR$AFTN, .DIR$NAME, 1, 0, .STATUS);
         if STATUS <> 0 thenn
            call ERROR(STATUS);
            call EXIT;
         endif;
         call WRITE(0, .('DELETING TARGET DISK FILES ...'), 30, .STATUS);
         ACTUAL = 1;
         do while ACTUAL <> 0;
            call MOVE(4, .(':F0:'), .FILENAME);
            TARGET$DIR$BUF(0).PRESENCE = 7FH;
            call READ(DIR$AFTN, .TARGET$DIR$BUF, size(TARGET$DIR$BUF), .ACTUAL, .STATUS);
            if STATUS <> 0 thenn
               call ERROR(STATUS);
               call EXIT;
            endif;
            do I = 0 to 9;
               K = 4;
               if TARGET$DIR$BUF(I).PRESENCE = 7FH thenn
                  goto UNDO;
               endif;
               if TARGET$DIR$BUF(I).PRESENCE = 0 thenn
                  if (TARGET$DIR$BUF(I).ATTRIBUTES and FORMAT$ATTR) = 0 thenn
                     FILENAME(2) = OUTPUT$DEVICE(2);
                     for J = 0 to 5;
                        if TARGET$DIR$BUF(I).FILENAME(J) <> 0 thenn
                           FILENAME(K) = TARGET$DIR$BUF(I).FILENAME(J);
                           K = K + 1;
                        endif;
                     endfor;
                     if TARGET$DIR$BUF(I).EXT(0) <> 0 thenn
                        FILENAME(K) = '.';
                        K = K + 1;
                     endif;
                     for J = 0 to 2;
                        if TARGET$DIR$BUF(I).EXT(J) <> 0 thenn
                           FILENAME(K) = TARGET$DIR$BUF(I).EXT(J);
                           K = K + 1;
                        endif;
                     endfor;
                     FILENAME(K) = ' ';
                     call DELETE(.FILENAME, .STATUS);
                     if STATUS <> 0 thenn
                        call ERROR(STATUS);
                        call EXIT;
                     endif;
                  endif;
               endif;
            enddo;
         enddo;
UNDO:
         call WRITE(0, .(' COMPLETED',CR,LF), 12, .STATUS);
         call CLOSE(DIR$AFTN, .STATUS);
         if STATUS <> 0 thenn
            call ERROR(STATUS);
            call EXIT;
         endif;
      endif;
   endif;
endproc SWITCH$DISKS;

BACKUP$FILES: procedure(BLOCK$PTR) public;
   dcl BLOCK$PTR pointer;
   dcl BLOCK based BLOCK$PTR structure(
      DEVICE(4) character,
      FILENAME(11)character,
      W$ATTR boolean,
      S$ATTR boolean,
      I$ATTR boolean,
      CHANGE$W boolean,
      CHANGE$S boolean,
      CHANGE$I boolean,
      OUTPUT$LIST$ELEMENTS byte,
      OUTPUT$LIST(4) character);
   dcl DIR$INDEX word;
   dcl SPACE$USED word;
   dcl FILE$FOUND boolean;
   dcl FILES$COPIED word;
   dcl DISKS$NEEDED word;
   dcl NUM$BUF(5) character;

   call move(length(DIR$NAME.DEVICE), .BLOCK.DEVICE, .DIR$NAME.DEVICE);
   call SPATH(.DIR$NAME, .SPATH$BLOCK, .STATUS);
   if STATUS <> 0 thenn
      call ERROR(STATUS);
      call EXIT;
   endif;
   if SPATH$BLOCK.DEV$TYPE <> 3 thenn
      call write(0,.('SOURCE DRIVE IS NOT A DISK',CR,LF),33,.STATUS);
      call EXIT;
   endif;
   call OPEN(.DIR$AFTN, .DIR$NAME, 1, 0, .STATUS);
   if STATUS <> 0 thenn
      call ERROR(STATUS);
      call EXIT;
   endif;
   call READ(DIR$AFTN, .DIR$BUF, size(DIR$BUF), .ACTUAL, .STATUS);
   if STATUS <> 0 thenn
      call ERROR(STATUS);
      call EXIT;
   endif;
   call CLOSE(DIR$AFTN, .STATUS);
   call UNPATH(.BLOCK.FILENAME);
   FILE$FOUND = false;
   DISKS$NEEDED, FILES$COPIED, DIR$INDEX = 0;
   SPACE$USED, MAX$LIMIT = 0;
   whilee DIR$BUF(DIR$INDEX).PRESENCE <> 7FH;
      if DIR$BUF(DIR$INDEX).PRESENCE = 0 thenn
         if MATCH$NAME(.DIR$BUF(DIR$INDEX).FILENAME, .BLOCK.FILENAME) and
               MATCH$ATTRIBUTES(DIR$BUF(DIR$INDEX).ATTRIBUTES, BLOCK.W$ATTR,
                                          BLOCK.S$ATTR, BLOCK.I$ATTR) thenn
            FILE$FOUND = true;
            if (REQUIRED$SPACE(DIR$INDEX) + SPACE$USED >= MAX$LIMIT) or
                                 FILES$COPIED >= MAX$FILES thenn
               call SWITCH$DISKS(BLOCK.OUTPUT$LIST$ELEMENTS,
                                 BLOCK.DEVICE(2),
                                 .BLOCK.OUTPUT$LIST, false);
               DISKS$NEEDED = DISKS$NEEDED + 1;
               SPACE$USED = ISIS$FILE$BLOCKS;
               FILES$COPIED = 0;
            endif;
            SPACE$USED = SPACE$USED + REQUIRED$SPACE(DIR$INDEX);
            FILES$COPIED = FILES$COPIED + 1;
         endif;
      endif;
      DIR$INDEX = DIR$INDEX + 1;
   endwhile;
   if not FILE$FOUND thenn
      call ERROR(13);
      call EXIT;
   endif;
   call NUMOUT(DISKS$NEEDED, 10, ' ', .NUM$BUF, 5);
   call WRITE(0,.(CR,LF),2,.STATUS);
   call WRITE(0,.NUM$BUF,5,.STATUS);
   if DISKS$NEEDED = 1 thenn
      call WRITE(0,.(' DISK REQUIRED FOR BACKUP',CR,LF),27,.STATUS);
   elsee
      call WRITE(0,.(' DISKS REQUIRED FOR BACKUP',CR,LF),28,.STATUS);
   endif;
   OUTPUT$LIST$INDEX = 20;
   FILES$COPIED, DIR$INDEX = 0;
   SPACE$USED, MAX$LIMIT = 0;
   whilee DIR$BUF(DIR$INDEX).PRESENCE <> 7FH;
      if DIR$BUF(DIR$INDEX).PRESENCE = 0 thenn
         if MATCH$NAME(.DIR$BUF(DIR$INDEX).FILENAME, .BLOCK.FILENAME) and
               MATCH$ATTRIBUTES(DIR$BUF(DIR$INDEX).ATTRIBUTES, BLOCK.W$ATTR,
                                          BLOCK.S$ATTR, BLOCK.I$ATTR) thenn
            if (REQUIRED$SPACE(DIR$INDEX) + SPACE$USED >= MAX$LIMIT) or
                                 FILES$COPIED >= MAX$FILES thenn
               call SWITCH$DISKS(BLOCK.OUTPUT$LIST$ELEMENTS,
                                 BLOCK.DEVICE(2),
                                 .BLOCK.OUTPUT$LIST, true);
               SPACE$USED = ISIS$FILE$BLOCKS;
               FILES$COPIED = 0;
            endif;
            call TRANSFER$FILE(.BLOCK.DEVICE, .OUTPUT$DEVICE,
                                 .DIR$BUF(DIR$INDEX).FILENAME,
                                 BLOCK.CHANGE$W, BLOCK.CHANGE$S, BLOCK.CHANGE$I);
            SPACE$USED = SPACE$USED + REQUIRED$SPACE(DIR$INDEX);
            FILES$COPIED = FILES$COPIED + 1;
         endif;
      endif;
      DIR$INDEX = DIR$INDEX + 1;
   endwhile;

end BACKUP$FILES;
end BACKUP$DISK$FILES;
src/func.plm
$ TITLE ('==> PASSIF -- FUNCMOD -- PERFORM MAJOR FUNCTIONS <==')

FUNC$MOD:
DO;

/************************************************************************/
/*																		*/
/*      '(C) Intel Corporation 1981'.  All rights reserved.  No			*/
/*      part of this program or publication may be reproduced,			*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

$ NOLIST

/*         LIT.INC          */

DECLARE                 AS LITERALLY 'LITERALLY',              /* plm */
    AMPERSAND           AS '''&''',							   /* ??? */
    BELL                AS '07H',                              /* plm */
    BLANK               AS '020H',                             /* plm */
    BOOLEAN             AS 'BYTE',                             /* plm */
    CHK                 AS 'CALL CHECK$STATUS',	               /* plm */
    CLEAR$CHAR			AS '01CH',							   /* 1510 */
    CO$ECHO$FILE        AS '0F00H',                            /* open */
    COLON               AS ''':''',                            /* char */
    COMMA               AS '02CH',                       	   /* plm */
    CONSOLE$INPUT       AS '1',                                /* open */
    CONSOLE$OUTPUT      AS '0',                                /* open */
    CONTROL$Z           AS '01AH',                             /* plm */
    CR                  AS '0DH',                              /* plm */
    DOT                 AS '''.''',                            /* char */
    END$DO              AS 'END',                              /* plm */
    END$DO$CASE         AS 'END',                              /* plm */
    END$DO$WHILE        AS 'END',                              /* plm */
    END$IF              AS '   ',                              /* plm */
    END$ITERATED$DO		AS 'END',							   /* plm */
    END$LOOP            AS ' ',                                /* plm */
    EOF$CHAR            AS 'CONTROL$Z',                        /* plm */
    ESC                 AS '01BH',                             /* plm */
    FALSE               AS '0H',                               /* plm */
    FF					AS '0CH',							   /* ??? */
    FOREVER             AS 'WHILE 1',                          /* plm */
    FORMAT$ATTRIBUTE	AS '3',								   /* attrib */
    HASH$MARK			AS '''#''',							   /* plm */
    INIT$STG			AS '(*) BYTE INITIAL',				   /* plm */
    LEAD$IN$CHAR		AS '07EH',							   /*1510 */
    LF                  AS '0AH',                              /* plm */
    NO$LINE$EDIT        AS '0',                                /* open */
    NULL				AS '0FFFFH',						   /* ???  */
    OPEN$FOR$READ       AS '1',                                /* open */
    OPEN$FOR$WRITE      AS '2',                                /* open */
    OPEN$FOR$UPDATE		AS '3',								   /* open */
    PUB$STRING			AS '(*) BYTE PUBLIC DATA',             /* plm  */
    RESET				AS '0',								   /* attrib */
    RETURN$MARKER$POS   AS '0',                                /* seek */
    SEEK$2$EOF          AS '4',                                /* seek */
    SEEK$BACKWARD$BY$N  AS '1',                                /* seek */
    SEEK$FORWARD$BY$N	AS '3',								   /* seek */
    SEEK$2$N            AS '2',                                /* seek */
    SEMICOLON			AS ''';''',							   /* plm  */
    SET					AS '1',								   /* attrib */
    STRING              AS '(*) BYTE DATA',                    /* plm  */
    TAB                 AS '09H',                              /* plm */
    TRANSFER$CONTROL    AS '1',                                /* load */
    TRUE                AS '0FFH',                             /* plm */
    UNDERBAR			AS '''_''', 						   /* ??? */
    USER$CI             AS '0',                                /* ??? */
    WRITE$PROTECT$ATTRIBUTE 		AS '2',					   /* attrib */
    ZERO$BIAS           AS '0'                                 /* load */ ;

    /*        ENDLIT.INC        */

$ LIST
$ NOLIST

		/* ISIS.INC */

ATTRIB:
	PROCEDURE(FILE$NAME$PTR,WHICH$ATTRIBUTE,SET$OR$RESET,STATUS$PTR) EXTERNAL;
	DECLARE (FILE$NAME$PTR,WHICH$ATTRIBUTE,SET$OR$RESET,STATUS$PTR) ADDRESS;
	END
ATTRIB;

CLOSE:
	PROCEDURE (AFTN,STATUS) EXTERNAL;
	DECLARE (AFTN,STATUS) ADDRESS;
	END
CLOSE;

CI:
	PROCEDURE BYTE EXTERNAL;
	END
CI;

CO:
	PROCEDURE (CHAR$CO) EXTERNAL;
	DECLARE CHAR$CO BYTE;
	END
CO;

CONSOL:
	PROCEDURE (CONSOLE$INPUT$FILE,CONSOL$OUTPUT$FILE,STATUS$CON) EXTERNAL;
	DECLARE (CONSOLE$INPUT$FILE,CONSOL$OUTPUT$FILE,STATUS$CON) ADDRESS;
	END
CONSOL;

DELETE:
	PROCEDURE (FILE$NAME$PTR,STATUS) EXTERNAL;
	DECLARE (FILE$NAME$PTR,STATUS) ADDRESS;
	END
DELETE;

ERROR:
	PROCEDURE  (ERROR$NUMBER) EXTERNAL;
	DECLARE ERROR$NUMBER ADDRESS;
	END
ERROR;

EXIT:
	PROCEDURE EXTERNAL;
	END
EXIT;

IO$CHK:
	PROCEDURE BYTE EXTERNAL;
	END
IO$CHK;

IO$DEF:
	PROCEDURE (WHICH$DEVICE,ENTRY$POINT) EXTERNAL;
	DECLARE WHICH$DEVICE BYTE,
			ENTRY$POINT ADDRESS;
	END
IO$DEF;

IO$SET:
	PROCEDURE (CONFIGURATION$BYTE) EXTERNAL;
	DECLARE CONFIGURATION$BYTE BYTE;
	END
IO$SET;

LOAD:
	PROCEDURE (FILE,BIAS,CONTROL$OF$TRANSFER,ENTRY$POINT,STATUS) EXTERNAL;
	DECLARE (FILE,BIAS,CONTROL$OF$TRANSFER,ENTRY$POINT,STATUS) ADDRESS;
	END
LOAD;

MEMCK:
	PROCEDURE ADDRESS EXTERNAL;
	END
MEMCK;

OPEN:
	PROCEDURE(AFTN,FILENAME,ACCESS$MODE,LINE$EDIT$AFTN,ERROR) EXTERNAL;
	DECLARE (AFTN,FILENAME,ACCESS$MODE,LINE$EDIT$AFTN,ERROR) ADDRESS;
	END
OPEN;

READ:
	PROCEDURE (AFTN,BUFFER,COUNT,ACTUAL,STATUS) EXTERNAL;
	DECLARE (AFTN,BUFFER,COUNT,ACTUAL,STATUS) ADDRESS;
	END
READ;

RENAME:
	PROCEDURE (OLD$NAME,NEW$NAME,STATUS$R) EXTERNAL;
	DECLARE (OLD$NAME,NEW$NAME,STATUS$R) ADDRESS;
	END
RENAME;

RESCAN:
	PROCEDURE (AFTN,STATUS) EXTERNAL;
	DECLARE (AFTN,STATUS) ADDRESS;
	END
RESCAN;

SEEK:
	PROCEDURE (AFTN,MODE,BLOCKNO,BYTENO,STATUS) EXTERNAL;
	DECLARE (AFTN,MODE,BLOCKNO,BYTENO,STATUS) ADDRESS;
	END
SEEK;

SPATH:
	PROCEDURE (FILE,BUFFER,STATUS) EXTERNAL;
	DECLARE (FILE,BUFFER,STATUS) ADDRESS;
	END
SPATH;

WHOCON:
	PROCEDURE (AFTN,BUFFER) EXTERNAL;
	DECLARE (AFTN,BUFFER) ADDRESS;
	END
WHOCON;

WRITE:
	PROCEDURE (AFTN,BUFFER,COUNT,STATUS) EXTERNAL;
	DECLARE (AFTN,BUFFER,COUNT,STATUS) ADDRESS;
	END
WRITE;

		/* END ISIS.INC */
$ NOLIST

/************************************************************/
/*															*/
/*              LITERALLY'S UNIQUE TO PASSIF                */
/*															*/
/************************************************************/

DECLARE
    MINIMUM$ACCEPTABLE$BANNER$LENGTH 	AS 		'73',
    MAXIMUM$TOKEN$LENGTH				AS		'70',
    BI									AS		'CALL BOMB$IF(STATUS)',

	FIRST$FIELD							AS		'0',
    SECOND$FIELD						AS		'28',
    THIRD$FIELD							AS		'54',

    RIGHT$PARENTHESIS 					AS		''')''',
    LEFT$PARENTHESIS 					AS		'''(''',
    RI									AS		'CALL REPORT$IF',
    UNRECOGNIZED$SWITCH$ERR 			AS		'201',
    QUESTION$MARK						AS		'''?''';

$ LIST
$ NOLIST

/*	MAIN.INC  */

DECLARE
    ACTUAL ADDRESS EXTERNAL,
    AFTN ADDRESS EXTERNAL,
    COMMAND$TAIL$BUF (250) BYTE EXTERNAL,
    DELIMITER BYTE EXTERNAL,
    FIRST$BLOCK$BUF (128) BYTE EXTERNAL,
    FIRST$OUTPUT$MSG$PTR ADDRESS EXTERNAL,
    FIRST$TIME$THROUGH BOOLEAN EXTERNAL,
    INITIALIZED$BANNER (74) BYTE EXTERNAL,
    PRINT$HASH$MARK BOOLEAN EXTERNAL,
    REPORT$FILE$ACTUAL ADDRESS EXTERNAL,
    REPORT$FILE$AFTN ADDRESS EXTERNAL,
    REPORT$FILE$STRING$BEGINNING ADDRESS EXTERNAL,
    SECOND$OUTPUT$MSG$PTR ADDRESS EXTERNAL,
    STATUS ADDRESS EXTERNAL,
    TMP$FILE$AFTN ADDRESS EXTERNAL,
    TMP$FILE$NAME (15) BYTE EXTERNAL,
    TOK$BUF (80) BYTE EXTERNAL;

DECLARE
    KEY$WORDS (10) STRUCTURE
    (LENGTH							BYTE,
    KEY$WORD	(13)				BYTE,
    PROC$PTR						ADDRESS) EXTERNAL;

CO$IS$VO:
	PROCEDURE BOOLEAN EXTERNAL;
	END
CO$IS$VO;

EXIT$ROUTINE:
	PROCEDURE EXTERNAL;
	END
EXIT$ROUTINE;

RE$POSITION$CURSOR:
	PROCEDURE EXTERNAL;
	END
RE$POSITION$CURSOR;

MOVE:
	PROCEDURE (COUNT,SOURCE$PTR,DEST$PTR) EXTERNAL;
	DECLARE (COUNT,SOURCE$PTR,DEST$PTR) ADDRESS;
	END
MOVE;

/*	END MAIN.INC  */
$ LIST
$ NOLIST

/*	TOKENS.INC  */

GET$ARGUMENT:
	PROCEDURE (BUF$PTR,STATUS$PTR) BYTE EXTERNAL;
	DECLARE (BUF$PTR,STATUS$PTR) ADDRESS;
    END
GET$ARGUMENT;

/*	END TOKENS.INC  */
$ LIST
$ NOLIST

/*	ERRMSG.INC  */

DECLARE
	BAD$SYNTAX$MSG 				(29) 				BYTE		EXTERNAL,
	BOMB$IF$MSG$1    			(12) 				BYTE		EXTERNAL,
	BOMB$IF$MSG$2				(40) 				BYTE		EXTERNAL,
    DURING$ASSERTION$CHECK$MSG	(50)				BYTE		EXTERNAL,
    PASSIF$INVOKED$BY$MSG       (19)                BYTE        EXTERNAL,
    ZERO$LENGTH$FILE$MSG 		(40) 				BYTE		EXTERNAL;

/*	END ERRMSG.INC  */
$ LIST
$ NOLIST

/*	CLI.INC  */

DECLARE BUF$COUNT BYTE EXTERNAL;

UDI$STRING$MATCH:
	PROCEDURE (STG$1$PTR,STG$2$PTR) BOOLEAN EXTERNAL;
    DECLARE (STG$1$PTR,STG$2$PTR) ADDRESS;
	END
UDI$STRING$MATCH;

ENFORCE$DELIMITER:
	PROCEDURE(ENFORCEE) EXTERNAL;
	DECLARE ENFORCEE BYTE;
	END
ENFORCE$DELIMITER;

NEXT$ARG:
	PROCEDURE EXTERNAL;
	END
NEXT$ARG;

INTERPRET$COMMAND$LINE:
	PROCEDURE EXTERNAL;
	END
INTERPRET$COMMAND$LINE;

/*	END CLI.INC  */
$ LIST
$ NOLIST

/*	REPORT.INC  */

BOMB$IF:
	PROCEDURE (STATUS) EXTERNAL;
    DECLARE STATUS ADDRESS;
    END
BOMB$IF;

REPORT$SYNTAX$ERROR:
	PROCEDURE EXTERNAL;
	END
REPORT$SYNTAX$ERROR;

REPORT$ISIS$ERROR:
	PROCEDURE (STATUS) EXTERNAL;
	DECLARE STATUS ADDRESS;
	END
REPORT$ISIS$ERROR;

REPORT$ASSERTION$SUCCESS:
	PROCEDURE EXTERNAL;
	END
REPORT$ASSERTION$SUCCESS;

REPORT$ASSERTION$FAILURE:
	PROCEDURE EXTERNAL;
	END
REPORT$ASSERTION$FAILURE;

REPORT$ASSERTION$FAILURE$W$ISIS$ERR:
	PROCEDURE (STATUS) EXTERNAL;
	DECLARE STATUS ADDRESS;
    END
REPORT$ASSERTION$FAILURE$W$ISIS$ERR;

REPORT$ASSERTION$FAILURE$W$MSG:
	PROCEDURE (OLD$STYLE$MSG$PTR) EXTERNAL;
	DECLARE OLD$STYLE$MSG$PTR ADDRESS;
    END
REPORT$ASSERTION$FAILURE$W$MSG;

MSG$LENGTH:
	PROCEDURE (OLD$STYLE$MSG$PTR) BYTE EXTERNAL;
    DECLARE OLD$STYLE$MSG$PTR ADDRESS;
	END
MSG$LENGTH;

/*	END REPORT.INC  */
$ LIST

/************************************************************/
/*															*/
/*      PROCEDURES   PERFORMING   PASSIF   FUNCTIONS        */
/*															*/
/************************************************************/

/************************************************************/
/*															*/
/*                        NOTES                             */
/*															*/
/************************************************************/

/*

1.	The token ri is a "literal" abbreviation of "call report$if",
	which will call "report$assertion$failure$w$isis$err" if
	status does not equal 0.

*/

$ EJECT

/************************************************************/
/*															*/
/*                   LOCAL VARIABLES                        */
/*															*/
/************************************************************/

DECLARE (THE$STRING$WAS$FOUND,THE$STRING$SHOULD$BE$THERE) BOOLEAN;

$ EJECT

/************************************************************/
/*															*/
/*                   LOCAL PROCEDURES                       */
/*															*/
/************************************************************/

REPORT$IF:
	PROCEDURE;
	IF STATUS<>0 THEN
		CALL REPORT$ASSERTION$FAILURE$W$ISIS$ERR(STATUS);
	END$IF
	END
REPORT$IF;

$ EJECT

/************************************************************/
/*															*/
/*                     FILE$EXISTS                          */
/*															*/
/************************************************************/

FILE$EXISTS:
	PROCEDURE PUBLIC;

	CALL NEXT$ARG;
	CALL ENFORCE$DELIMITER(RIGHT$PARENTHESIS);

	CALL OPEN(.AFTN,.TOK$BUF(1),OPEN$FOR$READ,NO$LINE$EDIT,.STATUS);
    IF STATUS=13 THEN
    	CALL REPORT$ASSERTION$FAILURE;
    ELSE IF STATUS<>0 THEN
        CALL REPORT$ASSERTION$FAILURE$W$ISIS$ERR(STATUS);
    ELSE
    	DO;
			/*	See whether file is of zero length. */
			DECLARE SOME$SPACE BYTE;
            CALL READ(AFTN,.SOME$SPACE,SIZE(SOME$SPACE),.ACTUAL,.STATUS); RI;
            IF ACTUAL=0 THEN
                CALL REPORT$ASSERTION$FAILURE$W$MSG(.ZERO$LENGTH$FILE$MSG);
			ELSE
				CALL REPORT$ASSERTION$SUCCESS;
            END$IF
        ENDDO;
    END$IF

	END
FILE$EXISTS;

$ EJECT

/************************************************************/
/*															*/
/*                    FILE$ABSENT                           */
/*															*/
/************************************************************/

FILE$ABSENT:
	PROCEDURE PUBLIC;

    CALL NEXT$ARG;
    CALL ENFORCE$DELIMITER(RIGHT$PARENTHESIS);

    CALL OPEN(.AFTN,.TOK$BUF(1),OPEN$FOR$READ,NO$LINE$EDIT,.STATUS);
    IF STATUS=13 THEN
    	CALL REPORT$ASSERTION$SUCCESS;
	ELSE IF STATUS<>0 THEN
		CALL REPORT$ASSERTION$FAILURE$W$ISIS$ERR(STATUS);
    ELSE
    	CALL REPORT$ASSERTION$FAILURE;
    END$IF

	END
FILE$ABSENT;

$ EJECT

/************************************************************/
/*															*/
/*                    FILES$MATCH                           */
/*															*/
/************************************************************/

FILES$MATCH:
	PROCEDURE PUBLIC;

	DECLARE (AFTN$1,AFTN$2) ADDRESS;
    DECLARE (ACTUAL$1,ACTUAL$2) ADDRESS;

    DECLARE BUF$SIZ ADDRESS;

    DECLARE (BUF$1$BOT,BUF$1$TOP,BUF$2$BOT,BUF$2$TOP) ADDRESS;

    DECLARE (BUF$1$PTR,BUF$2$PTR) ADDRESS;
    DECLARE  BUF$1$BYTE BASED BUF$1$PTR BYTE,
    		 BUF$2$BYTE BASED BUF$2$PTR BYTE;

    /*	Pick up the first filename. */
	CALL NEXT$ARG;
	CALL ENFORCE$DELIMITER(COMMA);

    /*	Open it. */
	CALL OPEN(.AFTN$1,.TOK$BUF(1),OPEN$FOR$READ,NO$LINE$EDIT,.STATUS); RI;

    /*	Pick up the second filename. */
    CALL NEXT$ARG;
	CALL ENFORCE$DELIMITER(RIGHT$PARENTHESIS);

    /* Open it. */
    CALL OPEN(.AFTN$2,.TOK$BUF(1),OPEN$FOR$READ,NO$LINE$EDIT,.STATUS); RI;

    /*	Allocate buffers in free memory. */
	BUF$SIZ = ((MEM$CK-.MEMORY)/256) * 128;

    BUF$1$BOT = .MEMORY;
    BUF$1$TOP = .MEMORY + BUF$SIZ - 1;

    BUF$2$BOT = BUF$1$TOP + 1;
    BUF$2$TOP = BUF$2$BOT + BUF$SIZ - 1;

	/*	Now, compare the files. */

    /*	B E G I N N I N G   O F   C O M P A R I S O N   L O O P. */

	begin$loop:
        CALL READ(AFTN$1,BUF$1$BOT,BUF$SIZ,.ACTUAL$1,.STATUS);
        CALL REPORT$ISIS$ERROR(STATUS);

        CALL READ(AFTN$2,BUF$2$BOT,BUF$SIZ,.ACTUAL$2,.STATUS);
        CALL REPORT$ISIS$ERROR(STATUS);

        /*	Perform fast check which may spot mismatched files. */
        IF ACTUAL$1 <> ACTUAL$2 THEN
            CALL REPORT$ASSERTION$FAILURE;
        END$IF

        BUF$1$PTR = BUF$1$BOT;
    	BUF$2$PTR = BUF$2$BOT;

		DO WHILE BUF$1$PTR < BUF$1$BOT+ACTUAL$1;
			IF BUF$1$BYTE <> BUF$2$BYTE THEN
				CALL REPORT$ASSERTION$FAILURE;
        	END$IF
        	BUF$1$PTR = BUF$1$PTR + 1;
            BUF$2$PTR = BUF$2$PTR + 1;
        END$DO$WHILE;

        IF ACTUAL$1=BUF$SIZ THEN
        	/*	There may be more bytes to compare. */
            GOTO begin$loop;
        ELSE
        	/*	The comparison was successful. */
            CALL REPORT$ASSERTION$SUCCESS;
        END$IF
	end$loop

    /*	E N D   O F   C O M P A R I S O N   L O O P. */

    END
FILES$MATCH;

$ EJECT

/************************************************************/
/*															*/
/*                  STRING$IS$IN$FILE                       */
/*															*/
/************************************************************/

STRING$IS$IN$FILE:
	PROCEDURE;
	DECLARE STRING$BUF (85) BYTE;
	DECLARE STRING$LENGTH BYTE AT (.STRING$BUF(0));
    DECLARE FIRST$STRING$CHARACTER BYTE AT (.STRING$BUF(1));

    DECLARE IN$TOKEN STRING (2,'IN');
    DECLARE FILE$TOKEN STRING(4,'FILE');

    DECLARE (BUF$BOT,BUF$TOP) ADDRESS;
    DECLARE BUF$PTR ADDRESS,
    		BUF$CHAR BASED BUF$PTR (100) BYTE;

    DECLARE BYTES$LEFT$IN$BUFFER ADDRESS;
	DECLARE BUF$SIZ ADDRESS;
	DECLARE DONT$START$SEARCH$PAST$HERE ADDRESS;

$ EJECT

    /************************************************************/
    /*															*/
    /*           PROCEDURES LOCAL TO STRING$IS$IN$FILE          */
    /*															*/
    /************************************************************/

	PERFORM$FANCY$BUFFER$REFRESH:
		PROCEDURE;

		/*	The reason for the adjective "fancy" is because,
			before any more reading is done, the text currently
			left in the buffer is moved down to the bottom of
			the buffer, and more text is appended above it.
			We don't have to worry about the text destination
			area overlapping the text source area because the
			text source and destination areas are at the top and
			bottom of the i/o buffer area, respectively;  cannot
			exceed 80 bytes each, and the i/o buffer area is huge.

            After moving the block of text, the variables controlling
            the string matching and buffering are modified so that
            the string matching algorithim begins at the bottom of
            the buffer, and searches the chunk of text which was at
            the top.*/

		DECLARE TMP$ACTUAL ADDRESS;
		DECLARE TMP$COUNT ADDRESS;

        BYTES$LEFT$IN$BUFFER = STRING$LENGTH - 1;

        CALL MOVE(/*count*/			BYTES$LEFT$IN$BUFFER           ,
        		  /*source*/		(DONT$START$SEARCH$PAST$HERE+1),
        		  /*destination*/	BUF$BOT             )          ;

		TMP$COUNT = BUF$SIZ - BYTES$LEFT$IN$BUFFER;

        CALL READ(AFTN,
                 (BUF$BOT+BYTES$LEFT$IN$BUFFER),
                  TMP$COUNT,
                 .TMP$ACTUAL,
                 .STATUS);

        CALL REPORT$ISIS$ERROR(STATUS);

		/*	Now, modify the "search-controlling" to restart the search at
			the bottom of the buffer. */
		ACTUAL  = TMP$ACTUAL + BYTES$LEFT$IN$BUFFER;

		END
    PERFORM$FANCY$BUFFER$REFRESH;

    REPORT$ASSERTION$VERDICT:
    	PROCEDURE (THE$STRING$WAS$FOUND);
        DECLARE THE$STRING$WAS$FOUND BOOLEAN;

        IF NOT (THE$STRING$WAS$FOUND xor THE$STRING$SHOULD$BE$THERE) THEN
			CALL REPORT$ASSERTION$SUCCESS;
        ELSE
        	CALL REPORT$ASSERTION$FAILURE;
        END$IF
    	END
    REPORT$ASSERTION$VERDICT;

    STRING$MATCH$W$BUF:
		PROCEDURE;

		/*	This procedure is the only way to get a positive verdict
			on string matching.  There are many ways to get a negative
			verdict.

			This procedure is attempting to match a UDI string with a
			vanilla string, so the indices of the two strings in the
			matching loop below will be off by one.

        	We can start the string comparison checking at the second
        	byte because the code which calls this procedure has already
        	checked the first byte. */

        DECLARE INDEX BYTE;

        DO INDEX=1 TO STRING$LENGTH-1;
			IF STRING$BUF(INDEX+1)<>BUF$CHAR(INDEX) THEN
				RETURN;
            END$IF
        END$DO$WHILE;

        CALL REPORT$ASSERTION$VERDICT(TRUE);
        END
    STRING$MATCH$W$BUF;

    NORMAL$FILE$READ:
		PROCEDURE;
		CALL READ(AFTN,BUF$BOT,BUF$SIZ,.ACTUAL,.STATUS); RI;
		END
    NORMAL$FILE$READ;

    THERE$PROBABLY$IS$MORE$TEXT:
        PROCEDURE BOOLEAN;
            RETURN ACTUAL=BUF$SIZ;
        END
    THERE$PROBABLY$IS$MORE$TEXT;

$ EJECT

    /************************************************************/
    /*															*/
    /*           FIRST EXECUTABLE IN STRING$IS$IN$FILE          */
    /*															*/
    /************************************************************/

    /*	Grab the string. */
    CALL NEXT$ARG;
	CALL ENFORCE$DELIMITER(RIGHT$PARENTHESIS);

    /*	Move string to local buffer. */
    CALL MOVE(/*count*/				TOK$BUF(0)+1,
    		  /*source*/			.TOK$BUF(0),
    		  /*destination*/		.STRING$BUF);

	/*	Look for the "in". */
    CALL NEXT$ARG;
	CALL ENFORCE$DELIMITER(BLANK);
	IF NOT UDI$STRING$MATCH(.IN$TOKEN,.TOK$BUF) THEN
		CALL REPORT$ASSERTION$FAILURE$W$MSG(.BAD$SYNTAX$MSG);
    END$IF

	/*	Look for the "file". */
	CALL NEXT$ARG;
	CALL ENFORCE$DELIMITER(LEFT$PARENTHESIS);
    IF NOT UDI$STRING$MATCH(.FILE$TOKEN,.TOK$BUF) THEN
		CALL REPORT$ASSERTION$FAILURE$W$MSG(.BAD$SYNTAX$MSG);
    END$IF

	/*	Grab filename. */
	CALL NEXT$ARG;
	CALL ENFORCE$DELIMITER(RIGHT$PARENTHESIS);

    /*	Open file. */
    CALL OPEN(.AFTN,.TOK$BUF(1),OPEN$FOR$READ,NO$LINE$EDIT,.STATUS);
    CALL REPORT$ISIS$ERROR(STATUS);

    /*	Allocate buffers in free memory. */
	BUF$SIZ = ((MEM$CK-.MEMORY)/128)*128;
    BUF$BOT = .MEMORY;
    BUF$TOP = BUF$BOT + BUF$SIZ - 1;
	BUF$PTR = BUF$BOT;

$ EJECT

    /************************************************************/
    /*															*/
    /*                MAIN LOOP OF STRING$IS$IN$FILE            */
    /*															*/
    /************************************************************/

    /*	read in file. */
    CALL NORMAL$FILE$READ;

    continue$string$search:
        DONT$START$SEARCH$PAST$HERE = BUF$BOT + ACTUAL - STRING$LENGTH;

            /**************************************************/
            /*												  */
            /*	HERE FOLLOWS THE "SUB-LOOP" OF THE MAIN LOOP  */
            /*												  */
            /**************************************************/

            DO BUF$PTR = BUF$BOT TO DONT$START$SEARCH$PAST$HERE;
                IF BUF$CHAR(0) = FIRST$STRING$CHARACTER THEN
                    CALL STRING$MATCH$W$BUF;
                END$IF
            END$ITERATED$DO;

        IF THERE$PROBABLY$IS$MORE$TEXT THEN
        	DO;
        		CALL PERFORM$FANCY$BUFFER$REFRESH;
        		GOTO continue$string$search;
        	ENDDO;
        ELSE
            CALL REPORT$ASSERTION$VERDICT(FALSE);
        END$IF
	end$loop

	/*	The code should never get this far.  If text is exhausted, then
		the procedure which discovers that fact will call the procedure
		report$assertion$verdict, which will report the fact, and not
        return.  If the string matches, then, similarly, the string
        match procedure will call report$assertion$verdict, which will
        not return. */

    END
STRING$IS$IN$FILE;

$ EJECT

/************************************************************/
/*															*/
/*                  STRING$FOUND                            */
/*															*/
/************************************************************/

STRING$FOUND:
	PROCEDURE PUBLIC;
	THE$STRING$SHOULD$BE$THERE = TRUE;
    CALL STRING$IS$IN$FILE;
	END
STRING$FOUND;

/************************************************************/
/*															*/
/*                    STRING$ABSENT                         */
/*															*/
/************************************************************/

STRING$ABSENT:
	PROCEDURE PUBLIC;
	THE$STRING$SHOULD$BE$THERE = FALSE;
    CALL STRING$IS$IN$FILE;
	END
STRING$ABSENT;

END
FUNC$MOD;
src/ganef.plm
GANEF: DO;


/************************************************************************/
/*																		*/
/*      '(C) Intel Corporation 1981'.  All rights reserved.  No			*/
/*      part of this program or publication may be reproduced,			*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

      
DECLARE COPYRIGHT (*) BYTE DATA ('(C) INTEL CORP 1981');

DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.0',0);
    

DECLARE /* SPECIAL ASCII CHARACTERS */
  LF LITERALLY '0AH',
  CR LITERALLY '0DH',
  ESC LITERALLY '1BH';

DECLARE /* COMMON BOOLEAN DECLARATIONS */
  BOOLEAN LITERALLY 'BYTE',
  TRUE LITERALLY '0FFH',
  FALSE LITERALLY '00H';

DECLARE /* DEFAULT ISIS I/O DEVICES */
  CO$AFTN       LITERALLY '0',
  CI$AFTN       LITERALLY '1';

DECLARE /* DEVICE ACCESS MODES FOR OPEN */
  OPEN$READ     LITERALLY '1',
  OPEN$WRITE    LITERALLY '2',
  OPEN$UPDATE   LITERALLY '3';

DECLARE /* SEEK MODES FOR SEEK */
  SEEK$RETURN   LITERALLY '0',
  SEEK$BACK     LITERALLY '1',
  SEEK$ABS      LITERALLY '2',
  SEEK$FORWARD  LITERALLY '3',
  SEEK$EOF      LITERALLY '4';

OPEN:
  PROCEDURE (AFT, FILE, ACCESS, MODE, STATUS) EXTERNAL;
    DECLARE (AFT, FILE, ACCESS, MODE, STATUS) ADDRESS;
  END OPEN;

READ:
  PROCEDURE (AFT, BUFFER, COUNT, ACTUAL, STATUS) EXTERNAL;
    DECLARE (AFT, BUFFER, COUNT, ACTUAL, STATUS) ADDRESS;
  END READ;

WRITE:
  PROCEDURE (AFT, BUFFER, COUNT, STATUS) EXTERNAL;
    DECLARE (AFT, BUFFER, COUNT, STATUS) ADDRESS;
  END WRITE;

SEEK:
  PROCEDURE (AFT, MODE, BLOCKNUM, BYTENUM, STATUS) EXTERNAL;
    DECLARE (AFT, MODE, BLOCKNUM, BYTENUM, STATUS) ADDRESS;
  END SEEK;

RESCAN:
  PROCEDURE (AFT, STATUS) EXTERNAL;
    DECLARE (AFT, STATUS) ADDRESS;
  END RESCAN;

CLOSE:
  PROCEDURE (AFT, STATUS) EXTERNAL;
    DECLARE (AFT, STATUS) ADDRESS;
  END CLOSE;

SPATH:
  PROCEDURE (FILE, BUFFER, STATUS) EXTERNAL;
    DECLARE (FILE, BUFFER, STATUS) ADDRESS;
  END SPATH;

EXIT:
  PROCEDURE EXTERNAL;
  END EXIT;

ABSIO: PROCEDURE (COMMAND, DISK, BLOCK, BUFFER$PTR) EXTERNAL;
  DECLARE (COMMAND, DISK) BYTE;
  DECLARE (BLOCK, BUFFER$PTR) ADDRESS;
END;

NUMOUT: PROCEDURE (VALUE, BASE, LC, BUFADR, WIDTH) EXTERNAL;
  DECLARE (VALUE, BUFADR) ADDRESS;
  DECLARE (BASE, LC, WIDTH) BYTE;
END;

DEBLANK: PROCEDURE (PTR) ADDRESS EXTERNAL;
  DECLARE (PTR) ADDRESS;
END;

DELIMIT: PROCEDURE (PTR) ADDRESS EXTERNAL;
  DECLARE (PTR) ADDRESS;
END;

FILE$ERROR: PROCEDURE (STATUS, PTR, CALLEXIT) EXTERNAL;
  DECLARE (STATUS, PTR) ADDRESS;
  DECLARE (CALLEXIT) BOOLEAN;
END;

SCAN$INTEGER: PROCEDURE (PTR$PTR) ADDRESS EXTERNAL;
  DECLARE (PTR$PTR) ADDRESS;
END;

FORCE$UPPER: PROCEDURE (BUFFER) EXTERNAL;
  DECLARE (BUFFER) ADDRESS;
END;

DECLARE DISK$READ LITERALLY '4';
DECLARE DISK$WRITE LITERALLY '6';
DECLARE (ACTUAL, STATUS) ADDRESS;
DECLARE (DISK, DISK$LAST$READ, FROM$DISK, TO$DISK, MARK$DISK) BYTE;
DECLARE (I, BLOCK, TRACK, SECTOR, TRACK$LAST$READ, SECTOR$LAST$READ,
  MARK$TRACK, MARK$SECTOR) ADDRESS;
DECLARE PN$BLOCK STRUCTURE (DEVICE$NO BYTE, NAME (6) BYTE, EXT (3) BYTE,
  DEVICE$TYPE BYTE, DRIVE$TYPE BYTE);
DECLARE PARM (3) ADDRESS;
DECLARE (OFFSET, OFFSET1) ADDRESS;
DECLARE (BLANKS) (4) BYTE DATA ('    ');
DECLARE STR (5) BYTE;
DECLARE BUFFER (128) BYTE;
DECLARE HEADER$BUFFER (64) ADDRESS;
DECLARE COMMAND (128) BYTE;
DECLARE CMND$PTR ADDRESS, CMND BASED CMND$PTR BYTE;
DECLARE RESTART LABEL;

WRITE$CO: PROCEDURE (STR, LEN);
  DECLARE (STR, LEN) ADDRESS;

  CALL WRITE (CO$AFTN, STR, LEN, .STATUS);
END;

WRITE$CRLF: PROCEDURE;
  CALL WRITE$CO (.(CR, LF), 2);
END;

WRITE$CO$CRLF: PROCEDURE (STR, LEN);
  DECLARE (STR, LEN) ADDRESS;

  CALL WRITE$CO (STR, LEN);
  CALL WRITE$CRLF;
END;

GET$COMMAND: PROCEDURE;
  CALL READ (CI$AFTN, .COMMAND, LENGTH (COMMAND), .ACTUAL, .STATUS);
  CALL FORCE$UPPER (.COMMAND);
  CMND$PTR = .COMMAND;
END GET$COMMAND;

CMND$ERROR: PROCEDURE;
  CALL WRITE$CO (.COMMAND, 1);
  CALL WRITE$CO$CRLF (.(' COMMAND FORMAT ERROR'), 21);
  GOTO RESTART;
END;

PARSE$BLOCK$NO: PROCEDURE;
  PARM (0) = TRACK;
  PARM (1) = SECTOR;
  PARM (2) = 0FFH;
  I = 0;
  CMND$PTR = DEBLANK (CMND$PTR + 1);
  DO WHILE CMND <> CR;
    IF I > 2 THEN
      CALL CMND$ERROR;
    IF CMND = '-' THEN
      CMND$PTR = CMND$PTR + 1;
    ELSE
      PARM (I) = SCAN$INTEGER (.CMND$PTR);
    I = I + 1;
    CMND$PTR = DEBLANK (CMND$PTR);
  END;
  IF PARM (2) <> 0FFH THEN
    IF PARM (2) > 9 THEN
      CALL CMND$ERROR;
  TRACK = PARM (0);
  SECTOR = PARM (1);
  DISK = PARM (2);
END;

DISPLAY$BLOCK$NO: PROCEDURE;
  CALL WRITE$CO (.('TRACK='), 6);
  CALL NUMOUT (TRACK, 10, ' ', .STR, 3);
  STR (3) = ' ';
  CALL WRITE$CO (.STR, 4);
  CALL NUMOUT (TRACK, 16, '0', .STR (1), 2);
  STR (0) = '(';
  CALL WRITE$CO (.STR, 3);
  CALL WRITE$CO (.('H), SECTOR='), 11);
  CALL NUMOUT (SECTOR, 10, ' ', .STR, 3);
  STR (3) = ' ';
  CALL WRITE$CO (.STR, 4);
  CALL NUMOUT (SECTOR, 16, '0', .STR (1), 2);
  STR (0) = '(';
  CALL WRITE$CO (.STR, 3);
  CALL WRITE$CO (.('H), DISK= '), 10);
  STR (0) = DISK + '0';
  CALL WRITE$CO (.STR, 1);
END;

DISPLAY$BUFFER: PROCEDURE;
  CALL DISPLAY$BLOCK$NO;
  CALL WRITE$CO$CRLF (.(CR, LF,
  '      0  1  2  3  4  5  6  7   8  9  A  B  C  D  E  F    0123456789ABCDEF'),
    75);
  OFFSET = 0;
  DO WHILE OFFSET < 128;
    CALL NUMOUT (OFFSET, 16, '0', .STR, 4);
    CALL WRITE$CO (.STR, 4);
    STR (0) = ' ';
    DO OFFSET1 = 0 TO 15;
      CALL NUMOUT (BUFFER (OFFSET + OFFSET1), 16, '0', .STR (1), 2);
      CALL WRITE$CO (.STR, 3);
      IF OFFSET1 = 7 THEN
        CALL WRITE$CO (.BLANKS, 1);
    END;
    CALL WRITE$CO (.BLANKS, 4);
    DO OFFSET1 = 0 TO 15;
      IF (BUFFER (OFFSET + OFFSET1) >= ' ') AND (BUFFER (OFFSET + OFFSET1) <=
          126) THEN
        CALL WRITE$CO (.BUFFER (OFFSET + OFFSET1), 1);
      ELSE
        CALL WRITE$CO (.('.'), 1);
    END;
    CALL WRITE$CRLF;
    OFFSET = OFFSET + 16;
  END;
END;

INVALID$BLOCK$NO: PROCEDURE BOOLEAN;
  DECLARE FILE$NAME$TEMPLATE (15) BYTE DATA (':F0:GANEF.TMP  ');
  DECLARE FILE$NAME (15) BYTE;

  IF DISK > 9 THEN
    RETURN TRUE;
  CALL MOVE (LENGTH (FILE$NAME), .FILE$NAME$TEMPLATE, .FILE$NAME);
  FILE$NAME (2) = DISK + '0';
  CALL SPATH (.FILE$NAME, .PN$BLOCK, .STATUS);
  IF STATUS <> 0 THEN
    RETURN TRUE;
  IF PN$BLOCK.DRIVE$TYPE = 0 THEN
    RETURN TRUE;
  IF SECTOR < 1 THEN
    RETURN TRUE;
  IF PN$BLOCK.DRIVE$TYPE < 4 THEN
  DO;  /* FLOPPY DRIVE */
    IF TRACK > 76 THEN
      RETURN TRUE;
    IF PN$BLOCK.DRIVE$TYPE = 1 THEN
    DO;  /* DOUBLE DENSITY FLOPPY DRIVE */
      IF SECTOR > 52 THEN
        RETURN TRUE;
    END;
    ELSE
    DO;  /* SINGLE DENSITY FLOPPY DRIVE */
      IF SECTOR > 26 THEN
        RETURN TRUE;
    END;
  END;
  ELSE IF PN$BLOCK.DRIVE$TYPE = 4 THEN
  DO;  /* 5440 HARD DISK DRIVE */
    IF TRACK > 199 THEN
      RETURN TRUE;
    IF SECTOR > 144 THEN
      RETURN TRUE;
  END;
  RETURN FALSE;
END;

VERIFY$BLOCK$NO: PROCEDURE;
  IF INVALID$BLOCK$NO THEN
  DO;
    IF STATUS <> 0 THEN
      CALL WRITE$CO (.('INTERNAL ERROR: '), 16);
    ELSE
    DO;
      IF PN$BLOCK.DRIVE$TYPE = 0 THEN
        CALL WRITE$CO (.('NO CONTROLLER FOR DRIVE: '), 24);
      ELSE
        CALL WRITE$CO (.('INVALID BLOCK NO: '), 18);
    END;
    CALL DISPLAY$BLOCK$NO;
    CALL WRITE$CRLF;
    GOTO RESTART;
  END;
END;

READ$AND$DISPLAY$SECTOR: PROCEDURE;
  CALL VERIFY$BLOCK$NO;
  CALL ABSIO (DISK$READ, DISK, SHL (TRACK, 8) + SECTOR, .BUFFER);
  CALL DISPLAY$BUFFER;
  DISK$LAST$READ = DISK;
  TRACK$LAST$READ = TRACK;
  SECTOR$LAST$READ = SECTOR;
END;

DISPLAY$SECTOR: PROCEDURE;
  CALL PARSE$BLOCK$NO;
  IF DISK = 0FFH THEN
    DISK = FROM$DISK;
  CALL READ$AND$DISPLAY$SECTOR;
END;

DISPLAY$NEXT$SECTOR: PROCEDURE;
  IF TRACK$LAST$READ = -1 THEN
  DO;
    CALL WRITE$CO$CRLF (.('NO SECTORS BEEN READ YET'), 24);
    GOTO RESTART;
  END;
  DISK = DISK$LAST$READ;
  TRACK = TRACK$LAST$READ;
  SECTOR = SECTOR$LAST$READ + 1;
  IF INVALID$BLOCK$NO THEN
  DO;
    TRACK = TRACK + 1;
    SECTOR = 1;
  END;
  CALL READ$AND$DISPLAY$SECTOR;
END;

WRITE$SECTOR: PROCEDURE;
  CMND$PTR = DEBLANK (CMND$PTR + 1);
  IF CMND = CR THEN
  DO;
    CALL WRITE$CO (.('WRITE TO '), 9);
    CALL DISPLAY$BLOCK$NO;
    CALL WRITE$CO (.(' ? '), 3);
    CALL GET$COMMAND;
    IF CMND <> 'Y' THEN
      GOTO RESTART;
  END;
  ELSE
  DO;
    CMND$PTR = .COMMAND;
    CALL PARSE$BLOCK$NO;
    IF DISK = 0FFH THEN
      DISK = TO$DISK;
  END;
  CALL VERIFY$BLOCK$NO;
  CALL ABSIO (DISK$WRITE, DISK, SHL (TRACK, 8) + SECTOR, .BUFFER);
END;

MARK$BLOCK$NO: PROCEDURE;
  CALL PARSE$BLOCK$NO;
  IF DISK = 0FFH THEN
    DISK = FROM$DISK;
  CALL VERIFY$BLOCK$NO;
  MARK$DISK = DISK;
  MARK$TRACK = TRACK;
  MARK$SECTOR = SECTOR;
END;

RECALL$BLOCK$NO: PROCEDURE;
  CMND$PTR = DEBLANK (CMND$PTR + 1);
  IF CMND <> CR THEN
    CALL CMND$ERROR;
  IF MARK$TRACK = -1 THEN
  DO;
    CALL WRITE$CO$CRLF (.('NO SECTOR HAS BEEN MARKED YET'), 29);
    GOTO RESTART;
  END;
  DISK = MARK$DISK;
  TRACK = MARK$TRACK;
  SECTOR = MARK$SECTOR;
  CALL READ$AND$DISPLAY$SECTOR;
END;

ASSIGN$DISK: PROCEDURE;
  CMND$PTR = DEBLANK (CMND$PTR + 1);
  PARM (0) = FROM$DISK;
  PARM (1) = TO$DISK;
  DO WHILE CMND <> CR;
    IF CMND = 'R' THEN
    DO;
      CMND$PTR = DEBLANK (CMND$PTR + 1);
      IF CMND <> '=' THEN
        CALL CMND$ERROR;
      CMND$PTR = DEBLANK (CMND$PTR + 1);
      PARM (0) = SCAN$INTEGER (.CMND$PTR);
      CMND$PTR = DEBLANK (CMND$PTR);
    END;
    ELSE IF CMND = 'W' THEN
    DO;
      CMND$PTR = DEBLANK (CMND$PTR + 1);
      IF CMND <> '=' THEN
        CALL CMND$ERROR;
      CMND$PTR = DEBLANK (CMND$PTR + 1);
      PARM (1) = SCAN$INTEGER (.CMND$PTR);
      CMND$PTR = DEBLANK (CMND$PTR);
    END;
    ELSE
      CALL CMND$ERROR;
  END;
  IF (PARM (0) > 9) OR (PARM (1) > 9) THEN
    CALL CMND$ERROR;
  FROM$DISK = PARM (0);
  TO$DISK = PARM (1);
  CALL WRITE$CO (.('READING FROM DRIVE '), 19);
  STR (0) = FROM$DISK + '0';
  CALL WRITE$CO (.STR, 1);
  CALL WRITE$CO (.(', WRITING TO DRIVE '), 19);
  STR (0) = TO$DISK + '0';
  CALL WRITE$CO$CRLF (.STR, 1);
END;

SUBSTITUTE$BUFFER: PROCEDURE;
  CMND$PTR = DEBLANK (CMND$PTR + 1);
  OFFSET = SCAN$INTEGER (.CMND$PTR);
  CMND$PTR = DEBLANK (CMND$PTR);
  IF CMND <> CR THEN
    CALL CMND$ERROR;
  IF OFFSET > 127 THEN
    CALL CMND$ERROR;
  CALL WRITE$CO$CRLF (.('TYPE INPUT IN HEX OR ASCII STRING'), 33);
  DO WHILE CMND <> ESC;
    CALL NUMOUT (OFFSET, 16, '0', .STR, 4);
    CALL WRITE$CO (.STR, 4);
    CALL NUMOUT (BUFFER (OFFSET), 16, '0', .STR (1), 2);
    STR (0) = ' ';
    STR (3) = '-';
    CALL WRITE$CO (.STR, 4);
    CALL GET$COMMAND;
    CMND$PTR = DEBLANK (CMND$PTR);
    IF CMND = CR THEN
    DO;
      OFFSET = OFFSET + 1;
      IF OFFSET > 127 THEN
        OFFSET = 0;
    END;
    DO WHILE (CMND <> ESC) AND (CMND <> CR);
      IF CMND = '''' THEN
      DO;
        CMND$PTR = CMND$PTR + 1;
        DO WHILE (CMND <> '''') AND (CMND <> CR) AND (CMND <> ESC);
          BUFFER (OFFSET) = CMND;
          OFFSET = OFFSET + 1;
          IF OFFSET > 127 THEN
            OFFSET = 0;
          CMND$PTR = CMND$PTR + 1;
        END;
        CMND$PTR = DEBLANK (CMND$PTR + 1);
      END;
      ELSE IF ((CMND >= '0') AND (CMND <= '9')) OR ((CMND >= 'A') AND
          (CMND <= 'F')) THEN
      DO;
        OFFSET1 = 0;
        DO WHILE ((CMND >= '0') AND (CMND <= '9')) OR ((CMND >= 'A') AND
            (CMND <= 'F'));
          OFFSET1 = SHL (OFFSET1, 4);
          IF CMND <= '9' THEN
            OFFSET1 = OFFSET1 + CMND - '0';
          ELSE
            OFFSET1 = OFFSET1 + CMND - 'A' + 10;
          CMND$PTR = CMND$PTR + 1;
        END;
        I = 1;
        CMND$PTR = DEBLANK (CMND$PTR);
        IF CMND = '*' THEN
        DO;
          CMND$PTR = DEBLANK (CMND$PTR + 1);
          I = SCAN$INTEGER (.CMND$PTR);
          CMND$PTR = DEBLANK (CMND$PTR);
        END;
        DO WHILE I > 0;
          BUFFER (OFFSET) = LOW (OFFSET1);
          OFFSET = OFFSET + 1;
          IF OFFSET > 127 THEN
            OFFSET = 0;
          I = I - 1;
        END;
      END;
      ELSE IF CMND = '-' THEN
      DO;
        OFFSET = OFFSET + 1;
        IF OFFSET > 127 THEN
          OFFSET = 0;
        CMND$PTR = DEBLANK (CMND$PTR + 1);
      END;
      ELSE
      DO;
        CALL WRITE$CO$CRLF (.('INVALID HEX INPUT'), 17);
        CMND = CR;
      END;
    END;
  END;
  CALL WRITE$CRLF;
  CALL DISPLAY$BUFFER;
END;

TRANSFER$FILE: PROCEDURE;
  DECLARE MORE$SECTORS BOOLEAN;
  DECLARE (FILE$NAME$PTR, FILE$AFTN) ADDRESS;

  CMND$PTR = DEBLANK (CMND$PTR + 1);
  CALL SPATH (CMND$PTR, .PN$BLOCK, .STATUS);
  IF STATUS <> 0 THEN
  DO;
    CALL WRITE$CO$CRLF (.('INVALID FILE NAME'), 17);
    GOTO RESTART;
  END;
  IF PN$BLOCK.DRIVE$TYPE = 0 THEN
  DO;
    CALL WRITE$CO (.('NO CONTROLLER FOR DRIVE: '), 24);
    STR (0) = PN$BLOCK.DEVICE$NO + '0';
    CALL WRITE$CO$CRLF (.STR, 1);
    GOTO RESTART;
  END;
  FILE$NAME$PTR = CMND$PTR;
  CMND$PTR = DELIMIT (CMND$PTR);
  CALL PARSE$BLOCK$NO;
  IF DISK = 0FFH THEN
    DISK = FROM$DISK;
  IF DISK = PN$BLOCK.DEVICE$NO THEN
    CALL WRITE$CO$CRLF (.('WARNING, READING AND WRITING TO SAME DISK'), 41);
  CALL VERIFY$BLOCK$NO;
  CALL ABSIO (DISK$READ, DISK, SHL (TRACK, 8) + SECTOR, .HEADER$BUFFER);
  IF HEADER$BUFFER (0) <> 0 THEN
    CALL WRITE$CO$CRLF (.('WARNING, NOT FIRST HEADER BLOCK'), 31);
  CALL WRITE$CO (.('RESTORE FILE AT: '), 17);
  CALL DISPLAY$BLOCK$NO;
  CALL WRITE$CO (.(', TO FILE '), 10);
  CALL WRITE$CO (FILE$NAME$PTR, DELIMIT (FILE$NAME$PTR) - FILE$NAME$PTR);
  CALL WRITE$CO (.(' ? '), 3);
  CALL READ (CI$AFTN, .BUFFER, 128, .ACTUAL, .STATUS);
  CALL FORCE$UPPER (.BUFFER);
  IF BUFFER (0) <> 'Y' THEN
    GOTO RESTART;
  CALL OPEN (.FILE$AFTN, FILE$NAME$PTR, OPEN$WRITE, 0, .STATUS);
  IF STATUS <> 0 THEN
  DO;
    CALL FILE$ERROR (STATUS, FILE$NAME$PTR, FALSE);
    GOTO RESTART;
  END;
  MORE$SECTORS = TRUE;
  DO WHILE MORE$SECTORS;
    DO I = 2 TO 63;
      IF MORE$SECTORS THEN
      DO;
        BLOCK = HEADER$BUFFER (I);
        IF BLOCK > 0 THEN
        DO;
          TRACK = HIGH (BLOCK);
          SECTOR = LOW (BLOCK);
          IF INVALID$BLOCK$NO THEN
          DO;
            CALL WRITE$CO$CRLF (.('INVALID POINTER ENCOUNTERED'), 27);
            MORE$SECTORS = FALSE;
          END;
          ELSE
          DO;
            CALL ABSIO (DISK$READ, DISK, BLOCK, .BUFFER);
            CALL WRITE (FILE$AFTN, .BUFFER, 128, .STATUS);
            IF STATUS <> 0 THEN
            DO;
              CALL FILE$ERROR (STATUS, FILE$NAME$PTR, FALSE);
              MORE$SECTORS = FALSE;
            END;
          END;
        END;
        ELSE
          MORE$SECTORS = FALSE;
      END;
    END;
    IF MORE$SECTORS THEN
    DO;
      BLOCK = HEADER$BUFFER (1);
      IF BLOCK > 0 THEN
      DO;
        TRACK = HIGH (BLOCK);
        SECTOR = LOW (BLOCK);
        IF INVALID$BLOCK$NO THEN
        DO;
          CALL WRITE$CO$CRLF (.('INVALID POINTER ENCOUNTERED'), 27);
          MORE$SECTORS = FALSE;
        END;
        ELSE
          CALL ABSIO (DISK$READ, DISK, BLOCK, .HEADER$BUFFER);
      END;
      ELSE
        MORE$SECTORS = FALSE;
    END;
  END;
  CALL CLOSE (FILE$AFTN, .STATUS);
  DISK$LAST$READ = DISK;
  TRACK$LAST$READ = TRACK;
  SECTOR$LAST$READ = SECTOR;
END;

GET$OPERANDS: PROCEDURE;
  CMND$PTR = DEBLANK (CMND$PTR + 1);
  PARM (1) = SCAN$INTEGER (.CMND$PTR);
  CMND$PTR = DEBLANK (CMND$PTR);
  PARM (2) = SCAN$INTEGER (.CMND$PTR);
  CMND$PTR = DEBLANK (CMND$PTR);
  IF CMND <> CR THEN
    CALL CMND$ERROR;
END;

DISPLAY$OPERAND: PROCEDURE;
  CALL NUMOUT (PARM (0), 10, ' ', .STR, 5);
  CALL WRITE$CO (.STR, 5);
  CALL WRITE$CO (.(' ('), 2);
  CALL NUMOUT (PARM (0), 16, '0', .STR, 4);
  CALL WRITE$CO (.STR, 4);
  CALL WRITE$CO$CRLF (.('H)'), 2);
END;

ADD$OPERANDS: PROCEDURE;
  CALL GET$OPERANDS;
  PARM (0) = PARM (1) + PARM (2);
  CALL DISPLAY$OPERAND;
END;

SUB$OPERANDS: PROCEDURE;
  CALL GET$OPERANDS;
  PARM (0) = PARM (1) - PARM (2);
  CALL DISPLAY$OPERAND;
END;

MULT$OPERANDS: PROCEDURE;
  CALL GET$OPERANDS;
  PARM (0) = PARM (1) * PARM (2);
  CALL DISPLAY$OPERAND;
END;

DIV$OPERANDS: PROCEDURE;
  CALL GET$OPERANDS;
  PARM (0) = PARM (1) / PARM (2);
  CALL DISPLAY$OPERAND;
END;

MOD$OPERANDS: PROCEDURE;
  CALL GET$OPERANDS;
  PARM (0) = PARM (1) MOD PARM (2);
  CALL DISPLAY$OPERAND;
END;

CALL GET$COMMAND;
CALL WRITE$CO$CRLF (.('ISIS-II GANEF DISK TRASHER, V1.0'), 32);
DISK, DISK$LAST$READ, FROM$DISK, TO$DISK, MARK$DISK = 0;
TRACK, SECTOR, TRACK$LAST$READ, SECTOR$LAST$READ, MARK$TRACK, MARK$SECTOR = -1;
RESTART:
DO WHILE TRUE;
  CALL WRITE$CO (.('*'), 1);
  CALL GET$COMMAND;
  IF (CMND = 'E') OR (CMND = 'Q') THEN
    CALL EXIT;
  ELSE IF CMND = 'D' THEN
    CALL DISPLAY$SECTOR;
  ELSE IF CMND = 'W' THEN
    CALL WRITE$SECTOR;
  ELSE IF CMND = 'M' THEN
    CALL MARK$BLOCK$NO;
  ELSE IF CMND = 'R' THEN
    CALL RECALL$BLOCK$NO;
  ELSE IF CMND = 'A' THEN
    CALL ASSIGN$DISK;
  ELSE IF CMND = 'S' THEN
    CALL SUBSTITUTE$BUFFER;
  ELSE IF CMND = 'T' THEN
    CALL TRANSFER$FILE;
  ELSE IF CMND = CR THEN
    CALL DISPLAY$NEXT$SECTOR;
  ELSE IF CMND = '+' THEN
    CALL ADD$OPERANDS;
  ELSE IF CMND = '-' THEN
    CALL SUB$OPERANDS;
  ELSE IF CMND = '*' THEN
    CALL MULT$OPERANDS;
  ELSE IF CMND = '/' THEN
    CALL DIV$OPERANDS;
  ELSE IF CMND = '%' THEN
    CALL MOD$OPERANDS;
  ELSE
    CALL WRITE$CO$CRLF (.('UNRECOGNIZED COMMAND'), 20);
END;
END;
src/genpex.plm
$title('===>  P E X    (I N C L U D E   M A K E R)  <===')

gen$pex: DO;


/************************************************************************/
/*																		*/
/*      '(C) Intel Corporation 1981'.  All rights reserved.  No			*/
/*      part of this program or publication may be reproduced,			*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

      
DECLARE COPYRIGHT (*) BYTE DATA ('(C) INTEL CORP 1981');

DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.0',0);
    


  /****
   *
   *  PEX:
   *    program to create declarations for external routines and variables.
   *    has been extended to PLM86 in addition to accepting input for PLM80.
   *
   *    The added characters are:
   *         'A'  --  ADDRESS.
   *         'B'  --  BYTE.
   *         'I'  --  INTEGER.
   *         'W'  --  WORD.
   *         'R'  --  REAL.
   *         '@'  --  ADDRESS.
   *         'L'  --  LABEL.
   *
   *    The syntax for lines in the input file is as follows:
   *
   *       line      =  plm-var (proc-decl | var-decl).
   *       proc-decl = 'P'&param-list&type.
   *       var-decl  =  (type | '"' plm-var '"') [&'S'] [&'..'&plm-var].
   *       params    = (list-12 | '(' &(type | list-12) ... ')'.
   *       list-12   = '1' | '2'.
   *       type      = 'A' | 'B' | 'I' | 'W' | 'R' | '@' | 'L'.
   *
   ****/

declare SCANP address external;
declare SCANBYTE BASED SCANP byte;
declare SCANADDR BASED SCANP address;
declare OBUFP address external;
declare SCANENDED byte external;
ANYCH: procedure byte external; end;
BLNKCH: procedure byte external; end;
BUMPSCANP: procedure external; end;
CONSOLEIN: procedure external; end;
ERRORMESSAGE: procedure(ZZ1) external; declare (ZZ1) address; end;
FILECH: procedure byte external; end;
FILL: procedure(ZZ1,ZZ2,ZZ3) external; declare (ZZ1,ZZ2) address, (ZZ3) byte; end;
FMOVE: procedure(ZZ1,ZZ2,ZZ3) external; declare (ZZ1,ZZ2,ZZ3) address; end;
FORCUP: procedure byte external; end;
FORCUPSTRING: procedure external; end;
LENSTRNUL: procedure(ZZ1) byte external; declare (ZZ1) address; end;
LETRCH: procedure byte external; end;
OUTCHAR: procedure(ZZ1) external; declare (ZZ1) byte; end;
OUTDEC: procedure(ZZ1) external; declare (ZZ1) address; end;
OUTPRINT: procedure(ZZ1) external; declare (ZZ1) address; end;
OUTWRITE: procedure(ZZ1,ZZ2) external; declare (ZZ1) address, (ZZ2) byte; end;
PRINT: procedure(ZZ1) external; declare (ZZ1) address; end;
PRINTCR: procedure(ZZ1) external; declare (ZZ1) address; end;
PUTBLANK: procedure external; end;
SCANEXPECT: procedure(ZZ1) external; declare (ZZ1) address; end;
SCANMATCH: procedure(ZZ1) byte external; declare (ZZ1) address; end;
SCANUNTIL: procedure(ZZ1) external; declare (ZZ1) address; end;
SCANWHILE: procedure(ZZ1) external; declare (ZZ1) address; end;
SCANWHILEBLANKS: procedure external; end;
SETOB: procedure(ZZ1) external; declare (ZZ1) address; end;
SETSC: procedure(ZZ1) external; declare (ZZ1) address; end;
SETSCANENDED: procedure external; end;
TERMCH: procedure byte external; end;
TOKNCH: procedure byte external; end;
declare STATUS byte external;
declare REPORT byte external;
declare FATAL byte external;
declare ACTUAL address external;
BACKCI: procedure external; end;
CLOSEI: procedure external; end;
DEL: procedure(ZZ1) external; declare (ZZ1) address; end;
EX: procedure external; end;
ISIS: procedure(ZZ1,ZZ2) external; declare (ZZ2) address, (ZZ1) byte; end;
MEMCK: procedure address external; end;
OPENI: procedure(ZZ1) external; declare (ZZ1) address; end;
OPENO: procedure(ZZ1) external; declare (ZZ1) address; end;
READI: procedure(ZZ1,ZZ2) external; declare (ZZ1,ZZ2) address; end;
WRITEO: procedure(ZZ1,ZZ2) external; declare (ZZ1,ZZ2) address; end;
MOVEFILENAME: procedure(ZZ1) external; declare (ZZ1) address; end;
NEWEXTENSION: procedure(ZZ1,ZZ2) external; declare (ZZ1,ZZ2) address; end;
OPENSCAN: procedure(ZZ1) external; declare (ZZ1) address; end;
OUTFILENAME: procedure(ZZ1) external; declare (ZZ1) address; end;
READIWITHLIMIT: procedure(ZZ1,ZZ2) external; declare (ZZ1,ZZ2) address; end;
declare NIL literally '0';
declare BOOLEAN literally 'BYTE';
declare CR literally '0DH';
declare LF literally '0AH';
declare FOREVER literally 'WHILE (1)';
declare ENDDO literally 'END';
declare CHAR literally 'BYTE';
declare TRUE literally '0FFH';
declare FALSE literally '000H';
$eject

  DECLARE available            ADDRESS,    /* ADDRESS of memory available for symbols */
          mem$top              ADDRESS,    /* last ADDRESS usable */
          file$name$buffer(15) CHAR;

  DECLARE SYMBOL$TABLE$ENTRY LITERALLY
      'STRUCTURE(THREAD ADDRESS,
                 NEXT ADDRESS,
                 MARK BYTE,
                 LENGTH ADDRESS,
                 STR(1) CHAR)',

          SYMBOL$TABLE$SIZE       LITERALLY '256',
          SYMBOL$TABLE$ENTRY$SIZE LITERALLY '7',
          MARKED                  LITERALLY '0FFH',
          UNMARKED                LITERALLY '0',

          symbol$length ADDRESS,
          hash$value    ADDRESS,
          thread$head   ADDRESS,

          symbol$table(SYMBOL$TABLE$SIZE) ADDRESS,
          symbol$buffer(41)               CHAR;

  DECLARE NULL$STRING CHAR DATA(0),
          EXTERNAL$STRING(*)         CHAR DATA(' external',0),
          ADDRESS$VARIABLE$STRING(*) CHAR DATA(' address',0),
          BYTE$VARIABLE$STRING(*)    CHAR DATA(' byte',0),
          POINTER$VARIABLE$STRING(*) CHAR DATA(' pointer',0),
          REAL$VARIABLE$STRING(*)    CHAR DATA(' real',0),
          WORD$VARIABLE$STRING(*)    CHAR DATA(' word',0),
          INTEGER$VARIABLE$STRING(*) CHAR DATA(' integer',0),
          LABEL$STRING(*)            CHAR DATA(' label',0);

  DECLARE put$symbol$flag BOOLEAN,
          src$file(15)    CHAR INITIAL (0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),
          ipx$file(15)    CHAR INITIAL (0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),
          include$count   ADDRESS INITIAL (0),
          include$begin   ADDRESS,
          src$buff(1024)  CHAR;

  DECLARE state  BYTE INITIAL(1),                /* first line cmd line */
          fsm(6) STRUCTURE(NEXT(6) BYTE) DATA(   /* used to scan files  */
          /* ? lf  $  /  *  A */
             0, 1, 0, 2, 0, 6,
             0, 1, 7, 2, 0, 6,
             0, 1, 0, 2, 3, 6,
             3, 4, 3, 3, 5, 3,
             3, 4, 8, 3, 5, 3,
             3, 4, 3, 0, 5, 3);
$eject

  /****
   *
   *  read$ch:
   *    bumps scanp.  if scan$ended is set, reads more data into the buffer.
   *  when an EOF occurs, scanp is set to point to a null string
   *
   ****/

  read$ch: PROCEDURE;

    CALL bump$scan$p;
    IF (scan$ended) THEN
      DO;
        CALL readi(.src$buff, size(src$buff)-1);
        IF (actual = 0) THEN
          DO;
            scanp = .NULL$STRING;
            CALL set$scan$ended;
            RETURN;
          END;
        src$buff(actual) = 0;
        scanp            = .src$buff;
        CALL set$scan$ended;
      END;

  END read$ch;

  /****
   *
   *  full$line:
   *    assures that there is a TERMCH in the string pointed to by
   *  scanp.  moves data and reads more if required
   *
   ****/

  full$line: PROCEDURE;

    DECLARE temp ADDRESS;

    temp = scanp;
    CALL scan$until(.termch);
    scanp = temp;
    IF (scan$ended) THEN
      DO;
        temp = .src$buff(last(src$buff)) - scanp;
        CALL fmove(temp, scanp, .src$buff);
        CALL readi(.src$buff(temp), size(src$buff) - temp - 1);
        src$buff(actual + temp) = 0;
        scanp = .src$buff;        /* should check long line ... */
      END;
  CALL set$scan$ended;

  END full$line;
$eject

  /****
   *
   *  init$memory:
   *    initializes available to .MEMORY and mem$top to MEMCK
   *
   ****/

  init$memory: PROCEDURE;

    DECLARE (m BASED mem$top) BYTE;

    available = .memory;
    mem$top   = memck;
    m         = 0;
    mem$top   = mem$top - 1;

  END init$memory;
$eject

  /****
   *
   *  file$name$line:
   *    returns TRUE and sets file$name$buffer to the file name if scanp points
   *    to a string which specifies a file name.
   *
   ****/

  file$name$line: PROCEDURE BOOLEAN;

    IF (scan$byte <> '$') THEN
      RETURN (FALSE);
    CALL bump$scan$p;
    CALL scan$while$blanks;
    IF (NOT scan$match(.('FILE',0))) THEN
      RETURN (FALSE);
    CALL scan$while$blanks;
    IF (scan$byte <> '(') THEN
      RETURN (FALSE);
    CALL bump$scan$p;
    CALL fill(size(file$name$buffer), .file$name$buffer, 0);
    IF (scan$byte = ':') THEN
      scanp= scanp + 4;
    CALL move$file$name(.file$name$buffer);
    IF (scan$byte <> ')') THEN
      RETURN (FALSE);
    CALL set$sc(.file$name$buffer);
    CALL forc$up$string;
    RETURN (TRUE);

  END file$name$line;
$eject

  /****
   *
   *  pex$file$matches$file$name:
   *    returns TRUE IF the file name passed in matches the file name in File-
   *    NameBuffer.
   *
   ****/

  pex$file$matches$file$name: PROCEDURE (px$name$ptr) BOOLEAN;

    DECLARE px$name$ptr ADDRESS;

    DECLARE px$name BASED px$name$ptr CHAR;

    IF (px$name = ':') THEN
      px$name$ptr= px$name$ptr + 4;

    CALL set$sc(.file$name$buffer);
    RETURN (scan$match(px$name$ptr));

  END pex$file$matches$file$name;

  /****
   *
   *  check$gap:
   *    errors out should space overflow.
   *
   ****/

  check$gap: PROCEDURE;

    IF (available >= mem$top) THEN
      CALL error$message(.('dynamic storage overflow.  too many PEX symbols',0));

  END check$gap;
$eject

  /****
   *
   *  point$scanp$to$next$line:
   *    advances scanp to the first character after the current END of line.
   *
   ****/

  point$scanp$to$next$line: PROCEDURE;

    CALL scan$until(.termch);
    CALL scan$while(.termch);

  END point$scanp$to$next$line;

  /****
   *
   *  find$include$file:
   *    searches for the word INCLUDE, then copies the file name to
   *  the area pointed to by obufp
   *
   ****/

  find$include$file: PROCEDURE;

    CALL full$line;
    DO
      WHILE (NOT termch);
      CALL read$ch;
      IF (scan$match(.('INCLUDE',0))) THEN
        DO;
          CALL scan$until(.filech);
          CALL out$file$name(scanp);
          CALL out$char(0);
          CALL scan$until(.termch);
          include$count = include$count + 1;
          available     = obufp;
          CALL check$gap;
          RETURN;
        END;
    ENDDO;

  END find$include$file;
$eject

  /****
   *
   *                 S Y M B O L   -   T A B L E   S E C T I O N
   *
   ****/

  /****
   *
   *  init$symbol$table:
   *    sets all the entries in the symbol table to NIL.  NILs thread$head.
   *
   ****/

  init$symbol$table: PROCEDURE;

    DECLARE i ADDRESS;

    i = length(symbol$table);
    DO
      WHILE (i <> 0);
      i = i - 1;
      symbol$table(i) = NIL;
    ENDDO;

    thread$head= NIL;

  END init$symbol$table;
$eject

  /****
   *
   *  get$id:
   *    copies the symbol currently being pointed to into symbol$buffer, converting
   *    from lower to upper case and discarding '$'.  A maximum of 32 characters
   *    is allowed.  scanp is left pointing to the character which halted the
   *    scan.
   *
   ****/

  get$id: PROCEDURE;

    symbol$length = 0;
    CALL set$ob(.symbol$buffer);
    DO
      WHILE (NOT scan$ended);
      IF (toknch) THEN
        DO;
          CALL out$char(forcup);
          symbol$length = symbol$length + 1;
        END;
      ELSE IF (scan$byte <> '$') THEN
        GOTO exit$loop;
      CALL bump$scanp;
    ENDDO;

exit$loop:;
    IF (symbol$length > size(symbol$buffer)) THEN
      CALL error$message(.('symbol greater than 40 characters long',0));

    CALL out$char(0);

  END get$id;
$eject

  /****
   *
   *  hash:
   *    sets hash$value to the hashed value of symbol$buffer;
   *
   ****/

  hash: PROCEDURE;

    hash$value = 0;
    CALL set$sc(.symbol$buffer);
    CALL set$scan$ended;
    DO
      WHILE (NOT scan$ended);
      hash$value = ror(hash$value,1) + scan$byte;
      CALL bump$scan$p;
    ENDDO;

    hash$value = low(hash$value);

  END hash;

  /****
   *
   *  lookup$id:
   *    searches the symbol table for the entry with ID = symbol$buffer.
   *
   ****/

  lookup$id: PROCEDURE ADDRESS;

    DECLARE ptr         ADDRESS,
            p BASED ptr SYMBOL$TABLE$ENTRY;

    CALL hash;
    ptr = symbol$table(hash$value);
    CALL set$sc(0);
    DO
      WHILE (ptr <> NIL);
      scanp = .symbol$buffer;           /* this is NOT string equality */
      IF (scan$match(.p.STR(0))) THEN
        IF (scan$byte = 0) THEN
          RETURN (ptr);
      ptr = p.NEXT;
    ENDDO;

    RETURN (NIL);

  END lookup$id;
$eject

  /****
   *
   *  insert$pex$symbol:
   *    the string pointed to by scanp is inserted into the symbol table.
   *    NOTE:  the symbol tables grow upward from available.
   *
   ****/

  insert$pex$symbol: PROCEDURE;

    DECLARE pex$data$string$ptr    ADDRESS,
            ste$p                  ADDRESS,
            ste$b BASED ste$p      SYMBOL$TABLE$ENTRY,
            pex$data$string$length ADDRESS;

    CALL get$id;
    CALL scan$while$blanks;
    pex$data$string$ptr    = scanp;
    pex$data$string$length = 0;
    DO
      WHILE (NOT (termch OR scan$ended));
      pex$data$string$length = pex$data$string$length + 1;
      CALL bump$scan$p;
    ENDDO;

    ste$p = available;
    obufp = .ste$b.STR(0);
    CALL out$write(.symbol$buffer, symbol$length);
    CALL out$char(0);
    CALL out$write(pex$data$string$ptr, pex$data$string$length);
    CALL out$char(0);
    available = obufp;
    CALL check$gap;

    CALL hash;
    ste$b.NEXT   = symbol$table(hash$value);
    ste$b.MARK   = UNMARKED;
    ste$b.LENGTH = symbol$length + pex$data$string$length + 2;
    ste$b.THREAD = thread$head;
    thread$head, symbol$table(hash$value) = ste$p;

  END insert$pex$symbol;
$eject

  /****
   *
   *  squash$symbol$table:
   *    transforms the symbol table from its current format into a series of
   *    of strings terminated by the null string.  Data is compacted by being
   *    moved from lower to lower locations, thus reusing space from deleted
   *    entries and allowing more space for the declarations.  thread$head
   *    points at the first of the series of strings.
   *
   ****/

  squash$symbol$table: PROCEDURE;

    DECLARE (prev, current, temp) ADDRESS,
            a BASED available     BYTE,
            p BASED prev          SYMBOL$TABLE$ENTRY,
            c BASED current       SYMBOL$TABLE$ENTRY;

    /*
     *  The thread fields must be reversed, so that thread fields are
     *  increasing.  At the end of the loop, prev points to the list.
     */

    current = thread$head;
    prev    = NIL;
    DO
      WHILE (current <> NIL);
      temp     = c.THREAD;
      c.THREAD = prev;
      prev     = current;
      current  = temp;
    ENDDO;

    thread$head, available = .memory;
    current = prev;
    DO
      WHILE (current <> NIL);
      prev = c.THREAD;
      temp = available + c.LENGTH;
      CALL fmove(c.LENGTH, .c.STR(0), available);
      CALL print$cr(available);
      current   = prev;
      available = temp;
    ENDDO;
    a         = 0;
    available = available + 1;     /* Terminated by a null string */

  END squash$symbol$table;
$eject

  /****
   *
   *  mark$id:
   *    looks up the symbol in symbol$buffer.  If found, sets Mark to the passed
   *    in value.
   *
   ****/

  mark$id: PROCEDURE (mark$value);

    DECLARE mark$value BYTE;

    DECLARE ste$p             ADDRESS,
            ste$b BASED ste$p SYMBOL$TABLE$ENTRY;

    ste$p = lookup$id;
    IF (ste$p = NIL) THEN
      RETURN;
    ste$b.MARK = mark$value;

  END mark$id;

  /****
   *
   *  find$and$mark:
   *    bump scanp to the next letter, get the symbol and set its mark field to
   *    the passed in value.
   *
   ****/

  find$and$mark: PROCEDURE (mark$value);

    DECLARE mark$value BYTE;

    CALL scan$until(.toknch);
    CALL get$id;
    CALL mark$id(mark$value);

  END find$and$mark;
$eject

  /****
   *
   *  mark$internal$references:
   *    assures that symbols containing references to other symbols (BASEd var-
   *    iables and literallys) are included in the declarations.
   *
   ****/

  mark$internal$references: PROCEDURE (mark$value);

    DECLARE mark$value BYTE;

    DECLARE ptr         ADDRESS,
            p BASED ptr SYMBOL$TABLE$ENTRY;

    ptr = thread$head;
    DO
      WHILE (ptr <> NIL);
      IF (p.MARK = mark$value) THEN
        DO;
          scanp = .p.STR(1) + lenstrnul(.p.STR(0));
          CALL set$scan$ended;
          DO
            WHILE (NOT scan$ended);
            IF ((scan$byte = '.') OR (scan$byte = '"')) THEN
              CALL find$and$mark(mark$value);
            ELSE IF (scan$byte = '''') THEN        /* only one level is allowed */
              DO
                WHILE (NOT scan$ended);
                CALL find$and$mark(mark$value);
              ENDDO;
            CALL bump$scan$p;
          ENDDO;
        END;
      ptr= p.THREAD;
    ENDDO;

  END mark$internal$references;
$eject

  /****
   *
   *  delete$entries:
   *    deletes all those entries whose mark field is equal to the passed in
   *    value from the THREAD list.
   *
   ****/

  delete$entries: PROCEDURE (mark$value);

    DECLARE mark$value BYTE;

    DECLARE (current, prev) ADDRESS,
            c BASED current SYMBOL$TABLE$ENTRY,
            p BASED prev    SYMBOL$TABLE$ENTRY;

    prev    = .thread$head;
    current = thread$head;
    DO
      WHILE (current <> NIL);

      IF (c.MARK <> mark$value) THEN
        DO;
          p.THREAD = current;
          prev     = current;
        END;

      current = c.THREAD;
    ENDDO;
    p.THREAD = NIL;

  END delete$entries;
$eject

  /****
   *
   *  write$char:
   *    writes the character to the output file
   *
   ****/

  write$char: PROCEDURE (ch);

    DECLARE ch CHAR;

    CALL writeo(.ch, 1);

  END write$char;

  /****
   *
   *  write$string:
   *    writes the null terminated string to the output file
   *
   ****/

  write$string: PROCEDURE (s$p);

    DECLARE s$p ADDRESS;

    CALL writeo(s$p, lenstrnul(s$p));

  END write$string;
$eject

  /****
   *
   *  write$number:
   *    writes the decimal ADDRESS using write$char.
   *
   ****/

  write$number: PROCEDURE (number);

    DECLARE number ADDRESS;

    DECLARE nbuff(6) CHAR;

    CALL fill(6, .nbuff, 0);
    CALL set$ob(.nbuff);
    CALL out$dec(number);
    CALL write$string(.nbuff);

  END write$number;
$eject

  write$declare: PROCEDURE;
    CALL write$string(.('declare ',0));
  END write$declare;

  write$semi: PROCEDURE;
    CALL write$char(';');
  END write$semi;

  write$blank: PROCEDURE;
    CALL write$char(' ');
  END write$blank;

  write$comma: PROCEDURE;
    CALL write$char(',');
  END write$comma;

  write$lp: PROCEDURE;
    CALL write$char('(');
  END write$lp;

  write$rp: PROCEDURE;
    CALL write$char(')');
  END write$rp;

  write$crlf: PROCEDURE;
    CALL write$string(.(CR,LF,0));
  END write$crlf;

  /****
   *
   *  write$lit:
   *    writes the definition as a literally statement.
   *
   ****/

  write$lit: PROCEDURE;

    CALL write$declare;
    CALL write$string(.symbol$buffer);
    CALL write$string(.(' literally ',0));
    CALL write$string(scanp);
    CALL write$semi;
    CALL write$crlf;

  END write$lit;
$eject

  /****
   *
   *  chr$idx:
   *    returns an index of the character pointed to by scanp.
   *
   ****/

  chr$idx: PROCEDURE (s$p) ADDRESS;

    DECLARE s$p ADDRESS;

    DECLARE i             BYTE,
            s$b BASED s$p CHAR;

    i = 1;
    DO
      WHILE (s$b <> 0);
      IF (s$b = scan$byte) THEN
        RETURN (i);
      s$p = s$p + 1;
      i   = i + 1;
    ENDDO;

    RETURN (0);

  END chr$idx;
$eject
  /****
   *
   *  get$user$type:
   *    puts a user type in the symbol table if it exists.
   *
   ****/
get$user$type: PROCEDURE;

    IF (scan$byte = '"') THEN
      DO;
        CALL scan$until(.toknch);
        CALL get$id;
        CALL scan$while$blanks;
      END;

END get$user$type;

  /****
   *
   *  write$var:
   *    writes a declaration for the variable with the given type.
   *
   ****/

  write$var: PROCEDURE;

    DECLARE TYPE$TBL(*) CHAR DATA('ABIW@R"L',0),
            TYPE$PTR(*) ADDRESS DATA(
              .NULL$STRING,
              .ADDRESS$VARIABLE$STRING,
              .BYTE$VARIABLE$STRING,
              .INTEGER$VARIABLE$STRING,
              .WORD$VARIABLE$STRING,
              .POINTER$VARIABLE$STRING,
              .REAL$VARIABLE$STRING,
              .symbol$buffer,
              .LABEL$STRING),
            idx ADDRESS,
      (based$ptr, array$ptr, bvar$ptr) ADDRESS;

    CALL write$declare;
    CALL write$string(.symbol$buffer);
    idx = chr$idx(.TYPE$TBL);
    CALL get$user$type;
    CALL bump$scan$p;
$eject

    based$ptr, array$ptr, bvar$ptr= .NULL$STRING;
    DO
      WHILE (NOT scan$ended);

      CALL scan$while$blanks;
      IF (scan$byte = 'S') THEN
        DO;
          array$ptr = .('(1)',0);
          CALL bump$scan$p;
        END;
      ELSE IF (scan$addr = '..') THEN
        DO;
           based$ptr       = .(' BASED ',0);
           scanp, bvar$ptr = scanp + 2;
           CALL scan$until(.BlnkCh);
           IF (NOT scan$ended) THEN
             DO;
               scan$byte = 0;
               scanp     = scanp + 1;
             END;
        END;
      ELSE IF (not scan$ended) THEN
        DO;
          CALL print(scanp);
          CALL error$message(.('bad pex line',0));
        END;
    ENDDO;

    CALL write$string(based$ptr);
    CALL write$string(bvar$ptr);
    CALL write$string(array$ptr);

    IF (TYPE$PTR(idx) = .symbol$buffer) THEN
      CALL write$blank;
    CALL write$string(TYPE$PTR(idx));
    IF (bvar$ptr = .NULL$STRING) THEN
      CALL write$string(.EXTERNAL$STRING);
    CALL write$semi;
    CALL write$crlf;
  END write$var;
$eject

  /****
   *
   *  pex$error:
   *    prints an error message on the terminal and exits.
   *
   ****/

  pex$error:
    PROCEDURE;

    CALL print$cr(.('bad PEX line',0));
    CALL print(.symbol$buffer);
    CALL put$blank;
    CALL print$cr(scanp);
    CALL ex;

  END pex$error;
$eject

  /****
   *
   *  write$proc:
   *    writes the declaration of a procedure.  The format of a procedure declar-
   *    ation is p[argument-list][type].  argument-list is either a string of
   *    '1' or '2', or '(' type-characters ')'.  type is type-character.
   *    type-character is one of the characters '@RIWAB'.
   *
   ****/

  write$proc: PROCEDURE;

    DECLARE PARAM$TYPE$STRING(*)     CHAR DATA('ABW@IR21"',0),
                /* The '"' is required to be the last type */
            PARAM$1$2$TYPE$STRING(2) CHAR at(.PARAM$TYPE$STRING(6)),
            param$count(10)          BYTE,
            param$type$ptr           ADDRESS,
            PARAM$TYPE$TBL(*)        ADDRESS DATA(
              .NULL$STRING,
              .ADDRESS$VARIABLE$STRING,
              .BYTE$VARIABLE$STRING,
              .WORD$VARIABLE$STRING,
              .POINTER$VARIABLE$STRING,
              .INTEGER$VARIABLE$STRING,
              .REAL$VARIABLE$STRING,
              .ADDRESS$VARIABLE$STRING,
              .BYTE$VARIABLE$STRING),
            PROC$TYPE$TBL(1) ADDRESS AT(.PARAM$TYPE$TBL(3)),
            ZZ$STRING(*)     CHAR DATA('ZZ',0),
            (saved$scanp, close$scan$p) ADDRESS,
            (i, j, params, params$left) ADDRESS;

    write$args: PROCEDURE (p);
      DECLARE p ADDRESS;
      CALL write$lp;
      i = chr$idx(p);
      DO
        FOREVER;
        CALL write$string(.ZZ$STRING);
        params = params + 1;
        CALL write$number(params);
        param$count(i) = param$count(i) + 1;
        IF scan$byte = '"' THEN
          DO;
            CALL bump$scan$p;
            CALL scan$while (.TOKNCH);
          END;
        CALL bump$scan$p;
        i = chr$idx(p);
        IF (i = 0) THEN
          DO;
            CALL write$rp;
            RETURN;
          END;
        CALL write$comma;
      ENDDO;
    END write$args;
$eject

    CALL fill(length(param$count), .param$count, 0);
    CALL bump$scan$p;
    CALL write$string(.symbol$buffer);
    CALL write$string(.(': procedure',0));
    params = 0;
    IF (scan$byte = '(') THEN
      DO;
        CALL bump$scan$p;
        saved$scanp = scanp;
        CALL write$args((param$type$ptr := .PARAM$TYPE$STRING));
        IF (scan$byte <> ')') THEN
          CALL error$message(.('Missing closing '')'' in procedure definition',0));
        close$scan$p = scan$p;
        CALL bump$scan$p;
      END;
    ELSE IF ((scan$byte = '1') or (scan$byte = '2')) THEN
      DO;
        saved$scanp = scanp;
        CALL write$args((param$type$ptr:= .PARAM$1$2$TYPE$STRING));
      END;
$eject

    IF scan$byte = '"' THEN
      DO;
        CALL get$user$type;
        CALL bump$scan$p;
        CALL write$blank;
        CALL write$string (.SYMBOL$BUFFER);
      END;
    CALL write$string(PARAM$TYPE$TBL(chr$idx(.PARAM$TYPE$STRING)));
    CALL write$string(.EXTERNAL$STRING);
    CALL write$semi;

    IF (params <> 0) THEN
      DO;
        params$left = params;
        CALL write$blank;
        CALL write$declare;
        DO
          i = 1 to last(PARAM$TYPE$TBL);
          IF (param$count(i) <> 0) THEN
            DO;
              CALL write$lp;
              scanp = saved$scanp;
              DO
                j = 1 to params;
                  IF scan$byte = '"' THEN
                    DO;
                      CALL bump$scan$p;
                      CALL scan$while (.TOKNCH);
                    END;
                  ELSE
                    IF (chr$idx(param$type$ptr) = i) THEN
                      DO;
                        CALL write$string(.ZZ$STRING);
                        CALL write$number(j);
                        params$left    = params$left - 1;
                        param$count(i) = param$count(i) - 1;
                        IF (param$count(i) <> 0) THEN
                          CALL write$comma;
                      END;
                  CALL bump$scan$p;
              ENDDO;
              CALL write$rp;
              CALL write$string(PARAM$TYPE$TBL(i));
              IF (params$left = 0) THEN
                GOTO exit$loop;
              CALL write$comma;
              CALL write$blank;
            END;
        ENDDO;
        scan$p = saved$scan$p;
        IF params$left > 0 THEN
          DO;
            DO
              j = 1 to params;
                IF scan$byte = '"' THEN
                  DO;
                    CALL get$user$type;
                    CALL write$string (.ZZ$STRING);
                    CALL write$number (j);
                    CALL write$blank;
                    CALL write$string (.SYMBOL$BUFFER);
                    params$left = params$left - 1;
                    IF params$left > 0 THEN
                      DO;
                        CALL write$comma;
                        CALL write$blank;
                      END;
                    ELSE
                      DO;
                        scan$p = close$scan$p;
                        GO TO exit$loop;
                      END;
                  END;
                CALL bump$scan$p;
            ENDDO;
          END;
exit$loop:;
        CALL write$semi;
      END;

    CALL write$string(.(' end;',CR,LF,0));

  END write$proc;
$eject

  /****
   *
   *  write$dcl:
   *    The symbol being defined is placed into symbol$buffer.  The first
   *    non-blank character of the definition string (pointed to by
   *    id$text$ptr) is used to determine whether a variable, procedure
   *    or literal declaration is to be produced.
   *
   ****/

  write$dcl: PROCEDURE (id$p, id$text$p);

    DECLARE (id$p, id$text$p) ADDRESS;

    DECLARE prc           ADDRESS,
            PROC$TABLE(*) ADDRESS DATA(
              .pex$error,                  /* unknown character */
              .write$proc,                 /* 'p' */
              .write$var,                  /* 'a' */
              .write$var,                  /* 'B' */
              .write$lit,                  /* "'" */
              .write$var,                  /* '@' */
              .write$var,                  /* 'R' */
              .write$var,                  /* 'W' */
              .write$var,                  /* 'i' */
              .write$var,                  /* '"' */
              .write$var);                 /* 'L' */

    scanp = id$text$p;
    CALL set$scan$ended;
    obufp = .symbol$buffer;
    CALL out$print(id$p);
    CALL out$char(0);
    CALL scan$while$blanks;
    CALL forc$up$string;
    prc = PROC$TABLE(chr$idx(.('PAB''@RWI"L',0)));
    CALL prc;

  END write$dcl;
$eject

  /****
   *
   *  dump$dcls:
   *    follows the pairs of strings starting at thread$head until the first
   *    string of a pair is a null string.  The pairs of strings are defined
   *    as symbol being defined followed by defining text for that symbol.
   *
   ****/

  dump$dcls: PROCEDURE;

    DECLARE (sym$p, s$p) ADDRESS,
            (s$b BASED s$p) BYTE;

    s$p = thread$head;
    DO
      WHILE (s$b <> 0);
      sym$p, scanp = s$p;
      CALL scan$while(.anych);
      scanp = scanp + 1;
      s$p   = scanp + lenstrnul(scanp) + 1;
      CALL forc$up$string;
      CALL write$dcl(sym$p, scanp);
    ENDDO;

  END dump$dcls;
$eject

  /****
   *
   *  class:
   *    returns the class of scan$byte
   *
   ****/

  class: PROCEDURE ADDRESS;

    IF (letrch) THEN
      RETURN (5);
    RETURN (chr$idx(.(LF,'$/*',0)));     /* all others are class 0 */

  END class;
$eject

  /****
   *
   *  Main module:
   *    initialize memory and symbol table.
   *    read in command line and get filenames for SRC$FILE and PEX$FILE.
   *    read in PEX$FILE, creating symbol table with all entries UNMARKED.
   *    read in SRC$FILE
   *    for each token until the END of the file, set its ste$b as MARKed.
   *    delete all UNMARKed STEs.
   *    transform the symbol table to preserve space.
   *    open SRC$FILE.IPX
   *    write the declarations.
   *    exit.
   *
   ****/

  CALL init$memory;
  CALL init$symbol$table;
  CALL back$ci;
  CALL console$in;
  CALL forc$up$string;
  CALL scan$while$blanks;
  IF (scan$match(.('DEBUG',0))) THEN
    CALL scan$while$blanks;
  CALL scan$while(.file$ch);
  CALL scan$while$blanks;
  fatal, report = TRUE;
  CALL open$scan(.openi);
  CALL scan$while$blanks;
  CALL scan$expect(.('TO',0));
  CALL move$file$name(.src$file);
  CALL print(.(CR,LF,'ISIS-II GENPEX V1.0',CR,LF,0));
  scanp = .src$file;
  CALL new$extension(.ipx$file, .('IPX',0));
  /* delete previous .IPX file */
  REPORT, FATAL = FALSE;          /* make no noise if it isn't there */
  CALL del(.ipx$file);
  REPORT, FATAL = TRUE;
$eject

  CALL readi$with$limit(available, mem$top-available+1);
  CALL fmove(actual, available, (scanp := mem$top-actual+1));
  CALL closei;

  put$symbol$flag = TRUE;
  CALL set$scan$ended;
  DO
    WHILE (NOT scan$ended);
    IF (toknch) THEN
      DO;
        IF (put$symbol$flag) THEN
          CALL insert$pex$symbol;
      END;
    ELSE IF (file$name$line) THEN
      put$symbol$flag = NOT pex$file$matches$file$name(.src$file);
    CALL point$scanp$to$next$line;
  ENDDO;
$eject

  /*
   * Scan the rest of the file for identifiers appearing in the symbol table
   * and mark the symbol table entries as being used.
   */

  CALL openi(.src$file);
  include$begin, obufp = available;     /* remember file names here */
  scanp                = .NULL$STRING;  /* cause READ$CH to read in data */
  DO
    FOREVER;
    CALL read$ch;
    IF (scan$ended) THEN
      DO;
        CALL closei;
        status        = 0FFH;
        fatal,report  = FALSE;
        DO                /* open include files */
          WHILE (status <> 0);
          IF (include$count = 0) THEN
            GOTO exit$loop;
          include$count = include$count - 1;
          scanp         = include$begin;
          CALL print$cr(scanp);
          CALL open$scan(.openi);
          include$begin = scanp + 1;
        ENDDO;
        fatal, report = TRUE;
        scanp         = .NULL$STRING;
      END;
    ELSE
      DO;
        state = fsm(state).NEXT(class);
        IF (state = 6) THEN
          DO;
            CALL full$line;
            CALL find$and$mark(MARKED);
            state = 0;
          END;
        ELSE IF (state > 6) THEN
          DO;
            CALL find$include$file;
            IF (state = 8) THEN
              state = 3;     /* continue scanning comment */
            ELSE
              state = 0;     /* otherwise start again */
          END;
      END;
  ENDDO;
exit$loop:;
$eject

  /*
   * All entries in symbol table which are used have been marked as such.
   * delete the unmarked entries and squash the symbol table.
   */

  CALL mark$internal$references(MARKED);
  CALL delete$entries(UNMARKED);
  CALL squash$symbol$table;

  /*
   * write the declarations
   */

  CALL openo(.ipx$file);
  CALL dump$dcls;

  CALL ex;

END gen$pex;
src/goto.plm
GOTO$MOD: DO;

/************************************************************************/
/*																		*/
/*      '(C) Intel Corporation 1981'.  All rights reserved.  No			*/
/*      part of this program or publication may be reproduced,			*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

DECLARE COPYRIGHT (*) BYTE DATA ('(C) INTEL CORP 1981');

DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.0',0);

DECLARE	LIT		LITERALLY	'LITERALLY',
		DCL		LIT	'DECLARE',
		TRUE	LIT	'0FFH',
		FALSE	LIT	'000H',
		PROC	LIT	'PROCEDURE',
		PROCEND	LIT	'END',
		THENDO	LIT	'THEN DO;',
		ELSEIF	LIT	'END; ELSE IF',
		ELSEDO	LIT	'END; ELSE DO;',
		IFEND	LIT	'END',
		WHILEND	LIT	'END',
		CR		LIT	'0DH',
		LF		LIT	'0AH';

EXIT:	PROC EXTERNAL;											PROCEND;
OPEN:	PROC (A,B,C,D,E) EXTERNAL;	DCL (A,B,C,D,E) ADDRESS;	PROCEND;
READ:	PROC (A,B,C,D,E) EXTERNAL;	DCL (A,B,C,D,E) ADDRESS;	PROCEND;
WRITE:	PROC (A,B,C,D) EXTERNAL;	DCL (A,B,C,D) ADDRESS;		PROCEND;
SEEK:	PROC (A,B,C,D,E) EXTERNAL;	DCL (A,B,C,D,E) ADDRESS;	PROCEND;
CLOSE:	PROC (A,B) EXTERNAL;		DCL (A,B) ADDRESS;			PROCEND;
SPATH:	PROC (A,B,C) EXTERNAL;		DCL (A,B,C) ADDRESS;		PROCEND;
DEBLANK:PROC (A) ADDRESS EXTERNAL;	DCL (A) ADDRESS;			PROCEND;
SEQ:	PROC (A,B,C) BYTE EXTERNAL;	DCL (A,B,C) ADDRESS;		PROCEND;
FORCE$UPPER:	PROC(A) EXTERNAL;	DCL (A) ADDRESS;			PROCEND;

DCL (STATUS, ACTUAL) ADDRESS;
DCL (CMND$PTR) ADDRESS, (CMND$CH BASED CMND$PTR) (1) BYTE;
DCL (PN1, PN2) STRUCTURE
	(DEV BYTE, NAME (6) BYTE, EXT (3) BYTE, DEV$TYPE BYTE, DRIVE$TYPE BYTE);

CMND$ERROR: PROC (MSG, MSGLEN);
DCL (MSG, MSGLEN) ADDRESS;
	CALL WRITE (0, .('Command tail error near #: '), 27, .STATUS);
	CALL WRITE (0, MSG, MSGLEN, .STATUS);
	CALL WRITE (0, .(' expected.', CR, LF), 12, .STATUS);
	CALL WRITE (0, .MEMORY, CMND$PTR - .MEMORY, .STATUS);
	CALL WRITE (0, .('#', CR, LF), 3, .STATUS);
	CALL EXIT;
PROCEND CMND$ERROR;

/* Read in the initial command line. */
CALL READ (1, .MEMORY, 128, .ACTUAL, .STATUS);
MEMORY (ACTUAL - 1) = CR;
CALL FORCE$UPPER (.MEMORY);

/* Scan the command line. */
CMND$PTR = DEBLANK (.MEMORY);
IF CMND$CH (0) = CR THENDO /* Null command tail. */
	CALL WRITE (0, .('ISIS-II GOTO V0.0', CR, LF), 19, .STATUS);
	CALL EXIT;
IFEND;
CALL SPATH (CMND$PTR, .PN1, .STATUS);
IF STATUS <> 0 THENDO /* Bad label. */
	CALL CMND$ERROR (.('<label>'), 7);
IFEND;

ACTUAL = 0;
CALL SEEK (1, 2, .ACTUAL, .ACTUAL, .STATUS); /* Rewind command file. */
IF STATUS <> 0 THENDO /* Can't seek, probably not in submit. */
	CALL EXIT;
IFEND;
DO WHILE TRUE;
	CALL WRITE (0, .('#'), 1, .STATUS);
	CALL READ (1, .MEMORY, 128, .ACTUAL, .STATUS);
	IF (STATUS <> 0) OR (ACTUAL = 0) THENDO
		CALL EXIT; /* Probably end of file. */
	IFEND;
	MEMORY (ACTUAL - 1) = CR;
	CALL FORCE$UPPER (.MEMORY);
	CMND$PTR = DEBLANK (.MEMORY);
	IF SEQ (CMND$PTR, .(';;'), 2) THENDO /* A possible label. */
		CMND$PTR = DEBLANK (CMND$PTR + 2);
		ACTUAL = 1;
		DO WHILE ACTUAL < 15;
			IF CMND$CH (ACTUAL) = ':' THENDO
				CMND$CH (ACTUAL) = ' ';
			IFEND;
			ACTUAL = ACTUAL + 1;
		WHILEND;
		CALL SPATH (CMND$PTR, .PN2, .STATUS);
		IF STATUS = 0 THENDO /* A valid label. */
			IF SEQ (.PN1, .PN2, 10) THENDO /* We found the label. */
				CALL EXIT;
			IFEND;
		IFEND;
	IFEND;
WHILEND;

END GOTO$MOD;
src/hdback.plm
HARD$DISK$BACKUP:  
DO;

/************************************************************************/
/*																		*/
/*      '(C) Intel Corporation 1981'.  All rights reserved.  No			*/
/*      part of this program or publication may be reproduced,			*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

DECLARE COPYRIGHT (*) BYTE DATA ('(C) INTEL CORP 1981');

DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V2.1',0);
    


/**********************************************************************
 *                                                                    *
 * This program is designed to be used in backing up a hard disk      *
 * platter to floppy disks.  It allows wildcard filenames as well     *
 * as the additional selection based on the file attributes.          *
 * Invocation is as follows:                                          *
 *                                                                    *
 *    [:F#:]BACKUP filename [{W{0|1} I{0|1} S{0|1}}] [DELETE]         *
 *        where:  filename ::= pathname | device                      *
 *                device ::= :Fn:                                     *
 *                                                                    *
 * The interpretation when an attribute is used is to backup the file *
 * only if there is a filename match and the attribute is set(reset)  *
 * By not specifying the attribute, the all of the attributes will    *
 * be ignored (except for the Format attribute).                      *
 * Files with the Format attribute will never be copied.              *
 *                                                                    *
 * The files are always transfered to drive 5 first, then drive 4,... *
 *                                                                    *
 * if the DELETE switch is used, then all files without the format    *
 * attribute on the target disk will be deleted                       *
 *                                                                    *
 **********************************************************************/

/* The following literally declarations are used to map PLM80 into
   PLM86 code
*/

declare word literally 'address';
declare integer literally 'address';
declare pointer literally 'address';

declare as literally 'literally';
declare dcl as 'declare';

dcl boolean as 'byte';
dcl true as '0FFH';
dcl false as '0';
dcl ptr as 'word';
dcl nil as '0';
dcl character as 'byte';
dcl char2 as 'word';
dcl varying as '1';

dcl for as 'do';
dcl endfor as 'end';
dcl thenn as 'then do;';
dcl elseif as 'end; else if';
dcl elsee as 'end; else do;';
dcl endif as 'end';
dcl whilee as 'do while';
dcl endwhile as 'end';
dcl endproc as 'end';
dcl endmod as 'end';
dcl enddo as 'end';

dcl COMMA as ''',''';
dcl CR as '0DH';
dcl LF as '0AH';
dcl ESC as '1BH';
dcl AMPERSAND as '''&''';

dcl VERSION(4) character initial('V2.1');
dcl COMMAND$LINE(128) character;
dcl COMMAND$PTR ptr;
dcl COMMAND$LINE$LENGTH word;
dcl BACKUP$PARM$BLOCK structure(
    DEVICE(4) character,
    FILENAME(11) character,
    W$ATTR boolean,
    S$ATTR boolean,
    I$ATTR boolean,
    CHANGE$W byte,
    CHANGE$S byte,
    CHANGE$I byte,
    OUTPUT$LIST$ELEMENTS byte,
    OUTPUT$LIST(4) character);
dcl (ACTUAL, STATUS) word;
dcl SELECTED$DEVICE(10) boolean initial(
     false,false,false,false,false,false,false,false,false,false);

dcl DELETE$OPTION boolean public initial(false); /*default-- nodelete*/

EXIT: procedure external;
end EXIT;

READ: procedure(AFTN, BUF$PTR, LEN, ACTUAL$PTR, STATUS$PTR) external;
   dcl (AFTN,LEN) word;
   dcl (BUF$PTR, ACTUAL$PTR, STATUS$PTR) pointer;
end READ;

WRITE: procedure(AFTN, BUF$PTR, LEN, STATUS$PTR) external;
   dcl (AFTN, LEN) word;
   dcl (BUF$PTR, STATUS$PTR) pointer;
end WRITE;

ERROR: procedure(STRING$PTR, PTR1);
   dcl (STRING$PTR, PTR1) pointer;
   dcl STRING based STRING$PTR (varying) character;
   dcl STATUS word;
   dcl I word;

   call WRITE(0,.('ERROR, NEAR #, ',CR,LF),17,.STATUS);
   call WRITE(0,.COMMAND$LINE, PTR1 - .COMMAND$LINE, .STATUS);
   call WRITE(0,.('#'),1,.STATUS);
   call WRITE(0,.COMMAND$LINE(PTR1 - .COMMAND$LINE), COMMAND$LINE$LENGTH -
                    (PTR1 - .COMMAND$LINE), .STATUS);
   call WRITE(0,.(CR,LF),2,.STATUS);

   I = 0;
   whilee STRING(I) <> 0;
      I = I + 1;
   endwhile;
   if I <> 0 thenn
      call WRITE(0,STRING$PTR,I,.STATUS);
      call WRITE(0,.(CR,LF),2,.STATUS);
   endif;
   call EXIT;
end ERROR;

SIGN$ON: procedure(VERSION$PTR);
   dcl VERSION$PTR pointer;
   dcl STATUS word;

   call WRITE(0,.(CR,LF,'ISIS-II HARD-DISK BACKUP PROGRAM, '),36,.STATUS);
   call WRITE(0,VERSION$PTR,4,.STATUS);
   call WRITE(0,.(CR,LF),2,.STATUS);
end SIGN$ON;

DEBLANK: procedure(PTR1) pointer;
   dcl PTR1 pointer;
   dcl CHAR1 based PTR1 character;

   do while CHAR1 = ' ';
      PTR1 = PTR1 + 1;
   enddo;
   return PTR1;
endproc DEBLANK;

SCAN$BLANK: procedure(PTR1) pointer;
   dcl PTR1 pointer;
   dcl CHAR1 based PTR1 character;

   whilee CHAR1 <> ' ' and CHAR1 <> CR;
      PTR1 = PTR1 + 1;
   endwhile;
   return PTR1;
endproc SCAN$BLANK;

GET$DEVICE: procedure(PTR1) pointer;
   dcl PTR1 pointer;
   dcl CHAR1 based PTR1 character;
   dcl DEFAULT$DEVICE(*) character data(':F0:');

   if CHAR1 = ':' thenn
      call move(length(BACKUP$PARM$BLOCK.DEVICE), PTR1, .BACKUP$PARM$BLOCK.DEVICE);
      PTR1 = PTR1 + 2;
      if CHAR1 >= '0' and CHAR1 <= '9' thenn
         SELECTED$DEVICE(CHAR1 - '0') = true;
      endif;
      PTR1 = PTR1 + 2;
   elsee
      call move(length(DEFAULT$DEVICE), .DEFAULT$DEVICE, .BACKUP$PARM$BLOCK.DEVICE);
      SELECTED$DEVICE(0) = true;
   endif;
   return PTR1;
endproc GET$DEVICE;

GET$FILENAME: procedure(PTR1) pointer;
   dcl PTR1 pointer;
   dcl CHAR1 based PTR1 character;
   dcl NULLS(*) character data(0,0,0,0,0,0,0,0,0,0,0,0);
   dcl INDEX byte;
   dcl DEFAULT$FILES(*) character data('*.*',0);

   call move(length(BACKUP$PARM$BLOCK.FILENAME), .NULLS,
                   .BACKUP$PARM$BLOCK.FILENAME);
   INDEX = 0;
   whilee true;
      if (CHAR1 >= 'A' and CHAR1 <= 'Z') or
         (CHAR1 >= 'a' and CHAR1 <= 'z') or
         (CHAR1 >= '0' and CHAR1 <= '9') or
         CHAR1 = '*' or CHAR1 = '.' or CHAR1 = '?' thenn
         BACKUP$PARM$BLOCK.FILENAME(INDEX) = CHAR1;
      elsee
         if INDEX = 0 thenn /* no files specified, use *.* */
            call move(length(DEFAULT$FILES), .DEFAULT$FILES,
                        .BACKUP$PARM$BLOCK.FILENAME);
         endif;
         return PTR1;
      endif;
      PTR1 = PTR1 + 1;
      INDEX = INDEX + 1;
   endwhile;
   return PTR1;
endproc GET$FILENAME;

COLLECT$ATTRIBUTES: procedure(PTR1) pointer;
   dcl PTR1 pointer;
   dcl CHAR1 based PTR1 character;

   BACKUP$PARM$BLOCK.W$ATTR, BACKUP$PARM$BLOCK.S$ATTR,
        BACKUP$PARM$BLOCK.I$ATTR, BACKUP$PARM$BLOCK.CHANGE$W,
        BACKUP$PARM$BLOCK.CHANGE$S, BACKUP$PARM$BLOCK.CHANGE$I = 0;
   PTR1 = DEBLANK(PTR1);
   whilee true;
      if CHAR1 = 'W' or CHAR1 = 'w' thenn
         if BACKUP$PARM$BLOCK.W$ATTR <> 0 thenn
            call ERROR(.('ERROR -- W ATTRIBUTE ALREADY SPECIFIED',0), PTR1);
         endif;
         PTR1 = DEBLANK(PTR1 + 1);
         if CHAR1 = '1' thenn
            BACKUP$PARM$BLOCK.W$ATTR = true;
         elseif CHAR1 = '0' thenn
            BACKUP$PARM$BLOCK.W$ATTR = 80H;
         elseif CHAR1 = '?' or CHAR1 = '*' thenn
            BACKUP$PARM$BLOCK.W$ATTR = 0;
         elsee
            call ERROR(.('ERROR -- INVALID ATTRIBUTE VALUE',0), PTR1);
         endif;
         PTR1 = DEBLANK(PTR1 + 1);
         if CHAR1 = '=' thenn  /* attribute reset */
            PTR1 = DEBLANK(PTR1 + 1);
            if CHAR1 = '1' thenn
               BACKUP$PARM$BLOCK.CHANGE$W = true;
            elseif CHAR1 = '0' thenn
               BACKUP$PARM$BLOCK.CHANGE$W = 80H;
            elsee
               BACKUP$PARM$BLOCK.CHANGE$W = 0;
               call ERROR(.('ERROR -- INVALID ATTRIBUTE VALUE',0), PTR1);
            endif;
            PTR1 = DEBLANK(PTR1 + 1);
         elsee
            BACKUP$PARM$BLOCK.CHANGE$W = 0;
         endif;
      elseif CHAR1 = 'S' or CHAR1 = 's' thenn
         if BACKUP$PARM$BLOCK.S$ATTR <> 0 thenn
            call ERROR(.('ERROR -- S ATTRIBUTE ALREADY SPECIFIED',0), PTR1);
         endif;
         PTR1 = DEBLANK(PTR1 + 1);
         if CHAR1 = '1' thenn
            BACKUP$PARM$BLOCK.S$ATTR = true;
         elseif CHAR1 = '0' thenn
            BACKUP$PARM$BLOCK.S$ATTR = 80H;
         elseif CHAR1 = '?' or CHAR1 =  '*' thenn
            BACKUP$PARM$BLOCK.S$ATTR = 0;
         elsee
            call ERROR(.('ERROR -- INVALID ATTRIBUTE VALUE',0), PTR1);
         endif;
         PTR1 = DEBLANK(PTR1 + 1);
         if CHAR1 = '=' thenn  /* attribute reset */
            PTR1 = DEBLANK(PTR1 + 1);
            if CHAR1 = '1' thenn
               BACKUP$PARM$BLOCK.CHANGE$S = true;
            elseif CHAR1 = '0' thenn
               BACKUP$PARM$BLOCK.CHANGE$S = 80H;
            elsee
               BACKUP$PARM$BLOCK.CHANGE$S = 0;
               call ERROR(.('ERROR -- INVALID ATTRIBUTE VALUE',0), PTR1);
            endif;
            PTR1 = DEBLANK(PTR1 + 1);
         elsee
            BACKUP$PARM$BLOCK.CHANGE$S = 0;
         endif;
      elseif CHAR1 = 'I' or CHAR1 = 'i' thenn
         if BACKUP$PARM$BLOCK.I$ATTR <> 0 thenn
            call ERROR(.('ERROR -- I ATTRIBUTE ALREADY SPECIFIED',0), PTR1);
         endif;
         PTR1 = DEBLANK(PTR1 + 1);
         if CHAR1 = '1' thenn
            BACKUP$PARM$BLOCK.I$ATTR = true;
         elseif CHAR1 = '0' thenn
            BACKUP$PARM$BLOCK.I$ATTR = 80H;
         elseif CHAR1 = '?' or CHAR1 = '*' thenn
            BACKUP$PARM$BLOCK.I$ATTR = 0;
         elsee
            call ERROR(.('ERROR -- INVALID ATTRIBUTE VALUE',0), PTR1);
         endif;
         PTR1 = DEBLANK(PTR1 + 1);
         if CHAR1 = '=' thenn  /* attribute reset */
            PTR1 = DEBLANK(PTR1 + 1);
            if CHAR1 = '1' thenn
               BACKUP$PARM$BLOCK.CHANGE$I = true;
            elseif CHAR1 = '0' thenn
               BACKUP$PARM$BLOCK.CHANGE$I = 80H;
            elsee
               BACKUP$PARM$BLOCK.CHANGE$I = 0;
               call ERROR(.('ERROR -- INVALID ATTRIBUTE VALUE',0), PTR1);
            endif;
            PTR1 = DEBLANK(PTR1 + 1);
         elsee
            BACKUP$PARM$BLOCK.CHANGE$I = 0;
         endif;
      elsee
         return PTR1;
      endif;
   endwhile;
endproc COLLECT$ATTRIBUTES;

COLLECT$OUTPUT$LIST: procedure(PTR1) pointer;
   dcl PTR1 pointer;
   dcl CHAR1 based PTR1 character;
   dcl OUTPUT$LIST$INDEX byte;

   if CHAR1 = 'T' or CHAR1 = 't' thenn
      PTR1 = PTR1 + 1;
      if CHAR1 = 'O' or CHAR1 = 'o' thenn
         PTR1 = DEBLANK(PTR1 + 1);
         if not(CHAR1 >= '0' and CHAR1 <= '9') thenn
             call ERROR(.('DEVICE DIGIT EXPECTED',0), PTR1);
         endif;
         OUTPUT$LIST$INDEX = 0;
         whilee CHAR1 >= '0' and CHAR1 <= '9';
            if SELECTED$DEVICE(CHAR1 - '0') thenn
               call ERROR(.('DEVICE ALREADY SELECTED',0), PTR1);
            elsee
               SELECTED$DEVICE(CHAR1 - '0') = true;
               if OUTPUT$LIST$INDEX > last(BACKUP$PARM$BLOCK.OUTPUT$LIST) thenn
                  call ERROR(.('MAXIMUM OF 4 OUTPUT DEVICES EXCEEDED',0), PTR1);
               elsee
                  BACKUP$PARM$BLOCK.OUTPUT$LIST(OUTPUT$LIST$INDEX) = CHAR1;
                  BACKUP$PARM$BLOCK.OUTPUT$LIST$ELEMENTS = OUTPUT$LIST$INDEX;
                  OUTPUT$LIST$INDEX = OUTPUT$LIST$INDEX + 1;
               endif;
            endif;
            PTR1 = DEBLANK(PTR1 + 1);
            if CHAR1 = ',' thenn
               PTR1 = DEBLANK(PTR1 + 1);
            endif;
         endwhile;
      elsee
         call ERROR(.('"TO" EXPECTED',0), PTR1);
      endif;
   elsee
      BACKUP$PARM$BLOCK.OUTPUT$LIST$ELEMENTS = 0;
      BACKUP$PARM$BLOCK.OUTPUT$LIST(0) = '5';
   endif;
   return PTR1;
endproc COLLECT$OUTPUT$LIST;

COLLECT$DELETE$OPTION: procedure(PTR1) pointer;
   dcl PTR1 pointer;
   dcl PTR2 pointer;
   dcl CHAR based PTR2 character;
   dcl D$STRING(*) character data('DELETE');
   dcl I byte;

   DELETE$OPTION = false;
   PTR2 = DEBLANK(PTR1);
   for I = 0 to length(D$STRING)-1;
      if D$STRING(I) = CHAR thenn
         PTR2 = PTR2 + 1;
      elsee
         return PTR1;
      endif;
   endfor;
   DELETE$OPTION = true;
   return PTR2;
end COLLECT$DELETE$OPTION;

VERIFY$END$OF$LINE: procedure(PTR1);
   dcl PTR1 pointer;
   dcl CHAR1 based PTR1 character;

   PTR1 = DEBLANK(PTR1);
   if (CHAR1 <> CR) and (CHAR1 <> LF) and (CHAR1 <> ESC) thenn
      call ERROR(.('BAD SYNTAX',0), PTR1);
   endif;
endproc VERIFY$END$OF$LINE;

UPPER$CASE: procedure(PTR1);
   dcl PTR1 pointer;
   dcl CHAR based PTR1 character;

   do while not ((CHAR = CR) or (CHAR = ESC) or (CHAR = LF));
      if (CHAR >= 'a') and (CHAR <= 'z') thenn
         CHAR = CHAR - 20H;
      endif;
      PTR1 = PTR1 + 1;
   enddo;

end UPPER$CASE;

BACKUP$FILES: procedure(COMMAND$PTR) external;
   dcl COMMAND$PTR pointer;
end BACKUP$FILES;

call SIGN$ON(.VERSION);
call READ(1,.COMMAND$LINE, length(COMMAND$LINE), .COMMAND$LINE$LENGTH, .STATUS);
call UPPER$CASE(.COMMAND$LINE);
COMMAND$PTR = DEBLANK(.COMMAND$LINE);
COMMAND$PTR = GET$DEVICE(COMMAND$PTR);
COMMAND$PTR = GET$FILENAME(COMMAND$PTR);
COMMAND$PTR = DEBLANK(COMMAND$PTR);
COMMAND$PTR = COLLECT$ATTRIBUTES(COMMAND$PTR);
COMMAND$PTR = COLLECT$OUTPUT$LIST(COMMAND$PTR);
COMMAND$PTR = COLLECT$DELETE$OPTION(COMMAND$PTR);
call VERIFY$END$OF$LINE(COMMAND$PTR);
call BACKUP$FILES(.BACKUP$PARM$BLOCK);
call WRITE(0,.(CR,LF),2,.STATUS);
call EXIT;

end HARD$DISK$BACKUP;
src/if.plm
IF$MOD: DO;

/************************************************************************/
/*																		*/
/*      '(C) Intel Corporation 1981'.  All rights reserved.  No			*/
/*      part of this program or publication may be reproduced,			*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

DECLARE COPYRIGHT (*) BYTE DATA ('(C) INTEL CORP 1981');

DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.0',0);

DECLARE	LIT		LITERALLY	'LITERALLY',
		DCL		LIT	'DECLARE',
		TRUE	LIT	'0FFH',
		FALSE	LIT	'000H',
		PROC	LIT	'PROCEDURE',
		PROCEND	LIT	'END',
		THENDO	LIT	'THEN DO;',
		ELSEIF	LIT	'END; ELSE IF',
		ELSEDO	LIT	'END; ELSE DO;',
		IFEND	LIT	'END',
		WHILEND	LIT	'END',
		CR		LIT	'0DH',
		LF		LIT	'0AH';

EXIT:	PROC EXTERNAL;											PROCEND;
OPEN:	PROC (A,B,C,D,E) EXTERNAL;	DCL (A,B,C,D,E) ADDRESS;	PROCEND;
READ:	PROC (A,B,C,D,E) EXTERNAL;	DCL (A,B,C,D,E) ADDRESS;	PROCEND;
WRITE:	PROC (A,B,C,D) EXTERNAL;	DCL (A,B,C,D) ADDRESS;		PROCEND;
CLOSE:	PROC (A,B) EXTERNAL;		DCL (A,B) ADDRESS;			PROCEND;
SPATH:	PROC (A,B,C) EXTERNAL;		DCL (A,B,C) ADDRESS;		PROCEND;
UNPATH:	PROC (A,B) EXTERNAL;		DCL (A,B) ADDRESS;			PROCEND;
MEMCK:	PROC ADDRESS EXTERNAL;									PROCEND;
DEBLANK:PROC (A) ADDRESS EXTERNAL;	DCL (A) ADDRESS;			PROCEND;
DELIMIT:PROC (A) ADDRESS EXTERNAL;	DCL (A) ADDRESS;			PROCEND;
SEQ:	PROC (A,B,C) BYTE EXTERNAL;	DCL (A,B,C) ADDRESS;		PROCEND;
FORCE$UPPER:	PROC(A) EXTERNAL;	DCL (A) ADDRESS;			PROCEND;

DCL (STATUS, ACTUAL, AFTN1, AFTN2) ADDRESS;
DCL (CMND, CMND$PTR) ADDRESS, (CMND$CH BASED CMND$PTR) (1) BYTE;
DCL (STRING1, LEN1, STRING2, LEN2) ADDRESS;
DCL (STRING1$CH BASED STRING1, STRING2$CH BASED STRING2) (1) BYTE;
DCL (BUFFER1, BUFFER2) ADDRESS;
DCL (FILE1, FILE2) (15) BYTE;
DCL (PN1, PN2) STRUCTURE
	(DEV BYTE, NAME (6) BYTE, EXT (3) BYTE, DEV$TYPE BYTE, DRIVE$TYPE BYTE);
DCL (BUFSIZE) ADDRESS;
DCL (NOT$FOUND, TEST) BYTE;
DCL (MSG) (*) BYTE DATA ('<file> or <string>');

FIND$ELSE: PROC;
DCL (IFF) (*) BYTE DATA ('IF', 0, 0, 0, 0, 0, 0, 0);
DCL (NESTED$IF) ADDRESS;
	NESTED$IF = 0;
	DO WHILE TRUE;
		CALL WRITE (0, .('#'), 1, .STATUS);
		CALL READ (1, .MEMORY, 128, .ACTUAL, .STATUS);
		IF (STATUS <> 0) OR (ACTUAL = 0) THENDO
			CALL EXIT; /* Probably hit the end of the command file. */
		IFEND;
		MEMORY (ACTUAL - 1) = CR;
		CALL FORCE$UPPER (.MEMORY);
		CMND$PTR = DEBLANK (.MEMORY);
		IF SEQ (CMND$PTR, .('DEBUG '), 6) THENDO
			CMND$PTR = DEBLANK (CMND$PTR + 5); /* Skip the DEBUG. */
		IFEND;
		CALL SPATH (CMND$PTR, .PN1, .STATUS);
		IF STATUS = 0 THENDO
			IF SEQ (.PN1.NAME, .IFF, 9) THENDO /* A nested IF. */
				NESTED$IF = NESTED$IF + 1;
			ELSEIF SEQ (.PN1.NAME, .('ELSE', 0, 0, 0, 0, 0), 9) THENDO
				IF NESTED$IF = 0 THENDO /* Not part of a nested IF. */
					CMND$PTR = DEBLANK (DELIMIT (CMND$PTR));
					CALL SPATH (CMND$PTR, .PN1, .STATUS);
					IF STATUS = 0 THENDO
						IF SEQ (.PN1.NAME, .IFF, 9) THENDO /* Found ELSE IF. */
							CMND = DELIMIT (CMND$PTR);
							GOTO RESTART; /* Go process the IF command. */
						IFEND;
					IFEND;
					CALL EXIT; /* Continue with the ELSE part. */
				IFEND;
			ELSEIF SEQ (.PN1.NAME, .('ENDIF', 0, 0, 0, 0), 9) THENDO
				IF NESTED$IF = 0 THENDO
					CALL EXIT; /* Continue with the ENDIF part. */
				IFEND;
				NESTED$IF = NESTED$IF - 1;
			IFEND;
		IFEND;
	WHILEND;
PROCEND FIND$ELSE;

DOIT: PROC;
	IF NOT$FOUND THENDO
		TEST = NOT TEST;
	IFEND;
	IF TEST THENDO
		CALL EXIT;
	ELSEDO
		CALL FIND$ELSE;
	IFEND;
PROCEND DOIT;

FILE$EXISTS: PROC;
	CALL OPEN (.AFTN1, .FILE1, 1, 0, .STATUS);
	IF STATUS = 0 THENDO /* The file exists, now check its length. */
		CALL READ (AFTN1, .MEMORY, 1, .ACTUAL, .STATUS);
		TEST = (STATUS = 0) AND (ACTUAL > 0);
		CALL CLOSE (AFTN1, .STATUS);
	IFEND;
	CALL DOIT;
PROCEND FILE$EXISTS;

STRING$COMPARE: PROC;
	IF LEN1 <> LEN2 THENDO
		TEST = FALSE;
	ELSEDO
		TEST = SEQ (STRING1, STRING2, LEN1);
	IFEND;
	CALL DOIT;
PROCEND STRING$COMPARE;

STRING$EQUALS$FILE: PROC;
	CALL MOVE (LEN1, STRING1, .MEMORY); /* Save the string. */
	STRING1 = .MEMORY;
	STRING2 = .MEMORY + LEN1;
	CALL OPEN (.AFTN2, .FILE2, 1, 0, .STATUS);
	IF STATUS <> 0 THENDO
		CALL DOIT;
	IFEND;
	CALL READ (AFTN2, STRING2, LEN1, .LEN2, .STATUS); /* Read in file. */
	CALL CLOSE (AFTN2, .STATUS); /* No need to check status of read. */
	CALL STRING$COMPARE;
PROCEND STRING$EQUALS$FILE;

FILE$COMPARE: PROC;

	STOP: PROC;
		CALL CLOSE (AFTN1, .STATUS);
		CALL CLOSE (AFTN2, .STATUS);
		CALL DOIT;
	PROCEND STOP;

	IF SEQ (.PN1, .PN2, 10) THENDO /* Path names the same, assume equal. */
		TEST = TRUE;
		CALL DOIT;
	IFEND;
	BUFSIZE = SHR (BUFSIZE, 1); /* Divide it into two equal pieces. */
	BUFFER2 = BUFFER1 + BUFSIZE;
	CALL OPEN (.AFTN1, .FILE1, 1, 0, .STATUS);
	IF STATUS <> 0 THENDO
		CALL STOP;
	IFEND;
	CALL OPEN (.AFTN2, .FILE2, 1, 0, .STATUS);
	IF STATUS <> 0 THENDO
		CALL STOP;
	IFEND;
	DO WHILE TRUE;
		CALL READ (AFTN1, BUFFER1, BUFSIZE, .LEN1, .STATUS);
		IF STATUS <> 0 THENDO
			CALL STOP;
		IFEND;
		CALL READ (AFTN2, BUFFER2, BUFSIZE, .LEN2, .STATUS);
		IF STATUS <> 0 THENDO
			CALL STOP;
		IFEND;
		IF LEN1 <> LEN2 THENDO
			CALL STOP;
		IFEND;
		IF LEN1 = 0 THENDO
			TEST = TRUE;
			CALL STOP;
		IFEND;
		IF NOT SEQ (BUFFER1, BUFFER2, LEN1) THENDO
			CALL STOP;
		IFEND;
	WHILEND;
PROCEND FILE$COMPARE;

STRING$IN$STRING: PROC;
	IF (LEN1 = 0) OR (LEN2 = 0) THENDO /* Null string as operand always true. */
		TEST = TRUE;
		CALL DOIT;
	IFEND;
	DO WHILE TRUE;
		DO WHILE STRING2$CH (0) <> STRING1$CH (0);
			STRING2 = STRING2 + 1;
			LEN2 = LEN2 - 1;
			IF LEN2 = 0 THENDO /* Hit the end of the string. */
				CALL DOIT;
			IFEND;
		WHILEND;
		IF LEN2 < LEN1 THENDO
			CALL DOIT; /* Not enough chars left in right string. */
		IFEND;
		IF SEQ (STRING2, STRING1, LEN1) THENDO
			TEST = TRUE;
			CALL DOIT;
		IFEND;
		STRING2 = STRING2 + 1;
		LEN2 = LEN2 - 1; /* LEN2 must be >= 1, hence no need to check. */
	WHILEND;
PROCEND STRING$IN$STRING;

STRING$IN$FILE: PROC;
DCL (WHATS$LEFT) ADDRESS;

	CHECK$STATUS: PROC (LEN);
	DCL (LEN) ADDRESS;
		IF (STATUS <> 0) OR (LEN < LEN1) THENDO
			CALL CLOSE (AFTN2, .STATUS);
			CALL DOIT;
		IFEND;
		BUFFER1 = BUFFER2 + LEN;
		CMND$PTR = BUFFER2;
	PROCEND CHECK$STATUS;

	IF LEN1 = 0 THENDO /* Looking for a null string. */
		TEST = TRUE;
		CALL DOIT;
	IFEND;
	CALL MOVE (LEN1, STRING1, .MEMORY); /* Save the string. */
	STRING1 = .MEMORY;
	BUFFER2 = BUFFER2 + LEN1;
	BUFSIZE = BUFSIZE - LEN1;
	CALL OPEN (.AFTN2, .FILE2, 1, 0, .STATUS);
	IF STATUS <> 0 THENDO
		CALL DOIT;
	IFEND;
	CALL READ (AFTN2, BUFFER2, BUFSIZE, .ACTUAL, .STATUS);
	CALL CHECK$STATUS (ACTUAL);
	DO WHILE TRUE;
		DO WHILE CMND$CH (0) <> STRING1$CH (0);
			CMND$PTR = CMND$PTR + 1;
			IF CMND$PTR = BUFFER1 THENDO /* Hit the end of the buffer. */
				CALL READ (AFTN2, BUFFER2, BUFSIZE, .ACTUAL, .STATUS);
				CALL CHECK$STATUS (ACTUAL);
			IFEND;
		WHILEND;
		WHATS$LEFT = BUFFER1 - CMND$PTR;
		IF WHATS$LEFT < LEN1 THENDO /* Not enough bytes left in buffer. */
			CALL MOVE (WHATS$LEFT, CMND$PTR, BUFFER2);
			CALL READ (AFTN2, BUFFER2 + WHATS$LEFT, BUFSIZE - WHATS$LEFT, .ACTUAL, .STATUS);
			CALL CHECK$STATUS (ACTUAL + WHATS$LEFT);
		IFEND;
		IF SEQ (CMND$PTR, STRING1, LEN1) THENDO
			TEST = TRUE;
			CALL CLOSE (AFTN2, .STATUS);
			CALL DOIT;
		IFEND;
		CMND$PTR = CMND$PTR + 1;
	WHILEND;
PROCEND STRING$IN$FILE;

CMND$ERROR: PROC (MSG, MSGLEN);
DCL (MSG, MSGLEN) ADDRESS;
	CALL WRITE (0, .('Command tail error near #: '), 27, .STATUS);
	CALL WRITE (0, MSG, MSGLEN, .STATUS);
	CALL WRITE (0, .(' expected.', CR, LF), 12, .STATUS);
	CALL WRITE (0, .MEMORY, CMND$PTR - .MEMORY, .STATUS);
	CALL WRITE (0, .('#', CR, LF), 3, .STATUS);
	CALL EXIT;
PROCEND CMND$ERROR;

SCAN$STRING: PROC (STRING$PTR, LEN$PTR) BYTE;
DCL (STRING$PTR, LEN$PTR) ADDRESS,
	(STRING BASED STRING$PTR, LEN BASED LEN$PTR) ADDRESS,
	(CH) BYTE;
	CH = CMND$CH (0);
	IF (CH <> '''') AND (CH <> '"') THENDO /* Not a string. */
		RETURN FALSE;
	IFEND;
	CMND$PTR, STRING = CMND$PTR + 1;
	DO WHILE CMND$CH (0) <> CH;
		CMND$PTR = CMND$PTR + 1;
	WHILEND;
	LEN = CMND$PTR - STRING;
	CMND$PTR = DEBLANK (CMND$PTR + 1);
	RETURN TRUE;
PROCEND SCAN$STRING;

SCAN$FILE: PROC (FILE$PTR, PN$PTR) BYTE;
DCL (FILE$PTR, PN$PTR) ADDRESS;
	CALL SPATH (CMND$PTR, PN$PTR, .STATUS);
	IF STATUS <> 0 THENDO
		RETURN FALSE;
	IFEND;
	CALL UNPATH (PN$PTR, FILE$PTR);
	CMND$PTR = DEBLANK (DELIMIT (CMND$PTR));
	RETURN TRUE;
PROCEND SCAN$FILE;

/* Read in the initial command line. */
CALL READ (1, (CMND := .MEMORY), 128, .ACTUAL, .STATUS);

RESTART: /* The restart point for the ELSE IF command. */

MEMORY (ACTUAL - 1) = CR;
CMND$PTR = CMND;
DO WHILE CMND$CH (0) <> CR;
	IF CMND$CH (0) = '&' THENDO
		CMND$CH (0) = ' ';
		CALL WRITE (0, .('**'), 2, .STATUS);
		CALL READ (1, CMND$PTR + 1, 128, .ACTUAL, .STATUS);
		CMND$CH (ACTUAL) = CR;
	IFEND;
	CMND$PTR = CMND$PTR + 1;
WHILEND;
CALL FORCE$UPPER (.MEMORY);

BUFSIZE = MEMCK - .MEMORY;
BUFFER1, BUFFER2 = .MEMORY;
/* Scan the command line. */
STRING1, STRING2, FILE1 (0), FILE2 (0) = 0;
NOT$FOUND, TEST = FALSE;
CMND$PTR = DEBLANK (CMND);
IF SEQ (CMND$PTR, .('NOT '), 4) THENDO
	NOT$FOUND = TRUE;
	CALL MOVE (8, .(':F0:NOT '), .FILE1); /* In case it was a file name. */
	CALL SPATH (.FILE1, .PN1, .STATUS);
	CMND$PTR = DEBLANK (CMND$PTR + 4);
IFEND;
IF CMND$CH (0) = CR THENDO /* Only a null command line or 'NOT' was found. */
	IF NOT NOT$FOUND THENDO /* Nothing on the command tail. */
		CALL WRITE (0, .('ISIS-II IF V0.1', CR, LF), 17, .STATUS);
		CALL EXIT;
	IFEND;
	NOT$FOUND = FALSE; /* The first parameter is the file 'NOT'. */
	CALL FILE$EXISTS; /* See if the file 'NOT' exists. */
ELSEIF CMND$CH (0) = '=' THENDO /* It better be preceded by 'NOT'. */
	IF NOT NOT$FOUND THENDO
		CALL CMND$ERROR (.MSG, 18);
	IFEND;
	NOT$FOUND = FALSE; /* The 'NOT' was a file name. */
	CMND$PTR = DEBLANK (CMND$PTR + 1);
	IF SCAN$FILE (.FILE2, .PN2) THENDO
		CALL FILE$COMPARE;
	ELSEDO
		CALL CMND$ERROR (.MSG, 6);
	IFEND;
ELSEIF SCAN$STRING (.STRING1, .LEN1) THENDO /* We have a string. */
	IF CMND$CH (0) = '=' THENDO
		CMND$PTR = DEBLANK (CMND$PTR + 1);
		IF SCAN$STRING (.STRING2, .LEN2) THENDO /* We have two strings. */
			CALL STRING$COMPARE;
		ELSEIF SCAN$FILE (.FILE2, .PN2) THENDO /* It's a file name. */
			CALL STRING$EQUALS$FILE;
		ELSEDO
			CALL CMND$ERROR (.MSG, 18);
		IFEND;
	ELSEIF SEQ (CMND$PTR, .('IN '), 3) THENDO
		CMND$PTR = DEBLANK (CMND$PTR + 2);
		IF SCAN$STRING (.STRING2, .LEN2) THENDO /* We have two strings. */
			CALL STRING$IN$STRING;
		ELSEIF SCAN$FILE (.FILE2, .PN2) THENDO /* It's a file name. */
			CALL STRING$IN$FILE;
		ELSEDO
			CALL CMND$ERROR (.MSG, 18);
		IFEND;
	ELSEDO /* Not '=' and not 'IN', command's in error. */
		CALL CMND$ERROR (.('''='' or ''IN'''), 11);
	IFEND;
ELSEIF SCAN$FILE (.FILE1, .PN1) THENDO /* Better be file name. */
	IF CMND$CH (0) = '=' THENDO /* We have more. */
		CMND$PTR = DEBLANK (CMND$PTR + 1);
		IF SCAN$FILE (.FILE2, .PN2) THENDO /* And it better be a file name. */
			CALL FILE$COMPARE;
		ELSEDO
			CALL CMND$ERROR (.MSG, 6);
		IFEND;
	IFEND;
	CALL FILE$EXISTS; /* Ignore rest of command, assume file test only. */
ELSEDO
	CALL CMND$ERROR (.MSG, 18);
IFEND;
CALL EXIT;

END IF$MOD;
src/last.plm
LAST: DO;


/************************************************************************/
/*																		*/
/*      '(C) Intel Corporation 1981'.  All rights reserved.  No			*/
/*      part of this program or publication may be reproduced,			*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

      
DECLARE COPYRIGHT (*) BYTE DATA ('(C) INTEL CORP 1981');

DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.0',0);
    


$NOLIST
/* PEX */
MAX :PROCEDURE (ZZ1,ZZ2)ADDRESS EXTERNAL;DECLARE (ZZ1,ZZ2)ADDRESS;END;
DECLARE FATAL BYTE EXTERNAL;
DECLARE ACTUAL ADDRESS EXTERNAL;
DECLARE BLOKNO ADDRESS EXTERNAL;
DECLARE BYTENO ADDRESS EXTERNAL;
CLOSEI :PROCEDURE  EXTERNAL;END;
DECLARE ENDOFFILE LITERALLY'7FFFH';
EX :PROCEDURE  EXTERNAL;END;
OPENI :PROCEDURE (ZZ1) EXTERNAL;DECLARE (ZZ1)ADDRESS;END;
READC :PROCEDURE (ZZ1,ZZ2) EXTERNAL;DECLARE (ZZ1,ZZ2)ADDRESS;END;
READI :PROCEDURE (ZZ1,ZZ2) EXTERNAL;DECLARE (ZZ1,ZZ2)ADDRESS;END;
SBYTEI :PROCEDURE (ZZ1) EXTERNAL;DECLARE (ZZ1)ADDRESS;END;
WRITEC :PROCEDURE (ZZ1,ZZ2) EXTERNAL;DECLARE (ZZ1,ZZ2)ADDRESS;END;
DECLARE TRUE LITERALLY'255';
/* ENDPEX */
$LIST

/********************************************************/
/*														*/
/*			FIRST				EXECUTABLE				*/
/*														*/
/********************************************************/


FATAL = TRUE;
CALL READC(.MEMORY,128);
CALL OPENI(.MEMORY);
CALL SBYTEI(END$OF$FILE);
CALL SBYTEI(0);
CALL SBYTEI(MAX(-512,-(BLOKNO*128+BYTENO)));
CALL READI(.MEMORY,512);
CALL CLOSEI;
CALL WRITEC(.MEMORY,ACTUAL);
CALL EX;

END LAST;
src/latest.plm
LATEST$MOD:
DO;

/************************************************************************/
/*																		*/
/*      '(C) Intel Corporation 1981'.  All rights reserved.  No			*/
/*      part of this program or publication may be reproduced,			*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

DECLARE COPYRIGHT (*) BYTE DATA ('(C) INTEL CORP 1981');

DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.0',0);

DECLARE LIT     LITERALLY 'LITERALLY',
        DCL     LIT       'DECLARE',
        TRUE    LIT       '0FFH',
        FALSE   LIT       '000H',
        PROC    LIT       'PROCEDURE',
        ENDPROC LIT       'END;',
        THENN   LIT       'THEN DO;',
        ELLSE   LIT       'END; ELSE DO;',
        ELSIF   LIT       'END; ELSE IF',
        ENDIF   LIT       'END;',
        ENDDO   LIT       'END;',
        CR      LIT       '0DH',
        LF      LIT       '0AH',
        CRLF    LIT       '0DH,0AH',
        CHK     LIT       'CALL CHECK$ISIS$STATUS(STATUS)',
        NULL    LIT       '0',
        TOEND   LIT       '7FFFH',
        TOBEG   LIT       '08000H'
        ;

DCL     PCNT$0$TYPE         LIT '0',
        PCNT$0$DOT$TYPE     LIT '1',
        PCNT$0$DOT$EXT$TYPE LIT '2',
        NUMB$0$TYPE         LIT '3';

DCL     NAME$DOT$TYPE       LIT  '0',
        NAME$DOT$EXT$TYPE   LIT  '1',
        NAME$ONLY$TYPE      LIT  '2';

DCL     UNKNOWN$TYPE        LIT  '10';

DCL     NAME$ADDED          LIT  '1',
        NEW$LINE            LIT  '3',
        DONE                LIT  '0';

DCL NO$NUM$EXTENSION        LIT  '0';

EXIT:   PROC             EXTERNAL;                                        END;
CO:     PROC (CHR)       EXTERNAL; DCL  CHR         BYTE;                 END;
READC:  PROC (PTR,LEN)   EXTERNAL; DCL (PTR,LEN)    ADDRESS;              END;
READ1:  PROC (PTR,LEN)   EXTERNAL; DCL (PTR,LEN)    ADDRESS;              END;
OPEN1:  PROC (PTR,MO)    EXTERNAL; DCL  PTR ADDRESS,MO BYTE;              END;
CLOSE1: PROC             EXTERNAL;                                        END;
SCANMATCH: PROC(P)BYTE   EXTERNAL; DCL  P           ADDRESS;              END;
SCAN$WHILE:PROC(P)       EXTERNAL; DCL  P           ADDRESS;              END;
TERM$CH:   PROC   BYTE   EXTERNAL;                                        END;
OUT$CHAR:  PROC   (CHAR) EXTERNAL; DCL  CHAR        BYTE;                 END;
OUT$PRINT: PROC (PTR)    EXTERNAL; DCL  PTR         ADDRESS;              END;
OUT$DEC$R: PROC (VAL,W)  EXTERNAL; DCL  VAL ADDRESS, W BYTE;              END;
FMOVE: PROC (C,S,D)      EXTERNAL; DCL  (C,S,D)     ADDRESS;              END;
ABSIO: PROC (A,B,C,D)    EXTERNAL; DCL  (A,B) BYTE,(C,D) ADDRESS;         END;
ERROR: PROC (ERROR$NO)   EXTERNAL; DCL ERROR$NO ADDRESS;                  END;
MEM$CK: PROC ADDRESS     EXTERNAL;                                        END;
SPATH: PROC(FILE,BUFFER,STATUS) EXTERNAL;
       DCL (FILE,BUFFER,STATUS) ADDRESS;                                  END;
LOAD: PROC(FILE,BIAS,SWITCH,ENTRY,STATUS) EXTERNAL;
      DCL (FILE,BIAS,SWITCH,ENTRY,STATUS) ADDRESS;                        END;
GETD: PROC(DRIVE,CON,COUNT,ACTUAL$COUNT,BUFFER,STATUS)  EXTERNAL;
      DCL (DRIVE,CON,COUNT,ACTUAL$COUNT,BUFFER,STATUS)  ADDRESS;          END;
WRITE: PROC(AFTN,BUFFER,COUNT,STATUS) EXTERNAL;
       DCL (AFTN,BUFFER,COUNT,STATUS) ADDRESS;                            END;

DCL    (STATUS,REPORT,ERRED,FATAL,ACTUAL) ADDRESS EXTERNAL;
DCL    (SCANP,OBUFP)      ADDRESS EXTERNAL,
       LEADCHAR           BYTE    EXTERNAL;

DCL    SCANBYTE BASED SCANP BYTE,
       SCANP$TMP ADDRESS;

/*********************************************
    G L O B A L   S T R U C T U R E S
*********************************************/
DCL   NAMEINDEX ADDRESS INITIAL (0);
DCL   MAXINDEX  LIT '200';
DCL   NAME$LIST (MAXINDEX)     STRUCTURE ( DRIVE (4) BYTE,
                                           NAME  (6) BYTE,
                                           EXT   (3) BYTE,
                                           TYPE BYTE);

$EJECT
/*********************************************
       G L O B A L   V A R I A B L E S
*********************************************/

DCL READING$REMOTE BYTE;
DCL END$OF$DIRECTORY ADDRESS;
DCL MEM$TOP ADDRESS;
DCL CONNECTION ADDRESS INITIAL (0);
DCL MONITOR ADDRESS DATA (0);
DCL HALT$FLAG       BYTE INITIAL (FALSE);
DCL READBUF (129)   BYTE;
DCL MSG$BUF (128)   BYTE;
DCL BLANK$STR (16)  BYTE DATA('                ');
DCL NULLSTRING(16)  BYTE DATA(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
DCL NO$EXT$MSG (*) BYTE INITIAL(
'        has no numeric extension',CR,LF,0);
/*012345676890123456789012345678901234567890*/
DCL EXT$MSG    (*) BYTE  INITIAL(
 'greatest numeric extension is       .    ',CR,LF,0);
/*012345678901234567890123456789012345678901234567890*/

/*********************************************
     D I R E C T O R Y    G L O B A L S
*********************************************/
DCL DIR$TO$SEARCH BYTE;
DCL DIRECTORY$NAME (*) BYTE INITIAL(':F :ISIS.DIR ');
DCL DIR$BUF  (16384) BYTE;
DCL DIR$ENTRY$PTR ADDRESS,
    DIR$ENTRY BASED DIR$ENTRY$PTR STRUCTURE
                (PRESENCE BYTE,
                FILENAME (6) BYTE,
                EXTENSION (3) BYTE,
                ATTRIBUTES BYTE,
                EOF$COUNT BYTE,
                NUM$DATA$BLKS ADDRESS,
                HEADER$BLK$PTR ADDRESS);

$EJECT

/*********************************************
    C O M M O N      P R O C E D U R E S
*********************************************/

PRINT: PROC (PTR);
  DCL PTR ADDRESS,CHR BASED PTR BYTE;
  DO WHILE CHR <> NULL;
     CALL CO(CHR);
     PTR = PTR + 1;
  ENDDO
END PRINT;

PRINT$CR: PROC (PTR);
  DCL PTR ADDRESS;
  CALL PRINT(PTR);
  CALL PRINT(.(CR,LF,0));
END PRINT$CR;

PRINT$CR$EXIT: PROC (PTR);
  DCL PTR ADDRESS;
  CALL PRINT$CR(PTR);
  CALL EXIT;
END;

CHK$STATUS: PROC (PTR);
  DCL PTR ADDRESS;
  IF STATUS <> 0 THENN
     CALL PRINT(.('bad status ',0));
     CALL PRINT$CR$EXIT(PTR);
  ENDIF
END CHK$STATUS;

CHECK$ISIS$STATUS: PROC(ISIS$STATUS);
   DCL ISIS$STATUS ADDRESS;
   IF ISIS$STATUS <> 0  THEN
     DO;
       CALL ERROR(ISIS$STATUS);
       CALL MONITOR;
     END;
END CHECK$ISIS$STATUS;

DEBLANK: PROC (PTR) ADDRESS;
 DCL PTR ADDRESS,CHR BASED PTR BYTE;
 DO WHILE CHR = ' ';
  PTR = PTR + 1;
 ENDDO
 RETURN PTR;
END DEBLANK;

LESSER$OF: PROC (VAL1,VAL2) ADDRESS;
  DCL (VAL1,VAL2) ADDRESS;
  IF VAL1 > VAL2 THENN
     RETURN VAL2;
  ELLSE
     RETURN VAL1;
  ENDIF
END LESSER$OF;

LET$CH$WP:          PROC (CHAR) BYTE;
  DCL CHAR BYTE;
   RETURN
   ( (CHAR >= 'a' AND CHAR <= 'z') OR
     (CHAR >= 'A' AND CHAR <= 'Z')  );
END LET$CH$WP;

DIG$CH$WP:          PROC (CHAR) BYTE;
  DCL CHAR BYTE;
  RETURN ((CHAR >= '0' AND CHAR <= '9'));
END DIG$CH$WP;

LET$OR$DIG$CH$WP:   PROC (CHAR) BYTE;
  DCL CHAR BYTE;
  RETURN (LET$CH$WP(CHAR) OR DIG$CH$WP(CHAR));
END LET$OR$DIG$CH$WP;

DOT$CH$WP:          PROC (CHAR) BYTE;
  DCL CHAR BYTE;
  RETURN (CHAR = '.');
END DOT$CH$WP;

COLON$CH$WP:        PROC (CHAR) BYTE;
   DCL CHAR BYTE;
   RETURN (CHAR = ':');
END COLON$CH$WP;

FILE$CH$WP:          PROC (CHAR) BYTE;
   DCL CHAR BYTE;
   RETURN( LET$OR$DIG$CH$WP(CHAR) OR DOT$CH$WP(CHAR) OR COLON$CH$WP(CHAR));
END FILE$CH$WP;

BLANK$CH$WP:         PROC (CHAR) BYTE;
   DCL CHAR BYTE;
   RETURN (CHAR = ' ');
END BLANK$CH$WP;

LENGTH$OF:       PROC (PROC$PTR) ADDRESS;
  DCL (PROC$PTR,TMP$PTR,LEN) ADDRESS;
  TMP$PTR = SCANP;
  CALL SCANWHILE(PROC$PTR);
  LEN = SCANP - TMP$PTR;
  SCANP = TMP$PTR;
  RETURN LEN;
END LENGTH$OF;

LET$CH:          PROC BYTE;
  RETURN(LET$CH$WP(SCANBYTE));
END LET$CH;

DIG$CH:          PROC BYTE;
  RETURN(DIG$CH$WP(SCANBYTE));
END DIG$CH;

LET$OR$DIG$CH:   PROC BYTE;
  RETURN (LET$CH OR DIG$CH);
END LET$OR$DIG$CH;

DOT$CH:          PROC BYTE;
  RETURN (SCANBYTE = '.');
END DOT$CH;

COLON$CH:        PROC BYTE;
  RETURN (SCANBYTE = ':');
END COLON$CH;

FILE$CH:          PROC BYTE;
   RETURN(LET$CH OR DIG$CH OR DOT$CH OR COLON$CH);
END FILE$CH;

BLANK$CH:         PROC BYTE;
   RETURN(SCANBYTE = ' ');
END BLANK$CH;

NULL$CH:          PROC BYTE;
   RETURN (SCANBYTE = NULL);
END NULL$CH;

ENFORCE$NO$TOKENS: PROC;
  DO WHILE NOT TERM$CH          ;
     IF NOT  BLANK$CH  THENN
       CALL PRINT$CR$EXIT(.('only blanks allowed after &',0));
     ENDIF
     SCANP = SCANP + 1;
  ENDDO
END ENFORCE$NO$TOKENS;

$EJECT

/***********************************************************************
        A B S I O   F O R   R E A D I N G   I S I S . D I R
            assumes isis.dir is at track(1) sector(1)
***********************************************************************/

READ$ABSIO$DIR: PROC (DISK);
  DECLARE DISK BYTE;
  DECLARE DIR$ENTRY LITERALLY
    'STRUCTURE(FN(10) BYTE, ATTRIB BYTE, EOF$COUNT BYTE,
     BLK$COUNT ADDRESS, HDR$BLK ADDRESS)';
  DECLARE ISIS$DIR$BLK LITERALLY '0101H';
  DECLARE DISK$READ LITERALLY '4';
  DECLARE DIR(1) DIR$ENTRY AT (.DIR$BUF);
  DECLARE SAVE DIR$ENTRY AT (.DIR$BUF);
  DECLARE DIR$PTR ADDRESS;
  DECLARE PTR$BLK(64) ADDRESS;
  DECLARE DATA$BLK$INDEX BYTE;
  DECLARE NUM$ENTRIES ADDRESS;
  DECLARE BUFFER(12) BYTE;
  DECLARE COUNT ADDRESS;
  DECLARE FREE$SPACE ADDRESS;
  DECLARE ACTUAL$ENTRY ADDRESS;
  DECLARE ENTRY ADDRESS;
  DECLARE J BYTE;
  DECLARE I ADDRESS;

  REWIND$DIR: PROCEDURE;
    CALL ABSIO(DISK$READ, DISK, ISIS$DIR$BLK, .PTR$BLK);
    DIR$PTR = .DIR(1);
    DATA$BLK$INDEX = 1;
  END REWIND$DIR;

  NEXT$SECTOR: PROCEDURE;
    DATA$BLK$INDEX = DATA$BLK$INDEX + 1;
    IF DATA$BLK$INDEX > LAST(PTR$BLK) THEN DO;  /* END OF POINTER BLOCK */
      DATA$BLK$INDEX = 2;
      IF PTR$BLK(1) = 0 THEN  /* END OF FILE */
        RETURN;
      CALL ABSIO(DISK$READ, DISK, PTR$BLK(1), .PTR$BLK);
    END;
  END NEXT$SECTOR;

  MORE$ENTRIES: PROCEDURE BYTE;
    IF DIR(NUM$ENTRIES).FN(0) = 7FH THEN
      RETURN FALSE;
    CALL NEXT$SECTOR;
    RETURN PTR$BLK(DATA$BLK$INDEX) <> 0;
  END MORE$ENTRIES;

  /* READ IN DIRECTORY FILE, LOCAL OR REMOTE */

  DIRECTORY$NAME(2) = DIR$TO$SEARCH;

  CALL SPATH(.DIRECTORY$NAME, .BUFFER, .STATUS); CHK;
     IF BUFFER(10) = 3  AND  BUFFER(11) = 5  THEN
        DO;
          MEM$TOP = MEM$CK - 13;
          IF MEM$TOP < 0E800H   THEN
            CALL PRINT$CR$EXIT(.('insufficient memory ', CR, LF, 0));
          ELSE
            DO;
               FREE$SPACE = 0E800H - .MEMORY;
               COUNT = FREE$SPACE / 16;
               CALL LOAD(.(':F0:ISIS.OV0 '),0,0,.ENTRY,.STATUS); CHK;
               CALL GETD(DIR$TO$SEARCH-'0',.CONNECTION,COUNT,.ACTUAL$ENTRY,
                         .DIR$BUF,.STATUS);  CHK;

               IF ACTUAL$ENTRY >= COUNT  THEN
                  CALL PRINT$CR$EXIT(.('remote directory too large.', CR,LF,0));
               READING$REMOTE = TRUE;
               END$OF$DIRECTORY = .DIR$BUF + (ACTUAL$ENTRY * 16);
            END;
        END;
     ELSE
        DO;
           DISK = DISK - '0';
           NUM$ENTRIES = 0;
           DIR(0).FN(0) = 0;
           CALL REWIND$DIR;
           DO WHILE MORE$ENTRIES;
              CALL ABSIO(DISK$READ, DISK, PTR$BLK(DATA$BLK$INDEX), DIR$PTR);
              DIR$PTR = DIR$PTR + 128;
              NUM$ENTRIES = NUM$ENTRIES + 8;  /* COUNT ENTRIES */
           END;
           DO WHILE DIR(NUM$ENTRIES).FN(0) = 7FH;
              NUM$ENTRIES = NUM$ENTRIES - 1;
           END;
           ACTUAL = (NUM$ENTRIES+1) * 16;
           READING$REMOTE = FALSE;
           END$OF$DIRECTORY = .DIR$BUF + ACTUAL;
        END;
END READ$ABSIO$DIR;

$EJECT

/**************************************************
  D I R E C T O R Y   M A N I P U L A T I N G
                P R O C E D U R E S
***************************************************/

NULL$OUT: PROC;
   DIR$ENTRY$PTR = .DIR$BUF;
   DO WHILE (DIR$ENTRY.PRESENCE<>07FH) AND (DIR$ENTRY$PTR<.DIR$BUF+ACTUAL-1);
      IF DIR$ENTRY.EXTENSION(0) < '0' OR DIR$ENTRY.EXTENSION(0) > '9' THENN
         DIR$ENTRY.FILENAME(0) = 0;
      ENDIF
      DIR$ENTRY$PTR = DIR$ENTRY$PTR + 16;
   ENDDO
END NULL$OUT;

GREATEST$EXT: PROC (NAME$PART$PTR) ADDRESS;
   DCL NAME$PART$PTR ADDRESS;
   DCL LEN$2 BYTE;
   DCL LARGEST$EXTENSION ADDRESS;
   DCL NUM$EXTENSION$FOUND BYTE;
   DCL EXT$PTR ADDRESS;

   NUMERIC$EXTENSION: PROC (PTR) BYTE;
        /*	Given a pointer into memory, this procedure determines
                whether the byte pointed to, and the next two contiguous
                bytes, constitute a wholly numeric ascii sequence.			*/
        DCL PTR ADDRESS, CHAR BASED PTR (3) BYTE;
        DCL L BYTE;
        DO L=0 TO 2;
                IF NOT (CHAR(L) >= '0' AND CHAR(L) <= '9')   THENN
                        RETURN FALSE;
                ENDIF
        ENDDO
        RETURN TRUE;
   END NUMERIC$EXTENSION;

   VALUE: PROC (DIR$EXT$PTR) ADDRESS;
        DCL DIR$EXT$PTR ADDRESS;
        DCL CHAR BASED DIR$EXT$PTR (3) BYTE;
        DCL T BYTE;
        DCL RESULT ADDRESS;
        RESULT = 0;
        DO T = 0 TO 2;
                RESULT = (RESULT * 10) + CHAR(T) - '0';
        ENDDO
        RETURN RESULT;
   END VALUE;

   NAME$PARTS$MATCH: PROC BYTE;
      DCL LEN$1 BYTE;
      DCL TMP$CHAR BYTE;
      DCL MATCH BYTE;
      SCANP = .DIR$ENTRY.FILENAME;
      LEN$1 = LESSER$OF(6,LENGTH$OF(.LET$OR$DIG$CH));
      SCANP = SCANP + LEN$1;
      TMP$CHAR = DIR$ENTRY.EXTENSION(0);
      SCAN$BYTE = 0;
      SCANP = NAME$PART$PTR;
      IF            LEN$1  <>  LEN$2          THENN
         DIR$ENTRY.EXTENSION(0) = TMP$CHAR;
         RETURN FALSE;
      ELLSE
         MATCH = SCAN$MATCH(.DIR$ENTRY.FILENAME) ;
         DIR$ENTRY.EXTENSION(0) = TMP$CHAR;
         RETURN MATCH;
      ENDIF
   END NAME$PARTS$MATCH;

   DIR$ENTRY$PTR = .DIR$BUF;
   SCANP = NAME$PART$PTR;
   LEN$2 = LESSER$OF(6,LENGTH$OF(.LET$OR$DIG$CH));
   NUM$EXTENSION$FOUND = FALSE;
   LARGEST$EXTENSION = 0;
   /*	Grand directory search loop. */
   DO WHILE  DIR$ENTRY$PTR < END$OF$DIRECTORY;
      IF NOT READING$REMOTE  THEN
        DO;
          IF DIR$ENTRY.PRESENCE = 7FH  THEN
            GO TO NO$MORE$DIR;
          IF DIR$ENTRY.PRESENCE = 0FFH  THEN
            GO TO LOOP1;
        END;
      DO;
        IF               DIR$ENTRY.FILENAME(0) =  NULL THEN GOTO LOOP1;
           IF            NAME$PARTS$MATCH                         THENN
              IF NUMERIC$EXTENSION(.DIR$ENTRY.EXTENSION) AND
                 DIR$ENTRY.PRESENCE <> 0FFH                   THENN
                 DCL EXTENSION$NUM ADDRESS;
                 NUM$EXTENSION$FOUND = TRUE;
                 EXTENSION$NUM = VALUE(.DIR$ENTRY.EXTENSION);
                 IF EXTENSION$NUM >= LARGEST$EXTENSION THENN
                    EXT$PTR = .DIR$ENTRY.EXTENSION;
                    LARGEST$EXTENSION = EXTENSION$NUM;
                 ENDIF
              ENDIF
           ENDIF
      END;
      loop1:
      DIR$ENTRY$PTR = DIR$ENTRY$PTR + 16;
   ENDDO
   no$more$dir:
   IF      NUM$EXTENSION$FOUND       THENN
      RETURN (EXT$PTR);
   ELLSE
      RETURN NO$NUM$EXTENSION;
   ENDIF
END GREATEST$EXT;

$EJECT

/********************************************************
         O U T P U T     P R O C E D U R E S
********************************************************/

OUTPUT$LIST: PROC;
  DCL TMP$FILL$INDEX  ADDRESS,
      TMP$NAME$INDEX  ADDRESS;

  PRINT$GREATEST$NUMERIC$EXT: PROC ;
     DCL ( EXT, TMP$P, LEN) ADDRESS;
     EXT = GREATEST$EXT(.NAME$LIST(TMP$NAME$INDEX).NAME);
     SCANP = .NAME$LIST(TMP$NAME$INDEX).NAME;
     LEN = LESSER$OF(LENGTH$OF(.LET$OR$DIG$CH),6);
     IF EXT = 0 THENN
        CALL FMOVE(6,.BLANK$STR,.NO$EXT$MSG);
        CALL FMOVE(LEN,SCANP,.NO$EXT$MSG);
        CALL PRINT(.NO$EXT$MSG);
     ELLSE
        CALL FMOVE(6,.BLANK$STR,.EXT$MSG(30));
        CALL FMOVE(LEN,SCANP,.EXT$MSG(30 + 6 - LEN));
        CALL FMOVE(3,EXT,.EXT$MSG(37));
        CALL PRINT(.EXT$MSG);
     ENDIF
  END PRINT$GREATEST$NUMERIC$EXT;

  CALL READ$ABSIO$DIR(DIR$TO$SEARCH);
  CALL NULL$OUT;
  TMP$NAME$INDEX = 0;
  DO WHILE TMP$NAME$INDEX <= NAME$INDEX;
     CALL PRINT$GREATEST$NUMERIC$EXT;
     TMP$NAME$INDEX = TMP$NAME$INDEX + 1;
  ENDDO
END OUTPUT$LIST;

$EJECT

/******************************************************
     C O M M A N D    L I N E  P R O C E S S I N G
                 P R O C E D U R E S
******************************************************/

PROCESS$COMMAND$LINE: PROC;
   GET$TEMPLATE$FILENAME: PROC;
     DCL STAT$MSG (*) BYTE DATA('process$command$line',0);
     CALL READC(.READBUF,128);
     CALL CHK$STATUS(.STAT$MSG);
     SCANP$TMP,SCANP = DEBLANK(.READBUF);
     IF         SCANMATCH(.('?',0))         THENN
        DCL VERNO (*) BYTE DATA('latest V1.0',0);
        CALL PRINT$CR$EXIT(.VERNO);
     ENDIF
     SCANP = DEBLANK(SCANP);
     IF DIG$CH THENN
        DIR$TO$SEARCH = SCANBYTE;
        SCANP = DEBLANK(SCANP+1);
     ELLSE
        CALL PRINT$CR$EXIT(.('missing drive #',0));
     ENDIF
  END GET$TEMPLATE$FILENAME;

   MAKE$LIST: PROC;
      DCL FLAG BYTE;

         ADD$FILENAME: PROC BYTE;

         ADD$NAME: PROC (N$INDEX);
            DCL (N$INDEX,LEN$NAME$PART)  ADDRESS;
            IF (LEN$NAME$PART :=LENGTH$OF(.LET$OR$DIG$CH)) > 6  THENN
               CALL PRINT$CR(.('name part too long: ',0));
               SCANP = SCANP + 7;
               SCANBYTE = NULL;
               CALL PRINT$CR$EXIT(SCANP-7);
            ELLSE
               CALL FMOVE(6,.NULL$STRING,.NAMELIST(N$INDEX).NAME);
               CALL FMOVE(LEN$NAME$PART,SCANP,.NAME$LIST(N$INDEX).NAME);
               /* set type field in the event that it will be used */
               SCANP = SCANP + LEN$NAME$PART;
               IF        BLANK$CH OR TERM$CH             THENN
                  NAMELIST(N$INDEX).TYPE = NAME$ONLY$TYPE;
               ELSIF      DOT$CH                 THENN
                  SCAN$P = SCANP + 1;
                  IF    LET$OR$DIG$CH     THENN
                     NAMELIST(N$INDEX).TYPE = NAME$DOT$EXT$TYPE;
                  ELLSE
                     NAMELIST(N$INDEX).TYPE = NAME$DOT$TYPE;
                  ENDIF
               ELLSE
                  CALL PRINT$CR$EXIT(.('a blank or dot must follow name part',0));
               ENDIF
            ENDIF
         END ADD$NAME;

         SCANP = DEBLANK(SCANP);
         IF TERM$CH                              THENN
            RETURN DONE;
         ELSIF SCANMATCH(.('&',0))     THENN
            CALL ENFORCE$NO$TOKENS;
            CALL PRINT(.('**',0));
            CALL READC(.READBUF,128);
            SCANP = DEBLANK(.READBUF);
            RETURN NEW$LINE;
         ELSIF FILE$CH                 THENN
            CALL ADD$NAME(NAME$INDEX);
            NAME$INDEX = NAME$INDEX + 1;
            RETURN NAME$ADDED;
         ELLSE                                          /* syntax chk opt */
            DCL TEMP$PTR ADDRESS;
            TEMP$PTR = SCANP;
            DO WHILE NOT(BLANK$CH) AND NOT(TERM$CH);
               SCANP = SCANP + 1;
            ENDDO
            SCAN$BYTE = NULL;
            CALL PRINT(TEMP$PTR);
            CALL PRINT$CR$EXIT(.(' not a filename',0));
         ENDIF
      END ADDFILENAME;

      FLAG = NOT DONE;
      DO WHILE FLAG <> DONE;
         FLAG = ADD$FILENAME;
      ENDDO
      IF NAME$INDEX = 0 THENN
         CALL PRINT$CR$EXIT(.('no filenames on command line',0));
      ELLSE
         NAME$INDEX = NAME$INDEX - 1;
      ENDIF
   END MAKE$LIST;

   CALL GET$TEMPLATE$FILENAME;
   CALL MAKE$LIST;
   END PROCESS$COMMAND$LINE;

$EJECT
/*********************************************************
     F I R S T      E X E C U T A B L E      C O D E
*********************************************************/
REPORT = FALSE;
LEAD$CHAR = '0';
CALL PROCESS$COMMAND$LINE;
CALL OUTPUT$LIST;

CALL EXIT;

END;

src/loop.plm
LOOP$MOD: DO;

/************************************************************************/
/*																		*/
/*      '(C) Intel Corporation 1981'.  All rights reserved.  No			*/
/*      part of this program or publication may be reproduced,			*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

DECLARE COPYRIGHT (*) BYTE DATA ('(C) INTEL CORP 1981');

DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.0',0);

DECLARE	LIT		LITERALLY	'LITERALLY',
		DCL		LIT	'DECLARE',
		TRUE	LIT	'0FFH',
		FALSE	LIT	'000H',
		PROC	LIT	'PROCEDURE',
		PROCEND	LIT	'END',
		THENDO	LIT	'THEN DO;',
		ELSEIF	LIT	'END; ELSE IF',
		ELSEDO	LIT	'END; ELSE DO;',
		IFEND	LIT	'END',
		WHILEND	LIT	'END',
		CR		LIT	'0DH',
		LF		LIT	'0AH';

EXIT:	PROC EXTERNAL;											PROCEND;
READ:	PROC (A,B,C,D,E) EXTERNAL;	DCL (A,B,C,D,E) ADDRESS;	PROCEND;
WRITE:	PROC (A,B,C,D) EXTERNAL;	DCL (A,B,C,D) ADDRESS;		PROCEND;
SEEK:	PROC (A,B,C,D,E) EXTERNAL;	DCL (A,B,C,D,E) ADDRESS;	PROCEND;

DCL (STATUS, ACTUAL) ADDRESS;

CALL READ (1, .MEMORY, 128, .ACTUAL, .STATUS); /* Skip command tail. */
ACTUAL = 0;
CALL SEEK (1, 2, .ACTUAL, .ACTUAL, .STATUS);
CALL EXIT; /* Don't need to check status. */

END LOOP$MOD;
src/lower.plm
/*
 * lower
 *      Program to convert a file to lower case ascii.
 *
 * Call:
 *
 *      -lower file1 file2
 *
 * Where:
 *      file1 is source file,
 *      file2 is file1 translated to lower case.
 *
 */

lower: DO;


/************************************************************************/
/*																		*/
/*      '(C) Intel Corporation 1981'.  All rights reserved.  No			*/
/*      part of this program or publication may be reproduced,			*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

      
DECLARE COPYRIGHT (*) BYTE DATA ('(C) INTEL CORP 1981');

DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.0',0);
    


    /*
     * external procs.
     */

    csargs: PROCEDURE(argptrs,string,count) EXTERNAL;
        DECLARE (string,argptrs,count) ADDRESS;
    END csargs;

    fopen: PROCEDURE(buffer,name,status) EXTERNAL;
        DECLARE (name,buffer,status) ADDRESS;
    END fopen;

    fcreat: PROCEDURE(buffer,name,status) EXTERNAL;
        DECLARE (name,buffer,status) ADDRESS;
    END fcreat;

    fflush: PROCEDURE(buffer) EXTERNAL;
        DECLARE buffer ADDRESS;
    END fflush;

    getc: PROCEDURE(buffer) BYTE EXTERNAL;
        DECLARE buffer ADDRESS;
    END getc;

    putc: PROCEDURE(chr,buffer) EXTERNAL;
        DECLARE chr BYTE;
        DECLARE buffer ADDRESS;
    END putc;

    outstr: PROCEDURE(string) EXTERNAL;
        DECLARE string ADDRESS;
    END outstr;

    exit: PROCEDURE EXTERNAL;
    END exit;

    /*
     * local data.
     */

    DECLARE
        in$buf(140) BYTE,
        out$buf(140) BYTE,
        arg$chrs(50) BYTE,
        arg$ptr(5) ADDRESS,
        arg$cnt ADDRESS,
        c BYTE,
        status ADDRESS;

    DECLARE
        CR LITERALLY '0DH',
        LF LITERALLY '0AH',
        FOREVER LITERALLY 'WHILE 1';

    /*
     * main program. open files, do translation.
     */

    CALL csargs(.arg$ptr,.arg$chrs,.arg$cnt);

    IF arg$cnt <> 3 THEN DO;
        CALL outstr(.('Useage: lower file filelc.',CR,LF,0));
        CALL exit;
    END;

    CALL fopen(.in$buf,arg$ptr(1),.status);
    IF status <> 0 THEN DO;
        CALL outstr(.('Can''t open ',0));
        CALL outstr(arg$ptr(1));
        CALL outstr(.(CR,LF,0));
        CALL exit;
    END;

    CALL fcreat(.out$buf,arg$ptr(2),.status);
    IF status <> 0 THEN DO;
        CALL outstr(.('Can''t create ',0));
        CALL outstr(arg$ptr(2));
        CALL outstr(.(CR,LF,0));
        CALL exit;
    END;

    /*
     * main loop. get char, xlat to lower case if necessary, write.
     */

    DO FOREVER;

        IF (c := getc(.in$buf)) = 0 THEN DO;
            CALL fflush(.out$buf);
            CALL exit;
        END;

        IF (c >= 'A') AND (c <= 'Z') THEN
            c = c + ('a' - 'A');

        CALL putc(c,.out$buf);

    END;

END lower;
src/m3.asm
;      '(C) Intel Corporation 1981'.  All rights reserved.  No
;      part of this program or publication may be reproduced,
;      transmitted, transcribed, stored in a retrievel system, or
;      translated into any language or computer language, in any
;      form or by any means, electronic, mechanical, magnetic,
;      optical, chemical, manual or otherwise, without the prior
;      written permission of Intel Corporation, 3065 Bowers
;      Avenue, Santa Clara, California, 95051, Attn: Software
;      License Administration.
	STKLN 10
	CSEG
	PUBLIC CONVND
	EXTRN DIVIDE
CONVND: PUSH PSW
	PUSH H
	MOV H,D
	MOV L,E
	MVI M,' '
	INX H
	MVI M,' '
	INX H
	MVI M,' '
	INX H
	MVI M,' '
	INX H
	MVI M,'0'
	INX H
	MVI M,':'
	DCX H
LOOP:   MOV A,C
	ANA A
	JNZ CONV1
	MOV A,B
	ANA A
	JZ RETURN
CONV1:  LXI D,10
	CALL DIVIDE
	MOV A,C
	ADI 30H
	MOV M,A
	DCX H
	MOV B,D
	MOV C,E
	JMP LOOP
RETURN: POP H
	POP PSW
	RET
	
	DSEG
CPYRT:		DB		'(C) INTEL CORP 1981'
    END
src/main.plm
$ TITLE ('==> PASSIF -- MAINMOD -- MAIN MODULE <==')

MAIN$MOD:
DO;

/************************************************************************/
/*																		*/
/*      '(C) Intel Corporation 1981'.  All rights reserved.  No			*/
/*      part of this program or publication may be reproduced,			*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

DECLARE COPYRIGHT (*) BYTE DATA ('(C) INTEL CORP 1981');

DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.0',0);

$ NOLIST

		/* ISIS.INC */

ATTRIB:
	PROCEDURE(FILE$NAME$PTR,WHICH$ATTRIBUTE,SET$OR$RESET,STATUS$PTR) EXTERNAL;
	DECLARE (FILE$NAME$PTR,WHICH$ATTRIBUTE,SET$OR$RESET,STATUS$PTR) ADDRESS;
	END
ATTRIB;

CLOSE:
	PROCEDURE (AFTN,STATUS) EXTERNAL;
	DECLARE (AFTN,STATUS) ADDRESS;
	END
CLOSE;

CI:
	PROCEDURE BYTE EXTERNAL;
	END
CI;

CO:
	PROCEDURE (CHAR$CO) EXTERNAL;
	DECLARE CHAR$CO BYTE;
	END
CO;

CONSOL:
	PROCEDURE (CONSOLE$INPUT$FILE,CONSOL$OUTPUT$FILE,STATUS$CON) EXTERNAL;
	DECLARE (CONSOLE$INPUT$FILE,CONSOL$OUTPUT$FILE,STATUS$CON) ADDRESS;
	END
CONSOL;

DELETE:
	PROCEDURE (FILE$NAME$PTR,STATUS) EXTERNAL;
	DECLARE (FILE$NAME$PTR,STATUS) ADDRESS;
	END
DELETE;

ERROR:
	PROCEDURE  (ERROR$NUMBER) EXTERNAL;
	DECLARE ERROR$NUMBER ADDRESS;
	END
ERROR;

EXIT:
	PROCEDURE EXTERNAL;
	END
EXIT;

IO$CHK:
	PROCEDURE BYTE EXTERNAL;
	END
IO$CHK;

IO$DEF:
	PROCEDURE (WHICH$DEVICE,ENTRY$POINT) EXTERNAL;
	DECLARE WHICH$DEVICE BYTE,
			ENTRY$POINT ADDRESS;
	END
IO$DEF;

IO$SET:
	PROCEDURE (CONFIGURATION$BYTE) EXTERNAL;
	DECLARE CONFIGURATION$BYTE BYTE;
	END
IO$SET;

LOAD:
	PROCEDURE (FILE,BIAS,CONTROL$OF$TRANSFER,ENTRY$POINT,STATUS) EXTERNAL;
	DECLARE (FILE,BIAS,CONTROL$OF$TRANSFER,ENTRY$POINT,STATUS) ADDRESS;
	END
LOAD;

MEMCK:
	PROCEDURE ADDRESS EXTERNAL;
	END
MEMCK;

OPEN:
	PROCEDURE(AFTN,FILENAME,ACCESS$MODE,LINE$EDIT$AFTN,ERROR) EXTERNAL;
	DECLARE (AFTN,FILENAME,ACCESS$MODE,LINE$EDIT$AFTN,ERROR) ADDRESS;
	END
OPEN;

READ:
	PROCEDURE (AFTN,BUFFER,COUNT,ACTUAL,STATUS) EXTERNAL;
	DECLARE (AFTN,BUFFER,COUNT,ACTUAL,STATUS) ADDRESS;
	END
READ;

RENAME:
	PROCEDURE (OLD$NAME,NEW$NAME,STATUS$R) EXTERNAL;
	DECLARE (OLD$NAME,NEW$NAME,STATUS$R) ADDRESS;
	END
RENAME;

RESCAN:
	PROCEDURE (AFTN,STATUS) EXTERNAL;
	DECLARE (AFTN,STATUS) ADDRESS;
	END
RESCAN;

SEEK:
	PROCEDURE (AFTN,MODE,BLOCKNO,BYTENO,STATUS) EXTERNAL;
	DECLARE (AFTN,MODE,BLOCKNO,BYTENO,STATUS) ADDRESS;
	END
SEEK;

SPATH:
	PROCEDURE (FILE,BUFFER,STATUS) EXTERNAL;
	DECLARE (FILE,BUFFER,STATUS) ADDRESS;
	END
SPATH;

WHOCON:
	PROCEDURE (AFTN,BUFFER) EXTERNAL;
	DECLARE (AFTN,BUFFER) ADDRESS;
	END
WHOCON;

WRITE:
	PROCEDURE (AFTN,BUFFER,COUNT,STATUS) EXTERNAL;
	DECLARE (AFTN,BUFFER,COUNT,STATUS) ADDRESS;
	END
WRITE;

		/* END ISIS.INC */
$ NOLIST

/*         LIT.INC          */

DECLARE                 AS LITERALLY 'LITERALLY',              /* plm */
    AMPERSAND           AS '''&''',							   /* ??? */
    BELL                AS '07H',                              /* plm */
    BLANK               AS '020H',                             /* plm */
    BOOLEAN             AS 'BYTE',                             /* plm */
    CHK                 AS 'CALL CHECK$STATUS',	               /* plm */
    CLEAR$CHAR			AS '01CH',							   /* 1510 */
    CO$ECHO$FILE        AS '0F00H',                            /* open */
    COLON               AS ''':''',                            /* char */
    COMMA               AS '02CH',                       	   /* plm */
    CONSOLE$INPUT       AS '1',                                /* open */
    CONSOLE$OUTPUT      AS '0',                                /* open */
    CONTROL$Z           AS '01AH',                             /* plm */
    CR                  AS '0DH',                              /* plm */
    DOT                 AS '''.''',                            /* char */
    END$DO              AS 'END',                              /* plm */
    END$DO$CASE         AS 'END',                              /* plm */
    END$DO$WHILE        AS 'END',                              /* plm */
    END$IF              AS '   ',                              /* plm */
    END$ITERATED$DO		AS 'END',							   /* plm */
    END$LOOP            AS ' ',                                /* plm */
    EOF$CHAR            AS 'CONTROL$Z',                        /* plm */
    ESC                 AS '01BH',                             /* plm */
    FALSE               AS '0H',                               /* plm */
    FF					AS '0CH',							   /* ??? */
    FOREVER             AS 'WHILE 1',                          /* plm */
    FORMAT$ATTRIBUTE	AS '3',								   /* attrib */
    HASH$MARK			AS '''#''',							   /* plm */
    INIT$STG			AS '(*) BYTE INITIAL',				   /* plm */
    LEAD$IN$CHAR		AS '07EH',							   /*1510 */
    LF                  AS '0AH',                              /* plm */
    NO$LINE$EDIT        AS '0',                                /* open */
    NULL				AS '0FFFFH',						   /* ???  */
    OPEN$FOR$READ       AS '1',                                /* open */
    OPEN$FOR$WRITE      AS '2',                                /* open */
    OPEN$FOR$UPDATE		AS '3',								   /* open */
    PUB$STRING			AS '(*) BYTE PUBLIC DATA',             /* plm  */
    RESET				AS '0',								   /* attrib */
    RETURN$MARKER$POS   AS '0',                                /* seek */
    SEEK$2$EOF          AS '4',                                /* seek */
    SEEK$BACKWARD$BY$N  AS '1',                                /* seek */
    SEEK$FORWARD$BY$N	AS '3',								   /* seek */
    SEEK$2$N            AS '2',                                /* seek */
    SEMICOLON			AS ''';''',							   /* plm  */
    SET					AS '1',								   /* attrib */
    STRING              AS '(*) BYTE DATA',                    /* plm  */
    TAB                 AS '09H',                              /* plm */
    TRANSFER$CONTROL    AS '1',                                /* load */
    TRUE                AS '0FFH',                             /* plm */
    UNDERBAR			AS '''_''', 						   /* ??? */
    USER$CI             AS '0',                                /* ??? */
    WRITE$PROTECT$ATTRIBUTE 		AS '2',					   /* attrib */
    ZERO$BIAS           AS '0'                                 /* load */ ;

    /*        ENDLIT.INC        */

$ LIST

DECLARE
    ACTUAL ADDRESS PUBLIC,
    AFTN ADDRESS PUBLIC,

    BLOCK$NO ADDRESS INITIAL (0),
    BYTE$NO ADDRESS  INITIAL (0),

    CI$BUF (130) BYTE,
    CHAR$PTR ADDRESS INITIAL (.CI$BUF),
    CHAR BASED CHAR$PTR BYTE,

    STATUS ADDRESS PUBLIC INITIAL (0) ;

	DECLARE
		FILE$INFORMATION STRUCTURE
           (DEVICE$NUMBER				BYTE,
            FILE$NAME 			(6)		BYTE,
            EXTENSION			(3)		BYTE,
            DEVICE$TYPE					BYTE,
            DRIVE$TYPE			(11)	BYTE);

$ LIST
$ NOLIST

/************************************************************/
/*															*/
/*              LITERALLY'S UNIQUE TO PASSIF                */
/*															*/
/************************************************************/

DECLARE
    MINIMUM$ACCEPTABLE$BANNER$LENGTH 	AS 		'73',
    MAXIMUM$TOKEN$LENGTH				AS		'70',
    BI									AS		'CALL BOMB$IF(STATUS)',

	FIRST$FIELD							AS		'0',
    SECOND$FIELD						AS		'28',
    THIRD$FIELD							AS		'54',

    RIGHT$PARENTHESIS 					AS		''')''',
    LEFT$PARENTHESIS 					AS		'''(''',
    RI									AS		'CALL REPORT$IF',
    UNRECOGNIZED$SWITCH$ERR 			AS		'201',
    QUESTION$MARK						AS		'''?''';

$ LIST
$ NOLIST

/*	CLI.INC  */

DECLARE BUF$COUNT BYTE EXTERNAL;

UDI$STRING$MATCH:
	PROCEDURE (STG$1$PTR,STG$2$PTR) BOOLEAN EXTERNAL;
    DECLARE (STG$1$PTR,STG$2$PTR) ADDRESS;
	END
UDI$STRING$MATCH;

ENFORCE$DELIMITER:
	PROCEDURE(ENFORCEE) EXTERNAL;
	DECLARE ENFORCEE BYTE;
	END
ENFORCE$DELIMITER;

NEXT$ARG:
	PROCEDURE EXTERNAL;
	END
NEXT$ARG;

INTERPRET$COMMAND$LINE:
	PROCEDURE EXTERNAL;
	END
INTERPRET$COMMAND$LINE;

/*	END CLI.INC  */
$ LIST
$ NOLIST

/*	ERRMSG.INC  */

DECLARE
	BAD$SYNTAX$MSG 				(29) 				BYTE		EXTERNAL,
	BOMB$IF$MSG$1    			(12) 				BYTE		EXTERNAL,
	BOMB$IF$MSG$2				(40) 				BYTE		EXTERNAL,
    DURING$ASSERTION$CHECK$MSG	(50)				BYTE		EXTERNAL,
    PASSIF$INVOKED$BY$MSG       (19)                BYTE        EXTERNAL,
    ZERO$LENGTH$FILE$MSG 		(40) 				BYTE		EXTERNAL;

/*	END ERRMSG.INC  */
$ LIST
$ NOLIST

/*	FUNC.INC  */

FILE$EXISTS:
	PROCEDURE EXTERNAL;
	END
FILE$EXISTS;

FILE$ABSENT:
	PROCEDURE EXTERNAL;
	END
FILE$ABSENT;

FILES$MATCH:
	PROCEDURE EXTERNAL;
    END
FILES$MATCH;

STRING$FOUND:
	PROCEDURE EXTERNAL;
	END
STRING$FOUND;

STRING$ABSENT:
	PROCEDURE EXTERNAL;
	END
STRING$ABSENT;

/*	END FUNC.INC  */
$ LIST
$ NOLIST

/*	REPORT.INC  */

BOMB$IF:
	PROCEDURE (STATUS) EXTERNAL;
    DECLARE STATUS ADDRESS;
    END
BOMB$IF;

REPORT$SYNTAX$ERROR:
	PROCEDURE EXTERNAL;
	END
REPORT$SYNTAX$ERROR;

REPORT$ISIS$ERROR:
	PROCEDURE (STATUS) EXTERNAL;
	DECLARE STATUS ADDRESS;
	END
REPORT$ISIS$ERROR;

REPORT$ASSERTION$SUCCESS:
	PROCEDURE EXTERNAL;
	END
REPORT$ASSERTION$SUCCESS;

REPORT$ASSERTION$FAILURE:
	PROCEDURE EXTERNAL;
	END
REPORT$ASSERTION$FAILURE;

REPORT$ASSERTION$FAILURE$W$ISIS$ERR:
	PROCEDURE (STATUS) EXTERNAL;
	DECLARE STATUS ADDRESS;
    END
REPORT$ASSERTION$FAILURE$W$ISIS$ERR;

REPORT$ASSERTION$FAILURE$W$MSG:
	PROCEDURE (OLD$STYLE$MSG$PTR) EXTERNAL;
	DECLARE OLD$STYLE$MSG$PTR ADDRESS;
    END
REPORT$ASSERTION$FAILURE$W$MSG;

MSG$LENGTH:
	PROCEDURE (OLD$STYLE$MSG$PTR) BYTE EXTERNAL;
    DECLARE OLD$STYLE$MSG$PTR ADDRESS;
	END
MSG$LENGTH;

/*	END REPORT.INC  */
$ LIST
$ NOLIST

/*	TOKENS.INC  */

GET$ARGUMENT:
	PROCEDURE (BUF$PTR,STATUS$PTR) BYTE EXTERNAL;
	DECLARE (BUF$PTR,STATUS$PTR) ADDRESS;
    END
GET$ARGUMENT;

/*	END TOKENS.INC  */
$ LIST

$ EJECT

/************************************************************/
/*															*/
/*                        NOTES                             */
/*															*/
/************************************************************/

/*

1.	Limitation of 250 characters in command tail.

2.  Calls to the "report assertion" procedures do not return (i.e., an exit
    call is therein encountered), since reporting the success or failure of an
    assertion is the ultimate goal to which a procedure can aspire.

3.	Some "initialized global variables" are declared just above the procedures
    in which they are used, not in the area "assigned" to them.  This is done
    in situations where the variables would have been declared locally, within
    said procedure, except that the plm80 language allows initialization only
    of identifiers declared at module level.

4.	CONVENTION ON BUFFER POINTERS -- The pointer to the bottom of a buffer
	points to the first byte used.  The pointer to the top of a buffer
	points to the last byte used.  This is a symmetrical situation, pleasing
	to the psyche of Western man.

5.  Passif's reaction to the Isis Errors it may encounter depends on where the
    error is detected, because some such errors may legitmately encountered
    during normal processing of assertion checking, but some may occur during
    Passif's own processing.  The legimate errors must be reported in the
    report file, but when Passif detects an error during its processing, it
    must exit.

	Passif can Isis report errors encountered in processing assertions, in
	its report file.  It has to bomb only when Isis errors are encountered
	in the process of updating the report file.

6.	If Passif needs a workfile, the workfile will be on the same disk as
	the report file, and will have name "passif.tmp".  This device will not
	be write-protected since the report file is there.

7.	Initializing, and/or re-initializing the report file is one of the
	trickier sections of Passif.

8.	The procedure exit$routine is used so that the updated banner can be
	printed out as the last Passif function before it exits.

9.	If any of the numbers in the report file reach 64k, then they stay at
	64k.

10.	I/O for the various searches and compares is buffered, but the i/o for
	"error entries" is not.

*/

$ EJECT

/************************************************************/
/*															*/
/*     UNINITIALIZED        GLOBAL           VARIABLES      */
/*															*/
/************************************************************/

DECLARE DELIMITER BYTE PUBLIC;
DECLARE TOK$BUF (80) BYTE PUBLIC;
DECLARE COMMAND$TAIL$BUF (250) BYTE PUBLIC;

DECLARE FIRST$BLOCK$BUF (128) BYTE PUBLIC;
DECLARE REPORT$FILE$AFTN ADDRESS PUBLIC;
DECLARE REPORT$FILE$ACTUAL ADDRESS PUBLIC;

DECLARE TMP$FILE$AFTN ADDRESS PUBLIC;
$ EJECT

/************************************************************/
/*															*/
/*       INITIALIZED        GLOBAL           VARIABLES      */
/*															*/
/************************************************************/

DECLARE FIRST$TIME$THROUGH BOOLEAN PUBLIC INITIAL (TRUE);

DECLARE FIRST$OUTPUT$MSG$PTR ADDRESS PUBLIC INITIAL (NULL);
DECLARE SECOND$OUTPUT$MSG$PTR ADDRESS PUBLIC INITIAL (NULL);

DECLARE PRINT$HASH$MARK BOOLEAN PUBLIC INITIAL (FALSE);

DECLARE ILLEGAL$COMMAND$LINE$CHAR$ERR BOOLEAN PUBLIC INITIAL (FALSE);

DECLARE TMP$FILE$NAME PUB$STRING (':F0:PASSIF.TMP ');

DECLARE REPORT$FILE STRING
	('REPORT_FILE=:F1:REPORT.LOG ');
/*    012345678901234567890123456        */
/*    0         1         2              */

$ EJECT

/************************************************************/
/*															*/
/*        IRREVOCABLY INITIALIZED GLOBAL VARIABLES          */
/*															*/
/************************************************************/

DECLARE REPORT$FILE$STRING$BEGINNING ADDRESS PUBLIC DATA (.REPORT$FILE(12));

DECLARE INITIALIZED$BANNER PUB$STRING
                                       (

'00000 TESTS EXECUTED        00000 TESTS PASSED        00000 TESTS FAILED'

                                    ,CR,LF);

$ EJECT

/************************************************************/
/*															*/
/*           KEYWORD              TABLE                     */
/*															*/
/************************************************************/

DECLARE KEY$WORDS (10) STRUCTURE
   (LENGTH							BYTE,
    KEY$WORD	(13)				BYTE,
	PROC$PTR						ADDRESS) PUBLIC DATA

/*               1234567890123                         */
    (11,		'FILE_EXISTS  '		,.FILE$EXISTS,
     11,		'FILE_ABSENT  '		,.FILE$ABSENT,
     11,		'FILES_MATCH  '		,.FILES$MATCH,

/*               1234567890123                         */
     12,		'STRING_FOUND '		,.STRING$FOUND,

/*               1234567890123                         */
     13,		'STRING_ABSENT'		,.STRING$ABSENT,

     02,		'FE           '		,.FILE$EXISTS,
     02,		'FA           '		,.FILE$ABSENT,
     02,		'FM           '		,.FILES$MATCH,
     02,		'SF           '		,.STRING$FOUND,
     02,		'SA           '		,.STRING$ABSENT);

$ EJECT

/************************************************************/
/*															*/
/*                  EXTERNAL PROCEDURES                     */
/*															*/
/************************************************************/

FMOVE:
	PROCEDURE (COUNT,SOURCE$PTR,DEST$PTR) EXTERNAL;
	DECLARE (COUNT,SOURCE$PTR,DEST$PTR) ADDRESS;
	END
FMOVE;

$ EJECT

/************************************************************/
/*															*/
/*           LOCAL              PROCEDURES                  */
/*															*/
/************************************************************/

MOVE:
	PROCEDURE (COUNT,SOURCE$PTR,DEST$PTR) PUBLIC;
	DECLARE (COUNT,SOURCE$PTR,DEST$PTR) ADDRESS;
    IF COUNT<>0 THEN
    	CALL FMOVE(COUNT,SOURCE$PTR,DEST$PTR);
    ENDIF
	END
MOVE;

RE$POSITION$CURSOR:
	PROCEDURE PUBLIC;
	CALL CO(CR);
	END
RE$POSITION$CURSOR;

CO$IS$VO:
	PROCEDURE BOOLEAN PUBLIC;
	DECLARE WHO$CON$BUF (15) BYTE;
	CALL WHO$CON(CONSOLE$OUTPUT,.WHO$CON$BUF);
	IF
		WHO$CON$BUF(0) = ':' AND
		WHO$CON$BUF(1) = 'V' AND
		WHO$CON$BUF(2) = 'O' AND
		WHO$CON$BUF(3) = ':'		THEN

		RETURN TRUE;
	ELSE
		RETURN FALSE;
	ENDIF
	END
CO$IS$VO;

PRINT$NEW$BANNER:
	PROCEDURE;
	DECLARE P BYTE;
	/*	We don't write all the way to the end of "initialized banner"
		so as to avoid printing the carriage return and line feed. */
    DO P = 0 TO LAST(INITIALIZED$BANNER)-2;
		CALL CO(FIRST$BLOCK$BUF(P));
	END$ITERATED$DO;

	IF CO$IS$VO THEN
		DO;
			CALL CO(CR);
			CALL CO(LF);
		ENDDO;
	ENDIF
    END
PRINT$NEW$BANNER;

EXIT$ROUTINE:
	PROCEDURE PUBLIC;
	CALL PRINT$NEW$BANNER;
	CALL EXIT;
	END
EXIT$ROUTINE;

$ EJECT

/************************************************************/
/*															*/
/*				MAIN		LINE		CODE				*/
/*															*/
/************************************************************/

CALL RE$POSITION$CURSOR;
CALL INTERPRET$COMMAND$LINE;
CALL EXIT$ROUTINE;

END
MAIN$MOD;
src/merg80.plm
MERG80: DO;


/************************************************************************/
/*																		*/
/*      '(C) Intel Corporation 1981'.  All rights reserved.  No			*/
/*      part of this program or publication may be reproduced,			*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

      
DECLARE COPYRIGHT (*) BYTE DATA ('(C) INTEL CORP 1981');

DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.0',0);
    


$NOLIST
BLNK$CH: PROCEDURE BYTE EXTERNAL;END;
DECLARE FILE$NAME$LIMIT BYTE EXTERNAL;
OUTBLANK: PROCEDURE EXTERNAL;END;
FMOVE: PROCEDURE (ZZ1,ZZ2,ZZ3) EXTERNAL; DECLARE (ZZ1,ZZ2,ZZ3)ADDRESS;END;
BUMP$SCAN$P: PROCEDURE EXTERNAL; END;
FORCUP: PROCEDURE BYTE EXTERNAL; END;
SCAN$WHILE$BLANKS: PROCEDURE EXTERNAL; END;
BLTSYM: PROCEDURE EXTERNAL; END;
SORT: PROCEDURE(ZZA,ZZB,ZZC)EXTERNAL; DECLARE(ZZA,ZZB,ZZC)ADDRESS; END;
SET$OB: PROCEDURE (A) EXTERNAL; DECLARE A ADDRESS; END;
FILL: PROCEDURE (A,B,C) EXTERNAL; DECLARE (A,B) ADDRESS, C BYTE; END;
OUT$CRLF: PROCEDURE EXTERNAL; END;
OUT$SCAN$STRING: PROCEDURE EXTERNAL; END;
LTNMCH: PROCEDURE BYTE EXTERNAL; END;
OUT$SCAN$BYTE: PROCEDURE EXTERNAL; END;
MIN: PROCEDURE (A,B) ADDRESS EXTERNAL; DECLARE (A,B) ADDRESS; END;
MAX: PROCEDURE (A,B) ADDRESS EXTERNAL; DECLARE (A,B) ADDRESS; END;
OUT$CHAR: PROCEDURE (CHAR) EXTERNAL; DECLARE CHAR BYTE; END;
TERM$CH: PROCEDURE BYTE EXTERNAL;
END;

CONSOLE$IN: PROCEDURE EXTERNAL;
END;

SBYTEU: PROCEDURE (DISTANCE) EXTERNAL;
  DECLARE DISTANCE ADDRESS;
END;

WRITEU: PROCEDURE (SRC$PTR,COUNT) EXTERNAL;
  DECLARE (SRC$PTR,COUNT) ADDRESS;
END;

READU: PROCEDURE (DEST$PTR,COUNT) EXTERNAL;
  DECLARE (DEST$PTR,COUNT) ADDRESS;
END;

READI: PROCEDURE (DEST$PTR,COUNT) EXTERNAL;
  DECLARE (DEST$PTR,COUNT) ADDRESS;
END;

OPENI: PROCEDURE (FILE$NAME$PTR) EXTERNAL;
  DECLARE FILE$NAME$PTR ADDRESS;
END;

OPENU: PROCEDURE (FILE$NAME$PTR) EXTERNAL;
  DECLARE FILE$NAME$PTR ADDRESS;
END;

DDIG$CH: PROCEDURE BYTE EXTERNAL;
END;

MEMCK: PROCEDURE ADDRESS EXTERNAL;
END;

EX: PROCEDURE EXTERNAL;
END;

OHEX$W: PROCEDURE (VALUE) EXTERNAL;
  DECLARE VALUE ADDRESS;
END;

OUT$WRITE: PROCEDURE (PTR,LENGTH) EXTERNAL;
  DECLARE PTR ADDRESS, LENGTH BYTE;
END;

HEX$IN: PROCEDURE ADDRESS EXTERNAL;
END;

SET$SC: PROCEDURE (PTR) EXTERNAL;
  DECLARE PTR ADDRESS;
END;

ERROR$MESSAGE: PROCEDURE (PTR) EXTERNAL;
  DECLARE PTR ADDRESS;
END;

PRINTCR: PROCEDURE (PTR) EXTERNAL;
  DECLARE PTR ADDRESS;
END;

DEC$IN: PROCEDURE ADDRESS EXTERNAL;
END;

OPEN$SCAN: PROCEDURE (PROC$ADDR) EXTERNAL;
  DECLARE PROC$ADDR ADDRESS;
END;

MOVE$PARENS$FILE$NAME: PROCEDURE (DEST$PTR) EXTERNAL;
  DECLARE DEST$PTR ADDRESS;
END;

SCAN$EXPECT: PROCEDURE (PTR) EXTERNAL;
  DECLARE PTR ADDRESS;
END;

SFOUND: PROCEDURE BYTE EXTERNAL;
END;

LEN$STR$NUL: PROCEDURE (PTR) ADDRESS EXTERNAL;
  DECLARE PTR ADDRESS;
END;
$LIST

DECLARE STR LITERALLY '(.(';
DECLARE NUL LITERALLY ',0))';
DECLARE TRUE LITERALLY '0FFH';
DECLARE FALSE LITERALLY '0';

DECLARE OBUF$P ADDRESS EXTERNAL;
DECLARE SCAN$P ADDRESS EXTERNAL;
DECLARE SCAN$BYTE BASED SCAN$P BYTE;
DECLARE SCAN$ADDR BASED SCAN$P ADDRESS;
DECLARE FATAL BYTE EXTERNAL;
DECLARE ACTUAL ADDRESS EXTERNAL;
DECLARE TARLEN BYTE EXTERNAL;
DECLARE TARGET (45) BYTE PUBLIC;
DECLARE TEMP ADDRESS;
DECLARE SYM$MAX ADDRESS;
DECLARE OUT$P ADDRESS;
DECLARE OUT$ADDR BASED OUT$P (1) ADDRESS;
DECLARE I BYTE;
DECLARE COL$MAX BYTE;
DECLARE COL$LENGTH BYTE;
DECLARE PTR$INDEX ADDRESS;
DECLARE SYM$COUNT ADDRESS;
DECLARE SYM$BASE ADDRESS;
DECLARE NAMES$TOP ADDRESS;
DECLARE LINES$TOP ADDRESS;
DECLARE CAPACITY$BYTES ADDRESS;
DECLARE SEPARATOR BYTE INITIAL (0CH);
DECLARE SORTING BYTE INITIAL (0FFH);
DECLARE GIVE$UP ADDRESS EXTERNAL;
DECLARE GIVE$UP$BYTE BASED GIVE$UP (3) BYTE;
DECLARE LOW$INDEX ADDRESS;
DECLARE INDEX ADDRESS;
DECLARE LIN$BASE ADDRESS;
DECLARE LIN BASED LIN$BASE (1) ADDRESS;
DECLARE QHSYMQ (*) BYTE DATA ('H SYM  ');
DECLARE QMODQ (*) BYTE DATA ('      MOD  ');
DECLARE QHLINQ (*) BYTE DATA ('H LIN  ');
DECLARE MOD$NAME (32) BYTE;
DECLARE OLD$INDEX ADDRESS;
$EJECT

READ$NOT$FINISHED: PROCEDURE BYTE;
  RETURN (ACTUAL = CAPACITY$BYTES);
END;

FLUSH: PROCEDURE;
  IF ACTUAL > 32766 THEN
   DO;
    CALL SBYTEU(-32512);
    CALL SBYTEU(32512 - ACTUAL);
   END;
  ELSE CALL SBYTEU(-ACTUAL);
  CALL WRITEU(LINES$TOP,SCAN$P-LINES$TOP);
  CALL READU(LINES$TOP,CAPACITY$BYTES);
  SCAN$P = LINES$TOP;
  GIVE$UP = LINES$TOP + ACTUAL;
  GIVEUP$BYTE(3) = 0;
END;

NEXT$CHAR$BLANK: PROCEDURE BYTE;
  CALL SET$SC(SCAN$P+1);
  RETURN BLNK$CH;
END;

NEXT$LINE$NUMBER$FOUND: PROCEDURE BYTE;
   DO WHILE NOT (DDIG$CH AND NEXT$CHAR$BLANK);
    SCAN$P = SCAN$P - 3;
    IF NOT SFOUND THEN RETURN FALSE;
     DO WHILE TERM$CH;
      IF NOT SFOUND THEN RETURN FALSE;
     END;
    SCAN$P = SCAN$P + 3;
   END;
  SCAN$P = SCAN$P - 3;
  IF (SCAN$P > GIVE$UP - 256) AND READ$NOT$FINISHED THEN CALL FLUSH;
  OBUF$P = SCAN$P + 6;
  RETURN TRUE;
END;

OUT$LIN: PROCEDURE (VALUE);
  DECLARE VALUE ADDRESS;
  IF VALUE < LOW$INDEX THEN GO TO DASHES;
  IF VALUE > INDEX THEN GO TO DASHES;
  IF LIN(VALUE) = 0 THEN GO TO DASHES;
  CALL OHEXW(LIN(VALUE));
  RETURN;
 DASHES:
  CALL OUT$WRITE(.('----'),4);
END;

$EJECT
GET$LINE$NUMBER: PROCEDURE;
  SCAN$P = SCAN$P - 16;
  LIN(INDEX) = HEXIN;
  SCAN$P = SCAN$P + 12;
END;

READ: PROCEDURE (PTR);
  DECLARE PTR ADDRESS;
  CALL READI(PTR,(CAPACITY$BYTES:=(MEMCK-PTR)));
  SCAN$P = .MEMORY;
  GIVEUP = PTR + ACTUAL;
END;

CHECK$GIVE$UP: PROCEDURE;
  CALL FMOVE(GIVEUP-SCAN$P,SCAN$P,.MEMORY);
  CALL READ(GIVEUP - SCAN$P + .MEMORY);
  CALL SET$SC(.MEMORY);
  TARLEN = 11;
  IF SFOUND THEN GIVE$UP = SCAN$P;
END;

PUT$SYM$ADDR: PROCEDURE;
  CALL SET$SC(SCAN$P-11);
  TEMP = HEXIN;
  CALL OUT$CHAR(LOW (TEMP));
  CALL OUT$CHAR(HIGH (TEMP));
END;

COLLECT$SYMBOL$NAMES: PROCEDURE;
  SYM$MAX = 0;
  SYM$COUNT = 0;
  CALL FMOVE(7,.QHSYMQ,.TARGET);
  TARLEN = 7;
  OUT$P = MEMCK;
  OBUF$P = .MEMORY;
   DO WHILE SFOUND;
    OUT$P = OUT$P - 2;
    SYM$COUNT = SYM$COUNT + 1;
    OUT$ADDR(0) = OBUF$P;
    CALL PUT$SYM$ADDR;
    SYM$BASE = OBUF$P;
     DO WHILE LTNMCH;
      CALL OUT$SCAN$BYTE;
     END;
    SYM$MAX = MAX(OBUF$P-SYM$BASE,SYM$MAX);
    CALL OUT$CHAR(0);
   END;
  NAMES$TOP = OBUF$P;
END;

COLLECT$LINE$NUMBERS: PROCEDURE;
  CALL FMOVE(7,.QHLINQ,.TARGET);
  TARLEN = 7;
  IF SFOUND THEN
   DO;
    INDEX = (LOW$INDEX := DECIN);
    LIN$BASE = NAMES$TOP - (2*LOW$INDEX);
    CALL GET$LINE$NUMBER;
     DO WHILE SFOUND;
      OLD$INDEX = INDEX;
      INDEX = DECIN;
       DO WHILE OLD$INDEX < INDEX - 1;
        OLD$INDEX = OLD$INDEX + 1;
        LIN(OLD$INDEX) = 0;
       END;
      CALL GET$LINE$NUMBER;
     END;
    LINES$TOP = .LIN(INDEX+1);
   END;
  ELSE LOW$INDEX = 0FFFFH;
END;

PROCESS$LOCATE$FILE: PROCEDURE;
  CALL SET$SC(.MEMORY);
  CALL READ(.MEMORY);
  CALL FMOVE(11,.QMODQ,.TARGET);
  TARLEN = LEN$STR$NUL(.MOD$NAME);
  CALL FMOVE(TARLEN,.MOD$NAME,.TARGET+11);
  TARLEN = TARLEN + 11;
   DO WHILE NOT SFOUND;
    IF READ$NOT$FINISHED THEN
     DO;
      CALL FMOVE(TARLEN,GIVEUP-TARLEN,.MEMORY);
      CALL READ(.MEMORY+TARLEN);
     END;
    ELSE
     DO;
      CALL ERROR$MESSAGE STR 'MOD NAME NOT FOUND' NUL;
      CALL EX;
     END;
   END;
  CALL CHECK$GIVEUP;
  CALL COLLECT$SYMBOL$NAMES;
  CALL COLLECT$LINE$NUMBERS;
END;

OUT$SYM$NAME: PROCEDURE;
  CALL SET$OB(OBUF$P);
  SCAN$P = OUT$ADDR(PTR$INDEX);
  CALL OHEXW(SCAN$ADDR);
  SCAN$P = SCAN$P + 2;
  CALL OUT$BLANK;
  CALL OUT$SCAN$STRING;
END;

OUTPUT$SYMBOLS: PROCEDURE;
  CALL FILL(15000,NAMES$TOP,' ');
  SYM$MAX = SYM$MAX + 8;
  COL$MAX = 128 / SYM$MAX;
  COL$LENGTH = MAX (60, SYM$COUNT/COL$MAX + 1);
  COL$LENGTH = MIN (COL$LENGTH,SYM$COUNT);
  OBUF$P = NAMES$TOP;
  CALL OUT$CHAR(SEPARATOR);
  I = COL$LENGTH;
   DO WHILE I > 0;
    PTR$INDEX = SYM$COUNT + (I := I - 1);
    OBUF$P = OBUF$P + 4;
     DO WHILE PTR$INDEX >= COL$LENGTH;
      PTR$INDEX = PTR$INDEX - COL$LENGTH;
      CALL OUT$SYM$NAME;
      OBUF$P = OBUF$P + SYM$MAX;
     END;
    CALL OUT$CRLF;
   END;
  CALL WRITEU(NAMES$TOP,OBUF$P - NAMES$TOP);
END;

$EJECT

FATAL = TRUE;
CALL CONSOLE$IN;
CALL OPEN$SCAN(.OPENI);
FILE$NAME$LIMIT = 31;
CALL MOVE$PARENS$FILE$NAME(.MOD$NAME);
CALL SCAN$EXPECT STR 'INTO' NUL;
CALL PROCESS$LOCATE$FILE;
CALL OPEN$SCAN(.OPENU);
 DO WHILE NOT TERM$CH;
  IF FORCUP = 'N' THEN SORTING = FALSE;
  IF FORCUP = 'L' THEN SEPARATOR = 0AH;
  CALL BUMP$SCAN$P;
 END;
CAPACITY$BYTES = OUT$P - LINES$TOP - 4;
SCAN$P = LINES$TOP;
ACTUAL = 0;
CALL FLUSH;
SCAN$P = SCAN$P + 3;
TARLEN = 1;
TARGET(0) = 0AH;
 DO WHILE NEXT$LINE$NUMBER$FOUND;
  CALL OUTLIN(DECIN);
  CALL OUT$BLANK;
  SCAN$P = SCAN$P + 4;
 END;
SCAN$P = GIVE$UP;
CALL FLUSH;
IF SORTING THEN CALL SORT(OUT$P,SYM$COUNT,.BLTSYM);
CALL OUTPUT$SYMBOLS;
CALL EX;

END MERG80;
src/merg86.plm
MERG86: DO;

/************************************************************************/
/*																		*/
/*      '(C) Intel Corporation 1981'.  All rights reserved.  No			*/
/*      part of this program or publication may be reproduced,			*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

DECLARE COPYRIGHT (*) BYTE DATA ('(C) INTEL CORP 1981');

DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.6',0);


DECLARE CR                  LITERALLY '0DH';
DECLARE LF                  LITERALLY '0AH';
DECLARE FF                  LITERALLY '0CH';

DECLARE SIGN$ON$MSG (*) BYTE            /* 01/21/81 */
 DATA (CR, LF, 'ISIS-II MERG86, V1.6 - LINK86 & LOC86/PLM86 MERGE PROGRAM',0);

$NOLIST
/* PEX */
DECLARE SCANP ADDRESS EXTERNAL;
DECLARE SCANADDR BASED SCANP ADDRESS;
DECLARE OBUFP ADDRESS EXTERNAL;
DECLARE TARLEN BYTE EXTERNAL;
DECLARE GIVEUP ADDRESS EXTERNAL;
BLNKCH :PROCEDURE BYTE EXTERNAL;END;
BUMPSCANP :PROCEDURE  EXTERNAL;END;
CONSOLEIN :PROCEDURE  EXTERNAL;END;
DDIGCH :PROCEDURE BYTE EXTERNAL;END;
DECIN :PROCEDURE ADDRESS EXTERNAL;END;
ERRORMESSAGE :PROCEDURE (ZZ1) EXTERNAL;DECLARE (ZZ1)ADDRESS;END;
FILL :PROCEDURE (ZZ1,ZZ2,ZZ3) EXTERNAL;DECLARE (ZZ1,ZZ2)ADDRESS,(ZZ3)BYTE;END;
FMOVE :PROCEDURE (ZZ1,ZZ2,ZZ3) EXTERNAL;DECLARE (ZZ1,ZZ2,ZZ3)ADDRESS;END;
BLTSYM: PROCEDURE EXTERNAL;END;
SORT :PROCEDURE (ZZ1,ZZ2,ZZ3) EXTERNAL;DECLARE (ZZ1,ZZ2,ZZ3)ADDRESS;END;
FORCUP :PROCEDURE BYTE EXTERNAL;END;
HEXIN :PROCEDURE ADDRESS EXTERNAL;END;
LENSTRNUL :PROCEDURE (ZZ1)BYTE EXTERNAL;DECLARE (ZZ1)ADDRESS;END;
LTNMCH :PROCEDURE BYTE EXTERNAL;END;
TOKNCH :PROCEDURE BYTE EXTERNAL; END;
MAX :PROCEDURE (ZZ1,ZZ2)ADDRESS EXTERNAL;DECLARE (ZZ1,ZZ2)ADDRESS;END;
MIN :PROCEDURE (ZZ1,ZZ2)ADDRESS EXTERNAL;DECLARE (ZZ1,ZZ2)ADDRESS;END;
OHEXB :PROCEDURE (ZZ1) EXTERNAL;DECLARE (ZZ1)BYTE;END;
OHEXW :PROCEDURE (ZZ1) EXTERNAL;DECLARE (ZZ1)ADDRESS;END;
OUTBLANK :PROCEDURE  EXTERNAL;END;
OUTCHAR :PROCEDURE (ZZ1) EXTERNAL;DECLARE (ZZ1)BYTE;END;
OUTCRLF :PROCEDURE  EXTERNAL;END;
OUTSCANBYTE :PROCEDURE  EXTERNAL;END;
OUTSCANSTRING :PROCEDURE  EXTERNAL;END;
OUTWRITE :PROCEDURE (ZZ1,ZZ2) EXTERNAL;DECLARE (ZZ1)ADDRESS,(ZZ2)BYTE;END;
SCANEXPECT :PROCEDURE (ZZ1) EXTERNAL;DECLARE (ZZ1)ADDRESS;END;
SCANMATCH :PROCEDURE (ZZ1)BYTE EXTERNAL;DECLARE (ZZ1)ADDRESS;END;
SETOB :PROCEDURE (ZZ1) EXTERNAL;DECLARE (ZZ1)ADDRESS;END;
SETSC :PROCEDURE (ZZ1) EXTERNAL;DECLARE (ZZ1)ADDRESS;END;
SFOUND :PROCEDURE BYTE EXTERNAL;END;
STRINGLENGTH :PROCEDURE (ZZ1,ZZ2)BYTE EXTERNAL;DECLARE (ZZ1,ZZ2)ADDRESS;END;
TERMCH :PROCEDURE BYTE EXTERNAL;END;
PRINTCR: PROCEDURE (ZZ1) EXTERNAL; DECLARE ZZ1 ADDRESS; END;
SCANWHILE: PROCEDURE (ZZ1) EXTERNAL; DECLARE ZZ1 ADDRESS; END;
SCANUNTIL: PROCEDURE (ZZ1) EXTERNAL; DECLARE ZZ1 ADDRESS; END;
DECLARE FATAL BYTE EXTERNAL;
DECLARE ACTUAL ADDRESS EXTERNAL;
EX :PROCEDURE  EXTERNAL;END;
MEMCK :PROCEDURE ADDRESS EXTERNAL;END;
OPENI :PROCEDURE (ZZ1) EXTERNAL;DECLARE (ZZ1)ADDRESS;END;
OPENU :PROCEDURE (ZZ1) EXTERNAL;DECLARE (ZZ1)ADDRESS;END;
READI :PROCEDURE (ZZ1,ZZ2) EXTERNAL;DECLARE (ZZ1,ZZ2)ADDRESS;END;
READU :PROCEDURE (ZZ1,ZZ2) EXTERNAL;DECLARE (ZZ1,ZZ2)ADDRESS;END;
SBYTEU :PROCEDURE (ZZ1) EXTERNAL;DECLARE (ZZ1)ADDRESS;END;
WRITEU :PROCEDURE (ZZ1,ZZ2) EXTERNAL;DECLARE (ZZ1,ZZ2)ADDRESS;END;
DECLARE FILENAMELIMIT BYTE EXTERNAL;
MOVEPARENSFILENAME :PROCEDURE (ZZ1) EXTERNAL;DECLARE (ZZ1)ADDRESS;END;
OPENSCAN :PROCEDURE (ZZ1) EXTERNAL;DECLARE (ZZ1)ADDRESS;END;
DECLARE FALSE LITERALLY'0';
DECLARE NUL LITERALLY',0))';
DECLARE STR LITERALLY'(.(';
DECLARE TRUE LITERALLY'255';
DECLARE SCANBYTE BASED SCANP BYTE;
OUTPRINT :PROCEDURE (ZZ1) EXTERNAL;DECLARE (ZZ1)ADDRESS;END;
/* ENDPEX */
$LIST

DECLARE TARGET (45) BYTE PUBLIC;
DECLARE TARGADDR ADDRESS AT (.TARGET);
DECLARE TEMP ADDRESS;
DECLARE SYM$MAX ADDRESS;
DECLARE ASSEMBLY$LANGUAGE BYTE INITIAL (0);
DECLARE OUT$P ADDRESS;
DECLARE OUTBYTE BASED OBUF$P BYTE;
DECLARE OUTWORD BASED OBUF$P ADDRESS;
DECLARE OUT$ADDR BASED OUT$P (1) ADDRESS;
DECLARE I BYTE;
DECLARE COL$MAX BYTE;
DECLARE COL$LENGTH BYTE;
DECLARE PTR$INDEX ADDRESS;
DECLARE SYM$COUNT ADDRESS;
DECLARE SYM$BASE ADDRESS;
DECLARE NAMES$TOP ADDRESS;
DECLARE LINES$TOP ADDRESS;
DECLARE LINES$TOP$BYTE BASED LINES$TOP (1) BYTE;
DECLARE CAPACITY$BYTES ADDRESS;
DECLARE SEPARATOR BYTE INITIAL (0CH);
DECLARE SORTING BYTE INITIAL (0FFH);
DECLARE GIVE$UP$BYTE BASED GIVE$UP (3) BYTE;
DECLARE OLD$SYMTAB$SEEN BYTE;
DECLARE LOW$INDEX ADDRESS;
DECLARE INDEX ADDRESS;
DECLARE LIN$BASE ADDRESS;
DECLARE LIN BASED LIN$BASE (1) ADDRESS;
DECLARE SYM$LINE (*) BYTE DATA ('H SYM  ');
DECLARE BAS$LINE (*) BYTE DATA ('H BAS  ');
DECLARE LIN$LINE (*) BYTE DATA ('H LIN  ');
DECLARE STACK$BASE (*) BYTE DATA ('STACK  ');
DECLARE START$OF$RECORD ADDRESS;
DECLARE ARROW (5) BYTE INITIAL ('==>  ');  /* goes right before MOD$NAME */
DECLARE MOD$NAME (32) BYTE INITIAL (0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
DECLARE MOD$NAME$LENGTH BYTE;
DECLARE CLOSE$ARROW (5) BYTE DATA ('  <==');
DECLARE OLD$INDEX ADDRESS;

/* NEW DECLARATIONS FOR VERSION X150, 01/15/81 */

DECLARE WIDTH$OF$TYPE$COL   LITERALLY '3';

DECLARE LINES$IN$HEADER  BYTE INITIAL (3);
DECLARE OFFSET$COL       BYTE INITIAL (8);
DECLARE TYPE$COL         BYTE INITIAL (15);
DECLARE SYMBOL$COL       BYTE INITIAL (20);
DECLARE LINE$COL         LITERALLY 'SYMBOL$COL';

$EJECT

READ$NOT$FINISHED: PROCEDURE BYTE;
  RETURN (ACTUAL = CAPACITY$BYTES);
END;

FLUSH: PROCEDURE;
  IF ACTUAL > 32766 THEN
   DO;
    CALL SBYTEU(-32512);
    CALL SBYTEU(32512 - ACTUAL);
   END;
  ELSE CALL SBYTEU(-ACTUAL);
  CALL WRITEU(LINES$TOP,SCAN$P-LINES$TOP);
  IF OLD$SYMTAB$SEEN THEN ACTUAL = 0;
  ELSE CALL READU(LINES$TOP,CAPACITY$BYTES);
  SCAN$P = LINES$TOP;
  GIVE$UP = LINES$TOP + ACTUAL;
  GIVEUP$BYTE(3) = 0;
  TARLEN = 2;
  TARGADDR = 0C00H;
  IF SFOUND THEN
   DO;
    OLD$SYMTAB$SEEN = TRUE;
    SCAN$P = SCAN$P - 2;
    GIVEUP = SCAN$P;
    CAPACITY$BYTES = ACTUAL + 1;
    SCAN$P = LINES$TOP;
   END;
END;

NEXT$CHAR$BLANK: PROCEDURE BYTE;
  CALL SET$SC(SCAN$P+1);
  RETURN BLNK$CH;
END;

NEXT$TRY: PROCEDURE BYTE;
  TARLEN = 1;
  TARGET(0) = 0AH;
   DO WHILE NOT (DDIG$CH AND NEXT$CHAR$BLANK);
    SCAN$P = SCAN$P - 3;
    IF NOT SFOUND THEN RETURN FALSE;
     DO WHILE TERM$CH;
      IF NOT SFOUND THEN RETURN FALSE;
     END;
    SCAN$P = SCAN$P + 3;
   END;
  SCAN$P = SCAN$P - 3;
  OBUF$P = SCAN$P + 6;
  RETURN TRUE;
END;

$EJECT

NEXT$LINE$NUMBER$FOUND: PROCEDURE BYTE;
  DECLARE DUMMY BYTE;
 TRY$LOOP:
  IF NEXT$TRY THEN RETURN TRUE;
  IF READ$NOT$FINISHED THEN
   DO;
    SCAN$P = GIVEUP - 255;
    DUMMY = SFOUND;
    CALL FLUSH;
    GO TO TRY$LOOP;
   END;
  RETURN FALSE;
END;

OUT$LIN: PROCEDURE (VALUE);
  DECLARE VALUE ADDRESS;
  IF VALUE < LOW$INDEX THEN GO TO DASHES;
  IF VALUE > INDEX THEN GO TO DASHES;
  IF LIN(VALUE) = 0 THEN GO TO DASHES;
  CALL OHEXW(LIN(VALUE));
  RETURN;
 DASHES:
  CALL OUT$WRITE(.('----'),4);
END;

GET$LINE$OFFSET: PROCEDURE;
  SCAN$P = START$OF$RECORD + OFFSET$COL;  /* POINT TO OFFSET COLUMN */
  LIN(INDEX) = HEXIN;
  START$OF$RECORD, SCAN$P = SCAN$P + 15;  /* MOVE TO NEXT RECORD */
END;

READ: PROCEDURE (PTR);
  DECLARE PTR ADDRESS;
  CALL READI(PTR,(CAPACITY$BYTES:=(MEMCK-PTR)));
  SCAN$P = .MEMORY;
  GIVEUP = PTR + ACTUAL;
END;

CHECK$GIVE$UP: PROCEDURE;
  CALL FMOVE(GIVEUP-SCAN$P,SCAN$P,.MEMORY);
  CALL READ(GIVEUP - SCAN$P + .MEMORY);
  SCAN$P = .MEMORY;
  CALL SCAN$WHILE(.TERMCH);
  START$OF$RECORD = SCAN$P;
END;

$EJECT

PUT$SYM$ADDR: PROCEDURE;
  SCAN$P = START$OF$RECORD;
  IF SCAN$BYTE = 'G' THEN
    DO;  /* BASE IS A GROUP */
      TEMP = DECIN;
      OUTBYTE = 0;
      OBUF$P = OBUF$P + 1;
      CALL OUT$CHAR (LOW(TEMP));
      CALL OUT$CHAR (HIGH(TEMP));
    END;
  ELSE IF SCAN$BYTE = 'S' THEN
    DO;
      SCAN$P = SCAN$P + 1;
      IF SCAN$BYTE = '(' THEN
        DO;  /* BASE IS A SEGMENT */
          TEMP = DECIN;
          OUTBYTE = 1;
          OBUF$P = OBUF$P + 1;
          CALL OUT$CHAR (LOW(TEMP));
          CALL OUT$CHAR (HIGH(TEMP));
        END;
      ELSE
        DO;  /* BASE IS STACK */
          OUTBYTE = 2;
          OBUF$P = OBUF$P + 1;
          OUT$WORD = 0;
          OBUF$P = OBUF$P + 2;
          SCAN$P = SCAN$P + 4; /* SKIP PASSED 'STACK' */
        END;
    END;
  ELSE
    DO;  /* BASE IS A FRAME NUMBER */
      OUTBYTE = 3;
      OBUF$P = OBUF$P + 1;
      TEMP = HEXIN;                   /* GET BASE ADDRESS AND OUTPUT IT */
      CALL OUT$CHAR(LOW (TEMP));
      CALL OUT$CHAR(HIGH (TEMP));
    END;
  TEMP = HEXIN;                   /* GET OFFSET ADDRESS AND OUTPUT IT */
  CALL OUT$CHAR(LOW (TEMP));
  CALL OUT$CHAR(HIGH (TEMP));
END;

$EJECT

CHECK$FOR$WARNING: PROCEDURE BYTE;

DECLARE I BYTE;

  IF SCAN$MATCH(.('WARNING:')) THEN
    DO I = 1 TO 4;
      CALL SCAN$UNTIL(.TERMCH);
      SCAN$P = SCAN$P + 2;
      RETURN TRUE;
    END;
  RETURN FALSE;

END CHECK$FOR$WARNING;

$EJECT

STILL$SYMBOLS: PROCEDURE BYTE;

CALL SET$SC(START$OF$RECORD);
SCAN$P = SCAN$P + TYPE$COL;            /* POINT TO TYPE OF RECORD */
IF (SCAN$MATCH(.('SYM',0))) OR (SCAN$MATCH(.('BAS',0))) THEN RETURN TRUE;
ELSE
  DO;
    SCAN$P = START$OF$RECORD;
    IF CHECK$FOR$WARNING THEN
      DO;
        START$OF$RECORD = SCAN$P;
        SCAN$P = SCAN$P + TYPE$COL;
        IF (SCAN$MATCH(.('SYM',0))) OR (SCAN$MATCH(.('BAS',0))) THEN
          RETURN TRUE;
        ELSE RETURN FALSE;
      END;
    ELSE RETURN FALSE;
  END;
RETURN FALSE;

END STILL$SYMBOLS;

COLLECT$SYMBOL$NAMES: PROCEDURE;
  SYM$MAX = 0;
  SYM$COUNT = 0;
  OUT$P = MEMCK;
  OBUF$P = .MEMORY;
   DO WHILE STILL$SYMBOLS;
    OUT$P = OUT$P - 2;
    SYM$COUNT = SYM$COUNT + 1;
    OUT$ADDR(0) = OBUF$P + 1; /* STORE POINTER TO NAME RECORD */
    CALL PUT$SYM$ADDR;
    SCAN$P = START$OF$RECORD + SYMBOL$COL; /* POINT TO SYMBOL NAME */
    SYM$BASE = OBUF$P;
     DO WHILE TOKNCH;
      CALL OUT$SCAN$BYTE;
     END;
    START$OF$RECORD, SCAN$P = SCAN$P + 2;            /* SKIP OVER CRLF */
    SYM$MAX = MAX(OBUF$P-SYM$BASE,SYM$MAX);
    CALL OUT$CHAR(0);
   END;
  NAMES$TOP = OBUF$P;
END;

$EJECT

STILL$LINES: PROCEDURE BYTE;

CALL SET$SC(START$OF$RECORD);
SCAN$P = SCAN$P + TYPE$COL;
IF SCAN$MATCH(.('LIN',0)) THEN RETURN TRUE;
ELSE
  DO;
    SCAN$P = START$OF$RECORD;
    IF CHECK$FOR$WARNING THEN
      DO;
        START$OF$RECORD = SCAN$P;
        SCAN$P = SCAN$P + TYPE$COL;
        IF SCAN$MATCH(.('LIN',0)) THEN RETURN TRUE;
        ELSE RETURN FALSE;
      END;
    ELSE RETURN FALSE;
  END;
RETURN FALSE;

END STILL$LINES;

COLLECT$LINE$NUMBERS: PROCEDURE;

  IF STILL$LINES THEN
   DO;
    SCAN$P = START$OF$RECORD + LINE$COL;  /* POINT TO LINE NUMBER */
    INDEX = (LOW$INDEX := DECIN);         /* INDEX = FIRST LINE NUMBER */
    LIN$BASE = NAMES$TOP - (2*LOW$INDEX); /* LINBASE SET SO INDEX AFTER NAMESTOP */
    CALL GET$LINE$OFFSET;
     DO WHILE STILL$LINES;
      SCAN$P = START$OF$RECORD + LINE$COL; /* POINT TO LINE NUMBER */
      OLD$INDEX = INDEX;
      INDEX = DECIN;
       DO WHILE OLD$INDEX < INDEX - 1;
        OLD$INDEX = OLD$INDEX + 1;
        LIN(OLD$INDEX) = 0;
       END;
      CALL GET$LINE$OFFSET;
     END;
    LINES$TOP = .LIN(INDEX+2);
    LINES$TOP$BYTE(0FFFFH) = 0AH;
   END;
  ELSE /* NO LINE RECORDS FOUND */
   DO;
    ASSEMBLY$LANGUAGE = TRUE;
    LOW$INDEX = 0FFFFH;
    LINES$TOP = NAMES$TOP;
   END;
END;

$EJECT

PROCESS$LOCATE$FILE: PROCEDURE;
  DECLARE I BYTE;

  CALL SET$SC(.MEMORY);
  CALL READ(.MEMORY);                 /* READ IN LOCATE LISTING INTO MEMORY */
  IF SCAN$MATCH (.(FF, 'ISIS-II', 0)) THEN /* FILE OUTPUT BY CROSS LOC86 */
   DO;
    CALL FMOVE(MOD$NAME$LENGTH, .MOD$NAME, .TARGET);
    TARLEN = MOD$NAME$LENGTH + 1;
    CALL FMOVE(3, .(':  '),.TARGET(MOD$NAME$LENGTH));
    LINES$IN$HEADER = 1;
    OFFSET$COL = 7;
    TYPE$COL = 14;
    SYMBOL$COL = 19;
   END;
  ELSE /* FILE OUTPUT BY RESIDENT LINK86 OR LOC86 */
   DO;
    TARLEN = MOD$NAME$LENGTH + 4;
    CALL FMOVE(2, .('= '), .TARGET);
    CALL FMOVE(MOD$NAME$LENGTH, .MOD$NAME, .TARGET(2));
    CALL FMOVE(2, .(CR,LF), .TARGET(MOD$NAME$LENGTH+2));
   END;
   DO WHILE NOT SFOUND;
    IF READ$NOT$FINISHED THEN
     DO;
      CALL FMOVE(TARLEN,GIVEUP-TARLEN,.MEMORY);
      CALL READ(.MEMORY+TARLEN);
     END;
    ELSE
     DO;
      CALL ERROR$MESSAGE STR 'MOD NAME NOT FOUND' NUL;
      CALL EX;
     END;
   END;
  DO I = 1 TO LINES$IN$HEADER;  /* POINT TO FIRST RECORD */
    CALL SCAN$UNTIL(.TERMCH);
    SCAN$P = SCAN$P + 2;
  END;
  START$OF$RECORD = SCAN$P;
  CALL CHECK$GIVEUP;
  CALL COLLECT$SYMBOL$NAMES;
  CALL COLLECT$LINE$NUMBERS;
END;

$EJECT

OUT$SYM$NAME: PROCEDURE;
  DECLARE BASE$TYPE BYTE;

  CALL SET$OB(OBUF$P);
  SCAN$P = OUT$ADDR(PTR$INDEX) - 1;
  BASE$TYPE = SCAN$BYTE AND 0000$0011B;
  SCAN$P = SCAN$P + 1;
  DO CASE BASE$TYPE;  /* OUTPUT BASE */

    /* CASE 0: GROUP INDEX */
    DO;
      CALL OUT$PRINT (.('G=',0));
      CALL OHEXB(SCAN$BYTE);
      CALL OUT$BLANK;
    END;

    /* CASE 1: SEGMENT INDEX */
    DO;
      CALL OUT$PRINT (.('S=',0));
      CALL OHEXB(SCAN$BYTE);
      CALL OUT$BLANK;
    END;

    /* CASE 2: STACK SYMBOL */
    DO;
      CALL OUT$PRINT(.('STAK ',0));
    END;

    /* CASE 3: ABSOLUTE BASE */
    DO;
      CALL OHEXW(SCAN$ADDR);            /* OUTPUT BASE ADDRESS */
      CALL OUT$BLANK;
    END;
  END; /* DO CASE */
  SCAN$P = SCAN$P + 2;              /* SKIP BASE ADDRESS */
  CALL OHEXW(SCAN$ADDR);            /* OUTPUT OFFSET ADDRESS */
  SCAN$P = SCAN$P +2;               /* SKIP OFFSET ADDRESS */
  CALL OUT$BLANK;
  CALL OUT$SCAN$STRING;
END;

OUTPUT$SYMBOLS: PROCEDURE;
  CALL FILL(15000,NAMES$TOP,' ');
  SYM$MAX = SYM$MAX + 14;
  COL$MAX = 128 / SYM$MAX;
  COL$LENGTH = MAX (60, SYM$COUNT/COL$MAX + 1);
  COL$LENGTH = MIN (COL$LENGTH,SYM$COUNT);
  OBUF$P = NAMES$TOP;
  CALL OUT$CHAR(0);
  CALL OUT$CHAR(SEPARATOR);
  CALL OUT$PRINT(.ARROW);
  CALL OUT$WRITE(.CLOSE$ARROW,4);
  CALL OUT$CRLF;
  I = COL$LENGTH;
   DO WHILE I > 0;
    PTR$INDEX = SYM$COUNT + (I := I - 1);
    OBUF$P = OBUF$P + 4;
     DO WHILE PTR$INDEX >= COL$LENGTH;
      PTR$INDEX = PTR$INDEX - COL$LENGTH;
      CALL OUT$SYM$NAME;
      OBUF$P = OBUF$P + SYM$MAX;
     END;
    CALL OUT$CRLF;
   END;
  CALL OUT$CRLF;
  CALL WRITEU(NAMES$TOP,OBUF$P - NAMES$TOP);
END;

$EJECT

SCAN$BACK: PROCEDURE (CHAR);
  DECLARE CHAR BYTE;
   DO WHILE SCAN$BYTE <> CHAR;
    SCAN$P = SCAN$P - 1;
   END;
END;

READ$MOD$NAME: PROCEDURE;
  IF ASSEMBLY$LANGUAGE THEN RETURN;
  TARLEN = 3;
  CALL FMOVE(3,.('DO;'),.TARGET);
  IF NOT SFOUND THEN
   DO;
    TARGADDR = 'od';
    IF NOT SFOUND THEN RETURN;
   END;
  CALL SCAN$BACK(':');
  CALL SCAN$BACK(0AH);
  SCAN$P = SCAN$P + 12;
  CALL SET$OB(.MOD$NAME);
   DO WHILE SCAN$BYTE <> ':';
    IF TOKNCH THEN CALL OUT$SCAN$BYTE;
    ELSE SCAN$P = SCAN$P + 1;
   END;
  CALL OUT$CHAR(0);
END;

$EJECT

/* MAIN LINE CODE */

FATAL = TRUE;
CALL CONSOLE$IN;
CALL PRINT$CR(.SIGN$ON$MSG);
CALL OPEN$SCAN(.OPENI);                  /* OPEN LOCATE LISTING FILE */
FILE$NAME$LIMIT = 31;
CALL MOVE$PARENS$FILE$NAME(.MOD$NAME);   /* GET MODNAME FOR (MODNAME) */
MOD$NAME$LENGTH = LEN$STR$NUL(.MOD$NAME);
I = SCAN$MATCH STR 'IN' NUL;
CALL SCAN$EXPECT STR 'TO' NUL;           /* SCAN FOR 'INTO' IN COMMAND LINE */
CALL PROCESS$LOCATE$FILE;
CALL OPEN$SCAN(.OPENU);                  /* OPEN PLM80 LIST FILE */
 DO WHILE NOT TERM$CH;                   /* SCAN FOR ANY OPTIONS */
  IF FORCUP = 'N' THEN SORTING = FALSE;
  IF FORCUP = 'L' THEN SEPARATOR = 0AH;
  CALL BUMP$SCAN$P;
 END;
CAPACITY$BYTES = OUT$P - LINES$TOP - 4;
OLD$SYMTAB$SEEN = FALSE;
SCAN$P = LINES$TOP;
ACTUAL = 0;
CALL FLUSH;
CALL READ$MOD$NAME;
TARLEN = 1;
TARGET(0) = 0AH;
SCAN$P = SCAN$P + 3;
 DO WHILE NEXT$LINE$NUMBER$FOUND;
  CALL OUTLIN(DECIN);
  CALL OUT$BLANK;
  SCAN$P = SCAN$P + 6;
 END;
SCAN$P = GIVE$UP;
CALL FLUSH;
IF SORTING THEN CALL SORT(OUT$P,SYM$COUNT,.BLTSYM);
CALL OUTPUT$SYMBOLS;
CALL EX;

END;
src/mfiler.plm
$TITLE('==>  F I L E R R  <==  MRKOBJ')
$DEBUG XREF

FILERR: DO;

/************************************************************************/
/*																		*/
/*      '(C) Intel Corporation 1981'.  All rights reserved.  No			*/
/*      part of this program or publication may be reproduced,			*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

/*******  EXTERNALS  *******/

/* FNAMES.LIB */

out$file$name: PROCEDURE (ptr) EXTERNAL; DECLARE ptr ADDRESS; END;

/*  UTIL.LIB  */

DECLARE obuf$p ADDRESS EXTERNAL;
DECLARE scan$p ADDRESS EXTERNAL;
error$message: PROCEDURE (ptr) EXTERNAL; DECLARE ptr ADDRESS; END;
out$blank: PROCEDURE EXTERNAL; END;
out$char: PROCEDURE (char) EXTERNAL; DECLARE char BYTE; END;
out$print: PROCEDURE (ptr) EXTERNAL; DECLARE ptr ADDRESS; END;

/*******  END OF EXTERNALS  *******/



/* file$error$msg is just like file$error$message in fnames.lib
   file$error$message has a bug in it: it doesn't put a null at
   the end of the string it builds for the call to error$message.
   so you tend to get garbage characters printed at the end of the
   string.
*/
file$error$msg: PROCEDURE (msg$ptr, file$name$ptr) PUBLIC;
  DECLARE (msg$ptr, file$name$ptr) ADDRESS;

  /* use free memory for building string,
     since we're going to exit anyways   */

  obuf$p = .memory;
  CALL out$file$name (file$name$ptr);
  CALL out$blank;
  CALL out$print (msg$ptr);
  CALL out$char (0);
  CALL error$message (.memory);
END file$error$msg;


/*  movem just calls the builtin MOVE procedure
    it is used because a call to MOVE turns off the optimize flag
*/
movem: PROCEDURE (count) PUBLIC;
  DECLARE count ADDRESS;

  /* movem always called with source = scan$p & destination = .memory */

  CALL move (count, scan$p, .memory);
END movem;

END;
src/mgsort.asm
$MACROFILE NOGEN

;      '(C) Intel Corporation 1981'.  All rights reserved.  No
;      part of this program or publication may be reproduced,
;      transmitted, transcribed, stored in a retrievel system, or
;      translated into any language or computer language, in any
;      form or by any means, electronic, mechanical, magnetic,
;      optical, chemical, manual or otherwise, without the prior
;      written permission of Intel Corporation, 3065 Bowers
;      Avenue, Santa Clara, California, 95051, Attn: Software
;      License Administration.

; SORT: PROCEDURE (PTR,COUNT,PROC$ADDR) EXTERNAL;
;   DECLARE (PTR,COUNT,PROC$ADDR) ADDRESS;
; END;
;
; SORT ACCEPTS AN ARRAY OF POINTERS AND SORTS THE POINTERS.
;   "COUNT" IS THE NUMBER OF POINTERS.
;   "PTR" IS THE LOCATION OF THE POINTERS
;   "PROC$ADDR" IS THE ADDRESS OF THE FOLLOWING PROCEDURE:
;
; GREATER$THAN: PROCEDURE (PTR1,PTR2);
;   DECLARE (PTR1,PTR2) ADDRESS;
;   ...
; END;
;
; "GREATER$THAN" ACCEPTS AS INPUT TWO POINTERS INTO THE ARRAY
;   OF POINTERS.  IT RETURNS TRUE IFF THE RECORD ASSOCIATED
;   WITH PTR1 IS GREATER THAN THE RECORD ASSOCIATED WITH PTR2.
;
; SORT SORTS THE POINTERS SO THAT THE ASSOCIATED RECORDS ARE IN
;   INCREASING ORDER.
$EJECT
        NAME SORT
        CSEG
        PUBLIC SORT

        MIDPOINT MACRO  ;; LOCATE POINTER IN THE MIDDLE OF THE ARRAY
        MOV A,L
        ADD E
        MOV C,A
        MOV A,H
        ADC D           ;; AC NOW EQUALS (HL+DE) -- NOW DIVIDE BY 2
        RAR
        MOV B,A
        MOV A,C
        RAR             ;; BA NOW EQUALS (HL+DE)/2 -- NOW INSURE THAT IT
                        ;;   HAS THE SAME PARITY AS ALL THE OTHER POINTERS
        XRA L
        ANI 0FEH
        XRA L
        MOV C,A         ;; BC IS THE ANSWER.
        ENDM

        CENTER MACRO    ;;SET HA TO (HL+BC)/2
        DAD B
        MOV A,H
        RAR
        MOV H,A
        MOV A,L
        RAR
        ENDM

        JFALSE MACRO PARAM    ;; JUMP IF BCGTDE WAS FALSE I.E. IF BC <= DE
        JNC PARAM
        ENDM

        SKIP1 MACRO        ;; SKIP NEXT 1 INSTRUCTION BYTE  -- WIPES OUT A
        DB (MVI A,0)
        ENDM

        SKIP2 MACRO        ;; SKIP NEXT 2 INSTRUCTION BYTES  -- WIPES OUT HL
        DB (LXI H,0)
        ENDM

        IFCROSS MACRO ADR  ;; JUMP TO ADR IF BC AND DE HAVE CROSSED.
        MOV A,E
        SUB C
        MOV A,D
        SBB B
        JC ADR
        ENDM
$EJECT
SORT:                 ; BC=COUNT   DE=PROC$ADDR   HL=???   S1=RET   S2=PTR
        XCHG
        SHLD PADDR    ; BC=COUNT   DE=???   HL=PROC$ADDR
        POP H
        XTHL          ; BC=COUNT   DE=???   HL=PTR
        MOV D,H
        MOV E,L       ; BC=COUNT   DE=START$PTR   HL=START$PTR
        DAD B
        DAD B
        DCX H
        DCX H
        XCHG          ; BC=COUNT   DE=END$PTR   HL=START$PTR

HDSORT:                ; INTERIOR SORT ROUTINE WHICH IS CALLED RECURSIVELY.
                      ; SORTS POINTERS AT HL THRU DE.     A,B,C IGNORED.

        MOV A,E
        SUB L
        MOV C,A
        MOV A,D
        SBB H
        RC            ; RETURN IF END$PTR < START$PTR
        ORA C
        RZ            ;   ...OR IF END$PTR = START$PTR
$EJECT
; THE TOPMOST POINTER IS GOING TO BE SWITCHED INTO ITS FINAL POSITION ON
; THE NEXT PAGE.  ON THIS PAGE, WE INCREASE THE PROBABILITY THAT THAT
; FINAL POSITION IS NEAR THE MIDDLE.  THIS SPEEDS THINGS UP.  WE DO SO
; BY LOOKING AT THE BOTTOM, MID, AND TOP POINTERS, AND SWITCHING THE
; SECOND HIGHEST OF THE THREE TO THE TOP POSITION.

                      ; POINTER ARRAY LOOKS LIKE THIS:
                      ; HL . . .    . . . DE
        PUSH H        ; S1 . . .    . . . DE
        MIDPOINT      ; S1 . . . BC . . . DE
        CALL BCGTDE
        CC SWITCH     ; GUARANTEES MID < TOP
        POP H         ; HL . . . BC . . . DE
        PUSH B        ; HL . . . S1 . . . DE
        MOV B,H
        MOV C,L       ; BC . . . S1 . . . DE
        CALL BCGTDE   ; BOTTOM > TOP?
        POP H         ; BC . . . HL . . . DE
        JC ALLSET     ; IF SO THEN TOP IS ALREADY GOOD
        XCHG          ; BC . . . DE . . . HL
        PUSH H        ; BC . . . DE . . . S1
        CALL BCGTDE
        CNC SWITCH    ; GUARANTEES TOP > BOTTOM > MID
        POP D         ; BC . . .    . . . DE
        CALL SWITCH   ; NOW BOTTOM > TOP > MID   SO TOP IS GOOD.
ALLSET:
        PUSH B
        PUSH D        ; S2=BC . . . . . . S1=DE
$EJECT
; IN THIS STAGE, SWITCHES OF POINTERS ARE MADE UNTIL THERE IS A
; SINGLE POINTER IN ITS FINAL POSITION, WITH ALL LESSER POINTERS
; TO THE LEFT AND ALL GREATER POINTERS TO THE RIGHT.

CMPF:
        CALL BCGTDE
        JFALSE CRUZF
        CALL SWITCH
CRUZB:
        DCX D
        DCX D
        IFCROSS RCURS2
CMPB:
        CALL BCGTDE
        JFALSE CRUZB
        CALL SWITCH
CRUZF:
        INX B
        INX B
        IFCROSS RCURS1

        JMP CMPF
$EJECT
; NOW WE CAN SPLIT THE SORT INTO TWO HALF SORTS AND DO THE HALF SORTS
; BY RECURSION.
; AN ADJUSTMENT OF BC OR DE MUST FIRST BE MADE, DEPENDING ON THE ENTRY POINT.

RCURS1:                  ; S2 . . . . . DE BC . . . . . S1
                         ;             GOOD
        DCX D
        DCX D
        SKIP2
RCURS2:                  ; S2 . . . . . DE BC . . . . . S1
                         ;                GOOD
        INX B
        INX B

; NOW COMPUTE WHICH HALF IS SMALLER AND DO IT FIRST.

RCURS:                   ; S2 . . . . . DE GOOD BC . . . . . S1
        MOV H,B
        MOV L,C
        POP B            ; S1 . . . . . DE      HL . . . . . BC
        XTHL             ; HL . . . . . DE      S1 . . . . . BC
        PUSH H           ; S1 . . . . . DE      S2 . . . . . BC
        CENTER
        SUB E
        MOV A,H
        SBB D
        POP H            ; HL . . . . . DE      S1 . . . . . BC
        JNC LEFT
RIGHT:
        XTHL             ; S1 . . . . . . DE   HL . . . BC
        PUSH D           ; S2 . . . . . . S1   HL . . . BC
        MOV D,B
        MOV E,C          ; S2 . . . . . . S1   HL . . . DE
        SKIP1
LEFT:
        PUSH B           ; HL . . . DE   S2 . . . . . . S1

        CALL HDSORT       ; SORT THE FIRST HALF
        POP D
        POP H            ; POP OFF THE POINTERS TO THE OTHER HALF
        JMP HDSORT        ; SORT THE OTHER HALF
$EJECT

SWITCH:           ; SWITCH WORD POINTED AT BY BC WITH WORD POINTED AT BY DE
                  ; SAVE B,C,D,E

        MOV H,B
        MOV L,C
        LDAX D
        MOV C,M
        MOV M,A
        XCHG
        MOV M,C
        INX H
        INX D
        LDAX D
        MOV C,M
        MOV M,A
        XCHG
        MOV M,C
        DCX D
        DCX H
        MOV C,L
        RET

        DSEG
BCGTDE:                  ; CALL EXTERNALLY-PASSED "BC GREATER THAN DE"
                         ; ROUTINE SO AS TO PRESERVE B,C,D,E AND RETURN
                         ; THE ANSWER IN THE CARRY FLAG (CARRY=TRUE)

        PUSH B
        PUSH D
        DB (CALL 0)
PADDR:
        DW 0
        RAR
        POP D
        POP B
        RET

        STKLN 100

$EJECT
        END
src/minvok.plm
$TITLE('==>  I N V O K  <==  MRKOBJ')
$DEBUG XREF

INVOK: DO;

/************************************************************************/
/*																		*/
/*      '(C) Intel Corporation 1981'.  All rights reserved.  No			*/
/*      part of this program or publication may be reproduced,			*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

      /*******  EXTERNALS *******/

/* FNAMES.LIB */

open$scan: PROCEDURE (proc$addr) EXTERNAL; DECLARE proc$addr ADDRESS; END;

/*  UTIL.LIB  */

DECLARE scan$p ADDRESS EXTERNAL;
console$in: PROCEDURE EXTERNAL; END;
error$message: PROCEDURE (ptr) EXTERNAL; DECLARE ptr ADDRESS; END;
file$ch: PROCEDURE BYTE EXTERNAL; END;
scan$match: PROCEDURE (ptr) BYTE EXTERNAL; DECLARE ptr ADDRESS; END;
scan$while: PROCEDURE (proc$addr) EXTERNAL; DECLARE proc$addr ADDRESS; END;
scan$while$blanks: PROCEDURE EXTERNAL; END;

/*  SYS.LIB   */

DECLARE report BYTE EXTERNAL;
DECLARE fatal  BYTE EXTERNAL;
isis$cl: PROCEDURE (proc$code,block$ptr) EXTERNAL;
  DECLARE proc$code BYTE, block$ptr ADDRESS; END;
open$u: PROCEDURE (file$name$ptr) EXTERNAL;
  DECLARE file$name$ptr ADDRESS; END;

/* FILERR.P80 */

file$error$msg: PROCEDURE (msg$ptr, file$name$ptr) EXTERNAL;
  DECLARE (msg$ptr, file$name$ptr) ADDRESS; END;

/*******  END OF EXTERNALS  *******/

DECLARE spath$code LITERALLY '14',
        TRUE       LITERALLY '0FFH',
        FALSE      LITERALLY '0';

DECLARE spath$file$info (12) BYTE,
        spath$status         ADDRESS,
        spath$block STRUCTURE (
         file$name$ptr ADDRESS,
         file$info$ptr ADDRESS,
         status$ptr    ADDRESS) INITIAL (0, .spath$file$info, .spath$status),
        temp                  BYTE;

DECLARE source$file$name$ptr ADDRESS PUBLIC AT (.spath$block.file$name$ptr);
DECLARE object$file$name$ptr ADDRESS PUBLIC;


process$invocation$line: PROCEDURE PUBLIC;

  fatal,          /* all ISIS errors are fatal */
  report = TRUE;  /* automatic error reporting */

  CALL console$in;  /* read rest of line, set scan$p at the beginning */
  CALL scan$while$blanks;

  /* now should be pointing at the object file name */

  object$file$name$ptr = scan$p;
  CALL scan$while (.file$ch);  /* past object file name, will open it later */
  CALL scan$while$blanks;

  IF NOT scan$match (.('WITH',0)) THEN
    CALL error$message (.('SCAN ERROR, "WITH" EXPECTED',0));
  CALL scan$while$blanks;

  /* should now be pointing at source file name
     use SPATH to validate file name            */

  spath$block.file$name$ptr = scan$p;
  CALL isis$cl (spath$code, .spath$block);
  IF spath$status <> 0 THEN
    CALL file$error$msg (.('IS A BAD SOURCE FILE NAME',0),
                         source$file$name$ptr);

  /* ignore rest of line, if any */
  /* invocation line OK, open object file for update */

  scan$p = object$file$name$ptr;
  CALL open$scan (.open$u);

END process$invocation$line;

END;
src/mrkobj.plm
$TITLE('==>  M R K O B J  <==  MRKOBJ')
$DEBUG XREF

MRKOBJ: DO;

/************************************************************************/
/*																		*/
/*      '(C) Intel Corporation 1981'.  All rights reserved.  No			*/
/*      part of this program or publication may be reproduced,			*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

DECLARE COPYRIGHT (*) BYTE DATA ('(C) INTEL CORP 1981');

DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.1',0);

/*******  EXTERNALS  *******/

/*  SYS.LIB  */

DECLARE actual ADDRESS EXTERNAL;
ex: PROCEDURE EXTERNAL; END;
readu: PROCEDURE (dst,count) EXTERNAL; DECLARE (dst,count) ADDRESS; END;
sbyteu: PROCEDURE (distance) EXTERNAL; DECLARE distance ADDRESS; END;
writeu: PROCEDURE (src,count) EXTERNAL; DECLARE (src,count) ADDRESS; END;

/* UTIL.LIB  */

DECLARE scan$p ADDRESS EXTERNAL;
DECLARE obuf$p ADDRESS EXTERNAL;
error$message: PROCEDURE (ptr) EXTERNAL; DECLARE ptr ADDRESS; END;
file$ch: PROCEDURE BYTE EXTERNAL; END;
out$scan$byte: PROCEDURE EXTERNAL; END;

/* INVOK.P80 */

process$invocation$line: PROCEDURE EXTERNAL; END;
DECLARE source$file$name$ptr ADDRESS EXTERNAL;
DECLARE object$file$name$ptr ADDRESS EXTERNAL;

/* FILERR.P80 */

file$error$msg: PROCEDURE (msg$ptr, file$name$ptr) EXTERNAL;
  DECLARE (msg$ptr, file$name$ptr) ADDRESS; END;
movem: PROCEDURE (count) EXTERNAL; DECLARE count ADDRESS; END;

/*******  END OF EXTERNALS  *******/

DECLARE scan$byte BASED scan$p BYTE,
        scan$word BASED scan$p ADDRESS,
        obuf$byte BASED obuf$p BYTE;

DECLARE end$of$filled$buffer ADDRESS,
        mod$end$rec$type     BYTE,
        mod$end$record$ptr   ADDRESS,
        record$length        ADDRESS,
        bytes$to$rewrite     ADDRESS,
        crec$begin           ADDRESS,
        crec$length$ptr      ADDRESS,
        crec$length BASED crec$length$ptr ADDRESS,
        check$sum            BYTE INITIAL (0),
        first$buffer$byte    BYTE AT (.memory) INITIAL (0);

DECLARE segid$8080$record STRUCTURE (
         type     BYTE,
         r$length ADDRESS,
         segid    BYTE,
         offset   ADDRESS,
         line$no  ADDRESS,
         checksum BYTE ) INITIAL (008H,6,0,0,0,0F2H);

DECLARE crec$8080 (31) BYTE INITIAL
       (10H,0,0,0,'SOURCE_FILE=              ',0),
        crec$8086 (32) BYTE INITIAL
  (88H,0,0,0FFH,0,'SOURCE_FILE=              ',0);

DECLARE crec$8080$name$length BYTE AT (.crec$8080(3));


DECLARE library$msg (*) BYTE INITIAL ('IS AN 808X LIBRARY',0),
        library$msg$type BYTE AT (.library$msg(9));
DECLARE not$obj$msg (*) BYTE INITIAL ('IS NOT AN OBJECT MODULE',0);

its$a$library: PROCEDURE (type);
  DECLARE type BYTE;

  library$msg$type = type;
  CALL file$error$msg (.library$msg, object$file$name$ptr);
  CALL ex;
END its$a$library;


its$not$an$object$module: PROCEDURE;

  CALL file$error$msg (.not$obj$msg, object$file$name$ptr);
  CALL ex;
END its$not$an$object$module;



scan$whole$file: PROCEDURE;
  DECLARE new$scan$p ADDRESS;
  /* the whole file is in the buffer,
     just scan until modend record found */

  DO WHILE scan$byte <> mod$end$rec$type;
    scan$p = scan$p + 1;
    record$length = scan$word;
    /* check for possibility of missing modend record! */
    new$scan$p = scan$p + record$length + 2;
    IF (new$scan$p >= end$of$filled$buffer)  /* but still less than 64K */
     OR (new$scan$p < scan$p) THEN  /* wrapped around 64K */
      CALL error$message (.('MISSING MODEND RECORD?!',0));
    scan$p = new$scan$p;
  END;
END scan$whole$file;


scan$and$buffer$file: PROCEDURE;
  DECLARE three$bytes$left$ptr ADDRESS,
          bytes$to$move        ADDRESS,
          bytes$left$in$buffer ADDRESS,
          too$much$file        ADDRESS;

  /* can't fit whole object file into buffer,
     must handle scanning to end of buffer, etc. */

  three$bytes$left$ptr = end$of$filled$buffer - 3;
  DO WHILE scan$byte <> mod$end$rec$type;
    IF scan$p >= three$bytes$left$ptr THEN  /* length field may not be here */
      DO;
        IF scan$p >= end$of$filled$buffer THEN  /* went too far, abort */
          DO;
            CALL error$message (.('UNABLE TO SCAN OBJECT FILE',0));
            CALL ex;
          END;
        /* OK here, move unscanned bytes to beginning and read again */
        bytes$to$move = end$of$filled$buffer - scan$p;
        CALL movem (bytes$to$move);
        CALL readu (.memory + bytes$to$move, 7000H);
        scan$p = .memory;
        end$of$filled$buffer = .memory + bytes$to$move + actual;
        IF actual < 7000H THEN  /* all the rest of the file is in the buffer */
          DO;
            CALL scan$whole$file;  /* do it the easy way */
            RETURN;
          END;
        three$bytes$left$ptr = end$of$filled$buffer - 3;
      END;
    /* now OK to look at the record length */
    scan$p = scan$p + 1;
    record$length = scan$word;
    scan$p = scan$p + 2;  /* bump past record field */
    /* record$length bytes may not have been read yet */
    bytes$left$in$buffer = end$of$filled$buffer - scan$p;
    DO WHILE bytes$left$in$buffer <= record$length;
      CALL readu (.memory, 7000H);
      scan$p = .memory;
      end$of$filled$buffer = .memory + actual;
      record$length = record$length - bytes$left$in$buffer;
      IF actual < 7000H THEN
        DO;
          scan$p = scan$p + record$length;
          CALL scan$whole$file;
          RETURN;
        END;
      bytes$left$in$buffer = actual;
      three$bytes$left$ptr = end$of$filled$buffer - 3;
    END;
    /* whatever's left of this record is in the buffer now */
    scan$p = scan$p + record$length;
    /* now pointing at next record type byte */
  END;  /* WHILE scan$byte <> mod$end$rec$type */
  /* now we've found the modend record, but there's still more to read */
  bytes$to$move = end$of$filled$buffer - scan$p;
  CALL movem (bytes$to$move);
  /* this is the last read, if it doesn't all fit, give up */
  too$much$file = 7000H - bytes$to$move + 1;
  CALL readu (.memory + bytes$to$move, too$much$file);
  IF actual = too$much$file THEN
    CALL error$message (.('CANNOT MARK OBJECT MODULE SEQUENCE',0));
  scan$p = .memory;
  end$of$filled$buffer = .memory + bytes$to$move + actual;
END scan$and$buffer$file;


/***************    MAINLINE CODE    ***************/

  CALL process$invocation$line;
  /* now object file has been opened for update */
  /* read the first byte to check for valid file */

  CALL readu (.memory, 1);
  IF first$buffer$byte = 002H THEN  /* 8080 module */
    mod$end$rec$type = 004H;
  ELSE IF first$buffer$byte = 080H THEN  /* 8086 translator module */
    mod$end$rec$type = 08AH;
  ELSE IF first$buffer$byte = 082H THEN  /* 8086 linker module */
    mod$end$rec$type = 08AH;
  ELSE IF first$buffer$byte = 06EH THEN  /* 8086 locater module */
    mod$end$rec$type = 08AH;
  ELSE IF first$buffer$byte = 02CH THEN  /* 8080 library */
    CALL its$a$library('0');
  ELSE IF first$buffer$byte = 0A4H THEN  /* 8086 library */
    CALL its$a$library('6');
  ELSE CALL its$not$an$object$module;

  /* OK to mark this object file, read it in */
  CALL readu (.memory + 1, 7000H);  /* 28K read */
  scan$p = .memory;
  end$of$filled$buffer = .memory + actual + 1;  /* points after last byte */
  IF actual < 7000H THEN  /* the whole file fit into the buffer */
    CALL scan$whole$file;
  ELSE  /* there's still more to read */
    CALL scan$and$buffer$file;

  /* now pointing at modend record */
  bytes$to$rewrite = end$of$filled$buffer - scan$p;
  mod$end$record$ptr = scan$p;
  
  /* seek backwards */
  CALL sbyteu (-bytes$to$rewrite);

  /* build comment record */
  IF mod$end$rec$type = 004H THEN  /* 8080 */
    DO;
      crec$length$ptr = (crec$begin := .crec$8080) + 1;
      obuf$p = .crec$8080(16);      /* source file name area */
    END;
  ELSE  /* 8086 */
    DO;
      crec$length$ptr = (crec$begin := .crec$8086) + 1;
      obuf$p = .crec$8086(17);
    END;
  scan$p = source$file$name$ptr;
  DO WHILE file$ch;
    CALL out$scan$byte;  /* put source file name into comment record */
  END;
  crec$length = obuf$p - crec$length$ptr - 1;  /* set record length */
  IF mod$end$rec$type = 004H THEN  /* set name length byte in 8080 record */
    crec$8080$name$length = crec$length - 2;
  /* now calculate checksum */
  scan$p = crec$begin;
  DO WHILE scan$p < obuf$p;
    check$sum = check$sum + scan$byte;
    scan$p = scan$p + 1;
  END;
  obuf$byte = 256 - check$sum;

  /* write the comment record and the rest of the object file */
  CALL writeu (crec$begin, crec$length + 3);
  IF mod$end$rec$type = 004H THEN  /* write dummy segid record for 8080 */
    CALL writeu (.segid$8080$record, 9);
  CALL writeu (mod$end$record$ptr, bytes$to$rewrite);

  CALL ex;

END;
src/note.plm
NOTE$MOD: DO;

/************************************************************************/
/*																		*/
/*      '(C) Intel Corporation 1981'.  All rights reserved.  No			*/
/*      part of this program or publication may be reproduced,			*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

DECLARE COPYRIGHT (*) BYTE DATA ('(C) INTEL CORP 1981');

DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.0',0);

DECLARE	LIT		LITERALLY	'LITERALLY',
		DCL		LIT	'DECLARE',
		TRUE	LIT	'0FFH',
		FALSE	LIT	'000H',
		PROC	LIT	'PROCEDURE',
		PROCEND	LIT	'END',
		THENDO	LIT	'THEN DO;',
		ELSEIF	LIT	'END; ELSE IF',
		ELSEDO	LIT	'END; ELSE DO;',
		IFEND	LIT	'END',
		WHILEND	LIT	'END',
		CR		LIT	'0DH',
		LF		LIT	'0AH';

EXIT:	PROC EXTERNAL;											PROCEND;
RESCAN:	PROC (A,B) EXTERNAL;		DCL (A,B) ADDRESS;			PROCEND;
READ:	PROC (A,B,C,D,E) EXTERNAL;	DCL (A,B,C,D,E) ADDRESS;	PROCEND;
WRITE:	PROC (A,B,C,D) EXTERNAL;	DCL (A,B,C,D) ADDRESS;		PROCEND;
SPATH:	PROC (A,B,C) EXTERNAL;		DCL (A,B,C) ADDRESS;		PROCEND;
WHOCON:	PROC (A,B) EXTERNAL;		DCL (A,B) ADDRESS;			PROCEND;
IOCHK:	PROC BYTE EXTERNAL;										PROCEND;
CO:		PROC (A) EXTERNAL;			DCL (A) BYTE;				PROCEND;

DCL (STATUS, ACTUAL) ADDRESS;
DCL (CMND, CMND$PTR) ADDRESS, (CMND$CH BASED CMND$PTR) (1) BYTE;
DCL (FILE) (15) BYTE;
DCL (PN) STRUCTURE
	(DEV BYTE, NAME (6) BYTE, EXT (3) BYTE, DEV$TYPE BYTE, DRIVE$TYPE BYTE);
DCL (COLD$START$CO) BYTE;

CALL RESCAN (1, .STATUS);
CALL READ (1, .MEMORY, 128, .ACTUAL, .STATUS); /* Get command tail. */
CMND = .MEMORY + ACTUAL;
CMND$PTR = .MEMORY;
DO WHILE CMND$PTR < CMND;
	IF CMND$CH (0) = '&' THENDO
		CMND$CH (1) = CR;
		CMND$CH (2) = LF;
		CALL WRITE (0, .('**'), 2, .STATUS);
		CALL READ (1, CMND$PTR + 3, 128, .ACTUAL, .STATUS);
		CMND = CMND$PTR + ACTUAL + 3;
	IFEND;
	CMND$PTR = CMND$PTR + 1;
WHILEND;

CALL WHOCON (0, .FILE); /* Find out what the :CO: file is. */
CALL SPATH (.FILE, .PN, .STATUS);
COLD$START$CO = IOCHK AND 3;
IF (PN.DEV = 7) AND (COLD$START$CO = 0) THENDO /* :CO: = :TO: */
ELSEIF (PN.DEV = 9) AND (COLD$START$CO = 1) THENDO /* :CO: = :VO: */
ELSEDO
	CMND$PTR = .MEMORY;
	DO WHILE CMND$PTR < CMND;
		CALL CO (CMND$CH (0));
		CMND$PTR = CMND$PTR + 1;
	WHILEND;
IFEND;
CALL EXIT;

END NOTE$MOD;
src/open.pex
open: procedure (conn$p, path$p, access, echo, status$p) external;
    declare (conn$p, path$p, access, echo, status$p) address;
end open;
src/out.plm
OUT: DO;

/************************************************************************/
/*																		*/
/*      '(C) Intel Corporation 1981'.  All rights reserved.  No			*/
/*      part of this program or publication may be reproduced,			*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

      

/* THIS MODULE IS RESPONSIBLE FOR BUFFERING OUTPUT */

WRITE: PROCEDURE (AFT,BUF,COU,STA) EXTERNAL;
  DECLARE (AFT,BUF,COU,STA) ADDRESS;
END WRITE;

CHECK$STATUS: PROCEDURE EXTERNAL;
END CHECK$STATUS;

/* LOCAL DECLARATIONS */

DECLARE
  CR LITERALLY '0DH',    /* ASCII */
  LF LITERALLY '0AH',    /* ASCII */

  OUT$AFTN ADDRESS EXTERNAL,    /* AFTN OF LIST FILE */
  ACTUAL ADDRESS EXTERNAL,    /* RETURNED BY ISIS */
  STATUS ADDRESS EXTERNAL,    /* RETURNED BY ISIS */
  BUFFER(2048) BYTE AT(.MEMORY), /* OUTPUT BUFFER */
  CURSOR ADDRESS INITIAL(0); /* POINTER INTO BUFFER */

DUMP: PROCEDURE PUBLIC;
  IF CURSOR>0
  THEN DO;
    CALL WRITE(OUT$AFTN,.BUFFER,CURSOR,.STATUS);
    CALL CHECK$STATUS;
    CURSOR = 0;
  END;
END DUMP;

DISPLAY: PROCEDURE (LEN,ADDR) PUBLIC;

  DECLARE
    LEN BYTE,    /* LENGTH OF TEXT TO PRINT */
    ADDR ADDRESS, /* ADDRESS OF INCOMMING OUTPUT */
    CHAR BASED ADDR BYTE;

  DO WHILE LEN>0;
    IF CHAR<20H OR CHAR>7EH
    THEN IF (CHAR = 0DH)  /* CARRIAGE RETURN */ OR
            (CHAR = 0AH) /* LINE FEED */
         THEN BUFFER(CURSOR) = CHAR;
         ELSE IF CHAR = 09H /* TAB */
              THEN BUFFER(CURSOR) = ' ';
              ELSE BUFFER(CURSOR) = '?';
    ELSE BUFFER(CURSOR) = CHAR;
    CURSOR = CURSOR + 1;
    ADDR = ADDR + 1;
    LEN = LEN - 1;
    IF CURSOR = 2048 THEN CALL DUMP;
  END;

END DISPLAY;

BLANKS: PROCEDURE (LEN) PUBLIC;

  DECLARE
    LEN BYTE;    /* LENGTH OF BLANKS TO PRINT */

  DO WHILE LEN>0;
    BUFFER(CURSOR) = ' ';
    CURSOR = CURSOR + 1;
    LEN = LEN - 1;
    IF CURSOR = 2048 THEN CALL DUMP;
  END;

END BLANKS;

NEW$LINE: PROCEDURE PUBLIC;

  /* DISPLAY CRLF */

  CALL DISPLAY(2,.(CR,LF));

END NEW$LINE;

END OUT;

src/pack.plm
Pack:   DO;


/************************************************************************/
/*																		*/
/*      '(C) Intel Corporation 1981'.  All rights reserved.  No			*/
/*      part of this program or publication may be reproduced,			*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

      
DECLARE COPYRIGHT (*) BYTE DATA ('(C) INTEL CORP 1981');

DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.0',0);
    


/*    This program is designed to accept ascii files and compress
      the blanks to reduce the storage costs on disks

      Blanks are compressed by converting strings of consecutive
      blanks into a single byte which has the high bit on.  This
      necessarily dictates that the system in use does not use
      the parity bit.  Strings of blanks greater than 128 are
      manipulated as multiple compression bytes.

*/

DECLARE dcl LITERALLY 'DECLARE';
DECLARE as LITERALLY 'LITERALLY';

dcl boolean as 'BYTE';
dcl end$of$file as 'actual=0';
dcl depart as '0FFH';
dcl true as '0FFH';
dcl false as '0';
dcl character as 'BYTE';
dcl pointer as 'ADDRESS';
dcl int1 as 'BYTE';
dcl int2 as 'ADDRESS';
dcl nil as '0';

dcl thenn as 'THEN DO;';
dcl elseif as 'END; ELSE IF';
dcl elsee as 'END; ELSE DO;';
dcl endif as 'END;';
dcl whilee as 'DO WHILE';
dcl endwhile as 'END;';
dcl for as 'DO';
dcl endfor as 'END;';
dcl enddo as 'END;';

dcl compress$1 as '0FFH';
dcl buffer$size as '10240';
dcl limit as 'buffer$size-1';
dcl cr as '0DH';
dcl lf as '0AH';

/* system EXTERNALs */

open:
  PROCEDURE (aft,file,access,mode,status) EXTERNAL;
    DECLARE (aft,file,access,mode,status) ADDRESS;

  END open;

close:
  PROCEDURE (aft,status) EXTERNAL;
    DECLARE (aft,status) ADDRESS;

  END close;

read:
  PROCEDURE (aft,buffer,count,actual,status) EXTERNAL;
    DECLARE (aft,buffer,count,actual,status) ADDRESS;

  END read;

write:
  PROCEDURE (aft,buffer,count,status) EXTERNAL;
    DECLARE (aft,buffer,count,status) ADDRESS;

  END write;

delete:
  PROCEDURE (file,status) EXTERNAL;
    DECLARE (file,status) ADDRESS;

  END delete;

exit:
  PROCEDURE EXTERNAL;

  END exit;

seq:
  PROCEDURE (s1,s2,len) boolean EXTERNAL;
    DECLARE s1 ADDRESS;
    DECLARE s2 ADDRESS;
    DECLARE len BYTE;

  END seq;

force$upper:
  PROCEDURE (buffer$ptr) EXTERNAL;
    DECLARE buffer$ptr ADDRESS;

  END force$upper;

file$error:
  PROCEDURE (status, filename$ptr, callexit) EXTERNAL;
    DECLARE (status, filename$ptr) ADDRESS;
    DECLARE callexit boolean;
  END file$error;

dcl disk$type BYTE PUBLIC; /* needed by dmeq */

dmeq:
  PROCEDURE (dir$aftn, search$arg, initial$i$no, dir$entry) ADDRESS EXTERNAL;
    DECLARE (dir$aftn, search$arg, initial$i$no, dir$entry) ADDRESS;
  END dmeq;

spath:
  PROCEDURE(file, buffer, status) EXTERNAL;
    DECLARE (file, buffer, status) ADDRESS;
  END spath;

wpath:
  PROCEDURE(pathname$ptr, pn, wc$used) BYTE EXTERNAL;
    DECLARE (pathname$ptr, pn, wc$used) ADDRESS;
  END wpath;

unpath:
  PROCEDURE(int, ext) EXTERNAL;
    DECLARE (int, ext) ADDRESS;
  END unpath;

packer: PROCEDURE boolean external;
end packer;

dcl version(4) character data('V1.0');
dcl (actual,status) int2;
dcl out$aftn int2 PUBLIC;
dcl in$aftn int2 PUBLIC;
dcl command$line(120) character;
dcl command$pointer pointer;
dcl command$char based command$pointer character;
dcl delete$source boolean;
dcl default$output boolean;
dcl default$extension(3) character initial('PCK');
dcl input$file$name(16) character PUBLIC;
dcl output$file$name(16) character PUBLIC;
dcl input$name pointer PUBLIC;
dcl output$name pointer PUBLIC;
dcl in$name pointer;
dcl out$name pointer;
dcl no$error$occured boolean;

dcl directory$name(16) character initial(':F0:ISIS.DIR ');
dcl dir$aftn int2;
dcl path$name(16) character;
dcl out$path$name(16) character;
dcl max$directory$length int2;
dcl file$found boolean;
dcl wildcard$used boolean;
dcl directory$entry int2;
dcl source$disk int1;
dcl buf16(16) character;
dcl found boolean;
dcl no$such$file as '13';
dcl star$dot$PCK(16) character initial(0,'******PCK      ');

deblank: PROCEDURE( char$ref ) pointer;
   /* scan for next non-blank */
   dcl char$ref pointer;
   dcl char BASED char$ref character;

   whilee char = ' ';
      char$ref = char$ref + 1;
   endwhile
   RETURN char$ref;
end deblank;

scan$blank: PROCEDURE( char$ref ) pointer;
   /* scan for a blank character */
   dcl char$ref pointer;
   dcl char BASED char$ref character;

   whilee char <> ' ' and char <> cr;
      char$ref = char$ref + 1;
   endwhile
   RETURN char$ref;
end scan$blank;

command$tail$error: PROCEDURE;
  CALL write(0,.command$line,command$pointer-.command$line,.status);
  CALL write(0,.('#'),1,.status);
  CALL write(0,command$pointer,actual-(command$pointer-.command$line),.status);
  CALL write(0,.('command tail error',cr,lf),20,.status);
  CALL exit;
END command$tail$error;

more$input$files: PROCEDURE boolean;

   /****************************************************************************
    *
    * This routine sets up the global input$file$name with the next file
    * which matches the wildcard pathname and returns true.  If no
    * more matching file names are found, false is returned.
    *
    ****************************************************************************/

   directory$entry = dmeq(diraftn, .pathname, directory$entry, .buf16);
   if directory$entry >= max$directory$length + 1 thenn
      RETURN false;
   elsee
      found = true;
      buf16(0) = source$disk;
      CALL move(15,.('                '),.input$filename);
      CALL unpath(.buf16, .input$file$name);
      RETURN true;
   endif
end more$input$files;

generate$default$output$filename: PROCEDURE;

   /****************************************************************************
    *
    * This procedure generates the default output$filename by changing
    * the input$filename extension to .PCK if no output filename was
    * specified.  If a name was specified (with wildcard) then the
    * appropriate replacements are made.
    *
    ****************************************************************************/

   dcl i int1;
   dcl internal$name(16) character;

   CALL move(15, .('               '), .output$filename);
   CALL move(15, .out$path$name, .internal$name);
   for i = 1 to 14;
      if out$path$name(i) = '*' or out$path$name(i) = '?' thenn
         internal$name(i) = buf16(i);
      endif
   endfor
   CALL unpath(.internal$name, .output$filename);
end generate$default$output$filename;

/*
     initialize values and open files
*/
   CALL write(0,.('ISIS-II  BLANK COMPRESSOR, '),27,.status);
   CALL write(0,.version,4,.status);
   CALL write(0,.(cr,lf),2,.status);

   CALL read(1,.command$line,120,.actual,.status);
   CALL force$upper(.command$line);
   command$pointer = deblank(.command$line);
   in$name = command$pointer;
   wildcard$used = true;
   status = wpath(in$name,.path$name,.wild$card$used);
   CALL file$error(status, in$name, true);

   output$name = .output$file$name;
   CALL move (15, .('               '), .output$filename);
   command$pointer = deblank(scan$blank(command$pointer));
   out$name = nil;
   if seq(command$pointer,.('TO '),3) thenn
      out$name, command$pointer=deblank(scan$blank(command$pointer));
      command$pointer = deblank(scan$blank(command$pointer));
      CALL move(command$pointer - out$name, out$name, .output$filename);
   endif
   default$output = true;
   if out$name <> nil thenn
      wildcard$used = true;
      status = wpath(out$name, .out$path$name, .wildcard$used);
      CALL file$error(status, out$name, true);
      if not wildcard$used thenn
         default$output = false;
      endif
   elsee
      /* generate template for :F#:*.PCK for output */
      CALL move(15, .star$dot$PCK, .out$path$name);
      out$path$name(0) = pathname(0);
   endif

   delete$source = true;
   if seq(command$pointer, .('DELETE'),6) thenn
      delete$source = true;
      command$pointer = deblank(scan$blank(command$pointer));
   elseif seq(command$pointer, .('NODELETE'),8) thenn
      delete$source = false;
      command$pointer = deblank(scan$blank(command$pointer));
   endif
   if command$char <> cr then call command$tail$error;

   /* setup wild card search */
   directory$name(2) = (source$disk := path$name(0)) + '0';
   path$name(0) = 0;
   CALL spath(.directory$name, .buf16, .status);
   CALL file$error(status, .directory$name, true);
   disk$type = buf16(11);
   if disk$type = 4 thenn
      max$directory$length = 992;
   elsee
      max$directory$length = 200;
   endif
   found = false;
   directory$entry = 0;
   CALL open(.diraftn, .directory$name, 1, 0, .status);
   CALL file$error(status, .directory$name, true);

   if not default$output thenn
      CALL open(.outaftn,output$name,2,0,.status);
      CALL file$error(status,output$name,true);
   endif

   input$name = .input$filename;
   whilee more$input$files;
      no$error$occured = true;
      CALL open(.inaftn,input$name,1,0,.status);
      CALL file$error(status,input$name,false);
      if status <> 0 thenn
         no$error$occured = false;
      endif
      if default$output and no$error$occured thenn
         CALL generate$default$output$filename;
         CALL open(.outaftn,output$name,2,0,.status);
         CALL file$error(status,output$name,false);
         if status <> 0 thenn
            no$error$occured = false;
            CALL close(inaftn, .status);
            CALL file$error(status, input$name, false);
         endif
      endif
      if no$error$occured thenn
         CALL write(0,.('  '),2,.status);
         CALL write(0,input$name,15,.status);
         CALL write(0,.(' TO '),4,.status);
         CALL write(0,output$name,15,.status);
         no$error$occured = not packer;
         if no$error$occured thenn
            CALL write(0,.(' PACKED '),8,.status);
         elsee
            CALL write(0,.(' ERROR  '),8,.status);
         endif

         if default$output thenn
            CALL close(outaftn,.status);
            CALL file$error(status,output$name,false);
         endif

         CALL close(inaftn, .status);
         CALL file$error(status, input$name, false);

         if delete$source and no$error$occured thenn
            CALL delete(input$name, .status);
            CALL file$error(status, input$name, false);
            CALL write(0,.(' DELETED'),8,.status);
         endif
         CALL write(0,.(cr,lf),2,.status);

      endif
   endwhile
   CALL close(dir$aftn, .status);
   CALL file$error(status, .directory$name, true);
   if not found thenn
      CALL file$error(no$such$file, in$name, true);
   endif
   CALL exit;
end Pack;
src/packer.plm
Packer:   DO;


/************************************************************************/
/*																		*/
/*      '(C) Intel Corporation 1981'.  All rights reserved.  No			*/
/*      part of this program or publication may be reproduced,			*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

      
/*    These routines are designed to accept ascii files and compress
      the blanks to reduce the storage costs on disks

      Blanks are compressed by converting strings of consecutive
      blanks into a single byte which has the high bit on.  This
      necessarily dictates that the system in use does not use
      the parity bit.  Strings of blanks greater than 128 are
      manipulated as multiple compression bytes.

      The logical value returned is true if an error occured

*/

DECLARE dcl LITERALLY 'DECLARE';
DECLARE as LITERALLY 'LITERALLY';

dcl boolean as 'BYTE';
dcl end$of$file as 'actual=0';
dcl depart as '0FFH';
dcl true as '0FFH';
dcl false as '0';
dcl character as 'BYTE';
dcl pointer as 'ADDRESS';
dcl int1 as 'BYTE';
dcl int2 as 'ADDRESS';
dcl nil as '0';

dcl thenn as 'THEN DO;';
dcl elseif as 'END; ELSE IF';
dcl elsee as 'END; ELSE DO;';
dcl endif as 'END;';
dcl whilee as 'DO WHILE';
dcl endwhile as 'END;';
dcl enddo as 'END;';
dcl for as 'DO';
dcl endfor as 'END;';

dcl compress$1 as '0FFH';
dcl buffer$size as '20480';
dcl limit as 'buffer$size-1';
dcl cr as '0DH';
dcl lf as '0AH';

/* system EXTERNALs */
read:
  PROCEDURE (aft,buffer,count,actual,status) EXTERNAL;
    DECLARE (aft,buffer,count,actual,status) address;

  END read;

write:
  PROCEDURE (aft,buffer,count,status) EXTERNAL;
    DECLARE (aft,buffer,count,status) address;

  END write;

file$error:
  PROCEDURE (status, filename$ptr, callexit) EXTERNAL;
    DECLARE (status, filename$ptr) address;
    DECLARE callexit boolean;
  END file$error;

dcl output$buffer(buffer$size) character;
dcl input$buffer(buffer$size) character;
dcl output$pointer pointer;
dcl output$character based output$pointer character;
dcl input$pointer pointer;
dcl input$character based input$pointer character;
dcl (actual,status) int2;
dcl compress boolean;
dcl compression$byte int1;
dcl i int2;
dcl input$name pointer EXTERNAL;
dcl output$name pointer EXTERNAL;
dcl out$aftn int2 EXTERNAL;
dcl in$aftn int2 EXTERNAL;

output: PROCEDURE(put$char) boolean;

/*
      This procedure accepts a character and fills a buffer.
      When the buffer is full, it is then written to the
      output file.
*/

   dcl put$char character;

   output$character = put$char;
   output$pointer = output$pointer + 1;
   if output$pointer > .output$buffer + limit thenn
      CALL write(outaftn,.output$buffer,buffer$size,.status);
      CALL file$error(status,output$name,false);
      if status <> 0 thenn
         RETURN false;
      endif
      output$pointer = .output$buffer;
   endif
   RETURN true;
END output;

flush: PROCEDURE;

/*
      This routine flushes the output buffer at the end of the file
*/

   if output$pointer = .output$buffer thenn
      RETURN;
   elsee
      CALL write(outaftn,.output$buffer,output$pointer-.output$buffer,
         .status);
      CALL file$error(status,output$name,false);
   endif
END flush;

packer: PROCEDURE boolean PUBLIC;

/*
   This procedure is responsible for compressing the blanks and
   transfering the contents of the input file
*/

   output$pointer = .output$buffer;
   input$pointer = .input$buffer;
   compress = false;

/*
        begin processing
*/

   CALL read(inaftn,.input$buffer,buffer$size,.actual,.status);
   CALL file$error(status,input$name,false);
   if status <> 0 thenn
      RETURN true;
   endif

   whilee not end$of$file;

      for i = 0 TO actual-1;

         if input$character=' ' thenn
            if not compress thenn
               compress=true;
               compression$byte=compress$1;
            elsee
               compression$byte=compression$byte-1;
               if compression$byte=80h thenn
                   /* 128 blanks */
                  if not output(080h) thenn
                     RETURN true;
                  endif
                  compression$byte=compress$1;
               endif
            endif
         elsee
            if compress thenn
               if not output(compression$byte) thenn
                  RETURN true;
               endif
               compress=false;
            endif
            if not output(input$character) thenn
               RETURN true;
            endif
         endif
         input$pointer=input$pointer+1;
      endfor

      CALL read(inaftn,.input$buffer,buffer$size,.actual,.status);
      CALL file$error(status,input$name,false);
      if status <> 0 thenn
         RETURN true;
      endif
      input$pointer=.input$buffer;
   endwhile

   CALL flush;
   RETURN false;
end packer;

end Packer;
src/pause.plm
$ TITLE('PAUSE')

PAUSE$MOD:
DO;


/************************************************************************/
/*																		*/
/*      '(C) Intel Corporation 1981'.  All rights reserved.  No			*/
/*      part of this program or publication may be reproduced,			*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

      
DECLARE COPYRIGHT (*) BYTE DATA ('(C) INTEL CORP 1981');

DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.0',0);
    

		/* ISIS.INC */

ATTRIB:
	PROCEDURE(FILE$NAME$PTR,WHICH$ATTRIBUTE,SET$OR$RESET,STATUS$PTR) EXTERNAL;
	DECLARE (FILE$NAME$PTR,WHICH$ATTRIBUTE,SET$OR$RESET,STATUS$PTR) ADDRESS;
	END
ATTRIB;

CLOSE:
	PROCEDURE (AFTN,STATUS) EXTERNAL;
	DECLARE (AFTN,STATUS) ADDRESS;
	END
CLOSE;

CI:
	PROCEDURE BYTE EXTERNAL;
	END
CI;

CO:
	PROCEDURE (CHAR$CO) EXTERNAL;
	DECLARE CHAR$CO BYTE;
	END
CO;

CONSOL:
	PROCEDURE (CONSOLE$INPUT$FILE,CONSOL$OUTPUT$FILE,STATUS$CON) EXTERNAL;
	DECLARE (CONSOLE$INPUT$FILE,CONSOL$OUTPUT$FILE,STATUS$CON) ADDRESS;
	END
CONSOL;

DELETE:
	PROCEDURE (FILE$NAME$PTR,STATUS) EXTERNAL;
	DECLARE (FILE$NAME$PTR,STATUS) ADDRESS;
	END
DELETE;

ERROR:
	PROCEDURE  (ERROR$NUMBER) EXTERNAL;
	DECLARE ERROR$NUMBER ADDRESS;
	END
ERROR;

EXIT:
	PROCEDURE EXTERNAL;
	END
EXIT;

IO$CHK:
	PROCEDURE BYTE EXTERNAL;
	END
IO$CHK;

IO$DEF:
	PROCEDURE (WHICH$DEVICE,ENTRY$POINT) EXTERNAL;
	DECLARE WHICH$DEVICE BYTE,
			ENTRY$POINT ADDRESS;
	END
IO$DEF;

IO$SET:
	PROCEDURE (CONFIGURATION$BYTE) EXTERNAL;
	DECLARE CONFIGURATION$BYTE BYTE;
	END
IO$SET;

LOAD:
	PROCEDURE (FILE,BIAS,CONTROL$OF$TRANSFER,ENTRY$POINT,STATUS) EXTERNAL;
	DECLARE (FILE,BIAS,CONTROL$OF$TRANSFER,ENTRY$POINT,STATUS) ADDRESS;
	END
LOAD;

MEMCK:
	PROCEDURE ADDRESS EXTERNAL;
	END
MEMCK;

OPEN:
	PROCEDURE(AFTN,FILENAME,ACCESS$MODE,LINE$EDIT$AFTN,ERROR) EXTERNAL;
	DECLARE (AFTN,FILENAME,ACCESS$MODE,LINE$EDIT$AFTN,ERROR) ADDRESS;
	END
OPEN;

READ:
	PROCEDURE (AFTN,BUFFER,COUNT,ACTUAL,STATUS) EXTERNAL;
	DECLARE (AFTN,BUFFER,COUNT,ACTUAL,STATUS) ADDRESS;
	END
READ;

RENAME:
	PROCEDURE (OLD$NAME,NEW$NAME,STATUS$R) EXTERNAL;
	DECLARE (OLD$NAME,NEW$NAME,STATUS$R) ADDRESS;
	END
RENAME;

RESCAN:
	PROCEDURE (AFTN,STATUS) EXTERNAL;
	DECLARE (AFTN,STATUS) ADDRESS;
	END
RESCAN;

SEEK:
	PROCEDURE (AFTN,MODE,BLOCKNO,BYTENO,STATUS) EXTERNAL;
	DECLARE (AFTN,MODE,BLOCKNO,BYTENO,STATUS) ADDRESS;
	END
SEEK;

SPATH:
	PROCEDURE (FILE,BUFFER,STATUS) EXTERNAL;
	DECLARE (FILE,BUFFER,STATUS) ADDRESS;
	END
SPATH;

WHOCON:
	PROCEDURE (AFTN,BUFFER) EXTERNAL;
	DECLARE (AFTN,BUFFER) ADDRESS;
	END
WHOCON;

WRITE:
	PROCEDURE (AFTN,BUFFER,COUNT,STATUS) EXTERNAL;
	DECLARE (AFTN,BUFFER,COUNT,STATUS) ADDRESS;
	END
WRITE;

		/* END ISIS.INC */
$ NOLIST
/*         LIT.INC          */

DECLARE                 AS LITERALLY 'LITERALLY',           /* plm */
    AMPERSAND           AS '''&''',							/* ??? */
    BACK$GROUND$FOLLOWS AS '019H',							/* 1510 */
    BELL$CHAR           AS '07H',                           /* plm */
    BLANK               AS '020H',                          /* plm */
    BOOLEAN             AS 'BYTE',                          /* plm */
    CHK                 AS 'CALL CHECK$STATUS',	            /* plm */
    CLEAR$CHAR			AS '01CH',							/* 1510 */
    CO$ECHO$FILE        AS '0F00H',                         /* open */
    COLON               AS ''':''',                         /* char */
    COMMA               AS '02CH',                       	/* plm */
    CONSOLE$INPUT       AS '1',                             /* open */
    CONSOLE$OUTPUT      AS '0',                             /* open */
    CONTROL$Z           AS '01AH',                          /* plm */
    CR                  AS '0DH',                           /* plm */
    DOT                 AS '''.''',                         /* char */
    END$DO              AS 'END',                           /* plm */
    END$DO$CASE         AS 'END',                           /* plm */
    END$DO$FOREVER		AS 'END',							/* plm */
    END$DO$WHILE        AS 'END',                           /* plm */
    END$IF              AS '   ',                           /* plm */
    END$ITERATED$DO		AS 'END',							/* plm */
    END$LOOP            AS ' ',                             /* plm */
    EOF$CHAR            AS 'CONTROL$Z',                     /* plm */
    ESCAPE              AS '01BH',                          /* plm */
    FALSE               AS '0H',                            /* plm */
    FF					AS '0CH',							/* ??? */
    FOREVER             AS 'WHILE 1',                       /* plm */
    FORE$GROUND$FOLLOWS AS '01FH',							/* 1510 */
    FORMAT$ATTRIBUTE	AS '3',								/* attrib */
    LEAD$IN$CHAR		AS '07EH',							/*1510 */
    LF                  AS '0AH',                           /* plm */
    NO$LINE$EDIT        AS '0',                             /* open */
    NULL				AS '0FFH',							/* ???  */
    OPEN$FOR$READ       AS '1',                             /* open */
    OPEN$FOR$WRITE      AS '2',                             /* open */
    OPEN$FOR$UPDATE		AS '3',								/* open */
    PARITY$BIT$MASK		AS '0111$1111$B',					/* plm  */
    PUB$STRING			AS '(*) BYTE PUBLIC DATA',          /* plm  */
    RESET				AS '0',								/* attrib */
    RETURN$MARKER$POS   AS '0',                             /* seek */
    RUB$OUT				AS '07FH',							/* plm  */
    SEEK$2$EOF          AS '4',                             /* seek */
    SEEK$BACKWARD$BY$N  AS '1',                             /* seek */
    SEEK$FORWARD$BY$N	AS '3',								/* seek */
    SEEK$2$N            AS '2',                             /* seek */
    SEMICOLON			AS ''';''',							/* plm  */
    SET					AS '1',								/* attrib */
    STRING              AS '(*) BYTE DATA',                 /* plm  */
    TAB                 AS '09H',                           /* plm */
    TRANSFER$CONTROL    AS '1',                             /* load */
    TRUE                AS '0FFH',                          /* plm */
    UNDERBAR			AS '''_''', 						/* ??? */
    USER$CI             AS '0',                             /* ??? */
    WRITE$PROTECT$ATTRIBUTE 		AS '2',					/* attrib */
    ZERO$BIAS           AS '0'                              /* load */ ;

 /*        ENDLIT.INC        */

$ LIST

DECLARE
    ACTUAL ADDRESS,
    AFTN ADDRESS,

    BLOCK$NO ADDRESS INITIAL (0),
    BYTE$NO ADDRESS  INITIAL (0),

    CI$BUF (130) BYTE,
    CHAR$PTR ADDRESS INITIAL (.CI$BUF),
    CHAR BASED CHAR$PTR BYTE,

    STATUS ADDRESS PUBLIC INITIAL (0),
    WHO$CON$BUF (20) BYTE,
    ZERO$VAL ADDRESS INITIAL (0)         ;

	DECLARE
		FILE$INFORMATION STRUCTURE
           (DEVICE$NUMBER				BYTE,
            FILE$NAME 			(6)		BYTE,
            EXTENSION			(3)		BYTE,
            DEVICE$TYPE					BYTE,
            DRIVE$TYPE			(11)	BYTE);

CHECK$STATUS:
	PROCEDURE EXTERNAL;
	END
CHECK$STATUS;

ISIS$TERMINATOR:
	PROCEDURE (A$CHAR) BOOLEAN EXTERNAL;
	DECLARE A$CHAR BYTE;
	END
ISIS$TERMINATOR;

ERROR$EXIT:
	PROCEDURE (MSG$PTR) EXTERNAL;
	DECLARE MSG$PTR ADDRESS;
	END
ERROR$EXIT;

FORCUP:
	PROCEDURE (TEXT$PTR,COUNT) EXTERNAL;
	DECLARE (TEXT$PTR,COUNT) ADDRESS;
	END
FORCUP;

$ LIST

DECLARE CARRIAGE$RETURN AS 'CR';
DECLARE MESSAGE STRING
	('hit <spacebar> to continue, ^Z to stop --',CR,LF);
DECLARE I BYTE;
DECLARE INPUT$BYTE BYTE;

DECLARE EXECUTE$MSG STRING ('Execute command      ==>"');
DECLARE QUESTION$MARK STRING ('"<==     ??',CR,LF);

CLEAR$SCREEN:
	PROCEDURE;
	DECLARE
		HAZELTINE$LEAD$IN AS '07EH',
        CLEAR$SCREEN$CHAR AS '01CH';
    CALL CO(HAZELTINE$LEAD$IN);
	CALL CO(CLEAR$SCREEN$CHAR);
	END
CLEAR$SCREEN;

RETURN$TO$COLD$BOOT$CI:
	PROCEDURE;
	DECLARE COLD$BOOT$CI (*) BYTE DATA
		(':?I: '),
		CHAR BYTE AT (.COLD$BOOT$CI(1));

	IF IO$CHK THEN
		CHAR = 'V';
	ELSE
		CHAR = 'T';
	ENDIF
	CALL CONSOL(.COLD$BOOT$CI,.(':CO: '),.STATUS);
	END
RETURN$TO$COLD$BOOT$CI;

STRIP$PARITY$BIT:
	PROCEDURE (INPUT$BYTE) BYTE;
	DECLARE INPUT$BYTE BYTE;
	RETURN (0111$1111$B AND INPUT$BYTE);
	END
STRIP$PARITY$BIT;

PRINT$MESSAGE:
    PROCEDURE;
    DO I=0 TO LAST(MESSAGE);
        CALL CO(MESSAGE(I));
    ENDDO;
	END
PRINT$MESSAGE;

CO$IS$VO:
	PROCEDURE BOOLEAN;
	DECLARE WHO$CON$BUF (15) BYTE;
	CALL WHO$CON(CONSOLE$OUTPUT,.WHO$CON$BUF);
	IF
		WHO$CON$BUF(0) = ':' AND
		WHO$CON$BUF(1) = 'V' AND
		WHO$CON$BUF(2) = 'O' AND
		WHO$CON$BUF(3) = ':'		THEN

		RETURN TRUE;
	ELSE
		RETURN FALSE;
	ENDIF
	END
CO$IS$VO;

PRINT$NEXT$LINE:
	PROCEDURE;

	/*	Re-assign the console output to prevent unwanted echoing. */
	CALL CONSOL(.(':CI: '),.(':BB: '),.STATUS); CHK;

    /*	clear the command tail buffer. */
    CALL READ(CONSOLE$INPUT,.CI$BUF,SIZE(CI$BUF),.ACTUAL,.STATUS); CHK;


	/*	Now, read the next line. */
    CALL READ(CONSOLE$INPUT,.CI$BUF,SIZE(CI$BUF),.ACTUAL,.STATUS); CHK;

    /*	Restore the console output. */
    CALL CONSOL(.(':CI: '),.(':VO: '),.STATUS); CHK;

    CALL WRITE(CONSOLE$OUTPUT,.EXECUTE$MSG,SIZE(EXECUTE$MSG),.STATUS); CHK;

    /*	Leave of the trailing CRLF on this write. */
    CALL WRITE(CONSOLE$OUTPUT,.CI$BUF,(ACTUAL-2),.STATUS); CHK;
    CALL WRITE(CONSOLE$OUTPUT,.QUESTION$MARK,SIZE(QUESTION$MARK),.STATUS);
    CHK;

    END
PRINT$NEXT$LINE;

$ EJECT

/********************************************/
/*											*/
/*			FIRST     EXECUTABLE			*/
/*											*/
/********************************************/

IF CO$IS$VO THEN
	CALL EXIT;
ENDIF

CALL PRINT$NEXT$LINE;
CALL PRINT$MESSAGE;
CALL CO(BELL$CHAR);

loop$begin:
	INPUT$BYTE = STRIP$PARITY$BIT(CI);
	IF INPUT$BYTE = CONTROL$Z THEN
		DO;
			CALL RETURN$TO$COLD$BOOT$CI;
            CALL EXIT;
		ENDDO;
	ELSE IF INPUT$BYTE <> BLANK THEN
		GO TO loop$begin;
	ELSE
		DO;
			CALL SEEK(CONSOLE$INPUT,SEEK$BACKWARD$BY$N,.ZERO$VAL,
                               .ACTUAL,.STATUS);
			CHK;
            CALL EXIT;
		ENDDO;
    ENDIF
end$loop

END PAUSE$MOD;
EOF
src/read.pex
read: procedure (conn, buff$p, count, actual$p, status$p) external;
    declare (conn, buff$p, count, actual$p, status$p) address;
end read;
src/relab.plm
$ TITLE ('RELAB -- DISK RELABELLING TOOL')

RELAB$MOD:
DO;


/************************************************************************/
/*																		*/
/*      '(C) Intel Corporation 1981'.  All rights reserved.  No			*/
/*      part of this program or publication may be reproduced,			*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

      
DECLARE COPYRIGHT (*) BYTE DATA ('(C) INTEL CORP 1981');

DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.0',0);
    

		/* ISIS.INC */

ATTRIB:
	PROCEDURE(FILE$NAME$PTR,WHICH$ATTRIBUTE,SET$OR$RESET,STATUS$PTR) EXTERNAL;
	DECLARE (FILE$NAME$PTR,WHICH$ATTRIBUTE,SET$OR$RESET,STATUS$PTR) ADDRESS;
	END
ATTRIB;

CLOSE:
	PROCEDURE (AFTN,STATUS) EXTERNAL;
	DECLARE (AFTN,STATUS) ADDRESS;
	END
CLOSE;

CI:
	PROCEDURE BYTE EXTERNAL;
	END
CI;

CO:
	PROCEDURE (CHAR$CO) EXTERNAL;
	DECLARE CHAR$CO BYTE;
	END
CO;

CONSOL:
	PROCEDURE (CONSOLE$INPUT$FILE,CONSOL$OUTPUT$FILE,STATUS$CON) EXTERNAL;
	DECLARE (CONSOLE$INPUT$FILE,CONSOL$OUTPUT$FILE,STATUS$CON) ADDRESS;
	END
CONSOL;

DELETE:
	PROCEDURE (FILE$NAME$PTR,STATUS) EXTERNAL;
	DECLARE (FILE$NAME$PTR,STATUS) ADDRESS;
	END
DELETE;

ERROR:
	PROCEDURE  (ERROR$NUMBER) EXTERNAL;
	DECLARE ERROR$NUMBER ADDRESS;
	END
ERROR;

EXIT:
	PROCEDURE EXTERNAL;
	END
EXIT;

IO$CHK:
	PROCEDURE BYTE EXTERNAL;
	END
IO$CHK;

IO$DEF:
	PROCEDURE (WHICH$DEVICE,ENTRY$POINT) EXTERNAL;
	DECLARE WHICH$DEVICE BYTE,
			ENTRY$POINT ADDRESS;
	END
IO$DEF;

IO$SET:
	PROCEDURE (CONFIGURATION$BYTE) EXTERNAL;
	DECLARE CONFIGURATION$BYTE BYTE;
	END
IO$SET;

LOAD:
	PROCEDURE (FILE,BIAS,CONTROL$OF$TRANSFER,ENTRY$POINT,STATUS) EXTERNAL;
	DECLARE (FILE,BIAS,CONTROL$OF$TRANSFER,ENTRY$POINT,STATUS) ADDRESS;
	END
LOAD;

MEMCK:
	PROCEDURE ADDRESS EXTERNAL;
	END
MEMCK;

OPEN:
	PROCEDURE(AFTN,FILENAME,ACCESS$MODE,LINE$EDIT$AFTN,ERROR) EXTERNAL;
	DECLARE (AFTN,FILENAME,ACCESS$MODE,LINE$EDIT$AFTN,ERROR) ADDRESS;
	END
OPEN;

READ:
	PROCEDURE (AFTN,BUFFER,COUNT,ACTUAL,STATUS) EXTERNAL;
	DECLARE (AFTN,BUFFER,COUNT,ACTUAL,STATUS) ADDRESS;
	END
READ;

RENAME:
	PROCEDURE (OLD$NAME,NEW$NAME,STATUS$R) EXTERNAL;
	DECLARE (OLD$NAME,NEW$NAME,STATUS$R) ADDRESS;
	END
RENAME;

RESCAN:
	PROCEDURE (AFTN,STATUS) EXTERNAL;
	DECLARE (AFTN,STATUS) ADDRESS;
	END
RESCAN;

SEEK:
	PROCEDURE (AFTN,MODE,BLOCKNO,BYTENO,STATUS) EXTERNAL;
	DECLARE (AFTN,MODE,BLOCKNO,BYTENO,STATUS) ADDRESS;
	END
SEEK;

SPATH:
	PROCEDURE (FILE,BUFFER,STATUS) EXTERNAL;
	DECLARE (FILE,BUFFER,STATUS) ADDRESS;
	END
SPATH;

WHOCON:
	PROCEDURE (AFTN,BUFFER) EXTERNAL;
	DECLARE (AFTN,BUFFER) ADDRESS;
	END
WHOCON;

WRITE:
	PROCEDURE (AFTN,BUFFER,COUNT,STATUS) EXTERNAL;
	DECLARE (AFTN,BUFFER,COUNT,STATUS) ADDRESS;
	END
WRITE;

		/* END ISIS.INC */
$ NOLIST
/*         LIT.INC          */

DECLARE                 AS LITERALLY 'LITERALLY',           /* plm */
    AMPERSAND           AS '''&''',							/* ??? */
    BACK$GROUND$FOLLOWS AS '019H',							/* 1510 */
    BELL$CHAR           AS '07H',                           /* plm */
    BLANK               AS '020H',                          /* plm */
    BOOLEAN             AS 'BYTE',                          /* plm */
    CHK                 AS 'CALL CHECK$STATUS',	            /* plm */
    CLEAR$CHAR			AS '01CH',							/* 1510 */
    CO$ECHO$FILE        AS '0F00H',                         /* open */
    COLON               AS ''':''',                         /* char */
    COMMA               AS '02CH',                       	/* plm */
    CONSOLE$INPUT       AS '1',                             /* open */
    CONSOLE$OUTPUT      AS '0',                             /* open */
    CONTROL$Z           AS '01AH',                          /* plm */
    CR                  AS '0DH',                           /* plm */
    DOT                 AS '''.''',                         /* char */
    END$DO              AS 'END',                           /* plm */
    END$DO$CASE         AS 'END',                           /* plm */
    END$DO$FOREVER		AS 'END',							/* plm */
    END$DO$WHILE        AS 'END',                           /* plm */
    END$IF              AS '   ',                           /* plm */
    END$ITERATED$DO		AS 'END',							/* plm */
    END$LOOP            AS ' ',                             /* plm */
    EOF$CHAR            AS 'CONTROL$Z',                     /* plm */
    ESCAPE              AS '01BH',                          /* plm */
    FALSE               AS '0H',                            /* plm */
    FF					AS '0CH',							/* ??? */
    FOREVER             AS 'WHILE 1',                       /* plm */
    FORE$GROUND$FOLLOWS AS '01FH',							/* 1510 */
    FORMAT$ATTRIBUTE	AS '3',								/* attrib */
    LEAD$IN$CHAR		AS '07EH',							/*1510 */
    LF                  AS '0AH',                           /* plm */
    NO$LINE$EDIT        AS '0',                             /* open */
    NULL				AS '0FFH',							/* ???  */
    OPEN$FOR$READ       AS '1',                             /* open */
    OPEN$FOR$WRITE      AS '2',                             /* open */
    OPEN$FOR$UPDATE		AS '3',								/* open */
    PARITY$BIT$MASK		AS '0111$1111$B',					/* plm  */
    PUB$STRING			AS '(*) BYTE PUBLIC DATA',          /* plm  */
    RESET				AS '0',								/* attrib */
    RETURN$MARKER$POS   AS '0',                             /* seek */
    RUB$OUT				AS '07FH',							/* plm  */
    SEEK$2$EOF          AS '4',                             /* seek */
    SEEK$BACKWARD$BY$N  AS '1',                             /* seek */
    SEEK$FORWARD$BY$N	AS '3',								/* seek */
    SEEK$2$N            AS '2',                             /* seek */
    SEMICOLON			AS ''';''',							/* plm  */
    SET					AS '1',								/* attrib */
    STRING              AS '(*) BYTE DATA',                 /* plm  */
    TAB                 AS '09H',                           /* plm */
    TRANSFER$CONTROL    AS '1',                             /* load */
    TRUE                AS '0FFH',                          /* plm */
    UNDERBAR			AS '''_''', 						/* ??? */
    USER$CI             AS '0',                             /* ??? */
    WRITE$PROTECT$ATTRIBUTE 		AS '2',					/* attrib */
    ZERO$BIAS           AS '0'                              /* load */ ;

 /*        ENDLIT.INC        */

$ LIST

DECLARE
    ACTUAL ADDRESS,
    AFTN ADDRESS,

    BLOCK$NO ADDRESS INITIAL (0),
    BYTE$NO ADDRESS  INITIAL (0),

    STATUS ADDRESS PUBLIC INITIAL (0),
    WHO$CON$BUF (20) BYTE,
    ZERO$VAL ADDRESS INITIAL (0)         ;

	DECLARE
		FILE$INFORMATION STRUCTURE
           (DEVICE$NUMBER				BYTE,
            FILE$NAME 			(6)		BYTE,
            EXTENSION			(3)		BYTE,
            DEVICE$TYPE					BYTE,
            DRIVE$TYPE			(11)	BYTE);

CHECK$STATUS:
	PROCEDURE EXTERNAL;
	END
CHECK$STATUS;

ISIS$TERMINATOR:
	PROCEDURE (A$CHAR) BOOLEAN EXTERNAL;
	DECLARE A$CHAR BYTE;
	END
ISIS$TERMINATOR;

$ LIST

DECLARE ISIS$LAB STRING
	(':F0:ISIS.LAB ');
/*    0123456789012		*/

DECLARE DRIVE$NUM BYTE AT (.ISIS$LAB(2));

DECLARE CHAR$PTR ADDRESS INITIAL (.CI$BUF),
		CHAR BASED CHAR$PTR BYTE,
		CHAR$ARRAY BASED CHAR$PTR (100) BYTE;

DECLARE CI$BUF (140) BYTE;
DECLARE NAME$PART$PTR ADDRESS;
DECLARE NEW$DISK$NAME (9) BYTE INITIAL (0,0,0,0,0,0,0,0,0);
									/*	1 2 3 4 5 6 7 8 9 */

SIGN$ON:
	PROCEDURE;
	DECLARE BANNER STRING
		('ISIS-II DISK RELABELLING UTILITY, V1.0',cr,lf);
	CALL WRITE(CONSOLE$OUTPUT,.BANNER,SIZE(BANNER),.STATUS); CHK;
	END
SIGN$ON;

FORCUP:
	PROCEDURE (TEXT$PTR,COUNT);
	DECLARE TEXT$PTR ADDRESS,
			TEXT BASED TEXT$PTR (100) BYTE;
	DECLARE COUNT ADDRESS;
	DECLARE J ADDRESS;

	DO J=1 TO COUNT;
		IF (TEXT(J)>='a') AND (TEXT(J)<='z') THEN
			TEXT(J) = TEXT(J) - 20H;
        ENDIF
	ENDDO;

	END
FORCUP;

DECIMAL$DIGIT:
	PROCEDURE (A$DIGIT) BOOLEAN;
	DECLARE A$DIGIT BYTE;
	RETURN
		(A$DIGIT>='0')
            AND
        (A$DIGIT<='9');
	END
DECIMAL$DIGIT;

PRINT$DOC:
	PROCEDURE;
	DECLARE DOC STRING
		('syntax is RELAB <isis$disk$filename> | ? | <null>',CR,LF);

	CALL WRITE(CONSOLE$OUTPUT,.DOC,SIZE(DOC),.STATUS); CHK;
	END
PRINT$DOC;

ERROR$EXIT:
	PROCEDURE;
	DECLARE ERR$MSG STRING
		('syntax error',CR,LF);
	CALL WRITE(CONSOLE$OUTPUT,.ERR$MSG,SIZE(ERR$MSG),.STATUS); CHK;
	CALL PRINT$DOC;
	CALL EXIT;
    END
ERROR$EXIT;

CONSTRUCT$NEW$NAME:
	PROCEDURE;

	DECLARE (OLD$NAME$INDEX,NEW$NAME$INDEX) BYTE;
	DECLARE OLD$NAME BASED NAME$PART$PTR (100) BYTE;

    move$and$bump:
    	procedure;
            new$disk$name(new$name$index) = old$name(old$name$index);
            old$name$index = old$name$index + 1;
            new$name$index = new$name$index + 1;
        end
    move$and$bump;

    NEW$NAME$INDEX,OLD$NAME$INDEX = 0;

    DO WHILE (OLD$NAME(OLD$NAME$INDEX)<>DOT) AND
         NOT (ISIS$TERMINATOR(OLD$NAME(OLD$NAME$INDEX)));
        CALL MOVE$AND$BUMP;
    ENDDOWHILE;

	IF OLD$NAME(OLD$NAME$INDEX)=DOT THEN
		DO;
			OLD$NAME$INDEX = OLD$NAME$INDEX + 1;
			NEW$NAME$INDEX = 6;
            DO WHILE NOT ISIS$TERMINATOR(OLD$NAME(OLD$NAME$INDEX));
            	CALL MOVE$AND$BUMP;
            ENDDOWHILE;
		ENDDO;
	ENDIF
    END
CONSTRUCT$NEW$NAME;

LEGIT$FILE$NAME:
	PROCEDURE (FILNAM$PTR) BOOLEAN;

	DECLARE FILNAM$PTR ADDRESS;
	DECLARE FILNAM BASED FILNAM$PTR (100) BYTE;
	DECLARE L ADDRESS;

	good$explicit$device$spec:
		procedure boolean;
		return
             filnam(1)='F' 				and
             decimal$digit(filnam(2))	and
             filnam(3)=COLON 	;
    	end
	good$explicit$device$spec;

    letter$or$digit:
		procedure (a$char) boolean;
		declare a$char byte;
		return
			(a$char>='0' and a$char<='9')
						or
            (a$char>='A' and a$char<='Z')
            						;
    	end
	letter$or$digit;

    /*	check validity of explicit device designation, if any. */
    IF FILNAM(0)=COLON THEN
		DO;
			IF NOT GOOD$EXPLICIT$DEVICE$SPEC THEN
                RETURN FALSE;
			ELSE
            	FILNAM$PTR = FILNAM$PTR + 4;
            ENDIF
		ENDDO;
	ENDIF

	/*	Scan name part.  */
    L=0;
    DO WHILE LETTER$OR$DIGIT(FILNAM(L));
		L = L + 1;
	ENDDO;

	/*	Check for illegal conditions. */
    IF
		L>6 OR 				/*	name part too long		*/
        L=0 OR 				/*	null name part			*/
        FILNAM(L)=COLON		/*	illegal colon terminator*/
        THEN
		RETURN FALSE;
    ENDIF

	/*	Scan extension, if any. */
    IF FILNAM(L) = DOT THEN
		DO;
			DECLARE EXT$BEGIN ADDRESS;
            L = L + 1;
            EXT$BEGIN = L;

            DO WHILE LETTER$OR$DIGIT(FILNAM(L));
				L = L + 1;
			ENDDOWHILE;

            IF
               (FILNAM(L)	=	DOT		OR	/* dot terminator illegal	*/
            	FILNAM(L)	=	COLON	OR	/* colon terminator illegal */
                L-EXT$BEGIN	=	0 		OR	/* null extension 			*/
                L-EXT$BEGIN >	3		)	/* extension too long 		*/
                                     THEN
            	RETURN FALSE;
            ENDIF
		ENDDO;
	ENDIF

	RETURN TRUE;

    END
LEGIT$FILE$NAME;

PARSE$COMMAND$TAIL:
	PROCEDURE;

	CALL READ(CONSOLE$INPUT,.CI$BUF,SIZE(CI$BUF),.ACTUAL,.STATUS); CHK;
	CALL FORCUP(.CI$BUF,SIZE(CI$BUF));

    /*	Point to command tail. */
    DO WHILE CHAR=TAB OR CHAR=BLANK;
		CHAR$PTR = CHAR$PTR + 1;
    ENDDO;

	/*	If question mark... */
    IF CHAR='?' THEN
		DO;
			CALL PRINT$DOC;
			CALL EXIT;
    	ENDDO;
    ENDIF

    /*	If null command tail...*/
    IF CHAR=CR OR
       CHAR=ESCAPE OR
       (CHAR$PTR-.CI$BUF>=121) THEN
       		CALL EXIT;
	ENDIF

    /*	If bad filename...*/
    IF NOT LEGIT$FILENAME(CHAR$PTR) THEN
		CALL ERROR$EXIT;
    ENDIF

    /*	If device explicitly specified...*/
    IF CHAR=COLON THEN
    	DO;
    		DRIVE$NUM = CHAR$ARRAY(2);
    		NAME$PART$PTR = CHAR$PTR + 4;
        ENDDO;
    ELSE
    	NAME$PART$PTR = CHAR$PTR;
    ENDIF

    END
PARSE$COMMAND$TAIL;

RELABEL$DISK:
	PROCEDURE;

	/*	remove software write-protection. */
    CALL ATTRIB(.ISIS$LAB,WRITE$PROTECT$ATTRIBUTE,RESET,.STATUS); CHK;
	CALL ATTRIB(.ISIS$LAB,   FORMAT$ATTRIBUTE,    RESET,.STATUS); CHK;

	/*	alter isis.lab */
    CALL OPEN(.AFTN,.ISIS$LAB,OPEN$FOR$UPDATE,NO$LINE$EDIT,.STATUS); CHK;
    CALL WRITE(AFTN,.NEW$DISK$NAME,SIZE(NEW$DISK$NAME),.STATUS); CHK;
    CALL CLOSE(AFTN,.STATUS); CHK;

    /*	restore "format" attribute. */
    CALL ATTRIB(.ISIS$LAB,   FORMAT$ATTRIBUTE,    SET,.STATUS); CHK;

	END
RELABEL$DISK;

$ EJECT

/********************************************************/
/*														*/
/*					MAIN	LINE	CODE				*/
/*														*/
/********************************************************/

CALL SIGN$ON;
CALL PARSE$COMMAND$TAIL;
CALL CONSTRUCT$NEW$NAME;
CALL RELABEL$DISK;
CALL EXIT;

END
RELAB$MOD;
EOF
src/report.plm
$ TITLE ('==> PASSIF -- REPORTMOD -- REPORT SUCCESS OR FAILURE <==')

REPORT$MOD:
DO;

/************************************************************************/
/*																		*/
/*      '(C) Intel Corporation 1981'.  All rights reserved.  No			*/
/*      part of this program or publication may be reproduced,			*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

$ NOLIST

/*         LIT.INC          */

DECLARE                 AS LITERALLY 'LITERALLY',              /* plm */
    AMPERSAND           AS '''&''',							   /* ??? */
    BELL                AS '07H',                              /* plm */
    BLANK               AS '020H',                             /* plm */
    BOOLEAN             AS 'BYTE',                             /* plm */
    CHK                 AS 'CALL CHECK$STATUS',	               /* plm */
    CLEAR$CHAR			AS '01CH',							   /* 1510 */
    CO$ECHO$FILE        AS '0F00H',                            /* open */
    COLON               AS ''':''',                            /* char */
    COMMA               AS '02CH',                       	   /* plm */
    CONSOLE$INPUT       AS '1',                                /* open */
    CONSOLE$OUTPUT      AS '0',                                /* open */
    CONTROL$Z           AS '01AH',                             /* plm */
    CR                  AS '0DH',                              /* plm */
    DOT                 AS '''.''',                            /* char */
    END$DO              AS 'END',                              /* plm */
    END$DO$CASE         AS 'END',                              /* plm */
    END$DO$WHILE        AS 'END',                              /* plm */
    END$IF              AS '   ',                              /* plm */
    END$ITERATED$DO		AS 'END',							   /* plm */
    END$LOOP            AS ' ',                                /* plm */
    EOF$CHAR            AS 'CONTROL$Z',                        /* plm */
    ESC                 AS '01BH',                             /* plm */
    FALSE               AS '0H',                               /* plm */
    FF					AS '0CH',							   /* ??? */
    FOREVER             AS 'WHILE 1',                          /* plm */
    FORMAT$ATTRIBUTE	AS '3',								   /* attrib */
    HASH$MARK			AS '''#''',							   /* plm */
    INIT$STG			AS '(*) BYTE INITIAL',				   /* plm */
    LEAD$IN$CHAR		AS '07EH',							   /*1510 */
    LF                  AS '0AH',                              /* plm */
    NO$LINE$EDIT        AS '0',                                /* open */
    NULL				AS '0FFFFH',						   /* ???  */
    OPEN$FOR$READ       AS '1',                                /* open */
    OPEN$FOR$WRITE      AS '2',                                /* open */
    OPEN$FOR$UPDATE		AS '3',								   /* open */
    PUB$STRING			AS '(*) BYTE PUBLIC DATA',             /* plm  */
    RESET				AS '0',								   /* attrib */
    RETURN$MARKER$POS   AS '0',                                /* seek */
    SEEK$2$EOF          AS '4',                                /* seek */
    SEEK$BACKWARD$BY$N  AS '1',                                /* seek */
    SEEK$FORWARD$BY$N	AS '3',								   /* seek */
    SEEK$2$N            AS '2',                                /* seek */
    SEMICOLON			AS ''';''',							   /* plm  */
    SET					AS '1',								   /* attrib */
    STRING              AS '(*) BYTE DATA',                    /* plm  */
    TAB                 AS '09H',                              /* plm */
    TRANSFER$CONTROL    AS '1',                                /* load */
    TRUE                AS '0FFH',                             /* plm */
    UNDERBAR			AS '''_''', 						   /* ??? */
    USER$CI             AS '0',                                /* ??? */
    WRITE$PROTECT$ATTRIBUTE 		AS '2',					   /* attrib */
    ZERO$BIAS           AS '0'                                 /* load */ ;

    /*        ENDLIT.INC        */

$ LIST
$ NOLIST

		/* ISIS.INC */

ATTRIB:
	PROCEDURE(FILE$NAME$PTR,WHICH$ATTRIBUTE,SET$OR$RESET,STATUS$PTR) EXTERNAL;
	DECLARE (FILE$NAME$PTR,WHICH$ATTRIBUTE,SET$OR$RESET,STATUS$PTR) ADDRESS;
	END
ATTRIB;

CLOSE:
	PROCEDURE (AFTN,STATUS) EXTERNAL;
	DECLARE (AFTN,STATUS) ADDRESS;
	END
CLOSE;

CI:
	PROCEDURE BYTE EXTERNAL;
	END
CI;

CO:
	PROCEDURE (CHAR$CO) EXTERNAL;
	DECLARE CHAR$CO BYTE;
	END
CO;

CONSOL:
	PROCEDURE (CONSOLE$INPUT$FILE,CONSOL$OUTPUT$FILE,STATUS$CON) EXTERNAL;
	DECLARE (CONSOLE$INPUT$FILE,CONSOL$OUTPUT$FILE,STATUS$CON) ADDRESS;
	END
CONSOL;

DELETE:
	PROCEDURE (FILE$NAME$PTR,STATUS) EXTERNAL;
	DECLARE (FILE$NAME$PTR,STATUS) ADDRESS;
	END
DELETE;

ERROR:
	PROCEDURE  (ERROR$NUMBER) EXTERNAL;
	DECLARE ERROR$NUMBER ADDRESS;
	END
ERROR;

EXIT:
	PROCEDURE EXTERNAL;
	END
EXIT;

IO$CHK:
	PROCEDURE BYTE EXTERNAL;
	END
IO$CHK;

IO$DEF:
	PROCEDURE (WHICH$DEVICE,ENTRY$POINT) EXTERNAL;
	DECLARE WHICH$DEVICE BYTE,
			ENTRY$POINT ADDRESS;
	END
IO$DEF;

IO$SET:
	PROCEDURE (CONFIGURATION$BYTE) EXTERNAL;
	DECLARE CONFIGURATION$BYTE BYTE;
	END
IO$SET;

LOAD:
	PROCEDURE (FILE,BIAS,CONTROL$OF$TRANSFER,ENTRY$POINT,STATUS) EXTERNAL;
	DECLARE (FILE,BIAS,CONTROL$OF$TRANSFER,ENTRY$POINT,STATUS) ADDRESS;
	END
LOAD;

MEMCK:
	PROCEDURE ADDRESS EXTERNAL;
	END
MEMCK;

OPEN:
	PROCEDURE(AFTN,FILENAME,ACCESS$MODE,LINE$EDIT$AFTN,ERROR) EXTERNAL;
	DECLARE (AFTN,FILENAME,ACCESS$MODE,LINE$EDIT$AFTN,ERROR) ADDRESS;
	END
OPEN;

READ:
	PROCEDURE (AFTN,BUFFER,COUNT,ACTUAL,STATUS) EXTERNAL;
	DECLARE (AFTN,BUFFER,COUNT,ACTUAL,STATUS) ADDRESS;
	END
READ;

RENAME:
	PROCEDURE (OLD$NAME,NEW$NAME,STATUS$R) EXTERNAL;
	DECLARE (OLD$NAME,NEW$NAME,STATUS$R) ADDRESS;
	END
RENAME;

RESCAN:
	PROCEDURE (AFTN,STATUS) EXTERNAL;
	DECLARE (AFTN,STATUS) ADDRESS;
	END
RESCAN;

SEEK:
	PROCEDURE (AFTN,MODE,BLOCKNO,BYTENO,STATUS) EXTERNAL;
	DECLARE (AFTN,MODE,BLOCKNO,BYTENO,STATUS) ADDRESS;
	END
SEEK;

SPATH:
	PROCEDURE (FILE,BUFFER,STATUS) EXTERNAL;
	DECLARE (FILE,BUFFER,STATUS) ADDRESS;
	END
SPATH;

WHOCON:
	PROCEDURE (AFTN,BUFFER) EXTERNAL;
	DECLARE (AFTN,BUFFER) ADDRESS;
	END
WHOCON;

WRITE:
	PROCEDURE (AFTN,BUFFER,COUNT,STATUS) EXTERNAL;
	DECLARE (AFTN,BUFFER,COUNT,STATUS) ADDRESS;
	END
WRITE;

		/* END ISIS.INC */
$ NOLIST

/************************************************************/
/*															*/
/*              LITERALLY'S UNIQUE TO PASSIF                */
/*															*/
/************************************************************/

DECLARE
    MINIMUM$ACCEPTABLE$BANNER$LENGTH 	AS 		'73',
    MAXIMUM$TOKEN$LENGTH				AS		'70',
    BI									AS		'CALL BOMB$IF(STATUS)',

	FIRST$FIELD							AS		'0',
    SECOND$FIELD						AS		'28',
    THIRD$FIELD							AS		'54',

    RIGHT$PARENTHESIS 					AS		''')''',
    LEFT$PARENTHESIS 					AS		'''(''',
    RI									AS		'CALL REPORT$IF',
    UNRECOGNIZED$SWITCH$ERR 			AS		'201',
    QUESTION$MARK						AS		'''?''';

$ LIST
$ NOLIST

/*	MAIN.INC  */

DECLARE
    ACTUAL ADDRESS EXTERNAL,
    AFTN ADDRESS EXTERNAL,
    COMMAND$TAIL$BUF (250) BYTE EXTERNAL,
    DELIMITER BYTE EXTERNAL,
    FIRST$BLOCK$BUF (128) BYTE EXTERNAL,
    FIRST$OUTPUT$MSG$PTR ADDRESS EXTERNAL,
    FIRST$TIME$THROUGH BOOLEAN EXTERNAL,
    INITIALIZED$BANNER (74) BYTE EXTERNAL,
    PRINT$HASH$MARK BOOLEAN EXTERNAL,
    REPORT$FILE$ACTUAL ADDRESS EXTERNAL,
    REPORT$FILE$AFTN ADDRESS EXTERNAL,
    REPORT$FILE$STRING$BEGINNING ADDRESS EXTERNAL,
    SECOND$OUTPUT$MSG$PTR ADDRESS EXTERNAL,
    STATUS ADDRESS EXTERNAL,
    TMP$FILE$AFTN ADDRESS EXTERNAL,
    TMP$FILE$NAME (15) BYTE EXTERNAL,
    TOK$BUF (80) BYTE EXTERNAL;

DECLARE
    KEY$WORDS (10) STRUCTURE
    (LENGTH							BYTE,
    KEY$WORD	(13)				BYTE,
    PROC$PTR						ADDRESS) EXTERNAL;

CO$IS$VO:
	PROCEDURE BOOLEAN EXTERNAL;
	END
CO$IS$VO;

EXIT$ROUTINE:
	PROCEDURE EXTERNAL;
	END
EXIT$ROUTINE;

RE$POSITION$CURSOR:
	PROCEDURE EXTERNAL;
	END
RE$POSITION$CURSOR;

MOVE:
	PROCEDURE (COUNT,SOURCE$PTR,DEST$PTR) EXTERNAL;
	DECLARE (COUNT,SOURCE$PTR,DEST$PTR) ADDRESS;
	END
MOVE;

/*	END MAIN.INC  */
$ LIST
$ NOLIST

/*	TOKENS.INC  */

GET$ARGUMENT:
	PROCEDURE (BUF$PTR,STATUS$PTR) BYTE EXTERNAL;
	DECLARE (BUF$PTR,STATUS$PTR) ADDRESS;
    END
GET$ARGUMENT;

/*	END TOKENS.INC  */
$ LIST
$ NOLIST

/*	ERRMSG.INC  */

DECLARE
	BAD$SYNTAX$MSG 				(29) 				BYTE		EXTERNAL,
	BOMB$IF$MSG$1    			(12) 				BYTE		EXTERNAL,
	BOMB$IF$MSG$2				(40) 				BYTE		EXTERNAL,
    DURING$ASSERTION$CHECK$MSG	(50)				BYTE		EXTERNAL,
    PASSIF$INVOKED$BY$MSG       (19)                BYTE        EXTERNAL,
    ZERO$LENGTH$FILE$MSG 		(40) 				BYTE		EXTERNAL;

/*	END ERRMSG.INC  */
$ LIST
$ NOLIST

/*	CLI.INC  */

DECLARE BUF$COUNT BYTE EXTERNAL;

UDI$STRING$MATCH:
	PROCEDURE (STG$1$PTR,STG$2$PTR) BOOLEAN EXTERNAL;
    DECLARE (STG$1$PTR,STG$2$PTR) ADDRESS;
	END
UDI$STRING$MATCH;

ENFORCE$DELIMITER:
	PROCEDURE(ENFORCEE) EXTERNAL;
	DECLARE ENFORCEE BYTE;
	END
ENFORCE$DELIMITER;

NEXT$ARG:
	PROCEDURE EXTERNAL;
	END
NEXT$ARG;

INTERPRET$COMMAND$LINE:
	PROCEDURE EXTERNAL;
	END
INTERPRET$COMMAND$LINE;

/*	END CLI.INC  */
$ LIST
$ NOLIST

/*	FUNC.INC  */

FILE$EXISTS:
	PROCEDURE EXTERNAL;
	END
FILE$EXISTS;

FILE$ABSENT:
	PROCEDURE EXTERNAL;
	END
FILE$ABSENT;

FILES$MATCH:
	PROCEDURE EXTERNAL;
    END
FILES$MATCH;

STRING$FOUND:
	PROCEDURE EXTERNAL;
	END
STRING$FOUND;

STRING$ABSENT:
	PROCEDURE EXTERNAL;
	END
STRING$ABSENT;

/*	END FUNC.INC  */
$ LIST

$ EJECT

/************************************************************/
/*															*/
/*                        NOTES                             */
/*															*/
/************************************************************/

/*

1.	Two types of string passing conventions are used:

	a.	the UDI convention, and
	b.	the "terminated by a binary 0" kind

2.	The procedures which report assertion failures with additional
	information work by preparing UDI-style message strings, setting
    pointers to them, then calling the vanilla "report$assertion$failure".
    In the course of its operation, report$assertion$failure will insert
    these prepared messages into the "failed assertion entry" if they're
    not null.

*/

$ EJECT

/************************************************************/
/*															*/
/*              LITERALLY'S FOR THIS MODULE                 */
/*															*/
/************************************************************/

DECLARE
	MAX$ENTRY$LINE$LENGTH 				AS				'71';

$ EJECT

/************************************************************/
/*															*/
/*                     MODULE GLOBALS                       */
/*															*/
/************************************************************/

DECLARE HYPENS$STG STRING
                   ('--------------------------------------',
                    '--------------------------------------',
                                 CR,LF,CR,LF);

DECLARE
    TEST$STG STRING
        ('test '),

    FAILED$STG STRING
        (' failed'),

    CI$STG STRING
        ('            :CI:=');

/************************************************************/
/*															*/
/*         INITIALIZED "MODULE GLOBAL" VARIABLES            */
/*															*/
/************************************************************/

DECLARE ZERO$VAL ADDRESS DATA (0);
DECLARE FOUR$SPACES STRING ('    ');
DECLARE CRLF STRING ('CR,LF');

/************************************************************/
/*															*/
/*               THE "REPORTING" PROCEDURES                 */
/*															*/
/************************************************************/

MSG$LENGTH:
	PROCEDURE (OLD$STYLE$MSG$PTR) BYTE PUBLIC;

	/*	This procedure is for assessing the length of
		an "old" style string;  that is, one terminated
		by a binary zero. */

    DECLARE OLD$STYLE$MSG$PTR ADDRESS,
    		OLD$STYLE$MSG BASED OLD$STYLE$MSG$PTR (1000) BYTE;
	DECLARE V BYTE;

	V = 0;
    DO WHILE (OLD$STYLE$MSG(V)<>0) AND V<255;
    	V = V + 1;
    END$DO$WHILE;
    RETURN V;
	END
MSG$LENGTH;

NUM$OUT:
	PROCEDURE (ERR$NUM,BUF$PTR);
	DECLARE (ERR$NUM,BUF$PTR) ADDRESS;
	DECLARE BUF BASED BUF$PTR (6) BYTE;
    DECLARE TMP$BUF (5) BYTE;
    DECLARE U BYTE;

	/*	This version of numout requires a pointer to a six-byte buffer
		as a parameter.  Numout places the "width" of the number in the
		first byte of the buffer, and the ascii expansion of the number
		in the next 1 to 5 bytes. */

	BUF(0) = 1;
	U = 4;

	loop$begin:
		TMP$BUF(U) = (ERR$NUM MOD 10) + '0';
        ERR$NUM = ERR$NUM / 10;
        IF ERR$NUM<>0 THEN
            DO;
            	U = U - 1;
                BUF(0) = BUF(0) + 1;
      			GOTO loop$begin;
        	ENDDO;
        ENDIF
	end$loop

	CALL MOVE(/*count*/			BUF(0),
			  /*source*/		.TMP$BUF(5-BUF(0)),
			  /*destination*/	.BUF(1));
	END
NUM$OUT;

HEXADECIMAL$DIGIT:
	PROCEDURE (A$CHAR) BOOLEAN;
	DECLARE A$CHAR BYTE;
	RETURN
		(A$CHAR>='0' AND A$CHAR<='9')
					OR
		(A$CHAR>='A' AND A$CHAR<='F');
	END
HEXADECIMAL$DIGIT;

$ EJECT

/************************************************************/
/*															*/
/*                       BOMB$IF                            */
/*															*/
/************************************************************/

BOMB$IF:
	PROCEDURE (STATUS) PUBLIC;

    /*	This procedure is called if an Isis error is encountered in the
    	course of processing the error reporting file.

        Such an error can not rationally be reported in the error
        report file, since it was the process of updating said file
        which caused the problem; therefore, under such
        circumstances, Passif prints the "bomb$if" error message to
        the console output, and to the cold boot console, and exits.
        */

    DECLARE STATUS ADDRESS;
	DECLARE T BYTE;
	DECLARE TMP$STATUS ADDRESS;
	DECLARE NUM$OUT$BUF (6) BYTE;
	DECLARE NUM$LEN BYTE;

	IF STATUS<>0 THEN
		DO;
            /*	First print the message to the cold boot console. */
            CALL RE$POSITION$CURSOR;
            CALL NUM$OUT(STATUS,.NUM$OUT$BUF);

            /*	Print out part one of the message. */
            DO T=1 TO MSG$LENGTH(.BOMB$IF$MSG$1);
                CALL CO(BOMB$IF$MSG$1(T));
            END$ITERATED$DO;

            /*	Print out the error number. */
            NUM$LEN = NUM$OUT$BUF(0);
            DO T=1 TO NUM$LEN;
                CALL CO(NUM$OUT$BUF(T));
            END$ITERATED$DO;

            /*	Print out part two of the message. */
            DO T=1 TO MSG$LENGTH(.BOMB$IF$MSG$2);
                CALL CO(BOMB$IF$MSG$2(T));
            END$ITERATED$DO;

            /*	Now print the message to the console output.  */
            CALL WRITE(CONSOLE$OUTPUT,.BOMB$IF$MSG$1,
                    MSG$LENGTH(.BOMB$IF$MSG$1),.TMP$STATUS);

        	CALL WRITE(CONSOLE$OUTPUT,.NUM$OUT$BUF(1),NUM$OUT$BUF(0),
                                 .TMP$STATUS);

            CALL WRITE(CONSOLE$OUTPUT,.BOMB$IF$MSG$2,
                    MSG$LENGTH(.BOMB$IF$MSG$2),.TMP$STATUS);

            CALL WRITE(CONSOLE$OUTPUT,.CRLF,SIZE(CRLF),.TMP$STATUS);
        	CALL EXIT;
    	ENDDO;
    ENDIF
    END
BOMB$IF;

EOL:
    PROCEDURE;
    CALL WRITE(REPORT$FILE$AFTN,.(CR,LF),2,.STATUS);
    BI;
    END
EOL;

INDENT:
    PROCEDURE;
    /*	Indent 4 spaces. */
    CALL WRITE(REPORT$FILE$AFTN,.FOUR$SPACES,SIZE(FOUR$SPACES),.STATUS); BI;
    END
INDENT;

$ EJECT

/************************************************************/
/*															*/
/*                WRITE$OUT$COMMAND$TAIL                    */
/*															*/
/************************************************************/

WRITE$OUT$COMMAND$TAIL:
	PROCEDURE;

	DECLARE UN$WRITTEN$BYTES BYTE;
	DECLARE COUNT$FOR$THIS$LINE BYTE;
	DECLARE BUF$PTR ADDRESS,
			BUF BASED BUF$PTR (100) BYTE;

    UNWRITTEN$BYTES = BUF$COUNT;
    BUF$PTR = .COMMAND$TAIL$BUF;

    loop$begin:
        IF UN$WRITTEN$BYTES > MAX$ENTRY$LINE$LENGTH THEN
    		COUNT$FOR$THIS$LINE = MAX$ENTRY$LINE$LENGTH;
        ELSE
        	COUNT$FOR$THIS$LINE = UN$WRITTEN$BYTES;
    	ENDIF

    	UN$WRITTEN$BYTES = UN$WRITTEN$BYTES - COUNT$FOR$THIS$LINE;

        CALL INDENT;
        CALL WRITE(REPORT$FILE$AFTN,BUF$PTR,COUNT$FOR$THIS$LINE,.STATUS); BI;

        IF UN$WRITTEN$BYTES > 0 THEN
        	DO;
                BUF$PTR = BUF$PTR + COUNT$FOR$THIS$LINE;
    			CALL EOL;
    			GOTO loop$begin;
            ENDDO;
    	ENDIF
    end$loop

	IF PRINT$HASH$MARK THEN
        CALL WRITE(REPORT$FILE$AFTN,.(HASH$MARK),1,.STATUS); BI;
    ENDIF

    END
WRITE$OUT$COMMAND$TAIL;

FIVE$ASCII$HEXADECIMAL$DIGITS:
	PROCEDURE (DIG$PTR) BOOLEAN;
	DECLARE DIG$PTR ADDRESS,
			DIG BASED DIG$PTR (5) BYTE;
    DECLARE M BYTE;

    DO M = 0 TO 4;
		IF NOT HEXADECIMAL$DIGIT(DIG(M)) THEN
			RETURN FALSE;
        ENDIF
    END$ITERATED$DO;
    RETURN TRUE;
	END
FIVE$ASCII$HEXADECIMAL$DIGITS;

BANNER$IS$LEGIT:
	PROCEDURE BOOLEAN;
	IF REPORT$FILE$ACTUAL >= SIZE(INITIALIZED$BANNER) THEN
		DO;
            RETURN
            FIVE$ASCII$HEXADECIMAL$DIGITS(.FIRST$BLOCK$BUF(FIRST$FIELD))  AND
            FIVE$ASCII$HEXADECIMAL$DIGITS(.FIRST$BLOCK$BUF(SECOND$FIELD)) AND
            FIVE$ASCII$HEXADECIMAL$DIGITS(.FIRST$BLOCK$BUF(THIRD$FIELD));
        ENDDO;
	ELSE
		RETURN FALSE;
	ENDIF
    END
BANNER$IS$LEGIT;

/*  The following is a typical banner.
0         1         2         3         4         5         6         7
0123456789012345678901234567890123456789012345678901234567890123456789012345

13517 TESTS EXECUTED         13499 TESTS PASSED         00018 TESTS FAILED
*/

$ EJECT

/************************************************************/
/*															*/
/*                READ$IN$AND$QA$REPORT$FILE                */
/*															*/
/************************************************************/

READ$IN$AND$QA$REPORT$FILE:
	PROCEDURE;

    RE$INITIALIZE$REPORT$FILE:
        PROCEDURE;

        DECLARE STATIC$BUF (128) BYTE;

		DECLARE FILE$INFORMATION STRUCTURE
           (DEVICE$NUMBER						BYTE,
            FILE$NAME				(6)			BYTE,
            EXTENSION				(3)			BYTE,
            DEVICE$TYPE							BYTE,
            DRIVE$TYPE							BYTE);

        /*	First, ascertain correct device for temporary file,
            and open it. */
        CALL SPATH(REPORT$FILE$STRING$BEGINNING,.FILE$INFORMATION,.STATUS); BI;
        TMP$FILE$NAME(2) = FILE$INFORMATION.DEVICE$NUMBER + '0';

        /*	The temporary file must be opened in update mode, since it may
        	become the report file;  and it is crucial for the report file
        	to be readable from, and writeable to. */

        CALL OPEN(.TMP$FILE$AFTN,.TMP$FILE$NAME,OPEN$FOR$UPDATE,NO$LINE$EDIT,
                                   .STATUS); BI;

        /*	Write out an initialized banner. */
        CALL WRITE(TMP$FILE$AFTN,.INITIALIZED$BANNER,
                       					SIZE(INITIALIZED$BANNER),.STATUS);

        /*	Now, write out the rest of the file, first seeking
            back to the beginning of the report file. */
        CALL SEEK(REPORT$FILE$AFTN,SEEK$2$N,.ZERO$VAL,.ZERO$VAL,.STATUS); BI;

        begin$copying$loop:
        	CALL READ(REPORT$FILE$AFTN,.STATIC$BUF,SIZE(STATIC$BUF),
                               .ACTUAL,.STATUS); BI;
            CALL WRITE(TMP$FILE$AFTN,.STATIC$BUF,ACTUAL,.STATUS); BI;
            IF ACTUAL = SIZE(STATIC$BUF) THEN
            	GOTO begin$copying$loop;
            ENDIF
        end$loop

		/*	Close report file, rename the temporary file, reassign
            the report$file$aftn, and seek back to the beginning.  We
            have to seek back to the beginning, because that's what
            the calling procedure expects.

            The result of all this is that, in terms of disk storage
            locations, what was the temporary file will be the report
            file, but both the ascii filename and the
            report$file$aftn will be correct.  */

        CALL CLOSE(REPORT$FILE$AFTN,.STATUS); BI;
		CALL DELETE(REPORT$FILE$STRING$BEGINNING,.STATUS); BI;
        CALL RENAME(.TMP$FILE$NAME,REPORT$FILE$STRING$BEGINNING,.STATUS); BI;
		REPORT$FILE$AFTN = TMP$FILE$AFTN;
        CALL SEEK(REPORT$FILE$AFTN,SEEK$2$N,.ZERO$VAL,.ZERO$VAL,.STATUS);
		END
    RE$INITIALIZE$REPORT$FILE;

$ EJECT

    /************************************************************/
    /*															*/
    /*      FIRST EXECUTABLE IN READ$IN$AND$QA$REPORT$FILE      */
    /*															*/
    /************************************************************/

	CALL OPEN(.REPORT$FILE$AFTN,
               REPORT$FILE$STRING$BEGINNING,
               OPEN$FOR$UPDATE,NO$LINE$EDIT,.STATUS); BI;

    loop$begin:
        CALL READ(REPORT$FILE$AFTN,.FIRST$BLOCK$BUF(0),SIZE(FIRST$BLOCK$BUF),
                        .REPORT$FILE$ACTUAL,.STATUS); BI;

        IF NOT BANNER$IS$LEGIT THEN
            DO;
                CALL RE$INITIALIZE$REPORT$FILE;
                GOTO loop$begin;
            ENDDO;
        ENDIF
    end$loop

    END
READ$IN$AND$QA$REPORT$FILE;

INCREMENT$ASCII:
	PROCEDURE (FIELD$PTR);
	DECLARE FIELD$PTR ADDRESS,
			FIELD  BASED FIELD$PTR (5) BYTE,
			N BYTE;

    N = 4;
    loop$begin:
    IF FIELD(N)='9' THEN
    	DO;
			IF N<>0 THEN
				DO;
					FIELD(N) = '0';
            		N = N - 1;
                	GOTO loop$begin;
                ENDDO;
            ELSE
            	DO N = 0 TO 4;
					FIELD(N) = '9';
            	END$ITERATED$DO;
            ENDIF
    	ENDDO;
    ELSE
        FIELD(N) = FIELD(N) + 1;
    ENDIF
	END
INCREMENT$ASCII;

WRITE$OUT$FIRST$BLOCK$BUF:
	PROCEDURE;
	CALL SEEK(REPORT$FILE$AFTN,SEEK$2$N,.ZERO$VAL,.ZERO$VAL,.STATUS); BI;
	CALL WRITE(REPORT$FILE$AFTN,.FIRST$BLOCK$BUF,REPORT$FILE$ACTUAL,.STATUS); BI;
	END
WRITE$OUT$FIRST$BLOCK$BUF;

REPORT$ASSERTION$SUCCESS:
	PROCEDURE PUBLIC;
	CALL READ$IN$AND$QA$REPORT$FILE;
    CALL INCREMENT$ASCII(.FIRST$BLOCK$BUF(FIRST$FIELD));
    CALL INCREMENT$ASCII(.FIRST$BLOCK$BUF(SECOND$FIELD));
    CALL WRITE$OUT$FIRST$BLOCK$BUF;
    CALL EXIT$ROUTINE;
	END
REPORT$ASSERTION$SUCCESS;

$ EJECT

/************************************************************/
/*															*/
/*               REPORT$ASSERTION$FAILURE                   */
/*															*/
/************************************************************/

REPORT$ASSERTION$FAILURE:
	PROCEDURE PUBLIC;

    DECLARE DOESNT$MATTER ADDRESS;
	DECLARE CI$BUF (20) BYTE;
    DECLARE Q BYTE;
	DECLARE W BYTE;

    /************************************************************/
    /*															*/
    /*      PROCEDURES LOCAL TO REPORT$ASSERTION$FAILURE        */
    /*															*/
    /************************************************************/

    INSERT$MSG:
    	PROCEDURE (MSG$PTR);
    	DECLARE MSG$PTR ADDRESS;

        /*	The strings passed to this procedure are of the "other" type,
        	meaning that the first byte of the string is part of the
        	string, and the string is terminated by a binary 0.  This
        	procedure assumes that the strings passed to it will fit on
        	a single line.  */
        IF MSG$PTR <> NULL THEN
            DO;
                CALL EOL;
                CALL INDENT;
                CALL WRITE(REPORT$FILE$AFTN,
                   MSG$PTR,MSG$LENGTH(MSG$PTR),.STATUS); BI;
			ENDDO;
		ENDIF
    	END
    INSERT$MSG;

    WRITE$CI$FILE:
    	PROCEDURE;
        /*	Write out :ci: file designation. */
        /*	Calculate how many bytes to write by finding the blank which
            terminates the filename string.  */
        CALL WHO$CON(CONSOLE$INPUT,.CI$BUF);
        Q = 0;
        DO WHILE CI$BUF(Q) <> BLANK;
            Q = Q + 1;
        ENDDOWHILE;
        CALL WRITE(REPORT$FILE$AFTN,.CI$BUF,Q,.STATUS); BI;
        END
    WRITE$CI$FILE;

    WRITE$OUT$TEST$FAILURE$NUMBER:
        PROCEDURE (AN$AFTN);

        DECLARE AN$AFTN ADDRESS;

        /*	Write out the "test" string.  */
        CALL WRITE(AN$AFTN,.TEST$STG,SIZE(TEST$STG),.STATUS); BI;

        /*	Write out the ordinal number of the test which failed. */
        CALL WRITE(AN$AFTN,.FIRST$BLOCK$BUF(0),5,.STATUS); BI;

        /*	Write out the "failed" string.  */
        CALL WRITE(AN$AFTN,.FAILED$STG,SIZE(FAILED$STG),.STATUS); BI;

        END
    WRITE$OUT$TEST$FAILURE$NUMBER;

    WRITE$FAILURE$NUMBER$IN$CO$FILE:
    	PROCEDURE;

		DECLARE
			FIRST$MESSAGE STRING
				(CR,LF,CR,LF,'                            ====> '),

        	SECOND$MESSAGE STRING
        		(' <====',CR,LF,CR,LF);

		CALL WRITE
            (CONSOLE$OUTPUT,.FIRST$MESSAGE,SIZE(FIRST$MESSAGE),.STATUS); BI;

        CALL WRITE$OUT$TEST$FAILURE$NUMBER (CONSOLE$OUTPUT);

		CALL WRITE
            (CONSOLE$OUTPUT,.SECOND$MESSAGE,SIZE(SECOND$MESSAGE),.STATUS); BI;

    	END
    WRITE$FAILURE$NUMBER$IN$CO$FILE;

$ EJECT

    /************************************************************/
    /*															*/
    /*  FIRST EXECUTABLE IN PROCEDURE REPORT$ASSERTION$FAILURE  */
    /*															*/
    /************************************************************/

    CALL READ$IN$AND$QA$REPORT$FILE;
    CALL INCREMENT$ASCII(.FIRST$BLOCK$BUF(FIRST$FIELD));
    CALL INCREMENT$ASCII(.FIRST$BLOCK$BUF(THIRD$FIELD));
    CALL WRITE$OUT$FIRST$BLOCK$BUF;

    /*	Now, seek to the end of the file. */
    CALL SEEK
      (REPORT$FILE$AFTN,SEEK$2$EOF,.DOESNT$MATTER,.DOESNT$MATTER,.STATUS); BI;

    /*	Write out the long row of hyphens which separates the "failed
    	assertion entry reports.  */
    CALL WRITE(REPORT$FILE$AFTN,.HYPENS$STG,SIZE(HYPENS$STG),.STATUS); BI;

	CALL WRITE$OUT$TEST$FAILURE$NUMBER (REPORT$FILE$AFTN);

    CALL WRITE(REPORT$FILE$AFTN,.CI$STG,SIZE(CI$STG),.STATUS); BI;

	IF NOT CO$IS$VO THEN
		CALL WRITE$FAILURE$NUMBER$IN$CO$FILE;
    ENDIF

    CALL WRITE$CI$FILE;
    CALL EOL;

	/*	Write out the first message, if any. */
	CALL INSERT$MSG(FIRST$OUTPUT$MSG$PTR);
	CALL EOL;

	CALL WRITE$OUT$COMMAND$TAIL;

    /*	Write out the second message, if any. */
	CALL INSERT$MSG(SECOND$OUTPUT$MSG$PTR);

    /*	Add blank lines at bottom of "assertion failure report entry". */
	DO W=1 TO 2;
		CALL EOL;
    END$ITERATED$DO;

    CALL EXIT$ROUTINE;

    END
REPORT$ASSERTION$FAILURE;

$ EJECT

REPORT$SYNTAX$ERROR:
	PROCEDURE PUBLIC;
	FIRST$OUTPUT$MSG$PTR = .BAD$SYNTAX$MSG;
    PRINT$HASH$MARK = TRUE;
    CALL REPORT$ASSERTION$FAILURE;
    END
REPORT$SYNTAX$ERROR;

REPORT$ASSERTION$FAILURE$W$MSG:
	PROCEDURE (OLD$STYLE$MSG$PTR) PUBLIC;
    DECLARE OLD$STYLE$MSG$PTR ADDRESS;

	SECOND$OUTPUT$MSG$PTR = OLD$STYLE$MSG$PTR;
    CALL REPORT$ASSERTION$FAILURE;
    END
REPORT$ASSERTION$FAILURE$W$MSG;

$ EJECT

/************************************************************/
/*															*/
/*           REPORT$ASSERTION$FAILURE$W$ISIS$ERR            */
/*															*/
/************************************************************/

REPORT$ASSERTION$FAILURE$W$ISIS$ERR:
	PROCEDURE (STATUS) PUBLIC;

	/*	This procedure accepts as input, and delivers as output,
		"delimited" strings.  Input, as specified above, does
		not mean the parameter with which this procedure was called,
		but some global strings which are concatenated to produce
        a larger string which becomes an error message. */

    DECLARE STATUS ADDRESS;
    DECLARE MSG$BUF (256) BYTE;
	DECLARE FIRST$FREE$BYTE ADDRESS;
    DECLARE ASCII$NUM$BUF (6) BYTE;

    /************************************************************/
    /*															*/
    /* PROCEDURES LOCAL TO REPORT$ASSERTION$FAILURE$W$ISIS$ERR  */
    /*															*/
    /************************************************************/

    LOAD$MSG$BUF:
    	PROCEDURE (SOURCE$PTR,COUNT);
    	DECLARE (SOURCE$PTR,COUNT) ADDRESS;
        CALL MOVE(/*count*/		COUNT,
                  /*source*/	SOURCE$PTR,
                  /*dest*/		.MSG$BUF(FIRST$FREE$BYTE));
    	FIRST$FREE$BYTE = FIRST$FREE$BYTE + COUNT;
    	END
    LOAD$MSG$BUF;

    /************************************************************/
    /*															*/
    /* FIRST EXECUTABLE IN REPORT$ASSERTION$FAILURE$W$ISIS$ERR  */
    /*															*/
    /************************************************************/

    FIRST$FREE$BYTE = 0;
    CALL LOAD$MSG$BUF(.BOMB$IF$MSG$1,MSG$LENGTH(.BOMB$IF$MSG$1));
    CALL NUM$OUT(STATUS,.ASCII$NUM$BUF);
    CALL LOAD$MSG$BUF(.ASCII$NUM$BUF(1),ASCII$NUM$BUF(0));
    CALL LOAD$MSG$BUF(.DURING$ASSERTION$CHECK$MSG,
                   MSG$LENGTH(.DURING$ASSERTION$CHECK$MSG));

    /*	Delimit the output string. */
    CALL LOAD$MSG$BUF(.ZERO$VAL,SIZE(ZERO$VAL));

    FIRST$OUTPUT$MSG$PTR  = .PASSIF$INVOKED$BY$MSG;
    SECOND$OUTPUT$MSG$PTR = .MSG$BUF;
	PRINT$HASH$MARK = TRUE;

    CALL REPORT$ASSERTION$FAILURE;
    END
REPORT$ASSERTION$FAILURE$W$ISIS$ERR;

REPORT$ISIS$ERROR:
	PROCEDURE (STATUS) PUBLIC;
	DECLARE STATUS ADDRESS;
	IF STATUS<>0 THEN
		CALL REPORT$ASSERTION$FAILURE$W$ISIS$ERR(STATUS);
	ENDIF
	END
REPORT$ISIS$ERROR;

END
REPORT$MOD;
src/rescan.plm
RESCAN:  DO;

/************************************************************************/
/*																		*/
/*      '(C) Intel Corporation 1981'.  All rights reserved.  No			*/
/*      part of this program or publication may be reproduced,			*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

DECLARE COPYRIGHT (*) BYTE DATA ('(C) INTEL CORP 1981');

DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.0',0);

/*******************************************************************************
 *
 * This program is designed to allow the restarting of a submit file
 * at any line within the .CS file.
 *
 * the action performed by this program is to copy the .CS file, line-by-line,
 * to CO ( not :CO: ) and query the keyboard CI ( not :CI: ) for a
 * response.  If the response is an escape ( ESC ) then the submit file
 * is restarted at the currently displayed line.  If the response is
 * a control C character (control$C) command is given to the cold start
 * console and the program exited.  If the response is any other character,
 * the next line of the file will be printed ( except for tilda ).
 * Due to the way ISIS handles the console device, reaching the end of the
 * file will cause an ISIS error 29 with a subsequent reboot.
 *
 *******************************************************************************/

/* commonly used literallys */

   declare decl literally 'declare';
   declare as literally 'literally';

   decl pointer as 'address';
   decl boolean as 'byte';
   decl character as 'byte';
   decl int1 as 'byte';
   decl int2 as 'address';

   decl true as '0FFH';
   decl false as '0';
   decl nil as '0';

   decl FOREVER as 'while true';
   decl ESC as '1BH';
   decl control$C as '03H';
   decl TILDA as '7FH';
   decl CONSOLE$MASK as '03H';

/* system externals */

READ: procedure( AFTN, BUFFER, LEN, ACTUAL, STATUS ) external;
   decl (AFTN,BUFFER,LEN,ACTUAL,STATUS) address;
end;

WRITE: procedure( AFTN, BUFFER , COUNT , STATUS ) external;
   decl (AFTN,BUFFER,COUNT,STATUS) address;
end;
   
CI: procedure character external;
end;

CO: procedure( CHAR ) external;
   decl CHAR character;
end;

IOCHK: procedure byte external;
end;

RESCAN: procedure( AFTN, STATUS ) external;
   decl (AFTN,STATUS) address;
end;

CONSOL: procedure( INFILE, OUTFILE, STATUS ) external;
   decl (INFILE,OUTFILE,STATUS) address;
end;

ERROR: procedure(ERRNUM) external;
   decl ERRNUM address;
end;

EXIT: procedure external;
end;

SEEK:
    PROCEDURE (AFT,MODE,BLOCKNUM,BYTENUM,STATUS) EXTERNAL;
    DECLARE (AFT,MODE,BLOCKNUM,BYTENUM,STATUS) ADDRESS;
    END
SEEK;

FERR: procedure(STATUS);
   decl STATUS int2;
   /* exit if error (status <> 0) */
   if STATUS <> 0 then do;
      call ERROR(STATUS);
      call EXIT;
   end;
end FERR;

/* global declarations */

   decl LINE(128) character; /* input and display line */

   decl I int1;
   decl CHAR character;
   decl (STATUS,ACTUAL) address;
   decl ZERO$BLOCKS address data (0);

/* main line code */

/* read command line for input file name */
call READ( 1, .LINE, 128, .ACTUAL, .STATUS );
call FERR(STATUS); /* tests for non-zero status;

/* scan for first non-blank character in line */
I = 0;
do while LINE(I) = ' ' and I < 127;
   I = I + 1;
end;

/* use the input file as the current console device */
call CONSOL( .LINE(I), .(':CO: '), .STATUS);
call FERR(STATUS);

/* main control loop */

do FOREVER;

   /* reads console file and writes to screen */
   call WRITE(0, .('#'), 1 , .STATUS );
   call FERR(STATUS);
   call READ( 1, .LINE, 128, .ACTUAL, .STATUS );
   call FERR(STATUS);

   /* query the keyboard */
IGNORE:
   CHAR = CI and 7FH;
   if CHAR = TILDA then go to IGNORE; /* ignore tilda characters */

   /* test for action */

   if CHAR = ESC then do;
      /* start file from this point */
      /* position to beginning of line */
      call SEEK(1				/* seek on console input */	,
      			1				/* seek backward mode	 */	,
                .zero$blocks								,
                .actual										,
                .STATUS 									);
      call EXIT;
   end;

   else if CHAR = control$C then do;
      /* return to cold start console */
      I = IOCHK; /* get current device flags */
      if ( I and CONSOLE$MASK ) <> 0 then do; /* console is :VI: */
         call CONSOL( .(':VI: '), .(':CO: '), .STATUS );
         call FERR(STATUS);
         call EXIT;
      end;
      else do; /* console is :TI: */
         call CONSOL( .(':TI: '), .(':CO: '), .STATUS );
         call FERR(STATUS);
         call EXIT;
      end;
   end;
end;

end RESCAN;
src/return.plm
RETURN$MOD: DO;

/************************************************************************/
/*																		*/
/*      '(C) Intel Corporation 1981'.  All rights reserved.  No			*/
/*      part of this program or publication may be reproduced,			*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

DECLARE COPYRIGHT (*) BYTE DATA ('(C) INTEL CORP 1981');

DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.0',0);

DECLARE	LIT		LITERALLY	'LITERALLY',
		DCL		LIT	'DECLARE',
		TRUE	LIT	'0FFH',
		FALSE	LIT	'000H',
		PROC	LIT	'PROCEDURE',
		PROCEND	LIT	'END',
		THENDO	LIT	'THEN DO;',
		ELSEIF	LIT	'END; ELSE IF',
		ELSEDO	LIT	'END; ELSE DO;',
		IFEND	LIT	'END',
		WHILEND	LIT	'END',
		CR		LIT	'0DH',
		LF		LIT	'0AH';

EXIT:	PROC EXTERNAL;											PROCEND;
READ:	PROC (A,B,C,D,E) EXTERNAL;	DCL (A,B,C,D,E) ADDRESS;	PROCEND;
WRITE:	PROC (A,B,C,D) EXTERNAL;	DCL (A,B,C,D) ADDRESS;		PROCEND;
SEEK:	PROC (A,B,C,D,E) EXTERNAL;	DCL (A,B,C,D,E) ADDRESS;	PROCEND;

DCL (STATUS, ACTUAL) ADDRESS;
DCL (CUR$BLOCKNO, CUR$BYTENO, EOF$BLOCKNO, EOF$BYTENO) ADDRESS;
DCL (LAST$BLOCKNO, LAST$BYTENO, BLOCKNO, BYTENO) ADDRESS;

CALL READ (1, .MEMORY, 128, .ACTUAL, .STATUS); /* Skip command tail. */
CALL SEEK (1, 0, .CUR$BLOCKNO, .CUR$BYTENO, .STATUS); /* Current point. */
IF STATUS <> 0 THENDO /* Can't seek, probably not in submit. */
	CALL EXIT;
IFEND;
CALL SEEK (1, 4, .EOF$BLOCKNO, .EOF$BYTENO, .STATUS); /* Seek to EOF. */
CALL SEEK (1, 0, .EOF$BLOCKNO, .EOF$BYTENO, .STATUS);
CALL SEEK (1, 2, .CUR$BLOCKNO, .CUR$BYTENO, .STATUS); /* Back up. */
LAST$BLOCKNO = CUR$BLOCKNO;
LAST$BYTENO = CUR$BYTENO;
DO WHILE TRUE;
	CALL WRITE (0, .('#'), 1, .STATUS);
	CALL READ (1, .MEMORY, 128, .ACTUAL, .STATUS);
	IF (STATUS <> 0) OR (ACTUAL = 0) THENDO
		CALL EXIT;
	IFEND;
	CALL SEEK (1, 0, .BLOCKNO, .BYTENO, .STATUS);
	IF (BLOCKNO = EOF$BLOCKNO) AND (BYTENO = EOF$BYTENO - 1) THENDO
		CALL SEEK (1, 2, .LAST$BLOCKNO, .LAST$BYTENO, .STATUS);
		CALL EXIT;
	IFEND;
	LAST$BLOCKNO = BLOCKNO;
	LAST$BYTENO = BYTENO;
WHILEND;

END RETURN$MOD;
src/seq.asm
;      '(C) Intel Corporation 1981'.  All rights reserved.  No
;      part of this program or publication may be reproduced,
;      transmitted, transcribed, stored in a retrievel system, or
;      translated into any language or computer language, in any
;      form or by any means, electronic, mechanical, magnetic,
;      optical, chemical, manual or otherwise, without the prior
;      written permission of Intel Corporation, 3065 Bowers
;      Avenue, Santa Clara, California, 95051, Attn: Software
;      License Administration.
	NAME	SEQ
	CSEG
	PUBLIC	SEQ
SEQ:	; SEQ (STR1, STR2, COUNT) BYTE;
	POP	H
	XTHL			; HL := str1
	XRA	A
	SUB	E
	MOV	E,A
	MVI	A,0
	SBB	D
	MOV	D,A
	ORA	E		; set Z flag if zero
	MVI	A,0FFH		; true if count = 0
	RZ
SEQ1:	LDAX	B
	CMP	M
	JZ	SEQ3		; chars equal
SEQ2:	XRA	A
	RET
SEQ3:	INX	B
	INX	H
	INR	E
	JNZ	SEQ1
	INR	D
	JNZ	SEQ1
	MVI	A,0FFH
	RET
	END
src/sort.plm
SORT:
  DO;


/************************************************************************/
/*																		*/
/*      '(C) Intel Corporation 1981'.  All rights reserved.  No			*/
/*      part of this program or publication may be reproduced,			*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

      
DECLARE COPYRIGHT (*) BYTE DATA ('(C) INTEL CORP 1981');

DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.0',0);
    

  DECLARE
    (CHAR$SIZE,ITEM$SIZE) ADDRESS,
    CHARS(1) BYTE AT (.MEMORY),
    ITEM$PTR ADDRESS,
    ITEM BASED ITEM$PTR (1) ADDRESS,
    NF BYTE,
    FIELD(10) STRUCTURE(
        FIRST ADDRESS,
        LAST ADDRESS),
    (CC,NR,NI,AFTN,AFTN2,STATUS) ADDRESS,
    WORKING BYTE,
    CONT BYTE,
    (I,J) ADDRESS,
    BPTR BYTE,
    BUF(30) BYTE;

  DECLARE
    TRUE LITERALLY '0FFH',
    FALSE LITERALLY '0',
    CR LITERALLY '0DH',
    LF LITERALLY '0AH',
    ZERO LITERALLY '30H',
    TOP$OF$MEMORY LITERALLY '60000',
    NINE LITERALLY '39H',
    ALL LITERALLY '30',
    CI LITERALLY '1',
    CO LITERALLY '0';

$INCLUDE(:F1:ERROR.PEX)
$INCLUDE(:F1:EXIT.PEX)
$INCLUDE(:F1:READ.PEX)
$INCLUDE(:F1:WRITE.PEX)
$INCLUDE(:F1:CLOSE.PEX)
$INCLUDE(:F1:OPEN.PEX)



  READ$FIELD: PROCEDURE;
    J=0;
    DO WHILE BUF(BPTR)<ZERO OR BUF(BPTR)>NINE;
      IF (BUF(BPTR)=CR) THEN RETURN;
      BPTR=BPTR+1;
      IF BPTR>=30 THEN RETURN;
      END;
    DO WHILE BUF(BPTR)>=ZERO AND BUF(BPTR)<=NINE;
      J=J*10+(BUF(BPTR)-ZERO);
      BPTR=BPTR+1;
      END;
    RETURN;
    END READ$FIELD;


  FIND$EOL: PROCEDURE;
    CC=CC+1;
    DO WHILE (CHARS(CC-1)<>LF OR CHARS(CC)=LF OR (CHARS(CC)=CONT AND CONT<>0))
                AND CC<NR;
      CC=CC+1;
      END;
    END FIND$EOL;




  WRYTE: PROCEDURE(I);
    DECLARE
      I ADDRESS,
      J ADDRESS;
    CC=ITEM(I);
    CALL FIND$EOL;
    J=CC-ITEM(I);
    CALL WRITE(AFTN2,.CHARS(ITEM(I)),J,.STATUS);
    END WRYTE;


  STAT: PROCEDURE(STATUS);
    DECLARE
      STATUS ADDRESS;
    IF STATUS<>0 THEN DO;
      CALL ERROR(STATUS);
      CALL EXIT;
      END;
    END STAT;




  SHELL$SORT: PROCEDURE;
    /* FROM KNUTH VOL 3, TRANSFORMED FOR ZERO-BASED ARRAYS */
    DECLARE (LT,EQ,GT) BYTE DATA (1,2,3),
      HA(9) ADDRESS DATA (0,1,4,13,40,121,364,1093,3280),
      H ADDRESS,
      (S,T) BYTE,
      (I,J,K) ADDRESS,
      T1 BYTE;

    COMPARE: PROCEDURE(S1P,S2P) BYTE;
      DECLARE (S1P,S2P) ADDRESS,
        S1 BASED S1P(1) BYTE,
        S2 BASED S2P(1) BYTE,
        (I,J) ADDRESS,
        (T1,T2) BYTE;
      D1: DO J=0 TO NF;
        D2: DO I=FIELD(J).FIRST TO FIELD(J).LAST;
          IF (T1:=S1(I))<(T2:=S2(I)) THEN RETURN LT;
          IF T1>T2 THEN RETURN GT;
          IF T1=CR AND FIELD(J).LAST=NR THEN I=NR;
          END D2;
        END D1;
      RETURN EQ;
      END COMPARE;

    /* CALCULATE T */
    T=0;  S=1;
    DO WHILE T=0;
      IF HA(S+2)>NI THEN T=S;
      S=S+1;
      END;
    /* LOOP ON S */
    S=T;
    D1: DO WHILE S>0;
      H=HA(S);
      J=H;
      D2: DO WHILE J<=NI;
        I=J; K=ITEM(J);
        D3: DO WHILE I>=H;
          I=I-H;
          T1=COMPARE(.CHARS(K),.CHARS(ITEM(I)));
          IF T1 > LT THEN DO;
            ITEM(I+H)=K;
            GO TO D6; /* SORRY ABOUT THAT */
            END;
          ITEM(I+H)=ITEM(I);
          END D3;
        ITEM(I)=K;
        D6:J=J+1;
        END D2;
      S=S-1;
      END D1;
    END SHELL$SORT;


  CHAR$SIZE=TOP$OF$MEMORY-.MEMORY;
  CALL READ(CI,.BUF,ALL,.NR,.STATUS);
  CALL STAT(STATUS);
  CALL OPEN(.AFTN,.BUF,1,0,.STATUS);
  CALL STAT(STATUS);
  CALL WRITE(CO,.('OUTPUT FILE: '),13,.STATUS);
  CALL STAT(STATUS);
  CALL READ(CI,.BUF,ALL,.NR,.STATUS);
  CALL STAT(STATUS);
  CALL OPEN(.AFTN2,.BUF,2,0,.STATUS);
  IF STATUS<>13 THEN CALL STAT(STATUS);
  CALL READ(AFTN,.CHARS,CHAR$SIZE,.NR,.STATUS);
  CALL STAT(STATUS);
  IF NR=CHAR$SIZE THEN CALL STAT(101);
  ITEM$PTR=.CHARS(NR);
  ITEM$SIZE=(TOP$OF$MEMORY-ITEM$PTR)/2;
  CALL WRITE(CO,.('CONTINUATION CHARACTER (CR IF NONE):'),36,.STATUS);
  CALL READ(CI,.BUF,ALL,.I,.STATUS);
  IF BUF(0)=CR THEN CONT=0;
  ELSE CONT=BUF(0);
  NI,CC,ITEM(0)=0;
  CALL FIND$EOL;
  DO WHILE CC<NR;
    NI=NI+1;
    IF NI>ITEM$SIZE THEN CALL STAT(103);
    ITEM(NI)=CC;
    CALL FIND$EOL;
    END;
  /* THIS SECTION OF CODE READS THE FIELDS BY WHICH THE USER WANTS HIS
     TEXT SORTED.  ON THE PROMPT 'FIELD- ' THE USER CAN RESPOND WITH A
     CARRIAGE RETURN, ONE NUMBER, OR TWO NUMBERS SEPARATED BY BLANKS AND/OR
     A COMMA.  LET THE CHARACTER @ BE CARRIAGE RETURN, 'END' MEAN THAT
     NO MORE PROMPTS ARE MADE FOR FIELDS, AND 'CONT' MEAN THAT PROMPTING
     WILL OCCUR FOR ANOTHER FIELD UNLESS THERE ARE ALREADY TEN FIELDS.
     THEN THE FOLLOWING RESPONSES ARE POSSIBLE AND WILL PRODUCE THE RESULTS
     SHOWN:

              FIELD- @        END.  IF NO FIELDS HAVE BEEN DEFINED, THEN
                               DEFINE ONE FIELD WITH THE DEFAULT VALUES
                               1 AND EOL.
              FIELD- N@       CONT, WITH THE SORT FIELD STARTING AT COLUMN N
                               AND GOING TO THE END OF LINE.
              FIELD- N,M@     CONT, WITH THE SORT FIELD STARTING AT
                               COLUMN N AND GOING TO COLUMN M.
                               EOL'S ARE IGNORED.
              FIELD- 0@       SAME AS (1).
              FIELD- N,0@     SAME AS (2).

     NOTE THAT TO USE A SINGLE COLUMN AS THE SORT FIELD, THE COLUMN NUMBER
     MUST BE ENTERED TWICE.  E.G.  FIELD- 3,3@   WILL USE ONLY COLUMN
     THREE FOR THIS SORT FIELD.  THE PRECEDENCE OF THE SORT FIELDS IS THE
     SAME AS THEIR ORDER OF ENTRY.
*/
  NF=0; WORKING=TRUE;
  DO WHILE NF<10 AND WORKING;
    CALL WRITE(CO,.('FIELD- '),7,.STATUS);
    CALL READ(CI,.BUF,ALL,.I,.STATUS);
    BPTR=0;
    CALL READ$FIELD;
    IF J=0 THEN DO;
      IF NF<>0 THEN NF=NF-1;
      ELSE DO;
        FIELD(NF).FIRST=0;
        FIELD(NF).LAST=NR;
        END;
      WORKING=FALSE;
      END;
    ELSE DO;
      FIELD(NF).FIRST=J-1;
      CALL READ$FIELD;
      IF J=0 THEN DO;
        FIELD(NF).LAST=NR;
        NF=NF+1;
        END;
      ELSE
        IF J>=FIELD(NF).FIRST THEN DO;
          FIELD(NF).LAST=J-1;
          NF=NF+1;
          END;
        ELSE CALL ERROR(108);
      END;
    END;
  IF NF=10 THEN NF=9;
  CALL SHELL$SORT;
  D1:DO I=0 TO NI;
    CALL WRYTE(I);
    CALL STAT(STATUS);
    END D1;
  CALL CLOSE(AFTN,.STATUS);
  CALL STAT(STATUS);
  CALL CLOSE(AFTN2,.STATUS);
  CALL STAT(STATUS);
  CALL EXIT;
  END SORT;
src/sort2.asm
$MACROFILE NOGEN

;      '(C) Intel Corporation 1981'.  All rights reserved.  No
;      part of this program or publication may be reproduced,
;      transmitted, transcribed, stored in a retrievel system, or
;      translated into any language or computer language, in any
;      form or by any means, electronic, mechanical, magnetic,
;      optical, chemical, manual or otherwise, without the prior
;      written permission of Intel Corporation, 3065 Bowers
;      Avenue, Santa Clara, California, 95051, Attn: Software
;      License Administration.

; SORT: PROCEDURE (PTR,COUNT,PROC$ADDR) EXTERNAL;
;   DECLARE (PTR,COUNT,PROC$ADDR) ADDRESS;
; END;
;
; SORT ACCEPTS AN ARRAY OF POINTERS AND SORTS THE POINTERS.
;   "COUNT" IS THE NUMBER OF POINTERS.
;   "PTR" IS THE LOCATION OF THE POINTERS
;   "PROC$ADDR" IS THE ADDRESS OF THE FOLLOWING PROCEDURE:
;
; GREATER$THAN: PROCEDURE (PTR1,PTR2);
;   DECLARE (PTR1,PTR2) ADDRESS;
;   ...
; END;
;
; "GREATER$THAN" ACCEPTS AS INPUT TWO POINTERS INTO THE ARRAY
;   OF POINTERS.  IT RETURNS TRUE IFF THE RECORD ASSOCIATED
;   WITH PTR1 IS GREATER THAN THE RECORD ASSOCIATED WITH PTR2.
;
; SORT SORTS THE POINTERS SO THAT THE ASSOCIATED RECORDS ARE IN
;   INCREASING ORDER.
$EJECT
        NAME SORT
        CSEG
        PUBLIC SORT

        MIDPOINT MACRO  ;; LOCATE POINTER IN THE MIDDLE OF THE ARRAY
        MOV A,L
        ADD E
        MOV C,A
        MOV A,H
        ADC D           ;; AC NOW EQUALS (HL+DE) -- NOW DIVIDE BY 2
        RAR
        MOV B,A
        MOV A,C
        RAR             ;; BA NOW EQUALS (HL+DE)/2 -- NOW INSURE THAT IT
                        ;;   HAS THE SAME PARITY AS ALL THE OTHER POINTERS
        XRA L
        ANI 0FEH
        XRA L
        MOV C,A         ;; BC IS THE ANSWER.
        ENDM

        CENTER MACRO    ;;SET HA TO (HL+BC)/2
        DAD B
        MOV A,H
        RAR
        MOV H,A
        MOV A,L
        RAR
        ENDM

        JFALSE MACRO PARAM    ;; JUMP IF BCGTDE WAS FALSE I.E. IF BC <= DE
        JNC PARAM
        ENDM

        SKIP1 MACRO        ;; SKIP NEXT 1 INSTRUCTION BYTE  -- WIPES OUT A
        DB (MVI A,0)
        ENDM

        SKIP2 MACRO        ;; SKIP NEXT 2 INSTRUCTION BYTES  -- WIPES OUT HL
        DB (LXI H,0)
        ENDM

        IFCROSS MACRO ADR  ;; JUMP TO ADR IF BC AND DE HAVE CROSSED.
        MOV A,E
        SUB C
        MOV A,D
        SBB B
        JC ADR
        ENDM
$EJECT
SORT:                 ; BC=COUNT   DE=PROC$ADDR   HL=???   S1=RET   S2=PTR
        XCHG
        SHLD PADDR    ; BC=COUNT   DE=???   HL=PROC$ADDR
        POP H
        XTHL          ; BC=COUNT   DE=???   HL=PTR
        MOV D,H
        MOV E,L       ; BC=COUNT   DE=START$PTR   HL=START$PTR
        DAD B
        DAD B
        DCX H
        DCX H
        XCHG          ; BC=COUNT   DE=END$PTR   HL=START$PTR

HDSORT:                ; INTERIOR SORT ROUTINE WHICH IS CALLED RECURSIVELY.
                      ; SORTS POINTERS AT HL THRU DE.     A,B,C IGNORED.

        MOV A,E
        SUB L
        MOV C,A
        MOV A,D
        SBB H
        RC            ; RETURN IF END$PTR < START$PTR
        ORA C
        RZ            ;   ...OR IF END$PTR = START$PTR
$EJECT
; THE TOPMOST POINTER IS GOING TO BE SWITCHED INTO ITS FINAL POSITION ON
; THE NEXT PAGE.  ON THIS PAGE, WE INCREASE THE PROBABILITY THAT THAT
; FINAL POSITION IS NEAR THE MIDDLE.  THIS SPEEDS THINGS UP.  WE DO SO
; BY LOOKING AT THE BOTTOM, MID, AND TOP POINTERS, AND SWITCHING THE
; SECOND HIGHEST OF THE THREE TO THE TOP POSITION.

                      ; POINTER ARRAY LOOKS LIKE THIS:
                      ; HL . . .    . . . DE
        PUSH H        ; S1 . . .    . . . DE
        MIDPOINT      ; S1 . . . BC . . . DE
        CALL BCGTDE
        CC SWITCH     ; GUARANTEES MID < TOP
        POP H         ; HL . . . BC . . . DE
        PUSH B        ; HL . . . S1 . . . DE
        MOV B,H
        MOV C,L       ; BC . . . S1 . . . DE
        CALL BCGTDE   ; BOTTOM > TOP?
        POP H         ; BC . . . HL . . . DE
        JC ALLSET     ; IF SO THEN TOP IS ALREADY GOOD
        XCHG          ; BC . . . DE . . . HL
        PUSH H        ; BC . . . DE . . . S1
        CALL BCGTDE
        CNC SWITCH    ; GUARANTEES TOP > BOTTOM > MID
        POP D         ; BC . . .    . . . DE
        CALL SWITCH   ; NOW BOTTOM > TOP > MID   SO TOP IS GOOD.
ALLSET:
        PUSH B
        PUSH D        ; S2=BC . . . . . . S1=DE
$EJECT
; IN THIS STAGE, SWITCHES OF POINTERS ARE MADE UNTIL THERE IS A
; SINGLE POINTER IN ITS FINAL POSITION, WITH ALL LESSER POINTERS
; TO THE LEFT AND ALL GREATER POINTERS TO THE RIGHT.

CMPF:
        CALL BCGTDE
        JFALSE CRUZF
        CALL SWITCH
CRUZB:
        DCX D
        DCX D
        IFCROSS RCURS2
CMPB:
        CALL BCGTDE
        JFALSE CRUZB
        CALL SWITCH
CRUZF:
        INX B
        INX B
        IFCROSS RCURS1

        JMP CMPF
$EJECT
; NOW WE CAN SPLIT THE SORT INTO TWO HALF SORTS AND DO THE HALF SORTS
; BY RECURSION.
; AN ADJUSTMENT OF BC OR DE MUST FIRST BE MADE, DEPENDING ON THE ENTRY POINT.

RCURS1:                  ; S2 . . . . . DE BC . . . . . S1
                         ;             GOOD
        DCX D
        DCX D
        SKIP2
RCURS2:                  ; S2 . . . . . DE BC . . . . . S1
                         ;                GOOD
        INX B
        INX B

; NOW COMPUTE WHICH HALF IS SMALLER AND DO IT FIRST.

RCURS:                   ; S2 . . . . . DE GOOD BC . . . . . S1
        MOV H,B
        MOV L,C
        POP B            ; S1 . . . . . DE      HL . . . . . BC
        XTHL             ; HL . . . . . DE      S1 . . . . . BC
        PUSH H           ; S1 . . . . . DE      S2 . . . . . BC
        CENTER
        SUB E
        MOV A,H
        SBB D
        POP H            ; HL . . . . . DE      S1 . . . . . BC
        JNC LEFT
RIGHT:
        XTHL             ; S1 . . . . . . DE   HL . . . BC
        PUSH D           ; S2 . . . . . . S1   HL . . . BC
        MOV D,B
        MOV E,C          ; S2 . . . . . . S1   HL . . . DE
        SKIP1
LEFT:
        PUSH B           ; HL . . . DE   S2 . . . . . . S1

        CALL HDSORT       ; SORT THE FIRST HALF
        POP D
        POP H            ; POP OFF THE POINTERS TO THE OTHER HALF
        JMP HDSORT        ; SORT THE OTHER HALF
$EJECT

SWITCH:           ; SWITCH WORD POINTED AT BY BC WITH WORD POINTED AT BY DE
                  ; SAVE B,C,D,E

        MOV H,B
        MOV L,C
        LDAX D
        MOV C,M
        MOV M,A
        XCHG
        MOV M,C
        INX H
        INX D
        LDAX D
        MOV C,M
        MOV M,A
        XCHG
        MOV M,C
        DCX D
        DCX H
        MOV C,L
        RET

        DSEG
BCGTDE:                  ; CALL EXTERNALLY-PASSED "BC GREATER THAN DE"
                         ; ROUTINE SO AS TO PRESERVE B,C,D,E AND RETURN
                         ; THE ANSWER IN THE CARRY FLAG (CARRY=TRUE)

        PUSH B
        PUSH D
        DB (CALL 0)
PADDR:
        DW 0
        RAR
        POP D
        POP B
        RET

        STKLN 100

$EJECT
        END
src/stopif.plm
$ TITLE('=====>>>  STOPIF   <<<=====')

STOPIF: DO;

/************************************************************************/
/*																		*/
/*      '(C) Intel Corporation 1981'.  All rights reserved.  No			*/
/*      part of this program or publication may be reproduced,			*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

      
/* THIS IMPROVED VERSION OF STOPIF IS DESIGNED TO RUN WITH THE ASSEMBLERS AS
WELL AS PL/M.  ADDITIONALLY, THE PRESENCE OF A PAGE BREAK SHOULD NOT FOUL UP
STOPIF. */

DECLARE COPYRIGHT (*) BYTE DATA ('(C) INTEL CORP 1981');

DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.0',0);
    

/* LITERALLY DEFINITIONS */

  DECLARE
    TRUE LITERALLY '0FFH',
    FALSE LITERALLY '0',
    WORD LITERALLY 'ADDRESS',
    POINTER LITERALLY 'ADDRESS',
    CR LITERALLY '0DH',
    LF LITERALLY '0AH',
    TAB LITERALLY '09H',
    FF LITERALLY '0CH',
    BELL LITERALLY '07H',
    BOOLEAN LITERALLY 'BYTE';

/* EXTERNAL PROCEDURES FROM ISIS */

OPEN: PROCEDURE(AFTN$P,FILENAME$P,ACCESS,MODE,STATUS$P) EXTERNAL;
  DECLARE
    (AFTN$P,FILENAME$P,STATUS$P) POINTER,
    (ACCESS,MODE) WORD;
END OPEN;

READ: PROCEDURE(AFTN,BUF$P,COUNT,ACTUAL$P,STATUS$P) EXTERNAL;
  DECLARE
    (AFTN,COUNT) WORD,
    (BUF$P,ACTUAL$P,STATUS$P) POINTER;
END READ;

WRITE: PROCEDURE(AFTN,BUF$P,COUNT,STATUS$P) EXTERNAL;
  DECLARE
    (AFTN,COUNT) WORD,
    (BUF$P,STATUS$P) POINTER;
END WRITE;

SEEK: PROCEDURE(AFTN,MODE,BLOCKNO$P,BYTENO$P,STATUS$P) EXTERNAL;
  DECLARE
    (AFTN,MODE) WORD,
    (BLOCKNO$P,BYTENO$P,STATUS$P) POINTER;
END SEEK;

ERROR: PROCEDURE (NUMBER) EXTERNAL;
  DECLARE NUMBER WORD;
END ERROR;

EXIT: PROCEDURE EXTERNAL;
END EXIT;

WHOCON: PROCEDURE(AFTN,FILE$NAME$P) EXTERNAL;
  DECLARE
    AFTN WORD,
    FILENAME$P POINTER;
END WHOCON;

CONSOL: PROCEDURE(INFILE$P,OUTFILE$P,STATUS$P) EXTERNAL;
  DECLARE (INFILE$P,OUTFILE$P,STATUS$P) POINTER;
END CONSOL;

/* GLOBAL VARIABLES */

DECLARE
  STATUS WORD, /* FOR CALLS TO ISIS */
  COMMAND$SIZE WORD,
  ACTUAL WORD,
  AFTN WORD,
  (BLOCK$NUMBER, BYTE$NUMBER) WORD,
  BUFFER(257) BYTE, /* THE LAST 128 BYTES OF THE LISTING */
  START$BUF BYTE INITIAL(128), /* POINTER INTO BUFFER,
                               /* FIRST READ 128, THEN 0 */
  LINE$CURSOR WORD, /* POINTER AT BEGINNING OF CURRENT LINE */
  LINE$END WORD, /* LAST POSITION IN CURRENT LINE */
  CURSOR WORD, /* POINTER AT FOR SCAN */
  TIMER BYTE, /* FOR TIMING THE BELL */
  COMMAND$TAIL(122) BYTE,
  NON$LIST$MSG (*) BYTE DATA('NOT A LISTING ==>',0),
  EMSG (*) BYTE DATA ('PROGRAM ERROR IN',0),
  WMSG (*) BYTE DATA ('PROGRAM WARNING IN',0);


/* LOCAL PROCEDURES */

CHECK$STATUS: PROCEDURE;

  IF STATUS <> 0
  THEN DO;
    CALL ERROR(STATUS);
    CALL CONSOL(.(':VI: '),.(':VO: '),.STATUS);
    IF STATUS <> 0
    THEN CALL ERROR(STATUS);
    CALL EXIT;
  END;

END CHECK$STATUS;

DISPLAY: PROCEDURE(LEN,BUF) PUBLIC; /* WRITE OUT A BUFFER TO THE CONSOL */

  DECLARE
    LEN WORD, /* THE NUMBER OF CHARACTER TO WRITE OUT */
    BUF ADDRESS; /* THE ADDRESS OF THE BUFFER */

  IF LEN > 0
  THEN DO;

    CALL WRITE(0,BUF,LEN,.STATUS);
    CALL CHECK$STATUS;

  END;

END DISPLAY;

PRINT: PROCEDURE(BUF) PUBLIC;
         /* WRITE OUT A BUFFER TERMINATED BY NULL TO :CO: */

  DECLARE
    BUF ADDRESS, /* ADDRESS OF BUFFER */
    PTR ADDRESS, /* POINTER INTO BUFFER */
    CHAR BASED PTR BYTE; /* CHARACTER IN BUFFER */

  /* SEARCH FOR NULL */
  PTR = BUF;
  DO WHILE CHAR <> 0;
    PTR = PTR + 1;
  END;

  /* print out buffer */
  CALL DISPLAY(PTR - BUF,BUF);

END PRINT;

FAIL: PROCEDURE(MSG$P);

  DECLARE MSG$P POINTER,
          OUT$FILE$NAME(15) BYTE;

  CALL PRINT(MSG$P);
  CALL DISPLAY(COMMAND$SIZE,.COMMAND$TAIL);
  CALL WHOCON(0,.OUT$FILE$NAME);
  CALL CONSOL(.(':VI: '),.(':VO: '),.STATUS);
  CALL CHECK$STATUS;
  IF OUT$FILE$NAME(1) <> 'V' /* VIDEO OUTPUT */
  THEN DO;
    CALL PRINT(MSG$P);
    CALL DISPLAY(COMMAND$SIZE,.COMMAND$TAIL);
  END;
  CALL PRINT(.(CR,LF,0));
  DO TIMER = 1 TO 80;
    CALL DISPLAY(1,.(BELL));
    CALL TIME(250);
  END;
  CALL EXIT;

END FAIL;

READ$BUF: PROCEDURE;

  IF BLOCK$NUMBER = 0
  THEN CALL FAIL(.NON$LIST$MSG);

  BLOCK$NUMBER = BLOCK$NUMBER - 1;
  CALL SEEK(AFTN,2,.BLOCK$NUMBER,.BYTE$NUMBER,.STATUS);
  CALL CHECK$STATUS;

  CALL READ(AFTN,.BUFFER(START$BUF),128,.ACTUAL,.STATUS);
  CALL CHECK$STATUS;

END READ$BUF;

EQUAL: PROCEDURE (MSG$P) BOOLEAN; /* COMPARE CONTENTS OF BUFFER TO MESSAGE */

  DECLARE
    MSG$P POINTER,
    MSG BASED MSG$P (1) BYTE,
    J BYTE;

  J = 0;
  DO WHILE MSG(J) <> 0;
    IF CURSOR + J > LINE$END /* END OF BUFFER MINUS CR,LF */
    THEN RETURN FALSE;
    IF BUFFER(CURSOR + J) <> MSG(J)
    THEN RETURN FALSE;
    J = J + 1;
  END;

  RETURN TRUE;

END EQUAL;

/* MAIN BEGIN */

/* READ COMMAND TAIL */
CALL READ(1,.COMMAND$TAIL,128,.COMMAND$SIZE,.STATUS);
CALL CHECK$STATUS;

CALL OPEN(.AFTN,.COMMAND$TAIL,1,0,.STATUS);
IF STATUS = 13
THEN CALL FAIL(.('NO SUCH FILE ==>',0));
IF STATUS = 4 OR STATUS = 5 OR STATUS = 23 OR STATUS = 28
THEN CALL FAIL(.('ILLEGAL FILENAME SPECIFICATION ==>',0));
CALL CHECK$STATUS;

CALL SEEK(AFTN,4,.BLOCK$NUMBER,.BYTE$NUMBER,.STATUS);
CALL CHECK$STATUS;

CALL SEEK(AFTN,0,.BLOCK$NUMBER,.BYTE$NUMBER,.STATUS);

CALL READ$BUF;
BUFFER(256) = CR;
LINE$CURSOR, LINE$END = 255;

DO WHILE LINE$CURSOR > 0;

  IF LINE$CURSOR = 127
  THEN DO;
    START$BUF = 0;
    CALL READ$BUF;
  END;

  IF BUFFER(LINE$CURSOR) = CR OR BUFFER(LINE$CURSOR) = LF
  THEN DO;     /* END OF A LINE, SEARCH FOR 'ERROR' */
    CURSOR = LINE$CURSOR + 1;
    IF BUFFER(CURSOR) <> FF
    THEN DO;
      DO WHILE LINE$END > CURSOR + 4;
        DO WHILE BUFFER(CURSOR) = ' ';
          CURSOR = CURSOR + 1;
        END;
        IF EQUAL(.('ERROR',0))
        THEN CALL FAIL(.EMSG);
        IF EQUAL(.('Error',0)) /* PASCAL-86 */
        THEN CALL FAIL(.EMSG);
        IF EQUAL(.('WARNING',0))
        THEN CALL FAIL(.WMSG);
        IF EQUAL(.('0 PROGRAM ERRORS',0)) /* SIII PL/M-86 */
        THEN GOTO NEXT$LINE;
        IF EQUAL(.('0 PROGRAM ERROR(S)',0)) /* SII PL/M-86 */
        THEN CALL EXIT;
        IF EQUAL(.('0 PROGRAM WARNINGS',0)) /* SIII PL/M-86 */
        THEN CALL EXIT;
        IF EQUAL(.('0 Errors Detected',0)) /* PASCAL-86 */
        THEN CALL EXIT;
        IF EQUAL(.('NO ERRORS',0)) /* ASM86, BOTH SII AND SIII */
        THEN CALL EXIT;
        DO WHILE BUFFER(CURSOR) <> ' ' AND LINE$END > CURSOR + 4;
          CURSOR = CURSOR + 1;
        END;
      END; /* ENOUGH SPACE FOR ERROR */
   END; /* NOT A PAGE HEADING LINE */
 NEXT$LINE:
   LINE$CURSOR, LINE$END = LINE$CURSOR - 1;
 END;
 ELSE LINE$CURSOR = LINE$CURSOR - 1;

END;

CALL FAIL(.NON$LIST$MSG);

END STOPIF;
src/tail.plm
TAIL:DO;


/************************************************************************/
/*																		*/
/*      '(C) Intel Corporation 1981'.  All rights reserved.  No			*/
/*      part of this program or publication may be reproduced,			*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

      
DECLARE COPYRIGHT (*) BYTE DATA ('(C) INTEL CORP 1981');


/* THIS MODULE SCANS THE COMMAND TAIL AND OPENS ALL THREE FILES */

DECLARE
  TRUE LITERALLY '0FFH',
  FALSE LITERALLY'0',
  CR LITERALLY'0DH', /* CARRIAGE RETURN */
  LF LITERALLY'0AH', /* LINE FEED */

  LINE(128) BYTE, /* COMMAND LINE */
  DIGITS(6) BYTE, /* USED FOR PRINTING SYNCPARM */
  PTR ADDRESS, /* CURSOR POSITION IN SCANNING COMMAND LINE */
  CHAR BASED PTR BYTE, /* CHARACTER IN COMMAND LINE */
  LEXLEN BYTE, /* LENGTH OF CURRENT LEXEME */
  LEXPTR ADDRESS, /* POINTER AT CURRENT LEXEME */
  LEXCHAR BASED LEXPTR BYTE, /* CHARACTER IN LEXEME */
  FILE$NAME$0(15) BYTE EXTERNAL,
  FILE$NAME$1(15) BYTE EXTERNAL,
  OUT$FILE$NAME(15) BYTE INITIAL('               '),
  AFTN0 ADDRESS EXTERNAL, /* AFTN FOR FILE1 */
  AFTN1 ADDRESS EXTERNAL, /* AFTN FOR FILE2 */
  OUT$AFTN ADDRESS EXTERNAL, /* AFTN FOR OUTPUT FILE */
  SYNCPARM BYTE EXTERNAL,
  ACTUAL ADDRESS PUBLIC, /* NUMBER OF CHARACTERS READ IN */
  STATUS ADDRESS PUBLIC;

OPEN: PROCEDURE(AFTN,FILE,ACCESS,MODE,STATUS) EXTERNAL;
  DECLARE(AFTN,FILE,ACCESS,MODE,STATUS) ADDRESS;
END OPEN;

ERROR: PROCEDURE(NUMBER) EXTERNAL;
  DECLARE NUMBER ADDRESS;
END ERROR;

READ: PROCEDURE(AFTN,BUF,COUNT,ACTUAL,STATUS) EXTERNAL;
  DECLARE(AFTN,BUF,COUNT,ACTUAL,STATUS) ADDRESS;
END READ;

WRITE: PROCEDURE(AFTN,BUF,COUNT,STATUS) EXTERNAL;
  DECLARE(AFTN,BUF,COUNT,STATUS) ADDRESS;
END WRITE;

EXIT: PROCEDURE EXTERNAL;
END EXIT;

DISPLAY: PROCEDURE (LEN,BUFFER) EXTERNAL;
  DECLARE
    LEN BYTE,
    BUFFER ADDRESS;
END DISPLAY;

NEW$LINE: PROCEDURE EXTERNAL;
END NEW$LINE;

DUMP: PROCEDURE EXTERNAL;
END DUMP;

CONVND: PROCEDURE(NUMBER,DIGITS) EXTERNAL;
  DECLARE (NUMBER,DIGITS) ADDRESS;
END CONVND;

CHECK$STATUS: PROCEDURE PUBLIC;

  /* CHECK STATUS AND IF NONZERO DON'T RETURN */

  IF STATUS<>0 THEN
    DO;
      CALL ERROR(STATUS);
      CALL EXIT;
    END;

END CHECK$STATUS;

SYN$ERR: PROCEDURE;

  /* REPORT FATAL SYNTAX ERROR. */

  CALL WRITE(0,.('COMMAND FORMAT: <FILE1> TO <FILE2>&',CR,LF,
            '[ PRINT( <FILE> ) ]  [ SYNC ( <NUMBER> ) ]',CR,LF),81,.STATUS);
  CALL CHECKSTATUS;
  CALL EXIT;

END SYN$ERR;

SCAN: PROCEDURE;

/* PROCEDURE TO RETURN THE NEXT LEXEME IN THE COMMAND TAIL */

  /* SKIP BLANKS AND COMMAS */
  DO WHILE (CHAR = ' ') OR (CHAR = '&');
    IF CHAR = '&' /* REPROMPT AND READ IN NEW LINE */
    THEN DO;
      CALL WRITE(0,.('**'),2,.STATUS);
      CALL CHECK$STATUS;
      CALL READ(1,.LINE,128,.ACTUAL,.STATUS);
      CALL CHECK$STATUS;
      PTR = .LINE;
    END;
    ELSE PTR = PTR + 1;
  END;
  LEXPTR = PTR;
  IF (CHAR = '(') OR (CHAR = ')') OR (CHAR = CR)
  THEN DO;
    LEXLEN = 1;
    PTR = PTR + 1;
    RETURN;
    END;
  LEXLEN = 0;
  /* ISOLATE COMMAND WORD */
  DO WHILE (CHAR <> ' ') AND (CHAR <> '(') AND (CHAR <> ')')
       AND (CHAR <> '&') AND (CHAR <> CR);
    IF CHAR > 60H /* LOWER CASE */
    THEN CHAR = CHAR - 20H; /* RAISE CASE */
    PTR = PTR + 1;
    LEXLEN = LEXLEN + 1;
  END;

END SCAN;

EQUAL: PROCEDURE(LEN1,PTR1,LEN2,PTR2) BYTE;

/* PROCEDURE TO TEST IF TWO STRINGS ARE EQUAL */

  DECLARE
    LEN1 BYTE, /* LENGTH OF STRING 1 */
    LEN2 BYTE, /* LENGTH OF STRING 2 */
    PTR1 ADDRESS, /* ADDRESS OF STRING 1 */
    PTR2 ADDRESS, /* ADDRESS OF STRING 2 */
    CHAR1 BASED PTR1 BYTE, /* CHARACTER IN STRING 1 */
    CHAR2 BASED PTR2 BYTE, /* CHARACTER IN STRING 2 */
    I BYTE; /* LOOP INDEX */
  IF LEN1 <> LEN2 THEN RETURN FALSE;

  DO I = 1 TO LEN1;
    IF CHAR1 <> CHAR2 THEN RETURN FALSE;
    PTR1 = PTR1 + 1;
    PTR2 = PTR2 + 1;
  END;

  RETURN TRUE;

END EQUAL;

COMMAND: PROCEDURE PUBLIC;

/* PROCEDURE TO READ THE COMMAND LINE AND OPEN FILES */

   DECLARE I BYTE; /* LOOP INDEX */

   CALL READ(1,.LINE,128,.ACTUAL,.STATUS);
   CALL CHECK$STATUS;
   PTR = .LINE;
   CALL SCAN;
   CALL MOVE(LEXLEN,LEXPTR,.FILE$NAME$0);
   CALL SCAN;
   IF NOT EQUAL(2,.('TO'),LEXLEN,LEXPTR) THEN CALL SYN$ERR;
   CALL SCAN;
   CALL MOVE(LEXLEN,LEXPTR,.FILE$NAME$1);
   CALL SCAN;
   IF EQUAL(5,.('PRINT'),LEXLEN,LEXPTR)
   THEN DO;
     CALL SCAN;
     IF NOT EQUAL(1,.('('),LEXLEN,LEXPTR) THEN CALL SYN$ERR;
     CALL SCAN;
     CALL MOVE(LEXLEN,LEXPTR,.OUT$FILE$NAME);
     CALL SCAN;
     IF NOT EQUAL(1,.(')'),LEXLEN,LEXPTR) THEN CALL SYN$ERR;
     CALL SCAN;
   END;
   ELSE CALL MOVE(4,.(':CO:'),.OUT$FILE$NAME);
   IF EQUAL(4,.('SYNC'),LEXLEN,LEXPTR)
   THEN DO;
     CALL SCAN;
     IF NOT EQUAL(1,.('('),LEXLEN,LEXPTR) THEN CALL SYN$ERR;
     CALL SCAN;
     SYNCPARM = 0;
     DO I = 1 TO LEXLEN;
       IF (LEXCHAR < 30H) OR (LEXCHAR > 39H) THEN CALL SYN$ERR;
       SYNCPARM = SYNCPARM*10 + LEXCHAR - 30H;
       LEXPTR = LEXPTR + 1;
     END;
     CALL SCAN;
     IF NOT EQUAL(1,.(')'),LEXLEN,LEXPTR) THEN CALL SYN$ERR;
     CALL SCAN;
   END;
   ELSE SYNCPARM = 3;
   IF NOT EQUAL(1,.(CR),LEXLEN,LEXPTR) THEN CALL SYN$ERR;
   CALL WRITE(0,.('ISIS-II SOURCE COMPARE V1.0',CR,LF,LF),30,.STATUS);
   CALL CHECKSTATUS;

CALL OPEN(.AFTN1,.FILE$NAME$1,1,0,.STATUS);    /* OPEN SECOND IN FILE */
CALL CHECK$STATUS;
CALL OPEN(.AFTN0,.FILE$NAME$0,1,0,.STATUS);    /* OPEN FIRST IN FILE */
CALL CHECK$STATUS;
CALL OPEN(.OUT$AFTN,.OUT$FILE$NAME,2,0,.STATUS);    /* OPEN NEW OUT FILE */
CALL CHECK$STATUS;
IF NOT EQUAL(15,.OUT$FILE$NAME,15,.(':CO:           '))
THEN DO;
  CALL DISPLAY(31,.(CR,LF,'ISIS-II SOURCE COMPARE X007',CR,LF));
  CALL DISPLAY(6,.('PRINT('));
  CALL DISPLAY(15,.OUT$FILE$NAME);
  CALL DISPLAY(10,.(')    SYNC('));
  CALL CONVND(SYNCPARM,.DIGITS);
  CALL DISPLAY(3,2+.DIGITS);
  CALL DISPLAY(3,.(')',CR,LF));
  CALL DISPLAY(8,.('FILE 1: '));
  CALL DISPLAY(15,.FILE$NAME$0);
  CALL NEW$LINE;
  CALL DISPLAY(8,.('FILE 2: '));
  CALL DISPLAY(15,.FILE$NAME$1);
  CALL NEWLINE;
  CALL NEWLINE;
  CALL DUMP;
END;
END COMMAND;

END TAIL;
src/tokens.plm
$ TITLE ('==> PASSIF -- TOKENSMOD -- UDI STYLE TOKENIZER <==')

TOKENS$MOD:
DO;

/************************************************************************/
/*																		*/
/*      '(C) Intel Corporation 1981'.  All rights reserved.  No			*/
/*      part of this program or publication may be reproduced,			*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

$ NOLIST

/*         LIT.INC          */

DECLARE                 AS LITERALLY 'LITERALLY',              /* plm */
    AMPERSAND           AS '''&''',							   /* ??? */
    BELL                AS '07H',                              /* plm */
    BLANK               AS '020H',                             /* plm */
    BOOLEAN             AS 'BYTE',                             /* plm */
    CHK                 AS 'CALL CHECK$STATUS',	               /* plm */
    CLEAR$CHAR			AS '01CH',							   /* 1510 */
    CO$ECHO$FILE        AS '0F00H',                            /* open */
    COLON               AS ''':''',                            /* char */
    COMMA               AS '02CH',                       	   /* plm */
    CONSOLE$INPUT       AS '1',                                /* open */
    CONSOLE$OUTPUT      AS '0',                                /* open */
    CONTROL$Z           AS '01AH',                             /* plm */
    CR                  AS '0DH',                              /* plm */
    DOT                 AS '''.''',                            /* char */
    END$DO              AS 'END',                              /* plm */
    END$DO$CASE         AS 'END',                              /* plm */
    END$DO$WHILE        AS 'END',                              /* plm */
    END$IF              AS '   ',                              /* plm */
    END$ITERATED$DO		AS 'END',							   /* plm */
    END$LOOP            AS ' ',                                /* plm */
    EOF$CHAR            AS 'CONTROL$Z',                        /* plm */
    ESC                 AS '01BH',                             /* plm */
    FALSE               AS '0H',                               /* plm */
    FF					AS '0CH',							   /* ??? */
    FOREVER             AS 'WHILE 1',                          /* plm */
    FORMAT$ATTRIBUTE	AS '3',								   /* attrib */
    HASH$MARK			AS '''#''',							   /* plm */
    INIT$STG			AS '(*) BYTE INITIAL',				   /* plm */
    LEAD$IN$CHAR		AS '07EH',							   /*1510 */
    LF                  AS '0AH',                              /* plm */
    NO$LINE$EDIT        AS '0',                                /* open */
    NULL				AS '0FFFFH',						   /* ???  */
    OPEN$FOR$READ       AS '1',                                /* open */
    OPEN$FOR$WRITE      AS '2',                                /* open */
    OPEN$FOR$UPDATE		AS '3',								   /* open */
    PUB$STRING			AS '(*) BYTE PUBLIC DATA',             /* plm  */
    RESET				AS '0',								   /* attrib */
    RETURN$MARKER$POS   AS '0',                                /* seek */
    SEEK$2$EOF          AS '4',                                /* seek */
    SEEK$BACKWARD$BY$N  AS '1',                                /* seek */
    SEEK$FORWARD$BY$N	AS '3',								   /* seek */
    SEEK$2$N            AS '2',                                /* seek */
    SEMICOLON			AS ''';''',							   /* plm  */
    SET					AS '1',								   /* attrib */
    STRING              AS '(*) BYTE DATA',                    /* plm  */
    TAB                 AS '09H',                              /* plm */
    TRANSFER$CONTROL    AS '1',                                /* load */
    TRUE                AS '0FFH',                             /* plm */
    UNDERBAR			AS '''_''', 						   /* ??? */
    USER$CI             AS '0',                                /* ??? */
    WRITE$PROTECT$ATTRIBUTE 		AS '2',					   /* attrib */
    ZERO$BIAS           AS '0'                                 /* load */ ;

    /*        ENDLIT.INC        */

$ LIST
$ NOLIST

		/* ISIS.INC */

ATTRIB:
	PROCEDURE(FILE$NAME$PTR,WHICH$ATTRIBUTE,SET$OR$RESET,STATUS$PTR) EXTERNAL;
	DECLARE (FILE$NAME$PTR,WHICH$ATTRIBUTE,SET$OR$RESET,STATUS$PTR) ADDRESS;
	END
ATTRIB;

CLOSE:
	PROCEDURE (AFTN,STATUS) EXTERNAL;
	DECLARE (AFTN,STATUS) ADDRESS;
	END
CLOSE;

CI:
	PROCEDURE BYTE EXTERNAL;
	END
CI;

CO:
	PROCEDURE (CHAR$CO) EXTERNAL;
	DECLARE CHAR$CO BYTE;
	END
CO;

CONSOL:
	PROCEDURE (CONSOLE$INPUT$FILE,CONSOL$OUTPUT$FILE,STATUS$CON) EXTERNAL;
	DECLARE (CONSOLE$INPUT$FILE,CONSOL$OUTPUT$FILE,STATUS$CON) ADDRESS;
	END
CONSOL;

DELETE:
	PROCEDURE (FILE$NAME$PTR,STATUS) EXTERNAL;
	DECLARE (FILE$NAME$PTR,STATUS) ADDRESS;
	END
DELETE;

ERROR:
	PROCEDURE  (ERROR$NUMBER) EXTERNAL;
	DECLARE ERROR$NUMBER ADDRESS;
	END
ERROR;

EXIT:
	PROCEDURE EXTERNAL;
	END
EXIT;

IO$CHK:
	PROCEDURE BYTE EXTERNAL;
	END
IO$CHK;

IO$DEF:
	PROCEDURE (WHICH$DEVICE,ENTRY$POINT) EXTERNAL;
	DECLARE WHICH$DEVICE BYTE,
			ENTRY$POINT ADDRESS;
	END
IO$DEF;

IO$SET:
	PROCEDURE (CONFIGURATION$BYTE) EXTERNAL;
	DECLARE CONFIGURATION$BYTE BYTE;
	END
IO$SET;

LOAD:
	PROCEDURE (FILE,BIAS,CONTROL$OF$TRANSFER,ENTRY$POINT,STATUS) EXTERNAL;
	DECLARE (FILE,BIAS,CONTROL$OF$TRANSFER,ENTRY$POINT,STATUS) ADDRESS;
	END
LOAD;

MEMCK:
	PROCEDURE ADDRESS EXTERNAL;
	END
MEMCK;

OPEN:
	PROCEDURE(AFTN,FILENAME,ACCESS$MODE,LINE$EDIT$AFTN,ERROR) EXTERNAL;
	DECLARE (AFTN,FILENAME,ACCESS$MODE,LINE$EDIT$AFTN,ERROR) ADDRESS;
	END
OPEN;

READ:
	PROCEDURE (AFTN,BUFFER,COUNT,ACTUAL,STATUS) EXTERNAL;
	DECLARE (AFTN,BUFFER,COUNT,ACTUAL,STATUS) ADDRESS;
	END
READ;

RENAME:
	PROCEDURE (OLD$NAME,NEW$NAME,STATUS$R) EXTERNAL;
	DECLARE (OLD$NAME,NEW$NAME,STATUS$R) ADDRESS;
	END
RENAME;

RESCAN:
	PROCEDURE (AFTN,STATUS) EXTERNAL;
	DECLARE (AFTN,STATUS) ADDRESS;
	END
RESCAN;

SEEK:
	PROCEDURE (AFTN,MODE,BLOCKNO,BYTENO,STATUS) EXTERNAL;
	DECLARE (AFTN,MODE,BLOCKNO,BYTENO,STATUS) ADDRESS;
	END
SEEK;

SPATH:
	PROCEDURE (FILE,BUFFER,STATUS) EXTERNAL;
	DECLARE (FILE,BUFFER,STATUS) ADDRESS;
	END
SPATH;

WHOCON:
	PROCEDURE (AFTN,BUFFER) EXTERNAL;
	DECLARE (AFTN,BUFFER) ADDRESS;
	END
WHOCON;

WRITE:
	PROCEDURE (AFTN,BUFFER,COUNT,STATUS) EXTERNAL;
	DECLARE (AFTN,BUFFER,COUNT,STATUS) ADDRESS;
	END
WRITE;

		/* END ISIS.INC */
$ NOLIST

/************************************************************/
/*															*/
/*              LITERALLY'S UNIQUE TO PASSIF                */
/*															*/
/************************************************************/

DECLARE
    MINIMUM$ACCEPTABLE$BANNER$LENGTH 	AS 		'73',
    MAXIMUM$TOKEN$LENGTH				AS		'70',
    BI									AS		'CALL BOMB$IF(STATUS)',

	FIRST$FIELD							AS		'0',
    SECOND$FIELD						AS		'28',
    THIRD$FIELD							AS		'54',

    RIGHT$PARENTHESIS 					AS		''')''',
    LEFT$PARENTHESIS 					AS		'''(''',
    RI									AS		'CALL REPORT$IF',
    UNRECOGNIZED$SWITCH$ERR 			AS		'201',
    QUESTION$MARK						AS		'''?''';

$ LIST
$ NOLIST

/*	MAIN.INC  */

DECLARE
    ACTUAL ADDRESS EXTERNAL,
    AFTN ADDRESS EXTERNAL,
    COMMAND$TAIL$BUF (250) BYTE EXTERNAL,
    DELIMITER BYTE EXTERNAL,
    FIRST$BLOCK$BUF (128) BYTE EXTERNAL,
    FIRST$OUTPUT$MSG$PTR ADDRESS EXTERNAL,
    FIRST$TIME$THROUGH BOOLEAN EXTERNAL,
    INITIALIZED$BANNER (74) BYTE EXTERNAL,
    PRINT$HASH$MARK BOOLEAN EXTERNAL,
    REPORT$FILE$ACTUAL ADDRESS EXTERNAL,
    REPORT$FILE$AFTN ADDRESS EXTERNAL,
    REPORT$FILE$STRING$BEGINNING ADDRESS EXTERNAL,
    SECOND$OUTPUT$MSG$PTR ADDRESS EXTERNAL,
    STATUS ADDRESS EXTERNAL,
    TMP$FILE$AFTN ADDRESS EXTERNAL,
    TMP$FILE$NAME (15) BYTE EXTERNAL,
    TOK$BUF (80) BYTE EXTERNAL;

DECLARE
    KEY$WORDS (10) STRUCTURE
    (LENGTH							BYTE,
    KEY$WORD	(13)				BYTE,
    PROC$PTR						ADDRESS) EXTERNAL;

CO$IS$VO:
	PROCEDURE BOOLEAN EXTERNAL;
	END
CO$IS$VO;

EXIT$ROUTINE:
	PROCEDURE EXTERNAL;
	END
EXIT$ROUTINE;

RE$POSITION$CURSOR:
	PROCEDURE EXTERNAL;
	END
RE$POSITION$CURSOR;

MOVE:
	PROCEDURE (COUNT,SOURCE$PTR,DEST$PTR) EXTERNAL;
	DECLARE (COUNT,SOURCE$PTR,DEST$PTR) ADDRESS;
	END
MOVE;

/*	END MAIN.INC  */
$ LIST
$ NOLIST

/*	ERRMSG.INC  */

DECLARE
	BAD$SYNTAX$MSG 				(29) 				BYTE		EXTERNAL,
	BOMB$IF$MSG$1    			(12) 				BYTE		EXTERNAL,
	BOMB$IF$MSG$2				(40) 				BYTE		EXTERNAL,
    DURING$ASSERTION$CHECK$MSG	(50)				BYTE		EXTERNAL,
    PASSIF$INVOKED$BY$MSG       (19)                BYTE        EXTERNAL,
    ZERO$LENGTH$FILE$MSG 		(40) 				BYTE		EXTERNAL;

/*	END ERRMSG.INC  */
$ LIST
$ NOLIST

/*	CLI.INC  */

DECLARE BUF$COUNT BYTE EXTERNAL;

UDI$STRING$MATCH:
	PROCEDURE (STG$1$PTR,STG$2$PTR) BOOLEAN EXTERNAL;
    DECLARE (STG$1$PTR,STG$2$PTR) ADDRESS;
	END
UDI$STRING$MATCH;

ENFORCE$DELIMITER:
	PROCEDURE(ENFORCEE) EXTERNAL;
	DECLARE ENFORCEE BYTE;
	END
ENFORCE$DELIMITER;

NEXT$ARG:
	PROCEDURE EXTERNAL;
	END
NEXT$ARG;

INTERPRET$COMMAND$LINE:
	PROCEDURE EXTERNAL;
	END
INTERPRET$COMMAND$LINE;

/*	END CLI.INC  */
$ LIST
$ NOLIST

/*	REPORT.INC  */

BOMB$IF:
	PROCEDURE (STATUS) EXTERNAL;
    DECLARE STATUS ADDRESS;
    END
BOMB$IF;

REPORT$SYNTAX$ERROR:
	PROCEDURE EXTERNAL;
	END
REPORT$SYNTAX$ERROR;

REPORT$ISIS$ERROR:
	PROCEDURE (STATUS) EXTERNAL;
	DECLARE STATUS ADDRESS;
	END
REPORT$ISIS$ERROR;

REPORT$ASSERTION$SUCCESS:
	PROCEDURE EXTERNAL;
	END
REPORT$ASSERTION$SUCCESS;

REPORT$ASSERTION$FAILURE:
	PROCEDURE EXTERNAL;
	END
REPORT$ASSERTION$FAILURE;

REPORT$ASSERTION$FAILURE$W$ISIS$ERR:
	PROCEDURE (STATUS) EXTERNAL;
	DECLARE STATUS ADDRESS;
    END
REPORT$ASSERTION$FAILURE$W$ISIS$ERR;

REPORT$ASSERTION$FAILURE$W$MSG:
	PROCEDURE (OLD$STYLE$MSG$PTR) EXTERNAL;
	DECLARE OLD$STYLE$MSG$PTR ADDRESS;
    END
REPORT$ASSERTION$FAILURE$W$MSG;

MSG$LENGTH:
	PROCEDURE (OLD$STYLE$MSG$PTR) BYTE EXTERNAL;
    DECLARE OLD$STYLE$MSG$PTR ADDRESS;
	END
MSG$LENGTH;

/*	END REPORT.INC  */
$ LIST
$ NOLIST

/*	FUNC.INC  */

FILE$EXISTS:
	PROCEDURE EXTERNAL;
	END
FILE$EXISTS;

FILE$ABSENT:
	PROCEDURE EXTERNAL;
	END
FILE$ABSENT;

FILES$MATCH:
	PROCEDURE EXTERNAL;
    END
FILES$MATCH;

STRING$FOUND:
	PROCEDURE EXTERNAL;
	END
STRING$FOUND;

STRING$ABSENT:
	PROCEDURE EXTERNAL;
	END
STRING$ABSENT;

/*	END FUNC.INC  */
$ LIST

$ EJECT

/************************************************************/
/*															*/
/*                    GENERAL    NOTES                      */
/*															*/
/************************************************************/

/*

1.	The variable "actual" has been locally redefined in this module.

2.	The procedure used to check isis status in this module is "bomb if"
	because Passif cannot make a reasonable failed assertion entry
	if it can't even read the command tail.

3.	The variable string$mode affects the functioning of the next$char
	procedure.  If string$mode is false, then next$char will handle
	ampersands, and strip out comments;  otherwise, their characters
	will be passed along.

4.	If the token "DEBUG" appears as the first token in the command
	line, it is stripped out here.

*/

/************************************************************/
/*															*/
/*                    DESIGN     NOTES                      */
/*															*/
/************************************************************

	This tokenizer has a very hierarchical design

	The procedure next$char quality assures characters for both
the "token stuffing" procedures, and for the delimiter processing
procedures.

	The procedure "bad$char" makes sure that a character is printable
before passing it on.

    Since next$char is a procedure which advances the buffer pointer before it
performs it checking, said checking would not ordinarily performed on the
first character in the buffer, except that the first character looked at will
be a dummy blank.

                             END OF DESIGN NOTES
*/

$ EJECT

/************************************************************/
/*															*/
/*                    GLOBAL VARIABLES                      */
/*															*/
/************************************************************/

DECLARE
    BIGGER$BUF (131) BYTE DATA (BLANK),
    LOCAL$BUF (130) BYTE AT (.BIGGER$BUF(1)),
	BUF$PTR ADDRESS,
	CHAR BASED BUF$PTR BYTE;

DECLARE FIRST$TOKEN$REQUESTED BOOLEAN INITIAL (TRUE);
DECLARE STRING$MODE BOOLEAN INITIAL (FALSE);

DECLARE PROMPT STRING ('**');

DECLARE DEBUG$STG STRING (5,'DEBUG');

/************************************************************/
/*															*/
/*                     LITERALLY'S                          */
/*															*/
/************************************************************/

DECLARE MAXIMUM$PHYSICAL$LINE$LENGTH			AS			'122';
DECLARE INVALID$COMMAND$SYNTAX					AS			'203';
DECLARE UP$ARROW								AS			'''^''';
DECLARE NO$ERROR$DETECTED						AS			'0';
DECLARE TILDE									AS			'07EH';
DECLARE RUB$OUT									AS			'07FH';
DECLARE QUOTE									AS			'''"''';

$ EJECT

/************************************************************/
/*															*/
/*                    PUBLIC PROCEDURES                     */
/*															*/
/************************************************************/

FORCUP:
    PROCEDURE (CHAR$PTR) PUBLIC;
    DECLARE CHAR$PTR ADDRESS,
            CHAR BASED CHAR$PTR BYTE;
    IF CHAR>='a' AND CHAR<='z' THEN
        CHAR = CHAR - 20H;
    ENDIF
    END
FORCUP;

GET$ARGUMENT:
	PROCEDURE (USER$BUF$PTR,STATUS$PTR) BYTE PUBLIC;
	DECLARE USER$BUF$PTR ADDRESS;
	DECLARE STATUS$PTR ADDRESS,
			STAT BASED STATUS$PTR BYTE;

	DECLARE USER$BUF BASED USER$BUF$PTR (100) BYTE;
	DECLARE TOKEN$LENGTH BASED USER$BUF$PTR BYTE;

    DECLARE ACTUAL ADDRESS;
	DECLARE RETURNEE BYTE;

	/*	We use a different variable for status information, in this
		procedure, than elsewhere, since this procedure is allowed to
		set the other status variable. */
    DECLARE LOCAL$STATUS ADDRESS;

$ EJECT

    /************************************************************/
    /*															*/
    /*             PROCEDURES LOCAL TO GET$ARGUMENT             */
    /*															*/
    /************************************************************/

    STUFF$CHAR:
    	PROCEDURE;
		USER$BUF(TOKEN$LENGTH+1) = CHAR;
    	TOKEN$LENGTH = TOKEN$LENGTH + 1;
        END
    STUFF$CHAR;

    REFRESH$CI$BUF:
        PROCEDURE;
        CALL READ
          (CONSOLE$INPUT,.LOCAL$BUF,SIZE(LOCAL$BUF),.ACTUAL,.LOCAL$STATUS);
        CALL BOMB$IF(LOCAL$STATUS);
        BUF$PTR = .BIGGER$BUF(0);
        END
    REFRESH$CI$BUF;

    OVER$ALL$INITIALIZATION:
    	PROCEDURE;
        /*	Get$argument starts at the very beginning of the command line
            to be compatible with the UDI convention. */
        CALL RESCAN(CONSOLE$INPUT,.STATUS); BI;
        CALL REFRESH$CI$BUF;
        END
    OVER$ALL$INITIALIZATION;

    INITIALIZE$FOR$THIS$TOKEN:
    	PROCEDURE;
        /*	Initialize the data fields returned to the user, in case
            get$argument has to return "unexpectedly". */
        TOKEN$LENGTH = 0;
        RETURNEE = HASH$MARK;
        STAT = NO$ERROR$DETECTED;
        END
    INITIALIZE$FOR$THIS$TOKEN;

	BLANK$OR$TAB:
		PROCEDURE (A$CHAR) BOOLEAN;
		DECLARE A$CHAR BYTE;

		IF A$CHAR=BLANK OR A$CHAR=TAB THEN
			RETURN TRUE;
    	ELSE
    		RETURN FALSE;
    	ENDIF
    	END
    BLANK$OR$TAB;

    NEXT$CHAR:
    	PROCEDURE;

        /*	This procedure detects some error conditions. The possible
        	error conditions detectable in string mode are

        	1.	carriage return encountered
        	2.	physical line too long

        	The possible error conditions in token mode are

        	1.	line too long
        	2.	illegal character (e.g., escape)

			If an error is detected, then the errant character is
			overwritten by a carriage return, and status is set to
			isis error 203, which is defined as "invalid command syntax".

            After encountering an illegal character, or error condition, the
            user should be able to get the remaining tokens on the line.
            The rest of this code expects that buf$ptr will be
            pointing to the start of the next token.  This function is
            correctly handled for the case of carriage return, whether
            or not an error state exists, by the set$delimiter procedure.

            Next$char will change all lowercase characters to uppercase,
            unless string$mode is true.  */

$ EJECT

        /************************************************************/
        /*															*/
        /*             PROCEDURES LOCAL TO NEXT$CHAR                */
        /*															*/
        /************************************************************/

        NEXT$CHAR$ERROR$CONDITION:
        	PROCEDURE;
            CHAR = HASH$MARK;
            STAT = INVALID$COMMAND$SYNTAX;
            END
        NEXT$CHAR$ERROR$CONDITION;

		BAD$CHAR:
			PROCEDURE BOOLEAN;

			RETURN (CHAR>=0 AND CHAR<=19H AND (NOT (CHAR=CR OR CHAR=TAB)))
							OR
            		CHAR = UP$ARROW
            				OR
            		CHAR > 07FH;
			END
        BAD$CHAR;

$ EJECT

        /************************************************************/
        /*															*/
        /*             FIRST EXECUTABLE IN NEXT$CHAR                */
        /*															*/
        /************************************************************/

        BUF$PTR = BUF$PTR + 1;

		/*	Check all possible error condtions, as specified in the
			comment above. */

		/*	First check for line too long. This error condition applies
			in both string mode and token mode. */

    check$current$character:
        IF BUF$PTR > .LOCAL$BUF(MAXIMUM$PHYSICAL$LINE$LENGTH) THEN
            /*	This is the "line too long" condition. */
        	CALL NEXT$CHAR$ERROR$CONDITION;
        ELSE IF STRING$MODE THEN
            DO;
               /*	Now, check for carriage-return encountered in string
                    mode. */
                IF CHAR = CR THEN
                    DO;
                    	STAT = INVALID$COMMAND$SYNTAX;
                    ENDDO;
                ENDIF
            ENDDO;
        ELSE
        	DO;
        		/*	Check for the illegal character error condition. */
        		IF BAD$CHAR THEN
        			CALL NEXT$CHAR$ERROR$CONDITION;
        		ELSE
        			DO;
						/*	Now, we can finally check for the non-error
							conditions which require special handling:
							ampersands, and comments. */
                        IF CHAR=AMPERSAND THEN
                        	DO;
                        		CALL WRITE(CONSOLE$OUTPUT,
                                           .PROMPT
                                           ,SIZE(PROMPT),
                                           .LOCAL$STATUS);
                        		CALL REFRESH$CI$BUF;
                                CALL BOMB$IF(LOCAL$STATUS);
                                GOTO check$current$character;
                            ENDDO;
                        ELSE IF CHAR=SEMICOLON THEN
                        	DO;
								/*	the line is terminated by the
									detection of this comment. */
                                CHAR = CR;
                        	ENDDO;
                        ENDIF
        			ENDDO;
                ENDIF
            ENDDO;
        ENDIF

		IF NOT STRING$MODE THEN
			CALL FORCUP(BUF$PTR);
        ENDIF

        END
    NEXT$CHAR;

	SKIP$CHAFF:
		PROCEDURE;
		DO WHILE BLANK$OR$TAB(CHAR);
			CALL NEXT$CHAR;
        END$DO$WHILE;
    	END
    SKIP$CHAFF;

$ EJECT

    /************************************************************/
    /*															*/
    /*                     TOKEN$DELIMITER                      */
    /*															*/
    /************************************************************/

    TOKEN$DELIMITER:
    	PROCEDURE (A$CHAR) BOOLEAN;
		DECLARE A$CHAR BYTE;

        EXPRESSION$1:
            PROCEDURE BOOLEAN;

            RETURN
                (A$CHAR>=0 AND A$CHAR<=20H)  OR
                (A$CHAR = ',')				OR
                (A$CHAR = ')')				OR
                (A$CHAR = '(')				OR
                (A$CHAR = '=')				OR
                (A$CHAR = '#')				OR
                (A$CHAR = '!')				OR
                (A$CHAR = '$')				OR
                (A$CHAR = '%')				OR
                (A$CHAR = '''')				OR
                (A$CHAR = '\');
            END
        EXPRESSION$1;

        EXPRESSION$2:
        	PROCEDURE BOOLEAN;

            RETURN
                (A$CHAR = TILDE)			OR
                (A$CHAR = '+')				OR
                (A$CHAR = '-')				OR
                (A$CHAR = '&')				OR
                (A$CHAR = '|')				OR
                (A$CHAR = ']')				OR
                (A$CHAR = '[')				OR
                (A$CHAR = '>')				OR
                (A$CHAR = '<')				OR
                (A$CHAR = ';')				OR
                (A$CHAR = RUBOUT);
    		END
        EXPRESSION$2;

        RETURN EXPRESSION$1 OR EXPRESSION$2;

        END
    TOKEN$DELIMITER;

$ EJECT

    SET$DELIMITER:
    	PROCEDURE;

		/*	This procedure expects char to be pointing to the first
			character following the token.  This procedure processes
			the strings of consecutive delimiters, as specified by
			UDI;  i.e., strings of blanks and tabs followed a fresh
			token become a single blank, but strings of blanks and
			tabs followed by one of the other delimiters are
			thrown away.

			If the "true" or "final" (after the chaff has been skipped)
            delimiter is anything besides a carriage return, then
            set$delimiter will advance buf$ptr to the next token.  */

        CALL SKIP$CHAFF;
        IF TOKEN$DELIMITER(CHAR) THEN
        	DO;
        		RETURNEE = CHAR;
        		IF NOT CHAR=CR THEN
        			CALL NEXT$CHAR;
            	ENDIF
            ENDDO;
        ELSE
        	RETURNEE = BLANK;
        ENDIF
        END
    SET$DELIMITER;

$ EJECT

    /************************************************************/
    /*															*/
    /*                  HANDLE$QUOTED$STRING                    */
    /*															*/
    /************************************************************/

    HANDLE$QUOTED$STRING:
        PROCEDURE;

        loop$begin:
        CALL NEXT$CHAR;
        IF CHAR = CR THEN
        	DO;
        		/*	Carriage-return will terminate a string.
        			Prepare to return. */
                CALL STUFF$CHAR;
        		RETURN;
            ENDDO;
        ELSE IF CHAR=QUOTE THEN
        	DO;
                /*	Check for double quotes.  If there are double
                	quotes then pass on a single quote.  If the
                	quote is only a single quote, then do not pass it
                	on, but terminate the string. */
    			CALL NEXT$CHAR;
				IF CHAR=QUOTE THEN
					/*	Pass on a single quote to stand for the double
						quotes. */
                    DO;
                    	CALL STUFF$CHAR;
                        GOTO loop$begin;
                	ENDDO;
                ELSE
                	/*	The previous quote has terminated the string. */
                    RETURN;
                ENDIF
            ENDDO;
        ELSE
        	DO;
				/*	The current character can have no interest to those
					procedures interested in terminating the string. */
                CALL STUFF$CHAR;
        		GOTO loop$begin;
            ENDDO;
        ENDIF
        END
    HANDLE$QUOTED$STRING;

$ EJECT

    /************************************************************/
    /*															*/
    /*                       STUFF$TOKEN                        */
    /*															*/
    /************************************************************/

    STUFF$TOKEN:
		PROCEDURE;

		/* This procedure expects the current character to be pointing
			to a token. */

        IF CHAR=QUOTE THEN
			DO;
				STRING$MODE = TRUE;
                CALL HANDLE$QUOTED$STRING;
        		STRING$MODE = FALSE;
            ENDDO;
        ELSE
            DO WHILE NOT TOKEN$DELIMITER(CHAR);
                CALL STUFF$CHAR;
                CALL NEXT$CHAR;
            END$DO$WHILE;
		END$IF
        END
    STUFF$TOKEN;

    TOKEN$TOO$LONG:
    	PROCEDURE BYTE;
		RETURN TOKEN$LENGTH > MAXIMUM$TOKEN$LENGTH;
    	END
    TOKEN$TOO$LONG;

	CORRECT$TOKEN$LENGTH:
		PROCEDURE;
		DECLARE CORRECTION$FACTOR BYTE;
		CORRECTION$FACTOR = TOKEN$LENGTH - MAXIMUM$TOKEN$LENGTH;
		BUF$PTR = BUF$PTR - CORRECTION$FACTOR;
		TOKEN$LENGTH = TOKEN$LENGTH - CORRECTION$FACTOR;
        END
    CORRECT$TOKEN$LENGTH;

$ EJECT

    /************************************************************/
    /*															*/
    /*      FIRST EXECUTABLE CODE IN PROCEDURE GET$ARGUMENT     */
    /*															*/
    /************************************************************/

	IF FIRST$TOKEN$REQUESTED THEN
		CALL OVER$ALL$INITIALIZATION;
    ENDIF

	CALL INITIALIZE$FOR$THIS$TOKEN;

	begin$loop:
    CALL SKIP$CHAFF;
    CALL STUFF$TOKEN;

    IF FIRST$TOKEN$REQUESTED THEN
        DO;
        	FIRST$TOKEN$REQUESTED = FALSE;
            IF UDI$STRING$MATCH(.DEBUG$STG(0),.USER$BUF(0)) THEN
                DO;
                    TOKEN$LENGTH = 0;
                    GOTO begin$loop;
                ENDDO;
            ENDIF
        ENDDO;
    ENDIF

    IF TOKEN$TOO$LONG THEN
    	DO;
			CALL CORRECT$TOKEN$LENGTH;
            STAT = INVALID$COMMAND$SYNTAX;
            RETURN BLANK;
    	ENDDO;
    ENDIF

    CALL SET$DELIMITER;
    RETURN RETURNEE;

    END
GET$ARGUMENT;

END
TOKENS$MOD;
src/unpack.plm
Unpack:   DO;


/************************************************************************/
/*																		*/
/*      '(C) Intel Corporation 1981'.  All rights reserved.  No			*/
/*      part of this program or publication may be reproduced,			*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

      
DECLARE COPYRIGHT (*) BYTE DATA ('(C) INTEL CORP 1981');

DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.0',0);
    


/*    This program is designed to accept packed files and decompress
      the blanks back to their original forms

      Blanks are decompressed by converting bytes with the high bit
      on into a string of blanks whose length is the lower
      seven bits of the byte.  All other characters are passed
      through without alteration.

*/

DECLARE dcl LITERALLY 'DECLARE';
DECLARE as LITERALLY 'LITERALLY';

dcl boolean as 'BYTE';
dcl depart as '0FFH';
dcl true as '0FFH';
dcl false as '0';
dcl character as 'BYTE';
dcl pointer as 'ADDRESS';
dcl int1 as 'BYTE';
dcl int2 as 'ADDRESS';
dcl nil as '0';

dcl thenn as 'THEN DO;';
dcl elseif as 'END; ELSE IF';
dcl elsee as 'END; ELSE DO;';
dcl endif as 'END;';
dcl whilee as 'DO WHILE';
dcl endwhile as 'END;';
dcl for as 'DO';
dcl endfor as 'END;';
dcl enddo as 'END;';

dcl cr as '0DH';
dcl lf as '0AH';

/* system EXTERNALs */

open:
  PROCEDURE (aft,file,access,mode,status) EXTERNAL;
    DECLARE (aft,file,access,mode,status) ADDRESS;

  END open;

close:
  PROCEDURE (aft,status) EXTERNAL;
    DECLARE (aft,status) ADDRESS;

  END close;

read:
  PROCEDURE (aft,buffer,count,actual,status) EXTERNAL;
    DECLARE (aft,buffer,count,actual,status) ADDRESS;

  END read;

write:
  PROCEDURE (aft,buffer,count,status) EXTERNAL;
    DECLARE (aft,buffer,count,status) ADDRESS;

  END write;

delete:
  PROCEDURE (file,status) EXTERNAL;
    DECLARE (file,status) ADDRESS;

  END delete;

exit:
  PROCEDURE EXTERNAL;

  END exit;

seq:
  PROCEDURE (s1,s2,len) boolean EXTERNAL;
    DECLARE s1 ADDRESS;
    DECLARE s2 ADDRESS;
    DECLARE len BYTE;

  END seq;

force$upper:
  PROCEDURE (buffer$ptr) EXTERNAL;
    DECLARE buffer$ptr ADDRESS;

  END force$upper;

file$error:
  PROCEDURE (status, filename$ptr, callexit) EXTERNAL;
    DECLARE (status, filename$ptr) ADDRESS;
    DECLARE callexit boolean;
  END file$error;

dcl disk$type BYTE PUBLIC; /* needed by dmeq */

dmeq:
  PROCEDURE (dir$aftn, search$arg, initial$i$no, dir$entry) ADDRESS EXTERNAL;
    DECLARE (dir$aftn, search$arg, initial$i$no, dir$entry) ADDRESS;
  END dmeq;

spath:
  PROCEDURE(file, buffer, status) EXTERNAL;
    DECLARE (file, buffer, status) ADDRESS;
  END spath;

wpath:
  PROCEDURE(pathname$ptr, pn, wc$used) BYTE EXTERNAL;
    DECLARE (pathname$ptr, pn, wc$used) ADDRESS;
  END wpath;

unpath:
  PROCEDURE(int, ext) EXTERNAL;
    DECLARE (int, ext) ADDRESS;
  END unpath;

unpacker: PROCEDURE boolean external;
end unpacker;

dcl version(4) character data('V1.0');
dcl (actual,status) int2;
dcl out$aftn int2 PUBLIC;
dcl in$aftn int2 PUBLIC;
dcl command$line(120) character;
dcl command$pointer pointer;
dcl command$char based command$pointer character;
dcl delete$source boolean;
dcl default$output boolean;
dcl default$extension(3) character initial('PCK');
dcl input$file$name(16) character PUBLIC;
dcl output$file$name(16) character PUBLIC;
dcl input$name pointer PUBLIC;
dcl output$name pointer PUBLIC;
dcl in$name pointer;
dcl out$name pointer;
dcl no$error$occured boolean;

dcl directory$name(16) character initial(':F0:ISIS.DIR ');
dcl dir$aftn int2;
dcl path$name(16) character;
dcl out$path$name(16) character;
dcl max$directory$length int2;
dcl file$found boolean;
dcl wildcard$used boolean;
dcl directory$entry int2;
dcl source$disk int1;
dcl buf16(16) character;
dcl found boolean;
dcl no$such$file as '13';
dcl star$dot$LST(16) character initial(0,'******LST      ');

deblank: PROCEDURE( char$ref ) pointer;
   /* scan for next non-blank */
   dcl char$ref pointer;
   dcl char BASED char$ref character;

   whilee char = ' ';
      char$ref = char$ref + 1;
   endwhile
   RETURN char$ref;
end deblank;

scan$blank: PROCEDURE( char$ref ) pointer;
   /* scan for a blank character */
   dcl char$ref pointer;
   dcl char BASED char$ref character;

   whilee char <> ' ' and char <> cr;
      char$ref = char$ref + 1;
   endwhile
   RETURN char$ref;
end scan$blank;

command$tail$error: PROCEDURE;
  CALL write(0,.command$line,command$pointer-.command$line,.status);
  CALL write(0,.('#'),1,.status);
  CALL write(0,command$pointer,actual-(command$pointer-.command$line),.status);
  CALL write(0,.('command tail error',cr,lf),20,.status);
  CALL exit;
END command$tail$error;

more$input$files: PROCEDURE boolean;

   /****************************************************************************
    *
    * This routine sets up the global input$file$name with the next file
    * which matches the wildcard pathname and returns true.  If no
    * more matching file names are found, false is returned.
    *
    ****************************************************************************/

   directory$entry = dmeq(diraftn, .pathname, directory$entry, .buf16);
   if directory$entry >= max$directory$length + 1 thenn
      RETURN false;
   elsee
      found = true;
      buf16(0) = source$disk;
      CALL move(15,.('                '),.input$filename);
      CALL unpath(.buf16, .input$file$name);
      RETURN true;
   endif
end more$input$files;

generate$default$output$filename: PROCEDURE;

   /****************************************************************************
    *
    * This procedure generates the default output$filename by changing
    * the input$filename extension to .PCK if no output filename was
    * specified.  If a name was specified (with wildcard) then the
    * appropriate replacements are made.
    *
    ****************************************************************************/

   dcl i int1;
   dcl internal$name(16) character;

   CALL move(15, .('               '), .output$filename);
   CALL move(15, .out$path$name, .internal$name);
   for i = 1 to 14;
      if out$path$name(i) = '*' or out$path$name(i) = '?' thenn
         internal$name(i) = buf16(i);
      endif
   endfor
   CALL unpath(.internal$name, .output$filename);
end generate$default$output$filename;

/*
     initialize values and open files
*/
   CALL write(0,.('ISIS-II  BLANK DECOMPRESSOR, '),29,.status);
   CALL write(0,.version,4,.status);
   CALL write(0,.(cr,lf),2,.status);

   CALL read(1,.command$line,120,.actual,.status);
   CALL force$upper(.command$line);
   command$pointer = deblank(.command$line);
   in$name = command$pointer;
   wildcard$used = true;
   status = wpath(in$name,.path$name,.wild$card$used);
   CALL file$error(status, in$name, true);

   output$name = .output$file$name;
   CALL move (15, .('               '), .output$filename);
   command$pointer = deblank(scan$blank(command$pointer));
   out$name = nil;
   if seq(command$pointer,.('TO '),3) thenn
      out$name, command$pointer=deblank(scan$blank(command$pointer));
      command$pointer = deblank(scan$blank(command$pointer));
      CALL move(command$pointer - out$name, out$name, .output$filename);
   endif
   default$output = true;
   if out$name <> nil thenn
      wildcard$used = true;
      status = wpath(out$name, .out$path$name, .wildcard$used);
      CALL file$error(status, out$name, true);
      if not wildcard$used thenn
         default$output = false;
      endif
   elsee
      /* generate template for :F#:*.LST for output */
      CALL move(15, .star$dot$LST, .out$path$name);
      out$path$name(0) = pathname(0);
   endif

   delete$source = true;
   if seq(command$pointer, .('DELETE'),6) thenn
      delete$source = true;
      command$pointer = deblank(scan$blank(command$pointer));
   elseif seq(command$pointer, .('NODELETE'),8) thenn
      delete$source = false;
      command$pointer = deblank(scan$blank(command$pointer));
   endif
   if command$char <> cr then call command$tail$error;

   /* setup wild card search */
   directory$name(2) = (source$disk := path$name(0)) + '0';
   path$name(0) = 0;
   CALL spath(.directory$name, .buf16, .status);
   CALL file$error(status, .directory$name, true);
   disk$type = buf16(11);
   if disk$type = 4 thenn
      max$directory$length = 992;
   elsee
      max$directory$length = 200;
   endif
   found = false;
   directory$entry = 0;
   CALL open(.diraftn, .directory$name, 1, 0, .status);
   CALL file$error(status, .directory$name, true);

   if not default$output thenn
      CALL open(.outaftn,output$name,2,0,.status);
      CALL file$error(status,output$name,true);
   endif

   input$name = .input$filename;
   whilee more$input$files;
      no$error$occured = true;
      CALL open(.inaftn,input$name,1,0,.status);
      CALL file$error(status,input$name,false);
      if status <> 0 thenn
         no$error$occured = false;
      endif
      if default$output and no$error$occured thenn
         CALL generate$default$output$filename;
         CALL open(.outaftn,output$name,2,0,.status);
         CALL file$error(status,output$name,false);
         if status <> 0 thenn
            no$error$occured = false;
            CALL close(inaftn, .status);
            CALL file$error(status, input$name, false);
         endif
      endif
      if no$error$occured thenn
         CALL write(0,.('  '),2,.status);
         CALL write(0,input$name,15,.status);
         CALL write(0,.(' TO '),4,.status);
         CALL write(0,output$name,15,.status);
         no$error$occured = not unpacker;
         if no$error$occured thenn
            CALL write(0,.(' UNPACKED '),10,.status);
         elsee
            CALL write(0,.(' ERROR    '),10,.status);
         endif

         if default$output thenn
            CALL close(outaftn,.status);
            CALL file$error(status,output$name,false);
         endif

         CALL close(inaftn, .status);
         CALL file$error(status, input$name, false);

         if delete$source and no$error$occured thenn
            CALL delete(input$name, .status);
            CALL file$error(status, input$name, false);
            CALL write(0,.(' DELETED'),8,.status);
         endif
         CALL write(0,.(cr,lf),2,.status);

      endif
   endwhile
   CALL close(dir$aftn, .status);
   CALL file$error(status, .directory$name, true);
   if not found thenn
      CALL file$error(no$such$file, in$name, true);
   endif
   CALL exit;
end Unpack;
src/unpakr.plm
Unpacker:   DO;


/************************************************************************/
/*																		*/
/*      '(C) Intel Corporation 1981'.  All rights reserved.  No			*/
/*      part of this program or publication may be reproduced,			*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

      
/*
      This routine is the logical opposite of the program pack
      this routine accepts as input a file containing the
      compression bytes produced by pack, reexpands them
      and outputs the result.

      The compression bytes are bytes which have the sign bit
      on which implies that parity must not be used by the
      system.  This byte is the negation of the number of
      blanks which have been compressed.

*/

/*
      symbolic definitions
*/

   DECLARE dcl LITERALLY 'DECLARE';
   DECLARE as LITERALLY 'LITERALLY';

   dcl true as '0FFH';
   dcl false as '0';
   dcl boolean as 'BYTE';
   dcl int1 as 'BYTE';
   dcl int2 as 'ADDRESS';
   dcl pointer as 'ADDRESS';
   dcl character as 'BYTE';
   dcl nil as '0';

   dcl thenn as 'THEN DO;';
   dcl elseif as 'END; ELSE IF';
   dcl elsee as 'END; ELSE DO;';
   dcl endif as 'END;';
   dcl for as 'DO';
   dcl endfor as 'END;';
   dcl whilee as 'DO WHILE';
   dcl endwhile as 'END;';

   dcl until literally 'while not';
   dcl end$of$file literally 'actual=0';
   dcl buffer$size literally '20480';
   dcl limit literally 'buffer$size-1';
   dcl compress$1 literally '81h';

read: PROCEDURE (aft,buffer,count,actual,status) EXTERNAL;
    DECLARE (aft,buffer,count,actual,status) ADDRESS;

  END read;

write: PROCEDURE (aft,buffer,count,status) EXTERNAL;
    DECLARE (aft,buffer,count,status) ADDRESS;

  END write;

file$error: PROCEDURE(status,ptr,callexit) EXTERNAL;
    DECLARE (status,ptr) ADDRESS;
    DECLARE callexit BOOLEAN;

  end file$error;

/*
      declarations
*/
   dcl output$buffer(buffer$size) byte;
   dcl input$buffer(buffer$size) byte;
   dcl output$pointer address;
   dcl output$character based output$pointer byte;
   dcl input$pointer address;
   dcl input$character based input$pointer byte;
   dcl status address;
   dcl actual address;
   dcl outaftn address EXTERNAL;
   dcl inaftn address EXTERNAL;
   dcl (input$name, output$name) address EXTERNAL;
   dcl compress boolean;
   dcl compression$byte byte;
   dcl (i,j) address;

output: PROCEDURE(put$char) boolean;

/*
      this procedure accepts a character and fills a buffer
      when the buffer is full, it is then written to the
      output file.
*/

   dcl put$char character;

   output$character=put$char;
   output$pointer=output$pointer+1;
   if output$pointer > .output$buffer+limit thenn
      call write(outaftn,.output$buffer,buffer$size,.status);
      call file$error(status,output$name,false);
      if status <> 0 thenn
         RETURN false;
      endif
      output$pointer=.output$buffer;
   endif
   RETURN true;
END output;

flush: PROCEDURE;
/*
      this routine flushes the output buffer at the end of the program
*/

   if output$pointer = .output$buffer thenn
      RETURN;
   endif
   call write(outaftn,.output$buffer,output$pointer-.output$buffer,
      .status);
   call file$error(status,output$name,false);
END flush;

unpacker: PROCEDURE boolean PUBLIC;

/*
     initialize values
*/

   output$pointer=.output$buffer;
   input$pointer=.input$buffer;
   compress=false;

/*
        begin processing
*/

   call read(inaftn,.input$buffer,buffer$size,.actual,.status);
   call file$error(status,input$name,false);
   if status <> 0 thenn
      RETURN true;
   endif

   whilee not end$of$file;

      for i = 0 to actual-1;

         if input$character > 127 thenn
            /* expand blanks */
            for j = 1 to -input$character;
               if not output(' ') thenn
                  RETURN true;
               endif
            endfor
         elsee
            if not output(input$character) thenn
               RETURN true;
            endif
         endif

         input$pointer=input$pointer+1;
      endfor

      call read(inaftn,.input$buffer,buffer$size,.actual,.status);
      call file$error(status,input$name,false);
      if status <> 0 thenn
         RETURN true;
      endif
      input$pointer=.input$buffer;
   endfor

   call flush;
   RETURN false;

END unpacker;

END Unpacker;
src/upper.plm
UPPER: DO;


/************************************************************************/
/*																		*/
/*      '(C) Intel Corporation 1981'.  All rights reserved.  No			*/
/*      part of this program or publication may be reproduced,			*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

      
DECLARE COPYRIGHT (*) BYTE DATA ('(C) INTEL CORP 1981');

DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.0',0);
    


$NOLIST
/* PEX */
DECLARE SCANP ADDRESS EXTERNAL;
DECLARE SCANBYTE BASED SCANP BYTE;
FORCUP :PROCEDURE BYTE EXTERNAL;END;
MIN :PROCEDURE (ZZ1,ZZ2)ADDRESS EXTERNAL;DECLARE (ZZ1,ZZ2)ADDRESS;END;
DECLARE FATAL BYTE EXTERNAL;
DECLARE ACTUAL ADDRESS EXTERNAL;
EX :PROCEDURE  EXTERNAL;END;
MEMCK :PROCEDURE ADDRESS EXTERNAL;END;
OPENU :PROCEDURE (ZZ1) EXTERNAL;DECLARE (ZZ1)ADDRESS;END;
READC :PROCEDURE (ZZ1,ZZ2) EXTERNAL;DECLARE (ZZ1,ZZ2)ADDRESS;END;
READU :PROCEDURE (ZZ1,ZZ2) EXTERNAL;DECLARE (ZZ1,ZZ2)ADDRESS;END;
SBYTEU :PROCEDURE (ZZ1) EXTERNAL;DECLARE (ZZ1)ADDRESS;END;
WRITEU :PROCEDURE (ZZ1,ZZ2) EXTERNAL;DECLARE (ZZ1,ZZ2)ADDRESS;END;
DECLARE FOREVER LITERALLY'WHILE 1';
DECLARE TRUE LITERALLY'255';
/* ENDPEX */
$LIST

DECLARE CAPACITY ADDRESS;
CAPACITY = MIN(32512,MEMCK-.MEMORY);
FATAL = TRUE;
CALL READC(.MEMORY,100);
CALL OPENU(.MEMORY);
DO FOREVER;
 CALL READU(.MEMORY,CAPACITY);
 IF ACTUAL = 0 THEN CALL EX;
 SCAN$P = .MEMORY;
  DO WHILE SCAN$P < .MEMORY + ACTUAL;
   SCAN$BYTE = FORCUP;
   SCAN$P = SCAN$P + 1;
  END;
 CALL SBYTEU(-ACTUAL);
 CALL WRITEU(.MEMORY,ACTUAL);
END;

END UPPER;
src/wait.plm
WAIT$MOD: DO;

/************************************************************************/
/*																		*/
/*      '(C) Intel Corporation 1981'.  All rights reserved.  No			*/
/*      part of this program or publication may be reproduced,			*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

DECLARE COPYRIGHT (*) BYTE DATA ('(C) INTEL CORP 1981');

DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.0',0);

DECLARE	LIT		LITERALLY	'LITERALLY',
		DCL		LIT	'DECLARE',
		TRUE	LIT	'0FFH',
		FALSE	LIT	'000H',
		PROC	LIT	'PROCEDURE',
		PROCEND	LIT	'END',
		THENDO	LIT	'THEN DO;',
		ELSEIF	LIT	'END; ELSE IF',
		ELSEDO	LIT	'END; ELSE DO;',
		IFEND	LIT	'END',
		WHILEND	LIT	'END',
		CR		LIT	'0DH',
		LF		LIT	'0AH';

EXIT:	PROC EXTERNAL;											PROCEND;
RESCAN:	PROC (A,B) EXTERNAL;		DCL (A,B) ADDRESS;			PROCEND;
READ:	PROC (A,B,C,D,E) EXTERNAL;	DCL (A,B,C,D,E) ADDRESS;	PROCEND;
WRITE:	PROC (A,B,C,D) EXTERNAL;	DCL (A,B,C,D) ADDRESS;		PROCEND;
SPATH:	PROC (A,B,C) EXTERNAL;		DCL (A,B,C) ADDRESS;		PROCEND;
CONSOL:	PROC (A,B,C) EXTERNAL;		DCL (A,B,C) ADDRESS;		PROCEND;
WHOCON:	PROC (A,B) EXTERNAL;		DCL (A,B) ADDRESS;			PROCEND;
IOCHK:	PROC BYTE EXTERNAL;										PROCEND;
CSTS:	PROC BYTE EXTERNAL;										PROCEND;
CI:		PROC BYTE EXTERNAL;										PROCEND;
CO:		PROC (A) EXTERNAL;			DCL (A) BYTE;				PROCEND;

DCL (STATUS, ACTUAL) ADDRESS;
DCL (CMND, CMND$PTR) ADDRESS, (CMND$CH BASED CMND$PTR) (1) BYTE;
DCL (FILE1, FILE2) (15) BYTE;
DCL (PN) STRUCTURE
	(DEV BYTE, NAME (6) BYTE, EXT (3) BYTE, DEV$TYPE BYTE, DRIVE$TYPE BYTE);
DCL (COLD$START$CO) BYTE;
DCL (CH) BYTE;

CALL RESCAN (1, .STATUS);
CALL READ (1, .MEMORY, 128, .ACTUAL, .STATUS); /* Get command tail. */
CMND = .MEMORY + ACTUAL;
CMND$PTR = .MEMORY;
DO WHILE CMND$PTR < CMND;
	IF CMND$CH (0) = '&' THENDO
		CMND$CH (1) = CR;
		CMND$CH (2) = LF;
		CALL WRITE (0, .('**'), 2, .STATUS);
		CALL READ (1, CMND$PTR + 3, 128, .ACTUAL, .STATUS);
		CMND = CMND$PTR + ACTUAL + 3;
	IFEND;
	CMND$PTR = CMND$PTR + 1;
WHILEND;

CALL WHOCON (0, .FILE1); /* Find out what the :CO: file is. */
CALL SPATH (.FILE1, .PN, .STATUS);
COLD$START$CO = IOCHK AND 3;
IF (PN.DEV = 7) AND (COLD$START$CO = 0) THENDO /* :CO: = :TO: */
ELSEIF (PN.DEV = 9) AND (COLD$START$CO = 1) THENDO /* :CO: = :VO: */
ELSEDO
	CMND$PTR = .MEMORY;
	DO WHILE CMND$PTR < CMND;
		CALL CO (CMND$CH (0));
		CMND$PTR = CMND$PTR + 1;
	WHILEND;
IFEND;

/* Wait for CR or Control-C. */
DO WHILE TRUE;
	CH = 198; /* Used as a temp to count the seconds here. */
	DO WHILE NOT CSTS; /* No keys hit yet, just wait. */
		CALL TIME (250);
		CH = CH + 1;
		IF CH = 199 THENDO /* Ring bell once every 5 second or so. */
			CH = 0;
			CALL CO (7);
		IFEND;
	WHILEND;
	CH = CI AND 7FH;
	IF CH = CR THENDO /* Got a CR, exit and continue. */
		CALL EXIT;
	ELSEIF CH = 03H THENDO /* Got an Control-C, abort the rest. */
		IF COLD$START$CO = 0 THENDO /* Cold start CONSOL is tty. */
			CALL MOVE (5, .(':TI: '), .FILE1);
			CALL MOVE (5, .(':TO: '), .FILE2);
			CALL CONSOL (.FILE1, .FILE2, .STATUS);
		ELSEIF COLD$START$CO = 1 THENDO /* Cold start CONSOL is crt. */
			CALL MOVE (5, .(':VI: '), .FILE1);
			CALL MOVE (5, .(':VO: '), .FILE2);
			CALL CONSOL (.FILE1, .FILE2, .STATUS);
		IFEND;
		CALL EXIT;
	IFEND;
WHILEND;

END WAIT$MOD;
src/which.plm
$ TITLE ('WHICH -- VERSION_NUMBER_SEARCHER')

WHICH$MOD:
DO;

/************************************************************************/
/*																		*/
/*      '(C) Intel Corporation 1981'.  All rights reserved.  No			*/
/*      part of this program or publication may be reproduced,			*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

DECLARE COPYRIGHT (*) BYTE DATA ('(C) INTEL CORP 1981');

DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=',1,'V1.0D',0);

/**************************************************************/
/*                 EXTERNAL  PROCEDURES                       */
/**************************************************************/

CLOSE:
	PROCEDURE (AFTN,STATUS) EXTERNAL;
	DECLARE (AFTN,STATUS) ADDRESS;
	END
CLOSE;

CO:
	PROCEDURE (CHAR$CO) EXTERNAL;
	DECLARE CHAR$CO BYTE;
	END
CO;

ERROR:
	PROCEDURE  (ERROR$NUMBER) EXTERNAL;
	DECLARE ERROR$NUMBER ADDRESS;
	END
ERROR;

EXIT:
	PROCEDURE EXTERNAL;
	END
EXIT;

OPEN:
	PROCEDURE(AFTN,FILENAME,ACCESS$MODE,LINE$EDIT$AFTN,ERROR) EXTERNAL;
	DECLARE (AFTN,FILENAME,ACCESS$MODE,LINE$EDIT$AFTN,ERROR) ADDRESS;
	END
OPEN;

READ:
	PROCEDURE (AFTN,BUFFER,COUNT,ACTUAL,STATUS) EXTERNAL;
	DECLARE (AFTN,BUFFER,COUNT,ACTUAL,STATUS) ADDRESS;
	END
READ;

WRITE:
	PROCEDURE (AFTN,BUFFER,COUNT,STATUS) EXTERNAL;
	DECLARE (AFTN,BUFFER,COUNT,STATUS) ADDRESS;
	END
WRITE;

/*************************************************************/
/*               LITERALLY  DECLARATION                      */
/*************************************************************/

DECLARE                                  LIT LITERALLY 'LITERALLY',
        BELL                             LIT '07H',               /* plm */
        BLANK                            LIT '020H',              /* plm */
        BOOLEAN                          LIT 'BYTE',              /* plm */
        CHK                              LIT 'CALL CHECK$STATUS(STATUS)', /* plm */
        CONSOLE$INPUT                    LIT '1',
        CONSOLE$OUTPUT                   LIT '0',
        CR                               LIT '0DH',               /* plm */
        CRLF                             LIT '0DH,0AH',           /* plm */
        FALSE                            LIT '0H',                /* plm */
        LF                               LIT '0AH',               /* plm */
        NO$LINE$EDIT                     LIT '0',                 /* open */
        OPEN$FOR$READ                    LIT '1',                 /* open */
        OPEN$FOR$WRITE                   LIT '2',                 /* open */
        READ$BUFFER$LENGTH               LIT '2048',              /* plm */
        SENTINEL$0                       LIT '0',
        SENTINEL$1                       LIT '1',
        SPACE                            LIT '020H',              /* plm */
        TAB                              LIT '09H',               /* plm */
        TRUE                             LIT '0FFH';              /* plm */

$EJECT

/************************************************************/
/*                GLOBAL  VARIABLE  DECLARATION             */
/************************************************************/

DECLARE STRING$TO$SEARCH (*) BYTE INITIAL
        ('program_version_number=');

DECLARE FOUND$MSG (*) BYTE INITIAL
        ('    program version number is ');

DECLARE NOT$FOUND$MSG (*) BYTE INITIAL
        ('    file does not contain a program version number', CR,LF);

DECLARE FILE$NAME (15) BYTE INITIAL (':F0:           ');
DECLARE BUFFER(READ$BUFFER$LENGTH)     BYTE;
DECLARE SUCCESSFUL$FIND  BYTE;
DECLARE END$OF$FILE      BYTE;
DECLARE STATUS ADDRESS;
DECLARE ACTUAL ADDRESS;
DECLARE AFTN$IN ADDRESS;
DECLARE I   BYTE;
DECLARE (LEN, LEN1)  ADDRESS;
DECLARE STRING$INDEX  BYTE;
DECLARE BUFFER$INDEX ADDRESS;
DECLARE BUFFER$PTR  ADDRESS;
DECLARE VERSION$MSG$LENGTH ADDRESS;
DECLARE PROGRAM$MSG$PRINTED BOOLEAN;

/********************************************************/
/*              UTILITY   PROCEDURES                    */
/********************************************************/

SKIP$BLANKS$N$TABS:  PROCEDURE (CHAR$PTR) ADDRESS  ;
     DECLARE CHAR$PTR ADDRESS;
     DECLARE CHAR BASED CHAR$PTR BYTE;

     DO WHILE (CHAR = BLANK)  OR  (CHAR = TAB);
        CHAR$PTR = CHAR$PTR + 1;
     END;

     RETURN CHAR$PTR;
END SKIP$BLANKS$N$TABS;

CHECK$STATUS:   PROCEDURE (ISIS$STATUS);
     DECLARE ISIS$STATUS ADDRESS;

     IF ISIS$STATUS <> 0  THEN
        DO;
           CALL ERROR(ISIS$STATUS);
           CALL EXIT;
        END;
END CHECK$STATUS;

STOP$EVERYTHING:  PROCEDURE(MSG$PTR);
    DECLARE MSG$PTR ADDRESS,
            MSG BASED MSG$PTR (256) BYTE;
    DECLARE MSG$LENGTH ADDRESS;

    MSG$LENGTH = 0;

    DO WHILE (MSG(MSG$LENGTH) <> 0)  AND  (MSG$LENGTH < 255);
       MSG$LENGTH = MSG$LENGTH + 1;
    END;

    CALL WRITE(CONSOLE$OUTPUT, MSG$PTR, MSG$LENGTH, .STATUS);
         CHK;
    CALL CO(BELL);
    CALL EXIT;
END STOP$EVERYTHING;

CAPITALIZE:   PROCEDURE(PTR, LEN);
      DECLARE  PTR ADDRESS,
               CHAR BASED PTR BYTE;
      DECLARE  LEN  BYTE;
      DECLARE  I    BYTE;

      DO  I = 1 TO LEN;
         IF CHAR >= 'a'  AND  CHAR <= 'z'   THEN
            CHAR = CHAR - SPACE;
         PTR = PTR + 1;
      END;
END CAPITALIZE;

ASCII$DIGIT:   PROCEDURE (CHAR) BOOLEAN;
      DECLARE  CHAR  BYTE;
      IF CHAR >= '0'  AND CHAR <= '9'  THEN
         RETURN TRUE;
      ELSE
         RETURN FALSE;
END ASCII$DIGIT;

FILE$NAME$LENGTH:   PROCEDURE(PTR)  BYTE;
     DECLARE  PTR  ADDRESS;
     DECLARE  CHAR  BASED PTR  BYTE;
     DECLARE  TMP$PTR  ADDRESS;

     TMP$PTR = PTR;
       DO WHILE         ( CHAR >= 'A'    AND   CHAR <= 'Z' )
                     OR ( ASCII$DIGIT(CHAR) )
                     OR   CHAR = '.'
                     OR   CHAR = ':'                         ;
            PTR = PTR + 1;
       END;
     TMP$PTR = PTR - TMP$PTR;
     IF TMP$PTR > 14  THEN
        DO;
           CALL ERROR(4);   /*  illegal filename specification  */
           CALL EXIT;
        END;
     RETURN  TMP$PTR;
END FILE$NAME$LENGTH;

STRING$FOUND:   PROCEDURE (BUFFER$PTR, LEN0)  BOOLEAN;
      DECLARE BUFFER$PTR ADDRESS;
      DECLARE LEN0       ADDRESS;
      DECLARE BUFFER$CHAR BASED BUFFER$PTR(256) BYTE;

      BUFFER$INDEX = 0;
      DO WHILE  BUFFER$INDEX < LEN0  AND  STRING$INDEX < LEN1;
         IF BUFFER$CHAR(BUFFER$INDEX) = STRING$TO$SEARCH(STRING$INDEX)  THEN
            STRING$INDEX = STRING$INDEX + 1;
         ELSE
            STRING$INDEX = 0;
         BUFFER$INDEX = BUFFER$INDEX + 1;
      END;

      IF STRING$INDEX >= LEN1   THEN
         RETURN TRUE;
      ELSE
         RETURN FALSE;
END STRING$FOUND;

CHECK$VERSION$NUMBER:  PROCEDURE(CHAR$PTR) ;
       DECLARE CHAR$PTR   ADDRESS,
               CHAR BASED CHAR$PTR BYTE;
       DECLARE (VERSION$TYPE$V, VERSION$TYPE$X)  BYTE;

       VERSION$TYPE$V, VERSION$TYPE$X = FALSE;
       IF CHAR = 'V'  THEN
           VERSION$TYPE$V = TRUE;
         ELSE
           IF CHAR = 'X'  THEN
               VERSION$TYPE$X = TRUE;

       IF VERSION$TYPE$V  OR  VERSION$TYPE$X  THEN
          DO;
             VERSION$MSG$LENGTH = 4;
             PROGRAM$MSG$PRINTED = TRUE;
             CHAR$PTR = CHAR$PTR + 1;
             IF ASCII$DIGIT(CHAR)   THEN
                 DO;
                    CHAR$PTR = CHAR$PTR + 1;
                    IF (CHAR = '.'  AND  VERSION$TYPE$V)  OR
                       (ASCII$DIGIT(CHAR)  AND  VERSION$TYPE$X)  THEN
                          DO;
                             CHAR$PTR = CHAR$PTR + 1;
                             IF  ASCII$DIGIT(CHAR)  THEN
                                RETURN;
                          END;
                 END;
          END;

       IF CHAR = SENTINEL$1 THEN DO;  /* LOOK FOR  1...0  COMBINATION  */
           CHAR$PTR = CHAR$PTR + 1;  /* ADVANCE BEYOND THE SENTINEL  */
           BUFFER$PTR = BUFFER$PTR + 1;  /* DON'T PRINT THE SENTINEL  */
           PROGRAM$MSG$PRINTED = FALSE;
           VERSION$MSG$LENGTH = 0;
           DO WHILE CHAR <> SENTINEL$0;  /*  DETERMINE THE MESSAGE LENGTH  */
               VERSION$MSG$LENGTH = VERSION$MSG$LENGTH + 1;
               CHAR$PTR = CHAR$PTR + 1;
               END;
           RETURN;
           END;

       SUCCESSFUL$FIND = FALSE;
       STRING$INDEX = 0;
END CHECK$VERSION$NUMBER;

/*******************************************************/
/*                MAIN  PROCEDURES                     */
/*******************************************************/

PARSE$COMMAND$TAIL:   PROCEDURE;

   DECLARE COMMAND$TAIL(140) BYTE;
   DECLARE CHAR$PTR ADDRESS,
           CHAR BASED CHAR$PTR BYTE;

   CALL READ(CONSOLE$INPUT, .COMMAND$TAIL, LENGTH(COMMAND$TAIL), .ACTUAL,
              .STATUS);   CHK;

   COMMAND$TAIL(ACTUAL - 1) = CR;
   CALL CAPITALIZE(.COMMAND$TAIL, ACTUAL);
   CHAR$PTR = SKIP$BLANKS$N$TABS(.COMMAND$TAIL);

   LEN = FILE$NAME$LENGTH(CHAR$PTR);
   IF CHAR = ':'  THEN
      DO I = 0  TO   LEN;
        FILE$NAME(I) = CHAR;
        CHAR$PTR = CHAR$PTR + 1;
      END;
   ELSE
      DO I = 4  TO  LEN + 4;
        FILE$NAME(I) = CHAR;
        CHAR$PTR = CHAR$PTR + 1;
      END;

   CHAR$PTR = SKIP$BLANKS$N$TABS(CHAR$PTR );
   IF CHAR <> CR  THEN
     CALL STOP$EVERYTHING(.('Syntax is "WHICH  <file name>" ',CR, LF, 0));

END PARSE$COMMAND$TAIL;

SEARCH$FOR$STRING:   PROCEDURE;

      CALL OPEN(.AFTN$IN, .FILE$NAME, OPEN$FOR$READ, NO$LINE$EDIT, .STATUS);
           CHK;

      LEN1 = LENGTH(STRING$TO$SEARCH);
      SUCCESSFUL$FIND, END$OF$FILE = FALSE;
      STRING$INDEX = 0;

      DO WHILE  NOT  END$OF$FILE;
         CALL READ(AFTN$IN, .BUFFER, READ$BUFFER$LENGTH, .ACTUAL, .STATUS);
              CHK;
         IF ACTUAL < READ$BUFFER$LENGTH  THEN
             END$OF$FILE = TRUE;

         BUFFER$PTR = .BUFFER;

         DO WHILE NOT SUCCESSFUL$FIND   AND  BUFFER$PTR < .BUFFER(ACTUAL);
            SUCCESSFUL$FIND = STRING$FOUND(BUFFER$PTR,
                                           .BUFFER(ACTUAL) - BUFFER$PTR);
            BUFFER$PTR = BUFFER$PTR + BUFFER$INDEX;
            IF SUCCESSFUL$FIND     THEN
                DO;
                    CALL CHECK$VERSION$NUMBER(BUFFER$PTR);
                    IF SUCCESSFUL$FIND  THEN
                        END$OF$FILE = TRUE;
                END;
         END;
      END;
END SEARCH$FOR$STRING;

PRINT$RESULT:   PROCEDURE;

      IF  SUCCESSFUL$FIND   THEN
         DO;
            IF PROGRAM$MSG$PRINTED THEN
                DO;
                   CALL WRITE(CONSOLE$OUTPUT, .FOUND$MSG, LENGTH(FOUND$MSG), .STATUS);
                   CHK;
                END;
            CALL WRITE(CONSOLE$OUTPUT, BUFFER$PTR, VERSION$MSG$LENGTH, .STATUS);   CHK;
            CALL WRITE(CONSOLE$OUTPUT, .(CRLF), 2, .STATUS);  CHK;
         END;
      ELSE
         DO;
            CALL WRITE(CONSOLE$OUTPUT, .NOT$FOUND$MSG, LENGTH(NOT$FOUND$MSG),
                       .STATUS);   CHK;
         END;

      CALL CLOSE(AFTN$IN, .STATUS);   CHK;
END PRINT$RESULT;

$EJECT

/*********************************************************/
/*            MAIN  EXECUTABLE  CODE                     */
/*********************************************************/

CALL PARSE$COMMAND$TAIL;
CALL SEARCH$FOR$STRING;
CALL PRINT$RESULT;
CALL EXIT;

END
WHICH$MOD;
src/write.pex
write: procedure (conn, buff$p, count, status$p) external;
    declare (conn, buff$p, count, status$p) address;
end write;
src/xlate2.plm
XLATE2$MOD:
DO;

/************************************************************************/
/*																		*/
/*      '(C) Intel Corporation 1981'.  All rights reserved.  No			*/
/*      part of this program or publication may be reproduced,			*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

DECLARE COPYRIGHT (*) BYTE DATA ('(C) INTEL CORP 1981');

DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.0',0);

DECLARE LIT     LITERALLY 'LITERALLY',
        DCL     LIT       'DECLARE',
        TRUE    LIT       '0FFH',
        FALSE   LIT       '000H',
        PROC    LIT       'PROCEDURE',
        ENDPROC LIT       'END;',
        THENN   LIT       'THEN DO;',
        ELLSE   LIT       'END; ELSE DO;',
        ELSIF   LIT       'END; ELSE IF',
        ENDIF   LIT       'END;',
        ENDDO   LIT       'END;',
        CR      LIT       '0DH',
        LF      LIT       '0AH',
        NULL    LIT       '0',
        CHK     LIT       'CALL CHECK$ISIS$STATUS(STATUS)',
        TOEND   LIT       '7FFFH',
        TOBEG   LIT       '08000H'
        ;

DCL     comtrace            LIT '/*';   /* for debugging procedure trace */

DCL     PCNT$0$TYPE         LIT '0',
        PCNT$0$DOT$TYPE     LIT '1',
        PCNT$0$DOT$EXT$TYPE LIT '2',
        NUMB$0$TYPE         LIT '3';

DCL     NAME$DOT$TYPE       LIT  '0',
        NAME$DOT$EXT$TYPE   LIT  '1',
        NAME$ONLY$TYPE      LIT  '2';

DCL     UNKNOWN$TYPE        LIT  '10';

DCL     NAME$ADDED          LIT  '1',
        NEW$LINE            LIT  '3',
        DONE                LIT  '0';

DCL NO$NUM$EXTENSION        LIT '0FFFFH';

$EJECT
EXIT:   PROC             EXTERNAL;                                        END;
RESCAN: PROC (AFT,ST)    EXTERNAL; DCL  (AFT, ST)   ADDRESS;              END;
CO:     PROC (CHR)       EXTERNAL; DCL  CHR         BYTE;                 END;
READC:  PROC (PTR,LEN)   EXTERNAL; DCL (PTR,LEN)    ADDRESS;              END;
READI:  PROC (PTR,LEN)   EXTERNAL; DCL (PTR,LEN)    ADDRESS;              END;
READ1:  PROC (PTR,LEN)   EXTERNAL; DCL (PTR,LEN)    ADDRESS;              END;
OPENO:  PROC (PTR)       EXTERNAL; DCL  PTR         ADDRESS;              END;
OPENI:  PROC (PTR)       EXTERNAL; DCL  PTR         ADDRESS;              END;
OPEN1:  PROC (PTR,MO)    EXTERNAL; DCL  PTR ADDRESS,MO BYTE;              END;
CLOSEO: PROC             EXTERNAL;                                        END;
CLOSEI: PROC             EXTERNAL;                                        END;
CLOSE1: PROC             EXTERNAL;                                        END;
CONS:   PROC (P1,P2)     EXTERNAL; DCL  (P1,P2)     ADDRESS;              END;
SEEK:   PROC (A,M,B,C,S) EXTERNAL; DCL  (A,M,B,C,S) ADDRESS;              END;
SCANMATCH: PROC(P)BYTE   EXTERNAL; DCL  P           ADDRESS;              END;
SCAN$WHILE:PROC(P)       EXTERNAL; DCL  P           ADDRESS;              END;
SCAN$UNTIL:PROC(P)       EXTERNAL; DCL  P           ADDRESS;              END;
TERM$CH:   PROC   BYTE   EXTERNAL;                                        END;
OUT$CHAR:  PROC   (CHAR) EXTERNAL; DCL  CHAR        BYTE;                 END;
OUT$PRINT: PROC (PTR)    EXTERNAL; DCL  PTR         ADDRESS;              END;
OUT$DEC$R: PROC (VAL,W)  EXTERNAL; DCL  VAL ADDRESS, W BYTE;              END;
DEC$IN:    PROC ADDRESS  EXTERNAL;                                        END;
DEL:       PROC(PTR)     EXTERNAL; DCL   PTR        ADDRESS;              END;
FMOVE: PROC (C,S,D)      EXTERNAL; DCL  (C,S,D)     ADDRESS;              END;
WHOCI:  PROC (PTR)       EXTERNAL; DCL  PTR         ADDRESS;              END;
WHOCO:  PROC (PTR)       EXTERNAL; DCL  PTR         ADDRESS;              END;
WRITEO: PROC(P,L)        EXTERNAL; DCL  (P,L)       ADDRESS;              END;
WRITEC: PROC(P,L)        EXTERNAL; DCL  (P,L)       ADDRESS;              END;
ERROR: PROC(ERROR$NO)    EXTERNAL; DCL  ERROR$NO    ADDRESS;              END;
MEM$CK: PROC ADDRESS     EXTERNAL;                                        END;
SPATH: PROC(FILE,BUFFER,STATUS)  EXTERNAL;
       DCL (FILE,BUFFER,STATUS)  ADDRESS;                                 END;
LOAD: PROC(FILE,BIAS,SWITCH,ENTRY,STATUS) EXTERNAL;
      DCL (FILE,BIAS,SWITCH,ENTRY,STATUS) ADDRESS;                        END;
GETD: PROC(DRIVE,CON,COUNT,ACTUAL$COUNT,BUFFER,STATUS) EXTERNAL;
      DCL (DRIVE,CON,COUNT,ACTUAL$COUNT,BUFFER,STATUS) ADDRESS;           END;
WRITE:PROC(AFTN,BUFFER,COUNT,STATUS) EXTERNAL;
      DCL (AFTN,BUFFER,COUNT,STATUS) ADDRESS;                             END;

DCL    (STATUS,REPORT,ERRED,FATAL,ACTUAL) ADDRESS EXTERNAL;
DCL    (SCANP,OBUFP,GIVEUP)      ADDRESS EXTERNAL,
       (SCANENDED,TARLEN,JOKER)  BYTE    EXTERNAL;
DCL    LEADCHAR                  BYTE    EXTERNAL;

$EJECT
DCL    SCANBYTE BASED SCANP BYTE,
       SCANP$TMP ADDRESS;
DCL    BLOKNO ADDRESS, BYTENO ADDRESS;

/*********************************************
    G L O B A L   S T R U C T U R E S
*********************************************/
DCL   NAMEINDEX ADDRESS;
DCL   MAXINDEX  LIT '200';
DCL   NAME$LIST (MAXINDEX)     STRUCTURE ( DRIVE (4) BYTE,
                                           NAME  (6) BYTE,
                                           EXT   (3) BYTE,
                                           TYPE BYTE);
DCL   FILL$INDEX BYTE;
DCL   MAX$FILLS LIT '30';
DCL   FILL$ARRAY (MAX$FILLS)   STRUCTURE ( FILL$PTR ADDRESS,
                                           TYPE BYTE,
                                           EXT (4) BYTE,
                                           DRIVE (4) BYTE);

/*********************************************
       G L O B A L   V A R I A B L E S
*********************************************/

DCL FRONT$EXT          LIT '512',
    READ$LEN           LIT '1024';
DCL TEMPLATE (1536)    BYTE;
DCL PAD                BYTE;  /* this is a pad for template, do not disturb */
DCL INVOK$NAME (16)    BYTE;

DCL (FROM$PTR, FILL$PTR) ADDRESS;
DCL ENDOFLIST          BYTE;

DCL DEBUG$FLAG         BYTE INITIAL (FALSE);
DCL HALT$FLAG          BYTE INITIAL (FALSE);
DCL SCRUNCH$FLAG       BYTE INITIAL (FALSE);

DCL TARGET (10)        BYTE PUBLIC ;
DCL READBUF (129)      BYTE;
DCL MSG$BUF (128)      BYTE;
DCL BLANK$STR (16)     BYTE DATA('                ');
DCL NULLSTRING(16)     BYTE DATA(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
DCL DR$STR(4)          BYTE DATA(':F#:');
DCL LENGTH$TO$WRITE$FROM$TEMPLATE ADDRESS;
DCL MONITOR ADDRESS DATA(0);
DCL CONNECTION ADDRESS INITIAL(0);
DCL MEM$TOP ADDRESS;
DCL END$OF$DIRECTORY ADDRESS;
DCL READING$REMOTE BYTE;

/*********************************************
    D I R E C T O R Y    G L O B A L S
*********************************************/
DCL DIR$TO$SEARCH BYTE;
DCL DIRECTORY$NAME (*) BYTE DATA(':F :ISIS.DIR ');
DCL DIR$BUF  (16384) BYTE;
DCL DIR$ENTRY$PTR ADDRESS,
    DIR$ENTRY BASED DIR$ENTRY$PTR STRUCTURE
                (PRESENCE BYTE,
                FILENAME (6) BYTE,
                EXTENSION (3) BYTE,
                ATTRIBUTES BYTE,
                EOF$COUNT BYTE,
                NUM$DATA$BLKS ADDRESS,
                HEADER$BLK$PTR ADDRESS);
DCL DIR$NAME (50) BYTE AT (.DIRECTORY$NAME);

$EJECT
/*********************************************
    C O M M O N      P R O C E D U R E S
*********************************************/
PRINT: PROC (PTR);
  DCL (TMP$PTR,PTR) ADDRESS,CHR BASED PTR BYTE;
  TMP$PTR = PTR;
  DO WHILE CHR <> NULL;
     PTR = PTR + 1;
  ENDDO
  CALL WRITEC(TMP$PTR,PTR-TMP$PTR);
END PRINT;

PRINT$CR: PROC (PTR);
  DCL PTR ADDRESS;
  CALL PRINT(PTR);
  CALL PRINT(.(CR,LF,0));
END PRINT$CR;

PRINT$CR$EXIT: PROC (PTR);
  DCL PTR ADDRESS;
  CALL PRINT$CR(PTR);
  CALL EXIT;
END;

CHK$STATUS: PROC (PTR);
  DCL PTR ADDRESS;
  DCL STATUS$OUT ADDRESS;
  IF STATUS <> 0 THENN
     STATUS$OUT = STATUS;
     CALL PRINT(.('bad status (= ',0));
     OBUFP = .MSG$BUF;
     CALL OUT$DEC$R(STATUS$OUT,5);
     CALL OUTPRINT(.(') ',0));
     CALL OUTCHAR(NULL);
     CALL PRINT(.MSG$BUF);
     CALL PRINT$CR$EXIT(PTR);
  ENDIF
END CHK$STATUS;

CHECK$ISIS$STATUS:  PROC(ISIS$STATUS);
   DCL ISIS$STATUS  ADDRESS;
   IF ISIS$STATUS <> 0  THEN
     DO;
       CALL ERROR(ISIS$STATUS);
       CALL MONITOR;
     END;
END CHECK$ISIS$STATUS;

comtrace BEG$PR$DEBUG: PROC ( PTR,VAL,PROC$PTR);
           DCL (PTR,PROC$PTR) ADDRESS, VAL BYTE;
           IF DEBUG$FLAG THENN
              DO WHILE VAL > 0;
                 CALL PRINT(.('.',0));
                 VAL = VAL - 1;
              ENDDO
              CALL PRINT(.('entering ',0));
              CALL PRINT$CR(PTR);
              CALL PROC$PTR;
           ENDIF
         END BEG$PR$DEBUG;

comtrace END$PR$DEBUG: PROC( PTR,VAL,PROC$PTR);
            DCL (PTR,PROC$PTR) ADDRESS, VAL BYTE;
           IF DEBUG$FLAG THENN
              DO WHILE VAL > 0;
                 CALL PRINT(.('.',0));
                 VAL = VAL - 1;
              ENDDO
              CALL PRINT(.('leaving  ',0));
              CALL PRINT$CR(PTR);
              CALL PROC$PTR;
           ENDIF
         END END$PR$DEBUG;                            /* opt */

DEBLANK: PROC (PTR) ADDRESS;
 DCL PTR ADDRESS,CHR BASED PTR BYTE;
 DO WHILE CHR = ' ';
  PTR = PTR + 1;
 ENDDO
 RETURN PTR;
END DEBLANK;

LESSER$OF: PROC (VAL1,VAL2) ADDRESS;
  DCL (VAL1,VAL2) ADDRESS;
  IF VAL1 > VAL2 THENN
     RETURN VAL2;
  ELLSE
     RETURN VAL1;
  ENDIF
END LESSER$OF;

LET$CH$WP:          PROC (CHAR) BYTE;
  DCL CHAR BYTE;
   RETURN
   ( (CHAR >= 'a' AND CHAR <= 'z') OR
     (CHAR >= 'A' AND CHAR <= 'Z')  );
END LET$CH$WP;

DIG$CH$WP:          PROC (CHAR) BYTE;
  DCL CHAR BYTE;
  RETURN ((CHAR >= '0' AND CHAR <= '9'));
END DIG$CH$WP;

LET$OR$DIG$CH$WP:   PROC (CHAR) BYTE;
  DCL CHAR BYTE;
  RETURN (LET$CH$WP(CHAR) OR DIG$CH$WP(CHAR));
END LET$OR$DIG$CH$WP;

DOT$CH$WP:          PROC (CHAR) BYTE;
  DCL CHAR BYTE;
  RETURN (CHAR = '.');
END DOT$CH$WP;

COLON$CH$WP:        PROC (CHAR) BYTE;
   DCL CHAR BYTE;
   RETURN (CHAR = ':');
END COLON$CH$WP;

FILE$CH$WP:          PROC (CHAR) BYTE;
   DCL CHAR BYTE;
   RETURN( LET$OR$DIG$CH$WP(CHAR) OR DOT$CH$WP(CHAR) OR COLON$CH$WP(CHAR));
END FILE$CH$WP;

BLANK$CH$WP:         PROC (CHAR) BYTE;
   DCL CHAR BYTE;
   RETURN (CHAR = ' ');
END BLANK$CH$WP;

LENGTH$OF:       PROC (PROC$PTR) ADDRESS;
  DCL (PROC$PTR,TMP$PTR,LEN) ADDRESS;
  TMP$PTR = SCANP;
  CALL SCANWHILE(PROC$PTR);
  LEN = SCANP - TMP$PTR;
  SCANP = TMP$PTR;
  RETURN LEN;
END LENGTH$OF;

NULL$PROC: PROC;
  SCANP = SCANP;
END NULL$PROC;

ENFORCE$LESS$OR$EQUAL: PROC (VAL,LIM$VAL,PROC$PTR);
   DCL(VAL,LIM$VAL,PROC$PTR) ADDRESS;
   IF VAL > LIM$VAL THEN CALL PROC$PTR;
END ENFORCE$LESS$OR$EQUAL;

ENFORCE$GREATER$OR$EQUAL: PROC (VAL,LIM$VAL,PROC$PTR);
   DCL(VAL,LIM$VAL,PROC$PTR) ADDRESS;
   IF VAL < LIM$VAL THEN CALL PROC$PTR;
END ENFORCE$GREATER$OR$EQUAL;

ENFORCE$WITHIN$BOUNDS: PROC (VAL,HI$LIM,LO$LIM,PROC$PTR);
   DCL(VAL,HI$LIM,LO$LIM,PROC$PTR) ADDRESS;
   CALL ENFORCE$LESS$OR$EQUAL(VAL,HI$LIM,PROC$PTR);
   CALL ENFORCE$GREATER$OR$EQUAL(VAL,LO$LIM,PROC$PTR);
END ENFORCE$WITHIN$BOUNDS;

LET$CH:          PROC BYTE;
  RETURN(LET$CH$WP(SCANBYTE));
END LET$CH;

LP:              PROC BYTE;
  RETURN(SCANBYTE='(');
END LP;

COMMA:           PROC BYTE;
  RETURN(SCANBYTE=',');
END COMMA;

DIG$CH:          PROC BYTE;
  RETURN(DIG$CH$WP(SCANBYTE));
END DIG$CH;

LET$OR$DIG$CH:   PROC BYTE;
  RETURN (LET$OR$DIG$CH$WP(SCANBYTE));
END LET$OR$DIG$CH;

DOT$CH:          PROC BYTE;
  RETURN(DOT$CH$WP(SCANBYTE));
END DOT$CH;

COLON$CH:        PROC BYTE;
  RETURN(COLON$CH$WP(SCANBYTE));
END COLON$CH;

FILE$CH:          PROC BYTE;
   RETURN(LET$OR$DIG$CH$WP(SCANBYTE)
   OR DOT$CH$WP(SCANBYTE)OR COLON$CH$WP(SCANBYTE) );
END FILE$CH;

BLANK$CH:         PROC BYTE;
   RETURN(BLANK$CH$WP(SCANBYTE));
END BLANK$CH;

NULL$CH:          PROC BYTE;
   RETURN (SCANBYTE = NULL);
END NULL$CH;

ENFORCE$NO$TOKENS: PROC;
  DO WHILE NOT TERM$CH ;
     IF NOT  BLANK$CH  THENN
       CALL PRINT$CR$EXIT(.('only blanks allowed after &',0));
     ENDIF
     SCANP = SCANP + 1;
  ENDDO
END ENFORCE$NO$TOKENS;

RESTORE: PROC;
  /* this procedure interprets the restore command in the xlate2.cs file */
  /* restores the previous :ci: file and deletes the xlate2.cs file      */
  DCL NAME$CI (16) BYTE;
  DCL CI$PTR ADDRESS;
  LP: PROC BYTE;
      RETURN (SCANBYTE='(');
  END LP;
  COMMA: PROC BYTE;
      RETURN (SCANBYTE=',');
  END COMMA;
  comtrace DCL PROC$NAME (*) BYTE DATA('restore',0);               /* opt */
  comtrace CALL BEG$PR$DEBUG(.PROC$NAME,1,.NULL$PROC);             /* opt */
  CALL FMOVE(15,.BLANK$STR,.NAME$CI);                     /* current :ci: */
  CALL WHOCI(.NAME$CI);    /* current :ci: name saved, file to be deleted */
  CALL CONS(CI$PTR:=DEBLANK(SCANP),.(':CO: '));    /* new :ci:, same :co: */
  SCANP = CI$PTR + 1;
  IF SCANBYTE = 'F' THENN                /* old :ci: = :f?:... --> delete */
     DCL MSG(*) BYTE DATA('xlate2 error: restore seek',0);
     CALL DEL(.NAME$CI);                 /* and console over to old pos   */
     CALL CHK$STATUS(.('cannot delete .cs file',0));
     CALL SCANUNTIL(.LP);
     BLOKNO = DEC$IN;
     CALL SCANUNTIL(.COMMA);
     BYTENO = DEC$IN;
     CALL SEEK(1,2,.BLOKNO,.BYTENO,.STATUS);
     CALL CHK$STATUS(.MSG);
  ENDIF
  CALL EXIT;                           /* f i n i s h e d  ! ! ! */
  comtrace CALL END$PR$DEBUG(.PROC$NAME,1,.NULL$PROC); /* opt */
END RESTORE;

$EJECT

/***************************************************
           I N I T I A L I Z A T I O N
***************************************************/

FIRST$INIT: PROC;
   DCL TMP$PTR ADDRESS;
   comtrace DCL PROC$NAME (*) BYTE DATA('first$init',0); /* opt */
   comtrace CALL BEG$PR$DEBUG(.PROC$NAME,1,.NULL$PROC); /* opt */
   REPORT = FALSE;              /* set sys.lib status checking to false */
   CALL FMOVE(16,.BLANK$STR,.INVOK$NAME);
   NAME$INDEX = 0;
   FILL$INDEX = 0;
   READBUF(128) = CR;
   comtrace CALL END$PR$DEBUG(.PROC$NAME,1,.NULL$PROC); /* opt */
END FIRST$INIT;

$EJECT

/****************************************************
       T E M P L A T E   P R O C E S S I N G
               P R O C E D U R E S
****************************************************/
/****************************************************
   these procedures
   1) read in the template file
   2) expand the template file at the substitution
      characters
   3) fills an array of pointers into
      the expanded template.
   4) fill an array describing the type of sub.
      parameter, preceding drive # , etc.
*****************************************************/

BUILD$TEMPLATE: PROC ;
   DCL (BEG$SUB$PTR,END$SUB$PTR) ADDRESS;

   SUBSTITUTION$FOUND: PROC (F$INDEX,B$PTR$PTR,E$PTR$PTR,LIMIT) BYTE;
     DCL (F$INDEX, B$PTR$PTR, E$PTR$PTR, LIMIT, TMP$PTR) ADDRESS;

     SET$FILL$DRIVE: PROC (F$INDEX,B$PTR$PTR);
       DCL (F$INDEX,B$PTR$PTR) ADDRESS, B$PTR BASED B$PTR$PTR ADDRESS;
       DCL TMP$PTR ADDRESS;
       comtrace DCL PROC$NAME (*) BYTE DATA('set$fill$drive',0);
                   PR$DEBUG: PROC;
                   CALL PRINT(.('fill index : ',0));
                   OBUFP = .MSG$BUF;
                   CALL OUT$DEC$R(F$INDEX,5);
                   CALL OUT$CHAR(NULL);
                   CALL PRINT$CR(.MSG$BUF);
                END PR$DEBUG;
                CALL BEG$PR$DEBUG(.PROC$NAME,3,.PR$DEBUG);       /* opt */

       TMP$PTR = SCANP;
       SCANP = SCANP - 2;
       IF          COLON$CH          THENN
          SCANP = SCANP - 3;
          B$PTR = SCANP;
          CALL FMOVE(4,SCANP,.FILL$ARRAY(F$INDEX).DRIVE);
          SCANP = SCANP + 2;
          IF   SCANBYTE = '?'   THENN
             CALL FMOVE(1,.DIR$TO$SEARCH,.FILL$ARRAY(F$INDEX).DRIVE(2));
          ENDIF
       ELLSE
          CALL FMOVE(4,.NULL$STRING,.FILL$ARRAY(F$INDEX).DRIVE);
          B$PTR = SCANP + 1;
       ENDIF
       SCANP = TMP$PTR;
       comtrace CALL END$PR$DEBUG(.PROC$NAME,3,.NULL$PROC); /* opt */
     END SET$FILL$DRIVE;

     SET$FILL$EXT: PROC (F$INDEX,E$PTR$PTR);
        DCL (F$INDEX,E$PTR$PTR) ADDRESS,
             E$PTR BASED E$PTR$PTR ADDRESS;
        comtrace DCL PROC$NAME (*) BYTE DATA('set$fill$ext',0); /* opt */
        comtrace CALL BEG$PR$DEBUG(.PROC$NAME,3,.NULL$PROC);    /* opt */
        SCANP = SCANP - 1;
        IF           SCANBYTE = '#'               THENN
           E$PTR,SCANP = SCANP + 2;
           FILL$ARRAY(F$INDEX).TYPE = NUMB$0$TYPE;
        ELSIF        SCANBYTE = '%'               THENN
           SCANP = SCANP + 2;
           IF         BLANK$CH            THENN
              E$PTR = SCANP;
              FILL$ARRAY(F$INDEX).TYPE = PCNT$0$TYPE;
           ELSIF       DOT$CH             THENN
              SCANP = SCANP + 1;
              IF NOT (LET$OR$DIG$CH) THENN
                 E$PTR = SCANP;
                 FILL$ARRAY(F$INDEX).TYPE = PCNT$0$DOT$TYPE;
              ELLSE
                    DCL LEN$EXT ADDRESS;
                    FILL$ARRAY(F$INDEX).TYPE = PCNT$0$DOT$EXT$TYPE;
                    LEN$EXT = LENGTH$OF(.LET$OR$DIG$CH);
                    IF LEN$EXT > 3 THENN
                       CALL PRINT$CR$EXIT(.('ext part too long',0));
                    ELLSE
                       CALL FMOVE(3,.BLANK$STR ,.FILL$ARRAY(F$INDEX).EXT);
                       CALL FMOVE(LEN$EXT,SCANP,.FILL$ARRAY(F$INDEX).EXT);
                       E$PTR,SCANP = SCANP + LEN$EXT;
                    ENDIF
              ENDIF
           ELLSE
              FILL$ARRAY(F$INDEX).TYPE = UNKNOWN$TYPE;
              E$PTR = SCANP;
           ENDIF
        ELLSE
           CALL PRINT$CR$EXIT(.('xlate2 error: set$fill$index',0));
        ENDIF
        E$PTR = LESSER$OF(E$PTR,.TEMPLATE+FRONT$EXT+ACTUAL);
        comtrace CALL END$PR$DEBUG(.PROC$NAME,3,.NULL$PROC);       /* opt */
     END SET$FILL$EXT;

     comtrace DCL PROC$NAME (*) BYTE DATA('substitution$found',0); /* opt */
     comtrace CALL BEG$PR$DEBUG(.PROC$NAME,2,.NULL$PROC);          /* opt */
     DO WHILE TRUE;
        DO WHILE SCANBYTE <> '%' AND SCANBYTE <> '#' ;
           SCANP = SCANP + 1;
        ENDDO
        SCANP = SCANP + 1;
        IF           SCANBYTE = '0' AND SCANP <= LIMIT          THENN
           DCL TMP$PTR ADDRESS;
           TMP$PTR = SCANP;
           CALL SET$FILL$DRIVE(F$INDEX,B$PTR$PTR);
           CALL SET$FILL$EXT(F$INDEX,E$PTR$PTR);
           SCANP = TMP$PTR;
           comtrace CALL END$PR$DEBUG(.PROC$NAME,2,.NULL$PROC);    /* opt */
           RETURN TRUE;
        ELSIF                 SCANP > LIMIT                     THENN
           comtrace CALL END$PR$DEBUG(.PROC$NAME,2,.NULL$PROC);    /* opt */
           RETURN FALSE;
        ENDIF
     ENDDO
   END SUBSTITUTION$FOUND;

   comtrace DCL PROC$NAME (*) BYTE DATA('build$template',0);       /* opt */
   comtrace CALL BEG$PR$DEBUG(.PROC$NAME,1,.NULL$PROC);            /* opt */
   CALL READI(.TEMPLATE+FRONT$EXT, READ$LEN);
   CALL CHK$STATUS(.('cannot read template file',0));
   TEMPLATE(FRONT$EXT + ACTUAL) = NULL;
   IF ACTUAL = 1024 THENN                  /* syntax chk opt */
      CALL PRINT$CR$EXIT(.('template file too large',0));
   ENDIF
   FROM$PTR,SCANP = .TEMPLATE+FRONT$EXT;
   FILL$PTR = .TEMPLATE;
   DO WHILE SUBSTITUTION$FOUND(FILL$INDEX,.BEG$SUB$PTR,.END$SUB$PTR,
                               .TEMPLATE(FRONT$EXT+ACTUAL-1));
      CALL FMOVE(BEG$SUB$PTR-FROM$PTR,FROM$PTR,FILL$PTR);
      FILL$PTR = FILL$PTR + BEG$SUB$PTR-FROM$PTR;
      FILL$ARRAY(FILL$INDEX).FILL$PTR = FILL$PTR;
      FILL$PTR = FILL$PTR + 16;
      FROM$PTR,SCANP = END$SUB$PTR;
      IF (FILL$INDEX := FILL$INDEX + 1) > MAX$FILLS THENN
         CALL PRINT$CR$EXIT(.('maximum substitutions exceeded',0));
      ENDIF
   ENDDO
   IF FILL$INDEX = 0 THENN
      CALL PRINT$CR$EXIT(
         .('no substitution signs in the template',0));
   ELLSE
      FILL$INDEX = FILL$INDEX - 1;
   ENDIF
   IF FROM$PTR  >  .TEMPLATE+ACTUAL+FRONT$EXT THENN
      CALL PRINT$CR$EXIT(.('xlate2 error: build$template',0));
   ENDIF
   CALL FMOVE(.TEMPLATE+FRONT$EXT+ACTUAL-FROM$PTR, FROM$PTR, FILL$PTR);
   /* this is a kludge, we want to add the -1 in the fmove but
      dont because we might end up with a 64k move, so we only
      adjust the fill$ptr accordingly.
   */
   FILL$PTR = FILL$PTR + .TEMPLATE+FRONT$EXT+ACTUAL - FROM$PTR;
   LENGTH$TO$WRITE$FROM$TEMPLATE = FILL$PTR - .TEMPLATE;
   CALL FMOVE(1,.(0),(FILL$PTR+1));
   comtrace CALL END$PR$DEBUG(.PROC$NAME,1,.NULL$PROC);     /* opt */
END BUILD$TEMPLATE;

$ EJECT

/**************************************************
  D I R E C T O R Y   M A N I P U L A T I N G
                P R O C E D U R E S
***************************************************/

READ$DIRECTORY:  PROC (NAKED$DEVICE$NUMBER) ;
   DCL NAKED$DEVICE$NUMBER BYTE;
   DCL BUFFER(12) BYTE;
   DCL COUNT ADDRESS;
   DCL FREE$SPACE ADDRESS;
   DCL ACTUAL$ENTRY ADDRESS;
   DCL ENTRY ADDRESS;

   comtrace DCL PROC$NAME (*) BYTE DATA('read$directory',0);
   CALL BEG$PR$DEBUG(.PROC$NAME,1,.NULL$PROC);          /* opt */

   DIR$NAME(2) = NAKED$DEVICE$NUMBER;

   CALL SPATH(.DIRECTORY$NAME,.BUFFER,.STATUS); CHK;
   IF BUFFER(10) = 3  AND  BUFFER(11) = 5  THEN
       DO;
         MEM$TOP = MEM$CK - 13;
         IF MEM$TOP < 0E800H  THEN
           CALL CHK$STATUS(.('insufficient memory',0));
         ELSE
           DO;
              FREE$SPACE = 0E800H - .MEMORY;
              COUNT = FREE$SPACE/16;
              CALL LOAD(.(':F0:ISIS.OV0 '),0,0,.ENTRY,.STATUS); CHK;
              CALL GETD(NAKED$DEVICE$NUMBER-'0',.CONNECTION,COUNT,
                        .ACTUAL$ENTRY,.DIR$BUF,.STATUS); CHK;
              IF ACTUAL$ENTRY >= COUNT  THEN
                 CALL CHK$STATUS(.('remote directory too large',0));
              READING$REMOTE = TRUE;
              END$OF$DIRECTORY = .DIR$BUF + (ACTUAL$ENTRY * 16);
           END;
       END;
   ELSE
       DO;
          CALL OPEN1(.DIRECTORY$NAME,1);
          CALL CHK$STATUS(.('cannot open directory file',0));
          CALL READ1(.DIR$BUF,SIZE(DIR$BUF));
          CALL CHK$STATUS(.('cannot read directory file',0));
          /*	Dir$buf is larger than an ISIS V4.0 hard disk directory  */
          CALL CLOSE1;
          CALL CHK$STATUS(.('cannot close directory file',0));

          READING$REMOTE = FALSE;
          END$OF$DIRECTORY = .DIR$BUF + ACTUAL;
          comtrace CALL END$PR$DEBUG(.PROC$NAME,1,.NULL$PROC);        /* opt */
       END;
END READ$DIRECTORY;

GREATEST$EXT: PROC (NAME$PART$PTR) ADDRESS;
   DCL NAME$PART$PTR ADDRESS;
   DCL LARGEST$EXTENSION ADDRESS;
   DCL NUM$EXTENSION$FOUND BYTE;
   NUMERIC$EXTENSION: PROC (PTR) BYTE;
        /*	Given a pointer into memory, this procedure determines
                whether the byte pointed to, and the next two contiguous
                bytes, constitute a wholly numeric ascii sequence.
        */
        DCL PTR ADDRESS,
            CHAR BASED PTR (10) BYTE;
        DCL L BYTE;
        DO L=0 TO 2;
                IF NOT DIG$CH$WP(CHAR(L)) THENN
                        RETURN FALSE;
                ENDIF
        ENDDO
        RETURN TRUE;
   END NUMERIC$EXTENSION;

   VALUE: PROC (DIR$EXT$PTR) ADDRESS;
        DCL DIR$EXT$PTR ADDRESS;
        DCL CHAR BASED DIR$EXT$PTR (3) BYTE;
        DCL T BYTE;
        DCL RESULT ADDRESS;
        RESULT = 0;
        DO T = 0 TO 2;
                RESULT = (RESULT * 10) + CHAR(T) - '0';
        ENDDO
        RETURN RESULT;
   END VALUE;

   NAME$PARTS$MATCH: PROC (NAME$PTR$1,NAME$PTR$2) BYTE;
           DCL (NAME$PTR$1,NAME$PTR$2) ADDRESS,
               TMP ADDRESS, COMP$BUF (7) BYTE, MATCH BYTE,
               (LEN$1,LEN$2) ADDRESS;
      TMP = SCANP;
      SCANP = NAME$PTR$1;
      LEN$1 = LESSER$OF(6,LENGTH$OF(.LET$OR$DIG$CH));
      SCANP = NAME$PTR$2;
      LEN$2 = LESSER$OF(6,LENGTH$OF(.LET$OR$DIG$CH));
      SCANP = TMP;
      IF                LEN$1    <>    LEN$2                THENN
         RETURN FALSE;
      ELLSE
         CALL FMOVE(LEN$1,NAME$PTR$1,.COMP$BUF);
         CALL FMOVE(1,.(0),.COMP$BUF(LEN$1));
         TMP = SCANP;
         SCANP = NAME$PTR$2;
         MATCH = SCAN$MATCH(.COMP$BUF);
         SCANP = TMP;
         RETURN MATCH;
      ENDIF
   END NAME$PARTS$MATCH;

   comtrace DCL PROC$NAME (*) BYTE DATA('greatest$ext',0);      /* opt */
   comtrace CALL BEG$PR$DEBUG(.PROC$NAME,1,.NULL$PROC);         /* opt */
   DIR$ENTRY$PTR = .DIR$BUF;
   NUM$EXTENSION$FOUND = FALSE;
   LARGEST$EXTENSION = 0;
   /*	Grand directory search loop. */
   DO WHILE  DIR$ENTRY$PTR < END$OF$DIRECTORY;
      IF NOT READING$REMOTE  THEN
        DO;
          IF DIR$ENTRY.PRESENCE = 7FH  THEN
             GO TO NO$MORE$DIR;
          IF DIR$ENTRY.PRESENCE = 0FFH  THEN
             GO TO BUMP$PTR;
        END;
      IF NAME$PARTS$MATCH(.DIR$ENTRY.FILENAME,NAME$PART$PTR) AND
               (DIR$ENTRY.PRESENCE <> 0FFH)                           THENN
         IF NUMERIC$EXTENSION(.DIR$ENTRY.EXTENSION) THENN
            DCL EXTENSION$NUM ADDRESS;
            NUM$EXTENSION$FOUND = TRUE;
            EXTENSION$NUM = VALUE(.DIR$ENTRY.EXTENSION);
            IF EXTENSION$NUM > LARGEST$EXTENSION THENN
               LARGEST$EXTENSION = EXTENSION$NUM;
            ENDIF
         ENDIF
      ENDIF
      bump$ptr:
      DIR$ENTRY$PTR = DIR$ENTRY$PTR + 16;
   ENDDO
   no$more$dir:
   IF      NUM$EXTENSION$FOUND       THENN
      comtrace CALL END$PR$DEBUG(.PROC$NAME,1,.NULL$PROC);          /* opt */
      RETURN LARGEST$EXTENSION;
   ELLSE
      comtrace CALL END$PR$DEBUG(.PROC$NAME,1,.NULL$PROC);          /* opt */
      RETURN NO$NUM$EXTENSION;
   ENDIF
END GREATEST$EXT;

$EJECT

/********************************************************
         O U T P U T     P R O C E D U R E S
********************************************************/

FILL$NAME: PROC (N$INDEX, F$INDEX);
  DCL (N$INDEX,F$INDEX) ADDRESS, (N$TYPE,F$TYPE) BYTE;
  DCL TMP$BUF (16) BYTE, LENGTH$NAME$PART BYTE;
  DCL MSG (*) BYTE DATA('xlate2 error: fill$name',0);
  N$TYPE = NAME$LIST(N$INDEX).TYPE;
  F$TYPE = FILL$ARRAY(F$INDEX).TYPE;
  SCANP = .NAME$LIST(N$INDEX).NAME;
  OBUFP = .TMP$BUF;
  LENGTH$NAME$PART = LESSER$OF(6,LENGTH$OF(.LET$OR$DIG$CH));
  CALL FMOVE(16,.BLANK$STR,OBUFP);
  IF FILL$ARRAY(F$INDEX).DRIVE(2) = '?' THENN
     FILL$ARRAY(F$INDEX).DRIVE(2) = DIR$TO$SEARCH;
  ENDIF
  IF FILL$ARRAY(F$INDEX).DRIVE(0) <> NULL THENN
     CALL FMOVE(4,.FILL$ARRAY(F$INDEX).DRIVE,OBUFP);
  ENDIF;
  OBUFP = OBUFP + 4;
  CALL FMOVE(LENGTH$NAME$PART,.NAME$LIST(N$INDEX).NAME,OBUFP);
  OBUFP = OBUFP + LENGTH$NAME$PART;
  IF                 F$TYPE <= 3                   THENN
     DO CASE F$TYPE;
        /* PCNT$0$TYPE */
        DO;
          IF N$TYPE = NAME$DOT$EXT$TYPE THENN
             DCL LENGTH$EXT BYTE;
             CALL OUTCHAR('.');
             SCANP = .NAME$LIST(N$INDEX).EXT;
             LENGTH$EXT = LESSER$OF(3,LENGTH$OF(.LET$OR$DIG$CH));
             CALL FMOVE(LENGTH$EXT,.NAME$LIST(N$INDEX).EXT,OBUFP);
          ENDIF
        ENDDO
        /* PCNT$0$DOT$TYPE */
        DO;
        ENDDO
        /* PCNT$0$DOT$EXT$TYPE */
        DO;
          DCL LENGTH$EXT BYTE;
          SCANP = .FILL$ARRAY(F$INDEX).EXT;
          LENGTH$EXT = LESSER$OF(3,LENGTH$OF(.LET$OR$DIG$CH));
          CALL OUTCHAR('.');
          CALL FMOVE(LENGTH$EXT,.FILL$ARRAY(F$INDEX).EXT,OBUFP);
        ENDDO
        /* NUMB$0$TYPE */
        DO;
          IF N$TYPE <> NAME$DOT$TYPE THENN
             DCL NUMB$EXT ADDRESS;
             DCL NAMEPART (7) BYTE;
             CALL OUT$CHAR('.');
             NUMB$EXT = GREATEST$EXT(.NAME$LIST(N$INDEX).NAME);
             /*   For the first version a wholly numeric 3 digit
                extension is required */
             IF NUMB$EXT >= 1000 THENN
                CALL PRINT(.('filename : ',0));
                SCANP = .NAME$LIST(N$INDEX).NAME;
                CALL FMOVE(7,.NULL$STRING,.MSG$BUF);
                CALL FMOVE(LESSEROF(6,LENGTHOF(.LET$OR$DIG$CH)),SCANP,.MSGBUF);
                OBUFP = .MSG$BUF(6);
                CALL OUTCHAR(NULL);
                CALL PRINT(.MSGBUF);
                CALL PRINT$CR(.(' has no numeric extension',0));
             ENDIF
             LEADCHAR = '0';
             CALL OUT$DEC$R(NUMB$EXT,3);
             LEADCHAR = ' ';
          ENDIF
        ENDDO
     ENDDO
  ELSIF          F$TYPE <> UNKNOWN$TYPE             THENN
     CALL PRINT$CR(.MSG);
     CALL PRINT(.('xlate2 error: fill$name, type = ',0));
     OBUFP = .MSG$BUF;
     CALL OUTDECR(F$TYPE,3);
     CALL OUTCHAR(NULL);
     CALL PRINT(.MSG$BUF);
     CALL PRINT(.(' on the ',0));
     OBUFP = .MSG$BUF;
     CALL OUTDECR(F$INDEX+1,3);
     CALL PRINT(.MSG$BUF);
     CALL PRINT$CR$EXIT(.(' template substitution',0));
  ENDIF
  CALL FMOVE(16,.TMP$BUF,FILL$ARRAY(F$INDEX).FILL$PTR);
END FILL$NAME;

OUTPUT$LIST: PROC;
  DCL TMP$FILL$INDEX  ADDRESS,
      TMP$NAME$INDEX  ADDRESS;
  DCL FILE$NAME (16) BYTE DATA(':F0:XLATE2.CS  ',0);
  DCL FILE$TO$EXECUTE (16) BYTE;
  
  OPEN$CONSOLE$FILE: PROC;
    DCL TMP$PTR ADDRESS;
    TMP$PTR = SCANP;
    CALL FMOVE(16,.FILENAME,.MSG$BUF);
    SCANP = DEBLANK(.INVOK$NAME);
    IF COLON$CH THENN
       SCANP = SCANP + 2;
       IF DIG$CH THENN
          CALL FMOVE(1,SCANP,.MSG$BUF(2));
       ENDIF
    ENDIF
    CALL FMOVE(16,.MSG$BUF,.FILE$TO$EXECUTE);
    SCANP = TMP$PTR;
    CALL OPENO(.MSG$BUF);
    CALL CHK$STATUS(.('cannot open .cs file',0));
  END OPEN$CONSOLE$FILE;
  
  MAKE$RESTORE$COMMAND: PROC;
    OBUFP = .MSG$BUF;
    CALL SEEK(1,0,.BLOKNO,.BYTENO,.STATUS);
    IF STATUS <> 0 THENN
       BLOKNO,BYTENO = 0;
    ENDIF
    CALL FMOVE(15,.INVOK$NAME,OBUFP);
    OBUFP = OBUFP + 15;
    CALL OUTPRINT(.(' RESTORE ',0));
    CALL FMOVE(15,.BLANK$STR,OBUFP);
    CALL WHOCI(OBUFP);
    OBUFP = OBUFP + 15;
    CALL OUTCHAR('(');
    CALL OUT$DEC$R(BLOKNO,5);
    CALL OUTCHAR(',');
    CALL OUT$DEC$R(BYTENO,5);
    CALL OUTPRINT(.(')',CR,LF,0));
    CALL WRITEO(.MSG$BUF,OBUFP-.MSG$BUF);
  END MAKE$RESTORE$COMMAND;
  
  comtrace DCL PROC$NAME (*) BYTE DATA('output$list',0);          /* opt */
  comtrace CALL BEG$PR$DEBUG(.PROC$NAME,1,.NULL$PROC);            /* opt */
  CALL READ$DIRECTORY(DIR$TO$SEARCH);
  CALL OPEN$CONSOLE$FILE;
  TMP$NAME$INDEX = 0;
  DO WHILE TMP$NAME$INDEX <= NAME$INDEX;
     TMP$FILL$INDEX = 0;
     DO WHILE TMP$FILL$INDEX <= FILL$INDEX;
        CALL FILL$NAME(TMP$NAME$INDEX,TMP$FILL$INDEX);
        TMP$FILL$INDEX = TMP$FILL$INDEX + 1;
     ENDDO
     TMP$NAME$INDEX = TMP$NAME$INDEX + 1;
     CALL WRITEO(.TEMPLATE,LENGTH$TO$WRITE$FROM$TEMPLATE);
  ENDDO
  CALL WRITEO(.(CR,LF),2);
  CALL MAKE$RESTORE$COMMAND;
  CALL CLOSEO;
  IF NOT HALT$FLAG THENN
     CALL CONS(.FILE$TO$EXECUTE,.(':CO: '));
  ENDIF
  comtrace CALL END$PR$DEBUG(.PROC$NAME,1,.NULL$PROC);         /* opt */
END OUTPUT$LIST;

/*********************************************************
         D E B U G G I N G   P R O C E D U R E S
**********************************************************/

/*
PRINTLIST: PROC;
  DCL TMP$INDEX ADDRESS;
  TMP$INDEX = 0;
  DO WHILE TMP$INDEX <= NAMEINDEX;
     DO;
       DCL SPACE(7) BYTE;
       SPACE(6) = NULL;
       CALL FMOVE(6,.NAMELIST(TMP$INDEX).NAME,.SPACE);
       CALL PRINT$CR(.SPACE);
       IF NAMELIST(TMPINDEX).TYPE < 3 THENN
          DO CASE NAMELIST(TMPINDEX).TYPE;
             DO;
                CALL PRINT$CR(.('name$dot$type',0));
             ENDDO
             DO;
                CALL PRINT$CR(.('name$dot$ext$type',0));
             ENDDO
             DO;
                CALL PRINT$CR(.('name$only$type',0));
             ENDDO
          ENDDO
       ELSIF NAMELIST(TMPINDEX).TYPE = UNKNOWN$TYPE THENN
          CALL PRINT$CR(.('unknown$type',0));
       ELLSE
          CALL PRINT$CR(.('bad name type',0));
       ENDIF
       TMP$INDEX = TMP$INDEX + 1;
     ENDDO
  ENDDO 
  OBUFP = .MSG$BUF;
  CALL OUT$DEC$R(NAME$INDEX+1,5);
  CALL OUT$PRINT(.(' filenames read from list',0));
  CALL OUT$CHAR(NULL);
  CALL PRINT$CR(.MSG$BUF);
END PRINTLIST; 
*/

/*
BULL: PROC; 
  DCL TMP$INDEX BYTE;
  TMP$INDEX = 0; 
  OBUFP = .MSG$BUF;
  CALL OUT$DEC$R(FILL$INDEX+1,3);
  CALL OUT$PRINT(.(' substitutions',0));
  CALL OUT$CHAR(NULL);
  CALL PRINT$CR(.MSG$BUF);
  DO WHILE TMP$INDEX <= FILL$INDEX;
     IF FILL$ARRAY(TMP$INDEX).TYPE < 4 THENN
        DO CASE FILL$ARRAY(TMP$INDEX).TYPE;
          CALL PRINT$CR(.('   %0 type',0));
          CALL PRINT$CR(.('   %0. type',0));
          CALL PRINT$CR(.('   %0.ext type',0));
          CALL PRINT$CR(.('   #0 type',0));
        ENDDO
     ELSIF FILL$ARRAY(TMP$INDEX).TYPE = UNKNOWN$TYPE  THENN
        CALL PRINT$CR(.('   unknown type',0));
     ELLSE
       CALL PRINT$CR(.('bogus type',0));
     ENDIF
     TMP$INDEX = TMP$INDEX + 1;
  ENDDO
  CALL PRINT$CR(.(' expanded template:',0));
  CALL PRINT$CR(.TEMPLATE);
END BULL;
*/

$EJECT

/******************************************************
     C O M M A N D    L I N E  P R O C E S S I N G
                 P R O C E D U R E S
******************************************************/

PROCESS$COMMAND$LINE: PROC;
   GET$TEMPLATE$FILENAME: PROC;
     DCL STAT$MSG (*) BYTE DATA('process$command$line',0);
     comtrace DCL PROC$NAME (*) BYTE DATA('get$template$filename',0);/* opt */
     comtrace CALL BEG$PR$DEBUG(.PROC$NAME,2,.NULL$PROC);            /* opt */
     CALL RESCAN(1,.STATUS);  
     CALL CHK$STATUS(.STAT$MSG);
     CALL READC(.READBUF,128);  
     CALL CHK$STATUS(.STAT$MSG);
     SCANP = DEBLANK(.READBUF);
     DEBUG$FLAG = SCANMATCH(.('DEBUG',0));
     SCANP = DEBLANK(SCANP);
     SCANP$TMP = SCANP;
     CALL SCANWHILE(.FILE$CH);
     CALL FMOVE(SCANP-SCANP$TMP,SCANP$TMP,.INVOK$NAME);
     SCANP = DEBLANK(SCANP);
     HALT$FLAG = SCANMATCH(.('HALT!',0));
     SCANP = DEBLANK(SCANP);
     IF         SCANMATCH(.('?',0))         THENN 
        DCL VERNO (*) BYTE DATA('xlate2 X004',0);
        CALL PRINT$CR$EXIT(.VERNO);
     ELSIF      SCANMATCH(.('RESTORE',0))   THENN
        CALL RESTORE;
     ENDIF
     CALL OPENI(DEBLANK(SCANP));
     CALL CHK$STATUS(.('cannot open template file',0));
     CALL SCANWHILE(.FILE$CH);
     SCANP = DEBLANK(SCANP);
     IF DIG$CH THENN
        DIR$TO$SEARCH = SCANBYTE;
        SCANP = DEBLANK(SCANP+1);
     ELLSE
        CALL PRINT$CR$EXIT(.('missing drive #',0));
     ENDIF
     comtrace CALL END$PR$DEBUG(.PROC$NAME,2,.NULL$PROC);            /* opt */
   END GET$TEMPLATE$FILENAME;
   
   MAKE$LIST: PROC;
      DCL FLAG BYTE;
      
         ADD$FILENAME: PROC BYTE;
         
         ADD$DRIVE: PROC (N$INDEX);
            DCL N$INDEX ADDRESS;
            IF COLON$CH THENN
               CALL FMOVE(4,SCANP,.NAME$LIST(N$INDEX).DRIVE);
               SCANP = SCANP + 4;
            ELLSE
               CALL FMOVE(4,.DR$STR,.NAME$LIST(N$INDEX).DRIVE);
               CALL FMOVE(1,.DIR$TO$SEARCH,.NAME$LIST(N$INDEX).DRIVE(2));
            ENDIF
         END ADD$DRIVE;

         ADD$NAME: PROC (N$INDEX);
            DCL (N$INDEX,LEN$NAME$PART)  ADDRESS;
            IF (LEN$NAME$PART :=LENGTH$OF(.LET$OR$DIG$CH)) > 6  THENN
               CALL PRINT$CR(.('name too long: ',0));
               SCANP = SCANP + 7; 
               SCANBYTE = NULL;
               CALL PRINT$CR$EXIT(SCANP-7);
            ELLSE
               CALL FMOVE(6,.NULL$STRING,.NAMELIST(N$INDEX).NAME);
               CALL FMOVE(LEN$NAME$PART,SCANP,.NAME$LIST(N$INDEX).NAME);
               /* set type field in the event that it will be used */
               SCANP = SCANP + LEN$NAME$PART;
               IF        BLANK$CH OR TERM$CH             THENN
                  NAMELIST(N$INDEX).TYPE = NAME$ONLY$TYPE;
               ELSIF      DOT$CH                 THENN
                  SCAN$P = SCANP + 1;
                  IF    LET$OR$DIG$CH     THENN
                     NAMELIST(N$INDEX).TYPE = NAME$DOT$EXT$TYPE;
                  ELLSE
                     NAMELIST(N$INDEX).TYPE = NAME$DOT$TYPE;
                  ENDIF
               ELLSE
                  CALL PRINT$CR$EXIT(.('a blank or dot must follow name part',0));
               ENDIF
            ENDIF
         END ADD$NAME; 

         ADD$EXT: PROC (N$INDEX);
            DCL (N$INDEX,LEN$EXT) ADDRESS;
            IF                    LET$OR$DIG$CH                    THENN
               IF (LEN$EXT := LENGTH$OF(.LET$OR$DIG$CH)) > 3 THENN
                  CALL PRINT$CR$EXIT(.('ext > 3 chars',0));
               ELLSE
                  CALL FMOVE(3,.NULL$STRING,.NAME$LIST(N$INDEX).EXT);
                  CALL FMOVE(LEN$EXT,SCANP,.NAME$LIST(N$INDEX).EXT);
                  SCANP = SCANP + LEN$EXT;
               ENDIF
            ENDIF
         END ADD$EXT;

$EJECT
         comtrace DCL PROC$NAME (*) BYTE DATA('add$filename',0);    /* opt */
         comtrace CALL BEG$PR$DEBUG(.PROC$NAME,3,.NULL$PROC);       /* opt */ 
         SCANP = DEBLANK(SCANP);
         IF TERM$CH                              THENN
            comtrace CALL END$PR$DEBUG(.PROC$NAME,3,.NULL$PROC);    /* opt */
            RETURN DONE;
         ELSIF SCANMATCH(.('&',0))     THENN
            CALL ENFORCE$NO$TOKENS;
            CALL PRINT(.('**',0));
            CALL READC(.READBUF,128);
            SCANP = DEBLANK(.READBUF);
            comtrace CALL END$PR$DEBUG(.PROC$NAME,3,.NULL$PROC);    /* opt */
            RETURN NEW$LINE;
         ELSIF FILE$CH                 THENN 
            CALL ADD$DRIVE(NAME$INDEX);
            CALL ADD$NAME(NAME$INDEX);
            CALL ADD$EXT(NAME$INDEX);
            NAME$INDEX = NAME$INDEX + 1;
            comtrace CALL END$PR$DEBUG(.PROC$NAME,3,.NULL$PROC);    /* opt */
            RETURN NAME$ADDED;
         ELLSE                                          /* syntax chk opt */
            DCL TEMP$PTR ADDRESS;
            TEMP$PTR = SCANP;
            DO WHILE NOT(BLANK$CH) AND NOT(TERM$CH);
               SCANP = SCANP + 1;
            ENDDO
            SCAN$BYTE = NULL;
            CALL PRINT(TEMP$PTR);
            CALL PRINT$CR$EXIT(.(' not a filename',0));
         ENDIF 
         comtrace CALL END$PR$DEBUG(.PROC$NAME,3,.NULL$PROC);       /* opt */
      END ADDFILENAME;
        
      comtrace DCL PROC$NAME (*) BYTE DATA('make$list',0);          /* opt */ 
      comtrace CALL BEG$PR$DEBUG(.PROC$NAME,2,.NULL$PROC);          /* opt */
      FLAG = NOT DONE;
      DO WHILE FLAG <> DONE;
         FLAG = ADD$FILENAME;
      ENDDO 
      IF NAME$INDEX = 0 THENN
         CALL PRINT$CR$EXIT(.('0 filenames on command line',0));
      ELLSE
         NAME$INDEX = NAME$INDEX - 1;
      ENDIF
      comtrace CALL END$PR$DEBUG(.PROC$NAME,2,.NULL$PROC);          /* opt */
   END MAKE$LIST; 

   comtrace DCL PROC$NAME (*) BYTE DATA('process$command$line',0);  /* opt */
   comtrace CALL BEG$PR$DEBUG(.PROC$NAME,1,.NULL$PROC);             /* opt */
   CALL GET$TEMPLATE$FILENAME;
   CALL MAKE$LIST;
   comtrace CALL END$PR$DEBUG(.PROC$NAME,1,.NULL$PROC);             /* opt */
END PROCESS$COMMAND$LINE;

$EJECT

/*********************************************************
     F I R S T      E X E C U T A B L E      C O D E
*********************************************************/

CALL FIRST$INIT;
CALL PROCESS$COMMAND$LINE;
CALL BUILD$TEMPLATE;
CALL OUTPUT$LIST;
/* CALL PRINTLIST; CALL BULL; */       /* debug opt */
CALL EXIT;

END XLATE2$MOD;
       
sys1/makefile
# common makefile info
ROOT=../../..
TARGETS = sys1.lib
unexport ISIS_F1

include $(ROOT)/tools/isis.mk

REF = $(call ipath,toolbox,1.0)
ASM80 = 2.0


OBJS =	ver08.obj ci.obj co.obj csts.obj iochk.obj iodef.obj ioset.obj\
	lo.obj memck.obj po.obj ri.obj cons.obj sblok1.obj sblok2.obj\
	sblok3.obj sblok9.obj sbloki.obj sbloku.obj sbyte1.obj sbyte2.obj\
	sbyte3.obj sbyte9.obj sbytei.obj sbyteu.obj attr.obj backci.obj\
	del.obj load.obj open1.obj open2.obj open3.obj open9.obj openi.obj\
	openo.obj openu.obj readc.obj renam.obj seek.obj whoci.obj\
	whoco.obj isiscl.obj

all::
	$(MAKE) $(TARGETS)

sys1.lib: $(OBJS)
	$(call lib,$@,$^)
sys1/sys1_all.src
?attr.asm
	name attr
	public	ATTR
	extrn	ZZXCHG, STATUS

	dseg
pathp:	dw	0
attrib:	dw	0
onoff:	dw	0
	dw	STATUS

	cseg
ATTR:	mvi	a,1
	ana	e
	sta	onoff
	xra	e
	rrc
	sta	attrib
	lxi	h,pathp + 1
	mov	m,b
	dcx	h
	mov	m,c
	mvi	a,0AH
	jmp	ZZXCHG

	end
?backci.asm
	name	BACKCI
	extrn	ISISCL, STATUS
	public	BACKCI
	
RESCAN	equ	11
	
	DSEG
RSARG:	dw	1	; rescan args - CI
	dw	STATUS	; status$p


	CSEG

BACKCI:	lxi	d,RSARG
	mvi	c,RESCAN
	jmp	ISISCL

	end
?ci.asm
	name	ci
	public	CI

CI	equ	0F803H
	end
?co.asm
	name	co
	public	CO

CO	equ	0F809H
	end
?cons.asm
	name	cons
	public	CONS
	extrn	ZZRENA

	cseg
CONS:	mvi	a,8
	jmp	ZZRENA
	end

?csts.asm
	name	csts
	public	CSTS

CSTS	equ	0F812H
	end
?del.asm
	name	DEL
	extrn	STATUS, ZZXCHG
	public	DEL

IDELET	EQU	2

	DSEG
pathp:	dw	0		; path$p
	dw	STATUS		; status$p
	
	CSEG

DEL:	lxi	h,pathp+1
	mov	m,b
	dcx	h
	mov	m,c
	mvi	a,IDELET
	jmp	ZZXCHG

	end
?iochk.asm
	name	iochk
	public	IOCHK

IOCHK	equ	0F815H
	end
?iodef.asm
	name	iodef
	public	IODEF

IODEF	equ	0F81EH
	end
?ioset.asm
	name	ioset
	public	IOSET

IOSET	equ	0F818H
	end

?isiscl.asm
	name ISISCL
	public STATUS, FATAL, ERRED, REPORT, ACTUAL, ZZCLOS
	public ZZREAD, ZZOPEN, EX, ERR, ISISCL, ZZXCHG, ZZLOD2
	public ZZWRIT, ISIS

	ASEG
ISIS	equ	40H

IOPEN	equ	0
ICLOSE	equ	1
IREAD	equ	3
IWRITE	equ	4
IEXIT	equ	9
IERROR	equ	12

	DSEG
ACTUAL:	dw	0
REPORT:	db	0FFH
ERRED:	db	0
FATAL:	db	0
STATUS:	dw	0
EXITV:	dw	STATUS


	CSEG
ZZWRIT:
	mvi	a,IWRITE
ZZLOD1:
	mov	m,d	; stuff the count
	dcx	h
	mov	m,e
	dcx	h

ZZLOD2: mov	m,b	; stuff the buff$p
	dcx	h
	mov	m,c
	dcx	h	; back up to conn arg
	dcx	h
ZZXCHG:			; hl -> isis arg ptr
	xchg
	mov	c,a	; isis cmd

ISISCL: call	ISIS
	lhld	STATUS
	mov	a,h
	ora	l
	rz
	mvi	a,0FFH	; flag we have an error
	sta	ERRED
	lda	REPORT	; continue if no reporting
	rar
	rnc

ERR:	mvi	c,IERROR
	lxi	d,STATUS
	call	ISIS
	lda	FATAL		; done if error is considered fatal
	rar
	rnc

EX:	mvi	c,IEXIT
	lxi	d,EXITV		; safe pointer
	call	ISIS
	rst	0		; reboot

ZZOPEN: sub	a		; IOPEN
	jmp	ZZLOD2

ZZREAD: mvi	a,IREAD
	jmp	ZZLOD1

ZZCLOS:	mvi	c,ICLOSE
	jmp	ISISCL


	end
?lo.asm
	name	lo
	public	LO

LO	equ	0F80FH
	end
?load.asm
	name	load
	public	LDEBUG, LOADGO, LOADOV, ENTRY
	extrn	ZZXCHG, STATUS

	dseg
pathp:	dw	0
offset:	dw	0
switch:	dw	0
entryp:	dw	ENTRY
statp:	dw	STATUS

ENTRY:	dw	0

	cseg
LDEBUG:	mvi	a,2
	jmp	ldcom

LOADGO:	mvi	a,1
	jmp	ldcom
LOADOV:	sub	a

ldcom:
	sta	switch
	lxi	h,pathp + 1
	mov	m,b
	dcx	h
	mov	m,c
	mvi	a,6
	jmp	ZZXCHG

	end
?memck.asm
	name	MEMCK
	public	MEMCK
	CSEG
MEMCK:	call	0F81BH
	mov	h,b
	mov	l,a
	ret

	end
?open1.asm
	name	OPEN1

	extrn	STATUS, ACTUAL, ZZOPEN, ZZCLOS, ZZREAD, ZZWRIT
	public	AFTN1, FNAME1, WRITE1, READ1, CLOSE1, ROPEN1, OPEN1

	DSEG
CONNP:	dw	AFTN1	; args for open
FNAME1:	dw	0	; path$p
ACCESS:	dw	0	; access
	dw	0	; echo
	dw	STATUS	; status$p

CONNC:	dw	0	; args for close
	dw	STATUS	; status$p

CONNR:	dw	1	; args for read
	dw	0	; buff$p
CNTR:	dw	0	; count
	dw	ACTUAL	; actual$p
	dw	STATUS	; status$p

AFTN1:	dw	0	; args for write
	dw	0	; buff$p
CNTW:	dw	0	; count
	dw	STATUS	; status$p


	CSEG

OPEN1:  lxi	h,ACCESS
	mov	m,e
	dcx	h
	call	ZZOPEN

ROPEN1: lhld	AFTN1	; update 
	shld	CONNR
	shld	CONNC
	ret

CLOSE1: lxi	d,CONNC
	jmp	ZZCLOS

READ1:  lxi	h,CNTR + 1
	jmp	ZZREAD

WRITE1: lxi	h,CNTW + 1
	jmp	ZZWRIT



	end
?open2.asm
	name	OPEN2

	extrn	STATUS, ACTUAL, ZZOPEN, ZZCLOS, ZZREAD, ZZWRIT
	public	AFTN2, FNAME2, WRITE2, READ2, CLOSE2, ROPEN2, OPEN2

	DSEG
CONNP:	dw	AFTN2	; args for open
FNAME2:	dw	0	; path$p
ACCESS:	dw	0	; access
	dw	0	; echo
	dw	STATUS	; status$p

CONNC:	dw	0	; args for close
	dw	STATUS	; status$p

CONNR:	dw	1	; args for read
	dw	0	; buff$p
CNTR:	dw	0	; count
	dw	ACTUAL	; actual$p
	dw	STATUS	; status$p

AFTN2:	dw	0	; args for write
	dw	0	; buff$p
CNTW:	dw	0	; count
	dw	STATUS	; status$p


	CSEG

OPEN2:  lxi	h,ACCESS
	mov	m,e
	dcx	h
	call	ZZOPEN

ROPEN2: lhld	AFTN2	; update 
	shld	CONNR
	shld	CONNC
	ret

CLOSE2: lxi	d,CONNC
	jmp	ZZCLOS

READ2:  lxi	h,CNTR + 1
	jmp	ZZREAD

WRITE2: lxi	h,CNTW + 1
	jmp	ZZWRIT

	end

?open3.asm
	name	OPEN3

	extrn	STATUS, ACTUAL, ZZOPEN, ZZCLOS, ZZREAD, ZZWRIT
	public	AFTN3, FNAME3, WRITE3, READ3, CLOSE3, ROPEN3, OPEN3

	DSEG
CONNP:	dw	AFTN3	; args for open
FNAME3:	dw	0	; path$p
ACCESS:	dw	0	; access
	dw	0	; echo
	dw	STATUS	; status$p

CONNC:	dw	0	; args for close
	dw	STATUS	; status$p

CONNR:	dw	1	; args for read
	dw	0	; buff$p
CNTR:	dw	0	; count
	dw	ACTUAL	; actual$p
	dw	STATUS	; status$p

AFTN3:	dw	0	; args for write
	dw	0	; buff$p
CNTW:	dw	0	; count
	dw	STATUS	; status$p


	CSEG

OPEN3:  lxi	h,ACCESS
	mov	m,e
	dcx	h
	call	ZZOPEN

ROPEN3: lhld	AFTN3	; update 
	shld	CONNR
	shld	CONNC
	ret

CLOSE3: lxi	d,CONNC
	jmp	ZZCLOS

READ3:  lxi	h,CNTR + 1
	jmp	ZZREAD

WRITE3: lxi	h,CNTW + 1
	jmp	ZZWRIT

	end
?open9.asm
	name	OPEN9

	extrn	STATUS, ACTUAL, ZZOPEN, ZZCLOS, ZZREAD, ZZWRIT
	public	AFTN9, FNAME9, WRITE9, READ9, CLOSE9, ROPEN9, OPEN9

	DSEG
CONNP:	dw	AFTN9	; args for open
FNAME9:	dw	0	; path$p
ACCESS:	dw	0	; access
	dw	0	; echo
	dw	STATUS	; status$p

CONNC:	dw	0	; args for close
	dw	STATUS	; status$p

CONNR:	dw	1	; args for read
	dw	0	; buff$p
CNTR:	dw	0	; count
	dw	ACTUAL	; actual$p
	dw	STATUS	; status$p

AFTN9:	dw	0	; args for write
	dw	0	; buff$p
CNTW:	dw	0	; count
	dw	STATUS	; status$p


	CSEG

OPEN9:  lxi	h,ACCESS
	mov	m,e
	dcx	h
	call	ZZOPEN

ROPEN9: lhld	AFTN9	; update 
	shld	CONNR
	shld	CONNC
	ret

CLOSE9: lxi	d,CONNC
	jmp	ZZCLOS

READ9:  lxi	h,CNTR + 1
	jmp	ZZREAD

WRITE9: lxi	h,CNTW + 1
	jmp	ZZWRIT



	end

?openi.asm
	name	OPENI
	extrn	STATUS, ACTUAL, ZZOPEN, ZZCLOS, ZZREAD
	public	AFTNI, FNAMEI, READI, CLOSEI, ROPENI, OPENI

	DSEG
CONNP:	dw	AFTNI	; args for open
FNAMEI:	dw	0
	dw	1	; access
	dw	0	; echo
	dw	STATUS	; status$p

CONNC:	dw	0	; args for close
	dw	STATUS

AFTNI:	dw	1	; args for read - conn - default CI
	dw	0	; buff$p
CNTR:	dw	0	; count
	dw	ACTUAL	; actual$p
	dw	STATUS	; status$p

	CSEG
OPENI:	lxi	h,FNAMEI + 1
	call	ZZOPEN

ROPENI:	lhld	AFTNI
	shld	CONNC
	ret

CLOSEI:	lxi	d,CONNC
	jmp	ZZCLOS

READI:	lxi	h, CNTR + 1
	jmp	ZZREAD

	end


?openo.asm
	name	OPENO
	extrn	STATUS, ACTUAL, ZZOPEN, ZZCLOS, ZZWRIT
	public	AFTNO, FNAMEO, WRITEO, CLOSEO, ROPENO, OPENO

	DSEG
CONNP:	dw	AFTNO	; args for open
FNAMEO:	dw	0
	dw	2	; access
	dw	0	; echo
	dw	STATUS	; status$p

CONNC:	dw	0	; args for close
	dw	STATUS

AFTNO:	dw	0	; args for write - conn - default CO
	dw	0	; buff$p
CNTW:	dw	0	; count
	dw	STATUS	; status$p

	CSEG

OPENO:	lxi	h,FNAMEO + 1
	call	ZZOPEN

ROPENO:	lhld	AFTNO
	shld	CONNC
	ret

CLOSEO:	lxi	d,CONNC
	jmp	ZZCLOS

WRITEO:	lxi	h,CNTW + 1
	jmp	ZZWRIT

	end
?openu.asm
	name	OPENU

	extrn	STATUS, ACTUAL, ZZOPEN, ZZCLOS, ZZREAD, ZZWRIT
	public	AFTNU, FNAMEU, WRITEU, READU, CLOSEU, ROPENU, OPENU

	DSEG
CONNP:	dw	AFTNU	; args for open
FNAMEU:	dw	0	; path$p
ACCESS:	dw	3	; access
	dw	0	; echo
	dw	STATUS	; status$p

CONNC:	dw	0	; args for close
	dw	STATUS	; status$p

CONNR:	dw	1	; args for read
	dw	0	; buff$p
CNTR:	dw	0	; count
	dw	ACTUAL	; actual$p
	dw	STATUS	; status$p

AFTNU:	dw	0	; args for write
	dw	0	; buff$p
CNTW:	dw	0	; count
	dw	STATUS	; status$p


	CSEG

OPENU:  lxi	h,ACCESS-1
	call	ZZOPEN

ROPENU: lhld	AFTNU	; update 
	shld	CONNR
	shld	CONNC
	ret

CLOSEU: lxi	d,CONNC
	jmp	ZZCLOS

READU:  lxi	h,CNTR + 1
	jmp	ZZREAD

WRITEU: lxi	h,CNTW + 1
	jmp	ZZWRIT

	end
?po.asm
	name	po
	public	PO

PO	equ	0F80CH
	end
?readc.asm
	name READC
	extrn	STATUS, ACTUAL, ZZREAD, ZZWRIT
	public	READC, WRITEC

	DSEG
	dw	1	; read args - CI
	dw	0	; buff$p
CNTR:	dw	0	; count
	dw	ACTUAL
	dw	STATUS

	dw	0	; write args - CO
	dw	0	; buff$p
CNTW:	dw	0	; count
	dw	STATUS

	CSEG
READC:	lxi	h,CNTR + 1
	jmp	ZZREAD

WRITEC:	lxi	h,CNTW + 1
	jmp	ZZWRIT

	end
?renam.asm
	name	renam
	public	RENAM, ZZRENA
	extrn	ZZXCHG, STATUS

	dseg
oldp:	dw	0
newp:	dw	0
statp:	dw	STATUS

	cseg
RENAM:	mvi	a,7

ZZRENA:	lxi	h,newp + 1	; de = new$p, bc = old$p
	mov	m,d
	dcx	h
	mov	m,e
	dcx	h
	mov	m,b
	dcx	h
	mov	m,c
	jmp	ZZXCHG

	end
?ri.asm
	name	ri
	public	RI

RI	equ	0F806H
	end
?sblok1.asm
	name	SBLOK1
	extrn	AFTN1
	extrn	ZZBLOK
	extrn	ISIS
	public	SBLOK1

	cseg
sblok1:	lxi	h,AFTN1
	jmp	ZZBLOK

	end

?sblok2.asm
	name	SBLOK2
	extrn	AFTN2
	extrn	ZZBLOK
	extrn	ISIS
	public	SBLOK2

	cseg
sblok2:	lxi	h,AFTN2
	jmp	ZZBLOK

	end


?sblok3.asm
	name	SBLOK3
	extrn	AFTN3
	extrn	ZZBLOK
	extrn	ISIS
	public	SBLOK3

	cseg
sblok3:	lxi	h,AFTN3
	jmp	ZZBLOK

	end


?sblok9.asm
	name	SBLOK9
	extrn	AFTN9
	extrn	ZZBLOK
	extrn	ISIS
	public	SBLOK9

	cseg
sblok9:	lxi	h,AFTN9
	jmp	ZZBLOK

	end


?sbloki.asm
	name	SBLOKI
	extrn	AFTNI
	extrn	ZZBLOK
	extrn	ISIS
	public	SBLOKI

	cseg
sblokI:	lxi	h,AFTNI
	jmp	ZZBLOK

	end


?sbloku.asm
	name	SBLOKU
	extrn	AFTNU
	extrn	ZZBLOK
	extrn	ISIS
	public	SBLOKU

	cseg
sblokU:	lxi	h,AFTNU
	jmp	ZZBLOK

	end


?sbyte1.asm
	name	SBYTE1
	extrn	AFTN1
	extrn	ZZBYTE
	extrn	ISIS
	public	SBYTE1

	cseg
sbyte1:	lxi	h,AFTN1
	jmp	ZZBYTE

	end
?sbyte2.asm
	name	SBYTE2
	extrn	AFTN2
	extrn	ZZBYTE
	extrn	ISIS
	public	SBYTE2

	cseg
sbyte2:	lxi	h,AFTN2
	jmp	ZZBYTE

	end

?sbyte3.asm
	name	SBYTE3
	extrn	AFTN3
	extrn	ZZBYTE
	extrn	ISIS
	public	SBYTE3

	cseg
sbyte3:	lxi	h,AFTN3
	jmp	ZZBYTE

	end

?sbyte9.asm
	name	SBYTE9
	extrn	AFTN9
	extrn	ZZBYTE
	extrn	ISIS
	public	SBYTE9

	cseg
sbyte9:	lxi	h,AFTN9
	jmp	ZZBYTE

	end

?sbytei.asm
	name	SBYTEI
	extrn	AFTNI
	extrn	ZZBYTE
	extrn	ISIS
	public	SBYTEI

	cseg
sbyteI:	lxi	h,AFTNI
	jmp	ZZBYTE

	end

?sbyteu.asm
	name	SBYTEU
	extrn	AFTNU
	extrn	ZZBYTE
	extrn	ISIS
	public	SBYTEU

	cseg
sbyteU:	lxi	h,AFTNU
	jmp	ZZBYTE

	end

?seek.asm
	name	seek
	public	ZZBLOK, SBLOK, ZZBYTE, SBYTE
	public	BLOKNO, BYTENO
	extrn	ZZXCHG
	extrn	STATUS

	dseg
conn:	dw	0
mode:	dw	0
blkp:	dw	BLOKNO
bytp:	dw	BYTENO
statp:	dw	STATUS

BLOKNO:	dw	0
BYTENO:	dw	0

; sblok: procedure(offset, conn) public; declare offset address, conn byte; end;
; sbyte: procedure(offset, conn) public; declare offset address, conn byte; end;

	cseg
conmod: mov	a,e		; set conn
	sta	conn
	call	getmod		; set mode
	sta	mode
	lxi	h,0		; useful 0
	ret

getmod: sub	a		; check for -ve offset
	add	b
	jm	seekbw
	ora	c
	rz			; return mode seek return for 0 offset
	call	chkmax
	mvi	a,3		; seek forward
	rnz
	inr	a		; seek eof
	ret

seekbw: cma			; not offset
	mov	b,a
	mov	a,c
	cma
	mov	c,a
	call	chkmax
	inx	b		; make offset full negate
	mvi	a,1		; seek backwards
	rnz			; not max
	inr	a		; seek abs -> rewind
	lxi	b,0		; offset = 0
	ret

chkmax: mvi	a,0FFH		; return 0 if max offset
	cmp	c
	rnz
	mvi	a,7FH
	cmp	b
	ret

ZZBLOK:	mov	e,m		; pickup conn from *hl

SBLOK:	call	conmod
	shld	BYTENO		; byte = 0
	dad	b
	shld	BLOKNO		; block = offset
seekcm:
	mvi	a,5
	lxi	h,conn
	jmp	ZZXCHG

ZZBYTE:	mov	e,m		; pickup conn from *hl

SBYTE:	call	conmod
	shld	BLOKNO		; block = 0
	dad	b
	shld	BYTENO		; byte = offset
	jmp	seekcm

	end
?ver08.asm
	name ver08
	end
?whoci.asm
	name	whoci
	public	WHOCI
	extrn	ZZLOD2, STATUS

	dseg
ciconn:	dw	1
buffp:	dw	0
statp:	dw	STATUS

	cseg
WHOCI:	mvi	a,0DH
	lxi	h,buffp + 1
	jmp	ZZLOD2
	end
?whoco.asm
	name	whoco
	public WHOCO
	extrn	ZZLOD2, STATUS

	dseg
coconn:	dw	0
buffp:	dw	0
statp:	dw	STATUS

	cseg
WHOCO:	mvi	a,0DH
	lxi	h,buffp + 1
	jmp	ZZLOD2

	end
sys2/makefile
# common makefile info
ROOT=../../..
TARGETS = sys2.lib
unexport ISIS_F1

include $(ROOT)/tools/isis.mk

REF = $(call ipath,toolbox,1.0)

OBJS =	ver10.obj ci.obj co.obj csts.obj iochk.obj iodef.obj ioset.obj lo.obj\
	memck.obj po.obj ri.obj cons.obj sblok1.obj sblok2.obj sblok3.obj\
       	sblok9.obj sbloki.obj sbloku.obj sbyte1.obj sbyte2.obj sbyte3.obj\
	sbyte9.obj sbytei.obj sbyteu.obj attr.obj backci.obj del.obj load.obj\
	open1.obj open2.obj open3.obj open9.obj openi.obj openo.obj openu.obj\
	readc.obj renam.obj seek.obj whoci.obj whoco.obj isiscl.obj

all::
	$(MAKE) $(TARGETS)

sys2.lib: $(OBJS)
	$(call lib,$@,$^)


sys2/sys2_all.src
?attr.asm
	name attr
	public	ATTR
	extrn	ZZXCHG, STATUS

	dseg
pathp:	dw	0
attrib:	dw	0
onoff:	dw	0
	dw	STATUS

	cseg
ATTR:	mvi	a,1
	ana	e
	sta	onoff
	xra	e
	rrc
	sta	attrib
	lxi	h,pathp + 1
	mov	m,b
	dcx	h
	mov	m,c
	mvi	a,0AH
	jmp	ZZXCHG

	end
?backci.asm
	name	BACKCI
	extrn	ISISCL, STATUS
	public	BACKCI
	
RESCAN	equ	11
	
	DSEG
RSARG:	dw	1	; rescan args - CI
	dw	STATUS	; status$p


	CSEG

BACKCI:	lxi	d,RSARG
	mvi	c,RESCAN
	jmp	ISISCL

	end
?ci.asm
	name	ci
	public	CI

CI	equ	0F803H
	end
?co.asm
	name	co
	public	CO

CO	equ	0F809H
	end
?cons.asm
	name	cons
	public	CONS
	extrn	ZZRENA

	cseg
CONS:	mvi	a,8
	jmp	ZZRENA
	end

?csts.asm
	name	csts
	public	CSTS

CSTS	equ	0F812H
	end
?del.asm
	name	DEL
	extrn	STATUS, ZZXCHG
	public	DEL

IDELET	EQU	2

	DSEG
pathp:	dw	0		; path$p
	dw	STATUS		; status$p
	
	CSEG

DEL:	lxi	h,pathp+1
	mov	m,b
	dcx	h
	mov	m,c
	mvi	a,IDELET
	jmp	ZZXCHG

	end
?iochk.asm
	name	iochk
	public	IOCHK

IOCHK	equ	0F815H
	end
?iodef.asm
	name	iodef
	public	IODEF

IODEF	equ	0F81EH
	end
?ioset.asm
	name	ioset
	public	IOSET

IOSET	equ	0F818H
	end

?isiscl.asm
	name ISISCL
	public STATUS, FATAL, ERRED, REPORT, ACTUAL, ZZCLOS
	public ZZREAD, ZZOPEN, EX, ERR, ISISCL, ZZXCHG, ZZLOD2
	public ZZWRIT, ISIS

	ASEG
ISIS	equ	40H

IOPEN	equ	0
ICLOSE	equ	1
IREAD	equ	3
IWRITE	equ	4
IEXIT	equ	9
IERROR	equ	12

	DSEG
ACTUAL:	dw	0
REPORT:	db	0FFH
ERRED:	db	0
FATAL:	db	0
STATUS:	dw	0
EXITV:	dw	STATUS


	CSEG
ZZWRIT:
	mvi	a,IWRITE
ZZLOD1:
	mov	m,d	; stuff the count
	dcx	h
	mov	m,e
	dcx	h

ZZLOD2: mov	m,b	; stuff the buff$p
	dcx	h
	mov	m,c
	dcx	h	; back up to conn arg
	dcx	h
ZZXCHG:			; hl -> isis arg ptr
	xchg
	mov	c,a	; isis cmd

ISISCL: call	ISIS
	lhld	STATUS
	mov	a,h
	ora	l
	rz
	mvi	a,0FFH	; flag we have an error
	sta	ERRED
	lda	REPORT	; continue if no reporting
	rar
	rnc

ERR:	mvi	c,IERROR
	lxi	d,STATUS
	call	ISIS
	lda	FATAL		; done if error is considered fatal
	rar
	rnc

EX:	mvi	c,IEXIT
	lxi	d,EXITV		; safe pointer
	call	ISIS
	rst	0		; reboot

ZZOPEN: sub	a		; IOPEN
	jmp	ZZLOD2

ZZREAD: mvi	a,IREAD
	jmp	ZZLOD1

ZZCLOS:	mvi	c,ICLOSE
	jmp	ISISCL


	end
?lo.asm
	name	lo
	public	LO

LO	equ	0F80FH
	end
?load.asm
	name	load
	public	LDEBUG, LOADGO, LOADOV, ENTRY
	extrn	ZZXCHG, STATUS

	dseg
pathp:	dw	0
offset:	dw	0
switch:	dw	0
entryp:	dw	ENTRY
statp:	dw	STATUS

ENTRY:	dw	0

	cseg
LDEBUG:	mvi	a,2
	jmp	ldcom

LOADGO:	mvi	a,1
	jmp	ldcom
LOADOV:	sub	a

ldcom:
	sta	switch
	lxi	h,pathp + 1
	mov	m,b
	dcx	h
	mov	m,c
	mvi	a,6
	jmp	ZZXCHG

	end
?memck.asm
	name	MEMCK
	public	MEMCK
	CSEG
MEMCK:	call	0F81BH
	mov	h,b
	mov	l,a
	ret

	end
?open1.asm
	name	OPEN1

	extrn	STATUS, ACTUAL, ZZOPEN, ZZCLOS, ZZREAD, ZZWRIT
	public	AFTN1, FNAME1, WRITE1, READ1, CLOSE1, ROPEN1, OPEN1

	DSEG
CONNP:	dw	AFTN1	; args for open
FNAME1:	dw	0	; path$p
ACCESS:	dw	0	; access
	dw	0	; echo
	dw	STATUS	; status$p

CONNC:	dw	0	; args for close
	dw	STATUS	; status$p

CONNR:	dw	1	; args for read
	dw	0	; buff$p
CNTR:	dw	0	; count
	dw	ACTUAL	; actual$p
	dw	STATUS	; status$p

AFTN1:	dw	0	; args for write
	dw	0	; buff$p
CNTW:	dw	0	; count
	dw	STATUS	; status$p


	CSEG

OPEN1:  lxi	h,ACCESS
	mov	m,e
	dcx	h
	call	ZZOPEN

ROPEN1: lhld	AFTN1	; update 
	shld	CONNR
	shld	CONNC
	ret

CLOSE1: lxi	d,CONNC
	jmp	ZZCLOS

READ1:  lxi	h,CNTR + 1
	jmp	ZZREAD

WRITE1: lxi	h,CNTW + 1
	jmp	ZZWRIT



	end
?open2.asm
	name	OPEN2

	extrn	STATUS, ACTUAL, ZZOPEN, ZZCLOS, ZZREAD, ZZWRIT
	public	AFTN2, FNAME2, WRITE2, READ2, CLOSE2, ROPEN2, OPEN2

	DSEG
CONNP:	dw	AFTN2	; args for open
FNAME2:	dw	0	; path$p
ACCESS:	dw	0	; access
	dw	0	; echo
	dw	STATUS	; status$p

CONNC:	dw	0	; args for close
	dw	STATUS	; status$p

CONNR:	dw	1	; args for read
	dw	0	; buff$p
CNTR:	dw	0	; count
	dw	ACTUAL	; actual$p
	dw	STATUS	; status$p

AFTN2:	dw	0	; args for write
	dw	0	; buff$p
CNTW:	dw	0	; count
	dw	STATUS	; status$p


	CSEG

OPEN2:  lxi	h,ACCESS
	mov	m,e
	dcx	h
	call	ZZOPEN

ROPEN2: lhld	AFTN2	; update 
	shld	CONNR
	shld	CONNC
	ret

CLOSE2: lxi	d,CONNC
	jmp	ZZCLOS

READ2:  lxi	h,CNTR + 1
	jmp	ZZREAD

WRITE2: lxi	h,CNTW + 1
	jmp	ZZWRIT

	end

?open3.asm
	name	OPEN3

	extrn	STATUS, ACTUAL, ZZOPEN, ZZCLOS, ZZREAD, ZZWRIT
	public	AFTN3, FNAME3, WRITE3, READ3, CLOSE3, ROPEN3, OPEN3

	DSEG
CONNP:	dw	AFTN3	; args for open
FNAME3:	dw	0	; path$p
ACCESS:	dw	0	; access
	dw	0	; echo
	dw	STATUS	; status$p

CONNC:	dw	0	; args for close
	dw	STATUS	; status$p

CONNR:	dw	1	; args for read
	dw	0	; buff$p
CNTR:	dw	0	; count
	dw	ACTUAL	; actual$p
	dw	STATUS	; status$p

AFTN3:	dw	0	; args for write
	dw	0	; buff$p
CNTW:	dw	0	; count
	dw	STATUS	; status$p


	CSEG

OPEN3:  lxi	h,ACCESS
	mov	m,e
	dcx	h
	call	ZZOPEN

ROPEN3: lhld	AFTN3	; update 
	shld	CONNR
	shld	CONNC
	ret

CLOSE3: lxi	d,CONNC
	jmp	ZZCLOS

READ3:  lxi	h,CNTR + 1
	jmp	ZZREAD

WRITE3: lxi	h,CNTW + 1
	jmp	ZZWRIT

	end
?open9.asm
	name	OPEN9

	extrn	STATUS, ACTUAL, ZZOPEN, ZZCLOS, ZZREAD, ZZWRIT
	public	AFTN9, FNAME9, WRITE9, READ9, CLOSE9, ROPEN9, OPEN9

	DSEG
CONNP:	dw	AFTN9	; args for open
FNAME9:	dw	0	; path$p
ACCESS:	dw	0	; access
	dw	0	; echo
	dw	STATUS	; status$p

CONNC:	dw	0	; args for close
	dw	STATUS	; status$p

CONNR:	dw	1	; args for read
	dw	0	; buff$p
CNTR:	dw	0	; count
	dw	ACTUAL	; actual$p
	dw	STATUS	; status$p

AFTN9:	dw	0	; args for write
	dw	0	; buff$p
CNTW:	dw	0	; count
	dw	STATUS	; status$p


	CSEG

OPEN9:  lxi	h,ACCESS
	mov	m,e
	dcx	h
	call	ZZOPEN

ROPEN9: lhld	AFTN9	; update 
	shld	CONNR
	shld	CONNC
	ret

CLOSE9: lxi	d,CONNC
	jmp	ZZCLOS

READ9:  lxi	h,CNTR + 1
	jmp	ZZREAD

WRITE9: lxi	h,CNTW + 1
	jmp	ZZWRIT



	end

?openi.asm
	name	OPENI
	extrn	STATUS, ACTUAL, ZZOPEN, ZZCLOS, ZZREAD
	public	AFTNI, FNAMEI, READI, CLOSEI, ROPENI, OPENI

	DSEG
CONNP:	dw	AFTNI	; args for open
FNAMEI:	dw	0
	dw	1	; access
	dw	0	; echo
	dw	STATUS	; status$p

CONNC:	dw	0	; args for close
	dw	STATUS

AFTNI:	dw	1	; args for read - conn - default CI
	dw	0	; buff$p
CNTR:	dw	0	; count
	dw	ACTUAL	; actual$p
	dw	STATUS	; status$p

	CSEG
OPENI:	lxi	h,FNAMEI + 1
	call	ZZOPEN

ROPENI:	lhld	AFTNI
	shld	CONNC
	ret

CLOSEI:	lxi	d,CONNC
	jmp	ZZCLOS

READI:	lxi	h, CNTR + 1
	jmp	ZZREAD

	end


?openo.asm
	name	OPENO
	extrn	STATUS, ACTUAL, ZZOPEN, ZZCLOS, ZZWRIT
	public	AFTNO, FNAMEO, WRITEO, CLOSEO, ROPENO, OPENO

	DSEG
CONNP:	dw	AFTNO	; args for open
FNAMEO:	dw	0
	dw	2	; access
	dw	0	; echo
	dw	STATUS	; status$p

CONNC:	dw	0	; args for close
	dw	STATUS

AFTNO:	dw	0	; args for write - conn - default CO
	dw	0	; buff$p
CNTW:	dw	0	; count
	dw	STATUS	; status$p

	CSEG

OPENO:	lxi	h,FNAMEO + 1
	call	ZZOPEN

ROPENO:	lhld	AFTNO
	shld	CONNC
	ret

CLOSEO:	lxi	d,CONNC
	jmp	ZZCLOS

WRITEO:	lxi	h,CNTW + 1
	jmp	ZZWRIT

	end
?openu.asm
	name	OPENU

	extrn	STATUS, ACTUAL, ZZOPEN, ZZCLOS, ZZREAD, ZZWRIT
	public	AFTNU, FNAMEU, WRITEU, READU, CLOSEU, ROPENU, OPENU

	DSEG
CONNP:	dw	AFTNU	; args for open
FNAMEU:	dw	0	; path$p
ACCESS:	dw	3	; access
	dw	0	; echo
	dw	STATUS	; status$p

CONNC:	dw	0	; args for close
	dw	STATUS	; status$p

CONNR:	dw	1	; args for read
	dw	0	; buff$p
CNTR:	dw	0	; count
	dw	ACTUAL	; actual$p
	dw	STATUS	; status$p

AFTNU:	dw	0	; args for write
	dw	0	; buff$p
CNTW:	dw	0	; count
	dw	STATUS	; status$p


	CSEG

OPENU:  lxi	h,ACCESS-1
	call	ZZOPEN

ROPENU: lhld	AFTNU	; update 
	shld	CONNR
	shld	CONNC
	ret

CLOSEU: lxi	d,CONNC
	jmp	ZZCLOS

READU:  lxi	h,CNTR + 1
	jmp	ZZREAD

WRITEU: lxi	h,CNTW + 1
	jmp	ZZWRIT

	end
?po.asm
	name	po
	public	PO

PO	equ	0F80CH
	end
?readc.asm
	name READC
	extrn	STATUS, ACTUAL, ZZREAD, ZZWRIT
	public	READC, WRITEC

	DSEG
	dw	1	; read args - CI
	dw	0	; buff$p
CNTR:	dw	0	; count
	dw	ACTUAL
	dw	STATUS

	dw	0	; write args - CO
	dw	0	; buff$p
CNTW:	dw	0	; count
	dw	STATUS

	CSEG
READC:	lxi	h,CNTR + 1
	jmp	ZZREAD

WRITEC:	lxi	h,CNTW + 1
	jmp	ZZWRIT

	end
?renam.asm
	name	renam
	public	RENAM, ZZRENA
	extrn	ZZXCHG, STATUS

	dseg
oldp:	dw	0
newp:	dw	0
statp:	dw	STATUS

	cseg
RENAM:	mvi	a,7

ZZRENA:	lxi	h,newp + 1	; de = new$p, bc = old$p
	mov	m,d
	dcx	h
	mov	m,e
	dcx	h
	mov	m,b
	dcx	h
	mov	m,c
	jmp	ZZXCHG

	end
?ri.asm
	name	ri
	public	RI

RI	equ	0F806H
	end
?sblok1.asm
	name	SBLOK1
	extrn	AFTN1
	extrn	ZZBLOK
	extrn	ISIS
	public	SBLOK1

	cseg
sblok1:	lxi	h,AFTN1
	jmp	ZZBLOK

	end

?sblok2.asm
	name	SBLOK2
	extrn	AFTN2
	extrn	ZZBLOK
	extrn	ISIS
	public	SBLOK2

	cseg
sblok2:	lxi	h,AFTN2
	jmp	ZZBLOK

	end


?sblok3.asm
	name	SBLOK3
	extrn	AFTN3
	extrn	ZZBLOK
	extrn	ISIS
	public	SBLOK3

	cseg
sblok3:	lxi	h,AFTN3
	jmp	ZZBLOK

	end


?sblok9.asm
	name	SBLOK9
	extrn	AFTN9
	extrn	ZZBLOK
	extrn	ISIS
	public	SBLOK9

	cseg
sblok9:	lxi	h,AFTN9
	jmp	ZZBLOK

	end


?sbloki.asm
	name	SBLOKI
	extrn	AFTNI
	extrn	ZZBLOK
	extrn	ISIS
	public	SBLOKI

	cseg
sblokI:	lxi	h,AFTNI
	jmp	ZZBLOK

	end


?sbloku.asm
	name	SBLOKU
	extrn	AFTNU
	extrn	ZZBLOK
	extrn	ISIS
	public	SBLOKU

	cseg
sblokU:	lxi	h,AFTNU
	jmp	ZZBLOK

	end


?sbyte1.asm
	name	SBYTE1
	extrn	AFTN1
	extrn	ZZBYTE
	extrn	ISIS
	public	SBYTE1

	cseg
sbyte1:	lxi	h,AFTN1
	jmp	ZZBYTE

	end
?sbyte2.asm
	name	SBYTE2
	extrn	AFTN2
	extrn	ZZBYTE
	extrn	ISIS
	public	SBYTE2

	cseg
sbyte2:	lxi	h,AFTN2
	jmp	ZZBYTE

	end

?sbyte3.asm
	name	SBYTE3
	extrn	AFTN3
	extrn	ZZBYTE
	extrn	ISIS
	public	SBYTE3

	cseg
sbyte3:	lxi	h,AFTN3
	jmp	ZZBYTE

	end

?sbyte9.asm
	name	SBYTE9
	extrn	AFTN9
	extrn	ZZBYTE
	extrn	ISIS
	public	SBYTE9

	cseg
sbyte9:	lxi	h,AFTN9
	jmp	ZZBYTE

	end

?sbytei.asm
	name	SBYTEI
	extrn	AFTNI
	extrn	ZZBYTE
	extrn	ISIS
	public	SBYTEI

	cseg
sbyteI:	lxi	h,AFTNI
	jmp	ZZBYTE

	end

?sbyteu.asm
	name	SBYTEU
	extrn	AFTNU
	extrn	ZZBYTE
	extrn	ISIS
	public	SBYTEU

	cseg
sbyteU:	lxi	h,AFTNU
	jmp	ZZBYTE

	end

?seek.asm
	name	seek
	public	ZZBLOK, SBLOK, ZZBYTE, SBYTE
	public	BLOKNO, BYTENO
	extrn	ZZXCHG
	extrn	STATUS

	dseg
conn:	dw	0
mode:	dw	0
blkp:	dw	BLOKNO
bytp:	dw	BYTENO
statp:	dw	STATUS

BLOKNO:	dw	0
BYTENO:	dw	0

; sblok: procedure(offset, conn) public; declare offset address, conn byte; end;
; sbyte: procedure(offset, conn) public; declare offset address, conn byte; end;

	cseg
conmod: mov	a,e		; set conn
	sta	conn
	call	getmod		; set mode
	sta	mode
	lxi	h,0		; useful 0
	ret

getmod: sub	a		; check for -ve offset
	add	b
	jm	seekbw
	ora	c
	rz			; return mode seek return for 0 offset
	call	chkmax
	mvi	a,3		; seek forward
	rnz
	inr	a		; seek eof
	ret

seekbw: cma			; not offset
	mov	b,a
	mov	a,c
	cma
	mov	c,a
	call	chkmax
	inx	b		; make offset full negate
	mvi	a,1		; seek backwards
	rnz			; not max
	inr	a		; seek abs -> rewind
	lxi	b,0		; offset = 0
	ret

chkmax: mvi	a,0FFH		; return 0 if max offset
	cmp	c
	rnz
	mvi	a,7FH
	cmp	b
	ret

ZZBLOK:	mov	e,m		; pickup conn from *hl

SBLOK:	call	conmod
	shld	BYTENO		; byte = 0
	dad	b
	shld	BLOKNO		; block = offset
seekcm:
	mvi	a,5
	lxi	h,conn
	jmp	ZZXCHG

ZZBYTE:	mov	e,m		; pickup conn from *hl

SBYTE:	call	conmod
	shld	BLOKNO		; block = 0
	dad	b
	shld	BYTENO		; byte = offset
	jmp	seekcm

	end
?ver10.plm
VERSIONNUMBER1P0: DO;
end;

?whoci.asm
	name	whoci
	public	WHOCI
	extrn	ZZLOD2, STATUS

	dseg
ciconn:	dw	1
buffp:	dw	0
statp:	dw	STATUS

	cseg
WHOCI:	mvi	a,0DH
	lxi	h,buffp + 1
	jmp	ZZLOD2
	end
?whoco.asm
	name	whoco
	public WHOCO
	extrn	ZZLOD2, STATUS

	dseg
coconn:	dw	0
buffp:	dw	0
statp:	dw	STATUS

	cseg
WHOCO:	mvi	a,0DH
	lxi	h,buffp + 1
	jmp	ZZLOD2

	end
unixio/makefile
ROOT = ../../..
TARGETS = unixio.lib
unexport ISIS_F1

include $(ROOT)/tools/isis.mk

REF = $(call ipath,toolbox,1.0)
PLM80 = 3.0
PLMFLAGS = code

OBJS = getcp.obj fopenp.obj getchr.obj putcp.obj fflush.obj putchr.obj\
       fcreat.obj csargs.obj strcmp.obj outstr.obj fclose.obj

all::
	$(MAKE) $(TARGETS)

unixio.lib: $(OBJS)
	$(call lib,$@,$^)

unixio/unixio_all.src
?csargs.plm
CSARGS: DO;
DECLARE TAB LITERALLY '9',
	CR  LITERALLY '0DH',
	ESC LITERALLY '1BH';


rescan: procedure (conn, status$p) external;
    declare (conn, status$p) address;
end rescan;

getchar: procedure byte external; end;

csargs: PROCEDURE(argptrs$p,string$p,count$p) public;
        DECLARE (string$p,argptrs$p,count$p) ADDRESS;
	DECLARE status address, c byte;
	DECLARE argptr based argptrs$p address,
		string  based string$p  byte,
		count   based count$p   address;
	
	call rescan(1, .status);
	count = 0;	
	c = ' ';
	do while 1;
		do while c = ' ' or c = TAB or c = ',';
			c = getchar;
		end;
		if c = CR or c = ESC then
			return;
		argptr = string$p;
		argptrs$p = argptrs$p + 2;
		count = count + 1;
		do while c <> ' ' and c <> TAB and c <> ','
		  and c <> CR and c <> ESC;
			string = c;
			string$p = string$p + 1;
			c = getchar;
		end;
		string = 0;
		string$p = string$p + 1;
	end;
end;
end;

?fclose.plm
FCLOSE: DO;

close: procedure (conn, status$p) external;
    declare (conn, status$p) address;
end close;

fclose: procedure(fp) public;
	declare (fp, status) address;
	declare fd based fp address;

	call close(fd, .status);
end;
end;

?fcreat.plm
FCREATP: DO;
open: procedure (conn$p, path$p, access, echo, status$p) external;
    declare (conn$p, path$p, access, echo, status$p) address;
end open;

fcreat: procedure(fp, fname, status$p) public;
	declare (fp, fname, status$p) address;
	declare file based fp structure(fd address, cnt address, actual address, buf(1) byte);

	call open(.file.fd, fname, 2, 0, status$p);
	file.cnt = 0;
	file.actual = 80h;
end;
end;

?fflush.plm
FFLUSHP: DO;

write: procedure (conn, buff$p, count, status$p) external;
    declare (conn, buff$p, count, status$p) address;
end write;

fflush: procedure(fp) public;
	declare (fp, status) address;
	declare file based fp structure(fd address, cnt address, w4 address, buf(1) byte);

	call write(file.fd, .file.buf, file.cnt, .status);
	file.cnt = 0;
end;
end;

?fopenp.plm
FOPENP: DO;
/* b1=01, b2=30, CODE(3EH) byte, DATA(6H) byte, STACK(8H) byte, MEMORY(0H) byte,*/
open: procedure (conn$p, path$p, access, echo, status$p) external;
    declare (conn$p, path$p, access, echo, status$p) address;
end open;

fopen: PROCEDURE(fp, path$p, status$p) public;
	DECLARE fp address,
		path$p address,
		status$p address;
	DECLARE file based fp
		STRUCTURE(conn address, count address, actual address, buff(1) byte);
	call open(.file.conn, path$p, 1, 0, status$p);
	file.count, file.actual = 0;
end;
end;

?getchr.plm
GETCHARP: DO;

getc: procedure(fp) byte external; declare fp address; end;

declare stdin structure(conn address, count address, actual address, buff(128) byte)
	initial (1, 0, 0);

getchar: procedure byte public;
	return getc(.stdin);
end;
end;
?getcp.plm
GETCP: DO;

read: procedure (conn, buff$p, count, actual$p, status$p) external;
    declare (conn, buff$p, count, actual$p, status$p) address;
end read;

getc: PROCEDURE(fp) byte public;
	declare fp address;
	declare status address, c byte;
	declare file based fp structure(conn address, count address, actual address, buff(1) byte);

	if file.count >= file.actual then
	do;
		call read(file.conn, .file.buff, 128, .file.actual, .status);
		if file.actual = 0 then
			return 0;
		file.count = 0;
	end;
	c = file.buff(file.count);
	file.count = file.count + 1;
	return c;
end;
end;
?outstr.plm
OUTSTR: DO;

putchar: procedure(ch) external; declare ch byte; end;

outstr: procedure(str) public;
	declare str address, ch based str byte;

	do while ch <> 0;
		call putchar(ch);
		str = str + 1;
	end;
end;
end;

?putchr.plm
PUTCHARP: DO;
write: procedure (conn, buff$p, count, status$p) external;
    declare (conn, buff$p, count, status$p) address;
end write;

putchar: procedure(ch) public;
	declare ch byte, status address;
	call write(0, .ch, 1, .status);
end;
end;
?putcp.plm
PUTCP: DO;
write: procedure (conn, buff$p, count, status$p) external;
    declare (conn, buff$p, count, status$p) address;
end write;

putc: procedure(ch, fp) public;
	declare fp address, ch byte;
	declare status address;
	declare file based fp structure(fd address, cnt address, actual address, buf(1) byte);

	if file.cnt >= file.actual then
	do;
		call Write(file.fd, .file.buf, file.actual, .status);
		file.cnt = 0;
	end;
	
	file.buf(file.cnt) = ch;
	file.cnt = file.cnt + 1;
end;
end;

?strcmp.plm
STRCOMP: DO;

strcomp: procedure(s, t) byte public;
	declare (s, t) address;
	declare sch based s byte,
		tch based t byte;

	do while sch = tch;
		if sch = 0 then
			return 0;
		s = s + 1;
		t = t + 1;
	end;
	if sch > tch then
		return 1;
	return 0ffh;
end;
end;
util1/makefile
# common makefile info
ROOT=../../..
TARGETS=util1.lib
unexport ISIS_F1

include $(ROOT)/tools/isis.mk

REF = $(call ipath,toolbox,1.0)
PLM80 = 3.1
ASM80 = 2.0

OBJS = 	ver07.obj bit.obj comp1.obj comp2.obj comp3.obj comp4.obj cons1.obj\
	cons2.obj cons3.obj cons4.obj fill.obj fmove.obj out1.obj out2.obj\
	out3.obj out4.obj out6.obj out7.obj out8.obj out9.obj scan.obj\
	scan1.obj scan2.obj scan3.obj scan5.obj scan6.obj scan7.obj scan9.obj\
	sfound.obj

all::
	$(MAKE) $(TARGETS)

util1.lib: $(OBJS)
	$(call lib,$@,$^)


util1/util1_all.src
?bit.asm
	name BIT
	public	BIT

; DECLARE BITMASK(*) BYTE DATA(80H, 40H, 20H, 10H, 8, 4, 2, 1);
; BIT: PROCEDURE(BITN, PBITS ) BYTE PUBLIC;
;      DECLARE N BYTE, PBITS ADDRESS;
;      DECLARE BITS BASED PBITS (1) BYTE;
;      IF N > BITS(0) THEN RETURN 0;
;      RETURN (BITS(1 + SHR(N, 3)) AND BITMASK(N AND 7)) <> 0;
; END;
	CSEG
BIT:	ldax	d
	cmp	c
	mvi	a,0
	rc
	inx	d
	xchg
	mov	d,a
	mov	a,c
	ani	0F8H
	rrc
	rrc
	rrc
	mov	e,a
	dad	d
	mov	a,c
	ani	7
	mov	e,a
	mov	a,m
	lxi	h,MASKS
	dad	d
	ana	m
	rz
	mvi	a,0FFH
	ret

MASKS:	db	80H, 40H, 20H, 10H, 8, 4, 2, 1

	end;
?comp1.asm
	name	COMP1
	public	MAX
	CSEG

; max(n, m) address

MAX:	xchg
	mov	a,c
	sub	l
	mov	a,b
	sbb	h
	rc		; m > n to return the original m
	mov	h,b
	mov	l,c
	ret		; return the n

	end
?comp2.asm
	name	COMP2
	public	MIN
	CSEG

; min(n, m) address

MIN:	xchg
	mov	a,c
	sub	l
	mov	a,b
	sbb	h
	rnc		; m < n so return m
	mov	h,b
	mov	l,c
	ret		; return n

	end
?comp3.asm
	name	COMP3
	public	DECSIZ

; DECSIZE(N) BYTE - returns number of digits in N
	cseg

DECSIZ:	mov	h,b
	mov	l,c
	mvi	a,1
	lxi	d,-10
	dad	d
	rnc
	inr	a
	lxi	d,-90
	dad	d
	rnc
	inr	a
	lxi	d,-900
	dad	d
	rnc
	inr	a
	lxi	d,-9000
	dad	d
	rnc
	inr	a
	ret

	end
?comp4.plm
COMP4: DO;

SETSC: PROCEDURE(SCANP) EXTERNAL; DECLARE SCANP ADDRESS; END;
SCANWHILE: PROCEDURE(FUNC) EXTERNAL; DECLARE FUNC ADDRESS; END;
ANYCH: PROCEDURE BYTE EXTERNAL; END;
DECLARE SCANP ADDRESS EXTERNAL;

LENSTRNUL: PROCEDURE(STR) BYTE PUBLIC;
	DECLARE STR ADDRESS;
	CALL SETSC(STR);
	CALL SCANWHILE(.ANYCH);
	RETURN SCANP - STR;
END;
END;

?cons1.plm
CONS1: DO;
DECLARE ACTUAL ADDRESS EXTERNAL,
	SCANP ADDRESS EXTERNAL,
	SCANBUF BASED SCANP (1) BYTE;

READC: PROCEDURE(buf, len) EXTERNAL; DECLARE (buf, len) ADDRESS; END;

CONSOLEIN: PROCEDURE PUBLIC;
	DECLARE buf(121) BYTE;
	CALL READC((SCANP := .buf), last(buf));
	SCANBUF(ACTUAL) = 0;
END;

END;	

?cons2.plm
CONS2: DO;

WRITEC: PROCEDURE(buf, len) EXTERNAL; DECLARE (buf, len) ADDRESS; END;


PUTCHAR: PROCEDURE(CH) PUBLIC;
	DECLARE CH BYTE;
	CALL WRITEC(.CH, 1);
END;

PUTCRLF: PROCEDURE PUBLIC;
	call PUTCHAR(0DH);
	call PUTCHAR(0AH);
END;

PRINT: PROCEDURE(STR) PUBLIC;
	DECLARE STR ADDRESS,
		CH BASED STR BYTE;

	DO WHILE CH <> 0;
		CALL PUTCHAR(CH);
		STR = STR + 1;
	END;
END;

PRINTCR: PROCEDURE(STR) PUBLIC;
	DECLARE STR ADDRESS;
	CALL PRINT(STR);
	CALL PUTCRLF;
END;

PUTBLANK: PROCEDURE PUBLIC;
	CALL PUTCHAR(' ');
END;

END;
?cons3.plm
CONS3: DO;
DECLARE OBUFP ADDRESS EXTERNAL;
SETOB: PROCEDURE(PTR) EXTERNAL; DECLARE PTR ADDRESS; END;
OUTDEC: PROCEDURE(N) EXTERNAL; DECLARE N ADDRESS; END;
OHEXB: PROCEDURE(N) EXTERNAL; DECLARE N ADDRESS; END;
OHEXW: PROCEDURE(N) EXTERNAL; DECLARE N ADDRESS; END;
SETPF: PROCEDURE/*(FUNC)*/ EXTERNAL; END;
PF: PROCEDURE(N) EXTERNAL; DECLARE N ADDRESS; END;
WRITEC: PROCEDURE(buf, len) EXTERNAL; DECLARE (buf, len) ADDRESS; END;

DECLARE BUF(6) BYTE;

WRITENUM: PROCEDURE(FUNC, N);
	DECLARE (FUNC, N) ADDRESS;
	call	SETPF;
	call	SETOB(.BUF);
	call	PF(N);
	CALL	WRITEC(.BUF, OBUFP - .BUF);
END;

DEC: PROCEDURE(N) PUBLIC;
	DECLARE N ADDRESS;
	CALL WRITENUM(.OUTDEC, N);
END;

HEXB: PROCEDURE(N) PUBLIC;
	DECLARE N BYTE;
	CALL WRITENUM(.OHEXB, N);
END;

HEXW: PROCEDURE(N) PUBLIC;
	DECLARE N ADDRESS;
	CALL WRITENUM(.OHEXW, N);
END;

END;
?cons4.plm
CONS4: DO;
DECLARE STATUS ADDRESS EXTERNAL,
	REPORT BYTE EXTERNAL,
	FATAL BYTE EXTERNAL;

PUTCRLF: PROCEDURE EXTERNAL; END;
EX: PROCEDURE EXTERNAL; END;
PRINT: PROCEDURE(STR) EXTERNAL; DECLARE STR ADDRESS; END;


STARS: PROCEDURE;
	CALL PRINT(.(' *** ', 0));
END;

ERRORMESSAGE: PROCEDURE(MSG) PUBLIC;
	DECLARE MSG ADDRESS;
	STATUS = MSG;
	IF NOT REPORT THEN RETURN;

	CALL STARS;
	CALL PRINT(MSG);
	CALL STARS;
	CALL PUTCRLF;
	IF FATAL THEN CALL EX;
END;

END;
?fill.asm
	name FILL
	public FILL

	CSEG

; FILL: PROCEDURE(CNT, DST, VAL) PROCEDURE;
;	DECLARE (CNT, DST) ADDRESS, VAL BYTE;
; END;

FILL:   pop	h	; CNT to HL
	xthl
	mov	a,e	; VAL in A reg
	inr	l	; adjust for quick loop check
	inr	h
	jmp	L2

L1:	stax	b
	inx	b

L2:	dcr	l
	jnz	L1
	dcr	h
	jnz	L1
	ret

	END;
?fmove.asm
	name	FMOVE
	public	FMOVE

; fmove(cnt, src, dst)
	cseg

FMOVE:	pop	h	; hl = cnt arg
	xthl
	push	b	; src
	mov	b,h	; xchg hl,bc
	mov	c,l
	pop	h
	dcx	b
	mov	a,e	; dst - src
	sub	l
	mov	a,d
	jz	L1	; possibly same
	sbb	h
	jmp	L2
L1:
	sbb	h
	rz		; nothing to do
L2:
	push	h
	lxi	h,L5
	jc	L3	; src > dst so copy forward
	pop	h
	dad	b	; adjust to copy backwards
	push	h
	xchg
	dad	b
	xchg
	lxi	h,L7
L3:
	inx	b
	mov	a,b	; rrc b,3
	rrc		; the hack below effectively does shl(bc, 3)
	rrc
	rrc
	mov	b,a
	mvi	a,7	; mask of part count
	ana	c
	push	psw
	xra	c	; invert the mask
	rrc		; rrc c,3
	rrc
	rrc
	xra	b	; merge with the rrc b,3 above
	ani	1FH	; mask of the lower bit that are to go in b
	xra	b	; this will leave low 5 bits of c + top 3 bits from b
	mov	c,a	
	mvi	a,1FH
	ana	b	; get the lower bits of b back
	mov	b,a	; end of hack
	inr	b	; adjust for simple loop test
	inr	c
	pop	psw	; get the residule
	rlc		; * 4
	rlc
	push	b	; subtract from the address of the bottom of the loop
	cma
	mov	c,a
	mvi	b,0FFH
	inx	b
	dad	b
	pop	b
	xthl		; effectively jumps to the correct loop code
	ret
L4:	mov	a, m
	stax	d
	inx	h
	inx	d
	mov	a, m
	stax	d
	inx	h
	inx	d
	mov	a, m
	stax	d
	inx	h
	inx	d
	mov	a, m
	stax	d
	inx	h
	inx	d
	mov	a, m
	stax	d
	inx	h
	inx	d
	mov	a, m
	stax	d
	inx	h
	inx	d
	mov	a, m
	stax	d
	inx	h
	inx	d
	mov	a, m
	stax	d
	inx	h
	inx	d

L5:	dcr	c
	jnz	L4
	dcr	b
	jnz	L4
	ret

L6:	mov	a, m
	stax	d
	dcx	h
	dcx	d
	mov	a, m
	stax	d
	dcx	h
	dcx	d
	mov	a, m
	stax	d
	dcx	h
	dcx	d
	mov	a, m
	stax	d
	dcx	h
	dcx	d
	mov	a, m
	stax	d
	dcx	h
	dcx	d
	mov	a, m
	stax	d
	dcx	h
	dcx	d
	mov	a, m
	stax	d
	dcx	h
	dcx	d
	mov	a, m
	stax	d
	dcx	h
	dcx	d

L7:	dcr	c
	jnz	L6
	dcr	b
	jnz	L6
	ret

	END


?genpex.plm
$title('===>  P E X    (I N C L U D E   M A K E R)  <===')

gen$pex: DO;


/************************************************************************/
/*																		*/
/*      '(C) Intel Corporation 1981'.  All rights reserved.  No			*/
/*      part of this program or publication may be reproduced,			*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

      
DECLARE COPYRIGHT (*) BYTE DATA ('(C) INTEL CORP 1981');

DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.0',0);
    


  /****
   *
   *  PEX:
   *    program to create declarations for external routines and variables.
   *    has been extended to PLM86 in addition to accepting input for PLM80.
   *
   *    The added characters are:
   *         'A'  --  ADDRESS.
   *         'B'  --  BYTE.
   *         'I'  --  INTEGER.
   *         'W'  --  WORD.
   *         'R'  --  REAL.
   *         '@'  --  ADDRESS.
   *         'L'  --  LABEL.
   *
   *    The syntax for lines in the input file is as follows:
   *
   *       line      =  plm-var (proc-decl | var-decl).
   *       proc-decl = 'P'&param-list&type.
   *       var-decl  =  (type | '"' plm-var '"') [&'S'] [&'..'&plm-var].
   *       params    = (list-12 | '(' &(type | list-12) ... ')'.
   *       list-12   = '1' | '2'.
   *       type      = 'A' | 'B' | 'I' | 'W' | 'R' | '@' | 'L'.
   *
   ****/

declare SCANP address external;
declare SCANBYTE BASED SCANP byte;
declare SCANADDR BASED SCANP address;
declare OBUFP address external;
declare SCANENDED byte external;
ANYCH: procedure byte external; end;
BLNKCH: procedure byte external; end;
BUMPSCANP: procedure external; end;
CONSOLEIN: procedure external; end;
ERRORMESSAGE: procedure(ZZ1) external; declare (ZZ1) address; end;
FILECH: procedure byte external; end;
FILL: procedure(ZZ1,ZZ2,ZZ3) external; declare (ZZ1,ZZ2) address, (ZZ3) byte; end;
FMOVE: procedure(ZZ1,ZZ2,ZZ3) external; declare (ZZ1,ZZ2,ZZ3) address; end;
FORCUP: procedure byte external; end;
FORCUPSTRING: procedure external; end;
LENSTRNUL: procedure(ZZ1) byte external; declare (ZZ1) address; end;
LETRCH: procedure byte external; end;
OUTCHAR: procedure(ZZ1) external; declare (ZZ1) byte; end;
OUTDEC: procedure(ZZ1) external; declare (ZZ1) address; end;
OUTPRINT: procedure(ZZ1) external; declare (ZZ1) address; end;
OUTWRITE: procedure(ZZ1,ZZ2) external; declare (ZZ1) address, (ZZ2) byte; end;
PRINT: procedure(ZZ1) external; declare (ZZ1) address; end;
PRINTCR: procedure(ZZ1) external; declare (ZZ1) address; end;
PUTBLANK: procedure external; end;
SCANEXPECT: procedure(ZZ1) external; declare (ZZ1) address; end;
SCANMATCH: procedure(ZZ1) byte external; declare (ZZ1) address; end;
SCANUNTIL: procedure(ZZ1) external; declare (ZZ1) address; end;
SCANWHILE: procedure(ZZ1) external; declare (ZZ1) address; end;
SCANWHILEBLANKS: procedure external; end;
SETOB: procedure(ZZ1) external; declare (ZZ1) address; end;
SETSC: procedure(ZZ1) external; declare (ZZ1) address; end;
SETSCANENDED: procedure external; end;
TERMCH: procedure byte external; end;
TOKNCH: procedure byte external; end;
declare STATUS byte external;
declare REPORT byte external;
declare FATAL byte external;
declare ACTUAL address external;
BACKCI: procedure external; end;
CLOSEI: procedure external; end;
DEL: procedure(ZZ1) external; declare (ZZ1) address; end;
EX: procedure external; end;
ISIS: procedure(ZZ1,ZZ2) external; declare (ZZ2) address, (ZZ1) byte; end;
MEMCK: procedure address external; end;
OPENI: procedure(ZZ1) external; declare (ZZ1) address; end;
OPENO: procedure(ZZ1) external; declare (ZZ1) address; end;
READI: procedure(ZZ1,ZZ2) external; declare (ZZ1,ZZ2) address; end;
WRITEO: procedure(ZZ1,ZZ2) external; declare (ZZ1,ZZ2) address; end;
MOVEFILENAME: procedure(ZZ1) external; declare (ZZ1) address; end;
NEWEXTENSION: procedure(ZZ1,ZZ2) external; declare (ZZ1,ZZ2) address; end;
OPENSCAN: procedure(ZZ1) external; declare (ZZ1) address; end;
OUTFILENAME: procedure(ZZ1) external; declare (ZZ1) address; end;
READIWITHLIMIT: procedure(ZZ1,ZZ2) external; declare (ZZ1,ZZ2) address; end;
declare NIL literally '0';
declare BOOLEAN literally 'BYTE';
declare CR literally '0DH';
declare LF literally '0AH';
declare FOREVER literally 'WHILE (1)';
declare ENDDO literally 'END';
declare CHAR literally 'BYTE';
declare TRUE literally '0FFH';
declare FALSE literally '000H';
$eject

  DECLARE available            ADDRESS,    /* ADDRESS of memory available for symbols */
          mem$top              ADDRESS,    /* last ADDRESS usable */
          file$name$buffer(15) CHAR;

  DECLARE SYMBOL$TABLE$ENTRY LITERALLY
      'STRUCTURE(THREAD ADDRESS,
                 NEXT ADDRESS,
                 MARK BYTE,
                 LENGTH ADDRESS,
                 STR(1) CHAR)',

          SYMBOL$TABLE$SIZE       LITERALLY '256',
          SYMBOL$TABLE$ENTRY$SIZE LITERALLY '7',
          MARKED                  LITERALLY '0FFH',
          UNMARKED                LITERALLY '0',

          symbol$length ADDRESS,
          hash$value    ADDRESS,
          thread$head   ADDRESS,

          symbol$table(SYMBOL$TABLE$SIZE) ADDRESS,
          symbol$buffer(41)               CHAR;

  DECLARE NULL$STRING CHAR DATA(0),
          EXTERNAL$STRING(*)         CHAR DATA(' external',0),
          ADDRESS$VARIABLE$STRING(*) CHAR DATA(' address',0),
          BYTE$VARIABLE$STRING(*)    CHAR DATA(' byte',0),
          POINTER$VARIABLE$STRING(*) CHAR DATA(' pointer',0),
          REAL$VARIABLE$STRING(*)    CHAR DATA(' real',0),
          WORD$VARIABLE$STRING(*)    CHAR DATA(' word',0),
          INTEGER$VARIABLE$STRING(*) CHAR DATA(' integer',0),
          LABEL$STRING(*)            CHAR DATA(' label',0);

  DECLARE put$symbol$flag BOOLEAN,
          src$file(15)    CHAR INITIAL (0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),
          ipx$file(15)    CHAR INITIAL (0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),
          include$count   ADDRESS INITIAL (0),
          include$begin   ADDRESS,
          src$buff(1024)  CHAR;

  DECLARE state  BYTE INITIAL(1),                /* first line cmd line */
          fsm(6) STRUCTURE(NEXT(6) BYTE) DATA(   /* used to scan files  */
          /* ? lf  $  /  *  A */
             0, 1, 0, 2, 0, 6,
             0, 1, 7, 2, 0, 6,
             0, 1, 0, 2, 3, 6,
             3, 4, 3, 3, 5, 3,
             3, 4, 8, 3, 5, 3,
             3, 4, 3, 0, 5, 3);
$eject

  /****
   *
   *  read$ch:
   *    bumps scanp.  if scan$ended is set, reads more data into the buffer.
   *  when an EOF occurs, scanp is set to point to a null string
   *
   ****/

  read$ch: PROCEDURE;

    CALL bump$scan$p;
    IF (scan$ended) THEN
      DO;
        CALL readi(.src$buff, size(src$buff)-1);
        IF (actual = 0) THEN
          DO;
            scanp = .NULL$STRING;
            CALL set$scan$ended;
            RETURN;
          END;
        src$buff(actual) = 0;
        scanp            = .src$buff;
        CALL set$scan$ended;
      END;

  END read$ch;

  /****
   *
   *  full$line:
   *    assures that there is a TERMCH in the string pointed to by
   *  scanp.  moves data and reads more if required
   *
   ****/

  full$line: PROCEDURE;

    DECLARE temp ADDRESS;

    temp = scanp;
    CALL scan$until(.termch);
    scanp = temp;
    IF (scan$ended) THEN
      DO;
        temp = .src$buff(last(src$buff)) - scanp;
        CALL fmove(temp, scanp, .src$buff);
        CALL readi(.src$buff(temp), size(src$buff) - temp - 1);
        src$buff(actual + temp) = 0;
        scanp = .src$buff;        /* should check long line ... */
      END;
  CALL set$scan$ended;

  END full$line;
$eject

  /****
   *
   *  init$memory:
   *    initializes available to .MEMORY and mem$top to MEMCK
   *
   ****/

  init$memory: PROCEDURE;

    DECLARE (m BASED mem$top) BYTE;

    available = .memory;
    mem$top   = memck;
    m         = 0;
    mem$top   = mem$top - 1;

  END init$memory;
$eject

  /****
   *
   *  file$name$line:
   *    returns TRUE and sets file$name$buffer to the file name if scanp points
   *    to a string which specifies a file name.
   *
   ****/

  file$name$line: PROCEDURE BOOLEAN;

    IF (scan$byte <> '$') THEN
      RETURN (FALSE);
    CALL bump$scan$p;
    CALL scan$while$blanks;
    IF (NOT scan$match(.('FILE',0))) THEN
      RETURN (FALSE);
    CALL scan$while$blanks;
    IF (scan$byte <> '(') THEN
      RETURN (FALSE);
    CALL bump$scan$p;
    CALL fill(size(file$name$buffer), .file$name$buffer, 0);
    IF (scan$byte = ':') THEN
      scanp= scanp + 4;
    CALL move$file$name(.file$name$buffer);
    IF (scan$byte <> ')') THEN
      RETURN (FALSE);
    CALL set$sc(.file$name$buffer);
    CALL forc$up$string;
    RETURN (TRUE);

  END file$name$line;
$eject

  /****
   *
   *  pex$file$matches$file$name:
   *    returns TRUE IF the file name passed in matches the file name in File-
   *    NameBuffer.
   *
   ****/

  pex$file$matches$file$name: PROCEDURE (px$name$ptr) BOOLEAN;

    DECLARE px$name$ptr ADDRESS;

    DECLARE px$name BASED px$name$ptr CHAR;

    IF (px$name = ':') THEN
      px$name$ptr= px$name$ptr + 4;

    CALL set$sc(.file$name$buffer);
    RETURN (scan$match(px$name$ptr));

  END pex$file$matches$file$name;

  /****
   *
   *  check$gap:
   *    errors out should space overflow.
   *
   ****/

  check$gap: PROCEDURE;

    IF (available >= mem$top) THEN
      CALL error$message(.('dynamic storage overflow.  too many PEX symbols',0));

  END check$gap;
$eject

  /****
   *
   *  point$scanp$to$next$line:
   *    advances scanp to the first character after the current END of line.
   *
   ****/

  point$scanp$to$next$line: PROCEDURE;

    CALL scan$until(.termch);
    CALL scan$while(.termch);

  END point$scanp$to$next$line;

  /****
   *
   *  find$include$file:
   *    searches for the word INCLUDE, then copies the file name to
   *  the area pointed to by obufp
   *
   ****/

  find$include$file: PROCEDURE;

    CALL full$line;
    DO
      WHILE (NOT termch);
      CALL read$ch;
      IF (scan$match(.('INCLUDE',0))) THEN
        DO;
          CALL scan$until(.filech);
          CALL out$file$name(scanp);
          CALL out$char(0);
          CALL scan$until(.termch);
          include$count = include$count + 1;
          available     = obufp;
          CALL check$gap;
          RETURN;
        END;
    ENDDO;

  END find$include$file;
$eject

  /****
   *
   *                 S Y M B O L   -   T A B L E   S E C T I O N
   *
   ****/

  /****
   *
   *  init$symbol$table:
   *    sets all the entries in the symbol table to NIL.  NILs thread$head.
   *
   ****/

  init$symbol$table: PROCEDURE;

    DECLARE i ADDRESS;

    i = length(symbol$table);
    DO
      WHILE (i <> 0);
      i = i - 1;
      symbol$table(i) = NIL;
    ENDDO;

    thread$head= NIL;

  END init$symbol$table;
$eject

  /****
   *
   *  get$id:
   *    copies the symbol currently being pointed to into symbol$buffer, converting
   *    from lower to upper case and discarding '$'.  A maximum of 32 characters
   *    is allowed.  scanp is left pointing to the character which halted the
   *    scan.
   *
   ****/

  get$id: PROCEDURE;

    symbol$length = 0;
    CALL set$ob(.symbol$buffer);
    DO
      WHILE (NOT scan$ended);
      IF (toknch) THEN
        DO;
          CALL out$char(forcup);
          symbol$length = symbol$length + 1;
        END;
      ELSE IF (scan$byte <> '$') THEN
        GOTO exit$loop;
      CALL bump$scanp;
    ENDDO;

exit$loop:;
    IF (symbol$length > size(symbol$buffer)) THEN
      CALL error$message(.('symbol greater than 40 characters long',0));

    CALL out$char(0);

  END get$id;
$eject

  /****
   *
   *  hash:
   *    sets hash$value to the hashed value of symbol$buffer;
   *
   ****/

  hash: PROCEDURE;

    hash$value = 0;
    CALL set$sc(.symbol$buffer);
    CALL set$scan$ended;
    DO
      WHILE (NOT scan$ended);
      hash$value = ror(hash$value,1) + scan$byte;
      CALL bump$scan$p;
    ENDDO;

    hash$value = low(hash$value);

  END hash;

  /****
   *
   *  lookup$id:
   *    searches the symbol table for the entry with ID = symbol$buffer.
   *
   ****/

  lookup$id: PROCEDURE ADDRESS;

    DECLARE ptr         ADDRESS,
            p BASED ptr SYMBOL$TABLE$ENTRY;

    CALL hash;
    ptr = symbol$table(hash$value);
    CALL set$sc(0);
    DO
      WHILE (ptr <> NIL);
      scanp = .symbol$buffer;           /* this is NOT string equality */
      IF (scan$match(.p.STR(0))) THEN
        IF (scan$byte = 0) THEN
          RETURN (ptr);
      ptr = p.NEXT;
    ENDDO;

    RETURN (NIL);

  END lookup$id;
$eject

  /****
   *
   *  insert$pex$symbol:
   *    the string pointed to by scanp is inserted into the symbol table.
   *    NOTE:  the symbol tables grow upward from available.
   *
   ****/

  insert$pex$symbol: PROCEDURE;

    DECLARE pex$data$string$ptr    ADDRESS,
            ste$p                  ADDRESS,
            ste$b BASED ste$p      SYMBOL$TABLE$ENTRY,
            pex$data$string$length ADDRESS;

    CALL get$id;
    CALL scan$while$blanks;
    pex$data$string$ptr    = scanp;
    pex$data$string$length = 0;
    DO
      WHILE (NOT (termch OR scan$ended));
      pex$data$string$length = pex$data$string$length + 1;
      CALL bump$scan$p;
    ENDDO;

    ste$p = available;
    obufp = .ste$b.STR(0);
    CALL out$write(.symbol$buffer, symbol$length);
    CALL out$char(0);
    CALL out$write(pex$data$string$ptr, pex$data$string$length);
    CALL out$char(0);
    available = obufp;
    CALL check$gap;

    CALL hash;
    ste$b.NEXT   = symbol$table(hash$value);
    ste$b.MARK   = UNMARKED;
    ste$b.LENGTH = symbol$length + pex$data$string$length + 2;
    ste$b.THREAD = thread$head;
    thread$head, symbol$table(hash$value) = ste$p;

  END insert$pex$symbol;
$eject

  /****
   *
   *  squash$symbol$table:
   *    transforms the symbol table from its current format into a series of
   *    of strings terminated by the null string.  Data is compacted by being
   *    moved from lower to lower locations, thus reusing space from deleted
   *    entries and allowing more space for the declarations.  thread$head
   *    points at the first of the series of strings.
   *
   ****/

  squash$symbol$table: PROCEDURE;

    DECLARE (prev, current, temp) ADDRESS,
            a BASED available     BYTE,
            p BASED prev          SYMBOL$TABLE$ENTRY,
            c BASED current       SYMBOL$TABLE$ENTRY;

    /*
     *  The thread fields must be reversed, so that thread fields are
     *  increasing.  At the end of the loop, prev points to the list.
     */

    current = thread$head;
    prev    = NIL;
    DO
      WHILE (current <> NIL);
      temp     = c.THREAD;
      c.THREAD = prev;
      prev     = current;
      current  = temp;
    ENDDO;

    thread$head, available = .memory;
    current = prev;
    DO
      WHILE (current <> NIL);
      prev = c.THREAD;
      temp = available + c.LENGTH;
      CALL fmove(c.LENGTH, .c.STR(0), available);
      CALL print$cr(available);
      current   = prev;
      available = temp;
    ENDDO;
    a         = 0;
    available = available + 1;     /* Terminated by a null string */

  END squash$symbol$table;
$eject

  /****
   *
   *  mark$id:
   *    looks up the symbol in symbol$buffer.  If found, sets Mark to the passed
   *    in value.
   *
   ****/

  mark$id: PROCEDURE (mark$value);

    DECLARE mark$value BYTE;

    DECLARE ste$p             ADDRESS,
            ste$b BASED ste$p SYMBOL$TABLE$ENTRY;

    ste$p = lookup$id;
    IF (ste$p = NIL) THEN
      RETURN;
    ste$b.MARK = mark$value;

  END mark$id;

  /****
   *
   *  find$and$mark:
   *    bump scanp to the next letter, get the symbol and set its mark field to
   *    the passed in value.
   *
   ****/

  find$and$mark: PROCEDURE (mark$value);

    DECLARE mark$value BYTE;

    CALL scan$until(.toknch);
    CALL get$id;
    CALL mark$id(mark$value);

  END find$and$mark;
$eject

  /****
   *
   *  mark$internal$references:
   *    assures that symbols containing references to other symbols (BASEd var-
   *    iables and literallys) are included in the declarations.
   *
   ****/

  mark$internal$references: PROCEDURE (mark$value);

    DECLARE mark$value BYTE;

    DECLARE ptr         ADDRESS,
            p BASED ptr SYMBOL$TABLE$ENTRY;

    ptr = thread$head;
    DO
      WHILE (ptr <> NIL);
      IF (p.MARK = mark$value) THEN
        DO;
          scanp = .p.STR(1) + lenstrnul(.p.STR(0));
          CALL set$scan$ended;
          DO
            WHILE (NOT scan$ended);
            IF ((scan$byte = '.') OR (scan$byte = '"')) THEN
              CALL find$and$mark(mark$value);
            ELSE IF (scan$byte = '''') THEN        /* only one level is allowed */
              DO
                WHILE (NOT scan$ended);
                CALL find$and$mark(mark$value);
              ENDDO;
            CALL bump$scan$p;
          ENDDO;
        END;
      ptr= p.THREAD;
    ENDDO;

  END mark$internal$references;
$eject

  /****
   *
   *  delete$entries:
   *    deletes all those entries whose mark field is equal to the passed in
   *    value from the THREAD list.
   *
   ****/

  delete$entries: PROCEDURE (mark$value);

    DECLARE mark$value BYTE;

    DECLARE (current, prev) ADDRESS,
            c BASED current SYMBOL$TABLE$ENTRY,
            p BASED prev    SYMBOL$TABLE$ENTRY;

    prev    = .thread$head;
    current = thread$head;
    DO
      WHILE (current <> NIL);

      IF (c.MARK <> mark$value) THEN
        DO;
          p.THREAD = current;
          prev     = current;
        END;

      current = c.THREAD;
    ENDDO;
    p.THREAD = NIL;

  END delete$entries;
$eject

  /****
   *
   *  write$char:
   *    writes the character to the output file
   *
   ****/

  write$char: PROCEDURE (ch);

    DECLARE ch CHAR;

    CALL writeo(.ch, 1);

  END write$char;

  /****
   *
   *  write$string:
   *    writes the null terminated string to the output file
   *
   ****/

  write$string: PROCEDURE (s$p);

    DECLARE s$p ADDRESS;

    CALL writeo(s$p, lenstrnul(s$p));

  END write$string;
$eject

  /****
   *
   *  write$number:
   *    writes the decimal ADDRESS using write$char.
   *
   ****/

  write$number: PROCEDURE (number);

    DECLARE number ADDRESS;

    DECLARE nbuff(6) CHAR;

    CALL fill(6, .nbuff, 0);
    CALL set$ob(.nbuff);
    CALL out$dec(number);
    CALL write$string(.nbuff);

  END write$number;
$eject

  write$declare: PROCEDURE;
    CALL write$string(.('declare ',0));
  END write$declare;

  write$semi: PROCEDURE;
    CALL write$char(';');
  END write$semi;

  write$blank: PROCEDURE;
    CALL write$char(' ');
  END write$blank;

  write$comma: PROCEDURE;
    CALL write$char(',');
  END write$comma;

  write$lp: PROCEDURE;
    CALL write$char('(');
  END write$lp;

  write$rp: PROCEDURE;
    CALL write$char(')');
  END write$rp;

  write$crlf: PROCEDURE;
    CALL write$string(.(CR,LF,0));
  END write$crlf;

  /****
   *
   *  write$lit:
   *    writes the definition as a literally statement.
   *
   ****/

  write$lit: PROCEDURE;

    CALL write$declare;
    CALL write$string(.symbol$buffer);
    CALL write$string(.(' literally ',0));
    CALL write$string(scanp);
    CALL write$semi;
    CALL write$crlf;

  END write$lit;
$eject

  /****
   *
   *  chr$idx:
   *    returns an index of the character pointed to by scanp.
   *
   ****/

  chr$idx: PROCEDURE (s$p) ADDRESS;

    DECLARE s$p ADDRESS;

    DECLARE i             BYTE,
            s$b BASED s$p CHAR;

    i = 1;
    DO
      WHILE (s$b <> 0);
      IF (s$b = scan$byte) THEN
        RETURN (i);
      s$p = s$p + 1;
      i   = i + 1;
    ENDDO;

    RETURN (0);

  END chr$idx;
$eject
  /****
   *
   *  get$user$type:
   *    puts a user type in the symbol table if it exists.
   *
   ****/
get$user$type: PROCEDURE;

    IF (scan$byte = '"') THEN
      DO;
        CALL scan$until(.toknch);
        CALL get$id;
        CALL scan$while$blanks;
      END;

END get$user$type;

  /****
   *
   *  write$var:
   *    writes a declaration for the variable with the given type.
   *
   ****/

  write$var: PROCEDURE;

    DECLARE TYPE$TBL(*) CHAR DATA('ABIW@R"L',0),
            TYPE$PTR(*) ADDRESS DATA(
              .NULL$STRING,
              .ADDRESS$VARIABLE$STRING,
              .BYTE$VARIABLE$STRING,
              .INTEGER$VARIABLE$STRING,
              .WORD$VARIABLE$STRING,
              .POINTER$VARIABLE$STRING,
              .REAL$VARIABLE$STRING,
              .symbol$buffer,
              .LABEL$STRING),
            idx ADDRESS,
      (based$ptr, array$ptr, bvar$ptr) ADDRESS;

    CALL write$declare;
    CALL write$string(.symbol$buffer);
    idx = chr$idx(.TYPE$TBL);
    CALL get$user$type;
    CALL bump$scan$p;
$eject

    based$ptr, array$ptr, bvar$ptr= .NULL$STRING;
    DO
      WHILE (NOT scan$ended);

      CALL scan$while$blanks;
      IF (scan$byte = 'S') THEN
        DO;
          array$ptr = .('(1)',0);
          CALL bump$scan$p;
        END;
      ELSE IF (scan$addr = '..') THEN
        DO;
           based$ptr       = .(' BASED ',0);
           scanp, bvar$ptr = scanp + 2;
           CALL scan$until(.BlnkCh);
           IF (NOT scan$ended) THEN
             DO;
               scan$byte = 0;
               scanp     = scanp + 1;
             END;
        END;
      ELSE IF (not scan$ended) THEN
        DO;
          CALL print(scanp);
          CALL error$message(.('bad pex line',0));
        END;
    ENDDO;

    CALL write$string(based$ptr);
    CALL write$string(bvar$ptr);
    CALL write$string(array$ptr);

    IF (TYPE$PTR(idx) = .symbol$buffer) THEN
      CALL write$blank;
    CALL write$string(TYPE$PTR(idx));
    IF (bvar$ptr = .NULL$STRING) THEN
      CALL write$string(.EXTERNAL$STRING);
    CALL write$semi;
    CALL write$crlf;
  END write$var;
$eject

  /****
   *
   *  pex$error:
   *    prints an error message on the terminal and exits.
   *
   ****/

  pex$error:
    PROCEDURE;

    CALL print$cr(.('bad PEX line',0));
    CALL print(.symbol$buffer);
    CALL put$blank;
    CALL print$cr(scanp);
    CALL ex;

  END pex$error;
$eject

  /****
   *
   *  write$proc:
   *    writes the declaration of a procedure.  The format of a procedure declar-
   *    ation is p[argument-list][type].  argument-list is either a string of
   *    '1' or '2', or '(' type-characters ')'.  type is type-character.
   *    type-character is one of the characters '@RIWAB'.
   *
   ****/

  write$proc: PROCEDURE;

    DECLARE PARAM$TYPE$STRING(*)     CHAR DATA('ABW@IR21"',0),
                /* The '"' is required to be the last type */
            PARAM$1$2$TYPE$STRING(2) CHAR at(.PARAM$TYPE$STRING(6)),
            param$count(10)          BYTE,
            param$type$ptr           ADDRESS,
            PARAM$TYPE$TBL(*)        ADDRESS DATA(
              .NULL$STRING,
              .ADDRESS$VARIABLE$STRING,
              .BYTE$VARIABLE$STRING,
              .WORD$VARIABLE$STRING,
              .POINTER$VARIABLE$STRING,
              .INTEGER$VARIABLE$STRING,
              .REAL$VARIABLE$STRING,
              .ADDRESS$VARIABLE$STRING,
              .BYTE$VARIABLE$STRING),
            PROC$TYPE$TBL(1) ADDRESS AT(.PARAM$TYPE$TBL(3)),
            ZZ$STRING(*)     CHAR DATA('ZZ',0),
            (saved$scanp, close$scan$p) ADDRESS,
            (i, j, params, params$left) ADDRESS;

    write$args: PROCEDURE (p);
      DECLARE p ADDRESS;
      CALL write$lp;
      i = chr$idx(p);
      DO
        FOREVER;
        CALL write$string(.ZZ$STRING);
        params = params + 1;
        CALL write$number(params);
        param$count(i) = param$count(i) + 1;
        IF scan$byte = '"' THEN
          DO;
            CALL bump$scan$p;
            CALL scan$while (.TOKNCH);
          END;
        CALL bump$scan$p;
        i = chr$idx(p);
        IF (i = 0) THEN
          DO;
            CALL write$rp;
            RETURN;
          END;
        CALL write$comma;
      ENDDO;
    END write$args;
$eject

    CALL fill(length(param$count), .param$count, 0);
    CALL bump$scan$p;
    CALL write$string(.symbol$buffer);
    CALL write$string(.(': procedure',0));
    params = 0;
    IF (scan$byte = '(') THEN
      DO;
        CALL bump$scan$p;
        saved$scanp = scanp;
        CALL write$args((param$type$ptr := .PARAM$TYPE$STRING));
        IF (scan$byte <> ')') THEN
          CALL error$message(.('Missing closing '')'' in procedure definition',0));
        close$scan$p = scan$p;
        CALL bump$scan$p;
      END;
    ELSE IF ((scan$byte = '1') or (scan$byte = '2')) THEN
      DO;
        saved$scanp = scanp;
        CALL write$args((param$type$ptr:= .PARAM$1$2$TYPE$STRING));
      END;
$eject

    IF scan$byte = '"' THEN
      DO;
        CALL get$user$type;
        CALL bump$scan$p;
        CALL write$blank;
        CALL write$string (.SYMBOL$BUFFER);
      END;
    CALL write$string(PARAM$TYPE$TBL(chr$idx(.PARAM$TYPE$STRING)));
    CALL write$string(.EXTERNAL$STRING);
    CALL write$semi;

    IF (params <> 0) THEN
      DO;
        params$left = params;
        CALL write$blank;
        CALL write$declare;
        DO
          i = 1 to last(PARAM$TYPE$TBL);
          IF (param$count(i) <> 0) THEN
            DO;
              CALL write$lp;
              scanp = saved$scanp;
              DO
                j = 1 to params;
                  IF scan$byte = '"' THEN
                    DO;
                      CALL bump$scan$p;
                      CALL scan$while (.TOKNCH);
                    END;
                  ELSE
                    IF (chr$idx(param$type$ptr) = i) THEN
                      DO;
                        CALL write$string(.ZZ$STRING);
                        CALL write$number(j);
                        params$left    = params$left - 1;
                        param$count(i) = param$count(i) - 1;
                        IF (param$count(i) <> 0) THEN
                          CALL write$comma;
                      END;
                  CALL bump$scan$p;
              ENDDO;
              CALL write$rp;
              CALL write$string(PARAM$TYPE$TBL(i));
              IF (params$left = 0) THEN
                GOTO exit$loop;
              CALL write$comma;
              CALL write$blank;
            END;
        ENDDO;
        scan$p = saved$scan$p;
        IF params$left > 0 THEN
          DO;
            DO
              j = 1 to params;
                IF scan$byte = '"' THEN
                  DO;
                    CALL get$user$type;
                    CALL write$string (.ZZ$STRING);
                    CALL write$number (j);
                    CALL write$blank;
                    CALL write$string (.SYMBOL$BUFFER);
                    params$left = params$left - 1;
                    IF params$left > 0 THEN
                      DO;
                        CALL write$comma;
                        CALL write$blank;
                      END;
                    ELSE
                      DO;
                        scan$p = close$scan$p;
                        GO TO exit$loop;
                      END;
                  END;
                CALL bump$scan$p;
            ENDDO;
          END;
exit$loop:;
        CALL write$semi;
      END;

    CALL write$string(.(' end;',CR,LF,0));

  END write$proc;
$eject

  /****
   *
   *  write$dcl:
   *    The symbol being defined is placed into symbol$buffer.  The first
   *    non-blank character of the definition string (pointed to by
   *    id$text$ptr) is used to determine whether a variable, procedure
   *    or literal declaration is to be produced.
   *
   ****/

  write$dcl: PROCEDURE (id$p, id$text$p);

    DECLARE (id$p, id$text$p) ADDRESS;

    DECLARE prc           ADDRESS,
            PROC$TABLE(*) ADDRESS DATA(
              .pex$error,                  /* unknown character */
              .write$proc,                 /* 'p' */
              .write$var,                  /* 'a' */
              .write$var,                  /* 'B' */
              .write$lit,                  /* "'" */
              .write$var,                  /* '@' */
              .write$var,                  /* 'R' */
              .write$var,                  /* 'W' */
              .write$var,                  /* 'i' */
              .write$var,                  /* '"' */
              .write$var);                 /* 'L' */

    scanp = id$text$p;
    CALL set$scan$ended;
    obufp = .symbol$buffer;
    CALL out$print(id$p);
    CALL out$char(0);
    CALL scan$while$blanks;
    CALL forc$up$string;
    prc = PROC$TABLE(chr$idx(.('PAB''@RWI"L',0)));
    CALL prc;

  END write$dcl;
$eject

  /****
   *
   *  dump$dcls:
   *    follows the pairs of strings starting at thread$head until the first
   *    string of a pair is a null string.  The pairs of strings are defined
   *    as symbol being defined followed by defining text for that symbol.
   *
   ****/

  dump$dcls: PROCEDURE;

    DECLARE (sym$p, s$p) ADDRESS,
            (s$b BASED s$p) BYTE;

    s$p = thread$head;
    DO
      WHILE (s$b <> 0);
      sym$p, scanp = s$p;
      CALL scan$while(.anych);
      scanp = scanp + 1;
      s$p   = scanp + lenstrnul(scanp) + 1;
      CALL forc$up$string;
      CALL write$dcl(sym$p, scanp);
    ENDDO;

  END dump$dcls;
$eject

  /****
   *
   *  class:
   *    returns the class of scan$byte
   *
   ****/

  class: PROCEDURE ADDRESS;

    IF (letrch) THEN
      RETURN (5);
    RETURN (chr$idx(.(LF,'$/*',0)));     /* all others are class 0 */

  END class;
$eject

  /****
   *
   *  Main module:
   *    initialize memory and symbol table.
   *    read in command line and get filenames for SRC$FILE and PEX$FILE.
   *    read in PEX$FILE, creating symbol table with all entries UNMARKED.
   *    read in SRC$FILE
   *    for each token until the END of the file, set its ste$b as MARKed.
   *    delete all UNMARKed STEs.
   *    transform the symbol table to preserve space.
   *    open SRC$FILE.IPX
   *    write the declarations.
   *    exit.
   *
   ****/

  CALL init$memory;
  CALL init$symbol$table;
  CALL back$ci;
  CALL console$in;
  CALL forc$up$string;
  CALL scan$while$blanks;
  IF (scan$match(.('DEBUG',0))) THEN
    CALL scan$while$blanks;
  CALL scan$while(.file$ch);
  CALL scan$while$blanks;
  fatal, report = TRUE;
  CALL open$scan(.openi);
  CALL scan$while$blanks;
  CALL scan$expect(.('TO',0));
  CALL move$file$name(.src$file);
  CALL print(.(CR,LF,'ISIS-II GENPEX V1.0',CR,LF,0));
  scanp = .src$file;
  CALL new$extension(.ipx$file, .('IPX',0));
  /* delete previous .IPX file */
  REPORT, FATAL = FALSE;          /* make no noise if it isn't there */
  CALL del(.ipx$file);
  REPORT, FATAL = TRUE;
$eject

  CALL readi$with$limit(available, mem$top-available+1);
  CALL fmove(actual, available, (scanp := mem$top-actual+1));
  CALL closei;

  put$symbol$flag = TRUE;
  CALL set$scan$ended;
  DO
    WHILE (NOT scan$ended);
    IF (toknch) THEN
      DO;
        IF (put$symbol$flag) THEN
          CALL insert$pex$symbol;
      END;
    ELSE IF (file$name$line) THEN
      put$symbol$flag = NOT pex$file$matches$file$name(.src$file);
    CALL point$scanp$to$next$line;
  ENDDO;
$eject

  /*
   * Scan the rest of the file for identifiers appearing in the symbol table
   * and mark the symbol table entries as being used.
   */

  CALL openi(.src$file);
  include$begin, obufp = available;     /* remember file names here */
  scanp                = .NULL$STRING;  /* cause READ$CH to read in data */
  DO
    FOREVER;
    CALL read$ch;
    IF (scan$ended) THEN
      DO;
        CALL closei;
        status        = 0FFH;
        fatal,report  = FALSE;
        DO                /* open include files */
          WHILE (status <> 0);
          IF (include$count = 0) THEN
            GOTO exit$loop;
          include$count = include$count - 1;
          scanp         = include$begin;
          CALL print$cr(scanp);
          CALL open$scan(.openi);
          include$begin = scanp + 1;
        ENDDO;
        fatal, report = TRUE;
        scanp         = .NULL$STRING;
      END;
    ELSE
      DO;
        state = fsm(state).NEXT(class);
        IF (state = 6) THEN
          DO;
            CALL full$line;
            CALL find$and$mark(MARKED);
            state = 0;
          END;
        ELSE IF (state > 6) THEN
          DO;
            CALL find$include$file;
            IF (state = 8) THEN
              state = 3;     /* continue scanning comment */
            ELSE
              state = 0;     /* otherwise start again */
          END;
      END;
  ENDDO;
exit$loop:;
$eject

  /*
   * All entries in symbol table which are used have been marked as such.
   * delete the unmarked entries and squash the symbol table.
   */

  CALL mark$internal$references(MARKED);
  CALL delete$entries(UNMARKED);
  CALL squash$symbol$table;

  /*
   * write the declarations
   */

  CALL openo(.ipx$file);
  CALL dump$dcls;

  CALL ex;

END gen$pex;
?out1.asm
	name OUT1
	public	OHEXB, OHEXW
	extrn	OBUFP

	CSEG
OHEXW:	mov	a,c
	mov	c,b
	mov	b,a
	call	OHEXB
	mov	c,b
OHEXB:	lhld	OBUFP
	mov	a,c
	rlc
	rlc
	rlc
	rlc
	call	OHEXN
	mov	a,c
OHEXN:
	ani	0FH
	adi	30H
	cpi	3AH
	jc	L001E
	adi	7
L001E:
	mov	m,a
	inx	h
	shld	OBUFP
	ret

	end
?out2.plm
OUT2: DO;

DECLARE OBUFP ADDRESS PUBLIC,
	OBUFCH BASED OBUFP BYTE;

OUTCHAR: PROCEDURE(CH) PUBLIC;
	DECLARE CH BYTE;

	OBUFCH = CH;
	OBUFP = OBUFP + 1;
END;

OUTCRLF: PROCEDURE PUBLIC;
	call OUTCHAR(0DH);
	call OUTCHAR(0AH);
END;

OUTBLANK: PROCEDURE PUBLIC;
	call OUTCHAR(' ');
END;

OUTWRITE: PROCEDURE(CHP, CNT) PUBLIC;
	DECLARE CHP ADDRESS, CNT BYTE,
		CH BASED CHP BYTE;
	do while CNT > 0;
		call OUTCHAR(CH);
		CHP = CHP + 1;
		CNT = CNT - 1;
	end;
END;

OUTPRINT: PROCEDURE(CHP) PUBLIC;
	DECLARE CHP ADDRESS, CH BASED CHP BYTE;

	do while CH <> 0;
		call OUTCHAR(CH);
		CHP = CHP + 1;
	end;
	OBUFCH = 0;
end;

end;
?out3.plm
OUT3: DO;

OUTDECR: PROCEDURE(A, B) EXTERNAL; DECLARE A ADDRESS, B BYTE; END;

OUTDEC: PROCEDURE(A) PUBLIC;
	DECLARE A ADDRESS;
	call OUTDECR(A, 0);
END;

END;
?out4.asm
	name	OUT4
	extrn	OBUFP
	public  SETOB
	stkln	14


	CSEG
SETOB:	pop	d		; return address
	lhld	OBUFP
	push	h		; old OBUFP	
	lxi	h,ROBUFP	; push return address for call to restore OBUFP
	push	h
	mov	h,b		; OBUFP = bc
	mov	l,c
	shld	OBUFP
	push	d		; restore return address
	ret

ROBUFP:	xchg
	pop	h
	shld	OBUFP
	xchg
	ret

	end
?out6.plm
OUT6: DO;

OUTCHARS: PROCEDURE(CNT, CH) EXTERNAL; DECLARE (CNT, CH) BYTE; END;
DECSIZ: PROCEDURE(N) BYTE EXTERNAL; DECLARE N ADDRESS; END;
DECLARE OBUFP ADDRESS EXTERNAL;

DECLARE LEADCHAR BYTE PUBLIC INITIAL(' ');

OUTDECR: PROCEDURE(N, WIDTH) PUBLIC;
	DECLARE N ADDRESS, WIDTH BYTE;
	DECLARE CHP ADDRESS, NDIGIT BYTE,
		CH BASED CHP BYTE;

	if (NDIGIT := DECSIZ(N)) < WIDTH THEN
		CALL OUTCHARS(WIDTH - NDIGIT, LEADCHAR);
	
	CHP = OBUFP + NDIGIT;
	DO WHILE CHP > OBUFP;
		CHP = CHP - 1;
		CH = '0' + N mod 10;
		N = N / 10;
	END;	
	OBUFP = OBUFP + NDIGIT;
END;
END;

?out7.plm
OUT7: DO;

OUTCHAR: PROCEDURE(CH) EXTERNAL; DECLARE CH BYTE; END;


OUTCHARS: PROCEDURE(CNT, CH) PUBLIC;
	DECLARE (CNT, CH) BYTE;

	DO WHILE CNT > 0;
		CALL OUTCHAR(CH);
		CNT = CNT - 1;
	END;
END;
END;

?out8.plm
OUT8: DO;

BUMPSCANP: PROCEDURE EXTERNAL; END;
OUTCHAR: PROCEDURE(CH) EXTERNAL; DECLARE CH BYTE; END;
DECLARE SCANP ADDRESS EXTERNAL,
	SCANCH BASED SCANP BYTE;

OUTSCANBYTE: PROCEDURE PUBLIC;
	call OUTCHAR(SCANCH);
	call BUMPSCANP;
end;
end;
?out9.plm
OUT9: DO;

OUTSCANBYTE: PROCEDURE EXTERNAL; END;
SETSCANENDED: PROCEDURE EXTERNAL; END;
DECLARE SCANP ADDRESS EXTERNAL,
	SCANENDED BYTE EXTERNAL;
SETSC: PROCEDURE(SCANP) EXTERNAL; DECLARE SCANP ADDRESS; END;

OUTSCANSTRING: PROCEDURE PUBLIC;
	call SETSC(SCANP);
	call SETSCANENDED;
	do while not SCANENDED;
		call OUTSCANBYTE;
	end;
end;
end;
?scan.asm
	name	scan
	public	DDIGCH, ANYCH, FORCUP, HDIGCH
	public	LETRCH, LTNMCH, TOKNCH, FILECH
	public	TERMCH, BLNKCH, ASCBIN
	public	SCANP

	CSEG
NXTCH:	lhld	SCANP
	mov	a,m
	mov	b,a
	ret

DDIGCH:	call	NXTCH
	cpi	'0'
	jc	RETZ
	cpi	'9' + 1
	jnc	RETZ

ANYCH:	stc
	sbb	a
	ret

FORCUP:	call	NXTCH
	cpi	'a'
	rc
	cpi	'z' + 1
	rnc
	sui	20H
	ret

HDIGCH:	call	DDIGCH
	rc
	call	FORCUP
	cpi	'A'
	jc	RETZ
	cpi	'F' + 1
	jc	ANYCH

RETZ:	sub	a
	ret

LETRCH:	call	FORCUP
	cpi	'A'
	jc	RETZ
	cpi	'Z' + 1
	jc	ANYCH
	sub	a
	ret

LTNMCH:	call	LETRCH
	rc
	call	DDIGCH
	rc
	sub	a
	ret

TOKNCH:	call	LTNMCH
	rc
	mov	a,b
	cpi	'?'
	jz	ANYCH
	cpi	'@'
	jz	ANYCH
	cpi	'_'
	jz	ANYCH
	sub	a
	ret

FILECH:	call	LTNMCH
	rc
	mov	a,b
	cpi	':'
	jz	ANYCH
	cpi	'.'
	jz	ANYCH
	sub	a
	ret

TERMCH:	call	NXTCH
	cpi	0DH	; CR
	jz	ANYCH
	cpi	0AH	; LF
	jz	ANYCH
	cpi	1BH	; ESC
	jz	ANYCH
	sub	a
	ret

BLNKCH:	call	NXTCH
	cpi	9	; TAB
	jz	ANYCH
	cpi	' '
	jz	ANYCH
	sub	a
	ret

ASCBIN:	call	NXTCH
	sui	'0'
	cpi	10
	rc
	sui	7
	ani	5FH
	ret

	DSEG
SCANP:	dw	0

	end

?scan1.plm
SCAN1: DO;

DECLARE SCAN$P ADDRESS EXTERNAL;
DECLARE CH BASED SCAN$P BYTE;

DECLARE SCAN$ENDED BYTE PUBLIC;
DECLARE ZZSCEN BYTE PUBLIC AT (.SCAN$ENDED);

FORCUP: PROCEDURE BYTE EXTERNAL; END FORCUP;

SETPF: PROCEDURE/*(FUNC)*/ EXTERNAL;
/*	DECLARE FUNC ADDRESS;*/
/* must be called immediately as first non declare statement
   as it relies on reg BC still holding in the passed in FUNC
*/
END SETPF;

PF: PROCEDURE BYTE EXTERNAL;
END PF;

SET$SCAN$ENDED: PROCEDURE PUBLIC;
	SCAN$ENDED = CH = 0;
END SET$SCAN$ENDED;

BUMP$SCANP: PROCEDURE PUBLIC;
	CALL SET$SCAN$ENDED;
	SCAN$P = SCAN$P + (SCAN$ENDED + 1);
	CALL SET$SCAN$ENDED;
END BUMP$SCANP;

SCAN$UNTIL: PROCEDURE(FUNC) PUBLIC;
	DECLARE FUNC ADDRESS;
	CALL SETPF/*(FUNC)*/;
	
	DO WHILE not PF;
		CALL BUMP$SCANP;
		if SCAN$ENDED then
			RETURN;
	END;
END SCAN$UNTIL;
	
	
SCAN$WHILE: PROCEDURE(FUNC) PUBLIC;
	DECLARE FUNC ADDRESS;
	CALL SETPF/*(FUNC)*/;
	
	DO WHILE PF;
		CALL BUMP$SCANP;
		if SCAN$ENDED then
			RETURN;
	END;
END SCAN$WHILE;

SCAN$MATCH: PROCEDURE(PTR) BYTE PUBLIC;
	DECLARE PTR ADDRESS;
	DECLARE C BASED PTR BYTE;
	DECLARE D7 ADDRESS;

	call	SET$SCAN$ENDED;
	D7 = SCAN$P;

	DO WHILE FORCUP = C AND NOT SCAN$ENDED;
		PTR = PTR + 1;
		CALL BUMP$SCANP;
		if C = 0 then
			return 0FFH;
	END;
	SCAN$P = D7;
	CALL Set$SCAN$ENDED;
	return 0;
END SCAN$MATCH;	

END;
?scan2.asm
	name SCAN2
	public SETPF, PF, PF1, PF2
	CSEG
SETPF:
	mov	h,b
	mov	l,c
	shld	PF+1
	ret

	DSEG

PF:
PF1:
PF2:	JMP	0
	END

?scan3.plm
SCAN3: DO;

SCAN$UNTIL: PROCEDURE(FUNC) EXTERNAL; DECLARE FUNC ADDRESS; END;
SCAN$WHILE$BLANKS: PROCEDURE EXTERNAL; END;
HDIGCH: PROCEDURE BYTE EXTERNAL; END;
DDIGCH: PROCEDURE BYTE EXTERNAL; END;
ASCBIN: PROCEDURE BYTE EXTERNAL; END;
BUMP$SCANP: PROCEDURE EXTERNAL; END;

DECLARE ACC ADDRESS;

HEXIN: PROCEDURE ADDRESS PUBLIC;

	ACC = 0;
	call SCAN$UNTIL(.HDIGCH);
	do while HDIGCH;
		ACC = ACC * 16 + ASCBIN;
		call	BUMP$SCANP;
	end;
	call	SCAN$WHILE$BLANKS;
	return ACC;
END;


DECIN: PROCEDURE ADDRESS PUBLIC;

	ACC = 0;
	call SCAN$UNTIL(.DDIGCH);
	do while DDIGCH;
		ACC = ACC * 10 + ASCBIN;
		call	BUMP$SCANP;
	end;
	call	SCAN$WHILE$BLANKS;
	return ACC;
END;

END;

?scan5.plm
SCAN5: DO;
BLNKCH: PROCEDURE BYTE EXTERNAL; END;
SCANWHILE: PROCEDURE(FUNC) EXTERNAL;
	DECLARE FUNC ADDRESS;
END;

SCANWHILEBLANKS: PROCEDURE PUBLIC;
	CALL SCANWHILE(.BLNKCH);
END;


END;
?scan6.plm
SCAN6: DO;

SCANMATCH: PROCEDURE(PTR) BYTE EXTERNAL; DECLARE PTR ADDRESS; END;
SETOB: PROCEDURE(PTR) EXTERNAL; DECLARE PTR ADDRESS; END;
OUTPRINT: PROCEDURE(STR) EXTERNAL; DECLARE STR ADDRESS; END;
OUTWRITE: PROCEDURE(FILE, STR) EXTERNAL; DECLARE (FILE, STR) ADDRESS; END;
ERRORMESSAGE: PROCEDURE(STR) EXTERNAL; DECLARE STR ADDRESS; END;

DECLARE MSG(*) BYTE INITIAL('SCAN ERROR: EXPECTED "');
DECLARE	OB(*) BYTE INITIAL('                               ');

SCANEXPECT: PROCEDURE(PTR) PUBLIC;
	DECLARE PTR ADDRESS;

	if SCANMATCH(PTR) THEN
		RETURN;
	CALL SETOB(.OB);
	CALL OUTPRINT(PTR);
	CALL OUTWRITE(.('"', 0), 2);
	CALL ERRORMESSAGE(.MSG);	
END;

END;
?scan7.asm
	name	SCAN7
	extrn	SCANP, ZZSCEN
	public	SETSC
	stkln	14

	cseg
SETSC:	pop	d		; return address
	lhld	SCANP		; original SCANP
	push	h
	lxi	h,RSETSC	; push address of restore routine
	push	h
	mov	h,b		; SCANP = bc
	mov	l,c
	shld	SCANP
	push	d		; restore return address
	ret

RSETSC:	xchg
	pop	h
	shld	SCANP		; restore original SCANP
	mov	b,a
	sub	a
	sub	m
	cmc
	sbb	a
	sta	ZZSCEN
	mov	a,b
	xchg
	ret

	end

?scan9.plm
SCAN9: DO;

DECLARE	SCANP ADDRESS EXTERNAL,
	SCANENDED BYTE EXTERNAL;

SETSC: PROCEDURE(SCANP) EXTERNAL; DECLARE SCANP ADDRESS; END;
FORCUP: PROCEDURE BYTE EXTERNAL; END;
BUMPSCANP: PROCEDURE EXTERNAL; END;

FORCUPSTRING: PROCEDURE PUBLIC;
	DECLARE SCANCH BASED SCANP BYTE;

	call SETSC(SCANP);
	do while not SCANENDED;
		SCANCH = FORCUP;
		call BUMPSCANP;
	end;
end;

end;	

?sfound.asm
	name SFOUND
	public SFOUND, TARLEN, JOKER, GIVEUP
	extrn SCANP, TARGET

	DSEG
TARLEN:	db	0
JOKER:	db	'?'
GIVEUP:	dw	0

	CSEG
SFOUND: lhld	GIVEUP
	xchg
	lhld	TARLEN
	mov	b,h		; b = joker
	mov	c,l		; c = tarlen
	lhld	SCANP
	mov	a,e
	sub	l
	mov	e,a
	mov	a,d
	sbb	h
	mov	d,a
	ora	e
	rz			; nothing to check
	inr	d		; adjust for simple loop checks
	inr	e
trial:
	lda	TARGET
	call	first		; returns if first char found
	push	b		; save joker and tarlen
	push	d		; save counters
	push	h		; save where we are matching
	lxi	d,TARGET
match:
	dcr	c		; matched one more
	inx	d
	jz	found		; all done?
	ldax	d
	cmp	m
	inx	h
	jz	match		; still matching
	cmp	b
	jz	match		; or is wild card
	pop	h		; no match so restore and retry
	pop	d
	pop	b
	jmp	trial
found:
	mvi	a,0FFH		; found
	shld	SCANP		; save location after this string
	pop	psw		; junk the stack saves
	pop	psw
	pop	psw
	ret
match1:
	cmp	m		; start match found
	inx	h
	rz			; return just the one level
first:
	dcr	e
	jnz	match1
	dcr	d
	jnz	match1
	pop	psw		; junk first return address
	sub	a		; return 0 to original caller
	ret

	END	
?ver07.asm
	name VER07

	end

util2/makefile
ROOT=../../..
TARGETS = util2.lib
unexport ISIS_F1


include $(ROOT)/tools/isis.mk

REF = $(call ipath,toolbox,1.0)
PLM80 = 3.1

OBJS = vernum.obj bit.obj bmove.obj comp1.obj comp2.obj comp3.obj comp4.obj\
       comp5.obj comp6.obj cons1.obj cons2.obj cons3.obj cons4.obj fill.obj\
       fmove.obj out1.obj out2.obj out3.obj out4.obj out6.obj out7.obj out8.obj\
       out9.obj out10.obj out11.obj rscan.obj scan.obj scan1.obj scan2.obj\
       scan3.obj scan5.obj scan6.obj scan7.obj scan9.obj scanp.obj sfound.obj

all::
	$(MAKE) $(TARGETS)

util2.lib: $(OBJS)
	$(call lib,$@,$^)


util2/util2_all.src
?bit.asm
	name BIT
	public	BIT

; DECLARE BITMASK(*) BYTE DATA(80H, 40H, 20H, 10H, 8, 4, 2, 1);
; BIT: PROCEDURE(BITN, PBITS ) BYTE PUBLIC;
;      DECLARE N BYTE, PBITS ADDRESS;
;      DECLARE BITS BASED PBITS (1) BYTE;
;      IF N > BITS(0) THEN RETURN 0;
;      RETURN (BITS(1 + SHR(N, 3)) AND BITMASK(N AND 7)) <> 0;
; END;
	CSEG
BIT:	ldax	d
	cmp	c
	mvi	a,0
	rc
	inx	d
	xchg
	mov	d,a
	mov	a,c
	ani	0F8H
	rrc
	rrc
	rrc
	mov	e,a
	dad	d
	mov	a,c
	ani	7
	mov	e,a
	mov	a,m
	lxi	h,MASKS
	dad	d
	ana	m
	rz
	mvi	a,0FFH
	ret

MASKS:	db	80H, 40H, 20H, 10H, 8, 4, 2, 1

	end;
?bmove.asm
	name	BMOVE
	extrn	ZFMOVE
	public	BMOVE, MOVE2, MOVE3, MOVE4, MOVE5, MOVE6, MOVE7, MOVE8
	public	MOVE9, MOVE10, MOVE11, MOVE12, MOVE13, MOVE14, MOVE15
	public	MOVE16, MOVE17, MOVE18, MOVE19, MOVE20, MOVE21, MOVE22
	public	MOVE23, MOVE24

	cseg page
MOVE24:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE23:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE22:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE21:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE20:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE19:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE18:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE17:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE16:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE15:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE14:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE13:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE12:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE11:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE10:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE9:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE8:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE7:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE6:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE5:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE4:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE3:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE2:	ldax	b
	stax	d
	inx	b
	inx	d
	ldax	b
	stax	d
	ret
	nop
	ret

BMOVE:	pop	h
	xthl
	mvi	a,24
	sub	l
	jc	L6F
	add	a
	add	a
	mov	l,a
	mvi	h,HIGH move24
	pchl
L6F:
	mvi	h,0
	jmp	ZFMOVE

	end;
?comp1.asm
	name	COMP1
	public	MAX
	CSEG

; max(n, m) address

MAX:	xchg
	mov	a,c
	sub	l
	mov	a,b
	sbb	h
	rc		; m > n to return the original m
	mov	h,b
	mov	l,c
	ret		; return the n

	end
?comp2.asm
	name	COMP2
	public	MIN
	CSEG

; min(n, m) address

MIN:	xchg
	mov	a,c
	sub	l
	mov	a,b
	sbb	h
	rnc		; m < n so return m
	mov	h,b
	mov	l,c
	ret		; return n

	end
?comp3.asm
	name	COMP3
	public	DECSIZ

; DECSIZE(N) BYTE - returns number of digits in N
	cseg

DECSIZ:	mov	h,b
	mov	l,c
	mvi	a,1
	lxi	d,-10
	dad	d
	rnc
	inr	a
	lxi	d,-90
	dad	d
	rnc
	inr	a
	lxi	d,-900
	dad	d
	rnc
	inr	a
	lxi	d,-9000
	dad	d
	rnc
	inr	a
	ret

	end
?comp4.plm
COMP4: DO;

SETSC: PROCEDURE(SCANP) EXTERNAL; DECLARE SCANP ADDRESS; END;
SCANWHILE: PROCEDURE(FUNC) EXTERNAL; DECLARE FUNC ADDRESS; END;
ANYCH: PROCEDURE BYTE EXTERNAL; END;
DECLARE SCANP ADDRESS EXTERNAL;

LENSTRNUL: PROCEDURE(STR) BYTE PUBLIC;
	DECLARE STR ADDRESS;
	CALL SETSC(STR);
	CALL SCANWHILE(.ANYCH);
	RETURN SCANP - STR;
END;
END;

?comp5.plm
COMP5: DO;

declare scanP address external;
ScanWhile: procedure(func) external; declare func address; end;
SetSc: procedure(scanp) external; declare scanp address; end;

StringLength: procedure(ptr, func) byte public;
	declare (ptr, func) address;

	call SetSc(ptr);
	call ScanWhile(func);
	return scanP - ptr;
end;
end;
?comp6.asm
	name COMP6
	public	ONBIT

	CSEG
ONBIT:	stc
	mov	a,c
	mvi	c,0FFH

L4:	inr	c
	rar
	jnc	L4
	mov	a,c
	ret

	end

?cons1.plm
CONS1: DO;
DECLARE ACTUAL ADDRESS EXTERNAL,
	SCANP ADDRESS EXTERNAL,
	SCANBUF BASED SCANP (1) BYTE;

READC: PROCEDURE(buf, len) EXTERNAL; DECLARE (buf, len) ADDRESS; END;

CONSOLEIN: PROCEDURE PUBLIC;
	DECLARE buf(123) BYTE;
	CALL READC((SCANP := .buf), last(buf));
	SCANBUF(ACTUAL) = 0;
END;

END;	

?cons2.plm
CONS2: DO;

WRITEC: PROCEDURE(buf, len) EXTERNAL; DECLARE (buf, len) ADDRESS; END;


PUTCHAR: PROCEDURE(CH) PUBLIC;
	DECLARE CH BYTE;
	CALL WRITEC(.CH, 1);
END;

PUTCRLF: PROCEDURE PUBLIC;
	call PUTCHAR(0DH);
	call PUTCHAR(0AH);
END;

PRINT: PROCEDURE(STR) PUBLIC;
	DECLARE STR ADDRESS,
		CH BASED STR BYTE;

	DO WHILE CH <> 0;
		CALL PUTCHAR(CH);
		STR = STR + 1;
	END;
END;

PRINTCR: PROCEDURE(STR) PUBLIC;
	DECLARE STR ADDRESS;
	CALL PRINT(STR);
	CALL PUTCRLF;
END;

PUTBLANK: PROCEDURE PUBLIC;
	CALL PUTCHAR(' ');
END;

END;
?cons3.plm
CONS3: DO;
DECLARE OBUFP ADDRESS EXTERNAL;
SETOB: PROCEDURE(PTR) EXTERNAL; DECLARE PTR ADDRESS; END;
OUTDEC: PROCEDURE(N) EXTERNAL; DECLARE N ADDRESS; END;
OHEXB: PROCEDURE(N) EXTERNAL; DECLARE N ADDRESS; END;
OHEXW: PROCEDURE(N) EXTERNAL; DECLARE N ADDRESS; END;
SETPF: PROCEDURE/*(FUNC)*/ EXTERNAL; END;
PF: PROCEDURE(N) EXTERNAL; DECLARE N ADDRESS; END;
WRITEC: PROCEDURE(buf, len) EXTERNAL; DECLARE (buf, len) ADDRESS; END;

DECLARE BUF(6) BYTE;

WRITENUM: PROCEDURE(FUNC, N);
	DECLARE (FUNC, N) ADDRESS;
	call	SETPF;
	call	SETOB(.BUF);
	call	PF(N);
	CALL	WRITEC(.BUF, OBUFP - .BUF);
END;

DEC: PROCEDURE(N) PUBLIC;
	DECLARE N ADDRESS;
	CALL WRITENUM(.OUTDEC, N);
END;

HEXB: PROCEDURE(N) PUBLIC;
	DECLARE N BYTE;
	CALL WRITENUM(.OHEXB, N);
END;

HEXW: PROCEDURE(N) PUBLIC;
	DECLARE N ADDRESS;
	CALL WRITENUM(.OHEXW, N);
END;

END;
?cons4.plm
CONS4: DO;
DECLARE STATUS ADDRESS EXTERNAL,
	REPORT BYTE EXTERNAL,
	FATAL BYTE EXTERNAL;

PUTCRLF: PROCEDURE EXTERNAL; END;
EX: PROCEDURE EXTERNAL; END;
PRINT: PROCEDURE(STR) EXTERNAL; DECLARE STR ADDRESS; END;


STARS: PROCEDURE;
	CALL PRINT(.(' *** ', 0));
END;

ERRORMESSAGE: PROCEDURE(MSG) PUBLIC;
	DECLARE MSG ADDRESS;
	STATUS = MSG;
	IF NOT REPORT THEN RETURN;

	CALL STARS;
	CALL PRINT(MSG);
	CALL STARS;
	CALL PUTCRLF;
	IF FATAL THEN CALL EX;
END;

END;
?fill.asm
	name FILL
	public FILL

	CSEG

; FILL: PROCEDURE(CNT, DST, VAL) PROCEDURE;
;	DECLARE (CNT, DST) ADDRESS, VAL BYTE;
; END;

FILL:   pop	h	; CNT to HL
	xthl
	mov	a,e	; VAL in A reg
	inr	l	; adjust for quick loop check
	inr	h
	jmp	L2

L1:	stax	b
	inx	b

L2:	dcr	l
	jnz	L1
	dcr	h
	jnz	L1
	ret

	END;
?fmove.asm
	name	FMOVE
	public	FMOVE, ZFMOVE

; fmove(cnt, src, dst)
	cseg

FMOVE:	pop	h	; hl = cnt arg
	xthl
ZFMOVE:
	push	b	; src
	mov	b,h	; xchg hl,bc
	mov	c,l
	pop	h
	dcx	b
	mov	a,e	; dst - src
	sub	l
	mov	a,d
	jz	L1	; possibly same
	sbb	h
	jmp	L2
L1:
	sbb	h
	rz		; nothing to do
L2:
	push	h
	lxi	h,L5
	jc	L3	; src > dst so copy forward
	pop	h
	dad	b	; adjust to copy backwards
	push	h
	xchg
	dad	b
	xchg
	lxi	h,L7
L3:
	inx	b
	mov	a,b	; rrc b,3
	rrc		; the hack below effectively does shl(bc, 3)
	rrc
	rrc
	mov	b,a
	mvi	a,7	; mask of part count
	ana	c
	push	psw
	xra	c	; invert the mask
	rrc		; rrc c,3
	rrc
	rrc
	xra	b	; merge with the rrc b,3 above
	ani	1FH	; mask of the lower bit that are to go in b
	xra	b	; this will leave low 5 bits of c + top 3 bits from b
	mov	c,a	
	mvi	a,1FH
	ana	b	; get the lower bits of b back
	mov	b,a	; end of hack
	inr	b	; adjust for simple loop test
	inr	c
	pop	psw	; get the residule
	rlc		; * 4
	rlc
	push	b	; subtract from the address of the bottom of the loop
	cma
	mov	c,a
	mvi	b,0FFH
	inx	b
	dad	b
	pop	b
	xthl		; effectively jumps to the correct loop code
	ret
L4:	mov	a, m
	stax	d
	inx	h
	inx	d
	mov	a, m
	stax	d
	inx	h
	inx	d
	mov	a, m
	stax	d
	inx	h
	inx	d
	mov	a, m
	stax	d
	inx	h
	inx	d
	mov	a, m
	stax	d
	inx	h
	inx	d
	mov	a, m
	stax	d
	inx	h
	inx	d
	mov	a, m
	stax	d
	inx	h
	inx	d
	mov	a, m
	stax	d
	inx	h
	inx	d

L5:	dcr	c
	jnz	L4
	dcr	b
	jnz	L4
	ret

L6:	mov	a, m
	stax	d
	dcx	h
	dcx	d
	mov	a, m
	stax	d
	dcx	h
	dcx	d
	mov	a, m
	stax	d
	dcx	h
	dcx	d
	mov	a, m
	stax	d
	dcx	h
	dcx	d
	mov	a, m
	stax	d
	dcx	h
	dcx	d
	mov	a, m
	stax	d
	dcx	h
	dcx	d
	mov	a, m
	stax	d
	dcx	h
	dcx	d
	mov	a, m
	stax	d
	dcx	h
	dcx	d

L7:	dcr	c
	jnz	L6
	dcr	b
	jnz	L6
	ret

	END


?out1.asm
	name OUT1
	public	OHEXB, OHEXW, OHEXPB, OHEXPW
	extrn	OBUFP

	CSEG
OHEXPB:	ldax	b
	mov	c,a
	jmp	OHEXB
OHEXPW:	mov	h,b
	mov	l,c
	mov	c,m
	inx	h
	mov	b,m
OHEXW:	mov	a,c
	mov	c,b
	mov	b,a
	call	OHEXB
	mov	c,b
OHEXB:	lhld	OBUFP
	mov	a,c
	rlc
	rlc
	rlc
	rlc
	call	OHEXN
	mov	a,c
OHEXN:
	ani	0FH
	adi	30H
	cpi	3AH
	jc	L001E
	adi	7
L001E:
	mov	m,a
	inx	h
	shld	OBUFP
	ret

	end
?out10.plm
OUT10: DO;
OutScanByte: procedure external; end;

OutScanBytes: procedure(n) public;
	declare n byte;

	do while n > 0;
		call OutScanByte;
		n = n - 1;
	end;
end;
end;

?out11.asm
	name OUT11
	public OBUFP, ZZOPRI, ZZOWRI, ZZOADD, ZZOCRL, ZZOCHR, ZZOBLK

	cseg

ZZOBLK:	mvi	c,' '		; save a space
ZZOCHR:	lhld	OBUFP		; save character
	mov	m,c
	inx	h
	shld	OBUFP
	ret
ZZOCRL:	lxi	b,0A0DH		; save crlf
ZZOADD:	lhld	OBUFP		; save byte pair
	mov	m,c
	inx	h
	mov	m,b
	inx	h
	shld	OBUFP
	ret
ZZOWRI:	sub	a		; copy from *bc -> *OBUFP for e chars
	add	e
	rz
	lhld	OBUFP
L1F:
	ldax	b
	mov	m,a
	inx	h
	inx	b
	dcr	e
	jnz	L1F
L27:
	shld	OBUFP
	ret
ZZOPRI:	lhld	OBUFP		; copy from *bc -> *OBUFP until *bc == 0
L2E:
	ldax	b
	ana	a
	jz	L27
	mov	m,a
	inx	h
	inx	b
	jmp	L2E

	dseg
OBUFP:	dw	0
	end
?out2.plm
OUT2: DO;
/* b1=01, b2=31, CODE(12H) byte, DATA(0H) byte, STACK(0H) byte, MEMORY(0H) byte,*/
declare jmp literally '0c3h';

declare (zzochr, zzocrl, zzoblk, zzowri, zzopri, zzoadd) label external;

declare outchar byte public data(jmp), outcharAddr address data(.zzochr);
declare outcrlf  byte public data(jmp), outcrlfAddr address data(.zzocrl);
declare outblank byte public data(jmp), outblankAddr address data(.zzoblk);
declare outwrite byte public data(jmp), outwriteAddr address data(.zzowri);
declare outprint byte public data(jmp), outprintAddr address data(.zzopri);
declare outaddr  byte public data(jmp), outaddrAddr address data(.zzoadd);

end;
?out3.plm
OUT3: DO;

OUTDECR: PROCEDURE(A, B) EXTERNAL; DECLARE A ADDRESS, B BYTE; END;

OUTDEC: PROCEDURE(A) PUBLIC;
	DECLARE A ADDRESS;
	call OUTDECR(A, 0);
END;

END;
?out4.asm
	name	OUT4
	extrn	OBUFP
	public  SETOB
	stkln	14


	CSEG
SETOB:	pop	d		; return address
	lhld	OBUFP
	push	h		; old OBUFP	
	lxi	h,ROBUFP	; push return address for call to restore OBUFP
	push	h
	mov	h,b		; OBUFP = bc
	mov	l,c
	shld	OBUFP
	push	d		; restore return address
	ret

ROBUFP:	xchg
	pop	h
	shld	OBUFP
	xchg
	ret

	end
?out6.plm
OUT6: DO;

OUTCHARS: PROCEDURE(CNT, CH) EXTERNAL; DECLARE (CNT, CH) BYTE; END;
DECSIZ: PROCEDURE(N) BYTE EXTERNAL; DECLARE N ADDRESS; END;
DECLARE OBUFP ADDRESS EXTERNAL;

DECLARE LEADCHAR BYTE PUBLIC INITIAL(' ');

OUTDECR: PROCEDURE(N, WIDTH) PUBLIC;
	DECLARE N ADDRESS, WIDTH BYTE;
	DECLARE CHP ADDRESS, NDIGIT BYTE,
		CH BASED CHP BYTE;

	if (NDIGIT := DECSIZ(N)) < WIDTH THEN
		CALL OUTCHARS(WIDTH - NDIGIT, LEADCHAR);
	
	CHP = OBUFP + NDIGIT;
	DO WHILE CHP > OBUFP;
		CHP = CHP - 1;
		CH = '0' + N mod 10;
		N = N / 10;
	END;	
	OBUFP = OBUFP + NDIGIT;
END;
END;

?out7.plm
OUT7: DO;

OUTCHAR: PROCEDURE(CH) EXTERNAL; DECLARE CH BYTE; END;


OUTCHARS: PROCEDURE(CNT, CH) PUBLIC;
	DECLARE (CNT, CH) BYTE;

	DO WHILE CNT > 0;
		CALL OUTCHAR(CH);
		CNT = CNT - 1;
	END;
END;
END;

?out8.plm
OUT8: DO;

BUMPSCANP: PROCEDURE EXTERNAL; END;
OUTCHAR: PROCEDURE(CH) EXTERNAL; DECLARE CH BYTE; END;
DECLARE SCANP ADDRESS EXTERNAL,
	SCANCH BASED SCANP BYTE;

OUTSCANBYTE: PROCEDURE PUBLIC;
	call OUTCHAR(SCANCH);
	call BUMPSCANP;
end;
end;
?out9.plm
OUT9: DO;

OUTSCANBYTE: PROCEDURE EXTERNAL; END;
SETSCANENDED: PROCEDURE EXTERNAL; END;
DECLARE SCANP ADDRESS EXTERNAL,
	SCANENDED BYTE EXTERNAL;
SETSC: PROCEDURE(SCANP) EXTERNAL; DECLARE SCANP ADDRESS; END;

OUTSCANSTRING: PROCEDURE PUBLIC;
	call SETSC(SCANP);
	call SETSCANENDED;
	do while not SCANENDED;
		call OUTSCANBYTE;
	end;
end;
end;
?rscan.asm
	name RSCAN
	extrn	SCANP
	public	RSCANB, RSCANA
	cseg

RSCANB:	lhld	SCANP	; return *(byte *)SCANP++
	mov	a,m
	inx	h
	shld	SCANP
	ret

RSCANA:	lhld	SCANP	; return *(address *)SCANP++
	mov	e,m
	inx	h
	mov	d,m
	inx	h
	shld	SCANP
	xchg
	ret

	end
?scan.asm
	name	scan
	public	QDIGCH, DDIGCH, BDIGCH, ANYCH, FORCUP, HDIGCH
	public	LETRCH, LTNMCH, TOKNCH, FILECH
	public	CRLFCH, TERMCH, BLNKCH, ASCBIN
	extrn	SCANP

	CSEG
NXTCH:	lhld	SCANP
	mov	a,m
	mov	b,a
	ret

QDIGCH:	call	NXTCH
	ori	1
	cpi	'9'
	jz	retz
DDIGCH:	call	NXTCH
	cpi	'0'
	jc	RETZ
	cpi	'9' + 1
	sbb	a
	ret
BDIGCH:	call	NXTCH
	ori	1
	cpi	'1'
	jnz	retz

ANYCH:	stc
	sbb	a
	ret

FORCUP:	call	NXTCH
	cpi	'a'
	rc
	cpi	'z' + 1
	rnc
	sui	20H
	ret

HDIGCH:	call	DDIGCH
	rc
	call	FORCUP
	cpi	'A'
	jc	RETZ
	cpi	'F' + 1
	jc	ANYCH

RETZ:	sub	a
	ret

LETRCH:	call	FORCUP
	cpi	'A'
	jc	RETZ
	cpi	'Z' + 1
	jc	ANYCH
	sub	a
	ret

LTNMCH:	call	LETRCH
	rc
	call	DDIGCH
	rc
	sub	a
	ret

TOKNCH:	call	LTNMCH
	rc
	mov	a,b
	cpi	'?'
	jz	ANYCH
	cpi	'@'
	jz	ANYCH
	cpi	'_'
	jz	ANYCH
	sub	a
	ret

FILECH:	call	LTNMCH
	rc
	mov	a,b
	cpi	':'
	jz	ANYCH
	cpi	'.'
	jz	ANYCH
	sub	a
	ret

CRLFCH:	call	NXTCH
	cpi	0DH	; CR
	jz	ANYCH
	cpi	0AH	; LF
	jz	ANYCH
	sub	a
	ret

TERMCH:	call	CRLFCH
	rc
	mov	a,b
	cpi	1BH	; esc
	jz	ANYCH
	sub	a
	ret

BLNKCH:	call	NXTCH
	cpi	9	; TAB
	jz	ANYCH
	cpi	' '
	jz	ANYCH
	sub	a
	ret

ASCBIN:	call	NXTCH
	sui	'0'
	cpi	10
	rc
	sui	7
	ani	5FH
	ret

	end

?scan1.plm
SCAN1: DO;

DECLARE SCAN$P ADDRESS EXTERNAL;
DECLARE CH BASED SCAN$P BYTE;

DECLARE SCAN$ENDED BYTE PUBLIC;
DECLARE ZZSCEN BYTE PUBLIC AT (.SCAN$ENDED);

FORCUP: PROCEDURE BYTE EXTERNAL; END FORCUP;

SETPF: PROCEDURE/*(FUNC)*/ EXTERNAL;
/*	DECLARE FUNC ADDRESS;*/
/* must be called immediately as first non declare statement
   as it relies on reg BC still holding in the passed in FUNC
*/
END SETPF;

PF: PROCEDURE BYTE EXTERNAL;
END PF;

SET$SCAN$ENDED: PROCEDURE PUBLIC;
	SCAN$ENDED = CH = 0;
END SET$SCAN$ENDED;

BUMP$SCANP: PROCEDURE PUBLIC;
	CALL SET$SCAN$ENDED;
	SCAN$P = SCAN$P + (SCAN$ENDED + 1);
	CALL SET$SCAN$ENDED;
END BUMP$SCANP;

SCAN$UNTIL: PROCEDURE(FUNC) PUBLIC;
	DECLARE FUNC ADDRESS;
	CALL SETPF/*(FUNC)*/;
	
	DO WHILE not PF;
		CALL BUMP$SCANP;
		if SCAN$ENDED then
			RETURN;
	END;
END SCAN$UNTIL;
	
	
SCAN$WHILE: PROCEDURE(FUNC) PUBLIC;
	DECLARE FUNC ADDRESS;
	CALL SETPF/*(FUNC)*/;
	
	DO WHILE PF;
		CALL BUMP$SCANP;
		if SCAN$ENDED then
			RETURN;
	END;
END SCAN$WHILE;

SCAN$MATCH: PROCEDURE(PTR) BYTE PUBLIC;
	DECLARE PTR ADDRESS;
	DECLARE C BASED PTR BYTE;
	DECLARE D7 ADDRESS;

	call	SET$SCAN$ENDED;
	D7 = SCAN$P;

	DO WHILE FORCUP = C AND NOT SCAN$ENDED;
		PTR = PTR + 1;
		CALL BUMP$SCANP;
		if C = 0 then
			return 0FFH;
	END;
	SCAN$P = D7;
	CALL Set$SCAN$ENDED;
	return 0;
END SCAN$MATCH;	

END;
?scan2.asm
	name SCAN2
	public SETPF, PF, PF1, PF2
	CSEG
SETPF:
	mov	h,b
	mov	l,c
	shld	PF+1
	ret

	DSEG

PF:
PF1:
PF2:	JMP	0
	END

?scan3.plm
SCAN3: DO;

SCAN$UNTIL: PROCEDURE(FUNC) EXTERNAL; DECLARE FUNC ADDRESS; END;
SCAN$WHILE$BLANKS: PROCEDURE EXTERNAL; END;
HDIGCH: PROCEDURE BYTE EXTERNAL; END;
DDIGCH: PROCEDURE BYTE EXTERNAL; END;
ASCBIN: PROCEDURE BYTE EXTERNAL; END;
BUMP$SCANP: PROCEDURE EXTERNAL; END;

DECLARE ACC ADDRESS;

HEXIN: PROCEDURE ADDRESS PUBLIC;

	ACC = 0;
	call SCAN$UNTIL(.HDIGCH);
	do while HDIGCH;
		ACC = ACC * 16 + ASCBIN;
		call	BUMP$SCANP;
	end;
	call	SCAN$WHILE$BLANKS;
	return ACC;
END;


DECIN: PROCEDURE ADDRESS PUBLIC;

	ACC = 0;
	call SCAN$UNTIL(.DDIGCH);
	do while DDIGCH;
		ACC = ACC * 10 + ASCBIN;
		call	BUMP$SCANP;
	end;
	call	SCAN$WHILE$BLANKS;
	return ACC;
END;

END;

?scan5.plm
SCAN5: DO;
BLNKCH: PROCEDURE BYTE EXTERNAL; END;
SCANWHILE: PROCEDURE(FUNC) EXTERNAL;
	DECLARE FUNC ADDRESS;
END;

SCANWHILEBLANKS: PROCEDURE PUBLIC;
	CALL SCANWHILE(.BLNKCH);
END;


END;
?scan6.plm
SCAN6: DO;

SCANMATCH: PROCEDURE(PTR) BYTE EXTERNAL; DECLARE PTR ADDRESS; END;
SETOB: PROCEDURE(PTR) EXTERNAL; DECLARE PTR ADDRESS; END;
OUTPRINT: PROCEDURE(STR) EXTERNAL; DECLARE STR ADDRESS; END;
OUTWRITE: PROCEDURE(FILE, STR) EXTERNAL; DECLARE (FILE, STR) ADDRESS; END;
ERRORMESSAGE: PROCEDURE(STR) EXTERNAL; DECLARE STR ADDRESS; END;

DECLARE MSG(*) BYTE INITIAL('SCAN ERROR: EXPECTED "',
/* 22 */		    '                               ');

SCANEXPECT: PROCEDURE(PTR) PUBLIC;
	DECLARE PTR ADDRESS;

	if SCANMATCH(PTR) THEN
		RETURN;
	CALL SETOB(.MSG(22));
	CALL OUTPRINT(PTR);
	CALL OUTWRITE(.('"', 0), 2);
	CALL ERRORMESSAGE(.MSG);	
END;

END;
?scan7.asm
	name	SCAN7
	extrn	SCANP, ZZSCEN
	public	SETSC
	stkln	14

	cseg
SETSC:	pop	d		; return address
	lhld	SCANP		; original SCANP
	push	h
	lxi	h,RSETSC	; push address of restore routine
	push	h
	mov	h,b		; SCANP = bc
	mov	l,c
	shld	SCANP
	push	d		; restore return address
	ret

RSETSC:	xchg
	pop	h
	shld	SCANP		; restore original SCANP
	mov	b,a
	sub	a
	sub	m
	cmc
	sbb	a
	sta	ZZSCEN
	mov	a,b
	xchg
	ret

	end

?scan9.plm
SCAN9: DO;

DECLARE	SCANP ADDRESS EXTERNAL,
	SCANENDED BYTE EXTERNAL;

SETSC: PROCEDURE(SCANP) EXTERNAL; DECLARE SCANP ADDRESS; END;
FORCUP: PROCEDURE BYTE EXTERNAL; END;
BUMPSCANP: PROCEDURE EXTERNAL; END;

FORCUPSTRING: PROCEDURE PUBLIC;
	DECLARE SCANCH BASED SCANP BYTE;

	call SETSC(SCANP);
	do while not SCANENDED;
		SCANCH = FORCUP;
		call BUMPSCANP;
	end;
end;

end;	

?scanp.asm
	name SCANP
	public SCANP
	dseg
SCANP:	dw	0
	end;

?sfound.asm
	name SFOUND
	public SFOUND, TARLEN, JOKER, GIVEUP
	extrn SCANP, TARGET

	DSEG
TARLEN:	db	0
JOKER:	db	'?'
GIVEUP:	dw	0

	CSEG
SFOUND: lhld	GIVEUP
	xchg
	lhld	TARLEN
	mov	b,h		; b = joker
	mov	c,l		; c = tarlen
	lhld	SCANP
	mov	a,e
	sub	l
	mov	e,a
	mov	a,d
	sbb	h
	mov	d,a
	ora	e
	rz			; nothing to check
	inr	d		; adjust for simple loop checks
	inr	e
trial:
	lda	TARGET
	call	first		; returns if first char found
	push	b		; save joker and tarlen
	push	d		; save counters
	push	h		; save where we are matching
	lxi	d,TARGET
match:
	dcr	c		; matched one more
	inx	d
	jz	found		; all done?
	ldax	d
	cmp	m
	inx	h
	jz	match		; still matching
	cmp	b
	jz	match		; or is wild card
	pop	h		; no match so restore and retry
	pop	d
	pop	b
	jmp	trial
found:
	mvi	a,0FFH		; found
	shld	SCANP		; save location after this string
	pop	b		; junk the stack saves
	pop	b
	pop	b
	ret
match1:
	cmp	m		; start match found
	inx	h
	rz			; return just the one level
first:
	dcr	e
	jnz	match1
	dcr	d
	jnz	match1
	pop	psw		; junk first return address
	sub	a		; return 0 to original caller
	ret

	END	
?vernum.plm
VERSIONNUMBER1P0: DO;
end;

util3/makefile
# common makefile info
ROOT=../../..
unexport ISIS_F1
TARGETS=util3.lib

include $(ROOT)/tools/isis.mk

REF = $(call ipath,toolbox,1.0)
PLM80 = 3.1
ASM80 = 2.0

OBJS = 	ver11.obj bit.obj bmove.obj comp1.obj comp2.obj comp3.obj comp4.obj\
	comp5.obj comp6.obj cons1.obj cons2.obj cons3.obj cons4.obj fill.obj\
	fmove.obj out1.obj out2.obj out3.obj out4.obj out6.obj out7.obj\
	out8.obj out9.obj out10.obj out11.obj rscan.obj scan.obj scan1.obj\
	scan2.obj scan3.obj scan5.obj scan6.obj scan7.obj scan9.obj scanp.obj\
	sfound.obj outfnm.obj inmod.obj cfnext.obj

all::
	$(MAKE) $(TARGETS)

util3.lib: $(OBJS)
	$(call lib,$@,$^)

util3/util3_all.src
?bit.asm
	name BIT
	public	BIT

; DECLARE BITMASK(*) BYTE DATA(80H, 40H, 20H, 10H, 8, 4, 2, 1);
; BIT: PROCEDURE(BITN, PBITS ) BYTE PUBLIC;
;      DECLARE N BYTE, PBITS ADDRESS;
;      DECLARE BITS BASED PBITS (1) BYTE;
;      IF N > BITS(0) THEN RETURN 0;
;      RETURN (BITS(1 + SHR(N, 3)) AND BITMASK(N AND 7)) <> 0;
; END;
	CSEG
BIT:	ldax	d
	cmp	c
	mvi	a,0
	rc
	inx	d
	xchg
	mov	d,a
	mov	a,c
	ani	0F8H
	rrc
	rrc
	rrc
	mov	e,a
	dad	d
	mov	a,c
	ani	7
	mov	e,a
	mov	a,m
	lxi	h,MASKS
	dad	d
	ana	m
	rz
	mvi	a,0FFH
	ret

MASKS:	db	80H, 40H, 20H, 10H, 8, 4, 2, 1

	end;
?bmove.asm
	name	BMOVE
	extrn	ZFMOVE
	public	BMOVE, MOVE2, MOVE3, MOVE4, MOVE5, MOVE6, MOVE7, MOVE8
	public	MOVE9, MOVE10, MOVE11, MOVE12, MOVE13, MOVE14, MOVE15
	public	MOVE16, MOVE17, MOVE18, MOVE19, MOVE20, MOVE21, MOVE22
	public	MOVE23, MOVE24

	cseg page
MOVE24:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE23:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE22:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE21:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE20:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE19:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE18:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE17:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE16:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE15:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE14:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE13:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE12:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE11:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE10:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE9:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE8:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE7:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE6:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE5:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE4:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE3:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE2:	ldax	b
	stax	d
	inx	b
	inx	d
	ldax	b
	stax	d
	ret
	nop
	ret

BMOVE:	pop	h
	xthl
	mvi	a,24
	sub	l
	jc	L6F
	add	a
	add	a
	mov	l,a
	mvi	h,HIGH move24
	pchl
L6F:
	mvi	h,0
	jmp	ZFMOVE

	end;
?cfnext.plm
CHFNMEXTMOD: DO;
/* b1=01, b2=31, CODE(51H) byte, DATA(8H) byte, STACK(2H) byte, MEMORY(0H) byte,*/
declare	OBUFP	address external,
	SCANP	address external;

OUTCHAR: PROCEDURE(ch) external; declare ch byte; end;
OUTPRINT: PROCEDURE(str) external; declare str address; end;
SCANUNTIL: PROCEDURE(proc) external; declare proc address; end;

CHFNMEXT: procedure(fname, ext) public;
	declare (fname, ext) address;
	declare (saveScanp, saveObufp) address;

	isDot: procedure byte;
		declare ch based scanp byte;
		return ch = '.';
	end;

	saveScanp = scanp;
	scanp = fname;
	call scanuntil(.isDot);
	saveObufp = obufp;
	obufp = scanp;
	call outchar('.');
	call outprint(ext);
	call outchar(0);
	scanp = saveScanp;
	obufp = saveObufp;
	return;
end;
end;
?comp1.asm
	name	COMP1
	public	MAX
	CSEG

; max(n, m) address

MAX:	xchg
	mov	a,c
	sub	l
	mov	a,b
	sbb	h
	rc		; m > n to return the original m
	mov	h,b
	mov	l,c
	ret		; return the n

	end
?comp2.asm
	name	COMP2
	public	MIN
	CSEG

; min(n, m) address

MIN:	xchg
	mov	a,c
	sub	l
	mov	a,b
	sbb	h
	rnc		; m < n so return m
	mov	h,b
	mov	l,c
	ret		; return n

	end
?comp3.asm
	name	COMP3
	public	DECSIZ

; DECSIZE(N) BYTE - returns number of digits in N
	cseg

DECSIZ:	mov	h,b
	mov	l,c
	mvi	a,1
	lxi	d,-10
	dad	d
	rnc
	inr	a
	lxi	d,-90
	dad	d
	rnc
	inr	a
	lxi	d,-900
	dad	d
	rnc
	inr	a
	lxi	d,-9000
	dad	d
	rnc
	inr	a
	ret

	end
?comp4.plm
COMP4: DO;

SETSC: PROCEDURE(SCANP) EXTERNAL; DECLARE SCANP ADDRESS; END;
SCANWHILE: PROCEDURE(FUNC) EXTERNAL; DECLARE FUNC ADDRESS; END;
ANYCH: PROCEDURE BYTE EXTERNAL; END;
DECLARE SCANP ADDRESS EXTERNAL;

LENSTRNUL: PROCEDURE(STR) BYTE PUBLIC;
	DECLARE STR ADDRESS;
	CALL SETSC(STR);
	CALL SCANWHILE(.ANYCH);
	RETURN SCANP - STR;
END;
END;

?comp5.plm
COMP5: DO;

declare scanP address external;
ScanWhile: procedure(func) external; declare func address; end;
SetSc: procedure(scanp) external; declare scanp address; end;

StringLength: procedure(ptr, func) byte public;
	declare (ptr, func) address;

	call SetSc(ptr);
	call ScanWhile(func);
	return scanP - ptr;
end;
end;
?comp6.asm
	name COMP6
	public	ONBIT

	CSEG
ONBIT:	stc
	mov	a,c
	mvi	c,0FFH

L4:	inr	c
	rar
	jnc	L4
	mov	a,c
	ret

	end

?cons1.plm
CONS1: DO;
DECLARE ACTUAL ADDRESS EXTERNAL,
	SCANP ADDRESS EXTERNAL,
	SCANBUF BASED SCANP (1) BYTE;

READC: PROCEDURE(buf, len) EXTERNAL; DECLARE (buf, len) ADDRESS; END;

CONSOLEIN: PROCEDURE PUBLIC;
	DECLARE buf(121) BYTE;
	CALL READC((SCANP := .buf), last(buf));
	SCANBUF(ACTUAL) = 0;
END;

END;	

?cons2.plm
CONS2: DO;

WRITEC: PROCEDURE(buf, len) EXTERNAL; DECLARE (buf, len) ADDRESS; END;


PUTCHAR: PROCEDURE(CH) PUBLIC;
	DECLARE CH BYTE;
	CALL WRITEC(.CH, 1);
END;

PUTCRLF: PROCEDURE PUBLIC;
	call PUTCHAR(0DH);
	call PUTCHAR(0AH);
END;

PRINT: PROCEDURE(STR) PUBLIC;
	DECLARE STR ADDRESS,
		CH BASED STR BYTE;

	DO WHILE CH <> 0;
		CALL PUTCHAR(CH);
		STR = STR + 1;
	END;
END;

PRINTCR: PROCEDURE(STR) PUBLIC;
	DECLARE STR ADDRESS;
	CALL PRINT(STR);
	CALL PUTCRLF;
END;

PUTBLANK: PROCEDURE PUBLIC;
	CALL PUTCHAR(' ');
END;

END;
?cons3.plm
CONS3: DO;
DECLARE OBUFP ADDRESS EXTERNAL;
SETOB: PROCEDURE(PTR) EXTERNAL; DECLARE PTR ADDRESS; END;
OUTDEC: PROCEDURE(N) EXTERNAL; DECLARE N ADDRESS; END;
OHEXB: PROCEDURE(N) EXTERNAL; DECLARE N ADDRESS; END;
OHEXW: PROCEDURE(N) EXTERNAL; DECLARE N ADDRESS; END;
SETPF: PROCEDURE/*(FUNC)*/ EXTERNAL; END;
PF: PROCEDURE(N) EXTERNAL; DECLARE N ADDRESS; END;
WRITEC: PROCEDURE(buf, len) EXTERNAL; DECLARE (buf, len) ADDRESS; END;

DECLARE BUF(6) BYTE;

WRITENUM: PROCEDURE(FUNC, N);
	DECLARE (FUNC, N) ADDRESS;
	call	SETPF;
	call	SETOB(.BUF);
	call	PF(N);
	CALL	WRITEC(.BUF, OBUFP - .BUF);
END;

DEC: PROCEDURE(N) PUBLIC;
	DECLARE N ADDRESS;
	CALL WRITENUM(.OUTDEC, N);
END;

HEXB: PROCEDURE(N) PUBLIC;
	DECLARE N BYTE;
	CALL WRITENUM(.OHEXB, N);
END;

HEXW: PROCEDURE(N) PUBLIC;
	DECLARE N ADDRESS;
	CALL WRITENUM(.OHEXW, N);
END;

END;
?cons4.plm
CONS4: DO;
DECLARE STATUS ADDRESS EXTERNAL,
	REPORT BYTE EXTERNAL,
	FATAL BYTE EXTERNAL;

PUTCRLF: PROCEDURE EXTERNAL; END;
EX: PROCEDURE EXTERNAL; END;
PRINT: PROCEDURE(STR) EXTERNAL; DECLARE STR ADDRESS; END;


STARS: PROCEDURE;
	CALL PRINT(.(' *** ', 0));
END;

ERRORMESSAGE: PROCEDURE(MSG) PUBLIC;
	DECLARE MSG ADDRESS;
	STATUS = MSG;
	IF NOT REPORT THEN RETURN;

	CALL STARS;
	CALL PRINT(MSG);
	CALL STARS;
	CALL PUTCRLF;
	IF FATAL THEN CALL EX;
END;

END;
?fill.asm
	name FILL
	public FILL

	CSEG

; FILL: PROCEDURE(CNT, DST, VAL) PROCEDURE;
;	DECLARE (CNT, DST) ADDRESS, VAL BYTE;
; END;

FILL:   pop	h	; CNT to HL
	xthl
	mov	a,e	; VAL in A reg
	inr	l	; adjust for quick loop check
	inr	h
	jmp	L2

L1:	stax	b
	inx	b

L2:	dcr	l
	jnz	L1
	dcr	h
	jnz	L1
	ret

	END;
?fmove.asm
	name	FMOVE
	public	FMOVE, ZFMOVE

; fmove(cnt, src, dst)
	cseg

FMOVE:	pop	h	; hl = cnt arg
	xthl
ZFMOVE:
	push	b	; src
	mov	b,h	; xchg hl,bc
	mov	c,l
	pop	h
	dcx	b
	mov	a,e	; dst - src
	sub	l
	mov	a,d
	jz	L1	; possibly same
	sbb	h
	jmp	L2
L1:
	sbb	h
	rz		; nothing to do
L2:
	push	h
	lxi	h,L5
	jc	L3	; src > dst so copy forward
	pop	h
	dad	b	; adjust to copy backwards
	push	h
	xchg
	dad	b
	xchg
	lxi	h,L7
L3:
	inx	b
	mov	a,b	; rrc b,3
	rrc		; the hack below effectively does shl(bc, 3)
	rrc
	rrc
	mov	b,a
	mvi	a,7	; mask of part count
	ana	c
	push	psw
	xra	c	; invert the mask
	rrc		; rrc c,3
	rrc
	rrc
	xra	b	; merge with the rrc b,3 above
	ani	1FH	; mask of the lower bit that are to go in b
	xra	b	; this will leave low 5 bits of c + top 3 bits from b
	mov	c,a	
	mvi	a,1FH
	ana	b	; get the lower bits of b back
	mov	b,a	; end of hack
	inr	b	; adjust for simple loop test
	inr	c
	pop	psw	; get the residule
	rlc		; * 4
	rlc
	push	b	; subtract from the address of the bottom of the loop
	cma
	mov	c,a
	mvi	b,0FFH
	inx	b
	dad	b
	pop	b
	xthl		; effectively jumps to the correct loop code
	ret
L4:	mov	a, m
	stax	d
	inx	h
	inx	d
	mov	a, m
	stax	d
	inx	h
	inx	d
	mov	a, m
	stax	d
	inx	h
	inx	d
	mov	a, m
	stax	d
	inx	h
	inx	d
	mov	a, m
	stax	d
	inx	h
	inx	d
	mov	a, m
	stax	d
	inx	h
	inx	d
	mov	a, m
	stax	d
	inx	h
	inx	d
	mov	a, m
	stax	d
	inx	h
	inx	d

L5:	dcr	c
	jnz	L4
	dcr	b
	jnz	L4
	ret

L6:	mov	a, m
	stax	d
	dcx	h
	dcx	d
	mov	a, m
	stax	d
	dcx	h
	dcx	d
	mov	a, m
	stax	d
	dcx	h
	dcx	d
	mov	a, m
	stax	d
	dcx	h
	dcx	d
	mov	a, m
	stax	d
	dcx	h
	dcx	d
	mov	a, m
	stax	d
	dcx	h
	dcx	d
	mov	a, m
	stax	d
	dcx	h
	dcx	d
	mov	a, m
	stax	d
	dcx	h
	dcx	d

L7:	dcr	c
	jnz	L6
	dcr	b
	jnz	L6
	ret

	END


?inmod.plm
ISISINMOD: DO;

ConsoleIn: procedure external; end;
TermCh: procedure byte external; end;
ScanUntil: procedure(func) external; declare func address; end;
declare scanP address external;
declare ch based scanP byte;

isisIn: procedure public;
	declare ptr address;

	call ConsoleIn;
	ptr = scanP;
	call ScanUntil(.TermCh);
	ch = 0;
	scanP = ptr;
end;
end;
?out1.asm
	name OUT1
	public	OHEXB, OHEXW, OHEXPB, OHEXPW
	extrn	OBUFP

	CSEG
OHEXPB:	ldax	b
	mov	c,a
	jmp	OHEXB
OHEXPW:	mov	h,b
	mov	l,c
	mov	c,m
	inx	h
	mov	b,m
OHEXW:	mov	a,c
	mov	c,b
	mov	b,a
	call	OHEXB
	mov	c,b
OHEXB:	lhld	OBUFP
	mov	a,c
	rlc
	rlc
	rlc
	rlc
	call	OHEXN
	mov	a,c
OHEXN:
	ani	0FH
	adi	30H
	cpi	3AH
	jc	L001E
	adi	7
L001E:
	mov	m,a
	inx	h
	shld	OBUFP
	ret

	end
?out10.plm
OUT10: DO;
OutScanByte: procedure external; end;

OutScanBytes: procedure(n) public;
	declare n byte;

	do while n > 0;
		call OutScanByte;
		n = n - 1;
	end;
end;
end;

?out11.asm
	name OUT11
	public OBUFP, ZZOPRI, ZZOWRI, ZZOADD, ZZOCRL, ZZOCHR, ZZOBLK

	cseg

ZZOBLK:	mvi	c,' '		; save a space
ZZOCHR:	lhld	OBUFP		; save character
	mov	m,c
	inx	h
	shld	OBUFP
	ret
ZZOCRL:	lxi	b,0A0DH		; save crlf
ZZOADD:	lhld	OBUFP		; save byte pair
	mov	m,c
	inx	h
	mov	m,b
	inx	h
	shld	OBUFP
	ret
ZZOWRI:	sub	a		; copy from *bc -> *OBUFP for e chars
	add	e
	rz
	lhld	OBUFP
L1F:
	ldax	b
	mov	m,a
	inx	h
	inx	b
	dcr	e
	jnz	L1F
L27:
	shld	OBUFP
	ret
ZZOPRI:	lhld	OBUFP		; copy from *bc -> *OBUFP until *bc == 0
L2E:
	ldax	b
	ana	a
	jz	L27
	mov	m,a
	inx	h
	inx	b
	jmp	L2E

	dseg
OBUFP:	dw	0
	end
?out2.plm
OUT2: DO;
/* b1=01, b2=31, CODE(12H) byte, DATA(0H) byte, STACK(0H) byte, MEMORY(0H) byte,*/
declare jmp literally '0c3h';

declare (zzochr, zzocrl, zzoblk, zzowri, zzopri, zzoadd) label external;

declare outchar byte public data(jmp), outcharAddr address data(.zzochr);
declare outcrlf  byte public data(jmp), outcrlfAddr address data(.zzocrl);
declare outblank byte public data(jmp), outblankAddr address data(.zzoblk);
declare outwrite byte public data(jmp), outwriteAddr address data(.zzowri);
declare outprint byte public data(jmp), outprintAddr address data(.zzopri);
declare outaddr  byte public data(jmp), outaddrAddr address data(.zzoadd);

end;
?out3.plm
OUT3: DO;

OUTDECR: PROCEDURE(A, B) EXTERNAL; DECLARE A ADDRESS, B BYTE; END;

OUTDEC: PROCEDURE(A) PUBLIC;
	DECLARE A ADDRESS;
	call OUTDECR(A, 0);
END;

END;
?out4.asm
	name	OUT4
	extrn	OBUFP
	public  SETOB
	stkln	14


	CSEG
SETOB:	pop	d		; return address
	lhld	OBUFP
	push	h		; old OBUFP	
	lxi	h,ROBUFP	; push return address for call to restore OBUFP
	push	h
	mov	h,b		; OBUFP = bc
	mov	l,c
	shld	OBUFP
	push	d		; restore return address
	ret

ROBUFP:	xchg
	pop	h
	shld	OBUFP
	xchg
	ret

	end
?out6.plm
OUT6: DO;

OUTCHARS: PROCEDURE(CNT, CH) EXTERNAL; DECLARE (CNT, CH) BYTE; END;
DECSIZ: PROCEDURE(N) BYTE EXTERNAL; DECLARE N ADDRESS; END;
DECLARE OBUFP ADDRESS EXTERNAL;

DECLARE LEADCHAR BYTE PUBLIC INITIAL(' ');

OUTDECR: PROCEDURE(N, WIDTH) PUBLIC;
	DECLARE N ADDRESS, WIDTH BYTE;
	DECLARE CHP ADDRESS, NDIGIT BYTE,
		CH BASED CHP BYTE;

	if (NDIGIT := DECSIZ(N)) < WIDTH THEN
		CALL OUTCHARS(WIDTH - NDIGIT, LEADCHAR);
	
	CHP = OBUFP + NDIGIT;
	DO WHILE CHP > OBUFP;
		CHP = CHP - 1;
		CH = '0' + N mod 10;
		N = N / 10;
	END;	
	OBUFP = OBUFP + NDIGIT;
END;
END;

?out7.plm
OUT7: DO;

OUTCHAR: PROCEDURE(CH) EXTERNAL; DECLARE CH BYTE; END;


OUTCHARS: PROCEDURE(CNT, CH) PUBLIC;
	DECLARE (CNT, CH) BYTE;

	DO WHILE CNT > 0;
		CALL OUTCHAR(CH);
		CNT = CNT - 1;
	END;
END;
END;

?out8.plm
OUT8: DO;

BUMPSCANP: PROCEDURE EXTERNAL; END;
OUTCHAR: PROCEDURE(CH) EXTERNAL; DECLARE CH BYTE; END;
DECLARE SCANP ADDRESS EXTERNAL,
	SCANCH BASED SCANP BYTE;

OUTSCANBYTE: PROCEDURE PUBLIC;
	call OUTCHAR(SCANCH);
	call BUMPSCANP;
end;
end;
?out9.plm
OUT9: DO;

OUTSCANBYTE: PROCEDURE EXTERNAL; END;
SETSCANENDED: PROCEDURE EXTERNAL; END;
DECLARE SCANP ADDRESS EXTERNAL,
	SCANENDED BYTE EXTERNAL;
SETSC: PROCEDURE(SCANP) EXTERNAL; DECLARE SCANP ADDRESS; END;

OUTSCANSTRING: PROCEDURE PUBLIC;
	call SETSC(SCANP);
	call SETSCANENDED;
	do while not SCANENDED;
		call OUTSCANBYTE;
	end;
end;
end;
?outfnm.plm
OUTFNM: DO;

OutScanByte: procedure external; end;
FileCh: procedure byte external; end;
ScanWhileBlanks: procedure external; end;

OutFileName: procedure public;
	declare i byte;

	call ScanWhileBlanks;
	do i = 1 to 14;
		if FileCh then
			call OutScanByte;
		else
			goto done;
	end;
done:
end;
end;

?rscan.asm
	name RSCAN
	extrn	SCANP
	public	RSCANB, RSCANA
	cseg

RSCANB:	lhld	SCANP	; return *(byte *)SCANP++
	mov	a,m
	inx	h
	shld	SCANP
	ret

RSCANA:	lhld	SCANP	; return *(address *)SCANP++
	mov	e,m
	inx	h
	mov	d,m
	inx	h
	shld	SCANP
	xchg
	ret

	end
?scan.asm
	name	scan
	public	QDIGCH, DDIGCH, BDIGCH, ANYCH, FORCUP, HDIGCH
	public	LETRCH, LTNMCH, TOKNCH, FILECH
	public	CRLFCH, TERMCH, BLNKCH, ASCBIN
	extrn	SCANP

	CSEG
NXTCH:	lhld	SCANP
	mov	a,m
	mov	b,a
	ret

QDIGCH:	call	NXTCH
	ori	1
	cpi	'9'
	jz	retz
DDIGCH:	call	NXTCH
	cpi	'0'
	jc	RETZ
	cpi	'9' + 1
	sbb	a
	ret
BDIGCH:	call	NXTCH
	ori	1
	cpi	'1'
	jnz	retz

ANYCH:	stc
	sbb	a
	ret

FORCUP:	call	NXTCH
	cpi	'a'
	rc
	cpi	'z' + 1
	rnc
	sui	20H
	ret

HDIGCH:	call	DDIGCH
	rc
	call	FORCUP
	cpi	'A'
	jc	RETZ
	cpi	'F' + 1
	jc	ANYCH

RETZ:	sub	a
	ret

LETRCH:	call	FORCUP
	cpi	'A'
	jc	RETZ
	cpi	'Z' + 1
	jc	ANYCH
	sub	a
	ret

LTNMCH:	call	LETRCH
	rc
	call	DDIGCH
	rc
	sub	a
	ret

TOKNCH:	call	LTNMCH
	rc
	mov	a,b
	cpi	'?'
	jz	ANYCH
	cpi	'@'
	jz	ANYCH
	cpi	'_'
	jz	ANYCH
	sub	a
	ret

FILECH:	call	LTNMCH
	rc
	mov	a,b
	cpi	':'
	jz	ANYCH
	cpi	'.'
	jz	ANYCH
	sub	a
	ret

CRLFCH:	call	NXTCH
	cpi	0DH	; CR
	jz	ANYCH
	cpi	0AH	; LF
	jz	ANYCH
	sub	a
	ret

TERMCH:	call	CRLFCH
	rc
	mov	a,b
	cpi	1BH	; esc
	jz	ANYCH
	sub	a
	ret

BLNKCH:	call	NXTCH
	cpi	9	; TAB
	jz	ANYCH
	cpi	' '
	jz	ANYCH
	sub	a
	ret

ASCBIN:	call	NXTCH
	sui	'0'
	cpi	10
	rc
	sui	7
	ani	5FH
	ret

	end

?scan1.plm
SCAN1: DO;

DECLARE SCAN$P ADDRESS EXTERNAL;
DECLARE CH BASED SCAN$P BYTE;

DECLARE SCAN$ENDED BYTE PUBLIC;
DECLARE ZZSCEN BYTE PUBLIC AT (.SCAN$ENDED);

FORCUP: PROCEDURE BYTE EXTERNAL; END FORCUP;

SETPF: PROCEDURE/*(FUNC)*/ EXTERNAL;
/*	DECLARE FUNC ADDRESS;*/
/* must be called immediately as first non declare statement
   as it relies on reg BC still holding in the passed in FUNC
*/
END SETPF;

PF: PROCEDURE BYTE EXTERNAL;
END PF;

SET$SCAN$ENDED: PROCEDURE PUBLIC;
	SCAN$ENDED = CH = 0;
END SET$SCAN$ENDED;

BUMP$SCANP: PROCEDURE PUBLIC;
	CALL SET$SCAN$ENDED;
	SCAN$P = SCAN$P + (SCAN$ENDED + 1);
	CALL SET$SCAN$ENDED;
END BUMP$SCANP;

SCAN$UNTIL: PROCEDURE(FUNC) PUBLIC;
	DECLARE FUNC ADDRESS;
	CALL SETPF/*(FUNC)*/;
	
	DO WHILE not PF;
		CALL BUMP$SCANP;
		if SCAN$ENDED then
			RETURN;
	END;
END SCAN$UNTIL;
	
	
SCAN$WHILE: PROCEDURE(FUNC) PUBLIC;
	DECLARE FUNC ADDRESS;
	CALL SETPF/*(FUNC)*/;
	
	DO WHILE PF;
		CALL BUMP$SCANP;
		if SCAN$ENDED then
			RETURN;
	END;
END SCAN$WHILE;

SCAN$MATCH: PROCEDURE(PTR) BYTE PUBLIC;
	DECLARE PTR ADDRESS;
	DECLARE C BASED PTR BYTE;
	DECLARE D7 ADDRESS;

	call	SET$SCAN$ENDED;
	D7 = SCAN$P;

	DO WHILE FORCUP = C AND NOT SCAN$ENDED;
		PTR = PTR + 1;
		CALL BUMP$SCANP;
		if C = 0 then
			return 0FFH;
	END;
	SCAN$P = D7;
	CALL Set$SCAN$ENDED;
	return 0;
END SCAN$MATCH;	

END;
?scan2.asm
	name SCAN2
	public SETPF, PF, PF1, PF2
	CSEG
SETPF:
	mov	h,b
	mov	l,c
	shld	PF+1
	ret

	DSEG

PF:
PF1:
PF2:	JMP	0
	END

?scan3.plm
SCAN3: DO;

SCAN$UNTIL: PROCEDURE(FUNC) EXTERNAL; DECLARE FUNC ADDRESS; END;
SCAN$WHILE$BLANKS: PROCEDURE EXTERNAL; END;
HDIGCH: PROCEDURE BYTE EXTERNAL; END;
DDIGCH: PROCEDURE BYTE EXTERNAL; END;
ASCBIN: PROCEDURE BYTE EXTERNAL; END;
BUMP$SCANP: PROCEDURE EXTERNAL; END;

DECLARE ACC ADDRESS;

HEXIN: PROCEDURE ADDRESS PUBLIC;

	ACC = 0;
	call SCAN$UNTIL(.HDIGCH);
	do while HDIGCH;
		ACC = ACC * 16 + ASCBIN;
		call	BUMP$SCANP;
	end;
	call	SCAN$WHILE$BLANKS;
	return ACC;
END;


DECIN: PROCEDURE ADDRESS PUBLIC;

	ACC = 0;
	call SCAN$UNTIL(.DDIGCH);
	do while DDIGCH;
		ACC = ACC * 10 + ASCBIN;
		call	BUMP$SCANP;
	end;
	call	SCAN$WHILE$BLANKS;
	return ACC;
END;

END;

?scan5.plm
SCAN5: DO;
BLNKCH: PROCEDURE BYTE EXTERNAL; END;
SCANWHILE: PROCEDURE(FUNC) EXTERNAL;
	DECLARE FUNC ADDRESS;
END;

SCANWHILEBLANKS: PROCEDURE PUBLIC;
	CALL SCANWHILE(.BLNKCH);
END;


END;
?scan6.plm
SCAN6: DO;

SCANMATCH: PROCEDURE(PTR) BYTE EXTERNAL; DECLARE PTR ADDRESS; END;
SETOB: PROCEDURE(PTR) EXTERNAL; DECLARE PTR ADDRESS; END;
OUTPRINT: PROCEDURE(STR) EXTERNAL; DECLARE STR ADDRESS; END;
OUTWRITE: PROCEDURE(FILE, STR) EXTERNAL; DECLARE (FILE, STR) ADDRESS; END;
ERRORMESSAGE: PROCEDURE(STR) EXTERNAL; DECLARE STR ADDRESS; END;

DECLARE MSG(*) BYTE INITIAL('SCAN ERROR: EXPECTED "',
/* 22 */		    '                               ');

SCANEXPECT: PROCEDURE(PTR) PUBLIC;
	DECLARE PTR ADDRESS;

	if SCANMATCH(PTR) THEN
		RETURN;
	CALL SETOB(.MSG(22));
	CALL OUTPRINT(PTR);
	CALL OUTWRITE(.('"', 0), 2);
	CALL ERRORMESSAGE(.MSG);	
END;

END;
?scan7.asm
	name	SCAN7
	extrn	SCANP, ZZSCEN
	public	SETSC
	stkln	14

	cseg
SETSC:	pop	d		; return address
	lhld	SCANP		; original SCANP
	push	h
	lxi	h,RSETSC	; push address of restore routine
	push	h
	mov	h,b		; SCANP = bc
	mov	l,c
	shld	SCANP
	push	d		; restore return address
	ret

RSETSC:	xchg
	pop	h
	shld	SCANP		; restore original SCANP
	mov	b,a
	sub	a
	sub	m
	cmc
	sbb	a
	sta	ZZSCEN
	mov	a,b
	xchg
	ret

	end

?scan9.plm
SCAN9: DO;

DECLARE	SCANP ADDRESS EXTERNAL,
	SCANENDED BYTE EXTERNAL;

SETSC: PROCEDURE(SCANP) EXTERNAL; DECLARE SCANP ADDRESS; END;
FORCUP: PROCEDURE BYTE EXTERNAL; END;
BUMPSCANP: PROCEDURE EXTERNAL; END;

FORCUPSTRING: PROCEDURE PUBLIC;
	DECLARE SCANCH BASED SCANP BYTE;

	call SETSC(SCANP);
	do while not SCANENDED;
		SCANCH = FORCUP;
		call BUMPSCANP;
	end;
end;

end;	

?scanp.asm
	name SCANP
	public SCANP
	dseg
SCANP:	dw	0
	end;

?sfound.asm
	name SFOUND
	public SFOUND, TARLEN, JOKER, GIVEUP
	extrn SCANP, TARGET

	DSEG
TARLEN:	db	0
JOKER:	db	'?'
GIVEUP:	dw	0

	CSEG
SFOUND: lhld	GIVEUP
	xchg
	lhld	TARLEN
	mov	b,h		; b = joker
	mov	c,l		; c = tarlen
	lhld	SCANP
	mov	a,e
	sub	l
	mov	e,a
	mov	a,d
	sbb	h
	mov	d,a
	ora	e
	rz			; nothing to check
	inr	d		; adjust for simple loop checks
	inr	e
trial:
	lda	TARGET
	call	first		; returns if first char found
	push	b		; save joker and tarlen
	push	d		; save counters
	push	h		; save where we are matching
	lxi	d,TARGET
match:
	dcr	c		; matched one more
	inx	d
	jz	found		; all done?
	ldax	d
	cmp	m
	inx	h
	jz	match		; still matching
	cmp	b
	jz	match		; or is wild card
	pop	h		; no match so restore and retry
	pop	d
	pop	b
	jmp	trial
found:
	mvi	a,0FFH		; found
	shld	SCANP		; save location after this string
	pop	b		; junk the stack saves
	pop	b
	pop	b
	ret
match1:
	cmp	m		; start match found
	inx	h
	rz			; return just the one level
first:
	dcr	e
	jnz	match1
	dcr	d
	jnz	match1
	pop	psw		; junk first return address
	sub	a		; return 0 to original caller
	ret

	END	
?ver11.asm
	name	VER11
	end;

