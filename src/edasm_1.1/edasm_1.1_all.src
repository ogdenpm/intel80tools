as80.pex
/* aliases for interface to assembler */
@PackToken  'PckTok'
@tokenSize  'tokSiz'
@tokenStart 'tokSt'
/* useful literals */
lit             'literally',

BELL            '7'
BS              '8'
TAB             '9'
LF              '0AH'
VT              '0BH'
FF              '0CH'
CR              '0DH'
ESC             '1BH'
CTRLC           '3'
CTRLQ           '11h'
CTRLR           '12h'
CTRLS           '13h'
CTRLX           '18h'
CTRLZ           '1Ah'
RUBOUT          '7FH'

TRUE            '0FFH'
FALSE           '0'
bool            'byte'
word            'address'
pointer         'address'
aPointer        'address'

MAXSYMSIZE      '6'

/* runtime error codes */
STACK$ERROR     '0'
TABLE$ERROR     '1'
EOF$ERROR       '2'


/* character classes */
CC$BAD          '0'
CC$WS           '1'
CC$SEMI         '2'
CC$COLON        '3'
CC$CR           '4'
CC$PUN          '5'
CC$DOLLAR       '6'
CC$QUOTE        '7'
CC$ESC          '13'
CC$DIG          '14'
CC$LET          '15'

TT$ID           '1'
TT$NUM          '2'
TT$PUNC         '3'
TT$STR          '4'
K$REGNAME       '7'

T$BEGIN         '0'
T$CR            '1'
T$LPAREN        '2'
T$RPAREN        '3'
T$STAR          '4'
T$PLUS          '5'
T$COMMA         '6'
T$MINUS         '7'
T$UPLUS         '8'
T$SLASH         '9'
T$UMINUS        '0Ah'
K$EQ            '0Bh'
K$LT            '0Ch'
K$LE            '0Dh'
K$GT            '0Eh'
K$GE            '0Fh'
K$NE            '10h'
K$NOT           '11h'
K$AND           '12h'
K$OR            '13h'
K$XOR           '14h'
K$MOD           '15h'
K$SHL           '16h'
K$SHR           '17h'
K$HIGH          '18h'
K$LOW           '19h'
K$DB            '1Ah'
K$DW            '1Bh'
K$DS            '1Ch'
K$EQU           '1Dh'
K$SET           '1Eh'
K$ORG           '1Fh'
K$END           '20h'
K$IF            '21h'
K$ELSE          '22h'
K$ENDIF         '23h'
K$LXI           '30h'
K$REG16         '31h'
K$LDSTAX        '32h'
K$ARITH         '33h'
K$IMM8          '34h'
K$MVI           '35h'
K$INRDCR        '36h'
K$MOV           '37h'
K$IMM16         '38h'
K$SINGLE        '39h'
K$RST           '3Ah'
K$EOT           '3Bh'


O$ID            '1'
O$TARGET        '2'
O$LABEL         '3'
O$SET           '4'
O$EQU           '5'
O$REF           '6'
O$NAME          '9'
O$STRING        '0Ah'
O$DATA          '0Bh'
O$NUMBER        '0Ch'

/* xref types */
XREF$DEF    '0'
XREF$REF    '1'
XREF$FIN    '2'


/* symbol table ids */
TID$KEYWORD    '0'
TID$SYMBOL    '1'

/* typedefs */
TOKENSYM$T      'structure(tok(2) word, value word, type byte, flags byte)'


/* global data */
acc1Flags       B
acc2Flags       B
acc1NumVal      "word"
acc2NumVal      "word"
acc1ValType     B
acc2ValType     B
accum           BS(4)
accum1          "word"
accum1$hb       B
accum1$lb       B
accum2          "word"
accum2$hb       B
accum2$lb       B
asmErrCode      B
atStartLine B
b1DF        B
b261        B
b275        B
b278        B
b279        B
b2B3        B
b30B        B
b3AD        B
b3B3        B
b3BA        B
b3BD        B
b3EC        B
chClass     BS(64)
checksum    B
condAsmSeen "bool"
controlId   B
controls    BS(13)
controlSeen BS(9)
controlSeenInitial BS(9)
createdUsrSym "bool"
crlf        BS
ctlCOND     B
ctlDEBUG    B
ctlEJECT    B
ctlLIST     B
ctlLISTChanged  B
ctlMOD85    B
ctlPAGELENGTH   B
ctlPAGEWIDTH    B
ctlPAGING   B
ctlSYMBOLS  B
ctlTAPEOBJECT   B
ctlTAPESOURCE   B
ctlTITLE    B
ctlXREF     B
curChar     B
curCol      B
curLoc      "word"
curOpFlags  B
curSym$p    "pointer"
curTok$p    "pointer"
curTokSize  B
curTokType  B
endItem     A
endLineBuf  "pointer"
endSymTab   AS(3)
errorOnLine "bool"
expectingOperands   B
expectingOpcode B
expectOp    "bool"
finished    "bool"
gettingCmdLine "bool"
gotLabel    B
hexBase     "word"
hexBuf      BS(17)
hexCnt      B
ifDepth     B
ii          B
inDB        "bool"
inDW        "bool"
inElse      BS(9)
inNestedParen   "bool"
isControlLine   "bool"
isInstr     "bool"
keywords    "TOKENSYM$T"S
kk          B
lastErrorLoc    A
lhsUserSymbol   B
lineBuf     BS(128)
lookAhead   B
lstBuf      BS(133)
lstBuf$p    "pointer"
maxCol      B
name        BS(6)
newOp       B
nextTokType B
objBuf      BS
opFlags     BS
opSP        B
opStack     BS(17)
pageNo      "word"
pass        B
passCnt     B
pc          "word"
primaryValid "bool"
reget       B
rhsUserSymbol B
rowCnt      "word"
runtimeError    "bool"
savName     BS(6)
segSize     "word"
showAddr    "bool"
skipIf      BS(9)
signOn      BS
spaces6     BS(7)
spIdx       B
startItem   A
startObjBuf A
symHighMark A
symtab      AS(3)
titleStr    BS(64)
titleLen    B
tokBuf      BS(64)
tokBufLen   B
tokenIdx    B
tokenAttr   BS(9)
tokenSize   BS(9)
tokenStart  "pointer"S(9)
tokenSym    "pointer"S(9)
tokenType   BS(9)
tokI        B
tokNumVal   "word"
topOp       B
tokStr      BS(7)
tokType     B
userLookupIsId "bool"
w3CA        "pointer"
W3ED        "word"
w3EF        "pointer"
w13FE       A
xrefBuf     BS(128)
yyType      B
/* procedures */

CI      PB
CO      P(B char)
RI      PB
PO      P(B char)
LO      P(B char)
MEMCK   PA
ChkInvalidRegOperand P
ChkLF       P
CollectByte P(B n)
DoEject     P
DoPass      P
EmitXref    P(B xrefMode, "pointer" name);
EndKeywords PA
FinishLine  P
GetCh       PB
GetChClass  PB
GetCmdCh    PB
GetId       P(B type)
GetNibbleAt P("pointer" ntable,B nindex)B
GetNum      P
GetNumVal   P"word"
GetPrecedence P(B op)B
GetSrcCh    PB
GetStr      P
Hex1        P(B n)B
IsReg       P(B n)"bool"
IsSkipping  P"bool"
Lookup      P(B tid)B
MkCode      P(B n)
Nest        P(B sw)
NewPageHeader   P
NextTokI    PB
Num2Ascii   P("word" value,"pointer" buf)
ObjByteToMem P(B ch)
PackToken   P
ParseControls   P
ParseControlLines   P
PopToken    P
PrintLine   P
PrintSymbols    P
PushToken   P(B tok)
PutCh$HEX   P(B ch)
PutCh$LO    P(B ch)
PutCh$LST   P(B ch)
PutCh$PO    P(B ch)
PutNonLF$LST    P(B ch)
PutObjectData   P(B n)
PutStr$CO  P("pointer" str)
PutStr$HEX  P("pointer" str)
PutStr$LST  P("pointer" str)
RecordError P(B ch)
ReportError P(B err)
SetExpectOperands P
SetCurSymType   P(B type)
ShowLine    P"bool"
Skip2EOL    P
SkipWhite   P
SubC3F5     P(B n)
SubC91A     P
TestBit     P(B maxbit,B bitIdx,"pointer" bitVector)"bool"
Tokenise    P
UnNest      P(B sw)
UnPackToken P("apointer" src,"pointer" dst)
UpdateSymbolEntry   P("word" val, B type)
WriteHex2$HEX P(B ch)
WriteHex2$LST P(B ch)

as80.plm
as80: do;
$include(as80.ipx)

    declare jmp byte data(0c3h), target address data(.main - 3);
    declare spaces6(*) byte public data('      ', 0);
    declare prompt(*) byte data(CR, LF, 'P=', 0);
    declare aNoErrors(*) byte data('NO ERRORS', CR, LF, 0);
    declare aPassError(*) byte data(CR, LF, 'PASS ERROR', 0);
    declare aPass1Complete(*) byte data(CR, LF, 'PASS 1 COMPLETE', CR, LF, 0);
    declare aPass(*) byte data(CR, LF, 'PASS ', 0);
    declare aAssembly(*) byte data(CR, LF, 'ASSEMBLY');
    declare aComplete(*) byte data(' COMPLETE, ', 0);
    declare crlf(*) byte public data(CR, LF, 0);
    declare signOn(*) byte public DATA(CR, LF, 'SERIES II 8080/8085 ROM ASSEMBLER, V1.1',
                                TAB, TAB, 'PAGE ', 0);
    declare copyRight(*) byte DATA('(C) 1976,1977 INTEL CORP');
    declare aCommandError(*) byte data(CR, LF, 'COMMAND ERROR', 0);
    declare vec0 address data(0);
    declare aStack(*) byte data(CR, LF, 'STACK');
    declare aTable(*) byte data(CR, LF, 'TABLE');
    declare aEof(*) byte data(CR, LF, 'EOF');
    declare aError(*) byte data(' ERROR', CR, LF);
    declare strPtrs(3) address data(.aStack, .aTable, .aEof);
    declare strLengths(3) byte data(7, 7, 5);
    declare OFF byte data(0), ON byte data(0ffh);
    declare controlSeenInitial(9) byte public data(0,0,0,0,0,0,0,0,0);
    declare hash$crlf(*) byte data('#', CR, LF, 0);
    declare space$crlf(*) byte data(' $', CR, LF, 0);
    declare rp$crlf(*) byte data(')', CR, LF);

    /* data located at 40h */
    declare b40 byte public, w41 address;
    declare tokenIdx byte public,
            lineBuf(128) byte public,
            tokenStart(9) address public, curTok$p address public at(.tokenStart), 
            tokenSym(9) address public, curSym$p address public at(.tokenSym),
            tokenType(9) byte public, curTokType byte public at(.tokenType),
            tokenSize(9) byte public, curTokSize byte public at(.tokenSize),
            tokenAttr(9) byte public, curTokAttr byte public at(.tokenAttr),
            endLineBuf address public;
    declare ifDepth byte public,
            skipIf(9) byte public,
            inElse(9) byte public,
            opSP byte public,
            opStack(17) byte public,
            (accum1, accum2) word public,
            (accum1$lb, accum1$hb, accum2$lb, accum2$hb) byte public at(.accum1),
            accum(4) byte public at(.accum1),
            (acc1Flags, acc2Flags, acc1ValType, acc2ValType) byte public,
            (acc1NumVal, acc2NumVal) address public;
    declare curChar byte public,
            (reget, lookAhead) byte public, (pad139, pad13A) byte,
            (symtab, endSymTab)(3) address public,
            (symHighMark, startObjBuf) address public,
            gotLabel byte public,
            (name, savName)(6) byte public,
            (lhsUserSymbol, rhsUserSymbol) byte public;
    declare passCnt byte public,
            lstBuf$p address public,
            xrefBuf(128) byte public,
            createdUsrSym byte public,
            userLookupIsId byte public,
            b1DF byte public,
            cmdInBuf(128)  byte,
            b260 byte, b261 byte public, asmErrCode byte public,
            (primaryValid, tokI, errorOnLine) byte public,
            atStartLine byte public,
            pad267 address,
            (maxCol, curCol) byte public;
    declare (endItem, startItem, rowCnt, pc, pageNo) address public,
            b275 byte public, showAddr byte public, pad277 byte,
            b278 byte public, b279 byte public,
            tokStr(7) byte public, lstBuf(133) byte public,
            curLoc address public,
            spIdx byte public, lastErrorLoc address public,
            b30B byte public,
            (ctlDEBUG, ctlXREF, ctlSYMBOLS, ctlPAGING) byte public,
            (ctlTAPESOURCE, ctlTAPEOBJECT, ctlMOD85, ctlPAGEWIDTH) byte public,
            (ctlPAGELENGTH, ctlTITLE) byte public,
            (ctlEJECT, ctlLIST,  ctlCOND) byte public,
            controls(13) byte public at (.ctlDEBUG),
            ctlLISTChanged byte public;
    declare titleLen byte public;
    declare controlSeen(9) byte public;
    declare titleStr(64) byte public;
    declare tokBufLen byte public;
    declare tokType byte public;
    declare controlId byte public;
    declare tokBuf(64) byte public;
    declare tokNumVal address public;
    declare isControlLine byte public;
    declare gettingCmdLine byte public;
    declare inDB byte public;
    declare inDW byte public;
    declare b3AD byte public;
    declare pass byte public;
    declare curOpFlags byte public;
    declare yyType byte public;
    declare newOp byte public;
    declare (topOp, b3B3) byte public;
    declare nextTokType byte public;
    declare finished byte public;
    declare inNestedParen byte public;
    declare (expectingOperands, expectingOpcode) byte public;
    declare condAsmSeen byte public;
    declare b3BA byte public;
    declare isInstr byte public;
    declare expectOp byte public;
    declare b3BD byte public;
    declare segSize address public;
    declare (pad3C0, errCnt, pad3C4) address;
    declare hexCnt byte public;
    declare checksum byte public;
    declare (hexBase, w3CA) address public;
    declare hexBuf(17) byte public;
    declare cmdInBuf$p address;
    declare runtimeError bool public;
    declare ii byte public;
    declare jj byte, kk byte public, pad3E3 byte;
    declare asciiErrorCnt(8) byte;
    declare b3EC byte public;
    declare (w3ED, w3EF) address public;
    declare endInBuf$p address;
    declare cmdCh byte;

    declare w13FE address public at(13feh);
    declare objBuf(1) byte public at(1400h);
    declare (startEditBuf, lenEditBuf) address at(2000h);

    /* the rom assembler has some isis system functions included but not used */
    /* these next three lines force the build to include them */
    EXIT: procedure external; end;
    LOAD: procedure (path$p, load$offset, switch, entry$p, status$p) external;
        declare (path$p, load$offset, switch, entry$p, status$p) address;
    end;
    WRITE: procedure (conn, buff$p, count, status$p) external;
        declare (conn, buff$p, count, status$p) address;
    end;



    GetCmdCh: procedure byte public;
        declare ch based cmdInBuf$p byte;
        cmdCh = ch;
        cmdInBuf$p = cmdInBuf$p + 1;
        return cmdCh;
    end;

    PutCh$CO: procedure(ch);
        declare ch byte;
        call CO(ch);
    end;

    PutCh$PO: procedure(ch) public;
        declare ch byte;
        call PO(ch);
    end;

    PutCh$LO: procedure(ch) public;
        declare ch byte;
        call LO(ch);
    end;

    Write$DEV: procedure(str, len, dev);
        declare str address, (len, dev) byte,
                i byte,
                ch based str byte;

        do i = 0 to len - 1;
            do case dev;
                call PutCh$CO(ch);      /* 0 */
                call PutCh$LO(ch);      /* 1 */
                call PutCh$HEX(ch);     /* 2 */
            end;
            str = str + 1;
        end;
    end;

    PunchNulls: procedure;
        do ii = 0 to 119;
            call PO(0);
        end;
    end;

    Skip2EOL: procedure public;
        if curChar <> CR then
            do while GetCh <> CR;
            end;
    end;


    ReportError: procedure(err) public;
        declare err byte;

        if runtimeError then
            return;

        if pass = 1 and err = STACK$ERROR then  do;
            b3BA = TRUE;
            return;
        end;
        call Write$DEV(strPtrs(err), strLengths(err), 0);
        call Write$Dev(.aError, 8, 0);
        if pass = 2 then do;
            call Write$DEV(strPtrs(err), strLengths(err), 1);
            call Write$DEV(.aError, 8, 1);
        end;
        if err = STACK$ERROR then do;
            runtimeError = TRUE;
            return;
        end;
        call vec0;
    end;
   
    declare inCh$p address, inCh based inCh$p byte;

    GetChFromBuf: procedure byte;

        if inCh$p >= endInBuf$p then
            call ReportError(EOF$ERROR);
        inCh$p = inCh$p + 1;
        return inCh;
    end;

    ObjByteToMem: procedure(err) public;
        declare err byte;
        declare ch based w3EF byte;

        if w3EF >= 2000h or w3EF < 1400h then
            call ReportError(TABLE$ERROR);

        ch = err;
        w3EF = w3EF + 1;
    end;        

    GetSrcCh: procedure byte public;
        if ctlTAPESOURCE then
            return RI;
        return GetChFromBuf;
    end;

    Hex1: procedure(ch) byte public;
        declare ch byte;
        if (ch := (ch and 0Fh) + '0') > '9' then
            ch = ch + 7;
        return ch;
    end;

    WriteHex2$HEX: procedure(n) public;
        declare n byte;
        call PutCh$HEX(Hex1(ror(n, 4)));
        call PutCh$HEX(Hex1(n));
    end;

    WriteHex2$LST: procedure(n) public;
        declare n byte;
        call PutCh$LST(Hex1(ror(n, 4)));
        call PutCh$LST(Hex1(n));
    end;


    MPorNoErrCode: procedure byte;
        return asmErrCode = ' ' or asmErrCode = 'M' or asmErrCode = 'P';
    end;


    GetNibbleAt: procedure(ntable, nindex) byte public;
        declare ntable address, nindex byte;
        declare n based ntable byte;
        declare tmp byte;

        ntable = ntable +  shr(nindex, 1);
        tmp = n;
        if not nindex then
            tmp = ror(tmp, 4);
        return tmp and 0fh;
    end;


    RecordError: procedure(err) public;
        declare err byte;
        if not skipIf(0) then do;
            if asmErrCode = ' ' then
                errCnt = errCnt + 1;
            if MPorNoErrCode or err = 'L' or err = 'U' then
                if asmErrCode <> 'L' then
                    asmErrCode = err;
        end;
    end;


    ParseControlLines: procedure public;
        do while GetCh = '$';
            call ParseControls;
            call FinishLine;
            isControlLine = FALSE;
        end;
        reget = 1;
    end;

    PutStr$CO: procedure(str) public;
        declare str address, ch based str byte;

        do while ch <> 0;
            call CO(ch);
            str = str + 1;
        end;
    end;


    GetCmdLine: procedure;
        declare ch based cmdInBuf$p byte;

        cmdInBuf$p = .cmdInBuf;
        ch = 0;
        do while (ch := CI and 07fh) <> CR;
            if ch = 7Fh then do;
                if cmdInBuf$p > .cmdInBuf then do;
                    cmdInBuf$p = cmdInBuf$p - 1;
                    call PutCh$CO(ch);
                end;
                else
                    call PutCh$CO(BELL);
            end;
            else if ch = CTRLX then do;
                call PutStr$CO(.hash$crlf);
                cmdInBuf$p = .cmdInBuf;
            end;
            else if ch = CTRLR then do;
                call PutStr$CO(.crlf);
                ch = 0;
                call PutStr$CO(.cmdInBuf);
            end;
            else if cmdInBuf$p < .b260 then do;
                call CO(ch);
                cmdInBuf$p = cmdInBuf$p + 1;
            end;
            ch = 0;
        end;
        cmdInBuf$p = .cmdInBuf;
        call PutStr$CO(.crlf);
    end;


    ResetData: procedure;
        b3AD, b3BA, b279, lhsUserSymbol, expectingOperands, skipIf(0), b3B3, gotLabel,
        rhsUserSymbol, inElse(0), inDB, inDW, condAsmSeen, finished, ctlTITLE = OFF;

        b261, atStartLine, expectingOpcode, primaryValid, ctlLIST,
        ctlLISTChanged, ctlCOND = ON;
        lookAhead, rowCnt, ctlEJECT, segSize, tokenIdx, ifDepth,
        opSp, opStack(0), pc, curTokSize, curTokType = OFF;
        hexCnt, hexBase, w13FE, checksum, errCnt = OFF;
        passCnt = passCnt + 1;
        curLoc, newOp = 1;
        curChar = ' ';
        asmErrCode = ' ';
        inCh$p = startEditBuf - 1;
    end;

    InitialiseData: procedure;
        declare curTokType2 word at(.curTokType);
        w41, curTokType2, curTokAttr, reget, passCnt, titleLen = OFF;

        createdUsrSym, userLookupIsID, b1DF, b278, b30B, ctlDEBUG,
        ctlXREF, ctlTAPESOURCE, ctlTAPEOBJECT, ctlMOD85, isControlLine,
        runtimeError, b3BD = OFF;

        b260, b261, ctlSYMBOLS, ctlPAGING, b3EC, isInstr, expectOp = ON;
        endLineBuf = .curTok$p;
        ctlPAGEWIDTH = 120;
x:  /* force hl load */
        ctlPAGELENGTH = 66;
        call move(9, .controlSeenInitial, .controlSeen);
        call move(7, .controlSeenInitial, .tokStr);
    end;


    ChkGenHex: procedure byte;
        return pass > 2 and ctlTAPEOBJECT;
    end;

    declare b40A(4) byte;

main:
    endInBuf$p = startEditBuf + lenEditBuf - 1;
    startObjBuf = 1400h;
    call WriteDev(.signOn, 41, 0);
    call PutStr$CO(.crlf);
    b40 = TRUE;
CMDLOOP:
    do while 1;
        call PutStr$CO(.prompt);
        call GetCmdLine;
        pass = GetCmdCh;
        if (pass and 0dfh) = 'E' then do;
            call PutStr$CO(.crlf);
            call vec0;
        end;
        if (pass := pass - '0') = 1 then do;
            call InitialiseData;
            curTok$p = .lineBuf;
            endLineBuf = .curTok$p;
            symtab(TID$KEYWORD) = .keywords;
            endSymTab(TID$KEYWORD) = EndKeywords;
            symtab(TID$SYMBOL), endSymTab(TID$SYMBOL), symHighMark = .MEMORY;
        end;
        call ResetData;
        if pass = 0 or pass > 4 then
            call PutStr$CO(.aPassError);
        else if pass <> 1 and b40 then do;
            call PutStr$CO(.aPassError);
            goto CMDLOOP;
        end;
        else do;
            gettingCmdLine = TRUE;
            call ParseControls;
            gettingCmdLine = FALSE;
            if asmErrCode <> ' ' then do;
                call PutStr$CO(.aCommandError);
                goto CMDLOOP;
            end;
            if pass = 1 then do;
                call ParseControlLines;
                b40 = FALSE;
                if ctlTAPESOURCE then do;
                   if ctlTAPEOBJECT then
                        startObjBuf = MEMCK - 1;
                end;
                else do; 
                    if startEditBuf < .startEditBuf then
                        call ReportError(TABLE$ERROR);
                    if endInBuf$p >= MEMCK then
                        call ReportError(EOF$ERROR);
                    if ctlTAPEOBJECT then
                        startObjBuf = .startEditBuf;
                end;
                if ctlXREF then do;
                    call PunchNulls;
                    lstBuf$p = .xrefBuf;
                end;
            end;
            if not pass then do;
                lastErrorLoc, curCol, maxCol = 0;
                pageNo = 1;
                call PutCh$LO(FF);
                call NewPageHeader;
                curCol = 24;
                b261 = 0;
            end; 
            call DoEject;
            call ParseControlLines;
            isControlLine = FALSE;
            primaryValid = FALSE;
            if ChkGenHex then do;
                call PunchNulls;
                if ctlDEBUG then do;
                    call PrintSymbols;
                    call PutStr$Hex(.space$crlf);
                end;
            end;

            call DoPass;
            if pass = 1 then do;
                call PutStr$CO(.aPass1Complete);
                if ctlXREF then
                    call PunchNulls;
            end;
            else do;
                if pass <> 3 then
                    call WriteDev(.aAssembly, 21, 1);
                call PutStr$CO(.aPass);
                call PutCh$CO(pass + '0');
                call PutStr$CO(.aComplete);
                if errCnt = 0 then do;
                    if pass <> 3 then
                        call Write$DEV(.aNoErrors, 11, 1);
                    call PutStr$CO(.aNoErrors);
                end;
                else do;
                    kk = ((errCnt > 1) and 1) + 6;
                    call Num2Ascii(errCnt, .asciiErrorCnt);
                    if pass <> 3 then do;
                        call WriteDEV(.crlf, 2, 1);
                        call Write$DEV(.asciiErrorCnt, 4, 1);
                        call Write$DEV(.aNoErrors + 2, kk, 1);
                        call PutCh$LO('(');
                        call Num2Ascii(lastErrorLoc, .b40A);
                        call Write$DEV(.b40A, 4, 1);
                        call Write$DEV(.rp$crlf, 3, 1);
                    end;
                    call PutStr$CO(.crlf);
                    call Write$DEV(.asciiErrorCnt, 4, 0);
                    call Write$DEV(.aNoErrors + 2, kk, 0);
                end;
                if ChkGenHex then
                    call PunchNulls;
            end;
        end;    /* if / else */
    end;    /* while 1 */
end;
eof;



pcktok.asm
    public PckTok
    extrn toksiz
    extrn tokst;

; pckTok - packs the token pointed by tokst, with length toksiz into 4 bytes
; packed version replaces original and toksize set to 4 bytes

    CSEG
PckTok:
    lhld    tokst       ; pointer to the token to pack
    xchg
    lxi     h, toksiz
    mov     c, m        ; unpacked length
    mvi     m, 4        ; new packed length is 4 bytes
    call    pack3       ; pack 3 chars into hl
    push    h
    call    pack3
    pop     b
    xchg                ; put the packed data into the first 4 bytes
    dcx     h
    dcx     h
    dcx     h
    mov     m, d
    dcx     h
    mov     m, e
    dcx     h
    mov     m, b
    dcx     h
    mov     m, c
    ret

pack3:
    lxi     h, 0        ; get 3 chars packed into 2 bytes
    mvi     b, 3

@1:
    push    d           ; pointer to next char
    mov     d, h        ; hl x 40
    mov     e, l
    dad     h
    dad     h
    dad     d
    dad     h
    dad     h
    dad     h
    pop     d    
    call    pack1       ; add in next char
    add     l
    mov     l, a
    mvi     a, 0
    adc     h
    mov     h, a
    dcr     b           ; get the 3 chars
    jnz     @1
    ret

pack1:
    ldax    d           ; pick up next character
    inx     d           ; advance for next time
    dcr     c           ; check it is valid
    jm      @2
    sui     2Fh         ; /012345678  (0-9)
                        ; 9?@ABCDEFG  (10-19)
                        ; HIJKLMNOPQ  (20-29)
                        ; RSTUVWXYZ[  (30-39)
    cpi     10h         ; digit so return
    rc
    sui     5           ; exclude : ; < = >
    ret

@2:
    sub     a           ; 0 no char
    ret

    end

as81.plm
token: do;
$include(as81.ipx)

    declare bC0C3(*) byte data(7Fh, 0E0h,    0,    0,    0,  80h, 0FFh, 0E0h);
    declare bC0CB(*) byte data(  0,    0,    0,    9,  40h, 0E8h);
    declare bC0D1(*) byte data(90h,    0,    0,    0,    0,    1);


    IsWhiteSpc: procedure byte;
        return curChar = ' ' or curChar = TAB;
    end;

    SkipWhite: procedure public;
        do while IsWhiteSpc;
            curChar = GetCh;
        end;
    end;

    Tokenise: procedure public;

        GotValue: procedure;
            if newOp = 0 then
                call RecordError('E');
            newOp = 0;
        end;


        do while 1;
            if atStartLine then do;
                call ParseControlLines;
                atStartLine = FALSE;
            end;

            do case GetChClass;
    badCase:    call RecordError('I');  /* 0 CC$BAD */
                ;                       /* 1 CC$WS */
                do;                     /* 2 CC$SEMI */
                    call Skip2EOL;
                    call ChkLF;
                    yyType = T$CR;
                    return;
                end;
                do;                     /* 3 CC$COLON */
                    if not gotLabel then do;
                        if skipIf(0) then
                            call PopToken;
                        else
                            call UpdateSymbolEntry(segSize, O$TARGET);
                        expectingOperands = 0;
                        gotLabel = TRUE;
                        expectingOpcode = TRUE;
                    end;
                    else do;
                        call RecordError('Q');
                        call PopToken;
                    end;
                    call EmitXref(XREF$DEF, .name);
                    rhsUserSymbol = FALSE;
                    newOp = O$LABEL;
                end;
                do;                     /* 4 CC$CR */
                    call ChkLF;
                    yyType = T$CR;
                    return;
                end;
                do;                     /* 5 CC$PUN */
                    if (curChar = '+' or curchar = '-') and
                       not TestBit(47, newOp, .bC0D1) then
                        curChar = curChar + (T$UPLUS  - T$PLUS);  /* make unary versions */
                    yyType = curChar - '(' + T$LPAREN;
                    return;
                end;
                do;                     /* 6 CC$DOLLAR */
                    call PushToken(O$NUMBER);
                    call CollectByte(low(segSize));
                    call CollectByte(high(segSize));
                    call GotValue;
                end;
                do;                     /* 7 CC$QUOTE */
                    call GetStr;
                    if expectingOpcode then
                        call SetExpectOperands;
                    call GotValue;
                end;
                ;                       /* 8 */
                ;                       /* 9 */
                ;                       /* 10 */
                ;                       /* 11 */
                ;                       /* 12 */
                do; goto badCase; end;  /* 13 CC$ESC */
                do;                     /* 14 CC$DIG */
                    call GetNum;
                    if expectingOpcode then
                        call SetExpectOperands;
                    call GotValue;
                end;
                do;                     /* 15 CC$LET */
                    call GetId(9);
                    if curTokSize > MAXSYMSIZE then
                        curTokSize = MAXSYMSIZE;
                    call move(6, .name, .savName);
                    call move(6, .spaces6, .name);
                    call move(curTokSize, curTok$p, .name);
                    call PackToken;
                    if rhsUserSymbol then do;
                        lhsUserSymbol = TRUE;
                        rhsUserSymbol = FALSE;
                    end;
                    if Lookup(0) = O$NAME then do;
                        curTokType = Lookup(1);
                        rhsUserSymbol = TRUE;
                    end;
                    yyType = curTokType;
                    if TestBit(47, curTokType, .bC0CB) then
                        b1DF = TRUE;
                    if not TestBit(59, curTokType, .bC0C3) then
                        call PopToken;

                    if lhsUserSymbol then
                        call EmitXref((((yyType + 1) or 1) <> 1Fh) and 1, .savName);
                    lhsUserSymbol = 0;
                    
                    if yyType < 10 or yyType = 9 or 80h then do;
                        call GotValue;
                        if expectingOpcode then
                            call SetExpectOperands;
                    end;
                    else do;
                        expectingOpcode = FALSE;
                        return;
                    end;
                end;
            end;    /* do case */
        end;        /* do while 1 */
    end;
end;
eof

as82.plm
list:do;
$include(as82.ipx)

    declare opFlags(*) byte public data(
                   0,  80h,    0,    0,  0Fh,  0Fh,  80h,  0Fh,
                 0Dh,  0Fh,  0Dh,  0Fh,  0Fh,  0Fh,  0Fh,  0Fh,
                 0Fh,  0Dh,  0Fh,  0Fh,  0Fh,  0Fh,  0Fh,  0Fh,
                 0Dh,  0Dh,  40h,  4Dh,    1,    1,    1,    1,
                 80h,    1,    0,    0,    0,  40h,  80h,    0,
                 40h,  80h,  80h,  40h,  81h, 0C0h,  80h,  0Dh,
                 47h,    7,    7,    7,  17h,  47h,    7,  47h,
                 37h,    5,    7,    0,    0,    0,  40h,  40h,
                   0,    1);
    declare noRegOperand(*) byte data(0,    0,    0,  19h,  40h,    0,    0,    1, 0C0h);
    declare typeHasVlaue(*) byte data(0FFh,  80h,    0,    0,    0,  80h, 0FFh, 0E0h);
    declare precedence(*) byte data(
                   0,    0,  87h,  17h,  78h,  76h,  66h,  66h,
                 65h,  43h,  38h,  88h,  88h,  11h,  11h,  11h,
                 11h,  11h,    1,  11h,    0,    1,  11h,    9,
                 11h,  11h,  11h,  11h,  11h,  11h,  11h,  11h,
                 11h);
    declare spaces15(15) byte data('               ');


    ClrXrefLeader: procedure;
        do ii = 1 to 24;
            lstBuf(ii) = ' ';
        end;
    end;

    subC3F5: procedure(n) public;
        declare n byte;
        declare (i, j) byte;

        PutLstRange$LST: procedure;
            do ii = i to j;
                call PutCh$LST(lstBuf(ii));
            end;
        end;

        b275 = TRUE;
        call PutCh$LST(LF);
        i = ctlPAGEWIDTH + 1;
        if (j := ctlPAGEWIDTH + ctlPAGEWIDTH - 24) < n then do;
            call PutLstRange$LST;
            i = j + 1;
            call ClrXrefLeader;
            call Putch$LST(LF);
            curCol = 24;
        end;
        j = n;
        call PutLstRange$LST;
        call ClrXrefLeader;
    end;


    DoEject: procedure public;
        if not pass and ctlLIST and ctlEJECT > 0 then
            call PutCh$LST(FF);
        else
            ctlEJECT = 0;
    end;


    TestBit: procedure(maxbit, bitIdx, bitVector) BOOL public;
        declare (maxbit, bitIdx) byte, bitVector address;
        declare bits based bitVector byte;

        if bitIdx > maxbit then
            return FALSE;
        bitVector = bitVector + shr(bitIdx, 3);
        return (bits and ror(1, (bitIdx and 7) + 1)) <> 0;
    end;

    IsReg: procedure(n) BOOL public;
        declare n byte;
        return n = K$REGNAME or n = 8;
    end;

    ChkInvalidRegOperand: procedure public;
        if TestBit(65, topOp, .noRegOperand) then
            if IsReg(acc1ValType) then
                call RecordError('X');
    end; 

    SwapAccBytes: procedure;
        declare tmp byte;
        tmp = accum1$lb;
        accum1$lb = accum1$hb;
        accum1$hb = tmp;
    end;

    SetExpectOperands: procedure public;
        expectingOperands = TRUE;
        expectingOpcode = FALSE;
    end;

    GetNumVal: procedure word public;
        declare tokByte based curTok$p (1) byte;
        accum1 = 0;
        acc1ValType = O$NAME;
        if tokenIdx = 0 or curTokType = O$DATA and not b3BD then
            call RecordError('Q');
        else do;
            if curTokType = O$NAME then
                call RecordError('U');
            else do;
                acc1ValType = curTokType;
                if TestBit(60, acc1ValType, .typeHasVlaue) then do;
                    curTok$p = curSym$p + 4;    /* point to value */
                    curTokSize = 2;
                end;
                else if curTokSize = 0 then
                    call RecordError('V');
                else if curTokSize > 2 then
                    call RecordError('V');
                
                if curTokSize > 0 then    /* get low byte */
                    accum1$lb = tokByte(0);
                if curTokSize > 1 then    /* get high byte */
                    accum1$hb = tokByte(1);
            end;
            if curTokSize = 2 and b3AD and curTokType = O$STRING then
                call SwapAccBytes;
            call PopToken; 
        end;
        b3BD = FALSE;
        return accum1;
    end;


    GetPrecedence: procedure(op) byte public;
        declare op byte;
        return GetNibbleAt(.precedence, op);
    end;

    MkCode: procedure(n) public;
        declare n byte;

        if (n and 3) <> 0 then do;   /* lxi, ldax, stax, regarith, mvi, mov, rst */
            if accum2$hb <> 0    /* reg or rst num <= 7 */
               or accum2$lb > 7     
               or n and accum2$lb    /* only B D H SP if lxi, ldax or stax */
               or (n and 3) = 3 and accum2$lb > 2    /* B or D if ldax or stax */
               or (not IsReg(acc2ValType) and topOp <> K$RST) then    /* reg unless rst */
                call RecordError('X');
            else if IsReg(acc2ValType) and topOp = K$RST then         /* cannot be reg for rst */
                call RecordError('X');
            if ror(n, 2) then
                accum2$lb = rol(accum2$lb, 3);
            accum1$lb = accum1$lb or accum2$lb;
        end;
        else if IsReg(acc2ValType) and topOp <> K$SINGLE then        /* single byte topOp */
            call RecordError('X');

        if shr(n, 3) then
            if accum2$hb + 1 > 1 then    /* Error if not FF or 00 */
                call RecordError('V');

        if topOp = K$IMM8 or topOp = K$IMM16 then do;   /* Imm8 or imm16 */
            acc1Flags = acc2Flags;
            acc1NumVal = acc2NumVal;
        end;
        else
            acc1Flags = 0;

        if topOp <> K$SINGLE and accum1$lb = 76h then   /* check for mov m,m (hlt) */
            call RecordError('X');
        if (topOp := shr(n, 4) + 30h) = 30h then        /* ? K$LXI */
            nextTokType = O$DATA;
    end;

    NextTokI: procedure byte public;
        if tokI >= tokenIdx then
            return 0;
        else do;
            tokI = tokI + 1;
            return tokI;
        end;
    end;

    AddXrefCh: procedure(ch);
        declare ch byte;
        declare xrefCh based  lstBuf$p byte;
        xrefCh = ch;
        lstBuf$p = lstBuf$p + 1;
    end;

    ShowLine: procedure BOOL public;
        return ((not isControlLine and ctlLIST) 
               or (ctlLISTChanged and isControlLine))
               and (not (condAsmSeen or skipIf(0)) or ctlCOND);
    end;

    EmitXref: procedure(xrefMode, name) public;
        declare xrefMode byte, name address;
        declare tmp address, len byte, pad420 address;
        declare ch based lstBuf$p byte;

        if xrefMode <> '2' then
            if not (pass = 1 and ctlXREF and not IsSkipping) then
                return;
        if xrefMode = '2' then do;
            call AddXrefCh('2');
            call move(15, .spaces15, lstBuf$p);
            lstBuf$p = lstBuf$p + 15;
            if ctlPAGING then
                call AddXrefCh('1');
            else
                call AddXrefCh('0');

            call AddXrefCh(Hex1(ror(ctlPAGELENGTH, 4) and 0fh));
            call AddXrefCh(Hex1(ctlPAGELENGTH and 0fh));
            call AddXrefCh(Hex1(ror(ctlPAGEWIDTH, 4)));
            call AddXrefCh(Hex1(ctlPAGEWIDTH and 0fh));
            call AddXrefCh('3');
            xrefMode = 255;
        end;
        else if xrefMode <> 255 then do;
            call AddXrefCh(xrefMode + '0');
            call move(6, name, lstBuf$p);
            lstBuf$p = lstBuf$p + 6;
            do ii = 4 to 12 by 4;
                tmp = shr(curLoc, 16 - ii);
                call AddXrefCh(Hex1(tmp and 0fh));
            end;
            call AddXrefCh(hex1(curLoc and 0fh));
        end;
        if xrefMode = 255 or (len := lstBuf$p - .xrefBuf) >= 104 then do;
            lstBuf$p = .xrefBuf;
            do ii = 1 to len;
                call PutCh$PO(ch);
                lstBuf$p = lstBuf$p + 1;
            end;
            lstBuf$p = .xrefBuf;
        end;
    end;
end;
as83.plm
print: do;
$include(as83.ipx)

    declare vec0 address data(0);



    IsSkipping: procedure byte public;
        return skipIf(0);
    end;

    subC91A: procedure public;
        spIdx = NextTokI;
        if expectingOperands then do;
            call RecordError('Q');
            expectingOperands = FALSE;
        end;
        if tokenIdx > 0 then do;
            if tokenType(spIdx) <> O$DATA and b278 = 0 then
                call RecordError('Q');
        end;
        if inDB or inDW then do;
            if tokenIdx = 1 and asmErrCode <> ' ' and curTokSize <> 1 then
                curTokSize = 2;
        end;
        else if asmErrCode <> ' ' and tokenIdx <> 0 then
            if tokenSize(spIdx) > 3 then
                tokenSize(spIdx) = 3;
    end;


    FinishLine: procedure public;
        declare objByte based curTok$p byte;

        b278 = FALSE;
        tokI = 1;
        errorOnLine = 0;
        call subC91A;
        if not pass then do;
            if ShowLine or asmErrCode <> ' ' then
                call PrintLine;
            else
                maxCol = FALSE;
        end;
        if runtimeError then
            call vec0;
        if not isControlLine then do;
            ii = 2;
            if tokenIdx < 2 or inDB or inDW then
                ii = 0;
            w3CA = tokenStart(ii) + tokenSize(ii);
            if IsSkipping or not isInstr then
                w3CA = .lineBuf;
            if pass >  2 then do;
                curTok$p = .lineBuf;
                if hexBase + hexCnt <> segSize or b3BA then do;
                    if hexCnt > 0 then
                        call PutObjectData(0);
                    hexBase = segSize;
                end;
                do while curTok$p < w3CA;
                    if hexCnt = 16 then do;
                        call PutObjectData(0);
                        hexBase = hexBase + 16;
                    end;
                    checksum = checksum - (hexBuf(hexCnt := hexCnt + 1) := objByte);
                    curTok$p = curTok$p + 1;
                end;
                if b3BA then
                    call PutObjectData(1);
            end;
            b3B3 = TRUE;
            segSize, pc = segSize + (w3CA - .lineBuf);
        end;
        do while tokenIdx > 0;
            call PopToken;
        end;
        if rhsUserSymbol then
            call EmitXref(1, .name);
        curLoc = curLoc + 1;
        gotLabel = 0;
        showAddr = 0;
        rhsUserSymbol = 0;
        lhsUserSymbol = 0;
        b1DF = 0;
        userLookupIsID = 0;
        inDB = 0;
        inDW = 0;
        asmErrCode = ' ';
        acc1Flags = 0;
        tokenIdx = 0;
        curTokSize = 0;
        curTokType = 0;
        curCol = 24;
        b3AD = 0;
        condAsmSeen = 0;
        skipIf(0) = skipIf(0) > 0;
        expectOp = 0FFh;
        atStartLine = 0FFh;
        isInstr = 0FFh;
        expectingOpcode = 0FFh;
        ctlEJECT = 0;
        if b3BA then do;
            finished = 0FFh;
            if not pass and ctlSYMBOLS then
                call PrintSymbols;
            if pass = 1 and ctlXREF then
                call EmitXref('2', .name);
        end;
    end;

end;
as84.plm
action: do;
$include(as84.ipx)

    declare isInstrMap(*) byte data(70h,    0,    0,  30h,    0,    3, 0FFh, 0E0h);
    declare aNextTape(*) byte data('NEXT TAPE', CR, LF, 0);

    Cond2Acc: procedure(cond);
        declare cond byte;
        
        if (accum1 := cond) then
            accum1 = 0FFFFh;
    end;

    HandleOp: procedure;
        do case topOp;
            ;                   /* 0 */
            call FinishLine;    /* 1 CR */
            goto case3;         /* 2 ( */
    case3:  do;                 /* 3 ) */
                if not (topOp = T$LPAREN and newOp = T$RPAREN) then
                    call RecordError('B');
                if curTokType = O$DATA then do;
                    curTokSize = 1;
                    b3BD = TRUE;
                end;
                expectOp = inNestedParen;
                if newOp = T$RPAREN then
                    b3B3 = TRUE;
            end;
            accum1 = accum1 * accum2;   /* 4 * */
            accum1 = accum1 + accum2;   /* 5 + */
            do;                         /* 6 , */
                call RecordError('Q');
                call PopToken;
            end;
            accum1 = accum1 - accum2;   /* 7 - */
            ;                           /* 8 unary + */
            accum1 = accum1 / accum2;   /* 9 / */
            accum1 = -accum1;           /* 10 unary - */
            call Cond2Acc(accum1 = accum2);  /* 11 EQ */
            call Cond2Acc(accum1 < accum2);  /* 12 LT */
            call Cond2Acc(accum1 <= accum2); /* 13 LE */
            call Cond2Acc(accum1 > accum2);  /* 14 GT */
            call Cond2Acc(accum1 >= accum2); /* 15 GE */
            call Cond2Acc(accum1 <> accum2); /* 16 NE */
            accum1 = not accum1;            /* 17 NOT */
            accum1 = accum1 and accum2;     /* 18 AND */
            accum1 = accum1 or accum2;      /* 19 OR */
            accum1 = accum1 xor accum2;     /* 20 XOR */
            accum1 = accum1 mod accum2;     /* 21 MOD */
            do;                             /* 22 SHL */
                if accum2$lb <> 0 then
                    accum1 = shl(accum1, accum2);
            end;
            do;                             /* 23 SHR */
                if accum2$lb <> 0 then
                    accum1 = shr(accum1, accum2);
            end;
            accum1 = high(accum1);          /* 24 HIGH */
            accum1 = low(accum1);           /* 25 LOW */
            do;                             /* 26 DB */
                if curTokType <> O$STRING then do;
                    accum1 = GetNumVal;
                    if accum1$hb - 1 < 0feh then    /* not 0 or FF */
                        call RecordError('V');
                    curOpFlags = 22h;
                end;
                curTokType = O$DATA;
                if IsReg(acc1ValType) then
                    call RecordError('X');
                nextTokType = O$DATA;
                inDB = TRUE;
            end;
            do;                             /* 27 DW */
                nextTokType = O$DATA;
                inDW = TRUE;
            end;
            do;                             /* 28 DS */
                showAddr = TRUE;
                segSize = segSize + accum1;
            end;
    case29: do;                             /* 29 EQU */
                showAddr = TRUE;
                call UpdateSymbolEntry(accum1, (K$SET + 4) - topOp);
                expectingOperands = FALSE;
            end;
            goto case29;                    /* 30 SET */
            do;                             /* 31 ORG */
                showAddr = TRUE;
                segSize = accum1;
            end;
            do;                             /* 32 END */
                segSize = 0;
                if tokenIdx > 0 then do;
                    segSize = GetNumVal;
                    if IsReg(acc1ValType) then
                        call RecordError('X');
                    showAddr = TRUE;
                end;
                if ifDepth > 0 then
                    call RecordError('N');
                if newOp <> T$CR then
                    call RecordError('Q');
                if expectOp then
                    b3BA = TRUE;
                else
                    call RecordError('Q');
            end;
            do;                             /* 33 IF */
                if expectOp then do;
                    condAsmSeen = TRUE;
                    call Nest(2);
                    if skipIf(0) = FALSE then
                        skipIf(0) = not ((low(accum1) and 1) = 1);
                    inElse(0) = FALSE;
                end;
            end;
            do;                             /* 34 ELSE */
                condAsmSeen = TRUE;
                if ifDepth = 0 then
                    call RecordError('N');
                else if inElse(0) = FALSE then do;
                    if skipIf(0) = FALSE then
                        skipIf(0) = TRUE;
                    else
                        skipIf(0) = skipIf(ifDepth);
                    inElse(0) = TRUE;
                end;
                else do;
                    kk = skipIf(0);
                    skipIf(0) = FALSE;
                    call RecordError('N');
                    skipIf(0) = kk;
                end;
            end;
            do;                             /* 35 ENDIF */
                if expectOp then do;
                    condAsmSeen = TRUE;
                    call UnNest(2);
                end;
            end;
            ;                               /* 36 */
            ;                               /* 37 */
            ;                               /* 38 */
            ;                               /* 39 */
            ;                               /* 40 */
            ;                               /* 41 */
            ;                               /* 42 */
            ;                               /* 43 */
            ;                               /* 44 */
            ;                               /* 45 */
            ;                               /* 46 */
            ;                               /* 47 */
            call MkCode(85h);               /* 48 LXI */
            call MkCode(5);                 /* 49 POP DAD PUSH INX DCX */
            call MkCode(7);                 /* 50 LDAX STAX */
            call MkCode(2);                 /* 51 ADC ADD SUB ORA SBB XRA AND CMP */
            call MkCode(8);                 /* 52 ADI OUT SBI ORI IN CPI SUI XRA ANI ACI */
            call MkCode(46h);               /* 53 MVI */
            call MkCode(6);                 /* 54 IND DCR */
            call MkCode(36h);               /* 55 MOV */
            call MkCode(0);                 /* 56 CZ CNZ JZ STA JNZ JNC LHLD */
                                            /*    CP JC SHLD CPE CPO CM LDA JP JM JPE */
                                            /*    CALL JPO CC CNC JMP */
            call MkCode(0);                 /* 57 RNZ STC DAA DI SIM SPHL RLC */
                                            /*    RP RAL HLT RM RAR RPE RET RIM */
                                            /*    PCHL CMA CNC RPO EI XTHL NOP */
                                            /*    RC RNX XCHG RZ RRC */
            call MkCode(6);                 /* 58 RST */
            do;                             /* 59 next tape */
                call PutStr$CO(.aNextTape);
                do while (CI and 7Fh) <> ' ';
                end;
            end;
        end;
    end;


    Parse: procedure;

        UpdateIsInstr: procedure;
            if not TestBit(60, topOp, .isInstrMap) then
                isInstr = FALSE;
        end;

        do while 1;
            if not (yyType = T$CR or (yyType >= K$END and yyType <= K$ENDIF)) and skipIf(0) then
                return;

            if GetPrecedence(newOp := yyType) > GetPrecedence(topOp := opStack(opSP)) or newOp = T$LPAREN then
            do;    /* SHIFT */
                if opSP >= 16 then do;
                    opSP = 0;
                    call ReportError(STACK$ERROR);
                end;
                else do;
                    opSp = opSp + 1;
                    opStack(opSP) = newOp;
                end;
                if newOp = T$LPAREN then do;
                    inNestedParen = expectOp;
                    expectOp = TRUE;
                end;
                return;
            end;

            /* REDUCE */
            if topOp = T$BEGIN then /* topOp used so set to newOp */
                topOp = newOp;
            else
                opSP = opSP - 1;    /* pop Op */
        

            if (curOpFlags := opFlags(topOp)) then      /* -------x -> getnum to acc1 & copy to acc2 */
            do;
                accum2 = GetNumVal;
                acc2ValType = acc1ValType;
            end;

            if (curOpFlags := ror(curOpFlags, 1)) then  /* ------x- -> getnum to acc1 */
                accum1 = GetNumVal;

            nextTokType = O$NUMBER;

            if topOp > T$RPAREN and topOp < K$DB then do;    /* expression topOp */
                if IsReg(acc1ValType) or IsReg(acc2ValType) then
                    call RecordError('X');
            end;
            else do;
                if not expectOp and topOp > T$RPAREN then
                    call RecordError('Q');
                call UpdateIsInstr;
                call ChkInvalidRegOperand;
            end;

            call HandleOp;
            if topOp > K$LOW then
                expectOp = FALSE;

            if b3B3 then
            do;
                b3B3 = FALSE;
                return;
            end;

            if showAddr then
                pc = accum1;

            if (curOpFlags and 1Eh) <> 0 then       /* --xxxx-- -> collect bytes */
                call PushToken(nextTokType);

            do ii = 0 to 3;
                if (curOpFlags := ror(curOpFlags, 1)) then  /* --xxxx-- -> collect high/low acc1/acc2 */
                    call CollectByte(accum(ii));
            end;

            if ror(curOpFlags, 1) then          /* -x------ -> list */
                if newOp = T$COMMA then
                do;
                    yyType = topOp;
                    expectOp = TRUE;
                end;
        end;
    end;

    DoPass: procedure public;
        do while finished = FALSE;
            call Tokenise;
            call Parse;
        end;
    end;

end;
eof
as85.plm
symbol: do;
$include(as85.ipx)

    declare bD239(2) byte data(2Dh, 80H);
    declare bD23B(*) byte data(8,  80h,    0,    0,    0,  80h);
    declare bD241(*) byte data(0,    0,    0,  1Fh,    0,    0,  80h,  80h);

    /* character class encoded as nibbles
     * values are
     * 0    CC$BAD
     * 1    CC$WS
     * 2    CC$SEMI
     * 3    CC$COLON
     * 4    CC$CR
     * 5    CC$PUN
     * 6    CC$DOLLAR
     * 7    CC$QUOTE
     * 13   CC$ESC
     * 14   CC$DIG
     * 15   CC$LET
     */
     

    declare chClass(64) byte public data(
       /* 01    23    45    67    89    AB    CD    EF */
           0 ,   0 ,   0 ,   0 ,   1 ,   0 ,  14h,   0 ,    /* 00-0F */
           0 ,   0 ,   0 ,   0 ,   0 ,  0Dh,   0 ,   0 ,    /* 10-1F */
          10h,   0 ,  60h,   7 ,  55h,  55h,  55h,   5 ,    /* 20-2F */
         0EEh, 0EEh, 0EEh, 0EEh, 0EEh,  32h,   0 ,  0Fh,    /* 30-3F */
         0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh,    /* 40-4F */
         0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0F0h,   0 ,   0 ,    /* 50-5F */
          0Fh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh,    /* 60-6F */
         0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0F0h,   0 ,   0);    /* 70-7F */

    declare curSym based curSym$p TOKENSYM$T;

    UnpackToken: procedure(src, dst) public;
        declare src apointer, dst pointer;
        declare wrd based src word;
        declare ch based dst byte;
        declare pad427 address, packedword word;

        Unpack1: procedure;
            ch = packedword mod 40;    
            if ch = 0 then
                ch = ' ';
            else if ch <= 10 then
                ch = ch + 2Fh;    /* digit */
            else 
                ch = ch + 34h;    /* ? @ and letters */
            packedword = packedword / 40;
            dst = dst - 1;
        end;

        UnpackWord: procedure;
            packedword = wrd;
            call Unpack1;
            call Unpack1;
            call Unpack1;
            src = src - 2;
        end;

        src = src + 2;
        dst = dst + 5;
        call UnpackWord;
        call UnpackWord;
    end;



    SetCurSymType: procedure(type);
        declare type byte;
            curSym.type = type;
    end;

    InsertSym: procedure;
        declare (p, q) pointer;
        declare pCh based p byte,
                qCh based q byte;

        /* move up the top block of the symbol tables to make room */
        symHighMark, p = (q := symHighMark) + 8;
        if startObjBuf < p then do;
            call ReportError(TABLE$ERROR);
            return;
        end;
        do while q > curSym$p; /* byte copy */
            p = p - 1;
            q = q - 1;
            pCh = qCh;
        end;
        call move(4, curTok$p, curSym$p);
        call SetCurSymType(0);
    end;

    UpdateSymbolEntry: procedure(val, type) public;
        declare val address, type byte;
        declare (flags, absFlag) byte,
                isSetOrEqu bool,
                origType byte;

        SetTokenType: procedure;
            curTokType = type;
            if (acc1ValType = K$REGNAME or acc1ValType = 8) and isSetOrEqu then
                curTokType = 12 - type;
        end;

        origType = curTokType;
        isSetOrEqu = type = O$EQU or type = O$SET;
        absFlag = 0;
        flags = curSym.flags;
        if curSym$p > endSymTab(TID$SYMBOL) or curSym$p < symTab(TID$SYMBOL) then do;
            call RecordError('Q');
            return;
        end;
        if tokenIdx > 1 then
            call RecordError('Q');
        if passCnt = 1 and curTokType = O$NAME then do;
            if createdUsrSym then do;
                if curSym.type >= 80h then do;
                    call RecordError('L');
                    absFlag = 80h;
                end;
            end; 
            else do;
                call InsertSym;
                endSymTab(TID$SYMBOL) = endSymTab(TID$SYMBOL) + 8;
                flags = 0;
            end;

            if not (acc1ValType = O$NAME and isSetOrEqu) then
                call SetTokenType;
        end;
        else if passCnt = 2 and curTokType = O$NAME and acc1ValType <> O$NAME and isSetOrEqu then do;
            call SetTokenType;
            if curSym.type < 80h then
                call SetCurSymType(curTokType);
        end;
        else do;
            if pass = 1 and (curTokType <> type and curTokType <> 8 or type = O$EQU) then
                curTokType = O$LABEL;
            if TestBit(40, curTokType, .bD23B) then
                flags = curTokType <> 28h or acc1Flags;
            else do;
                if pass = 1 then
                    curTokType = 3;
                if curSym.value <> val then
                    call RecordError('P');
            end;
        end;

        absFlag = absFlag or (curSym.type and 80h);
        if pass = 1 and (type = O$NAME or origtype <> curTokType) then
            call SetCurSymType(curTokType or absFlag);
        kk = curSym.type;
        if curTokType = O$LABEL or kk = O$LABEL then
            call RecordError('M');
        
        if kk >= 80h then
            call RecordError('L');

        if pass = 1 and (curTokType = type or type = O$EQU and curTokType = 7)
           or (type = O$SET and asmErrCode = ' ') then
            curSym.value = val;

        curSym.flags = flags;
        if createdUsrSym then
            call PopToken;
    end;


    Lookup: procedure(tableId) byte public;
        declare tableId byte;
        declare (lowOffset, entryOffset, highOffset, midOffset) pointer,
                packedTok$p pointer,
                (i, gt) byte;
        declare packedTok based packedTok$p word,
                entryTok based entryOffset word;

        lowOffset = symTab(tableId);
        highOffset, entryOffset = endSymTab(tableId);

        do while (midOffset := lowOffset + shr((highOffset - lowOffset) and 0FFF0h, 1)) <> entryOffset;
            entryOffset = midOffset;
            packedTok$p = curTok$p;
            do i = 0 to 1;
                if entryTok = packedTok then do;
                    entryOffset = entryOffset + 2;
                    packedTok$p = packedTok$p + 2;
                end;
                else
                    goto NotSame;
            end; 
            entryOffset, curSym$p = entryOffset - 4;
            curTokType = curSym.type;
            if TestBit(56, curTokType, .bD241) then
                b3AD = TRUE;
            if tableId = 0 then
                if curSym.flags = 2 and not ctlMOD85 then
                    call RecordError('O');
            if (userLookupIsId := (kk := curTokType and 7fh) = O$NAME) then
                if b1DF then
                    call SetCurSymType(80h + O$NAME);
            return kk;

    NotSame:
            gt = entryTok > packedTok;
            entryOffset = midOffset;
            if gt then
                highOffset = entryOffset;
            else
                lowOffset = entryOffset;
        end;
        
        curSym$p = highOffset;
        if tableId = TID$SYMBOL and not skipIf(0) then do;
            createdUsrSym = FALSE;
            call UpdateSymbolEntry(curLoc, (b1DF and 80h) or O$NAME);
            createdUsrSym = TRUE;
        end;
        return O$NAME;
    end;
end;
as86.plm
as86: do;
$include(as86.ipx)
    GetCh: procedure byte public;
        declare ch byte;    /* relies on static variable */
        declare pad445 byte;

        /* all the compilers I have generate
         * lda reget
         * rar
         * jc
         *
         * the code in the rom is
         * lda reget
         * cma
         * rar
         * jnc
         *
         * code here has enable to add a missing byte
         * to do code alignment. Post build patch
         * modifies the code to match
         */
        if not reget then do;
            enable;             /* force code alignment - to patch */
            kk = TRUE;

            do while kk;
                ch = lookAhead;
                if gettingCmdLine then do;
                    lookAhead = 0;
                    if ch <> cr then
                        lookAhead = GetCmdCh;
                end;
                else
                    lookAhead = GetSrcCh and 7fh;
                kk = ch = 0 or ch = 7fh or ch = FF;
            end;
            if not gettingCmdLine and (pass = 2 or pass = 4) then
                call PutNonLF$LST(ch);
        end;
        reget = FALSE;
        return (curChar := ch);
    end;

    GetChClass: procedure byte public;
        curChar = GetCh;
        return GetNibbleAt(.chClass, curChar);
    end;


    ChkLF: procedure public;
        if lookAhead = LF then
            lookAhead = 0;
        else
            call RecordError('I');
    end;

    PopToken: procedure public;
        tokenStart(0) = tokenStart(tokenIdx);
        tokenSym(0) = tokenSym(tokenIdx);
        tokenType(0) = tokenType(tokenIdx);
        tokenAttr(0) = tokenAttr(tokenIdx);
        tokenSize(0) = tokenSize(tokenIdx);
        if tokenIdx <> 0 then
            tokenIdx = tokenIdx - 1;
    end;


    Nest: procedure(sw) public;    /* sw not used for non macro version */
        declare sw byte;

        if (ifDepth := ifDepth + 1) > 8 then do;
            call ReportError(STACK$ERROR);
            ifDepth = 0;
        end;
        else do;
            skipIf(ifDepth) = skipIf(0);
            inElse(ifDepth) = inElse(0);
        end;
    end;


    UnNest: procedure(sw) public;
        declare sw byte;
        
        if ifDepth = 0 then
            call RecordError('N');
        else do;
            skipIf(0) = skipIf(ifDepth);
            inElse(0) = inElse(ifDepth);
            ifDepth= ifDepth - 1;
        end;
    end;


    PushToken: procedure(type) public;
        declare type byte;

            if tokenIdx >= 8 then
                call ReportError(STACK$ERROR);
            else do;
                tokenIdx = tokenIdx + 1;
                tokenStart(tokenIdx) = tokenStart(0);
                tokenSym(tokenIdx) = tokenSym(0);
                tokenType(tokenIdx) = tokenType(0);
                tokenAttr(tokenIdx) = tokenAttr(0);
                tokenSize(tokenIdx) = tokenSize(0);
                tokenStart(0) = tokenStart(0) + tokenSize(0);    /* advance for next token */
                tokenSym(0) = 0;
                tokenType(0) = type;
                tokenAttr(0), tokenSize(0) = 0;
            end;
        end;

    CollectByte: procedure(c) public;
        declare c byte;
        declare s pointer;
        declare ch based s byte;

        if (s := curTok$p + tokenSize(0)) < endLineBuf then    /* check for lineBuf overrun */
        do;
            ch = c;
            curTokSize = curTokSize + 1;
        end;
        else
            call ReportError(STACK$ERROR);
    end;

    GetId: procedure(type) public;
        declare type byte;

        call PushToken(type);    /* save any previous token and initialise this one */
        reget = 1;              /* force re get of first character */

        do while GetChClass > CC$ESC;    /* digit or letter */
            if curChar > 60h then    /* make sure upper case */
                curChar = curChar and 0DFh;
            call CollectByte(curChar);
        end;
        reget = 1;        /* force re get of Exit char */
    end;

    GetNum: procedure public;
        declare accum word,
            (radix, digit, i) byte;
        declare chrs based curTok$p (1) byte;

        call GetId(O$NUMBER);
        radix = chrs(curTokSize:= curTokSize - 1);
        if radix = 'H' then
            radix = 16;

        if radix = 'D' then
            radix = 10;

        if radix = 'O' then
            radix = 8;

        if radix = 'Q' then
            radix = 8;

        if radix = 'B' then
            radix = 2;

        if radix > 16 then
            radix = 10;
        else
            curTokSize = curTokSize  - 1;

        accum = 0;
        do i = 0 to curTokSize;
            if chrs(i) = '?' or chrs(i) = '@' then
            do;
                call RecordError('I');
                digit = 0;
            end;
            else
            do;
                if (digit := chrs(i) - '0') > 9 then
                    digit = digit - 7;
                if digit >= radix then do;
                    call RecordError('I');
                    digit = 0;
                end;
            end;

            accum = accum * radix + digit;
        end;
        /* replace with packed number */
        curTokSize = 0;
        call CollectByte(low(accum));
        call CollectByte(high(accum));
    end;

    GetStr: procedure public;
        call PushToken(O$STRING);

        do while GetCh <> CR;
            if curChar = '''' then
                if GetCh <> '''' then
                    goto break;
            call CollectByte(curChar);
        end;

        call RecordError('B');
    break:
        reget = 1;
    end;
end;
as87.plm
control: do;
$include(as87.ipx)
    declare controlTable(*) byte data(
    /* format of entries
        byte -> 00PNxxxx where
            P -> 0 general control 1 -> primary control
            N -> 0 NO prefix not supported 1-> NO prefix supported
            xxxx -> number of chars in name string
        name string
    */
            35h, 'DEBUG',       34h, 'XREF',
            37h, 'SYMBOLS',     36h, 'PAGING',
            3Ah, 'TAPESOURCE',  3Ah, 'TAPEOBJECT',
            25h, 'MOD85',       29h, 'PAGEWIDTH',
            2Ah, 'PAGELENGTH',    5, 'TITLE',
              5, 'EJECT',       14h, 'LIST',
            14h, 'COND');

    declare savedControlSeen(11) byte, savedTitleStr(64) byte, savedControls(17) byte;
    declare savedCtlList byte at(.savedControls + 11), tokVal byte, controLError byte;

    SkipNextWhite: procedure;   /* skip white but read first */
        do while GetCh = ' ' or curChar = TAB;
        end;
    end;

    ChkParen: procedure(c) bool;
        declare c byte;

        call SkipWhite;
        reget = FALSE;
        return curChar = '(' and c = 1 or curChar = ')' and c = 0;
    end;

    GetTok: procedure byte;
        tokBufLen = 0;
        tokType = 0;
        if curChar = CR then
            return curChar;

        call SkipNextWhite;
        if curChar > 'A'-1 and 'Z'+1 > curChar or curChar > 'a'-1 and 'z'+1 > curChar then
        do;                            /* letter */
            call GetId(O$ID);
            if asmErrCode = ' ' and curTokSize < 14 then do;
                tokType = 1;
                call move(tokBufLen := curTokSize, .lineBuf, .tokBuf);
            end;
        end;
        else if curChar > '0'-1  and  '9'+1 > curChar then    /* digit ? */
        do;
            call GetNum;
            if asmErrCode = ' ' then
            do;
                tokNumVal = GetNumVal;
                tokType = TT$NUM;
                tokBuf(0) = ' ';
            end;
        end;
        else if curChar = '''' then    /* string ? */
        do;
            call GetStr;
            if asmErrCode = ' ' then
            do;
                tokBufLen = 64;         /* cap at 64 chars */
                if curTokSize < 64 then
                    tokBufLen = curTokSize;
                tokType = TT$STR;
                if tokBufLen > 0 then
                    call move(tokBufLen, .lineBuf, .tokBuf);
            end;
        end;
        else
        do;
            tokBufLen = 1;
            tokBuf(0) = curChar;
            tokType = TT$PUNC;
            return curChar;
        end;

        call PopToken;      /* restore the stack from GetId/GetNum/GetStr calls */
        return tokBuf(0);
    end;

    GetControlNumArg: procedure bool;
        if not ChkParen(1) then    /* ( */
            return FALSE;
        tokVal = GetTok;
        if tokType <> TT$NUM then
            return FALSE;
        return ChkParen(0);    /* ) */
    end;

    LookupControl: procedure byte;
        declare (cmdIdx, cmdStartIdx) byte, 
            ctlVal bool,
            (cmdLen, found, ctlFlags, noInvalid) byte,
            (control$p, nextControl$p, pad4BC, pad4BE) pointer;
        declare twoch word at(.tokBuf);
        declare ch based control$p byte;

        SetControl: procedure;
            if not noInvalid then
            do;
                controls(controlId) = ctlVal;
                if not ctlVal then
                    controlId = 11;    /* no action needed */
            end;
        end;


        cmdLen = tokBufLen;
        cmdStartIdx = 0;
        ctlVal = TRUE;
        if twoch = 'ON' then    /* NO stored with bytes swapped */
        do;
            cmdStartIdx = 2;    /* don't match the NO in the table */
            ctlVal = FALSE;        /* control will be set as false */
            cmdLen = tokBufLen - 2;    /* length of string to match excludes the NO */
        end;

        control$p = .controlTable;
        controlId = 0;
        cmdIdx = cmdStartIdx;
        found = FALSE;

        do while not found and controlId < 14;
            nextControl$p = control$p + (ch and 0Fh) + 1;
            if (ch and 0Fh) = cmdLen then
            do;
                ctlFlags = ch;
                do while cmdIdx < tokBufLen;
                    control$p = control$p + 1;
                    if ch <> tokBuf(cmdIdx) then
                        cmdIdx = tokBufLen + 1;    /* cause early Exit */
                    else
                        cmdIdx = cmdIdx + 1;    /* check next character */
                end;

                if cmdIdx = tokBufLen then        /* found it */
                    found = TRUE;
            end;
            control$p = nextControl$p;
            controlId = controlId + 1;
            cmdIdx = cmdStartIdx;
        end;
        controlId = controlId - 1;
        if not found then
            goto ERROR;

        if (noInvalid := (ctlFlags and 10h) <> 10h) and not ctlVal then
            goto ERROR;                         /* NO not supported */

        if (ctlFlags and 20h) <> 20h then        /* general control */
        do;
            call SetControl;
            return controlId;
        end;

        if not primaryValid then            /* is a PRIMARY control */
           goto ERROR;

        if (80h and controlSeen(controlId)) = 80h and not gettingCmdLine then
            goto ERROR;
        if controlId = 4 and not (pass = 1 and gettingCmdLine) then
            goto ERROR;                     /* TAPESOURCE only valid on cmdLine in pass 1 */

        if ((controlSeen(controlId) and passCnt) and 7fh) = passCnt then
            goto ERROR;                     /* seen already in this pass */
        
        controlSeen(controlId) = (gettingCmdLine and 80h) or passCnt;
        call SetControl;
        return controlId;

    ERROR:
        return 0ffh;
    end;

    ProcessControl: procedure;
        /* simple controls already processed */
        if controlId >= 11 or controlId < 6 then
            return;

        do case controlId - 6;
            ctlMOD85 = TRUE;        /* MOD85 */
            do;                     /* PAGEWIDTH */
                if GetControlNumArg then do;
                    ctlPAGEWIDTH = tokNumVal;
                    if ctlPAGEWIDTH > 132 then
                        ctlPAGEWIDTH = 132;
                    else if ctlPAGEWIDTH < 72 then
                        ctlPAGEWIDTH = 72;
                end;
                else
                    controlError = TRUE;
            end;
            do;                     /* PAGELENGTH */
                if GetControlNumArg then do;
                    ctlPAGELENGTH = tokNumVal;
                    if ctlPAGELENGTH < 12 then
                        ctlPAGELENGTH = 12;
                end;
                else
                    controlError = TRUE;
            end;
            do;                     /* TITLE */
                if ChkParen(1) then do;
                    tokVal = GetTok;
                    if tokType <> TT$STR or tokBufLen = 0 then
                        controlError = TRUE;
                    else do;
                        if pass > 1 or primaryValid then do;
                            call move(tokBufLen, .tokBuf, .titleStr);
                            titleLen = tokBufLen;
                        end;
                        if ChkParen(0) then do;
                            ctlTITLE = TRUE;
                            if primaryValid then
                                b30B = TRUE;
                        end;
                        else
                            controlError = TRUE;
                    end;
                end;
                else
                    controlError = TRUE;
            end;
            ctlEJECT = ctlEJECT + 1; /* EJECT */
        end;
    end;


    ParseControls: procedure public;
        isControlLine = TRUE;
        call move(11, .controlSeen, .savedControlSeen);
        call move(64, .titleStr, .savedTitleStr);
        call move(17, .controls, .savedControls);
        ctlLISTChanged = ctlLIST;
        controlError = FALSE;
        if IsSkipping then
            call Skip2EOL;
        else
            do while GetTok <> CR and controlError = 0;
                if LookupControl = 255 then    /* Error ? */
                    controlError = TRUE;
                else
                    call ProcessControl;
            end;

        if controlError then do;
            if tokBuf(0) <> CR then do;
                reget = 0;
                call Skip2EOL;
            end;
            call RecordError('C');
            if gettingCmdLine then do;
                call move(11, .savedControlSeen, .controlSeen);
                call move(64, .savedTitleStr, .titleStr);
                call move(17, .savedControls, .controls);
            end;
        end;
        if not gettingCmdLine then
            call ChkLf;
        if ctlList <> savedCtlList then
            ctlListChanged = TRUE;
        reget = FALSE;
    end;
end;
as88.plm
io: do;
$include(as88.ipx)

    declare aUserSymbols(*) byte data(CR, LF, 'USER SYMBOLS', CR, LF, 0);
    declare locHeader(*) byte data('  LOC  OBJ         SEQ         SOURCE STATEMENT',
                                    CR, LF, LF, 0);
    declare junk(*) byte data(CR, LF, LF, 0, CR);
    declare lfx3(*) byte data(LF, LF, LF, 0);
    declare crLParen(*) byte data(CR, ' (', 0);
    declare RParenLf(*) byte data(')', LF, 0);
    declare dollar$crlf(*) byte data(' $', CR, LF, 0);
    declare crFF(*) byte data(CR, FF, 0);
    declare zeroSpace(*) byte data('0 ', 0);
    declare spaceZero(*) byte data(' 0', 0);
    declare h$crlf(*) byte data('H', CR, LF, 0);

    PutCh$HEX: procedure(ch) public;
        declare ch byte;

        if ctlTAPEOBJECT then
            call PO(ch);
        else
            call ObjByteToMem(ch);
    end;

    PutStr$HEX: procedure(str) public;
        declare str address, ch based str byte;
    
        do while ch <> 0;
            call PutCh$HEX(ch);
            str = str + 1;
        end;
    end;

    PutObjectData: procedure(n) public;
        declare n byte, i byte, ptr address;

        if not ctlTAPEOBJECT then do;
            if n = 1 then
                return;
            if b3EC then do;
                w3ED = hexBase;
                b3EC = 0;
            end;
            w3EF = (hexBase - w3ED) + .objBuf;
            
            do i = 1 to hexCnt;
                call PutCh$HEX(hexBuf(i));
            end;
            hexCnt = 0;
            if (ptr := w3EF - .objBuf) > w13FE then
                w13FE = ptr;
            return;
        end;
        call PutCh$HEX(':');
        call WriteHex2$HEX(hexCnt);
        call WriteHex2$HEX(high(hexBase));
        call WriteHex2$HEX(low(hexBase));
        call WriteHex2$HEX(n);
        do i = 1 to hexCnt;
            call WriteHex2$HEX(hexBuf(i));
        end;
        checksum = checksum - high(hexBase) - low(hexBase) - n - hexCnt;
        call WriteHex2$HEX(checksum);
        call Putch$HEX(CR);
        call Putch$HEX(LF);
        if n = 1 and b3BA then
            call PutStr$HEX(.dollar$crlf);
        checksum = 0;
        hexCnt = 0;
    end;


    declare numBuf(5) byte;

    OutCh$LO: procedure(ch);
        declare ch byte;

        if ch = LF then do;
            if maxCol > ctlPAGEWIDTH then
                maxCol = ctlPAGEWIDTH;
            ch = 0;
            do while ch < maxCol;
                call PutCh$LO(lstBuf(ch := ch + 1));
            end;
            call Putch$LO(CR);
            call Putch$LO(LF);
            maxCol = 0;
        end;
        else do;
            if ch >= ' ' then
                lstBuf(curCol) = ch;
            if curCol > maxCol then
                maxCol = curCol;
        end;
    end; 

    PrintChar: procedure(ch);
        declare ch byte;
        declare (spaces, i) byte;

        if ch = FF then do;
            do while rowCnt <> 0;
                if (rowCnt := rowCnt + 1) > ctlPAGELENGTH then
                    rowCnt = 0;
                else if ctlPAGING then
                    call OutCh$LO(LF);
            end;
            return;
        end;
        if ch = CR then
            curCol = 0;
        if ch = LF then
            rowCnt = rowCnt + 1;
        
        spaces = (ch = TAB) and (7 - (curCol and 7));
        if ch = TAB then
            ch = ' ';
        do i = 0 to spaces;
            if curCol < 132 then do;
                curCol = curCol + ((ch >= ' ') and 1);
                call OutCh$LO(ch);
            end;
        end;
    end;

    PutStr$LST: procedure(str) public;
        declare str address, ch based str byte;

        do while ch <> 0;
            call PrintChar(ch);
            str = str + 1;
        end;
    end;

    PrintNStr: procedure(len, str);
        declare len byte, str address, ch based str byte;
        do while len > 0;
            call PrintChar(ch);
            str = str + 1;
            len = len - 1;
        end;
    end;

    CrLf$LST: procedure;
        call PutStr$LST(.crlf);
    end;

    Num2Ascii: procedure(value, buf$p) public;
        declare (value, buf$p) address;
        declare ch based buf$p byte;

        call move(5, .spaces6 + 1, buf$p);
        numBuf(4) = 0;
        buf$p = buf$p + 3;
        do while 1;
            ch = value mod 10 + '0';
            buf$p = buf$p - 1;
            if (value := value / 10) = 0 then
                return;
        end;
    end;

    PutNum$LST: procedure(value);
        declare value address, pad4DB byte;
        call Num2Ascii(value, .numBuf);
        call PutStr$LST(.numBuf);
    end;


    NewPageHeader: procedure public;
        call PutStr$LST(.lfx3);
        call PutStr$LST(.signOn + 2);
        call PutNum$LST(pageNo);
        call CrLf$LST;
        if (b30B and b261) or ctlTITLE then
            call PrintNStr(titleLen, .titleStr);
        call CrLf$LST;
        call CrLf$LST;
        if not b279 then
            call PutStr$LST(.locHeader);
        pageNo = pageNo + 1;
    end;

    PutCh$LST: procedure(ch) public;
        declare ch byte;
    
        if ch = FF or rowCnt >= ctlPAGELENGTH - 3 then do;
            call PutStr$LST(.crFF);
            if ctlPAGING then do;
                if ch <> FF then
                    ctlEJECT = ctlEJECT + 1; 
                do while ctlEJECT > 0;
                    call PrintChar(FF);
                    call NewPageHeader;
                    ctlEJECT = ctlEJECT - 1;
                end;
            end;
            curCol = not b279 and 24;
        end;
        if ch <> FF then
            call PrintChar(ch);
    end;
    
    declare pad4DD(8) byte;

    PutNonLF$LST: procedure(ch) public;
        declare ch byte;
        if ch <> LF then
            call PutCh$LST(ch);
    end;

    PrintSymbols: procedure public;
        declare type based curSym$p byte;

        ICallSymM1: procedure(proc);
            declare proc address;
            declare ch based curSym$p byte;

            curSym$p = curSym$p - 1;
            call proc(ch);
        end;


        b279 = TRUE;
        curSym$p = symTab(TID$SYMBOL) - 2;
        if not pass and b3BA then
            call PutStr$LST(.aUserSymbols);
        do while (curSym$p := curSym$p + 8) < endSymTab(TID$SYMBOL);
            if type <> 9 then do;
                call UnpackToken(curSym$p - 6, .tokStr);
                if pass > 2 and ctlDEBUG and not b3BA then do;
                    call PutStr$HEX(.zeroSpace);
                    call PutStr$HEX(.tokStr);
                    call PutStr$HEX(.spaceZero);
                    call ICallSymM1(.WriteHex2$HEX);
                    call ICallSymM1(.WriteHex2$HEX);
                    curSym$p = curSym$p + 2;
                    call PutStr$HEX(.h$crlf);
                end;
                if not pass and b3BA then do;
                    if ctlPAGEWIDTH - curCol < 15 then
                        call CrLf$LST;
                    call PutCh$LST(tokStr(0));
                    call PutStr$LST(.tokStr(1));
                    call PutCh$LST(' ');
                    call ICallSymM1(.WriteHex2$LST);
                    call ICallSymM1(.WriteHex2$LST);
                    curSym$p = curSym$p + 2;
                    call PutStr$LST(.spaces6 + 2);
                end;
            end;
        end;
        if not pass and b3BA then
            call CrLf$LST;
    end;




    PrintLine: procedure public;
        declare byt based startItem byte;

        PrintErrorLocChain: procedure;
            if not errorOnLine then
                return;
            call PutStr$LST(.crLParen);
            call PutNum$LST(lastErrorLoc);
            call PutStr$LST(.RParenLf);
            lastErrorLoc = curLoc;
        end;



        do while 1;
            endItem = tokenStart(spIdx) + tokenSize(spIdx);
            startItem = tokenStart(spIdx);
            if skipIf(0) then do;
                endItem = startItem;
                if not ctlCOND and asmErrCode = ' ' then
                    maxCol = 24;
            end;
        Loop:
            b275 = 0;
            call PutCh$LST(CR);
            call Putch$LST(asmErrCode);
            call PutCh$LST(' ');
            if asmErrCode <> ' ' then
                errorOnLine = TRUE;
            asmErrCode = ' ';
            if not isControlLine then do;
                if (showAddr := endItem <> startItem or showAddr) then do;
                    call WriteHex2$LST(high(pc));
                    call WriteHex2$LST(low(pc));
                end;
                else
                    call PutStr$LST(.spaces6 + 2);

                call PutCh$LST(' ');
                do ii = 1 to 4;
                    if startItem < endItem and isInstr then do;
                        pc = pc + 1;
                        call WriteHex2$LST(byt);
                    end;
                    else
                        call PutStr$LST(.spaces6 + 4);
                    startItem = startItem + 1;
                end;
                call PutStr$LST(.spaces6 + 4);
            end;
            else
                do ii = 3 to 17;
                    call PutCh$LST(' ');
                end;
            call PutStr$LST(.spaces6 + 4);
            if b278 then
                call PutStr$LST(.spaces6 + 2);
            else do;
                b278 = TRUE;
                call PutNum$LST(curLoc);
            end;
            call PutCh$LST(' ');
            if maxCol > ctlPAGEWIDTH then
                call subC3F5(maxCol);
            call PutCh$LST(LF);
            if isControlLine then do;
                call DoEject;
                goto Done;
            end;
            if startItem < endItem then
                goto Loop;
            else if spIdx = 0 or not (inDB or inDW) then do;
                call PrintErrorLocChain;
                return;
            end;
            call subC91A;
        end;
    Done:
        call PrintErrorLocChain;
    end;
end;
keywrd.plm
keywords: do;
$include(keywrd.ipx)
    declare keywords(116) TOKENSYM$T public data(
             5140h,      0,    7,    7,     0,  /* A      */
             53ADh,      0, 0CEh,  34h,     0,  /* ACI    */
             53CFh,      0,  88h,  33h,     0,  /* ADC    */
             53D0h,      0,  80h,  33h,     0,  /* ADD    */
             53D5h,      0, 0C6h,  34h,     0,  /* ADI    */
             555Dh,      0, 0A0h,  33h,     0,  /* ANA    */
             5560h,      0,    0,  12h,     0,  /* AND    */
             5565h,      0, 0E6h,  34h,     0,  /* ANI    */
             5780h,      0,    0,    7,     0,  /* B      */
             5DC0h,      0,    1,    7,     0,  /* C      */
             5FE0h,  9600h, 0CDh,  38h,     0,  /* CALL   */
             6018h,      0, 0DCh,  38h,     0,  /* CC     */
             61A8h,      0, 0FCh,  38h,     0,  /* CM     */
             61B5h,      0,  2Fh,  39h,     0,  /* CMA    */
             61B7h,      0,  3Fh,  39h,     0,  /* CMC    */
             61C4h,      0, 0B8h,  33h,     0,  /* CMP    */
             61DFh,      0, 0D4h,  38h,     0,  /* CNC    */
             61F6h,      0, 0C4h,  38h,     0,  /* CNZ    */
             6220h,      0, 0F4h,  38h,     0,  /* CP     */
             6231h,      0, 0ECh,  38h,     0,  /* CPE    */
             6235h,      0, 0FEh,  34h,     0,  /* CPI    */
             623Bh,      0, 0E4h,  38h,     0,  /* CPO    */
             63B0h,      0, 0CCh,  38h,     0,  /* CZ     */
             6400h,      0,    2,    7,     0,  /* D      */
             6615h,      0,  27h,  39h,     0,  /* DAA    */
             6618h,      0,    9,  31h,     0,  /* DAD    */
             6630h,      0,    0,  1Ah,     0,  /* DB     */
             6676h,      0,    5,  36h,     0,  /* DCR    */
             667Ch,      0,  0Bh,  31h,     0,  /* DCX    */
             6748h,      0, 0F3h,  39h,     0,  /* DI     */
             68D8h,      0,    0,  1Ch,     0,  /* DS     */
             6978h,      0,    0,  1Bh,     0,  /* DW     */
             6A40h,      0,    3,    7,     0,  /* E      */
             6D88h,      0, 0FBh,  39h,     0,  /* EI     */
             6E1Fh,  6A40h,    0,  22h,     0,  /* ELSE   */
             6E60h,      0,    0,  20h,     0,  /* END    */
             6E60h,  8610h,    0,  23h,     0,  /* ENDIF  */
             6E98h,      0,    0,  3Bh,     0,  /* EOT    */
             6EC8h,      0,    0,  0Bh,     0,  /* EQ     */
             6EE9h,      0,    0,  1Dh,     0,  /* EQU    */
             7968h,      0,    0,  0Fh,     0,  /* GE     */
             7BC0h,      0,    0,  0Eh,     0,  /* GT     */
             7D00h,      0,    4,    7,     0,  /* H      */
             805Bh,  7D00h,    0,  18h,     0,  /* HIGH   */
             80E0h,      0,  76h,  39h,     0,  /* HLT    */
             8610h,      0,    0,  21h,     0,  /* IF     */
             8750h,      0, 0DBh,  34h,     0,  /* IN     */
             876Eh,      0,    4,  36h,     0,  /* INR    */
             8774h,      0,    3,  31h,     0,  /* INX    */
             8BD8h,      0, 0DAh,  38h,     0,  /* JC     */
             8D68h,      0, 0FAh,  38h,     0,  /* JM     */
             8D84h,      0, 0C3h,  38h,     0,  /* JMP    */
             8D9Fh,      0, 0D2h,  38h,     0,  /* JNC    */
             8DB6h,      0, 0C2h,  38h,     0,  /* JNZ    */
             8DE0h,      0, 0F2h,  38h,     0,  /* JP     */
             8DF1h,      0, 0EAh,  38h,     0,  /* JPE    */
             8DFBh,      0, 0E2h,  38h,     0,  /* JPO    */
             8F70h,      0, 0CAh,  38h,     0,  /* JZ     */
             9600h,      0,    5,    7,     0,  /* L      */
             988Dh,      0,  3Ah,  38h,     0,  /* LDA    */
             988Dh, 0E100h,  0Ah,  32h,     0,  /* LDAX   */
             98A8h,      0,    0,  0Dh,     0,  /* LE     */
             9938h,  6400h,  2Ah,  38h,     0,  /* LHLD   */
             9A5Bh,      0,    0,  19h,     0,  /* LOW    */
             9B00h,      0,    0,  0Ch,     0,  /* LT     */
             9BB5h,      0,    1,  30h,     0,  /* LXI    */
             9C40h,      0,    6,    7,     0,  /* M      */
            0A088h,      0,    0,  15h,     0,  /* MOD    */
            0A09Ah,      0,  40h,  37h,     0,  /* MOV    */
            0A1A5h,      0,    6,  35h,     0,  /* MVI    */
            0A528h,      0,    0,  10h,     0,  /* NE     */
            0A6D4h,      0,    0,  39h,     0,  /* NOP    */
            0A6D8h,      0,    0,  11h,     0,  /* NOT    */
            0AD70h,      0,    0,  13h,     0,  /* OR     */
            0AD7Dh,      0, 0B0h,  33h,     0,  /* ORA    */
            0AD83h,      0,    0,  1Fh,     0,  /* ORG    */
            0AD85h,      0, 0F6h,  34h,     0,  /* ORI    */
            0AE08h,      0, 0D3h,  34h,     0,  /* OUT    */
            0B16Ch,  9600h, 0E9h,  39h,     0,  /* PCHL   */
            0B354h,      0, 0C1h,  31h,     0,  /* POP    */
            0B3FBh,      0,    6,    7,     0,  /* PSW    */
            0B447h,  7D00h, 0C5h,  31h,     0,  /* PUSH   */
            0BDA0h,      0,  17h,  39h,     0,  /* RAL    */
            0BDA6h,      0,  1Fh,  39h,     0,  /* RAR    */
            0BDD8h,      0, 0D8h,  39h,     0,  /* RC     */
            0BE48h,      0, 0C9h,  39h,     0,  /* RET    */
            0BEE1h,      0,  20h,  39h,     2,  /* RIM    */
            0BF4Fh,      0,    7,  39h,     0,  /* RLC    */
            0BF68h,      0, 0F8h,  39h,     0,  /* RM     */
            0BF9Fh,      0, 0D0h,  39h,     0,  /* RNC    */
            0BFB6h,      0, 0C0h,  39h,     0,  /* RNZ    */
            0BFE0h,      0, 0F0h,  39h,     0,  /* RP     */
            0BFF1h,      0, 0E8h,  39h,     0,  /* RPE    */
            0BFFBh,      0, 0E0h,  39h,     0,  /* RPO    */
            0C03Fh,      0,  0Fh,  39h,     0,  /* RRC    */
            0C078h,      0, 0C7h,  3Ah,     0,  /* RST    */
            0C170h,      0, 0C8h,  39h,     0,  /* RZ     */
            0C3FEh,      0,  98h,  33h,     0,  /* SBB    */
            0C405h,      0, 0DEh,  34h,     0,  /* SBI    */
            0C488h,      0,    0,  1Eh,     0,  /* SET    */
            0C4F8h,      0,    0,  16h,     0,  /* SHL    */
            0C4F8h,  6400h,  22h,  38h,     0,  /* SHLD   */
            0C4FEh,      0,    0,  17h,     0,  /* SHR    */
            0C521h,      0,  30h,  39h,     2,  /* SIM    */
            0C620h,      0,    6,    7,     0,  /* SP     */
            0C634h,  9600h, 0F9h,  39h,     0,  /* SPHL   */
            0C6CDh,      0,  32h,  38h,     0,  /* STA    */
            0C6CDh, 0E100h,    2,  32h,     0,  /* STAX   */
            0C6CFh,      0,  37h,  39h,     0,  /* STC    */
            0C6F6h,      0,  90h,  33h,     0,  /* SUB    */
            0C6FDh,      0, 0D6h,  34h,     0,  /* SUI    */
            0E36Ch,  76C0h, 0EBh,  39h,     0,  /* XCHG   */
            0E556h,      0,    0,  14h,     0,  /* XOR    */
            0E5BDh,      0, 0A8h,  33h,     0,  /* XRA    */
            0E5C5h,      0, 0EEh,  34h,     0,  /* XRI    */
            0E614h,  9600h, 0E3h,  39h,     0   /* XTHL   */
    );

    EndKeywords: procedure address public;
        return .EndKeywords;
    end; 
end;
editor.plm
editor: do;
    /* useful literals */
    declare LIT LITERALLY 'literally';
    declare BELL LIT '7',
            BS  LIT '8',
            TAB LIT '9',
            LF  LIT '0AH',
            VT  LIT '0BH',
            FF  LIT '0CH',
            CR  LIT '0DH',
            ESC LIT '1BH';

    declare CTRLC   LIT '3',
            CTRLQ   LIT '11h',
            CTRLR   LIT '12h',
            CTRLS   LIT '13h',
            CTRLX   LIT '18h',
            CTRLZ   LIT '1Ah',
            RUBOUT  LIT '7FH';

    declarE ISALPHA LIT '0',
            ISNUMBER   LIT '1',
            ISOTHER lIT '2';

    declare TRUE    LIT '0FFH',
            FALSE   LIT '0',
            BOOL    LIT 'BYTE';      
    declare jmps(2) structure(jmp byte, target address) data(
        0c3h, .main-3, 0c3h, 0);    /* To patch 0 with .REENTER */
    declare copyRight(*) byte data('(C) 1973,1974,1975,1976,1977 INTEL CORP');
    declare vecStart0 address data(0F800h);
    declare signOn(*) byte data(CR, LF, 'ROM TEXT EDITOR, V1.1', CR, LF);
    declare aIllegal(*) byte data(22h, ' ILLEGAL IN THIS CONTEXT', CR, LF);
    declare aNotFound(*) byte data(CR, LF, 'CANNOT FIND ', 22h);
    declare crlf(2) byte data(CR, LF);
    declare aStartPunch(*) byte data(CR, LF, 'START PUNCH, TYPE CHAR', CR, LF);
    declare aIterFault(*) byte data(CR, LF, 'ITERATION STACK FAULT');
    declare aBreak(*) byte data(CR, LF, '*BREAK*', CR, LF);
    declare aUnused(*)  byte data(' - UNUSED BYTES', CR, LF);
    declare bA8C1 byte data(0);

    declare (ILLEGAL, BREAK) label public;

    /* data located at 2000h */
    declare (w2000, w2002, w2004) address,
            (textPtr, endPtr) address,
            (w200A, w200C, cmdCnt, w2010, w2012) address,
            memSize address,
            (char, chType, backwards, curCol) byte;
    declare (iterSp, b201B, b201C, findLen, B201E) byte,
            needLeader byte, b2020 byte,
            findBuf(17) byte,
            (iterStackPtr, iterStackCnt)(8) address;

    ci: procedure byte external;
    end ci;

    co: procedure (char) external;
        declare (char) byte;
    end co;

    ri: procedure byte external;
    end ri;

    po: procedure (char) external;
        declare (char) byte;
    end po;

    lo: procedure (char) external;
        declare (char) byte;
    end lo;

    csts: procedure byte external;
    end csts;

    memck: procedure address external;
    end memck;

    numout: procedure(value, base, lc, bufadr, width) external;
        declare (value, bufadr) address, (base, lc, width) byte; 
    end;

    ChIn$CI: procedure byte;
        return CI and 7fh;
    end;

    ChkCtrlC: procedure;
        if CSTS then
        if ChIn$CI = CTRLC then
            goto BREAK;
    end;

    Write$PO: procedure(curPos, endPos);
        declare (curPos, endPos) address;
        /* 
           this code compiles differently on all available compilers
           cf the rom code, specifically the code in the rom after
           the call to PO is
           lxi h,needLeader
           mvi m,0
           inx h
           inr m
           jnz ..

           even though needLeader and b2020 are adjacent in memory
           according to the declaration, the compiler generates
           lxi h,needLeader
           mvi m,0
           lxi h,b2020
           inr m
           jnz ...

           the hack here is to comment out the line of code
           and to insert a dummy enables to pad to align
        */

        if needLeader then
            do b2020 = 1 to 120;
                call PO(0);
                /*needLeader = 0;*/
                enable;
                enable;
                enable;
            end;
        do while curPos <= endPos;
            call ChkCtrlC;
            call PO(MEMORY(curPos));
            curPos = curPos + 1;
        end;
    end; 

    Putch$CO: procedure(ch);
        declare ch byte;
        CALL CO(ch);
        if CSTS then do;
            ch = ChIn$CI;
            if ch = CTRLS then
                do while (ch := ChIn$CI) <> CTRLQ;
                    if ch = 3 then
                        goto BREAK;
                end;
        end;
    end;

    DisplayCh: procedure(ch);
        declare (ch, spaces, i) byte;

        spaces = ch = TAB and (7 - (curCol and 7));
        if ch = TAB then
            ch = ' ';
        do i = 0 to spaces;
            if ch = CR then
                curCol = 0;
            if ch = FF then
                ch = '!';
            if ch = ESC or ch = 7dh then
                ch = '$';
            if ch >= ' ' then
                curCol = curCol + 1;
            call Putch$CO(ch);
        end;
    end;

    DisplayText: procedure(str$p,  len);
        declare (str$p, len, i) address;
        declare str based str$p (1) byte;

        do i = 0 to len;
            call ChkCtrlC;
            call DisplayCh(str(i));
        end;
    end;

    ChIn$RO: procedure byte;
        call ChkCtrlC;
        char = RI;
        if CARRY then
            char = CTRLZ;
        return char and 7fh;
    end;

    moveup: procedure;
        declare dstidx address;

        if iter$sp <> 0 then
            return;
        dstidx = memsize - 1;

        do while w2012 >= w2004;
            memory(dstidx) = memory(w2012);
            dstidx = dstidx - 1;
            w2012 = w2012 - 1;
        end;
        w2004 = dstidx + 1;
        w2012 = memsize - 1;
    end;

    MoveDown: procedure;
        endPtr = textPtr;
        do while w200A <= w200C;
            MEMORY(endPtr) = MEMORY(w200A);
            w200A = w200A + 1;
            endPtr = endPtr + 1;
        end;
        MEMORY(endPtr := endPtr - 1) = 0ffh;;
        call MoveUp;
    end;

    GetText: procedure;
        declare (inCh,  prevInCh) byte,
                idx address;

        do while 1;
            b201B = FALSE;
            w2004 = memSize;
            w2012 = memSize - 1;
            prevInCh = 0;
            iterSp = 0;
            call DisplayCh('*');
            inch = ChIn$CI;

            do while inCh <> CTRLC;
                do while inCh = RUBOUT;
                    if w2004 <> memSize then do;
                        if (inCh := MEMORY(w2004)) = ESC THEN
                            inCh = '$';
                        call DisplayCh(inCh);
                        w2004 = w2004 + 1;
                        inCh = ChIn$CI;
                        prevInCh = 0;
                    end;
                    else do;
                        inCh = CTRLC;
                        call DisplayCh(BELL);
                    end;
                end;
                if inCh = CTRLX then do;
                    call DisplayCh('#');
                    call DisplayText(.crlf, 1);
                    do while w2004 <> memSize and MEMORY(w2004) <> LF;
                        w2004 = w2004 + 1;
                    end;
                    inCh = ChIn$CI;
                end;
                else if inCh = CTRLR then do;
                    call DisplayText(.crlf, 1);
                    idx = w2004;
                    do while idx < memSize and LF <> MEMORY(idx);
                        idx = idx + 1;
                    end;
                    do while idx <> w2004;
                        call DisplayCh(MEMORY(idx := idx - 1));
                    end;
                    inCh = ChIn$CI;
                end;
                else if endPtr >= w2004 - 10 then do;
                    inCh = ChIn$CI;
                    call DisplayCh(BELL);
                end;
                else do;
                    if inCh = CR then do;
                        MEMORY(w2004 := w2004 - 1) = CR;
                        call DisplayCh(CR);
                        inCh = LF;
                    end;
                    if inCh <> CTRLC then do;
                        if inCh =  7dh then
                            inCh = ESC;
                        if inCh = ESC then
                            call DisplayCh('$');
                        else
                            call DisplayCh(inCh);
                        MEMORY(w2004 := w2004 - 1) = inCH;
                        if inCh = ESC and prevInCh = ESC then do;
                            call DisplayText(.crlf, 1);
                            return;
                        end;
                        prevInCh = inCh;
                        inCh = ChIn$CI;
                    end;
                end;
            end;
            call DisplayText(.crlf, 1);
        end;    /* while 1 */
    end;

    GetCmdCh: procedure byte;
        declare ch byte;

        if w2004 > w2012 then
            call GetText;
        if csts then
            if ChIn$CI = CTRLC then do;
                if b201E then
                    call MoveDown;
                goto BREAK;
            end;
        chtype = ISOTHER;
        ch = MEMORY(w2012); 
        if ch >= 'A' and ch <= 'Z' or ch >= 'a' and ch <= 'z' then
            chtype = ISALPHA;
        if (ch >= '0' and ch <= '9') or ch = '+' or ch = '-' then
            chtype = ISNUMBER;
        w2012 = w2012 - 1;
        return ch;
     end;

    GetCmdNum: procedure address;
        declare val address;
        if char < '0' then do;
            backwards = char = '-';
            char = GetCmdCh;
        end; 

        val =  0;
        do while chtype = ISNUMBER;
            if char < '0' then
                goto ILLEGAL;
            /* val = val * 10 + char - '0' */
            val = shl(shl(val, 2) + val, 1) + char - '0';
            char = GetCmdCh;
        end;
        if val = 0 and backwards then
            return 1;
        return val;
    end;


    FindRel: procedure address;
        declare start address, (i, ch) byte;

        start = 0;
        do while MEMORY(textPtr + start) <> 0ffh;
            i = 0;
            do while (ch := MEMORY(textPtr + start + i)) = findbuf(i);
                if findbuf(i := i + 1) = esc then
                    return start;
            end;
            if ch = 0ffh then
                return 0ffffh;
            start = start + 1;
        end;
        return 0ffffh;
    end;

    SeekLine: procedure address;
        declare startLine address, ch byte;

        startLine = textPtr;
        if cmdCnt = 0 or backwards then do;
            if textPtr = 1 then
                return 1;
            if textPtr = endPtr then
                startLine = startLine - 1;
            cmdCnt = cmdCnt + 1;
            do while cmdCnt <> 0 and textPtr <> 1;
                if (ch := MEMORY(startLine)) = 0ffh then
                    return startLine + 1;
                if ch = LF then
                    cmdCnt = cmdCnt - 1;
                startLine = startLine - 1;
            end;
            return startLine + 2;   /* after the marker */
        end;
        else
            do while cmdCnt <> 0;
                if (ch := memory(startLine)) = 0ffh then
                    return startLine;
                if ch = LF then
                    cmdCnt = cmdCnt - 1;
                startLine = startLine + 1;
            end;
        return startLine;
    end;


    FindLoc: procedure address;
        declare relOffset address;
 
        findLen = 0;
        do while (findbuf(findLen) := getcmdch) <> ESC;
            if findLen < 16 then
                findLen = findLen + 1;
        end;
        if (relOffset := FindRel) = 0ffffh then do;
            call DisplayText(.aNotFound, 14);
            if findLen <> 0 then
                call DisplayText(.findbuf, findLen - 1);
            call PutCh$CO(22h);
            call DisplayText(.crlf, 1);
            goto break;
        end;
        else
            return relOffset + textPtr;
    end;


    ShowUnused: procedure;
        declare b2072(6) byte, b2078 byte,
                b2079 byte, b207A(6) byte;
        declare unused address, junk address;

        unused = memSize - endPtr;
        call NumOut(unused, 10, bA8C1, .b207A, 6);
        b2079 = 5;
        b2078 = 5;
        /* copy the digits over inserting a comma if >= 1000 */
        do while b2078 <> 0ffh;
            b2072(b2078) = b207A(b2079);
            b2079 = b2079 - 1;
            b2078 = b2078 - 1;
            if b207A(b2079) <> 0 and b2079 = 2 then do;
                b2072(b2078) = ',';
                b2078 = b2078 - 1;
            end;
        end;
        call DisplayText(.b2072, 5);
        call DisplayText(.aUnused, 16);
    end;

main:
    call DisplayText(.signOn, 24);
    memSize = MEMCK - .MEMORY;
    MEMORY(0) = 0ffh;
    MEMORY(1) = 0ffh;
    w2000 = .MEMORY(1);
    textPtr, endPtr = 1;
    b201B = 0;
    needLeader = TRUE;
    call GetText;

CMDLOOP:
    do while 1;
        b201E = 0;
        w200A = textPtr;
        w200C = endPtr;
        backwards = 0;
        cmdCnt = 1;
        char = GetCmdCh;
        if chType = ISNUMBER then
            cmdCnt = getCmdNum;
        if char = '<' then do;
            if backwards then
                goto ILLEGAL;
            if (iterSp := iterSp + 1) > 8 then do;
                call DisplayText(.aIterFault, 22);
                goto BREAK;
            end;
            iterStackPtr(iterSp) = w2012;
            if (iterStackCnt(iterSp) := cmdCnt) = 0 then
                goto ILLEGAL;
            goto CMDLOOP;
        end;
        if char = '>' and iterSp <> 0 then do;
            if (iterStackCnt(iterSp) := iterStackCnt(iterSp) - 1) <> 0 then
                w2012 = iterStackPtr(iterSp);
            else
               iterSp = iterSp - 1;
            goto CMDLOOP;
        end; 
        if chType = ISALPHA then do;
            if char > 'Z' then
                char = char and 0dfh;
            do case char - 'A';
               do;                  /* 'A' APPEND */
                    b201C = TRUE;
                    cmdCnt = 0;
                    do while b201C;
                        if endPtr >= w2004 - 240 OR b201B THEN
                            b201C = 0;
                        else if (char := ChIn$RO) <> ctrlz then do; 
                            if char <> 0 and char <> 7fh then do;
                                if char = FF then
                                    b201C = 0;
                                MEMORY(endPtr) = char;
                                endPtr = endPtr + 1;
                                if char = LF then
                                    if (cmdCnt := cmdCnt + 1) = 50 then
                                        b201C = 0;
                            end;
                        end;
                        else do;
                            b201B = 0FFH;
                            b201C = 0;
                        end;
                    end;
                    MEMORY(endPtr) = 0ffh;
                end;
                textPtr = 1;        /* 'B' TEXT POINTER TO BEGINNING */
                do;                 /* 'C' TEXT POINTER CHARACTER */
                    if backwards then do;
                        if textPtr - 1 < cmdCnt then
                            textPtr = 1;
                        else
                            textPtr = textPtr - cmdCnt;
                    end;
                    else if (w2010 := textPtr + cmdCnt) > endPtr then
                        textPtr = endPtr;
                    else
                        textPtr = w2010;
                end;
                do;                 /* 'D' DELETE */
                    if backwards then do;
                        if textPtr - 1 < cmdCnt then
                            textPtr = 1;
                        else
                            textPtr = textPtr - cmdCnt;
                    end;
                    else if (w2010 := textPtr + cmdCnt) > endPtr then
                        w200A = endPtr;
                    else
                        w200A = w2010;
                    call MoveDown;
                end;
                do;                 /* 'E' EXIT */
                    call DisplayText(.aStartPunch, 25);
                    char = CI;
                    char = 0;
                    call Write$PO(1, endPtr - 1);
                    if b201B then
                        call PO(CTRLZ);
                    else
                        do while char <> CTRLZ;
                            char = ChIn$RO;
                            call PO(char);
                        end;
                    do char = 1 to 120;
                        call PO(0);
                    end;
                    w200A = STACKPTR;
                    w2002 = endPtr - 1;
                    call vecStart0;
        REENTER:
                    STACKPTR = w200A;
                end;
                textPtr = FindLoc + findLen;/* 'F' FIND */
                do; goto ILLEGAL; end;      /* 'G' */
                do; goto ILLEGAL; end;      /* 'H' */
    CASE$I:     do;                         /* 'I' INSERT */
                    b201E = TRUE;
                    do while (char := GetCmdCh) <> ESC;
                        if textPtr = w200A then do; 
                            call MoveUp;
                            if w2004 - 11 < w200C then
                                goto BREAK;
                            w2010 = w200C;
                            w200C, w200A = w2004 - 10;
                            do while w2010 >= textptr;
                                MEMORY(w200A) = MEMORY(w2010);
                                w2010 = w2010 - 1;
                                w200A = w200A - 1;
                            end;
                            w200A = w200A + 1;
                        end;
                        MEMORY(textPtr) = char;
                        textPtr = textPtr + 1; 
                    END; 
                    b201E = 0;
                    call MoveDown;
                end;
                do; goto ILLEGAL; end;      /* 'J' */
                do;                         /* 'K' KILL */
                    if (w200A := SeekLine) < textPtr then do;
                        w2010 = textptr;
                        textptr = w200A;
                        w200A = w2010;
                    end;
                    call MoveDown;
                end;
                textPtr = SeekLine;         /* 'L' TEXT POINTER LINE*/
                call ShowUnused;            /* 'M' MEMORY */
                do;                         /* 'N' PUNCH NULLS */
                    call DisplayText(.aStartPunch, 25);
                    b2020 = CI;
                    do b2020 = 1 to 120;
                        call PO(0);
                    end;
                    b2020 = CI;
                end;
                do; goto ILLEGAL; end;      /* 'O' */
                do; goto ILLEGAL; end;      /* 'P' */
                do;                         /* 'Q' QUIT */
                    w200A = STACKPTR;
                    w2002 = endPtr - 1;
                    call vecStart0;
                END;
                do; goto ILLEGAL; end;      /* 'R' */
                do;                         /* 'S' SUBSTITUTE */
                    w200A = (textPtr := FindLoc) + findLen;
                    goto CASE$I;
                end;
                do;                         /* 'T' TYPE */
                    if (w2010 := SeekLine) <> textPtr then
                        if textPtr < w2010 then
                        call DisplayText(.MEMORY + textptr, w2010 - textptr - 1);
                    else
                        call DisplayText(.MEMORY + w2010, textptr - w2010 - 1);
                end;
                do; goto ILLEGAL; end;      /* 'U' */
                do; goto ILLEGAL; end;      /* 'V' */
                do;                         /* 'W' WRITE */
                    call DisplayText(.aStartPunch, 25);
                    b2020 = CI;
                    backwards = 0;
                    textptr = 1;
                    w200A = SeekLine;
                    call Write$PO(1, w200A - 1);
                    b2020 = CI;
                    call MoveDown;
                end;
                do; goto ILLEGAL; end;      /* 'X' */
                do; goto ILLEGAL; end;      /* 'Y' */
                textPtr = endPtr;           /* 'Z' TEXT POINTER END */
            end;    /* of case */
        end;
        else
            goto ILLEGAL;
    end;


ILLEGAL:
    if char > ' ' then do;
        call DisplayText(.crlf, 1);
        call Putch$CO(22h);
        call DisplayCh(char);
        call DisplayText(.aIllegal, 26);
        call GetText;
    end;
    goto CMDLOOP;


BREAK:
    call DisplayText(.aBreak, 10);
    call GetText;
    goto CMDLOOP;


end;
eof;
dblank.plm
deblank: do;

    DEBLANK: PROCEDURE(PTR) ADDRESS public;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE (C = ' ');
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;
end;
dlimit.plm
delimit: do;
    DELIMIT: PROCEDURE(PTR) ADDRESS public;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE (C = ':' OR C = '.' OR
                 ('0' <= C AND C <= '9') OR
                 ('A' <= C AND C <= 'Z'));
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;
end;
fupper.plm
forceUpper: do;
declare CR LITERALLY '0dh';
uppercase: procedure(char) byte external; declare char byte; end;

    ForceUpper: procedure(bufferPtr) public;
        declare bufferPtr address, ch based bufferPtr byte;

        do while ch <> CR;
            ch = uppercase(ch);
            bufferPtr = bufferPtr + 1;
        end;
    end;
end;
numout.plm
numout: do;
    NUMOUT: PROCEDURE(VALUE, BASE, LC, BUFADR, WIDTH) public;
        DECLARE (VALUE, BUFADR) ADDRESS, (BASE, LC, WIDTH) BYTE; 
        DECLARE DIGITS(*) byte data('0123456789ABCDEF');
        DECLARE I BYTE;
        DECLARE BUF BASED BUFADR (1) BYTE;

        DO I = 1 TO WIDTH;
            BUF(WIDTH - I) = DIGITS(VALUE MOD BASE);
            VALUE = VALUE / BASE;   
        END;

        I = 0;
        DO WHILE BUF(I) = '0' AND I < WIDTH - 1;
            BUF(I) = LC;
            I = I + 1;
        END;
    END;
end;
seq.plm
seq: do;

    SEQ: PROCEDURE(S1, S2, CNT) BYTE;
        DECLARE (S1,S2) ADDRESS, CNT BYTE;
        DECLARE S1A BASED S1(1) BYTE;
        DECLARE S2A BASED S2(1) BYTE;
        DECLARE I BYTE;
        CNT = CNT - 1;
        DO I = 0 TO CNT;
            IF S1A(I) <> S2A(I) THEN
                RETURN 0;
        END;
        RETURN 0FFH;
    END;
end;
ucase.plm
uppercase: do;
    uppercase: procedure(char) byte public;
        declare char byte;
        if char < 'a' then
            return char;
        if char > 'z' then
            return char;
        return char and 0dfh;
    end;
end;

