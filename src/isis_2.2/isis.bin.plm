3BH: DO;
    DECLARE VER DATA(2,2);

/* COMMON CONTROL CHARACTERS */
DECLARE CONTROL$E LITERALLY '5';
DECLARE BELL LITERALLY '7';
DECLARE BS LITERALLY '8';
DECLARE CR LITERALLY '0DH';
DECLARE LF LITERALLY '0AH';
DECLARE HASH LITERALLY '23H';
DECLARE CARET LITERALLY '5EH';
DECLARE CONTROL$P LITERALLY '10H';
DECLARE CONTROL$Q LITERALLY '11H';
DECLARE CONTROL$R LITERALLY '12H';
DECLARE CONTROL$S LITERALLY '13H';
DECLARE CONTROL$X LITERALLY '18H';
DECLARE CONTROL$Z LITERALLY '1AH';
DECLARE ESC LITERALLY '1BH';
DECLARE DELKEY LITERALLY '7FH';

/* BOOLEAN LITERALS */
DECLARE BOOLEAN LITERALLY 'BYTE';
DECLARE TRUE LITERALLY '0FFH';
DECLARE FALSE LITERALLY '0';

/* CONSOLE LITERALS */
DECLARE AFT$CONSOL$IN LITERALLY '5';
DECLARE AFT$CONSOL$OUT LITERALLY '4';
DECLARE READ$MODE LITERALLY '1';
DECLARE WRITE$MODE LITERALLY '2';
DECLARE UPDATE$MODE LITERALLY '3';

/* SEEK OPTIONS */
DECLARE SEEK$RETURN LITERALLY '0';
DECLARE SEEK$BACKWARD LITERALLY '1';
DECLARE SEEK$ABS LITERALLY '2';
DECLARE SEEK$FORWARD LITERALLY '3';
DECLARE SEEK$EOF LITERALLY '4';

/* ERROR CODES */
DECLARE OK LITERALLY '0';
DECLARE NO$FREE$BUFFER LITERALLY '1';
DECLARE BAD$AFT$NO LITERALLY '2';

DECLARE AFT$FULL LITERALLY '3';
DECLARE BAD$PATH LITERALLY '4';
DECLARE BAD$DEVICE LITERALLY '5';
DECLARE CANT$WRITE LITERALLY '6';
DECLARE DISK$FULL LITERALLY '7';
DECLARE CANT$READ LITERALLY '8';
DECLARE DIRECTORY$FULL LITERALLY '9';
DECLARE DIFFERENT$DISK LITERALLY '10';
DECLARE MULTIDEFINED LITERALLY '11';
DECLARE ALREADY$OPEN LITERALLY '12';
DECLARE NO$SUCH$FILE LITERALLY '13';
DECLARE WRITE$PROTECT LITERALLY '14';
DECLARE ISIS$OVERWRITE LITERALLY '15';
DECLARE BAD$LOAD$FORMAT LITERALLY '16';
DECLARE NON$DISK$FILE LITERALLY '17';
DECLARE BAD$COMMAND LITERALLY '18';
DECLARE NON$DISK$SEEK LITERALLY '19';
DECLARE LONG$BACK$SEEK LITERALLY '20';
DECLARE CANT$RESCAN LITERALLY '21';
DECLARE BAD$ACCESS LITERALLY '22';
DECLARE NULL$FILENAME LITERALLY '23';
DECLARE DISK$IO$ERROR LITERALLY '24';
DECLARE BAD$ECHO LITERALLY '25';
DECLARE BAD$ATTRIB LITERALLY '26';
DECLARE BAD$SEEK$ARG LITERALLY '27';
DECLARE NULL$EXTENSION LITERALLY '28';
DECLARE CONSOLE$EOF LITERALLY '29';
DECLARE DRIVE$NOT$READY LITERALLY '30';
DECLARE SEEK$ON$WRITE LITERALLY '31';
DECLARE CANT$DELETE LITERALLY '32';
DECLARE BAD$PARAMETER LITERALLY '33';
DECLARE BAD$RETSW LITERALLY '34';
DECLARE SEEK$PAST$EOF LITERALLY '35';

DECLARE WARNING LITERALLY '0';
DECLARE MESSAGE LITERALLY '1';
DECLARE ABORT LITERALLY '2';
DECLARE CMSK LITERALLY '0FCH';

/* ATTRIBUTES */
DECLARE INVISIBLE$ATTRIBUTE LITERALLY '1';
DECLARE SYSTEM$ATTRIBUTE LITERALLY '2';
DECLARE WRITEP$ATTRIBUTE LITERALLY '4';
DECLARE FORMAT$ATTRIBUTE LITERALLY '80H';

/* ACCESS MODE */
DECLARE ACCESS$READ LITERALLY '1';
DECLARE ACCESS$WRITE LITERALLY '2';

/* OMF RECORD TYPES */
DECLARE R$MODHDR LITERALLY '2';
DECLARE R$MODEND LITERALLY '4';
DECLARE R$CONTENT LITERALLY '6';
DECLARE R$RELOC LITERALLY '22H';

DECLARE AFT$BOTTOM LITERALLY '4';
DECLARE AFT$FIRST LITERALLY   '6';
DECLARE AFT$LAST LITERALLY '11';
DECLARE F3DEV LITERALLY '3';
DECLARE CIDEV LITERALLY '21';
DECLARE CODEV LITERALLY '22';
DECLARE BBDEV LITERALLY '20';

DECLARE BLINK LITERALLY '0';
DECLARE FLINK LITERALLY '1';

DECLARE CMD$RECAL LITERALLY '3';
DECLARE CMD$READ LITERALLY '4';
DECLARE CMD$WRITE LITERALLY '6';

DECLARE MDSMON LITERALLY '0';
DECLARE BTSTRP LITERALLY '8';

ISIS: PROCEDURE(COMMAND, PARAMETER$BLOCK);
    DECLARE COMMAND BYTE, PARAMETER$BLOCK ADDRESS;
    DECLARE PARAM BASED PARAMETER$BLOCK (5) ADDRESS;
    DECLARE COPYRIGHT DATA('(C) 1975,1976 INTEL CORP');
    DECLARE I BYTE;
    DECLARE SYSPARAM(0) ADDRESS;
    DECLARE USERSTATUS$P ADDRESS, USERSTATUS BASED USERSTATUS$P ADDRESS;
    DECLARE (PARAM1, PARAM2, PARAM3, PARAM4, PARAM5) ADDRESS;
    DECLARE RETPARAMIDX(14) BYTE INITIAL( 5, 2, 2, 5, 4, 5, 5, 3,
                                         3, 1, 4, 2, 2, 3);
    DECLARE PARAMTYPE(5) ADDRESS INITIAL(
                111110001010B,    /* BIT SET IF PARAMETER NEEDS TO CHECK FOR */
                111001100111110B,    /* ADDRESS BELOW MEMORY (3000H) */
                100001101000000B,
                100001110000B,
                11010010B);

    DECLARE COLD$START$FLAG BOOLEAN INITIAL (TRUE);
    DECLARE (COLD$CIDEV, ALT$CIDEV) BYTE;
    DECLARE USERSP ADDRESS;
    DECLARE USRSTK(32) BYTE INITIAL(0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,
                                    0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,
                                    0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,
                                    0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,0C7H);
    DECLARE TOPSTACK(0) BYTE;

    CI: PROCEDURE BYTE;
        GOTO 0F803H;
    END;

    RI: PROCEDURE BYTE;
        GOTO 0F806H;
    END;

    CO: PROCEDURE(CH);
        DECLARE CH BYTE;
        GOTO 0F809H;
    END;

    PO: PROCEDURE(CH);
        DECLARE CH BYTE;
        GOTO 0F80CH;
    END;

    LO: PROCEDURE(CH);
        DECLARE CH BYTE;
        GOTO 0F80FH;
    END;

    IOCHK: PROCEDURE BYTE;
        GOTO 0F815H;
    END;

    IOSET: PROCEDURE(CH);
        DECLARE CH BYTE;
        GOTO 0F818H;
    END;


    CSTS: PROCEDURE BYTE;
        GOTO 0F812H;
    END;

    MEMCK: PROCEDURE ADDRESS;
        GOTO 0F81BH;
    END;

    BINASC: PROCEDURE(VALUE, BASE, LC, BUFADR, WIDTH);
        DECLARE (VALUE, BUFADR) ADDRESS, (BASE, LC, WIDTH) BYTE;
        DECLARE DIGITS DATA('0123456789ABCDEF');
        DECLARE I BYTE;
        DECLARE BUF BASED BUFADR (1) BYTE;

        DO I = 1 TO WIDTH;
            BUF(WIDTH - I) = DIGITS(VALUE MOD BASE);
            VALUE = VALUE / BASE;
        END;

        I = 0;
        DO WHILE BUF(I) = '0' AND I < WIDTH - 1;
            BUF(I) = LC;
            I = I + 1;
        END;
    END;

    DECLARE STATUS ADDRESS;
    DECLARE DEBUG$TOGGLE BYTE INITIAL(0);
    DECLARE GLOBAL$SEVERITY BYTE INITIAL(0);
    DECLARE FDCC$ERROR$TYPE ADDRESS INITIAL(0);
    DECLARE INITIO$BASE ADDRESS INITIAL(6), INITIO BASED INITIO$BASE BYTE;

    ERR: PROCEDURE(SEVERITY, ERROR$TYPE);
        DECLARE (SEVERITY, ERROR$TYPE, I, IMAX) BYTE;
        DECLARE PC BASED USER$SP ADDRESS;
        DECLARE MSG1(8) BYTE INITIAL(CR, LF, 'ERROR '),
                MSG2(3) BYTE INITIAL(0, 0, 0), /* ERROR NUMBER GOES HERE */
                MSG3(9) BYTE INITIAL(' USER PC '),
                MSG4(4) BYTE INITIAL(0,0,0,0), /* USER PC IN HEX GOES HERE */
                MSG5(2) BYTE INITIAL(CR, LF),
                MSG6(5) BYTE INITIAL('FDCC='),
                MSG7(4) BYTE INITIAL(0,0,0,0), /* FDCC ERROR DATA GOES HERE */
                MSG8(2) BYTE INITIAL(CR, LF);

        IF (SEVERITY := SEVERITY OR GLOBAL$SEVERITY) <> WARNING THEN
        DO;
            CALL BINASC(ERROR$TYPE, 10, 0, .MSG2, 3);
            CALL BINASC(PC,16,'0',.MSG4,4);
            CALL IOSET((IOCHK AND CMSK) OR (INITIO AND 3));
            IMAX = 25;  /* NUMBER OF CHARACTERS IN NORMAL ERROR MESSAGE */
            IF ERROR$TYPE = DISK$IO$ERROR THEN
            DO;
                IMAX = 36;
                CALL BINASC(FDCC$ERROR$TYPE, 16, '0', .MSG7, 4);
            END;
            DO I = 0 TO IMAX;
                CALL CO(MSG1(I));
            END;
        END;
        ELSE
        DO;
            USER$STATUS = ERROR$TYPE;
            STACKPTR = USER$SP;
        END;
        IF SEVERITY >= ABORT THEN
        DO;
            IF DEBUG$TOGGLE THEN
                GOTO MDSMON;    /* EXIT VIA MONITOR */
            GOTO BTSTRP;        /* EXIT VIA SOFTWARE BOOTSTRAP */
        END;
    END;

    DECLARE BUFFER$TABLE(19) BYTE INITIAL(0,0,0,0,0,0,0,0,0,0,
                             0,0,0,0,0,0,0,0,0);

    CLRBUF: PROCEDURE(BUFFER$P);
        DECLARE BUFFER$P ADDRESS;
        DECLARE BUFFER BASED BUFFER$P (128) BYTE;
        DECLARE I BYTE;

        DO I = 0 TO 127;
            BUFFER(I) = 0;
        END;
    END;


    FREEBUF: PROCEDURE(BUFFER);
        DECLARE BUFFER ADDRESS;

        BUFFER$TABLE(SHR(BUFFER - .MEMORY, 7)) = 0;
    END;

    GETBUF: PROCEDURE ADDRESS;
        DECLARE I BYTE;

        DO I = 0 TO LAST(BUFFER$TABLE);
            IF BUFFER$TABLE(I) = 0 THEN
            DO;
                BUFFER$TABLE(I) = 2;
                RETURN .MEMORY + SHL(DOUBLE(I), 7);
            END;
        END;
        CALL ERR(ABORT, NO$FREE$BUFFER);
    END;

    /* THE AFT TABLES AND POINTERS TO CURRENTLY SELECTED ENTRY */
    DECLARE AFT$CURRENT BYTE INITIAL(0FFH);
    DECLARE POINTER$BASE ADDRESS, LINKS BASED POINTER$BASE (64) ADDRESS;
    DECLARE DATUM$BASE ADDRESS, DATUM BASED DATUM$BASE (128) BYTE;
    DECLARE CLOSED$P ADDRESS, CUR$CLOSED BASED CLOSED$P BYTE;
    DECLARE DEVICE$P ADDRESS, CUR$DEVICE BASED DEVICE$P BYTE;
    DECLARE ACCESS$P ADDRESS, CUR$ACCESS BASED ACCESS$P BYTE;
    DECLARE ECHOAFT$P ADDRESS, CUR$ECHOAFT BASED ECHOAFT$P BYTE;
    DECLARE EBUF$P ADDRESS, CUR$EBUF BASED EBUF$P ADDRESS;
    DECLARE DBUF$P ADDRESS, CUR$DBUF BASED DBUF$P ADDRESS;
    DECLARE BYTENO$P ADDRESS, CUR$BYTENO BASED BYTENO$P BYTE;
    DECLARE DNUM$P ADDRESS, CUR$DNUM BASED DNUM$P ADDRESS;
    DECLARE LBUF$P ADDRESS, CUR$LBUF BASED LBUF$P ADDRESS;
    DECLARE DPTR$P ADDRESS, CUR$DPTR BASED DPTR$P BYTE;
    DECLARE LASTBYTE$P ADDRESS, CUR$LASTBYTE BASED LASTBYTE$P BYTE;
    DECLARE ALLOC$P ADDRESS, CUR$ALLOC BASED ALLOC$P BYTE;
    DECLARE DMOD$P ADDRESS, CUR$DMOD BASED DMOD$P BYTE;
    DECLARE BLKCNT$P ADDRESS, CUR$BLKCNT BASED BLKCNT$P ADDRESS;
    DECLARE BLKNO$P ADDRESS, CUR$BLKNO BASED BLKNO$P ADDRESS;
    DECLARE LADDR$P ADDRESS, CUR$LADDR BASED LADDR$P ADDRESS;
    DECLARE L1ADDR$P ADDRESS, CUR$L1ADDR BASED L1ADDR$P ADDRESS;
    DECLARE DADDR$P ADDRESS, CUR$DADDR BASED DADDR$P ADDRESS;


    DECLARE CLOSED(12) BYTE INITIAL(0, 0, 0, 0, 0FFH, 0FFH, 0FFH, 0FFH,
                                    0FFH, 0FFH, 0FFH, 0FFH);
    DECLARE DEVICE(12) BYTE INITIAL(0, 1, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0);
    DECLARE ACCESS(12) BYTE INITIAL(3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0);
    DECLARE ECHOAFT(12) BYTE INITIAL(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    DECLARE EBUF(12) ADDRESS;
    DECLARE DBUF(12) ADDRESS;
    DECLARE BYTENO(12) BYTE INITIAL(128, 128, 128, 128, 0, 0, 0, 0, 0, 0, 0, 0);
    DECLARE DNUM(12) ADDRESS INITIAL(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    DECLARE LBUF(12) ADDRESS INITIAL(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    DECLARE DPTR(12) BYTE INITIAL(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    DECLARE LASTBYTE(12) BYTE INITIAL(128, 128, 128, 128, 0, 0, 0,
                                      0, 0, 0, 0, 0);
    DECLARE ALLOC(12) BYTE INITIAL(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    DECLARE DMOD(12) BYTE INITIAL(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    DECLARE BLKCNT(12) ADDRESS INITIAL(25, 25, 25, 25, 0, 0, 0, 0, 0, 0, 0, 0);
    DECLARE BLKNO(12) ADDRESS INITIAL(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    DECLARE LADDR(12) ADDRESS INITIAL(101H, 101H, 101H, 101H, 0, 0,
                                      0, 0, 0, 0, 0, 0);
    DECLARE L1ADDR(12) ADDRESS INITIAL(101H, 101H, 101H, 101H, 0, 0,
                                       0, 0, 0, 0, 0, 0);
    DECLARE DADDR(12) ADDRESS INITIAL(102H, 102H, 102H, 102H, 0, 0, 0,
                                      0, 0, 0, 0, 0);


    SETTABS: PROCEDURE(AFT);
        DECLARE AFT BYTE;

        IF AFT$CURRENT <> AFT THEN
        DO;
            AFT$CURRENT = AFT;
            CLOSED$P = .CLOSED(AFT);
            DEVICE$P = .DEVICE(AFT);
            ACCESS$P = .ACCESS(AFT);
            ECHOAFT$P = .ECHOAFT(AFT);
            EBUF$P = .EBUF(AFT);
            BYTENO$P = .BYTENO(AFT);
            DNUM$P = .DNUM(AFT);
            DPTR$P = .DPTR(AFT);
            LASTBYTE$P = .LASTBYTE(AFT);
            BLKNO$P = .BLKNO(AFT);
            ALLOC$P = .ALLOC(AFT);
            DMOD$P = .DMOD(AFT);
            BLKCNT$P = .BLKCNT(AFT);
            LADDR$P = .LADDR(AFT);
            L1ADDR$P = .L1ADDR(AFT);
            DADDR$P = .DADDR(AFT);
        END;
        LBUF$P = .LBUF(AFT);
        DBUF$P = .DBUF(AFT);
        POINTER$BASE = CUR$LBUF;
        DATUM$BASE = CUR$DBUF;
    END;

    GETAFT: PROCEDURE BYTE;
        DECLARE I BYTE;

        DO I = AFT$BOTTOM TO AFT$LAST;
            IF CLOSED(I) THEN
                RETURN I;
        END;
        CALL ERR(ABORT, AFT$FULL);
    END;

    PACKBUFS: PROCEDURE ADDRESS;
        DECLARE I BYTE, BUFFER$TOP ADDRESS;

        LOWBUF: PROCEDURE(BUFPTR);
            DECLARE BUFPTR ADDRESS;
            DECLARE (NEWBUF, OLDBUF) ADDRESS, I BYTE;
            DECLARE BUFFER BASED BUFPTR ADDRESS,
                    NBUF BASED NEWBUF (128) BYTE,
                    OBUF BASED OLDBUF (128) BYTE;

            I = SHR(BUFFER - .MEMORY, 7);
            IF BUFFER$TABLE(I) <> 2 THEN
                RETURN;
            OLDBUF = BUFFER;
            CALL FREEBUF(OLDBUF);
            NEWBUF = GETBUF;
            IF BUFFER$TOP < NEWBUF THEN
                BUFFER$TOP = NEWBUF;
            IF NEWBUF = OLDBUF THEN
                RETURN;
            DO I = 0 TO 127;
                NBUF(I) = OBUF(I);
            END;
            BUFFER = NEWBUF;
        END;

        BUFFER$TOP = .MEMORY;
        DO I = AFT$BOTTOM TO AFT$LAST;
            CALL LOWBUF(.LBUF(I));
            CALL LOWBUF(.DBUF(I));
            CALL LOWBUF(.EBUF(I));
        END;
        RETURN BUFFER$TOP + 128;
    END;

    /*
       XEQIOPB PROVIDES ACCESS TO THE FDCC
       CONTROLLER 1 = BASE ADDRESS 78H (DRIVES 0, 1 FOR SD)
       CONTROLLER 2 = BASE ADDRESS 88H (DRIVES 2, 3 FOR SD)

       DRIVE: AN INTEGER 0-3, SPECIFYING THE DISK TO BE ACCESSED
       IOPB:  THE ADDRESS OF A PARAMETER BLOCK TO BE SENT TO THE
          FDCC CONTROLLER. THIS PARAMETER MUST BE SET UP
          AS IF IT WERE FOR DRIVE 0; IF 'DRIVE' SELECTS
          ANOTHER DRIVE, 'DISKIO' WILL SET ALL THE NECESSARY
          BITS

       THE CALLER PROVIDES A PARAMETER BLOCK SPECIFYING SOME
       VALID DISK OPERATION ON DRIVE 0 AND AN INTEGER DRIVE SELECT VALUE
       IN THIS BOOT CODE ONLY READ AND RECAL ARE USED
       THE PROCEDURE WAITS FOR THE CONTROLLER TO GO UNBUSY, THEN
       PERFORMS THE DESIRED ACTION. IN CASE OF A CONTROLLER ERROR,
       THE DISK DRIVE IS RECALIBRATED AND THE ACTION IS TRIED AGAIN.
       IF SUCCESSFUL COMPLETION CANNOT BE OBTAINED AFTER 'MAX$RETRIES'
       ATTEMPTS, A FATAL ERROR OCCURS, OTHERWISE A NORMAL RETURN IS MADE

    */
        DECLARE FDCC$STATUS$0   LITERALLY   '78H',
                FDCC$STATUS$1   LITERALLY   '88H',
                RESULT$TYPE$0   LITERALLY   '79H',
                RESULT$TYPE$1   LITERALLY   '89H',
                RESULT$BYTE$0   LITERALLY   '7BH',
                RESULT$BYTE$1   LITERALLY   '8BH',
                LOW$ADDRESS$0   LITERALLY   '79H',
                LOW$ADDRESS$1   LITERALLY   '89H',
                HIGH$ADDRESS$0  LITERALLY   '7AH',
                HIGH$ADDRESS$1  LITERALLY   '8AH';

        DECLARE MAX$RETRIES     LITERALLY   '10',
                DISK$DONE       LITERALLY   '4',
                READ$COMMAND    LITERALLY   '4',
                WRITE$COMMAND   LITERALLY   '6',
                RECALIBRATE     LITERALLY   '3';

        DECLARE IOCW    LITERALLY '0',      /* IOPB OFFSETS */
                IOINS   LITERALLY '1',
                NSEC    LITERALLY '2',
                TADR    LITERALLY '3',
                SADR    LITERALLY '4',
                BUFLO   LITERALLY '5',
                BUFHI   LITERALLY '6';


    XEQIOPB: PROCEDURE(DRIVE, IOPB);
        /* THIS PROCEDURE ISSUES THE IOPB TO THE DISK CONTROLLER, IN THE */
        /* CASE OF THE 8271 IT ALSO TRANSFERS THE DATA BYTE BY BYTE */
        DECLARE DRIVE BYTE; /* DRIVE NUMBER: ASSUMES VALUE 0,1,2,3 */
        DECLARE IOPB ADDRESS;   /* POINTER TO THE PARAMATER BLOCK NAMED DCB */
        DECLARE DCB BASED IOPB (7) BYTE;

        DECLARE TEMPA(0) ADDRESS;
        DECLARE (TEMP2, TEMP1, JNK) BYTE;

        /* RECALIBRATE COMMAND */
        DECLARE RECAL$PB(5) BYTE INITIAL(80H, RECALIBRATE, 0, 0, 0);

        DECLARE I BYTE;     /* INDEX VARIABLE IN FOR STATEMENTS */
        DECLARE IVAL BYTE;  /* INTERRUPT MASK VALUE */

        DISK$STAT: PROCEDURE BYTE; /* RETURN THE DISK DRIVE STATUS */
            IF ROR(DRIVE, 1) THEN    /* DRIVE 1 */
                RETURN INPUT(FDCC$STATUS$1);
            RETURN INPUT(FDCC$STATUS$0);
        END;


        R$TYPE: PROCEDURE BYTE; /* RETURN THE RESULT TYPE OF A DISK OPERATION */
            IF ROR(DRIVE, 1) THEN
                RETURN INPUT(RESULT$TYPE$1);
            RETURN INPUT(RESULT$TYPE$0);
        END;


        R$BYTE: PROCEDURE BYTE; /* RETURN THE REULT BYTE OF A DISK OPERATION */
            IF ROR(DRIVE, 1) THEN
                RETURN INPUT(RESULT$BYTE$1);
            RETURN INPUT(RESULT$BYTE$0);
        END;

        /*
           START$IO OUTPUTS THE ADDRESS OF THE IOPB TO THE DISK CONTROLLER
        */
        START$IO: PROCEDURE(IOPB);
            DECLARE IOPB ADDRESS;

            IF ROR(DRIVE, 1) THEN
            DO;
                OUTPUT(LOW$ADDRESS$1) = LOW(IOPB);
                OUTPUT(HIGH$ADDRESS$1) = HIGH(IOPB);
            END;
            ELSE
            DO;
                OUTPUT(LOW$ADDRESS$0) = LOW(IOPB);
                OUTPUT(HIGH$ADDRESS$0) = HIGH(IOPB);
            END;
        END;


        IVAL = INPUT(0FCH);
        OUTPUT(0FCH) = IVAL OR 2; /* PREVENT  REENTRANCY */

        RECAL$PB(IOINS) = RECALIBRATE;
        RECAL$PB(SADR) = 0;
        IF DRIVE THEN
        DO;
            DCB(IOINS) = DCB(IOINS) OR 30H;
            DCB(SADR) = DCB(SADR) OR 20H;
            RECAL$PB(IOINS) = RECALIBRATE OR 30H;
            RECAL$PB(SADR) = 20H;
        END;

        DO I = 0 TO MAX$RETRIES;

            DO WHILE (DISK$STAT AND DISK$DONE) <> 0;
                TEMP1 = R$TYPE;
                TEMP1 = R$BYTE;
            END;
            /* IF DISK DRIVE NOT READY, GIVE FATAL ERROR */
            IF (DISK$STAT AND ((DRIVE AND 1) + 1)) = 0 THEN
                CALL ERR(ABORT, DRIVE$NOT$READY);

            CALL START$IO(IOPB);
            DO WHILE (DISK$STAT AND DISK$DONE) = 0;
                ;
            END;
            TEMP1 = R$TYPE;
            IF (TEMP2 := R$BYTE) = 0 THEN
            DO;
                OUTPUT(0FCH) = IVAL;    /* RESTORE INTERRUPT 1 */
                RETURN;
            END;
            CALL START$IO(.RECAL$PB);
            DO WHILE (DISK$STAT AND DISK$DONE) = 0;
                ;
            END;
        END;
        FDCC$ERROR$TYPE = TEMPA;
        CALL ERR(ABORT, DISK$IO$ERROR);
    END;


    XIO: PROCEDURE(OPCODE, DRIVE, TRKSEC, BUFFER);
        DECLARE (OPCODE, DRIVE) BYTE, (TRKSEC, BUFFER) ADDRESS;
        DECLARE DCB(10) BYTE INITIAL(80H, 0, 0, 0, 0, 0, 0, 0, 0, 0);

        DCB(IOINS) = OPCODE;
        DCB(NSEC) = 1;
        DCB(TADR) = HIGH(TRKSEC);
        DCB(SADR) = LOW(TRKSEC);
        DCB(BUFLO) = LOW(BUFFER);
        DCB(BUFHI) = HIGH(BUFFER);
        CALL XEQIOPB(DRIVE, .DCB);
    END;

    RDSEC: PROCEDURE(TRKSEC, BUFFER);
         DECLARE (TRKSEC, BUFFER) ADDRESS;
         CALL XIO(CMD$READ, CUR$DEVICE, TRKSEC, BUFFER);
    END;

    WRSEC: PROCEDURE(TRKSEC, BUFFER);
        DECLARE (TRKSEC, BUFFER) ADDRESS;
        CALL XIO(CMD$WRITE, CUR$DEVICE, TRKSEC, BUFFER);
    END;

    DECLARE (PN, PN2) (10) BYTE;

    DECLARE DEVICENAMES DATA('F0F1F2F3TITOVIVOI1O1TRHRR1R2TPHPP1P2LPL1BBCICO');
    DECLARE FULLNAME(15) BYTE;

    TOUPPER: PROCEDURE(CH) BYTE;
        DECLARE CH BYTE;
        IF CH < 61H THEN    /* LOWER CASE A */
            RETURN CH;
        IF CH > 7AH THEN    /* LOWER CASE Z */
            RETURN CH;
        RETURN CH AND 0DFH;
    END;

    CANON: PROCEDURE(FILENAME, INTFN$P) BYTE;
        DECLARE (FILENAME, INTFN$P) ADDRESS;
        DECLARE PATHCH BASED FILENAME BYTE; /* CHAR OF FILENAME POINTS TO */
        DECLARE PATHCHARS BASED FILENAME (1) BYTE;
        DECLARE INTFN BASED INTFN$P (10) BYTE;  /* BYTE VERSION OF INTFN  */
        DECLARE STARTNAME ADDRESS, STARTCH BASED STARTNAME BYTE;
        DECLARE DEVPAIR(0) ADDRESS, (FIRST, SECOND) BYTE;
        DECLARE DEVPTR ADDRESS, DEVNAME BASED DEVPTR ADDRESS;
        DECLARE NULL$NAME BYTE;
        DECLARE (J, I) BYTE;


        ALPHANUM: PROCEDURE BOOLEAN;
            RETURN (PATHCH >= 'A' AND PATHCH <= 'Z')
                OR (PATHCH >= '0' AND PATHCH <= '9')
                OR (PATHCH >= 61H AND PATHCH <= 7AH);   /* LOWER CASE A-Z */
        END;

        DEVPTR = .DEVICENAMES;

        DO I = 0 TO LAST(INTFN);    /* CLEAR INTFN */
            INTFN(I) = 0;
        END;
        DO WHILE PATHCH = ' ';  /* SKIP LEADING SPACE */
            FILENAME = FILENAME + 1;
        END;
        STARTNAME = FILENAME;
        IF PATHCH = ':' THEN
        DO;
            INTFN(0) = 0FFH;
            IF PATHCHARS(3) <> ':' THEN
                RETURN BAD$PATH;
            FILENAME = FILENAME + 1;    /* PAST ':' */
            FIRST = TOUPPER(PATHCH);
            FILENAME = FILENAME + 1;
            SECOND = TOUPPER(PATHCH);
            FILENAME = FILENAME + 2;

            I =  0;
            DO WHILE I < 45; /* SIZE(DEVICENAMES) */
                IF DEVNAME = DEVPAIR THEN
                    INTFN(0) = SHR(I, 1);   /* SAVE DEVICE NUMBER */
                I = I + 2;
                DEVPTR = DEVPTR + 2;
            END;
            IF INTFN(0) = 0FFH THEN
                RETURN BAD$DEVICE;
        END;

        NULL$NAME = TRUE;
        I = 1;
        DO WHILE I < 7;
            IF ALPHANUM THEN
            DO;
                INTFN(I) = TOUPPER(PATHCH);
                FILENAME = FILENAME + 1;
                NULL$NAME = FALSE;
            END;
            I = I + 1;
        END;
        IF PATHCH = '.' THEN
        DO;
            FILENAME = FILENAME + 1;
            I = 7;
            DO WHILE I < 10;
                IF ALPHANUM THEN
                DO;
                    INTFN(I) = TOUPPER(PATHCH);
                    FILENAME = FILENAME + 1;
                END;
                I = I + 1;
            END;
        END;
        IF INTFN(0) <= F3DEV AND NULL$NAME THEN
            RETURN NULL$FILENAME;
        J =  -1;
        DO WHILE STARTNAME < FILENAME;
            J = J + 1;
            FULLNAME(J) = STARTCH;
            STARTNAME = STARTNAME + 1;
        END;
        IF FULLNAME(J) = '.' THEN
            RETURN NULL$EXTENSION;
        FULLNAME(J + 1) = ' ';
        IF ALPHANUM  OR PATHCH = '.' OR PATHCH = ':' THEN
            RETURN BAD$PATH;
        RETURN OK;
    END;

    GETFN: PROCEDURE(FILENAME, INTFN$P);
        DECLARE (FILENAME, INTFN$P) ADDRESS;

        IF (STATUS := CANON(FILENAME, INTFN$P)) <> 0 THEN
            CALL ERR(WARNING, STATUS);
    END;


    DECLARE BITMAPBUFFER(256) BYTE,
        CURRENT$BITMAP BYTE INITIAL(0FFH),
        MAP$CHANGE BYTE INITIAL(FALSE),
        BASETRKSEC(0) ADDRESS, (BASESECTOR, BASETRACK) BYTE,
        BITMAPINDEX ADDRESS,
        MAP$DCB(10) BYTE INITIAL(80H, 0, 2, 2, 2, 0, 0, 0, 0, 0),
        BITMASK(8) BYTE INITIAL(80H, 40H, 20H, 10H, 8, 4, 2, 1);

    RWMAP: PROCEDURE(DRIVE, OPCD);
        DECLARE (DRIVE, OPCD) BYTE;
        DECLARE TMP BYTE;

        OPMAP: PROCEDURE;
            MAP$CHANGE = FALSE;
            BITMAPINDEX = 0;
            BASETRKSEC = 1;
            MAP$DCB(IOINS) = OPCD;
            MAP$DCB(BUFLO) = LOW(.BITMAPBUFFER);
            MAP$DCB(BUFHI) = HIGH(.BITMAPBUFFER);
            CALL XEQIOPB(DRIVE, .MAP$DCB);

        END;

        IF DRIVE <> CURRENT$BITMAP THEN
        DO;
            IF OPCD = CMD$WRITE THEN
                RETURN;
            IF CURRENT$BITMAP <> 0FFH AND MAP$CHANGE THEN
            DO;
                OPCD = CMD$WRITE;
                TMP = DRIVE;
                DRIVE = CURRENT$BITMAP;
                CALL OPMAP;
                OPCD = CMD$READ;
                DRIVE = TMP;
            END;
            CURRENT$BITMAP = DRIVE;
            CALL OPMAP;
        END;
        ELSE IF OPCD = CMD$WRITE THEN
            CALL OPMAP;
    END;


    ALLOCATE: PROCEDURE(DRIVE) ADDRESS;
        DECLARE DRIVE BYTE;
        DECLARE BITNO BYTE;
        DECLARE TRKSEC(0) ADDRESS, (SECTOR, TRACK) BYTE;
        DECLARE BITMAPBYTE$P ADDRESS, BITMAPBYTE BASED BITMAPBYTE$P BYTE;

        CALL RWMAP(DRIVE, CMD$READ);

        DO TRACK = BASETRACK TO 76;
            DO SECTOR = BASESECTOR TO 26;
                BITNO = LOW(BITMAPINDEX) AND 7;
                BITMAPBYTE$P = .BITMAPBUFFER + SHR(BITMAPINDEX, 3);
                IF (BITMASK(BITNO) AND BITMAPBYTE) = 0 THEN /* FOUND A SLOT */
                    DO;
                        MAP$CHANGE = TRUE;
                        BITMAPBYTE = BITMAPBYTE OR BITMASK(BITNO);
                        BASETRKSEC = TRKSEC;
                        RETURN TRKSEC;
                    END;
                BITMAPINDEX = BITMAPINDEX + 1;
            END;
            BASESECTOR = 1;
        END;
        CALL ERR(ABORT, DISK$FULL);
    END;

    DEALLOC: PROCEDURE(DRIVE, TRKSEC);
        DECLARE DRIVE BYTE, TRKSEC ADDRESS;
        DECLARE BITMAPBYTE$P ADDRESS, BITMAPBYTE BASED BITMAPBYTE$P BYTE;
        DECLARE BITNO BYTE;

        CALL RWMAP(DRIVE, CMD$READ);
        IF (BITMAPBYTE$P := HIGH(TRKSEC) * 26 + LOW(TRKSEC) - 1) <
                                                        BITMAPINDEX THEN
        DO;
            BITMAPINDEX = BITMAPBYTE$P;
            BASETRKSEC = TRKSEC;
        END;
        BITNO = LOW(BITMAPBYTE$P) AND 7;
        BITMAPBYTE$P = .BITMAPBUFFER + SHR(BITMAPBYTE$P, 3);
        BITMAPBYTE = BITMAPBYTE AND NOT BITMASK(BITNO);
        MAP$CHANGE = TRUE;
    END;


    DECLARE MAXLL   LITERALLY   '122';  /* MAXIMUM LINE LENGTH */

    DECLARE IOBYTEMASKS DATA(0FFH, 0FFH, 0FFH, 0FFH, 0FCH, 0FCH, 0FCH, 0FCH,
                     0FCH, 0FCH, 0F3H, 0F3H, 0F3H, 0F3H, 0CFH, 0CFH, 0CFH, 0CFH,
                     3FH, 3FH, 0FFH, 0FFH, 0FFH);

    DECLARE IOBYTEFLAGS DATA(0, 0, 0, 0, 0, 0, 1, 1,
                     3, 3, 0, 4, 8, 0CH, 0, 10H, 20H,
                     30H, 80H, 0C0H, 0, 0, 0);

    SIZECK: PROCEDURE;
        IF CUR$BLKNO = CUR$BLKCNT AND CUR$LASTBYTE < CUR$BYTENO THEN
            CUR$LASTBYTE = CUR$BYTENO;
        IF CUR$BLKNO > CUR$BLKCNT THEN
        DO;
            CUR$BLKCNT = CUR$BLKNO;
            CUR$LASTBYTE = CUR$BYTENO;
        END;
    END;


    FIO: PROCEDURE(AFTN, BUFFER, COUNT, ACTUAL$P, READFLAG);
        DECLARE AFTN BYTE, (BUFFER, COUNT, ACTUAL$P) ADDRESS, READFLAG BYTE;
        DECLARE ACTUAL BASED ACTUAL$P ADDRESS;
        DECLARE NEEDWRITE BYTE, (WORK$BUF, NEWLINKS$P) ADDRESS;
        DECLARE NEWLINKS BASED NEWLINKS$P (64) ADDRESS;
        DECLARE BUFCH BASED BUFFER BYTE;

        GETD: PROCEDURE;
            IF CUR$DADDR <> 0 THEN
                RETURN;

            CUR$ALLOC = TRUE;

            CUR$BLKNO = CUR$BLKNO - 1;
            LINKS(CUR$DPTR), CUR$DADDR = ALLOCATE(CUR$DEVICE);
            CUR$BLKNO = CUR$BLKNO + 1;

            IF CUR$ACCESS = 3 THEN
            DO;
                CALL CLRBUF(CUR$DBUF);
                CALL WRSEC(CUR$DADDR, CUR$DBUF);
            END;
        END;


        ACTUAL = 0;

        DO WHILE COUNT > ACTUAL;
            IF CUR$BLKCNT <= CUR$BLKNO AND READFLAG
              AND CUR$BYTENO = CUR$LASTBYTE THEN
                RETURN;
            IF CUR$BYTENO = 128 THEN
            DO;
                CUR$BYTENO = 0;
                IF CUR$DMOD THEN
                DO;
                    CALL WRSEC(CUR$DADDR, CUR$DBUF);
                    CUR$DMOD = FALSE;
                END;
                IF (CUR$DPTR := CUR$DPTR + 1) = 64 THEN
                DO;
                    IF LINKS(FLINK) = 0 THEN
                    DO;
                        LINKS(FLINK) = ALLOCATE(CUR$DEVICE);
                        CUR$ALLOC = TRUE;
                        CALL CLRBUF(CUR$DBUF);
                        NEWLINKS$P = CUR$DBUF;
                        NEWLINKS(0) = CUR$LADDR;    /* SAVE FORWARD LINK */
                        CALL RWMAP(CUR$DEVICE, CMD$WRITE);
                        CALL WRSEC(LINKS(FLINK), CUR$DBUF);
                    END;

                    IF CUR$ALLOC THEN
                    DO;
                        CALL RWMAP(CUR$DEVICE, CMD$WRITE);
                        CALL WRSEC(CUR$LADDR, CUR$LBUF);
                        CUR$ALLOC = FALSE;
                    END;
                    CUR$LADDR = LINKS(FLINK);
                    CALL RDSEC(CUR$LADDR, CUR$LBUF);
                    CUR$DPTR = 2;
                END;

                CUR$BLKNO = CUR$BLKNO + 1;
                CUR$DADDR = LINKS(CUR$DPTR);

                IF (NEEDWRITE := COUNT - ACTUAL >= 128 AND
                   (NOT READFLAG OR CUR$BLKNO < CUR$BLKCNT)) THEN
                DO;
                    ACTUAL = ACTUAL + (CUR$BYTENO := 128);
                    WORK$BUF = BUFFER;
                    BUFFER = BUFFER + 128;
                END;
                ELSE
                    WORK$BUF = CUR$DBUF;

                IF READFLAG THEN
                DO;
                    IF CUR$DADDR = 0 THEN
                        CALL CLRBUF(WORK$BUF);
                    ELSE
                        CALL RDSEC(CUR$DADDR, WORK$BUF);
                END;
                ELSE
                DO;
                    CALL GETD;
                    IF NEEDWRITE THEN
                        CALL WRSEC(CUR$DADDR, WORK$BUF);
                    ELSE IF CUR$ACCESS = UPDATE$MODE THEN
                        CALL RDSEC(CUR$DADDR, WORK$BUF);
                END;
            END;

            IF CUR$BYTENO <> 128 THEN
            DO;
                IF READFLAG THEN
                    BUFCH = DATUM(CUR$BYTENO);
                ELSE
                DO;
                    CALL GETD;
                    DATUM(CUR$BYTENO) = BUFCH;
                    CUR$DMOD = TRUE;
                END;
                CUR$BYTENO = CUR$BYTENO + 1;
                BUFFER = BUFFER + 1;
                ACTUAL = ACTUAL + 1;
            END;
        END; /* OF DO WHILE */
        CALL SIZECK;
    END;


    SETDEV: PROCEDURE;
        /*
           SET LOGICAL FILE ASSIGNMENTS TO USE MONITOR ROUTINES
           FOR DOING BYTE AT A TIME I/O DEVICES
        */
        CALL IOSET((IOCHK AND IOBYTEMASKS(CUR$DEVICE))
                    OR IOBYTEFLAGS(CUR$DEVICE));
    END;


    READ: PROCEDURE(AFT, BUFFER, COUNT, ACTUAL$P) ;
        DECLARE AFT BYTE, (BUFFER, COUNT, ACTUAL$P) ADDRESS;
        DECLARE ACTUAL BASED ACTUAL$P ADDRESS;
        DECLARE CH BASED BUFFER BYTE;
        DECLARE READCASE(20) BYTE INITIAL(0, 0, 0, 0, 1, 0FFH, 1, 0FFH, 1,
                          0FFH, 2, 2, 2, 2, 0FFH, 0FFH, 0FFH, 0FFH, 0FFH, 0FFH);

        ACTUAL = 0;
        CALL SETTABS(AFT);

        IF (CUR$ACCESS AND 1) = 0 OR CUR$CLOSED THEN    /* NOT READ */
            CALL ERR(WARNING, CANT$READ);

        CALL SETDEV;
        IF CUR$DEVICE <= F3DEV THEN
            CALL FIO(AFT, BUFFER, COUNT, ACTUAL$P, TRUE);
        ELSE
        DO WHILE 1;
            IF CUR$DEVICE = BBDEV THEN
                COUNT = 0;
            IF ACTUAL = COUNT THEN
                RETURN;
            IF READCASE(CUR$DEVICE) THEN
                CH = CI;
            ELSE
            DO;
                CH = RI;
                IF CARRY THEN
                    RETURN;
            END;
            BUFFER = BUFFER + 1;
            ACTUAL = ACTUAL + 1;
        END;
    END;

    WRITE: PROCEDURE(AFT, BUFFER, COUNT);
        DECLARE AFT BYTE, (BUFFER, COUNT) ADDRESS;
        DECLARE CH BASED BUFFER BYTE;
        DECLARE ACTUAL ADDRESS;
        DECLARE WRITECASE(23) BYTE INITIAL(0, 0, 0, 0, 0FFH, 1, 0FFH, 1,
                                      0FFH, 1, 0FFH, 0FFH, 0FFH, 0FFH, 2, 2,
                                      2, 2, 3, 3, 4, 0FFH, 0FFH);

        CALL SETTABS(AFT);
        IF (CUR$ACCESS AND 2) = 0 OR CUR$CLOSED THEN
            CALL ERR(WARNING, CANT$WRITE);

        CALL SETDEV;

        DO WHILE COUNT <> 0;
            DO CASE WRITECASE(CUR$DEVICE);
            DO;     /* CASE 0 */
                CALL FIO(AFT, BUFFER, COUNT, .ACTUAL, FALSE);
                RETURN;
            END;
            DO;     /* CASE 1 */
                CALL CO(CH);
                IF CSTS THEN
                    IF (CI AND 7FH) = CONTROL$S THEN
                        DO WHILE (CI AND 7FH) <> CONTROL$Q;
                        END;
            END;
            CALL PO(CH);        /* CASE 2 */
            CALL LO(CH);        /* CASE 3 */
            ;                   /* CASE 4 */
            END;

            COUNT = COUNT - 1;
            BUFFER = BUFFER + 1;
        END;
    END;



    EDIT: PROCEDURE(AFT, BUFFER, COUNT, ACTUAL$P);
        DECLARE AFT BYTE, (BUFFER, COUNT, ACTUAL$P) ADDRESS;
        DECLARE ACTUAL BASED ACTUAL$P ADDRESS;
        DECLARE LINE$P ADDRESS,
            IN$MODE BYTE,
            LIT$MODE BYTE,
            LPTR BYTE,
            CHAR BYTE,
            I BYTE,     /* NOTE READ CLOBBERS SELECTOR AS WELL */
            SELECTOR BYTE;
        DECLARE OBUF BASED BUFFER (1) BYTE;
        DECLARE BYTES BASED LINE$P (128) BYTE;
        DECLARE ADDR BASED LINE$P (64) ADDRESS;
        DECLARE SPECIALCHARS(10) BYTE INITIAL(0, DELKEY, CONTROL$Z, CONTROL$R,
                                 CONTROL$X, CR, LF, ESC, CONTROL$E, CONTROL$P);


        ECHO: PROCEDURE(CHAR);      /* NESTED SUB OF EDIT */
            DECLARE CHAR BYTE;
            CALL WRITE(CUR$ECHOAFT, .CHAR, 1);
            CALL SETTABS(AFT);
        END;

        LIT$MODE = FALSE;
        LINE$P = EBUF(AFT);
        LPTR = BYTES(126);
        IN$MODE = BYTES(127);

        DO WHILE IN$MODE;
            CALL READ(AFT, .CHAR, 1, .I);
            IF I = 0 THEN
            DO;
                IF AFT = AFT$CONSOL$IN THEN
                    CALL ERR(ABORT, CONSOLE$EOF);
                ELSE
                    CHAR = CONTROL$Z;
            END;
            BYTES(125) = FALSE;
            CHAR = CHAR AND 7FH;
            IF CHAR <> LF THEN
                CALL ECHO(BYTES(LPTR) := CHAR);

            SELECTOR = 0;
            DO I = 0 TO 9;
                IF CHAR = SPECIALCHARS(I) THEN
                    SELECTOR = I;
            END;
            SELECTOR = SELECTOR AND NOT LIT$MODE;
            LIT$MODE = FALSE;
            DO CASE SELECTOR;
                LPTR = LPTR + 1;    /* CASE 0 - NORMAL */
                DO;         /* CASE 1, RUBOUT */
                    IF LPTR <> 0 THEN
                    DO;
                        CALL ECHO(BYTES(LPTR := LPTR - 1));
                    END;
                    ELSE
                        CALL ECHO(BELL);
                END;
                DO;         /* CASE 2 - CONTROL-Z */
                    ACTUAL = 0;
                    BYTES(125) = TRUE;
                    ADDR(63) = 0FF00H;
                    CALL ECHO(CR);
                    CALL ECHO(LF);
                    RETURN;
                END;
                DO;         /* CASE 3 - CONTROL-R */
                    CALL ECHO(CR);
                    CALL ECHO(LF);
                    CALL WRITE(ECHOAFT(AFT), LINE$P, LPTR);
                END;
                DO;         /* CASE 4 - CONTROL-X */
                    LPTR = 0;
                    CALL ECHO(HASH);
                    CALL ECHO(CR);
                    CALL ECHO(LF);
                END;
                DO;         /* CASE 5 - CR */
                    BYTES(LPTR := LPTR + 1) = LF;
                    CALL ECHO(LF);
                    IN$MODE = FALSE;
                    LPTR = 0;
                END;
                DO;         /* CASE 6 - LF */
                    IF LPTR <> 0 THEN
                    DO;
                        CALL ECHO(BYTES(LPTR) := CHAR);
                        IN$MODE = FALSE;
                        LPTR = 0;
                    END;
                END;
                DO;         /* CASE 7 -  ESC */
                    CALL ECHO(0);
                    CALL ECHO('$');
                    IN$MODE = FALSE;
                    LPTR = 0;
                END;
                DO;         /* CASE 8 - CONTROL-E */
                    IF AFT = AFT$CONSOL$IN THEN
                    DO;
                        I = DEVICE(AFT$CONSOL$IN);
                        DEVICE(AFT$CONSOL$IN) = ALT$CIDEV;
                        ALT$CIDEV = I;
                        CALL ECHO(CARET);
                        CALL ECHO('E');
                    END;
                END;
                LIT$MODE = TRUE;    /* CASE 8 - CONTROL-P */
            END; /* OF CASE */
            IF LPTR = 122 THEN
            DO;
                IN$MODE = FALSE;
                LPTR = 0;
            END;
        END;

        ACTUAL = 0;
        DO WHILE ACTUAL < COUNT AND NOT IN$MODE;
            IF LPTR < MAXLL THEN    /* 122 */
            DO;
                IF (OBUF(ACTUAL) := BYTES(LPTR)) = LF OR BYTES(LPTR) = ESC THEN
                DO;
                    IN$MODE = TRUE;
                    LPTR = -1;
                END;

                ACTUAL = ACTUAL + 1;
                LPTR = LPTR + 1;
            END;
            ELSE
            DO;
                IN$MODE = TRUE;
                LPTR = 0;
            END;
        END;
        BYTES(126) = LPTR;
        BYTES(127) = IN$MODE;
    END;


    RESCAN: PROCEDURE(AFTN);
        DECLARE AFTN BYTE;
        DECLARE BUF$P ADDRESS, BYTES BASED BUF$P(128) BYTE,
                      ADDR BASED BUF$P(64) ADDRESS;

        CALL SETTABS(AFTN);
        BUF$P = CUR$EBUF;
        IF CUR$ECHOAFT = 0 OR BYTES(125) THEN
            CALL ERR(WARNING, CANT$RESCAN);
        ADDR(63) = 0;   /* LPTR = 0, IN$MODE = FALSE */
    END;

    REWIND: PROCEDURE;
        CUR$BYTENO = 128;
        CUR$DPTR = 1;
        CUR$BLKNO = 0;
        CUR$ALLOC = 0;
        CUR$DMOD = 0;
        CUR$DADDR = 0;
        CALL RDSEC(CUR$LADDR := CUR$L1ADDR, CUR$LBUF);
    END;




    SEEK: PROCEDURE(AFT, MODE, BLOCKNO$P, BYTENO$P);
        DECLARE AFT BYTE, (MODE, BLOCKNO$P, BYTENO$P) ADDRESS;
        DECLARE BLOCKNO BASED BLOCKNO$P ADDRESS, BYTENO BASED BYTENO$P ADDRESS;
        DECLARE LOWMODE BYTE, BYTLO(0) BYTE, (BYT, BLK) ADDRESS;
        DECLARE BACKWARDS BYTE;
        DECLARE BYTENOSTEP(2) BYTE INITIAL(128, 1);
        DECLARE BLKNOSTEP(2) ADDRESS INITIAL(1, 0FFFFH);
        DECLARE NEXT ADDRESS;
        DECLARE BACKFIX BYTE;

        OFFEND: PROCEDURE(BLKNUMA, BLKNUMB, BYTENUMA, BYTENUMB) BOOLEAN;
            DECLARE (BLKNUMA, BLKNUMB) ADDRESS, (BYTENUMA, BYTENUMB) BYTE;

            BYTENUMA = BYTENUMA + LOW(BYT);
            BLKNUMA = (ROL(BYTENUMA, 1) AND 1) + BLK + BLKNUMA;
            BYTENUMA = BYTENUMA AND 7FH;
            BLKNUMB = BLKNUMB + (ROL(BYTENUMB, 1) AND 1);
            BYTENUMB = BYTENUMB AND 7FH;
            IF BLKNUMA <> BLKNUMB THEN
                RETURN BLKNUMB < BLKNUMA;
            RETURN BYTENUMB < BYTENUMA;

        END;

        BYT = BYTENO;
        BLK = BLOCKNO;

        IF MODE > SEEK$EOF THEN
            CALL ERR(WARNING, BAD$SEEK$ARG);

        CALL SETTABS(AFT);
        IF CUR$CLOSED THEN
            CALL ERR(WARNING, BAD$AFT$NO);

        IF CUR$DEVICE = BBDEV THEN
            RETURN;

        IF CUR$DEVICE > F3DEV THEN
            CALL ERR(WARNING, NON$DISK$SEEK);

        IF CUR$ACCESS = WRITE$MODE THEN
            CALL ERR(WARNING, SEEK$ON$WRITE);

        IF (LOWMODE := MODE) = SEEK$RETURN THEN
        DO;
            BYTENO = CUR$BYTENO;
            IF (BLOCKNO := CUR$BLKNO - 1) = 0FFFFH THEN
            DO;
                BLOCKNO, BYTENO = 0;
            END;
            RETURN;
        END;

        IF CUR$DMOD THEN
            CALL WRSEC(CUR$DADDR, CUR$DBUF);

        IF CUR$ALLOC THEN
        DO;
            CALL RWMAP(CUR$DEVICE, CMD$WRITE);
            CALL WRSEC(CUR$LADDR, CUR$LBUF);
        END;

        CUR$DMOD = 0;
        CUR$ALLOC = 0;

        IF LOWMODE = SEEK$EOF THEN
        DO;
            LOWMODE = SEEK$ABS;
            BYT = CUR$LASTBYTE;
            IF (BLK := CUR$BLKCNT - 1) = 0FFFFH THEN
                BLK, BYT = 0;
        END;
        IF LOWMODE = SEEK$ABS THEN
            CALL REWIND;

        BACKWARDS = (LOWMODE = 1) AND 1;
        BACKFIX = CUR$BYTENO = 128 AND BACKWARDS;
        BLK = (BLK AND 07FFFH) + SHR(BYT, 7);
        BYTLO = (BYTLO AND 7FH);
        IF NOT BACKWARDS THEN
        DO;
            IF (CUR$ACCESS = 1) AND OFFEND(CUR$BLKNO, CUR$BLKCNT,
                                         CUR$BYTENO, CUR$LASTBYTE) THEN
                CALL ERR(WARNING, SEEK$PAST$EOF);
        END;
        ELSE IF OFFEND(1, CUR$BLKNO, 0, CUR$BYTENO) THEN
                CALL ERR(WARNING, LONG$BACK$SEEK);

        DO WHILE BYTLO > 0;
            BYTLO = BYTLO - 1;
            IF CUR$BYTENO = BYTENOSTEP(BACKWARDS) THEN
            DO;
                CUR$BYTENO = BYTENOSTEP(1 - BACKWARDS);
                BLK = BLK + 1;
            END;
            ELSE
            DO;
                CUR$BYTENO = CUR$BYTENO + BLKNOSTEP(BACKWARDS);
            END;
            IF NOT BACKWARDS THEN
                CALL SIZECK;
        END;
        DO WHILE BLK > 0;
            BLK = BLK - 1;
            IF NOT BACKWARDS THEN
            DO;
                IF CUR$DPTR = 63 THEN
                DO;
                    CUR$DPTR = 1;
                    IF (NEXT := LINKS(FLINK)) = 0 THEN
                    DO;
                        LINKS(FLINK), NEXT = ALLOCATE(CUR$DEVICE);
                        CALL RWMAP(CUR$DEVICE, CMD$WRITE);
                        CALL WRSEC(CUR$LADDR, CUR$LBUF);
                        CALL CLRBUF(CUR$LBUF);
                        LINKS(BLINK) = CUR$LADDR;
                        CALL WRSEC(NEXT, CUR$LBUF);
                        CUR$LADDR = NEXT;
                    END;
                    ELSE
                        CALL RDSEC((CUR$LADDR := NEXT), CUR$LBUF);
                END;
                CUR$DPTR = CUR$DPTR + 1;
            END;
            ELSE IF (CUR$DPTR := CUR$DPTR - 1) < 2 THEN
                IF LINKS(BLINK) <> 0 THEN
                DO;
                    CUR$DPTR = 63;
                    CALL RDSEC(CUR$LADDR := LINKS(BLINK), CUR$LBUF);
                END;
            CUR$BLKNO = CUR$BLKNO + BLKNOSTEP(BACKWARDS);
        END;
        IF CUR$DADDR <> LINKS(CUR$DPTR) OR BACKFIX THEN
            IF (CUR$DADDR := LINKS(CUR$DPTR)) = 0 THEN
                CALL CLRBUF(CUR$DBUF);
            ELSE
                CALL RDSEC(CUR$DADDR, CUR$DBUF);
        CALL SIZECK;
    END;

    SYNC: PROCEDURE;
        CALL WRSEC(CUR$DADDR, CUR$DBUF);
    END;

    DECLARE DIRECT$EMPTY BYTE, DIRECT$FILE(9) BYTE, DIRECT$ATTRIB BYTE,
            DIRECT$EOF$COUNT BYTE, DIRECT$BLK ADDRESS, DIRECT$HDR$BLK ADDRESS;
    DECLARE DIRECT$INO BYTE;

    SEARCH: PROCEDURE(INTFN$P) BOOLEAN;
        DECLARE INTFN$P ADDRESS;
        DECLARE INTFN BASED INTFN$P (12) BYTE;
        DECLARE RCOUNT ADDRESS;
        DECLARE BLOCKNO ADDRESS INITIAL(0);
        DECLARE BYTENO ADDRESS;
        DECLARE (I, AFT) BYTE;
        DECLARE DNUM ADDRESS;
        DECLARE RETURN$VALUE BOOLEAN;
        /*
          THIS PROCEDURE IS USED TO LOOKUP A FILE NAME IN A
          DISK DIRECTORY. THE DEVICE NUMBER OF THE DISK
          IS CONTAINED IN FN(0), THE SIX CHARACTERS OF THE
          FILE NAME ARE IN FN(1) THROUGH FN(6), AND THE
          THREE CHARACTERS OF THE FILE EXTENSION ARE IN
          FN(7) THROUGH FN(9)

          THE PROCEDURE RETURNS 'TRUE' IF THE FILE IS FOUND,
          WITH DIRECT$I$NO POINTING TO THE ENTRY OF THE FILE IN THE
          DIRECTORY

          OTHERWISE, THE PROCEDURE RETURNS 'FALSE', AND DIRECT$I$NO POINTS
          AT A BLANK SLOT IN THE DIRECTORY. THE DIRECTORY MARKER IS
          ADJUSTED SO TAHT IT POINTS AT THE BEGINNING OF THE ENTRY
          POINTED TO BY DIRECT$I$NO.

          IF THE DIRECTORY IS FULL, DIRECT$I$NO = 0FFH
        */
        DBUF(AFT := CUR$DEVICE + 0) = GETBUF;
        LBUF(AFT) = GETBUF;
        CALL SETTABS(AFT);
        CALL REWIND;
        DIRECT$I$NO = 0FFH;
        DNUM = 0;
        RCOUNT = 1;
        DIRECT$EMPTY, RETURN$VALUE = 0;

        DO WHILE RCOUNT <> 0 AND DIRECT$EMPTY <> 7FH;
            CALL READ(AFT, .DIRECT$EMPTY, 16, .RCOUNT);
            IF DIRECT$EMPTY THEN
            DO;
                IF DIRECT$I$NO = 0FFH THEN
                    DIRECT$I$NO = DNUM;
            END;
            ELSE
            DO;
                DO I = 1 TO 9;
                    IF INTFN(I) <> DIRECT$FILE(I - 1) THEN
                    GOTO SKIP;
                END;
                DIRECT$I$NO = DNUM;
                RETURN$VALUE = 0FFH;
                RCOUNT = 0;
            END;
    SKIP:
            DNUM = DNUM + 1;
        END;

        IF DIRECT$I$NO <> 0FFH THEN
        DO;
            BYTENO = DIRECT$I$NO * 16;      /* SIZE OF DIRECT ENTRY */
            CALL SEEK(AFT, SEEK$ABS, .BLOCKNO, .BYTENO);
        END;
        CALL FREE$BUF(CUR$DBUF);
        CALL FREE$BUF(CUR$LBUF);
        RETURN RETURN$VALUE;
    END;


    ATTRIB: PROCEDURE(FILENAME, SWID, VALUE);
        DECLARE (FILENAME, SWID) ADDRESS, VALUE BYTE;
        DECLARE MASK(4) BYTE INITIAL(INVISIBLE$ATTRIBUTE,
                                       SYSTEM$ATTRIBUTE,
                                       WRITEP$ATTRIBUTE,
                                       FORMAT$ATTRIBUTE);

        IF SWID > 4 THEN
            CALL ERR(WARNING, BAD$ATTRIB);
        CALL GETFN(FILENAME, .PN);
        IF PN(0) > F3DEV THEN
            CALL ERR(WARNING, NON$DISK$FILE);
        CALL SETTABS(PN(0));
        IF NOT SEARCH(.PN) THEN
            CALL ERR(WARNING, NO$SUCH$FILE);

        DIRECT$ATTRIB = DIRECT$ATTRIB OR MASK(LOW(SWID));
        IF NOT VALUE THEN
            DIRECT$ATTRIB = DIRECT$ATTRIB AND (NOT MASK(LOW(SWID)));
        CALL WRITE(PN(0), .DIRECT$EMPTY, 16);
        CALL SYNC;
    END;


    CLOSE: PROCEDURE(AFT);
        DECLARE AFT BYTE;
        DECLARE BLKZERO ADDRESS INITIAL(0), BYTNO ADDRESS INITIAL(0);
        DECLARE I BYTE;   /* READ RETURNS AN ADDRESS BUT HIGH BYTE WILL BE 0 */
        DECLARE CLOSECASE(23) BYTE INITIAL(0,0,0,0,       /* F0-F3 */
              1,2,1,2,1,2,1,1,1,1,  /* TI, TO, VI, VO, I1, O1, TR, HR, T1, T2 */
              3,3,3,3,4,4,1,1,1);   /* TP, HP, P1, P2, LP, L1, BB, CI, CO */

        CALL SETTABS(AFT);
        IF CUR$CLOSED THEN
            RETURN;
        IF CUR$ECHOAFT <> 0 THEN
            CALL FREE$BUF(CUR$EBUF);
        DO CASE CLOSECASE(CUR$DEVICE);
            DO; /* 0 - DISK */
                IF CUR$DMOD THEN
                    CALL WRSEC(CUR$DADDR, CUR$DBUF);
                IF CUR$ALLOC THEN
                    CALL WRSEC(CUR$LADDR, CUR$LBUF);

                CALL FREE$BUF(CUR$LBUF);
                CALL FREE$BUF(CUR$DBUF);
                IF CUR$ACCESS >= 2 THEN
                DO;
                    CALL SIZECK;
                    BLKZERO = 0;
                    CALL RWMAP(CUR$DEVICE, CMD$WRITE);
                    /* LET DEVICE USE RETURNED BUFFERS */
                    DBUF(CUR$DEVICE) = CUR$DBUF;
                    LBUF(CUR$DEVICE) = CUR$LBUF;
                    CALL SETTABS(CUR$DEVICE);
                    CALL REWIND;                 /* GET TO DIR HEADER */
                    BYTNO = 16 * DNUM(AFT);
                    /* SEEK TO FILE ENTRY */
                    CALL SEEK(CUR$DEVICE, SEEK$ABS, .BLKZERO, .BYTNO);
                    /* READ THE DIR ENTRY */
                    CALL READ(CUR$DEVICE, .DIRECT$EMPTY, 16, .I);
                    DIRECT$EOF$COUNT = LASTBYTE(AFT);
                    DIRECT$BLK = BLKCNT(AFT);
                    BYTNO = 16;
                    CALL SEEK(CUR$DEVICE, 1, .BLKZERO, .BYTNO);
                    CALL WRITE(CUR$DEVICE, .DIRECT$EMPTY, 16);
                    CALL SYNC;
                END;
            END;
            ;   /* 1 */
            ;   /* 2 */
            DO I = 0 TO 119;    /* 3 OUTPUT 120 NULLS */
                CALL WRITE(AFT, .(0), 1);
            END;
            ;   /* 4 */
        END;
        CLOSED(AFT) = TRUE;
    END;


    RENAME: PROCEDURE(OLD$NAME, NEW$NAME);
        DECLARE (OLD$NAME, NEW$NAME) ADDRESS;
        DECLARE I BYTE;
        DECLARE ALREADY$EXISTS BOOLEAN;


        CALL GETFN(OLD$NAME, .PN2);
        CALL GETFN(NEW$NAME, .PN);
        IF PN(0) > F3DEV THEN
            CALL ERR(WARNING, NON$DISK$FILE);
        IF PN(0) <> PN2(0) THEN
            CALL ERR(WARNING, DIFFERENT$DISK);
        CALL SETTABS(PN(0));
        /* IF NEW$NAME ALREADY EXISTS AND OLD$NAME DOES NOT EXISTI,
           THEN WE WANT OT GIVE THE OLD$NAME ERROR MESSAGE.
           HOWEVER, SEARCH(NEW$NAME) SHOULD PRECEDE SEARCH(OLD$NAME)
           THIS IS BECAUSE POINTER VARIABLES SHOULD BE LEFT POINTING TO
           THE OLD FILE UPON EXIT FROM THIS PROCEDURE */
        ALREADY$EXISTS = SEARCH(.PN);
        IF NOT SEARCH(.PN2) THEN
            CALL ERR(WARNING, NO$SUCH$FILE);
        IF (DIRECT$ATTRIB AND (WRITEP$ATTRIBUTE OR FORMAT$ATTRIBUTE)) <> 0 THEN
            CALL ERR(WARNING, WRITE$PROTECT);
        IF ALREADY$EXISTS THEN
            CALL ERR(WARNING, MULTIDEFINED);
        DO I = 0 TO 8;
            DIRECT$FILE(I) = PN(I + 1);
        END;
        CALL WRITE(CUR$DEVICE + 0, .DIRECT$EMPTY, 16);
        CALL SYNC;
    END;

    SCRATCH: PROCEDURE(DRIVE);
        DECLARE DRIVE BYTE;
        DECLARE (AFT, I) BYTE;
        DECLARE BLOCKNO ADDRESS INITIAL (0);
        DECLARE BYTENO ADDRESS INITIAL(16 /* SIZE DIRECTORY ENTRY */);
        DECLARE LINKBUF$P ADDRESS, LINKBUF BASED LINKBUF$P (64) ADDRESS;

        /* INTERNAL DELETE ROUTING
        DRIVE = F0DEV .. F3DEV
        DIRECT MUST CONTAIN THE DIRECTORY ENTRY FOR AN EXISTING FILE OR DISK.
        AFT SLOT FOR THE APPROPRIATE DIRECTORY MUST HAVE BUFFERS;
        AND THESE BUFFERS MUST BE SETUP FOR DIRECTORY READING AND
        WRITING. THESE BUFFERS WILL BE CLOBBERED
        */
        DIRECT$EMPTY = TRUE;
        CALL SETTABS(AFT := DRIVE + 0);
        CALL WRITE(AFT, .DIRECT$EMPTY, 16);
        CALL XIO(CMD$WRITE, DRIVE, CUR$DADDR, CUR$DBUF);
        CALL SEEK(AFT, SEEK$BACKWARD, .BLOCKNO, .BYTENO);
        LINKBUF$P = CUR$DBUF;    /* LIST OF BLOCKS TO DELETE */
        DO WHILE DIRECT$HDR$BLK <> 0;
            CALL DEALLOC(DRIVE, DIRECT$HDR$BLK);
            CALL XIO(CMD$READ, DRIVE, DIRECT$HDR$BLK, LINKBUF$P);
            DIRECT$HDR$BLK = LINKBUF(FLINK);
            DO I = 2 TO 63;
                IF LINKBUF(I) <> 0 THEN
                    CALL DEALLOC(DRIVE, LINKBUF(I));
            END;
        END;
        CALL XIO(CMD$READ, DRIVE, CUR$DADDR, CUR$DBUF);
        CALL RWMAP(DRIVE, CMD$WRITE);
    END;


    DELETE: PROCEDURE(FILENAME);
        DECLARE FILENAME ADDRESS;
        DECLARE I BYTE;

        CALL GETFN(FILENAME, .PN);
        IF PN(0) > F3DEV THEN
            CALL ERR(WARNING, NON$DISK$FILE);
        ELSE
            CALL SETTABS(PN(0));
        IF SEARCH(.PN) THEN
        DO;
            IF (DIRECT$ATTRIB
              AND (WRITEP$ATTRIBUTE OR FORMAT$ATTRIBUTE)) = 0 THEN
            DO;
                DO I = AFT$BOTTOM TO AFT$LAST;
                    IF (NOT CLOSED(I))
                        AND (DEVICE(I) = PN(0)) AND (DNUM(I) = DIRECT$INO) THEN
                        CALL ERR(WARNING, CANT$DELETE);
                END;
                CALL SCRATCH(PN(0));
            END;
            ELSE
                CALL ERR(WARNING, WRITE$PROTECT);
        END;
        ELSE
            CALL ERR(WARNING, NO$SUCH$FILE);
    END;

    DECLARE ACCESS$SUPPORT DATA(3, 3, 3, 3, 1, 2, 1, 2,
                                1, 2, 1, 1, 1, 1, 2, 2,
                                2, 2, 2, 2, 3, 1, 2);
    OPEN: PROCEDURE(FILENAME, INACCESS, ECHOAFT) BYTE;
        DECLARE (FILENAME, INACCESS, ECHOAFT) ADDRESS;
        DECLARE (AFT, REQACCESS, FOUND, TEMP, I) BYTE;
        DECLARE BUF$P ADDRESS, BYTES BASED BUF$P (128) BYTE,
                              ADDR BASED BUF$P (64) ADDRESS;

        FREE1: PROCEDURE(ERRNUM);
            DECLARE ERRNUM BYTE;

            IF CUR$ECHOAFT <> 0 THEN
                CALL FREE$BUF(CUR$EBUF);
            CALL ERR(WARNING, ERRNUM);
        END;

        FREE3: PROCEDURE(ERRNUM);
            DECLARE ERRNUM BYTE;

            CALL FREE$BUF(CUR$DBUF);
            CALL FREE$BUF(CUR$LBUF);
            CALL FREE1(ERRNUM);
        END;

        IF INACCESS > 3 OR (REQACCESS := INACCESS) = 0 THEN
            CALL ERR(WARNING, BAD$ACCESS);
        CALL GETFN(FILENAME, .PN);
        IF PN(0) = 0FFH THEN
                CALL ERR(WARNING, BAD$DEVICE);
        IF (ACCESS$SUPPORT(PN(0)) AND REQACCESS) = 0 THEN
                CALL ERR(WARNING, BAD$ACCESS);

        IF PN(0) = CIDEV THEN
            RETURN AFT$CONSOL$IN - AFT$BOTTOM;
        IF PN(0) = CODEV THEN
            RETURN AFT$CONSOL$OUT - AFT$BOTTOM;

        CALL SETTABS(AFT := GETAFT);
        CUR$ACCESS = REQACCESS;
        CUR$ECHOAFT = 0;
        IF ECHOAFT <> 0 THEN
        DO;
            CUR$ECHOAFT = AFT$BOTTOM + LOW(ECHOAFT);
            IF ACCESS(CUR$ECHOAFT) <> WRITE$MODE
              OR (CUR$ACCESS AND READ$MODE) = 0 THEN
                CALL ERR(WARNING, BAD$ECHO);

            BUF$P, CUR$EBUF = GET$BUF;
            BYTES(0) = LF;
            ADDR(63) = 0FF00H;
            BYTES(125) = TRUE;
        END;

        IF (CUR$DEVICE := PN(0)) <= F3DEV THEN
        DO;
            FOUND = SEARCH(.PN);
            CALL SETTABS(AFT);
            IF FOUND THEN
                DO I = AFT$BOTTOM TO AFT$LAST;
                    IF NOT CLOSED(I) THEN
                        IF DNUM(I) = DIRECT$I$NO AND DEVICE(I) = PN(0) THEN
                            CALL FREE1(ALREADY$OPEN);
                END;
            CUR$DNUM = DIRECT$I$NO;
            CUR$DBUF = GET$BUF;
            CUR$LBUF = GET$BUF;
            IF REQACCESS = 1 THEN
            DO;
                IF NOT FOUND THEN
                    CALL FREE3(NO$SUCH$FILE);
                CUR$L1ADDR = DIRECT$HDR$BLK;
                CUR$BLKCNT = DIRECT$BLK;
                CUR$LASTBYTE = DIRECT$EOF$COUNT;
                CALL REWIND;
            END;
            ELSE
            DO;
                IF NOT FOUND THEN
                DO;
                    IF DIRECT$I$NO = 0FFH THEN
                        CALL FREE3(DIRECTORY$FULL);
                    DIRECT$BLK = 0;
                    DIRECT$EOF$COUNT = 128;
                    DIRECT$ATTRIB = 0;
                END;
                IF (DIRECT$ATTRIB AND (WRITEP$ATTRIBUTE
                                       OR FORMAT$ATTRIBUTE)) <> 0 THEN
                    CALL FREE3(WRITE$PROTECT);

                IF REQACCESS = 2 AND FOUND THEN
                DO;
                    CALL SCRATCH(CUR$DEVICE);
                    CALL SETTABS(AFT);
                    DIRECT$BLK = 0;
                    DIRECT$EOF$COUNT = 128;
                END;
                CUR$LASTBYTE = DIRECT$EOF$COUNT;
                CUR$BLKCNT = DIRECT$BLK;
                IF NOT (TEMP := REQACCESS = 3 AND FOUND) THEN
                DO;
                    DIRECT$HDR$BLK = ALLOCATE(CUR$DEVICE);
                END;
                CUR$L1ADDR = DIRECT$HDR$BLK;
                DIRECT$EMPTY = 0;
                DO I = 0 TO 8;
                    DIRECT$FILE(I) = PN(I + 1);
                END;
                IF REQACCESS = 3 AND NOT FOUND THEN
                    DIRECT$ATTRIB = 0;
                CALL WRITE(CUR$DEVICE, .DIRECT$EMPTY, 16);
                CALL SYNC;

                CALL SETTABS(AFT);
                CALL REWIND;
                IF NOT TEMP THEN
                DO;
                    CALL CLRBUF(CUR$LBUF);
                    CALL RWMAP(CUR$DEVICE, CMD$WRITE);
                    CALL WRSEC(CUR$L1ADDR, CUR$LBUF);
                END;
            END;
        END;
        ELSE IF CUR$DEVICE <> BBDEV THEN
        DO;
            DO I = AFT$BOTTOM TO AFT$LAST;
                IF NOT CLOSED(I) THEN
                    IF CUR$DEVICE = DEVICE(I) THEN
                        CALL FREE1(ALREADY$OPEN);
            END;
            IF CUR$DEVICE >= 14 AND CUR$DEVICE <= 17 THEN
                DO I = 1 TO 120;
                    CUR$CLOSED = FALSE;
                    CALL WRITE(AFT, .(0), 1);
                END;
        END;
        CUR$CLOSED = FALSE;
        RETURN AFT - AFT$BOTTOM;
    END;



    DECLARE CUR$CONSOL$IN(15) BYTE,
            CUR$CONSOL$OUT(15) BYTE;

    DECLARE COLD$CONSOL$IN(5)  BYTE INITIAL(':XI: '),
            COLD$CONSOL$OUT(5) BYTE INITIAL(':XO: ');


    CONSOL: PROCEDURE(INFILE, OUTFILE);
        DECLARE (INFILE, OUTFILE) ADDRESS;
        DECLARE INSTRING BASED INFILE BYTE,
            OUTSTRING BASED OUTFILE BYTE;
        DECLARE TEMP BYTE;
        DECLARE TDRV(2) BYTE INITIAL('TV'); /* T OR V IS 1ST LETTER OF NAME */

        IF COLD$START$FLAG THEN
        DO;
          COLD$CONSOL$IN(1), COLD$CONSOL$OUT(1) = TDRV(INITIO AND 1);
          INFILE = .COLD$CONSOL$IN;
          OUTFILE = .COLD$CONSOL$OUT;
        END;

        GLOBAL$SEVERITY = ABORT;
        CALL GETFN(OUTFILE, .PN);
        IF PN(0) <> CODEV THEN
        DO;
            CALL CLOSE(AFT$CONSOL$OUT);
            TEMP = OPEN(OUTFILE, WRITE$MODE, FALSE);
            DO TEMP = 0 TO 14;
                CUR$CONSOL$OUT(TEMP) = FULLNAME(TEMP);
            END;
        END;
        CALL GETFN(INFILE, .PN);
        IF PN(0) <> CIDEV THEN
        DO;
            CALL CLOSE(AFT$CONSOL$IN);
            TEMP = OPEN(INFILE, READ$MODE, 100H);
            IF COLD$START$FLAG THEN
                COLD$CIDEV = DEVICE(AFT$CONSOL$IN);
            ALT$CIDEV = COLD$CIDEV;
            DO TEMP = 0 TO 14;
                CUR$CONSOL$IN(TEMP) = FULLNAME(TEMP);
            END;
        END;
        COLD$START$FLAG = FALSE;
    END;


    WHOCON: PROCEDURE(AFT, BUFFER$P);
        DECLARE AFT BYTE;
        DECLARE BUFFER$P ADDRESS, BUFFER BASED BUFFER$P (1) BYTE;
        DECLARE NAME$P ADDRESS, NAME BASED NAME$P (1) BYTE;
        DECLARE I BYTE;

        IF AFT THEN
            NAME$P = .CUR$CONSOL$IN;
        ELSE
            NAME$P = .CUR$CONSOL$OUT;
        DO I = 0 TO 14;
            BUFFER(I) = NAME(I);
        END;
    END;


    LOAD: PROCEDURE(PATHNAME, BIAS, RETSW, ENTRY$P);
        DECLARE (PATHNAME, BIAS, RETSW, ENTRY$P) ADDRESS;
        DECLARE ENTRY BASED ENTRY$P ADDRESS;
        DECLARE PAD1 BYTE;
        DECLARE (AFT, I, RETSW$B, PAD2) BYTE;
        DECLARE HEADER$TYPE BYTE, HEADER$LENGTH ADDRESS;
        DECLARE RECORD$TYPE BYTE, RECORD$SEGID BYTE, RECORD$LOAD$ADDR ADDRESS;
        DECLARE ACTUAL ADDRESS, BYTENO ADDRESS;
        DECLARE BLOCKNO ADDRESS INITIAL(0), 
                USER$BOTTOM ADDRESS INITIAL(0FFFFH), BUFFER$TOP ADDRESS;

        BOUNDS$TEST: PROCEDURE;

            RECORD$LOAD$ADDR = RECORD$LOAD$ADDR + BIAS;

            IF RECORD$LOAD$ADDR >= 18H AND RECORD$LOAD$ADDR <= 3FH
              AND RECORD$LOAD$ADDR + HEADER$LENGTH <= 40H THEN
                RETURN;
            IF USER$BOTTOM > RECORD$LOAD$ADDR THEN
            /* FIRST ADDRESS WILL UPDATE THIS IF APPLICABLE */
                USER$BOTTOM = RECORD$LOAD$ADDR; 
            IF BUFFER$TOP > RECORD$LOAD$ADDR
              OR RECORD$LOAD$ADDR + HEADER$LENGTH  < RECORD$LOAD$ADDR THEN
                CALL ERR(ABORT, ISIS$OVERWRITE);
        END;

        IF RETSW > 2 THEN
            CALL ERR(WARNING, BAD$RETSW);

        AFT = AFT$BOTTOM +  OPEN(PATHNAME, 1, 0);   /* OPEN$READ */

        IF (RETSW$B := RETSW) <> 0 THEN
            USER$BOTTOM = MEMCK;
        BUFFER$TOP = PACKBUFS;
        DO WHILE TRUE;
            /* READ HEADER TYPE AND LENGTH */
            CALL READ(AFT, .HEADER$TYPE, 3, .ACTUAL);
            /* SHORT, RELOCATE OR ODD TYPE */
            IF ACTUAL < 3 OR HEADER$TYPE >= R$RELOC OR HEADER$TYPE THEN
                CALL ERR(ABORT, BAD$LOAD$FORMAT);
            IF HEADER$TYPE > R$CONTENT THEN
            DO;
                BLOCKNO = 0;
                BYTENO = HEADER$LENGTH;
                /* SKIP HEADER */
                CALL SEEK(AFT, SEEK$FORWARD, .BLOCKNO, .BYTENO);
            END;
            ELSE
            DO;
                DO CASE SHR(HEADER$TYPE,1);
                CALL ERR(ABORT, BAD$LOAD$FORMAT);   /* CASE 0 */
                DO;                                 /* CASE 1 - R$MODHDR SKIP */
                    BLOCKNO = 0;
                    BYTENO = HEADER$LENGTH;
                    /* SKIP HEADER */
                    CALL SEEK(AFT, SEEK$FORWARD, .BLOCKNO, .BYTENO);
                END;
                DO; /* CASE 2 - R$MODEND */
                    CALL READ(AFT, .RECORD$TYPE, 4, .ACTUAL);
                    HEADER$LENGTH = 0;
                    IF RECORD$TYPE = 1 THEN      /* SYSTEM */
                        CALL BOUNDS$TEST;
                    ELSE
                        RECORD$LOAD$ADDR = 0;
                    CALL CLOSE(AFT);
                    USER$BOTTOM = USER$BOTTOM AND 0FF80H;
                    DO I = 0 TO 18;
                        IF .MEMORY + SHL(DOUBLE(I), 7) >= USER$BOTTOM  THEN
                            BUFFER$TABLE(I) = 1;    /* NOT AVAILABLE */
                        ELSE
                            BUFFER$TABLE(I) = BUFFER$TABLE(I) AND 0FEH;
                    END;
                    IF RETSW$B = 0 THEN
                    DO;
                        ENTRY = RECORD$LOAD$ADDR;
                        RETURN;
                    END;
                    IF RETSW$B = 1 THEN
                    DO;
                        STACKPTR = USERSP + 2;
                        DEBUG$TOGGLE = FALSE;
                        GOTO RECORD$LOAD$ADDR;
                    END;
                    STACKPTR = MEMCK;
                    ENTRY$P = STACKPTR;
                    ENTRY = RECORD$LOAD$ADDR;
                    DEBUG$TOGGLE = TRUE;
                    GOTO MDSMON;
                END;
                DO; /* CASE 3 - R$CONTENT */
                    CALL READ(AFT, .RECORD$SEGID, 3, .ACTUAL);
                    IF RECORD$SEGID <> 0 THEN
                        CALL ERR(ABORT, BAD$LOAD$FORMAT);
                    /* DON'T INCLUDE HEADER AND CRC */
                    HEADER$LENGTH = HEADER$LENGTH - 4;
                    CALL BOUNDS$TEST;
                    CALL READ(AFT, RECORD$LOAD$ADDR, HEADER$LENGTH, .ACTUAL);
                    IF ACTUAL < HEADER$LENGTH THEN
                        CALL ERR(ABORT, BAD$LOAD$FORMAT);
                    CALL READ(AFT, .RECORD$SEGID, 1, .ACTUAL);
                END;
                END;    /* OF CASE */
            END;    /* OF ELSE */
        END;
    END;

    EXIT: PROCEDURE;
        DECLARE I BYTE;
        DO I = AFT$FIRST TO AFT$LAST;
            CALL CLOSE(I);
        END;
        IF MAP$CHANGE THEN
            CALL RWMAP(CURRENT$BITMAP, CMD$WRITE);
        CURRENT$BITMAP = 0FFH;
        CALL LOAD(.('ISIS.CLI '), 0, 1, 0);
    END EXIT;

    DECLARE BOOTLOAD DATA(80H, 4, 26, 0, 1, 0, 30H);   /* 3000H -> MEMORY */

    REBOOT: PROCEDURE INTERRUPT 1;
        DECLARE I BYTE;
        STACKPTR = .TOPSTACK;
        DO I = AFT$BOTTOM TO AFT$LAST;
            CALL CLOSE(I);
        END;
        CALL XEQIOPB(0, .BOOTLOAD);
        GOTO 3000H;
    END;

    AFT$CHK: PROCEDURE;
        ;        /* ADJUST USERS AFT */
        IF (PARAM1 := PARAM1 + AFT$BOTTOM) >= 12 /* AFT$LAST + 1 */
                                         OR PARAM1 < AFT$BOTTOM THEN
            CALL ERR(WARNING, BAD$AFT$NO);
    END;

    /* ISIS */
    USERSP = STACKPTR;
    STACKPTR = .TOPSTACK;

    IF COMMAND = 'D' THEN
        CALL XEQIOPB(PARAM(0), PARAM(1));
    ELSE
    DO;
        DO I = 0 TO 4;
            /* CHECK IF AN ADDRESS PARAMETER */
            IF SHR(PARAMTYPE(I), COMMAND + 1) THEN
                IF (PARAM(I) < .MEMORY) THEN
                    CALL ERR(ABORT, BAD$PARAMETER);
            SYSPARAM(I+1) = PARAM(I);
        END;

        /* GET THE RETURN STATUS ADDRESS */
        USERSTATUS$P = SYSPARAM(RETPARAMIDX(COMMAND));
        USERSTATUS = 0;
        GLOBAL$SEVERITY = 0;
        IF COMMAND < 14 THEN       /* MAX$COMMAND */
            DO CASE COMMAND;
            DO;     /* 0 - OPEN */
                DECLARE AFT BASED PARAM1 ADDRESS;
                AFT = OPEN(PARAM2, PARAM3, PARAM4);  /* FILE, ACCESS, MODE */
            END;
            DO;     /* 1 - CLOSE */
                CALL AFT$CHK;
                IF PARAM1 >= 6 THEN
                    CALL CLOSE(PARAM1);
            END;
            CALL DELETE(PARAM1);    /* 2 - DELETE - FILE */
            DO;         /* 3 - READ */
                CALL AFT$CHK;
                IF ECHOAFT(PARAM1) = 0 THEN
                    /* AFTN, BUFFER, COUNT, ACTUAL */
                    CALL READ(PARAM1, PARAM2, PARAM3, PARAM4);
                ELSE
                    /* AFTN, BUFFER, COUNT, ACTUAL */
                    CALL EDIT(PARAM1, PARAM2, PARAM3, PARAM4);
            END;
            DO;         /* 4 - WRITE */
                CALL AFT$CHK;
                CALL WRITE(PARAM1, PARAM2, PARAM3); /* AFTN, BUFFER, COUNT */
            END;
            DO;         /* 5 - SEEK */
                CALL AFT$CHK;
                /* AFTN, BUFFER, COUNT, ACTUAL */
                CALL SEEK(PARAM1, PARAM2, PARAM3, PARAM4);
            END;
            /* 6 - SEEK - FILE, BASE, RETSW, ENTRY */
            CALL LOAD(PARAM1, PARAM2, PARAM3, PARAM4);
            CALL RENAME(PARAM1, PARAM2);      /* 7 - RENAME - FILE1, FILE2 */
            DO;                               /* 8 - CONSOLE - FILE1, FILE2 */
                GLOBAL$SEVERITY = 2;
                CALL CONSOL(PARAM1, PARAM2);
            END;
            CALL EXIT;                        /* 9 - EXIT */
            /* 10 - ATTRIB - FILE, SWID, SWVALUE */
            CALL ATTRIB(PARAM1, PARAM2, PARAM3);
            DO;         /* 11 - RESCAN */
                CALL AFT$CHK;
                CALL RESCAN(PARAM1);        /* AFTN */
            END;
            CALL ERR(MESSAGE, PARAM1);  /* 12 - ERROR - MESSAGE, ERRNUM */
            CALL WHOCON(PARAM1, PARAM2);    /* 13 - WHOCON - AFTN, BUFFER */
            END;
        ELSE
            CALL ERR(WARNING, BAD$COMMAND);
    END;
    STACKPTR = USERSP;
END;
END;
EOF

