absio.plm
Absio: do;
$include(absio.ipx)
Absio: procedure(cmd, disk, block, buffer) public;
	declare (cmd, disk) byte, (block, buffer) address;
	declare dcb DCB$T;

	dcb.iocw = 80H;
	dcb.ioins = cmd;
	dcb.nsec = 1;
	dcb.tadr = high(block);
	dcb.sadr = low(block);
	dcb.buf = buffer;
	call Diskio(disk, .dcb);
end;
end;

cli.plm
CLI:
DO;
declare version(2) byte data(2, 10h);
declare cpyrite(*) byte data('(C) 1975,1976 INTEL CORP');
$include(cli.ipx)
$LIST
DECLARE BUFFER(128) BYTE;
DECLARE DEBUG BOOLEAN;
DECLARE BUFFER$PTR ADDRESS, CHAR BASED BUFFER$PTR BYTE;
DECLARE (PATHNAME$PTR,ACTUAL,STATUS,ENTRY,RETSW) ADDRESS;

/* *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
   *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*

   BEGINNING OF PROGRAM.

   *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
   *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-* */

STACKPTR = MEMCK;
OUTPUT(0FCH) = 0FCH; /* ENABLE CONSOLE INTERRUPTS 0 AHD 1 */
ENABLE;
OUTPUT(0FDH) = 20H; /* SEND END OF INTERRUPT COMMAND */
BUFFER$PTR = .(':CI: ');
CALL RESCAN(1,.STATUS);
IF STATUS = 0 THEN
DO;
  CALL READ(1,.BUFFER,LENGTH(BUFFER),.ACTUAL,.STATUS);
  CALL FILE$ERROR(STATUS,BUFFER$PTR,TRUE);
END;
DO FOREVER;
  CALL WRITE(0,.('-'),1,.STATUS);
  CALL READ(1,.BUFFER,LENGTH(BUFFER),.ACTUAL,.STATUS);
  CALL FILE$ERROR(STATUS,BUFFER$PTR,TRUE);
  BUFFER(ACTUAL) = CR;
  CALL FORCE$UPPER(.BUFFER);
  BUFFER$PTR = DEBLANK(.BUFFER);
  IF CHAR <> CR THEN
  DO;
    /* NOW CHECK FDR DEBUG MODE (PATHNAHE PRECEDED BY 'DEBUG' */
    DEBUG = FALSE; /* ASSUME NORMAL CASE, NOT DEBUGGING */
    IF SEQ(.('DEBUG'),BUFFER$PTR,5)
    AND (DELIMIT(BUFFER$PTR)=BUFFER$PTR+5) THEN
    DO;
      BUFFER$PTR = DEBLANK(DELIMIT(BUFFER$PTR+5));
      DEBUG = TRUE;
      IF CHAR = CR THEN CALL MONITOR;
    END;
    PATHNAME$PTR = BUFFER$PTR;
    BUFFER$PTR = DELIMIT(DEBLANK(BUFFER$PTR));
    CALL RESCAN(1,.STATUS);
    CALL READ(1,.BUFFER,BUFFER$PTR-.BUFFER,.ACTUAL,.STATUS);
    CALL FORCE$UPPER(PATHNAME$PTR);
    IF DEBUG THEN RETSW = 2; ELSE RETSW = 1;
    CALL LOAD(PATHNAME$PTR,0,RETSW,.ENTRY,.STATUS);
    CALL FILE$ERROR(STATUS,PATHNAME$PTR,FALSE);
    CALL READ(1,.BUFFER,LENGTH(BUFFER),.ACTUAL,.STATUS);
  END;
END;
END;
EOF
clrbuf.plm
clrbuf: do;

clearBuf: procedure(bufp) public;
    declare bufp address;
    declare buf based bufp (1) byte;
    declare i byte;

    do i = 0 to 127;
        buf(i) = 0;
    end;
end;
end;
dblank.plm
DEBLANK: DO;

deblank: procedure(ptr) address public;
	declare ptr address;
	declare c based ptr byte;

	do while (c = ' ');
		ptr = ptr + 1;
	end;
	return ptr;
end;

end;
diskio.plm
diskio: do;
$include(diskio.ipx)

diskio: procedure(drive, iopb) public;
    declare (drive, iopb) address;
    declare params(2) address;

    params(0) = drive;
    params(1) = iopb;
    call isis(44h, .params);
end;
end;
dlimit.plm
DELIMIT: DO;

delimit: procedure(ptr) address public;
	declare ptr address;
	declare c based ptr byte;

	do while (c = ':' or c = '.' or ('0' <= c and c <= '9') or ('A' <= c and c <= 'Z'));
		ptr = ptr + 1;
	end;
	return ptr;
end;
end;
filerr.plm
FILEERROR: DO;
$include(filerr.ipx)

file$error: procedure(status, ptr, callExit) public;
	declare (status, ptr) address, callExit byte;
	declare actual address;

	if status <> 0 then
	do;
		ptr = deblank(ptr);
		call write(0, .(' '), 1, .actual);
		call write(0, ptr, scanblank(ptr) - ptr, .actual);
		call write(0, .(','), 1, .actual);
		call reportError(status);
		if callExit then
			call exit;
	end;
end;
end;
fmttrk.plm
formatTrack: do;
$include(fmttrk.ipx)

FormatTrack: procedure(disk,sTrack,eTrack,interleave) public;
	declare (disk,sTrack,eTrack,interleave) byte;
    declare (i, j, curTrack) byte;
	declare trackBuf(52) byte,
    dcb DCB$T;

	dcb.iocw = 0c0h;
    dcb.ioins = 2;

    do i = 1 to 51 by 2;
            trackbuf(i) = 0c7h;
    end; 
    j = 0;

	do curTrack = sTrack to eTrack;
		do i = 0 to 51 by 2;
			trackBuf(i) = 0;
		end;
		do i = 1 to 26;
			j = (j + interleave) mod 26;
			do while trackBuf(j + j) <> 0;
				j = (j + 1) mod 26;
			end;
			trackBuf(j + j) = i;
		end;
        dcb.tadr = curTrack;
		dcb.buf = .trackBuf;
		call Diskio(disk, .dcb);
	end;
end;
end;
format.patch
p 3B5B 2F 1F D2 F0 3C   # patch due to cma ! jnc -> jc
p 3B7E 7e               # patch due to unneeded mov a,m
p 47e2 4e 06            # patch due to different register usage
p 47e8 09
s 42c8
format.plm
format: do;
$include(format.ipx)
    declare ver(2) byte data(2, 16h);
    declare copyright(*) byte data('(C) 1975,1976 INTEL CORP');
/*
	THE CODE BLOCK BELOW IS LOADED INTO ISIS.T0 ON NON SYSTEM DISKS TO PRINT A MESSAGE
	THE CORRESPONDING ASM CODE IS

		ASEG
		org 3000h

		IN	79H
		IN	7BH
	L3004:	IN	0FFH
		ANI	2
		JNZ	L3004
		LXI	H, MSG
		MVI	B, 32
	L3010:	MOV	C, M
		CALL	0F809H	; CO
		INX	H
		DCR	B
		JNZ	L3010
		RST	0
	MSG:	DB	0DH, 0AH
		DB	'NON-SYSTEM DISK, TRY ANOTHER'
		DB	0DH, 0AH
		END
*/
declare codeblock(*) byte data(0dbh, 79h, 0dbh, 7bh, 0dbh, 0ffh, 0e6h, 2,
			       0c2h, 4, 30h, 21h, 1ah, 30h, 6, 20h, 4eh,
			       0cdh, 9, 0f8h, 23h, 5, 0c2h, 10h, 30h, 0c7h,
			       CR, LF, 'NON-SYSTEM DISK, TRY ANOTHER', CR, LF);
declare attribMap(*) byte data(INVISIBLE$A, SYSTEM$A, WRITEP$A);
declare crlf(2) byte data(CR, LF);

declare buffer(128) byte,
        memSize address, actual address,
        pn(10) byte, bufferPtr address, (i, j, k) address,
        (system, copyall, copy) byte; 
declare (aftin, aftout, dirAft, status) address;
declare srcName(16) byte, dstName(16) byte;

/* the following is in the data segment and newer compilers
   complain if a write attempt is made
   a kludge work around is to defined standard arrays at the same
   locations, these can be modified
*/
declare	xt0File(*) byte data(':FX:ISIS.T0 '),
        xbinFile(*) byte data(':FX:ISIS.BIN '),
        xmapFile(*) byte data(':FX:ISIS.MAP '),
        xlabFile(*) byte data(':FX:ISIS.LAB '),
        xdirFile(*) byte data(':FX:ISIS.DIR ');

declare	t0File(11) byte at(.xt0File),
        binFile(12) byte at(.xbinFile),
        mapFile(12) byte at(.xmapFile),
        labFile(12) byte at(.xlabFile),
        dirFile(12) byte at(.xdirFile);

declare bitmap(256) byte public;
declare currentBitmap byte public initial(0ffh),
        mapChange byte initial(FALSE),
        (baseSector, baseTrack) byte,
        bitmapIndex address,
        mapDCB DCB$T external,
        dcb DCB$T initial(80h, 0, 2, 2, 2, 0);



declare direct DIRECT$T, pad byte;


declare ch based bufferPtr byte;

    copyall, system = FALSE;
    call Read(1, .buffer, 128, .actual, .status);
	buffer(actual) = CR;
	call ForceUpper(.buffer);
	bufferPtr = Deblank(.buffer);
	status = Path(bufferPtr, .pn);
    call FileError(status, bufferPtr, TRUE);
    if pn(0) > 3 then
        call FileError(0CEh, bufferPtr, TRUE);
    if pn(0) = 0 then
        pn(0) = 1;
	t0File(2), binFile(2), mapFile(2), labFile(2), dirFile(2) = pn(0) + '0';
    bufferPtr = deblank(delimit(bufferPtr));

    do while ch <> CR;
        if ch = '$' then
            bufferPtr = deblank(bufferPtr + 1);
        if ch = 'S' then do;
            bufferPtr = deblank(bufferPtr + 1);
            system = TRUE;
        end;
        else if ch = 'A' then do;
            bufferPtr = deblank(bufferPtr + 1);
            copyAll = TRUE;
        end;
        else 
            call FileError(0C9h, bufferPtr, TRUE);
    end;
    labFile(2) = '0';
    call Open(.aftin, .labFile, 1, 0, .status);
    call FileError(status, .labFile, TRUE);
    call Read(aftin, .buffer, 128, .actual, .status);
    call FileError(status, .labFile, TRUE);
    call Close(aftin, .status);
    call FileError(status, .labFile, TRUE);

    labFile(2) = pn(0) + '0';

    do i = 0 to 76;
        call FormatTrack(pn(0), i, i, buffer(33h + i) - '0');
    end;

    call WriteDirectory(pn(0));
    call Open(.aftout, .labFile, 3, 0, .status);
    call FileError(status, .labFile, TRUE);

    call Write(aftout, .pn(1), 9, .status);
    do i = 1 to 40;
        call Write(aftout, .(0), 1, .status);
    end;
    call Write(aftout, .(CR, LF), 2, .status);
    call Write(aftout, .buffer(33h), 77, .status);
    call Close(aftout, .status); 
    call FileError(status, .labFile, TRUE);

	if system or copyAll then
	do;
		if copyAll then
			call Write(0, .('COPYING ALL FILES', CR, LF), 19, .status);
		else
			call Write(0, .('COPYING SYSTEM FILES', CR, LF), 22, .status);

		memSize = (Memck - .Memory) and 0ff80h;
        call Open(.aftout, .t0File, 3, 0, .status);
        call FileError(status, .t0File, TRUE);
        call Open(.aftin, .('ISIS.T0 '), 1, 0, .status);
        call FileError(status, .('ISIS.T0 '), TRUE);

        actual = 1;
        do while actual <> 0;
            call Read(aftin, .memory, memSize, .actual, .status);
            call FileError(status, .('ISIS.T0 '), TRUE);
            call Write(aftout, .memory, actual, .status);
            if actual < memSize then
                actual = 0;
        end;
        call Close(aftout, .status);
        call FileError(status, .t0File, TRUE);
        call Close(aftin, .status);
        call FileError(status, .('ISIS.T0 '), TRUE);

		call Open(.dirAFT, .('ISIS.DIR '), READ$MODE, 0, .status);
		call FileError(status, .('ISIS.DIR '), TRUE);
		direct.empty = 0;
		do while direct.empty <> 7fh;
			call Read(dirAft, .direct, size(direct), .actual, .status);
			call FileError(status, .('ISIS.DIR '), TRUE);
			if actual < size(direct) then
				direct.empty = 7fh;
			else if not direct.empty then
			do;
/* PATCH: Newer compilers optimise cma ! jnc to jc
   add an enable here to keep code length and patch later
*/
                ENABLE;
                copy = ((direct.attrib and SYSTEM$A) <> 0 or copyall)
                       and  (direct.attrib AND FORMAT$A) = 0;
/* PATCH: New compilers optimise mov m,a ! mov a,m to just mov m,a
   add an enable here to keep code length and patch later
*/
                ENABLE;
                if copy then do;
                    direct.empty = 0;
                    call UnPath(.direct, .srcName);
                    direct.empty = pn(0);
                    call UnPath(.direct, .dstName);

					call Open(.aftOut, .dstName, UPDATE$MODE, 0, .status);
					call FileError(status, .dstName, TRUE);
					call Open(.aftIn, .srcName, READ$MODE, 0, .status);
					call FileError(status, .srcName, TRUE);
					actual = 1;
					do while actual <> 0;
						call Read(aftIn, .MEMORY, memSize, .actual, .status);
						call FileError(status, .srcName, TRUE);
						call Write(aftOut, .MEMORY, actual, .status);
                        if actual < memSize then
                            actual = 0;
					end;

					call Close(aftOut, .status);
					call FileError(status, .dstName, TRUE);
					call Close(aftIn, .status);
					call FileError(status, .srcName, TRUE);
					do i = 0 to 2;
						if (attribMap(i) and direct.attrib) <> 0 then
						do;
							call Attrib(.dstName, i, TRUE, .status);
							call FileError(status, .dstName, TRUE);
						end;
					end;
					/* find end of file name skipping :Fx: */
					k = Delimit(.srcName + 4) - .srcName - 4;
					call Write(0, .srcName + 4, k, .status);
					call Write(0, .crlf, 2, .status);
				end;
			end;
		end;
		call Close(dirAft, .status);
        call Attrib(.t0File, 3, 0ffh, .status);
        call Attrib(.binFile, 2, 0ffh, .status);
	end;
	else
	do;
		call Write(0, .('NON-SYSTEM DISKETTE', CR, LF), 21, .status);
		call Open(.aftOut, .t0File, UPDATE$MODE, 0, .status);
		call Write(aftOut, .codeBlock, 58, .status);
		call Close(aftOut, .status);
        call Attrib(.t0File, 3, 0ffh, .status);
		call Delete(.binFile, .status);
	end;

	call Attrib(.dirFile, 3, 0ffh, .status);
	call Attrib(.labFile, 3, 0ffh, .status);
	call Attrib(.mapFile, 3, 0ffh, .status);
	call Exit;
end;
forupp.plm
FORCEUPPER: DO;
$include(forupp.ipx)


forceupper: procedure(bufferPtr) public;
	declare bufferPtr address, ch based bufferPtr byte;

	do while ch <> CR;
		ch = uppercase(ch);
		bufferPtr = bufferPtr + 1;
	end;
end;
end;
isis.bin.cfg
$*=1 A=2 N=1 H=8

isis.bin.plm
3BH: DO;
    DECLARE VER DATA(2,2);

/* COMMON CONTROL CHARACTERS */
DECLARE CONTROL$E LITERALLY '5';
DECLARE BELL LITERALLY '7';
DECLARE BS LITERALLY '8';
DECLARE CR LITERALLY '0DH';
DECLARE LF LITERALLY '0AH';
DECLARE HASH LITERALLY '23H';
DECLARE CARET LITERALLY '5EH';
DECLARE CONTROL$P LITERALLY '10H';
DECLARE CONTROL$Q LITERALLY '11H';
DECLARE CONTROL$R LITERALLY '12H';
DECLARE CONTROL$S LITERALLY '13H';
DECLARE CONTROL$X LITERALLY '18H';
DECLARE CONTROL$Z LITERALLY '1AH';
DECLARE ESC LITERALLY '1BH';
DECLARE DELKEY LITERALLY '7FH';

/* BOOLEAN LITERALS */
DECLARE BOOLEAN LITERALLY 'BYTE';
DECLARE TRUE LITERALLY '0FFH';
DECLARE FALSE LITERALLY '0';

/* CONSOLE LITERALS */
DECLARE AFT$CONSOL$IN LITERALLY '5';
DECLARE AFT$CONSOL$OUT LITERALLY '4';
DECLARE READ$MODE LITERALLY '1';
DECLARE WRITE$MODE LITERALLY '2';
DECLARE UPDATE$MODE LITERALLY '3';

/* SEEK OPTIONS */
DECLARE SEEK$RETURN LITERALLY '0';
DECLARE SEEK$BACKWARD LITERALLY '1';
DECLARE SEEK$ABS LITERALLY '2';
DECLARE SEEK$FORWARD LITERALLY '3';
DECLARE SEEK$EOF LITERALLY '4';

/* ERROR CODES */
DECLARE OK LITERALLY '0';
DECLARE NO$FREE$BUFFER LITERALLY '1';
DECLARE BAD$AFT$NO LITERALLY '2';

DECLARE AFT$FULL LITERALLY '3';
DECLARE BAD$PATH LITERALLY '4';
DECLARE BAD$DEVICE LITERALLY '5';
DECLARE CANT$WRITE LITERALLY '6';
DECLARE DISK$FULL LITERALLY '7';
DECLARE CANT$READ LITERALLY '8';
DECLARE DIRECTORY$FULL LITERALLY '9';
DECLARE DIFFERENT$DISK LITERALLY '10';
DECLARE MULTIDEFINED LITERALLY '11';
DECLARE ALREADY$OPEN LITERALLY '12';
DECLARE NO$SUCH$FILE LITERALLY '13';
DECLARE WRITE$PROTECT LITERALLY '14';
DECLARE ISIS$OVERWRITE LITERALLY '15';
DECLARE BAD$LOAD$FORMAT LITERALLY '16';
DECLARE NON$DISK$FILE LITERALLY '17';
DECLARE BAD$COMMAND LITERALLY '18';
DECLARE NON$DISK$SEEK LITERALLY '19';
DECLARE LONG$BACK$SEEK LITERALLY '20';
DECLARE CANT$RESCAN LITERALLY '21';
DECLARE BAD$ACCESS LITERALLY '22';
DECLARE NULL$FILENAME LITERALLY '23';
DECLARE DISK$IO$ERROR LITERALLY '24';
DECLARE BAD$ECHO LITERALLY '25';
DECLARE BAD$ATTRIB LITERALLY '26';
DECLARE BAD$SEEK$ARG LITERALLY '27';
DECLARE NULL$EXTENSION LITERALLY '28';
DECLARE CONSOLE$EOF LITERALLY '29';
DECLARE DRIVE$NOT$READY LITERALLY '30';
DECLARE SEEK$ON$WRITE LITERALLY '31';
DECLARE CANT$DELETE LITERALLY '32';
DECLARE BAD$PARAMETER LITERALLY '33';
DECLARE BAD$RETSW LITERALLY '34';
DECLARE SEEK$PAST$EOF LITERALLY '35';

DECLARE WARNING LITERALLY '0';
DECLARE MESSAGE LITERALLY '1';
DECLARE ABORT LITERALLY '2';
DECLARE CMSK LITERALLY '0FCH';

/* ATTRIBUTES */
DECLARE INVISIBLE$ATTRIBUTE LITERALLY '1';
DECLARE SYSTEM$ATTRIBUTE LITERALLY '2';
DECLARE WRITEP$ATTRIBUTE LITERALLY '4';
DECLARE FORMAT$ATTRIBUTE LITERALLY '80H';

/* ACCESS MODE */
DECLARE ACCESS$READ LITERALLY '1';
DECLARE ACCESS$WRITE LITERALLY '2';

/* OMF RECORD TYPES */
DECLARE R$MODHDR LITERALLY '2';
DECLARE R$MODEND LITERALLY '4';
DECLARE R$CONTENT LITERALLY '6';
DECLARE R$RELOC LITERALLY '22H';

DECLARE AFT$BOTTOM LITERALLY '4';
DECLARE AFT$FIRST LITERALLY   '6';
DECLARE AFT$LAST LITERALLY '11';
DECLARE F3DEV LITERALLY '3';
DECLARE CIDEV LITERALLY '21';
DECLARE CODEV LITERALLY '22';
DECLARE BBDEV LITERALLY '20';

DECLARE BLINK LITERALLY '0';
DECLARE FLINK LITERALLY '1';

DECLARE CMD$RECAL LITERALLY '3';
DECLARE CMD$READ LITERALLY '4';
DECLARE CMD$WRITE LITERALLY '6';

DECLARE MDSMON LITERALLY '0';
DECLARE BTSTRP LITERALLY '8';

ISIS: PROCEDURE(COMMAND, PARAMETER$BLOCK);
    DECLARE COMMAND BYTE, PARAMETER$BLOCK ADDRESS;
    DECLARE PARAM BASED PARAMETER$BLOCK (5) ADDRESS;
    DECLARE COPYRIGHT DATA('(C) 1975,1976 INTEL CORP');
    DECLARE I BYTE;
    DECLARE SYSPARAM(0) ADDRESS;
    DECLARE USERSTATUS$P ADDRESS, USERSTATUS BASED USERSTATUS$P ADDRESS;
    DECLARE (PARAM1, PARAM2, PARAM3, PARAM4, PARAM5) ADDRESS;
    DECLARE RETPARAMIDX(14) BYTE INITIAL( 5, 2, 2, 5, 4, 5, 5, 3,
                                         3, 1, 4, 2, 2, 3);
    DECLARE PARAMTYPE(5) ADDRESS INITIAL(
                111110001010B,    /* BIT SET IF PARAMETER NEEDS TO CHECK FOR */
                111001100111110B,    /* ADDRESS BELOW MEMORY (3000H) */
                100001101000000B,
                100001110000B,
                11010010B);

    DECLARE COLD$START$FLAG BOOLEAN INITIAL (TRUE);
    DECLARE (COLD$CIDEV, ALT$CIDEV) BYTE;
    DECLARE USERSP ADDRESS;
    DECLARE USRSTK(32) BYTE INITIAL(0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,
                                    0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,
                                    0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,
                                    0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,0C7H,0C7H);
    DECLARE TOPSTACK(0) BYTE;

    CI: PROCEDURE BYTE;
        GOTO 0F803H;
    END;

    RI: PROCEDURE BYTE;
        GOTO 0F806H;
    END;

    CO: PROCEDURE(CH);
        DECLARE CH BYTE;
        GOTO 0F809H;
    END;

    PO: PROCEDURE(CH);
        DECLARE CH BYTE;
        GOTO 0F80CH;
    END;

    LO: PROCEDURE(CH);
        DECLARE CH BYTE;
        GOTO 0F80FH;
    END;

    IOCHK: PROCEDURE BYTE;
        GOTO 0F815H;
    END;

    IOSET: PROCEDURE(CH);
        DECLARE CH BYTE;
        GOTO 0F818H;
    END;


    CSTS: PROCEDURE BYTE;
        GOTO 0F812H;
    END;

    MEMCK: PROCEDURE ADDRESS;
        GOTO 0F81BH;
    END;

    BINASC: PROCEDURE(VALUE, BASE, LC, BUFADR, WIDTH);
        DECLARE (VALUE, BUFADR) ADDRESS, (BASE, LC, WIDTH) BYTE;
        DECLARE DIGITS DATA('0123456789ABCDEF');
        DECLARE I BYTE;
        DECLARE BUF BASED BUFADR (1) BYTE;

        DO I = 1 TO WIDTH;
            BUF(WIDTH - I) = DIGITS(VALUE MOD BASE);
            VALUE = VALUE / BASE;
        END;

        I = 0;
        DO WHILE BUF(I) = '0' AND I < WIDTH - 1;
            BUF(I) = LC;
            I = I + 1;
        END;
    END;

    DECLARE STATUS ADDRESS;
    DECLARE DEBUG$TOGGLE BYTE INITIAL(0);
    DECLARE GLOBAL$SEVERITY BYTE INITIAL(0);
    DECLARE FDCC$ERROR$TYPE ADDRESS INITIAL(0);
    DECLARE INITIO$BASE ADDRESS INITIAL(6), INITIO BASED INITIO$BASE BYTE;

    ERR: PROCEDURE(SEVERITY, ERROR$TYPE);
        DECLARE (SEVERITY, ERROR$TYPE, I, IMAX) BYTE;
        DECLARE PC BASED USER$SP ADDRESS;
        DECLARE MSG1(8) BYTE INITIAL(CR, LF, 'ERROR '),
                MSG2(3) BYTE INITIAL(0, 0, 0), /* ERROR NUMBER GOES HERE */
                MSG3(9) BYTE INITIAL(' USER PC '),
                MSG4(4) BYTE INITIAL(0,0,0,0), /* USER PC IN HEX GOES HERE */
                MSG5(2) BYTE INITIAL(CR, LF),
                MSG6(5) BYTE INITIAL('FDCC='),
                MSG7(4) BYTE INITIAL(0,0,0,0), /* FDCC ERROR DATA GOES HERE */
                MSG8(2) BYTE INITIAL(CR, LF);

        IF (SEVERITY := SEVERITY OR GLOBAL$SEVERITY) <> WARNING THEN
        DO;
            CALL BINASC(ERROR$TYPE, 10, 0, .MSG2, 3);
            CALL BINASC(PC,16,'0',.MSG4,4);
            CALL IOSET((IOCHK AND CMSK) OR (INITIO AND 3));
            IMAX = 25;  /* NUMBER OF CHARACTERS IN NORMAL ERROR MESSAGE */
            IF ERROR$TYPE = DISK$IO$ERROR THEN
            DO;
                IMAX = 36;
                CALL BINASC(FDCC$ERROR$TYPE, 16, '0', .MSG7, 4);
            END;
            DO I = 0 TO IMAX;
                CALL CO(MSG1(I));
            END;
        END;
        ELSE
        DO;
            USER$STATUS = ERROR$TYPE;
            STACKPTR = USER$SP;
        END;
        IF SEVERITY >= ABORT THEN
        DO;
            IF DEBUG$TOGGLE THEN
                GOTO MDSMON;    /* EXIT VIA MONITOR */
            GOTO BTSTRP;        /* EXIT VIA SOFTWARE BOOTSTRAP */
        END;
    END;

    DECLARE BUFFER$TABLE(19) BYTE INITIAL(0,0,0,0,0,0,0,0,0,0,
                             0,0,0,0,0,0,0,0,0);

    CLRBUF: PROCEDURE(BUFFER$P);
        DECLARE BUFFER$P ADDRESS;
        DECLARE BUFFER BASED BUFFER$P (128) BYTE;
        DECLARE I BYTE;

        DO I = 0 TO 127;
            BUFFER(I) = 0;
        END;
    END;


    FREEBUF: PROCEDURE(BUFFER);
        DECLARE BUFFER ADDRESS;

        BUFFER$TABLE(SHR(BUFFER - .MEMORY, 7)) = 0;
    END;

    GETBUF: PROCEDURE ADDRESS;
        DECLARE I BYTE;

        DO I = 0 TO LAST(BUFFER$TABLE);
            IF BUFFER$TABLE(I) = 0 THEN
            DO;
                BUFFER$TABLE(I) = 2;
                RETURN .MEMORY + SHL(DOUBLE(I), 7);
            END;
        END;
        CALL ERR(ABORT, NO$FREE$BUFFER);
    END;

    /* THE AFT TABLES AND POINTERS TO CURRENTLY SELECTED ENTRY */
    DECLARE AFT$CURRENT BYTE INITIAL(0FFH);
    DECLARE POINTER$BASE ADDRESS, LINKS BASED POINTER$BASE (64) ADDRESS;
    DECLARE DATUM$BASE ADDRESS, DATUM BASED DATUM$BASE (128) BYTE;
    DECLARE CLOSED$P ADDRESS, CUR$CLOSED BASED CLOSED$P BYTE;
    DECLARE DEVICE$P ADDRESS, CUR$DEVICE BASED DEVICE$P BYTE;
    DECLARE ACCESS$P ADDRESS, CUR$ACCESS BASED ACCESS$P BYTE;
    DECLARE ECHOAFT$P ADDRESS, CUR$ECHOAFT BASED ECHOAFT$P BYTE;
    DECLARE EBUF$P ADDRESS, CUR$EBUF BASED EBUF$P ADDRESS;
    DECLARE DBUF$P ADDRESS, CUR$DBUF BASED DBUF$P ADDRESS;
    DECLARE BYTENO$P ADDRESS, CUR$BYTENO BASED BYTENO$P BYTE;
    DECLARE DNUM$P ADDRESS, CUR$DNUM BASED DNUM$P ADDRESS;
    DECLARE LBUF$P ADDRESS, CUR$LBUF BASED LBUF$P ADDRESS;
    DECLARE DPTR$P ADDRESS, CUR$DPTR BASED DPTR$P BYTE;
    DECLARE LASTBYTE$P ADDRESS, CUR$LASTBYTE BASED LASTBYTE$P BYTE;
    DECLARE ALLOC$P ADDRESS, CUR$ALLOC BASED ALLOC$P BYTE;
    DECLARE DMOD$P ADDRESS, CUR$DMOD BASED DMOD$P BYTE;
    DECLARE BLKCNT$P ADDRESS, CUR$BLKCNT BASED BLKCNT$P ADDRESS;
    DECLARE BLKNO$P ADDRESS, CUR$BLKNO BASED BLKNO$P ADDRESS;
    DECLARE LADDR$P ADDRESS, CUR$LADDR BASED LADDR$P ADDRESS;
    DECLARE L1ADDR$P ADDRESS, CUR$L1ADDR BASED L1ADDR$P ADDRESS;
    DECLARE DADDR$P ADDRESS, CUR$DADDR BASED DADDR$P ADDRESS;


    DECLARE CLOSED(12) BYTE INITIAL(0, 0, 0, 0, 0FFH, 0FFH, 0FFH, 0FFH,
                                    0FFH, 0FFH, 0FFH, 0FFH);
    DECLARE DEVICE(12) BYTE INITIAL(0, 1, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0);
    DECLARE ACCESS(12) BYTE INITIAL(3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0);
    DECLARE ECHOAFT(12) BYTE INITIAL(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    DECLARE EBUF(12) ADDRESS;
    DECLARE DBUF(12) ADDRESS;
    DECLARE BYTENO(12) BYTE INITIAL(128, 128, 128, 128, 0, 0, 0, 0, 0, 0, 0, 0);
    DECLARE DNUM(12) ADDRESS INITIAL(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    DECLARE LBUF(12) ADDRESS INITIAL(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    DECLARE DPTR(12) BYTE INITIAL(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    DECLARE LASTBYTE(12) BYTE INITIAL(128, 128, 128, 128, 0, 0, 0,
                                      0, 0, 0, 0, 0);
    DECLARE ALLOC(12) BYTE INITIAL(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    DECLARE DMOD(12) BYTE INITIAL(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    DECLARE BLKCNT(12) ADDRESS INITIAL(25, 25, 25, 25, 0, 0, 0, 0, 0, 0, 0, 0);
    DECLARE BLKNO(12) ADDRESS INITIAL(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    DECLARE LADDR(12) ADDRESS INITIAL(101H, 101H, 101H, 101H, 0, 0,
                                      0, 0, 0, 0, 0, 0);
    DECLARE L1ADDR(12) ADDRESS INITIAL(101H, 101H, 101H, 101H, 0, 0,
                                       0, 0, 0, 0, 0, 0);
    DECLARE DADDR(12) ADDRESS INITIAL(102H, 102H, 102H, 102H, 0, 0, 0,
                                      0, 0, 0, 0, 0);


    SETTABS: PROCEDURE(AFT);
        DECLARE AFT BYTE;

        IF AFT$CURRENT <> AFT THEN
        DO;
            AFT$CURRENT = AFT;
            CLOSED$P = .CLOSED(AFT);
            DEVICE$P = .DEVICE(AFT);
            ACCESS$P = .ACCESS(AFT);
            ECHOAFT$P = .ECHOAFT(AFT);
            EBUF$P = .EBUF(AFT);
            BYTENO$P = .BYTENO(AFT);
            DNUM$P = .DNUM(AFT);
            DPTR$P = .DPTR(AFT);
            LASTBYTE$P = .LASTBYTE(AFT);
            BLKNO$P = .BLKNO(AFT);
            ALLOC$P = .ALLOC(AFT);
            DMOD$P = .DMOD(AFT);
            BLKCNT$P = .BLKCNT(AFT);
            LADDR$P = .LADDR(AFT);
            L1ADDR$P = .L1ADDR(AFT);
            DADDR$P = .DADDR(AFT);
        END;
        LBUF$P = .LBUF(AFT);
        DBUF$P = .DBUF(AFT);
        POINTER$BASE = CUR$LBUF;
        DATUM$BASE = CUR$DBUF;
    END;

    GETAFT: PROCEDURE BYTE;
        DECLARE I BYTE;

        DO I = AFT$BOTTOM TO AFT$LAST;
            IF CLOSED(I) THEN
                RETURN I;
        END;
        CALL ERR(ABORT, AFT$FULL);
    END;

    PACKBUFS: PROCEDURE ADDRESS;
        DECLARE I BYTE, BUFFER$TOP ADDRESS;

        LOWBUF: PROCEDURE(BUFPTR);
            DECLARE BUFPTR ADDRESS;
            DECLARE (NEWBUF, OLDBUF) ADDRESS, I BYTE;
            DECLARE BUFFER BASED BUFPTR ADDRESS,
                    NBUF BASED NEWBUF (128) BYTE,
                    OBUF BASED OLDBUF (128) BYTE;

            I = SHR(BUFFER - .MEMORY, 7);
            IF BUFFER$TABLE(I) <> 2 THEN
                RETURN;
            OLDBUF = BUFFER;
            CALL FREEBUF(OLDBUF);
            NEWBUF = GETBUF;
            IF BUFFER$TOP < NEWBUF THEN
                BUFFER$TOP = NEWBUF;
            IF NEWBUF = OLDBUF THEN
                RETURN;
            DO I = 0 TO 127;
                NBUF(I) = OBUF(I);
            END;
            BUFFER = NEWBUF;
        END;

        BUFFER$TOP = .MEMORY;
        DO I = AFT$BOTTOM TO AFT$LAST;
            CALL LOWBUF(.LBUF(I));
            CALL LOWBUF(.DBUF(I));
            CALL LOWBUF(.EBUF(I));
        END;
        RETURN BUFFER$TOP + 128;
    END;

    /*
       XEQIOPB PROVIDES ACCESS TO THE FDCC
       CONTROLLER 1 = BASE ADDRESS 78H (DRIVES 0, 1 FOR SD)
       CONTROLLER 2 = BASE ADDRESS 88H (DRIVES 2, 3 FOR SD)

       DRIVE: AN INTEGER 0-3, SPECIFYING THE DISK TO BE ACCESSED
       IOPB:  THE ADDRESS OF A PARAMETER BLOCK TO BE SENT TO THE
          FDCC CONTROLLER. THIS PARAMETER MUST BE SET UP
          AS IF IT WERE FOR DRIVE 0; IF 'DRIVE' SELECTS
          ANOTHER DRIVE, 'DISKIO' WILL SET ALL THE NECESSARY
          BITS

       THE CALLER PROVIDES A PARAMETER BLOCK SPECIFYING SOME
       VALID DISK OPERATION ON DRIVE 0 AND AN INTEGER DRIVE SELECT VALUE
       IN THIS BOOT CODE ONLY READ AND RECAL ARE USED
       THE PROCEDURE WAITS FOR THE CONTROLLER TO GO UNBUSY, THEN
       PERFORMS THE DESIRED ACTION. IN CASE OF A CONTROLLER ERROR,
       THE DISK DRIVE IS RECALIBRATED AND THE ACTION IS TRIED AGAIN.
       IF SUCCESSFUL COMPLETION CANNOT BE OBTAINED AFTER 'MAX$RETRIES'
       ATTEMPTS, A FATAL ERROR OCCURS, OTHERWISE A NORMAL RETURN IS MADE

    */
        DECLARE FDCC$STATUS$0   LITERALLY   '78H',
                FDCC$STATUS$1   LITERALLY   '88H',
                RESULT$TYPE$0   LITERALLY   '79H',
                RESULT$TYPE$1   LITERALLY   '89H',
                RESULT$BYTE$0   LITERALLY   '7BH',
                RESULT$BYTE$1   LITERALLY   '8BH',
                LOW$ADDRESS$0   LITERALLY   '79H',
                LOW$ADDRESS$1   LITERALLY   '89H',
                HIGH$ADDRESS$0  LITERALLY   '7AH',
                HIGH$ADDRESS$1  LITERALLY   '8AH';

        DECLARE MAX$RETRIES     LITERALLY   '10',
                DISK$DONE       LITERALLY   '4',
                READ$COMMAND    LITERALLY   '4',
                WRITE$COMMAND   LITERALLY   '6',
                RECALIBRATE     LITERALLY   '3';

        DECLARE IOCW    LITERALLY '0',      /* IOPB OFFSETS */
                IOINS   LITERALLY '1',
                NSEC    LITERALLY '2',
                TADR    LITERALLY '3',
                SADR    LITERALLY '4',
                BUFLO   LITERALLY '5',
                BUFHI   LITERALLY '6';


    XEQIOPB: PROCEDURE(DRIVE, IOPB);
        /* THIS PROCEDURE ISSUES THE IOPB TO THE DISK CONTROLLER, IN THE */
        /* CASE OF THE 8271 IT ALSO TRANSFERS THE DATA BYTE BY BYTE */
        DECLARE DRIVE BYTE; /* DRIVE NUMBER: ASSUMES VALUE 0,1,2,3 */
        DECLARE IOPB ADDRESS;   /* POINTER TO THE PARAMATER BLOCK NAMED DCB */
        DECLARE DCB BASED IOPB (7) BYTE;

        DECLARE TEMPA(0) ADDRESS;
        DECLARE (TEMP2, TEMP1, JNK) BYTE;

        /* RECALIBRATE COMMAND */
        DECLARE RECAL$PB(5) BYTE INITIAL(80H, RECALIBRATE, 0, 0, 0);

        DECLARE I BYTE;     /* INDEX VARIABLE IN FOR STATEMENTS */
        DECLARE IVAL BYTE;  /* INTERRUPT MASK VALUE */

        DISK$STAT: PROCEDURE BYTE; /* RETURN THE DISK DRIVE STATUS */
            IF ROR(DRIVE, 1) THEN    /* DRIVE 1 */
                RETURN INPUT(FDCC$STATUS$1);
            RETURN INPUT(FDCC$STATUS$0);
        END;


        R$TYPE: PROCEDURE BYTE; /* RETURN THE RESULT TYPE OF A DISK OPERATION */
            IF ROR(DRIVE, 1) THEN
                RETURN INPUT(RESULT$TYPE$1);
            RETURN INPUT(RESULT$TYPE$0);
        END;


        R$BYTE: PROCEDURE BYTE; /* RETURN THE REULT BYTE OF A DISK OPERATION */
            IF ROR(DRIVE, 1) THEN
                RETURN INPUT(RESULT$BYTE$1);
            RETURN INPUT(RESULT$BYTE$0);
        END;

        /*
           START$IO OUTPUTS THE ADDRESS OF THE IOPB TO THE DISK CONTROLLER
        */
        START$IO: PROCEDURE(IOPB);
            DECLARE IOPB ADDRESS;

            IF ROR(DRIVE, 1) THEN
            DO;
                OUTPUT(LOW$ADDRESS$1) = LOW(IOPB);
                OUTPUT(HIGH$ADDRESS$1) = HIGH(IOPB);
            END;
            ELSE
            DO;
                OUTPUT(LOW$ADDRESS$0) = LOW(IOPB);
                OUTPUT(HIGH$ADDRESS$0) = HIGH(IOPB);
            END;
        END;


        IVAL = INPUT(0FCH);
        OUTPUT(0FCH) = IVAL OR 2; /* PREVENT  REENTRANCY */

        RECAL$PB(IOINS) = RECALIBRATE;
        RECAL$PB(SADR) = 0;
        IF DRIVE THEN
        DO;
            DCB(IOINS) = DCB(IOINS) OR 30H;
            DCB(SADR) = DCB(SADR) OR 20H;
            RECAL$PB(IOINS) = RECALIBRATE OR 30H;
            RECAL$PB(SADR) = 20H;
        END;

        DO I = 0 TO MAX$RETRIES;

            DO WHILE (DISK$STAT AND DISK$DONE) <> 0;
                TEMP1 = R$TYPE;
                TEMP1 = R$BYTE;
            END;
            /* IF DISK DRIVE NOT READY, GIVE FATAL ERROR */
            IF (DISK$STAT AND ((DRIVE AND 1) + 1)) = 0 THEN
                CALL ERR(ABORT, DRIVE$NOT$READY);

            CALL START$IO(IOPB);
            DO WHILE (DISK$STAT AND DISK$DONE) = 0;
                ;
            END;
            TEMP1 = R$TYPE;
            IF (TEMP2 := R$BYTE) = 0 THEN
            DO;
                OUTPUT(0FCH) = IVAL;    /* RESTORE INTERRUPT 1 */
                RETURN;
            END;
            CALL START$IO(.RECAL$PB);
            DO WHILE (DISK$STAT AND DISK$DONE) = 0;
                ;
            END;
        END;
        FDCC$ERROR$TYPE = TEMPA;
        CALL ERR(ABORT, DISK$IO$ERROR);
    END;


    XIO: PROCEDURE(OPCODE, DRIVE, TRKSEC, BUFFER);
        DECLARE (OPCODE, DRIVE) BYTE, (TRKSEC, BUFFER) ADDRESS;
        DECLARE DCB(10) BYTE INITIAL(80H, 0, 0, 0, 0, 0, 0, 0, 0, 0);

        DCB(IOINS) = OPCODE;
        DCB(NSEC) = 1;
        DCB(TADR) = HIGH(TRKSEC);
        DCB(SADR) = LOW(TRKSEC);
        DCB(BUFLO) = LOW(BUFFER);
        DCB(BUFHI) = HIGH(BUFFER);
        CALL XEQIOPB(DRIVE, .DCB);
    END;

    RDSEC: PROCEDURE(TRKSEC, BUFFER);
         DECLARE (TRKSEC, BUFFER) ADDRESS;
         CALL XIO(CMD$READ, CUR$DEVICE, TRKSEC, BUFFER);
    END;

    WRSEC: PROCEDURE(TRKSEC, BUFFER);
        DECLARE (TRKSEC, BUFFER) ADDRESS;
        CALL XIO(CMD$WRITE, CUR$DEVICE, TRKSEC, BUFFER);
    END;

    DECLARE (PN, PN2) (10) BYTE;

    DECLARE DEVICENAMES DATA('F0F1F2F3TITOVIVOI1O1TRHRR1R2TPHPP1P2LPL1BBCICO');
    DECLARE FULLNAME(15) BYTE;

    TOUPPER: PROCEDURE(CH) BYTE;
        DECLARE CH BYTE;
        IF CH < 61H THEN    /* LOWER CASE A */
            RETURN CH;
        IF CH > 7AH THEN    /* LOWER CASE Z */
            RETURN CH;
        RETURN CH AND 0DFH;
    END;

    CANON: PROCEDURE(FILENAME, INTFN$P) BYTE;
        DECLARE (FILENAME, INTFN$P) ADDRESS;
        DECLARE PATHCH BASED FILENAME BYTE; /* CHAR OF FILENAME POINTS TO */
        DECLARE PATHCHARS BASED FILENAME (1) BYTE;
        DECLARE INTFN BASED INTFN$P (10) BYTE;  /* BYTE VERSION OF INTFN  */
        DECLARE STARTNAME ADDRESS, STARTCH BASED STARTNAME BYTE;
        DECLARE DEVPAIR(0) ADDRESS, (FIRST, SECOND) BYTE;
        DECLARE DEVPTR ADDRESS, DEVNAME BASED DEVPTR ADDRESS;
        DECLARE NULL$NAME BYTE;
        DECLARE (J, I) BYTE;


        ALPHANUM: PROCEDURE BOOLEAN;
            RETURN (PATHCH >= 'A' AND PATHCH <= 'Z')
                OR (PATHCH >= '0' AND PATHCH <= '9')
                OR (PATHCH >= 61H AND PATHCH <= 7AH);   /* LOWER CASE A-Z */
        END;

        DEVPTR = .DEVICENAMES;

        DO I = 0 TO LAST(INTFN);    /* CLEAR INTFN */
            INTFN(I) = 0;
        END;
        DO WHILE PATHCH = ' ';  /* SKIP LEADING SPACE */
            FILENAME = FILENAME + 1;
        END;
        STARTNAME = FILENAME;
        IF PATHCH = ':' THEN
        DO;
            INTFN(0) = 0FFH;
            IF PATHCHARS(3) <> ':' THEN
                RETURN BAD$PATH;
            FILENAME = FILENAME + 1;    /* PAST ':' */
            FIRST = TOUPPER(PATHCH);
            FILENAME = FILENAME + 1;
            SECOND = TOUPPER(PATHCH);
            FILENAME = FILENAME + 2;

            I =  0;
            DO WHILE I < 45; /* SIZE(DEVICENAMES) */
                IF DEVNAME = DEVPAIR THEN
                    INTFN(0) = SHR(I, 1);   /* SAVE DEVICE NUMBER */
                I = I + 2;
                DEVPTR = DEVPTR + 2;
            END;
            IF INTFN(0) = 0FFH THEN
                RETURN BAD$DEVICE;
        END;

        NULL$NAME = TRUE;
        I = 1;
        DO WHILE I < 7;
            IF ALPHANUM THEN
            DO;
                INTFN(I) = TOUPPER(PATHCH);
                FILENAME = FILENAME + 1;
                NULL$NAME = FALSE;
            END;
            I = I + 1;
        END;
        IF PATHCH = '.' THEN
        DO;
            FILENAME = FILENAME + 1;
            I = 7;
            DO WHILE I < 10;
                IF ALPHANUM THEN
                DO;
                    INTFN(I) = TOUPPER(PATHCH);
                    FILENAME = FILENAME + 1;
                END;
                I = I + 1;
            END;
        END;
        IF INTFN(0) <= F3DEV AND NULL$NAME THEN
            RETURN NULL$FILENAME;
        J =  -1;
        DO WHILE STARTNAME < FILENAME;
            J = J + 1;
            FULLNAME(J) = STARTCH;
            STARTNAME = STARTNAME + 1;
        END;
        IF FULLNAME(J) = '.' THEN
            RETURN NULL$EXTENSION;
        FULLNAME(J + 1) = ' ';
        IF ALPHANUM  OR PATHCH = '.' OR PATHCH = ':' THEN
            RETURN BAD$PATH;
        RETURN OK;
    END;

    GETFN: PROCEDURE(FILENAME, INTFN$P);
        DECLARE (FILENAME, INTFN$P) ADDRESS;

        IF (STATUS := CANON(FILENAME, INTFN$P)) <> 0 THEN
            CALL ERR(WARNING, STATUS);
    END;


    DECLARE BITMAPBUFFER(256) BYTE,
        CURRENT$BITMAP BYTE INITIAL(0FFH),
        MAP$CHANGE BYTE INITIAL(FALSE),
        BASETRKSEC(0) ADDRESS, (BASESECTOR, BASETRACK) BYTE,
        BITMAPINDEX ADDRESS,
        MAP$DCB(10) BYTE INITIAL(80H, 0, 2, 2, 2, 0, 0, 0, 0, 0),
        BITMASK(8) BYTE INITIAL(80H, 40H, 20H, 10H, 8, 4, 2, 1);

    RWMAP: PROCEDURE(DRIVE, OPCD);
        DECLARE (DRIVE, OPCD) BYTE;
        DECLARE TMP BYTE;

        OPMAP: PROCEDURE;
            MAP$CHANGE = FALSE;
            BITMAPINDEX = 0;
            BASETRKSEC = 1;
            MAP$DCB(IOINS) = OPCD;
            MAP$DCB(BUFLO) = LOW(.BITMAPBUFFER);
            MAP$DCB(BUFHI) = HIGH(.BITMAPBUFFER);
            CALL XEQIOPB(DRIVE, .MAP$DCB);

        END;

        IF DRIVE <> CURRENT$BITMAP THEN
        DO;
            IF OPCD = CMD$WRITE THEN
                RETURN;
            IF CURRENT$BITMAP <> 0FFH AND MAP$CHANGE THEN
            DO;
                OPCD = CMD$WRITE;
                TMP = DRIVE;
                DRIVE = CURRENT$BITMAP;
                CALL OPMAP;
                OPCD = CMD$READ;
                DRIVE = TMP;
            END;
            CURRENT$BITMAP = DRIVE;
            CALL OPMAP;
        END;
        ELSE IF OPCD = CMD$WRITE THEN
            CALL OPMAP;
    END;


    ALLOCATE: PROCEDURE(DRIVE) ADDRESS;
        DECLARE DRIVE BYTE;
        DECLARE BITNO BYTE;
        DECLARE TRKSEC(0) ADDRESS, (SECTOR, TRACK) BYTE;
        DECLARE BITMAPBYTE$P ADDRESS, BITMAPBYTE BASED BITMAPBYTE$P BYTE;

        CALL RWMAP(DRIVE, CMD$READ);

        DO TRACK = BASETRACK TO 76;
            DO SECTOR = BASESECTOR TO 26;
                BITNO = LOW(BITMAPINDEX) AND 7;
                BITMAPBYTE$P = .BITMAPBUFFER + SHR(BITMAPINDEX, 3);
                IF (BITMASK(BITNO) AND BITMAPBYTE) = 0 THEN /* FOUND A SLOT */
                    DO;
                        MAP$CHANGE = TRUE;
                        BITMAPBYTE = BITMAPBYTE OR BITMASK(BITNO);
                        BASETRKSEC = TRKSEC;
                        RETURN TRKSEC;
                    END;
                BITMAPINDEX = BITMAPINDEX + 1;
            END;
            BASESECTOR = 1;
        END;
        CALL ERR(ABORT, DISK$FULL);
    END;

    DEALLOC: PROCEDURE(DRIVE, TRKSEC);
        DECLARE DRIVE BYTE, TRKSEC ADDRESS;
        DECLARE BITMAPBYTE$P ADDRESS, BITMAPBYTE BASED BITMAPBYTE$P BYTE;
        DECLARE BITNO BYTE;

        CALL RWMAP(DRIVE, CMD$READ);
        IF (BITMAPBYTE$P := HIGH(TRKSEC) * 26 + LOW(TRKSEC) - 1) <
                                                        BITMAPINDEX THEN
        DO;
            BITMAPINDEX = BITMAPBYTE$P;
            BASETRKSEC = TRKSEC;
        END;
        BITNO = LOW(BITMAPBYTE$P) AND 7;
        BITMAPBYTE$P = .BITMAPBUFFER + SHR(BITMAPBYTE$P, 3);
        BITMAPBYTE = BITMAPBYTE AND NOT BITMASK(BITNO);
        MAP$CHANGE = TRUE;
    END;


    DECLARE MAXLL   LITERALLY   '122';  /* MAXIMUM LINE LENGTH */

    DECLARE IOBYTEMASKS DATA(0FFH, 0FFH, 0FFH, 0FFH, 0FCH, 0FCH, 0FCH, 0FCH,
                     0FCH, 0FCH, 0F3H, 0F3H, 0F3H, 0F3H, 0CFH, 0CFH, 0CFH, 0CFH,
                     3FH, 3FH, 0FFH, 0FFH, 0FFH);

    DECLARE IOBYTEFLAGS DATA(0, 0, 0, 0, 0, 0, 1, 1,
                     3, 3, 0, 4, 8, 0CH, 0, 10H, 20H,
                     30H, 80H, 0C0H, 0, 0, 0);

    SIZECK: PROCEDURE;
        IF CUR$BLKNO = CUR$BLKCNT AND CUR$LASTBYTE < CUR$BYTENO THEN
            CUR$LASTBYTE = CUR$BYTENO;
        IF CUR$BLKNO > CUR$BLKCNT THEN
        DO;
            CUR$BLKCNT = CUR$BLKNO;
            CUR$LASTBYTE = CUR$BYTENO;
        END;
    END;


    FIO: PROCEDURE(AFTN, BUFFER, COUNT, ACTUAL$P, READFLAG);
        DECLARE AFTN BYTE, (BUFFER, COUNT, ACTUAL$P) ADDRESS, READFLAG BYTE;
        DECLARE ACTUAL BASED ACTUAL$P ADDRESS;
        DECLARE NEEDWRITE BYTE, (WORK$BUF, NEWLINKS$P) ADDRESS;
        DECLARE NEWLINKS BASED NEWLINKS$P (64) ADDRESS;
        DECLARE BUFCH BASED BUFFER BYTE;

        GETD: PROCEDURE;
            IF CUR$DADDR <> 0 THEN
                RETURN;

            CUR$ALLOC = TRUE;

            CUR$BLKNO = CUR$BLKNO - 1;
            LINKS(CUR$DPTR), CUR$DADDR = ALLOCATE(CUR$DEVICE);
            CUR$BLKNO = CUR$BLKNO + 1;

            IF CUR$ACCESS = 3 THEN
            DO;
                CALL CLRBUF(CUR$DBUF);
                CALL WRSEC(CUR$DADDR, CUR$DBUF);
            END;
        END;


        ACTUAL = 0;

        DO WHILE COUNT > ACTUAL;
            IF CUR$BLKCNT <= CUR$BLKNO AND READFLAG
              AND CUR$BYTENO = CUR$LASTBYTE THEN
                RETURN;
            IF CUR$BYTENO = 128 THEN
            DO;
                CUR$BYTENO = 0;
                IF CUR$DMOD THEN
                DO;
                    CALL WRSEC(CUR$DADDR, CUR$DBUF);
                    CUR$DMOD = FALSE;
                END;
                IF (CUR$DPTR := CUR$DPTR + 1) = 64 THEN
                DO;
                    IF LINKS(FLINK) = 0 THEN
                    DO;
                        LINKS(FLINK) = ALLOCATE(CUR$DEVICE);
                        CUR$ALLOC = TRUE;
                        CALL CLRBUF(CUR$DBUF);
                        NEWLINKS$P = CUR$DBUF;
                        NEWLINKS(0) = CUR$LADDR;    /* SAVE FORWARD LINK */
                        CALL RWMAP(CUR$DEVICE, CMD$WRITE);
                        CALL WRSEC(LINKS(FLINK), CUR$DBUF);
                    END;

                    IF CUR$ALLOC THEN
                    DO;
                        CALL RWMAP(CUR$DEVICE, CMD$WRITE);
                        CALL WRSEC(CUR$LADDR, CUR$LBUF);
                        CUR$ALLOC = FALSE;
                    END;
                    CUR$LADDR = LINKS(FLINK);
                    CALL RDSEC(CUR$LADDR, CUR$LBUF);
                    CUR$DPTR = 2;
                END;

                CUR$BLKNO = CUR$BLKNO + 1;
                CUR$DADDR = LINKS(CUR$DPTR);

                IF (NEEDWRITE := COUNT - ACTUAL >= 128 AND
                   (NOT READFLAG OR CUR$BLKNO < CUR$BLKCNT)) THEN
                DO;
                    ACTUAL = ACTUAL + (CUR$BYTENO := 128);
                    WORK$BUF = BUFFER;
                    BUFFER = BUFFER + 128;
                END;
                ELSE
                    WORK$BUF = CUR$DBUF;

                IF READFLAG THEN
                DO;
                    IF CUR$DADDR = 0 THEN
                        CALL CLRBUF(WORK$BUF);
                    ELSE
                        CALL RDSEC(CUR$DADDR, WORK$BUF);
                END;
                ELSE
                DO;
                    CALL GETD;
                    IF NEEDWRITE THEN
                        CALL WRSEC(CUR$DADDR, WORK$BUF);
                    ELSE IF CUR$ACCESS = UPDATE$MODE THEN
                        CALL RDSEC(CUR$DADDR, WORK$BUF);
                END;
            END;

            IF CUR$BYTENO <> 128 THEN
            DO;
                IF READFLAG THEN
                    BUFCH = DATUM(CUR$BYTENO);
                ELSE
                DO;
                    CALL GETD;
                    DATUM(CUR$BYTENO) = BUFCH;
                    CUR$DMOD = TRUE;
                END;
                CUR$BYTENO = CUR$BYTENO + 1;
                BUFFER = BUFFER + 1;
                ACTUAL = ACTUAL + 1;
            END;
        END; /* OF DO WHILE */
        CALL SIZECK;
    END;


    SETDEV: PROCEDURE;
        /*
           SET LOGICAL FILE ASSIGNMENTS TO USE MONITOR ROUTINES
           FOR DOING BYTE AT A TIME I/O DEVICES
        */
        CALL IOSET((IOCHK AND IOBYTEMASKS(CUR$DEVICE))
                    OR IOBYTEFLAGS(CUR$DEVICE));
    END;


    READ: PROCEDURE(AFT, BUFFER, COUNT, ACTUAL$P) ;
        DECLARE AFT BYTE, (BUFFER, COUNT, ACTUAL$P) ADDRESS;
        DECLARE ACTUAL BASED ACTUAL$P ADDRESS;
        DECLARE CH BASED BUFFER BYTE;
        DECLARE READCASE(20) BYTE INITIAL(0, 0, 0, 0, 1, 0FFH, 1, 0FFH, 1,
                          0FFH, 2, 2, 2, 2, 0FFH, 0FFH, 0FFH, 0FFH, 0FFH, 0FFH);

        ACTUAL = 0;
        CALL SETTABS(AFT);

        IF (CUR$ACCESS AND 1) = 0 OR CUR$CLOSED THEN    /* NOT READ */
            CALL ERR(WARNING, CANT$READ);

        CALL SETDEV;
        IF CUR$DEVICE <= F3DEV THEN
            CALL FIO(AFT, BUFFER, COUNT, ACTUAL$P, TRUE);
        ELSE
        DO WHILE 1;
            IF CUR$DEVICE = BBDEV THEN
                COUNT = 0;
            IF ACTUAL = COUNT THEN
                RETURN;
            IF READCASE(CUR$DEVICE) THEN
                CH = CI;
            ELSE
            DO;
                CH = RI;
                IF CARRY THEN
                    RETURN;
            END;
            BUFFER = BUFFER + 1;
            ACTUAL = ACTUAL + 1;
        END;
    END;

    WRITE: PROCEDURE(AFT, BUFFER, COUNT);
        DECLARE AFT BYTE, (BUFFER, COUNT) ADDRESS;
        DECLARE CH BASED BUFFER BYTE;
        DECLARE ACTUAL ADDRESS;
        DECLARE WRITECASE(23) BYTE INITIAL(0, 0, 0, 0, 0FFH, 1, 0FFH, 1,
                                      0FFH, 1, 0FFH, 0FFH, 0FFH, 0FFH, 2, 2,
                                      2, 2, 3, 3, 4, 0FFH, 0FFH);

        CALL SETTABS(AFT);
        IF (CUR$ACCESS AND 2) = 0 OR CUR$CLOSED THEN
            CALL ERR(WARNING, CANT$WRITE);

        CALL SETDEV;

        DO WHILE COUNT <> 0;
            DO CASE WRITECASE(CUR$DEVICE);
            DO;     /* CASE 0 */
                CALL FIO(AFT, BUFFER, COUNT, .ACTUAL, FALSE);
                RETURN;
            END;
            DO;     /* CASE 1 */
                CALL CO(CH);
                IF CSTS THEN
                    IF (CI AND 7FH) = CONTROL$S THEN
                        DO WHILE (CI AND 7FH) <> CONTROL$Q;
                        END;
            END;
            CALL PO(CH);        /* CASE 2 */
            CALL LO(CH);        /* CASE 3 */
            ;                   /* CASE 4 */
            END;

            COUNT = COUNT - 1;
            BUFFER = BUFFER + 1;
        END;
    END;



    EDIT: PROCEDURE(AFT, BUFFER, COUNT, ACTUAL$P);
        DECLARE AFT BYTE, (BUFFER, COUNT, ACTUAL$P) ADDRESS;
        DECLARE ACTUAL BASED ACTUAL$P ADDRESS;
        DECLARE LINE$P ADDRESS,
            IN$MODE BYTE,
            LIT$MODE BYTE,
            LPTR BYTE,
            CHAR BYTE,
            I BYTE,     /* NOTE READ CLOBBERS SELECTOR AS WELL */
            SELECTOR BYTE;
        DECLARE OBUF BASED BUFFER (1) BYTE;
        DECLARE BYTES BASED LINE$P (128) BYTE;
        DECLARE ADDR BASED LINE$P (64) ADDRESS;
        DECLARE SPECIALCHARS(10) BYTE INITIAL(0, DELKEY, CONTROL$Z, CONTROL$R,
                                 CONTROL$X, CR, LF, ESC, CONTROL$E, CONTROL$P);


        ECHO: PROCEDURE(CHAR);      /* NESTED SUB OF EDIT */
            DECLARE CHAR BYTE;
            CALL WRITE(CUR$ECHOAFT, .CHAR, 1);
            CALL SETTABS(AFT);
        END;

        LIT$MODE = FALSE;
        LINE$P = EBUF(AFT);
        LPTR = BYTES(126);
        IN$MODE = BYTES(127);

        DO WHILE IN$MODE;
            CALL READ(AFT, .CHAR, 1, .I);
            IF I = 0 THEN
            DO;
                IF AFT = AFT$CONSOL$IN THEN
                    CALL ERR(ABORT, CONSOLE$EOF);
                ELSE
                    CHAR = CONTROL$Z;
            END;
            BYTES(125) = FALSE;
            CHAR = CHAR AND 7FH;
            IF CHAR <> LF THEN
                CALL ECHO(BYTES(LPTR) := CHAR);

            SELECTOR = 0;
            DO I = 0 TO 9;
                IF CHAR = SPECIALCHARS(I) THEN
                    SELECTOR = I;
            END;
            SELECTOR = SELECTOR AND NOT LIT$MODE;
            LIT$MODE = FALSE;
            DO CASE SELECTOR;
                LPTR = LPTR + 1;    /* CASE 0 - NORMAL */
                DO;         /* CASE 1, RUBOUT */
                    IF LPTR <> 0 THEN
                    DO;
                        CALL ECHO(BYTES(LPTR := LPTR - 1));
                    END;
                    ELSE
                        CALL ECHO(BELL);
                END;
                DO;         /* CASE 2 - CONTROL-Z */
                    ACTUAL = 0;
                    BYTES(125) = TRUE;
                    ADDR(63) = 0FF00H;
                    CALL ECHO(CR);
                    CALL ECHO(LF);
                    RETURN;
                END;
                DO;         /* CASE 3 - CONTROL-R */
                    CALL ECHO(CR);
                    CALL ECHO(LF);
                    CALL WRITE(ECHOAFT(AFT), LINE$P, LPTR);
                END;
                DO;         /* CASE 4 - CONTROL-X */
                    LPTR = 0;
                    CALL ECHO(HASH);
                    CALL ECHO(CR);
                    CALL ECHO(LF);
                END;
                DO;         /* CASE 5 - CR */
                    BYTES(LPTR := LPTR + 1) = LF;
                    CALL ECHO(LF);
                    IN$MODE = FALSE;
                    LPTR = 0;
                END;
                DO;         /* CASE 6 - LF */
                    IF LPTR <> 0 THEN
                    DO;
                        CALL ECHO(BYTES(LPTR) := CHAR);
                        IN$MODE = FALSE;
                        LPTR = 0;
                    END;
                END;
                DO;         /* CASE 7 -  ESC */
                    CALL ECHO(0);
                    CALL ECHO('$');
                    IN$MODE = FALSE;
                    LPTR = 0;
                END;
                DO;         /* CASE 8 - CONTROL-E */
                    IF AFT = AFT$CONSOL$IN THEN
                    DO;
                        I = DEVICE(AFT$CONSOL$IN);
                        DEVICE(AFT$CONSOL$IN) = ALT$CIDEV;
                        ALT$CIDEV = I;
                        CALL ECHO(CARET);
                        CALL ECHO('E');
                    END;
                END;
                LIT$MODE = TRUE;    /* CASE 8 - CONTROL-P */
            END; /* OF CASE */
            IF LPTR = 122 THEN
            DO;
                IN$MODE = FALSE;
                LPTR = 0;
            END;
        END;

        ACTUAL = 0;
        DO WHILE ACTUAL < COUNT AND NOT IN$MODE;
            IF LPTR < MAXLL THEN    /* 122 */
            DO;
                IF (OBUF(ACTUAL) := BYTES(LPTR)) = LF OR BYTES(LPTR) = ESC THEN
                DO;
                    IN$MODE = TRUE;
                    LPTR = -1;
                END;

                ACTUAL = ACTUAL + 1;
                LPTR = LPTR + 1;
            END;
            ELSE
            DO;
                IN$MODE = TRUE;
                LPTR = 0;
            END;
        END;
        BYTES(126) = LPTR;
        BYTES(127) = IN$MODE;
    END;


    RESCAN: PROCEDURE(AFTN);
        DECLARE AFTN BYTE;
        DECLARE BUF$P ADDRESS, BYTES BASED BUF$P(128) BYTE,
                      ADDR BASED BUF$P(64) ADDRESS;

        CALL SETTABS(AFTN);
        BUF$P = CUR$EBUF;
        IF CUR$ECHOAFT = 0 OR BYTES(125) THEN
            CALL ERR(WARNING, CANT$RESCAN);
        ADDR(63) = 0;   /* LPTR = 0, IN$MODE = FALSE */
    END;

    REWIND: PROCEDURE;
        CUR$BYTENO = 128;
        CUR$DPTR = 1;
        CUR$BLKNO = 0;
        CUR$ALLOC = 0;
        CUR$DMOD = 0;
        CUR$DADDR = 0;
        CALL RDSEC(CUR$LADDR := CUR$L1ADDR, CUR$LBUF);
    END;




    SEEK: PROCEDURE(AFT, MODE, BLOCKNO$P, BYTENO$P);
        DECLARE AFT BYTE, (MODE, BLOCKNO$P, BYTENO$P) ADDRESS;
        DECLARE BLOCKNO BASED BLOCKNO$P ADDRESS, BYTENO BASED BYTENO$P ADDRESS;
        DECLARE LOWMODE BYTE, BYTLO(0) BYTE, (BYT, BLK) ADDRESS;
        DECLARE BACKWARDS BYTE;
        DECLARE BYTENOSTEP(2) BYTE INITIAL(128, 1);
        DECLARE BLKNOSTEP(2) ADDRESS INITIAL(1, 0FFFFH);
        DECLARE NEXT ADDRESS;
        DECLARE BACKFIX BYTE;

        OFFEND: PROCEDURE(BLKNUMA, BLKNUMB, BYTENUMA, BYTENUMB) BOOLEAN;
            DECLARE (BLKNUMA, BLKNUMB) ADDRESS, (BYTENUMA, BYTENUMB) BYTE;

            BYTENUMA = BYTENUMA + LOW(BYT);
            BLKNUMA = (ROL(BYTENUMA, 1) AND 1) + BLK + BLKNUMA;
            BYTENUMA = BYTENUMA AND 7FH;
            BLKNUMB = BLKNUMB + (ROL(BYTENUMB, 1) AND 1);
            BYTENUMB = BYTENUMB AND 7FH;
            IF BLKNUMA <> BLKNUMB THEN
                RETURN BLKNUMB < BLKNUMA;
            RETURN BYTENUMB < BYTENUMA;

        END;

        BYT = BYTENO;
        BLK = BLOCKNO;

        IF MODE > SEEK$EOF THEN
            CALL ERR(WARNING, BAD$SEEK$ARG);

        CALL SETTABS(AFT);
        IF CUR$CLOSED THEN
            CALL ERR(WARNING, BAD$AFT$NO);

        IF CUR$DEVICE = BBDEV THEN
            RETURN;

        IF CUR$DEVICE > F3DEV THEN
            CALL ERR(WARNING, NON$DISK$SEEK);

        IF CUR$ACCESS = WRITE$MODE THEN
            CALL ERR(WARNING, SEEK$ON$WRITE);

        IF (LOWMODE := MODE) = SEEK$RETURN THEN
        DO;
            BYTENO = CUR$BYTENO;
            IF (BLOCKNO := CUR$BLKNO - 1) = 0FFFFH THEN
            DO;
                BLOCKNO, BYTENO = 0;
            END;
            RETURN;
        END;

        IF CUR$DMOD THEN
            CALL WRSEC(CUR$DADDR, CUR$DBUF);

        IF CUR$ALLOC THEN
        DO;
            CALL RWMAP(CUR$DEVICE, CMD$WRITE);
            CALL WRSEC(CUR$LADDR, CUR$LBUF);
        END;

        CUR$DMOD = 0;
        CUR$ALLOC = 0;

        IF LOWMODE = SEEK$EOF THEN
        DO;
            LOWMODE = SEEK$ABS;
            BYT = CUR$LASTBYTE;
            IF (BLK := CUR$BLKCNT - 1) = 0FFFFH THEN
                BLK, BYT = 0;
        END;
        IF LOWMODE = SEEK$ABS THEN
            CALL REWIND;

        BACKWARDS = (LOWMODE = 1) AND 1;
        BACKFIX = CUR$BYTENO = 128 AND BACKWARDS;
        BLK = (BLK AND 07FFFH) + SHR(BYT, 7);
        BYTLO = (BYTLO AND 7FH);
        IF NOT BACKWARDS THEN
        DO;
            IF (CUR$ACCESS = 1) AND OFFEND(CUR$BLKNO, CUR$BLKCNT,
                                         CUR$BYTENO, CUR$LASTBYTE) THEN
                CALL ERR(WARNING, SEEK$PAST$EOF);
        END;
        ELSE IF OFFEND(1, CUR$BLKNO, 0, CUR$BYTENO) THEN
                CALL ERR(WARNING, LONG$BACK$SEEK);

        DO WHILE BYTLO > 0;
            BYTLO = BYTLO - 1;
            IF CUR$BYTENO = BYTENOSTEP(BACKWARDS) THEN
            DO;
                CUR$BYTENO = BYTENOSTEP(1 - BACKWARDS);
                BLK = BLK + 1;
            END;
            ELSE
            DO;
                CUR$BYTENO = CUR$BYTENO + BLKNOSTEP(BACKWARDS);
            END;
            IF NOT BACKWARDS THEN
                CALL SIZECK;
        END;
        DO WHILE BLK > 0;
            BLK = BLK - 1;
            IF NOT BACKWARDS THEN
            DO;
                IF CUR$DPTR = 63 THEN
                DO;
                    CUR$DPTR = 1;
                    IF (NEXT := LINKS(FLINK)) = 0 THEN
                    DO;
                        LINKS(FLINK), NEXT = ALLOCATE(CUR$DEVICE);
                        CALL RWMAP(CUR$DEVICE, CMD$WRITE);
                        CALL WRSEC(CUR$LADDR, CUR$LBUF);
                        CALL CLRBUF(CUR$LBUF);
                        LINKS(BLINK) = CUR$LADDR;
                        CALL WRSEC(NEXT, CUR$LBUF);
                        CUR$LADDR = NEXT;
                    END;
                    ELSE
                        CALL RDSEC((CUR$LADDR := NEXT), CUR$LBUF);
                END;
                CUR$DPTR = CUR$DPTR + 1;
            END;
            ELSE IF (CUR$DPTR := CUR$DPTR - 1) < 2 THEN
                IF LINKS(BLINK) <> 0 THEN
                DO;
                    CUR$DPTR = 63;
                    CALL RDSEC(CUR$LADDR := LINKS(BLINK), CUR$LBUF);
                END;
            CUR$BLKNO = CUR$BLKNO + BLKNOSTEP(BACKWARDS);
        END;
        IF CUR$DADDR <> LINKS(CUR$DPTR) OR BACKFIX THEN
            IF (CUR$DADDR := LINKS(CUR$DPTR)) = 0 THEN
                CALL CLRBUF(CUR$DBUF);
            ELSE
                CALL RDSEC(CUR$DADDR, CUR$DBUF);
        CALL SIZECK;
    END;

    SYNC: PROCEDURE;
        CALL WRSEC(CUR$DADDR, CUR$DBUF);
    END;

    DECLARE DIRECT$EMPTY BYTE, DIRECT$FILE(9) BYTE, DIRECT$ATTRIB BYTE,
            DIRECT$EOF$COUNT BYTE, DIRECT$BLK ADDRESS, DIRECT$HDR$BLK ADDRESS;
    DECLARE DIRECT$INO BYTE;

    SEARCH: PROCEDURE(INTFN$P) BOOLEAN;
        DECLARE INTFN$P ADDRESS;
        DECLARE INTFN BASED INTFN$P (12) BYTE;
        DECLARE RCOUNT ADDRESS;
        DECLARE BLOCKNO ADDRESS INITIAL(0);
        DECLARE BYTENO ADDRESS;
        DECLARE (I, AFT) BYTE;
        DECLARE DNUM ADDRESS;
        DECLARE RETURN$VALUE BOOLEAN;
        /*
          THIS PROCEDURE IS USED TO LOOKUP A FILE NAME IN A
          DISK DIRECTORY. THE DEVICE NUMBER OF THE DISK
          IS CONTAINED IN FN(0), THE SIX CHARACTERS OF THE
          FILE NAME ARE IN FN(1) THROUGH FN(6), AND THE
          THREE CHARACTERS OF THE FILE EXTENSION ARE IN
          FN(7) THROUGH FN(9)

          THE PROCEDURE RETURNS 'TRUE' IF THE FILE IS FOUND,
          WITH DIRECT$I$NO POINTING TO THE ENTRY OF THE FILE IN THE
          DIRECTORY

          OTHERWISE, THE PROCEDURE RETURNS 'FALSE', AND DIRECT$I$NO POINTS
          AT A BLANK SLOT IN THE DIRECTORY. THE DIRECTORY MARKER IS
          ADJUSTED SO TAHT IT POINTS AT THE BEGINNING OF THE ENTRY
          POINTED TO BY DIRECT$I$NO.

          IF THE DIRECTORY IS FULL, DIRECT$I$NO = 0FFH
        */
        DBUF(AFT := CUR$DEVICE + 0) = GETBUF;
        LBUF(AFT) = GETBUF;
        CALL SETTABS(AFT);
        CALL REWIND;
        DIRECT$I$NO = 0FFH;
        DNUM = 0;
        RCOUNT = 1;
        DIRECT$EMPTY, RETURN$VALUE = 0;

        DO WHILE RCOUNT <> 0 AND DIRECT$EMPTY <> 7FH;
            CALL READ(AFT, .DIRECT$EMPTY, 16, .RCOUNT);
            IF DIRECT$EMPTY THEN
            DO;
                IF DIRECT$I$NO = 0FFH THEN
                    DIRECT$I$NO = DNUM;
            END;
            ELSE
            DO;
                DO I = 1 TO 9;
                    IF INTFN(I) <> DIRECT$FILE(I - 1) THEN
                    GOTO SKIP;
                END;
                DIRECT$I$NO = DNUM;
                RETURN$VALUE = 0FFH;
                RCOUNT = 0;
            END;
    SKIP:
            DNUM = DNUM + 1;
        END;

        IF DIRECT$I$NO <> 0FFH THEN
        DO;
            BYTENO = DIRECT$I$NO * 16;      /* SIZE OF DIRECT ENTRY */
            CALL SEEK(AFT, SEEK$ABS, .BLOCKNO, .BYTENO);
        END;
        CALL FREE$BUF(CUR$DBUF);
        CALL FREE$BUF(CUR$LBUF);
        RETURN RETURN$VALUE;
    END;


    ATTRIB: PROCEDURE(FILENAME, SWID, VALUE);
        DECLARE (FILENAME, SWID) ADDRESS, VALUE BYTE;
        DECLARE MASK(4) BYTE INITIAL(INVISIBLE$ATTRIBUTE,
                                       SYSTEM$ATTRIBUTE,
                                       WRITEP$ATTRIBUTE,
                                       FORMAT$ATTRIBUTE);

        IF SWID > 4 THEN
            CALL ERR(WARNING, BAD$ATTRIB);
        CALL GETFN(FILENAME, .PN);
        IF PN(0) > F3DEV THEN
            CALL ERR(WARNING, NON$DISK$FILE);
        CALL SETTABS(PN(0));
        IF NOT SEARCH(.PN) THEN
            CALL ERR(WARNING, NO$SUCH$FILE);

        DIRECT$ATTRIB = DIRECT$ATTRIB OR MASK(LOW(SWID));
        IF NOT VALUE THEN
            DIRECT$ATTRIB = DIRECT$ATTRIB AND (NOT MASK(LOW(SWID)));
        CALL WRITE(PN(0), .DIRECT$EMPTY, 16);
        CALL SYNC;
    END;


    CLOSE: PROCEDURE(AFT);
        DECLARE AFT BYTE;
        DECLARE BLKZERO ADDRESS INITIAL(0), BYTNO ADDRESS INITIAL(0);
        DECLARE I BYTE;   /* READ RETURNS AN ADDRESS BUT HIGH BYTE WILL BE 0 */
        DECLARE CLOSECASE(23) BYTE INITIAL(0,0,0,0,       /* F0-F3 */
              1,2,1,2,1,2,1,1,1,1,  /* TI, TO, VI, VO, I1, O1, TR, HR, T1, T2 */
              3,3,3,3,4,4,1,1,1);   /* TP, HP, P1, P2, LP, L1, BB, CI, CO */

        CALL SETTABS(AFT);
        IF CUR$CLOSED THEN
            RETURN;
        IF CUR$ECHOAFT <> 0 THEN
            CALL FREE$BUF(CUR$EBUF);
        DO CASE CLOSECASE(CUR$DEVICE);
            DO; /* 0 - DISK */
                IF CUR$DMOD THEN
                    CALL WRSEC(CUR$DADDR, CUR$DBUF);
                IF CUR$ALLOC THEN
                    CALL WRSEC(CUR$LADDR, CUR$LBUF);

                CALL FREE$BUF(CUR$LBUF);
                CALL FREE$BUF(CUR$DBUF);
                IF CUR$ACCESS >= 2 THEN
                DO;
                    CALL SIZECK;
                    BLKZERO = 0;
                    CALL RWMAP(CUR$DEVICE, CMD$WRITE);
                    /* LET DEVICE USE RETURNED BUFFERS */
                    DBUF(CUR$DEVICE) = CUR$DBUF;
                    LBUF(CUR$DEVICE) = CUR$LBUF;
                    CALL SETTABS(CUR$DEVICE);
                    CALL REWIND;                 /* GET TO DIR HEADER */
                    BYTNO = 16 * DNUM(AFT);
                    /* SEEK TO FILE ENTRY */
                    CALL SEEK(CUR$DEVICE, SEEK$ABS, .BLKZERO, .BYTNO);
                    /* READ THE DIR ENTRY */
                    CALL READ(CUR$DEVICE, .DIRECT$EMPTY, 16, .I);
                    DIRECT$EOF$COUNT = LASTBYTE(AFT);
                    DIRECT$BLK = BLKCNT(AFT);
                    BYTNO = 16;
                    CALL SEEK(CUR$DEVICE, 1, .BLKZERO, .BYTNO);
                    CALL WRITE(CUR$DEVICE, .DIRECT$EMPTY, 16);
                    CALL SYNC;
                END;
            END;
            ;   /* 1 */
            ;   /* 2 */
            DO I = 0 TO 119;    /* 3 OUTPUT 120 NULLS */
                CALL WRITE(AFT, .(0), 1);
            END;
            ;   /* 4 */
        END;
        CLOSED(AFT) = TRUE;
    END;


    RENAME: PROCEDURE(OLD$NAME, NEW$NAME);
        DECLARE (OLD$NAME, NEW$NAME) ADDRESS;
        DECLARE I BYTE;
        DECLARE ALREADY$EXISTS BOOLEAN;


        CALL GETFN(OLD$NAME, .PN2);
        CALL GETFN(NEW$NAME, .PN);
        IF PN(0) > F3DEV THEN
            CALL ERR(WARNING, NON$DISK$FILE);
        IF PN(0) <> PN2(0) THEN
            CALL ERR(WARNING, DIFFERENT$DISK);
        CALL SETTABS(PN(0));
        /* IF NEW$NAME ALREADY EXISTS AND OLD$NAME DOES NOT EXISTI,
           THEN WE WANT OT GIVE THE OLD$NAME ERROR MESSAGE.
           HOWEVER, SEARCH(NEW$NAME) SHOULD PRECEDE SEARCH(OLD$NAME)
           THIS IS BECAUSE POINTER VARIABLES SHOULD BE LEFT POINTING TO
           THE OLD FILE UPON EXIT FROM THIS PROCEDURE */
        ALREADY$EXISTS = SEARCH(.PN);
        IF NOT SEARCH(.PN2) THEN
            CALL ERR(WARNING, NO$SUCH$FILE);
        IF (DIRECT$ATTRIB AND (WRITEP$ATTRIBUTE OR FORMAT$ATTRIBUTE)) <> 0 THEN
            CALL ERR(WARNING, WRITE$PROTECT);
        IF ALREADY$EXISTS THEN
            CALL ERR(WARNING, MULTIDEFINED);
        DO I = 0 TO 8;
            DIRECT$FILE(I) = PN(I + 1);
        END;
        CALL WRITE(CUR$DEVICE + 0, .DIRECT$EMPTY, 16);
        CALL SYNC;
    END;

    SCRATCH: PROCEDURE(DRIVE);
        DECLARE DRIVE BYTE;
        DECLARE (AFT, I) BYTE;
        DECLARE BLOCKNO ADDRESS INITIAL (0);
        DECLARE BYTENO ADDRESS INITIAL(16 /* SIZE DIRECTORY ENTRY */);
        DECLARE LINKBUF$P ADDRESS, LINKBUF BASED LINKBUF$P (64) ADDRESS;

        /* INTERNAL DELETE ROUTING
        DRIVE = F0DEV .. F3DEV
        DIRECT MUST CONTAIN THE DIRECTORY ENTRY FOR AN EXISTING FILE OR DISK.
        AFT SLOT FOR THE APPROPRIATE DIRECTORY MUST HAVE BUFFERS;
        AND THESE BUFFERS MUST BE SETUP FOR DIRECTORY READING AND
        WRITING. THESE BUFFERS WILL BE CLOBBERED
        */
        DIRECT$EMPTY = TRUE;
        CALL SETTABS(AFT := DRIVE + 0);
        CALL WRITE(AFT, .DIRECT$EMPTY, 16);
        CALL XIO(CMD$WRITE, DRIVE, CUR$DADDR, CUR$DBUF);
        CALL SEEK(AFT, SEEK$BACKWARD, .BLOCKNO, .BYTENO);
        LINKBUF$P = CUR$DBUF;    /* LIST OF BLOCKS TO DELETE */
        DO WHILE DIRECT$HDR$BLK <> 0;
            CALL DEALLOC(DRIVE, DIRECT$HDR$BLK);
            CALL XIO(CMD$READ, DRIVE, DIRECT$HDR$BLK, LINKBUF$P);
            DIRECT$HDR$BLK = LINKBUF(FLINK);
            DO I = 2 TO 63;
                IF LINKBUF(I) <> 0 THEN
                    CALL DEALLOC(DRIVE, LINKBUF(I));
            END;
        END;
        CALL XIO(CMD$READ, DRIVE, CUR$DADDR, CUR$DBUF);
        CALL RWMAP(DRIVE, CMD$WRITE);
    END;


    DELETE: PROCEDURE(FILENAME);
        DECLARE FILENAME ADDRESS;
        DECLARE I BYTE;

        CALL GETFN(FILENAME, .PN);
        IF PN(0) > F3DEV THEN
            CALL ERR(WARNING, NON$DISK$FILE);
        ELSE
            CALL SETTABS(PN(0));
        IF SEARCH(.PN) THEN
        DO;
            IF (DIRECT$ATTRIB
              AND (WRITEP$ATTRIBUTE OR FORMAT$ATTRIBUTE)) = 0 THEN
            DO;
                DO I = AFT$BOTTOM TO AFT$LAST;
                    IF (NOT CLOSED(I))
                        AND (DEVICE(I) = PN(0)) AND (DNUM(I) = DIRECT$INO) THEN
                        CALL ERR(WARNING, CANT$DELETE);
                END;
                CALL SCRATCH(PN(0));
            END;
            ELSE
                CALL ERR(WARNING, WRITE$PROTECT);
        END;
        ELSE
            CALL ERR(WARNING, NO$SUCH$FILE);
    END;

    DECLARE ACCESS$SUPPORT DATA(3, 3, 3, 3, 1, 2, 1, 2,
                                1, 2, 1, 1, 1, 1, 2, 2,
                                2, 2, 2, 2, 3, 1, 2);
    OPEN: PROCEDURE(FILENAME, INACCESS, ECHOAFT) BYTE;
        DECLARE (FILENAME, INACCESS, ECHOAFT) ADDRESS;
        DECLARE (AFT, REQACCESS, FOUND, TEMP, I) BYTE;
        DECLARE BUF$P ADDRESS, BYTES BASED BUF$P (128) BYTE,
                              ADDR BASED BUF$P (64) ADDRESS;

        FREE1: PROCEDURE(ERRNUM);
            DECLARE ERRNUM BYTE;

            IF CUR$ECHOAFT <> 0 THEN
                CALL FREE$BUF(CUR$EBUF);
            CALL ERR(WARNING, ERRNUM);
        END;

        FREE3: PROCEDURE(ERRNUM);
            DECLARE ERRNUM BYTE;

            CALL FREE$BUF(CUR$DBUF);
            CALL FREE$BUF(CUR$LBUF);
            CALL FREE1(ERRNUM);
        END;

        IF INACCESS > 3 OR (REQACCESS := INACCESS) = 0 THEN
            CALL ERR(WARNING, BAD$ACCESS);
        CALL GETFN(FILENAME, .PN);
        IF PN(0) = 0FFH THEN
                CALL ERR(WARNING, BAD$DEVICE);
        IF (ACCESS$SUPPORT(PN(0)) AND REQACCESS) = 0 THEN
                CALL ERR(WARNING, BAD$ACCESS);

        IF PN(0) = CIDEV THEN
            RETURN AFT$CONSOL$IN - AFT$BOTTOM;
        IF PN(0) = CODEV THEN
            RETURN AFT$CONSOL$OUT - AFT$BOTTOM;

        CALL SETTABS(AFT := GETAFT);
        CUR$ACCESS = REQACCESS;
        CUR$ECHOAFT = 0;
        IF ECHOAFT <> 0 THEN
        DO;
            CUR$ECHOAFT = AFT$BOTTOM + LOW(ECHOAFT);
            IF ACCESS(CUR$ECHOAFT) <> WRITE$MODE
              OR (CUR$ACCESS AND READ$MODE) = 0 THEN
                CALL ERR(WARNING, BAD$ECHO);

            BUF$P, CUR$EBUF = GET$BUF;
            BYTES(0) = LF;
            ADDR(63) = 0FF00H;
            BYTES(125) = TRUE;
        END;

        IF (CUR$DEVICE := PN(0)) <= F3DEV THEN
        DO;
            FOUND = SEARCH(.PN);
            CALL SETTABS(AFT);
            IF FOUND THEN
                DO I = AFT$BOTTOM TO AFT$LAST;
                    IF NOT CLOSED(I) THEN
                        IF DNUM(I) = DIRECT$I$NO AND DEVICE(I) = PN(0) THEN
                            CALL FREE1(ALREADY$OPEN);
                END;
            CUR$DNUM = DIRECT$I$NO;
            CUR$DBUF = GET$BUF;
            CUR$LBUF = GET$BUF;
            IF REQACCESS = 1 THEN
            DO;
                IF NOT FOUND THEN
                    CALL FREE3(NO$SUCH$FILE);
                CUR$L1ADDR = DIRECT$HDR$BLK;
                CUR$BLKCNT = DIRECT$BLK;
                CUR$LASTBYTE = DIRECT$EOF$COUNT;
                CALL REWIND;
            END;
            ELSE
            DO;
                IF NOT FOUND THEN
                DO;
                    IF DIRECT$I$NO = 0FFH THEN
                        CALL FREE3(DIRECTORY$FULL);
                    DIRECT$BLK = 0;
                    DIRECT$EOF$COUNT = 128;
                    DIRECT$ATTRIB = 0;
                END;
                IF (DIRECT$ATTRIB AND (WRITEP$ATTRIBUTE
                                       OR FORMAT$ATTRIBUTE)) <> 0 THEN
                    CALL FREE3(WRITE$PROTECT);

                IF REQACCESS = 2 AND FOUND THEN
                DO;
                    CALL SCRATCH(CUR$DEVICE);
                    CALL SETTABS(AFT);
                    DIRECT$BLK = 0;
                    DIRECT$EOF$COUNT = 128;
                END;
                CUR$LASTBYTE = DIRECT$EOF$COUNT;
                CUR$BLKCNT = DIRECT$BLK;
                IF NOT (TEMP := REQACCESS = 3 AND FOUND) THEN
                DO;
                    DIRECT$HDR$BLK = ALLOCATE(CUR$DEVICE);
                END;
                CUR$L1ADDR = DIRECT$HDR$BLK;
                DIRECT$EMPTY = 0;
                DO I = 0 TO 8;
                    DIRECT$FILE(I) = PN(I + 1);
                END;
                IF REQACCESS = 3 AND NOT FOUND THEN
                    DIRECT$ATTRIB = 0;
                CALL WRITE(CUR$DEVICE, .DIRECT$EMPTY, 16);
                CALL SYNC;

                CALL SETTABS(AFT);
                CALL REWIND;
                IF NOT TEMP THEN
                DO;
                    CALL CLRBUF(CUR$LBUF);
                    CALL RWMAP(CUR$DEVICE, CMD$WRITE);
                    CALL WRSEC(CUR$L1ADDR, CUR$LBUF);
                END;
            END;
        END;
        ELSE IF CUR$DEVICE <> BBDEV THEN
        DO;
            DO I = AFT$BOTTOM TO AFT$LAST;
                IF NOT CLOSED(I) THEN
                    IF CUR$DEVICE = DEVICE(I) THEN
                        CALL FREE1(ALREADY$OPEN);
            END;
            IF CUR$DEVICE >= 14 AND CUR$DEVICE <= 17 THEN
                DO I = 1 TO 120;
                    CUR$CLOSED = FALSE;
                    CALL WRITE(AFT, .(0), 1);
                END;
        END;
        CUR$CLOSED = FALSE;
        RETURN AFT - AFT$BOTTOM;
    END;



    DECLARE CUR$CONSOL$IN(15) BYTE,
            CUR$CONSOL$OUT(15) BYTE;

    DECLARE COLD$CONSOL$IN(5)  BYTE INITIAL(':XI: '),
            COLD$CONSOL$OUT(5) BYTE INITIAL(':XO: ');


    CONSOL: PROCEDURE(INFILE, OUTFILE);
        DECLARE (INFILE, OUTFILE) ADDRESS;
        DECLARE INSTRING BASED INFILE BYTE,
            OUTSTRING BASED OUTFILE BYTE;
        DECLARE TEMP BYTE;
        DECLARE TDRV(2) BYTE INITIAL('TV'); /* T OR V IS 1ST LETTER OF NAME */

        IF COLD$START$FLAG THEN
        DO;
          COLD$CONSOL$IN(1), COLD$CONSOL$OUT(1) = TDRV(INITIO AND 1);
          INFILE = .COLD$CONSOL$IN;
          OUTFILE = .COLD$CONSOL$OUT;
        END;

        GLOBAL$SEVERITY = ABORT;
        CALL GETFN(OUTFILE, .PN);
        IF PN(0) <> CODEV THEN
        DO;
            CALL CLOSE(AFT$CONSOL$OUT);
            TEMP = OPEN(OUTFILE, WRITE$MODE, FALSE);
            DO TEMP = 0 TO 14;
                CUR$CONSOL$OUT(TEMP) = FULLNAME(TEMP);
            END;
        END;
        CALL GETFN(INFILE, .PN);
        IF PN(0) <> CIDEV THEN
        DO;
            CALL CLOSE(AFT$CONSOL$IN);
            TEMP = OPEN(INFILE, READ$MODE, 100H);
            IF COLD$START$FLAG THEN
                COLD$CIDEV = DEVICE(AFT$CONSOL$IN);
            ALT$CIDEV = COLD$CIDEV;
            DO TEMP = 0 TO 14;
                CUR$CONSOL$IN(TEMP) = FULLNAME(TEMP);
            END;
        END;
        COLD$START$FLAG = FALSE;
    END;


    WHOCON: PROCEDURE(AFT, BUFFER$P);
        DECLARE AFT BYTE;
        DECLARE BUFFER$P ADDRESS, BUFFER BASED BUFFER$P (1) BYTE;
        DECLARE NAME$P ADDRESS, NAME BASED NAME$P (1) BYTE;
        DECLARE I BYTE;

        IF AFT THEN
            NAME$P = .CUR$CONSOL$IN;
        ELSE
            NAME$P = .CUR$CONSOL$OUT;
        DO I = 0 TO 14;
            BUFFER(I) = NAME(I);
        END;
    END;


    LOAD: PROCEDURE(PATHNAME, BIAS, RETSW, ENTRY$P);
        DECLARE (PATHNAME, BIAS, RETSW, ENTRY$P) ADDRESS;
        DECLARE ENTRY BASED ENTRY$P ADDRESS;
        DECLARE PAD1 BYTE;
        DECLARE (AFT, I, RETSW$B, PAD2) BYTE;
        DECLARE HEADER$TYPE BYTE, HEADER$LENGTH ADDRESS;
        DECLARE RECORD$TYPE BYTE, RECORD$SEGID BYTE, RECORD$LOAD$ADDR ADDRESS;
        DECLARE ACTUAL ADDRESS, BYTENO ADDRESS;
        DECLARE BLOCKNO ADDRESS INITIAL(0), 
                USER$BOTTOM ADDRESS INITIAL(0FFFFH), BUFFER$TOP ADDRESS;

        BOUNDS$TEST: PROCEDURE;

            RECORD$LOAD$ADDR = RECORD$LOAD$ADDR + BIAS;

            IF RECORD$LOAD$ADDR >= 18H AND RECORD$LOAD$ADDR <= 3FH
              AND RECORD$LOAD$ADDR + HEADER$LENGTH <= 40H THEN
                RETURN;
            IF USER$BOTTOM > RECORD$LOAD$ADDR THEN
            /* FIRST ADDRESS WILL UPDATE THIS IF APPLICABLE */
                USER$BOTTOM = RECORD$LOAD$ADDR; 
            IF BUFFER$TOP > RECORD$LOAD$ADDR
              OR RECORD$LOAD$ADDR + HEADER$LENGTH  < RECORD$LOAD$ADDR THEN
                CALL ERR(ABORT, ISIS$OVERWRITE);
        END;

        IF RETSW > 2 THEN
            CALL ERR(WARNING, BAD$RETSW);

        AFT = AFT$BOTTOM +  OPEN(PATHNAME, 1, 0);   /* OPEN$READ */

        IF (RETSW$B := RETSW) <> 0 THEN
            USER$BOTTOM = MEMCK;
        BUFFER$TOP = PACKBUFS;
        DO WHILE TRUE;
            /* READ HEADER TYPE AND LENGTH */
            CALL READ(AFT, .HEADER$TYPE, 3, .ACTUAL);
            /* SHORT, RELOCATE OR ODD TYPE */
            IF ACTUAL < 3 OR HEADER$TYPE >= R$RELOC OR HEADER$TYPE THEN
                CALL ERR(ABORT, BAD$LOAD$FORMAT);
            IF HEADER$TYPE > R$CONTENT THEN
            DO;
                BLOCKNO = 0;
                BYTENO = HEADER$LENGTH;
                /* SKIP HEADER */
                CALL SEEK(AFT, SEEK$FORWARD, .BLOCKNO, .BYTENO);
            END;
            ELSE
            DO;
                DO CASE SHR(HEADER$TYPE,1);
                CALL ERR(ABORT, BAD$LOAD$FORMAT);   /* CASE 0 */
                DO;                                 /* CASE 1 - R$MODHDR SKIP */
                    BLOCKNO = 0;
                    BYTENO = HEADER$LENGTH;
                    /* SKIP HEADER */
                    CALL SEEK(AFT, SEEK$FORWARD, .BLOCKNO, .BYTENO);
                END;
                DO; /* CASE 2 - R$MODEND */
                    CALL READ(AFT, .RECORD$TYPE, 4, .ACTUAL);
                    HEADER$LENGTH = 0;
                    IF RECORD$TYPE = 1 THEN      /* SYSTEM */
                        CALL BOUNDS$TEST;
                    ELSE
                        RECORD$LOAD$ADDR = 0;
                    CALL CLOSE(AFT);
                    USER$BOTTOM = USER$BOTTOM AND 0FF80H;
                    DO I = 0 TO 18;
                        IF .MEMORY + SHL(DOUBLE(I), 7) >= USER$BOTTOM  THEN
                            BUFFER$TABLE(I) = 1;    /* NOT AVAILABLE */
                        ELSE
                            BUFFER$TABLE(I) = BUFFER$TABLE(I) AND 0FEH;
                    END;
                    IF RETSW$B = 0 THEN
                    DO;
                        ENTRY = RECORD$LOAD$ADDR;
                        RETURN;
                    END;
                    IF RETSW$B = 1 THEN
                    DO;
                        STACKPTR = USERSP + 2;
                        DEBUG$TOGGLE = FALSE;
                        GOTO RECORD$LOAD$ADDR;
                    END;
                    STACKPTR = MEMCK;
                    ENTRY$P = STACKPTR;
                    ENTRY = RECORD$LOAD$ADDR;
                    DEBUG$TOGGLE = TRUE;
                    GOTO MDSMON;
                END;
                DO; /* CASE 3 - R$CONTENT */
                    CALL READ(AFT, .RECORD$SEGID, 3, .ACTUAL);
                    IF RECORD$SEGID <> 0 THEN
                        CALL ERR(ABORT, BAD$LOAD$FORMAT);
                    /* DON'T INCLUDE HEADER AND CRC */
                    HEADER$LENGTH = HEADER$LENGTH - 4;
                    CALL BOUNDS$TEST;
                    CALL READ(AFT, RECORD$LOAD$ADDR, HEADER$LENGTH, .ACTUAL);
                    IF ACTUAL < HEADER$LENGTH THEN
                        CALL ERR(ABORT, BAD$LOAD$FORMAT);
                    CALL READ(AFT, .RECORD$SEGID, 1, .ACTUAL);
                END;
                END;    /* OF CASE */
            END;    /* OF ELSE */
        END;
    END;

    EXIT: PROCEDURE;
        DECLARE I BYTE;
        DO I = AFT$FIRST TO AFT$LAST;
            CALL CLOSE(I);
        END;
        IF MAP$CHANGE THEN
            CALL RWMAP(CURRENT$BITMAP, CMD$WRITE);
        CURRENT$BITMAP = 0FFH;
        CALL LOAD(.('ISIS.CLI '), 0, 1, 0);
    END EXIT;

    DECLARE BOOTLOAD DATA(80H, 4, 26, 0, 1, 0, 30H);   /* 3000H -> MEMORY */

    REBOOT: PROCEDURE INTERRUPT 1;
        DECLARE I BYTE;
        STACKPTR = .TOPSTACK;
        DO I = AFT$BOTTOM TO AFT$LAST;
            CALL CLOSE(I);
        END;
        CALL XEQIOPB(0, .BOOTLOAD);
        GOTO 3000H;
    END;

    AFT$CHK: PROCEDURE;
        ;        /* ADJUST USERS AFT */
        IF (PARAM1 := PARAM1 + AFT$BOTTOM) >= 12 /* AFT$LAST + 1 */
                                         OR PARAM1 < AFT$BOTTOM THEN
            CALL ERR(WARNING, BAD$AFT$NO);
    END;

    /* ISIS */
    USERSP = STACKPTR;
    STACKPTR = .TOPSTACK;

    IF COMMAND = 'D' THEN
        CALL XEQIOPB(PARAM(0), PARAM(1));
    ELSE
    DO;
        DO I = 0 TO 4;
            /* CHECK IF AN ADDRESS PARAMETER */
            IF SHR(PARAMTYPE(I), COMMAND + 1) THEN
                IF (PARAM(I) < .MEMORY) THEN
                    CALL ERR(ABORT, BAD$PARAMETER);
            SYSPARAM(I+1) = PARAM(I);
        END;

        /* GET THE RETURN STATUS ADDRESS */
        USERSTATUS$P = SYSPARAM(RETPARAMIDX(COMMAND));
        USERSTATUS = 0;
        GLOBAL$SEVERITY = 0;
        IF COMMAND < 14 THEN       /* MAX$COMMAND */
            DO CASE COMMAND;
            DO;     /* 0 - OPEN */
                DECLARE AFT BASED PARAM1 ADDRESS;
                AFT = OPEN(PARAM2, PARAM3, PARAM4);  /* FILE, ACCESS, MODE */
            END;
            DO;     /* 1 - CLOSE */
                CALL AFT$CHK;
                IF PARAM1 >= 6 THEN
                    CALL CLOSE(PARAM1);
            END;
            CALL DELETE(PARAM1);    /* 2 - DELETE - FILE */
            DO;         /* 3 - READ */
                CALL AFT$CHK;
                IF ECHOAFT(PARAM1) = 0 THEN
                    /* AFTN, BUFFER, COUNT, ACTUAL */
                    CALL READ(PARAM1, PARAM2, PARAM3, PARAM4);
                ELSE
                    /* AFTN, BUFFER, COUNT, ACTUAL */
                    CALL EDIT(PARAM1, PARAM2, PARAM3, PARAM4);
            END;
            DO;         /* 4 - WRITE */
                CALL AFT$CHK;
                CALL WRITE(PARAM1, PARAM2, PARAM3); /* AFTN, BUFFER, COUNT */
            END;
            DO;         /* 5 - SEEK */
                CALL AFT$CHK;
                /* AFTN, BUFFER, COUNT, ACTUAL */
                CALL SEEK(PARAM1, PARAM2, PARAM3, PARAM4);
            END;
            /* 6 - SEEK - FILE, BASE, RETSW, ENTRY */
            CALL LOAD(PARAM1, PARAM2, PARAM3, PARAM4);
            CALL RENAME(PARAM1, PARAM2);      /* 7 - RENAME - FILE1, FILE2 */
            DO;                               /* 8 - CONSOLE - FILE1, FILE2 */
                GLOBAL$SEVERITY = 2;
                CALL CONSOL(PARAM1, PARAM2);
            END;
            CALL EXIT;                        /* 9 - EXIT */
            /* 10 - ATTRIB - FILE, SWID, SWVALUE */
            CALL ATTRIB(PARAM1, PARAM2, PARAM3);
            DO;         /* 11 - RESCAN */
                CALL AFT$CHK;
                CALL RESCAN(PARAM1);        /* AFTN */
            END;
            CALL ERR(MESSAGE, PARAM1);  /* 12 - ERROR - MESSAGE, ERRNUM */
            CALL WHOCON(PARAM1, PARAM2);    /* 13 - WHOCON - AFTN, BUFFER */
            END;
        ELSE
            CALL ERR(WARNING, BAD$COMMAND);
    END;
    STACKPTR = USERSP;
END;
END;
EOF

isis.pex
TRUE		'0FFH'
FALSE		'0'
CR		'0DH'
LF      '0AH'
BOOLEAN		'byte'
FOREVER		'while(1)'


# my user types
pointer     'address'
bool        'byte'
apointer    'address'
word        'address'
DCB$T	'STRUCTURE (iocw BYTE, ioins BYTE, nsec BYTE, tadr BYTE, sadr BYTE, buf ADDRESS)'
DIRECT$T 'structure(empty byte, file(9) byte, attrib byte, eof$count byte, blk address, hdrBlk address)'

CMD$WRITE   '6'
INVISIBLE$A '1'
SYSTEM$A    '2'
WRITEP$A    '4'
FORMAT$A    '80H'

Attrib		P("pointer" path$p,"word" attrib,"word" on$off,"apointer" status$p)
Absio       P(B cmd,B disk,"word" block,"pointer" buffer)
ClearBuf     P(A buf$ptr)
Close           P("word" conn,"apointer" status$p)
Delete      P("pointer" file,"apointer" status$p)
deblank		p(a str)a
delimit		p(a ptr)a
Diskio      P(A disk,A dcb$p)
FormatTrack P(B disk,B sTrack,B eTrack,B interleave)
MoveAscii   P("pointer" dst,"pointer" src,B cnt)
error		p(a error$num)
exit		p
file$error	p(a satatus,a ptr,b callExit)
force$upper	p(a bufferPtr)
load		p(a path$p,a load$offset,a switch,a entry$p,a status$p)
Isis            P(B type,A parameter$ptr)
Open            P("apointer" conn$p,"pointer" path$p,"word" access,"word" echo,"apointer" status$p)
memck		pa
Monitor		p
NumOut      P("word" val,B base,B lc,"pointer" buf,B width)
Path        P("pointer" filename,"pointer" pn)B
read		p(a conn,a buff$p,a count,a actual$p,a status$p)
reportError	p(a status)
rescan		p(a conn,a status$p)
seek		p(a conn,a mode,a block$p,a byte$p,a status$p)
seq		p(a s1,a s2,b cnt)b
SetBlock    P(A adr)
uppercase	p(b ch)b
scanblank	p(a ptr)a
Unpath      P(A int,A ext)
write		p(a conn,a buff$p,a count,a status$p)
WriteDirectory P(B disk)

# file access modes
READ$MODE   '1'
WRITE$MODE  '2'
UPDATE$MODE '3'

# public data
bitMap  BS(256)
maskArray   BS(8)

isis.t0.plm
/*
    THE SOURCE BELOW NEEDS TO BE COMPILED WITH THE FORTRAN CROSS COMPILER
    UNFORTUNATELY INTEL SEEM TO HAVE USED A LATER VERSION THAT SUPPORTED
    'AT' AND DID NOT FILL UNINITIALISED DATA WITH ZEROS

    THE PERL ROUTINE LOADANDFIX.PL LOADS THE HEX FILE CREATED, 
    AND REPLACES UNITIALISED AND DATA PAST MEMORY WITH THE
    BYTES IN THE ORIGINAL ISIS.T0 FILE
*/
3000H: DO; 

    DECLARE BOOLEAN LITERALLY 'BYTE';
    DECLARE TRUE    LITERALLY '0FFH';
    DECLARE CMSK    LITERALLY '0FCH';
    DECLARE CR  LITERALLY '0DH',
            LF  LITERALLY '0AH';

    DECLARE T0VER DATA(2, 20H);     /* ISIS.T0 VERSION ? */
    DECLARE (USER$STATUS, USER$STACKPTR, START$ADDR) ADDRESS;
    DECLARE A$DEVICE BYTE;
    DECLARE MEMBASE ADDRESS INITIAL(0);
    DECLARE BYTE$AT BASED MEMBASE (1) BYTE;
    DECLARE VERSION$LEVEL   LITERALLY   'BYTE$AT(3EH)',
            EDIT$LEVEL      LITERALLY   'BYTE$AT(3FH)';
    DECLARE TEMP BYTE;
    DECLARE ISIS$SIGNON(12) BYTE INITIAL(CR, LF, 'ISIS-II, V'),
            SIGN$V(2) BYTE, /* VERSION NUMBER */
            SIGN$DOT(1) BYTE INITIAL('.'),
            SIGN$E(2) BYTE,  /* EDIT NUMBER */
            SIGN$CRLF(2) BYTE INITIAL (CR, LF);
3200H:
    DECLARE COPYRIGHT DATA('(C) 1975,1976 INTEL CORP');

    ISIS: PROCEDURE(CMD, PARAM$P);
        DECLARE CMD BYTE, PARAM$P ADDRESS;
        GOTO 40H;
    END ISIS;

    READ: PROCEDURE(CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P) ADDRESS;

        CALL ISIS(3, .CONN);
    END;

    WRITE: PROCEDURE(CONN, BUFF$P, COUNT, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, STATUS$P) ADDRESS;

        CALL ISIS(4, .CONN);
    END;

    EXIT: PROCEDURE;
        DECLARE STATUS ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(9, .STATUS);
    END;

    CONSOL: PROCEDURE(CI$P, CO$P, STATUS$P);
        DECLARE (CI$P, CO$P, STATUS$P) ADDRESS;
        CALL ISIS(8, .CI$P);
    END;

    NUMOUT: PROCEDURE(VALUE, BASE, LC, BUFADR, WIDTH);
        DECLARE (VALUE, BUFADR) ADDRESS, (BASE, LC, WIDTH) BYTE; 
        DECLARE DIGITS DATA('0123456789ABCDEF');
        DECLARE I BYTE;
        DECLARE BUF BASED BUFADR (1) BYTE;

        DO I = 1 TO WIDTH;
            BUF(WIDTH - I) = DIGITS(VALUE MOD BASE);
            VALUE = VALUE / BASE;   
        END;

        I = 0;
        DO WHILE BUF(I) = '0' AND I < WIDTH - 1;
            BUF(I) = LC;
            I = I + 1;
        END;
    END;



    /* THE FOLLOWING FOUR VARIABLES ARE USED IN THE ERR PROCEDURE */
    DECLARE STATUS ADDRESS;     /* ERROR NUMBERS ARE PLACED HERE */
    DECLARE DEBUG$TOGGLE BOOLEAN;   /* GOVERNES ACTION WHEN ERROR OCCURS */
    DECLARE GLOBAL$SEVERITY BYTE;   /* OVERRIDES NORMAL ERROR SEVERITY */
    DECLARE FDCC$ERROR$TYPE ADDRESS;    /* HAS DATA ON DISK I/O ERRORS */

    /* USEFUL LITERALS */
    DECLARE WARNING LITERALLY '0',
            MESSAGE LITERALLY '1',
            ABORT   LITERALLY '2';

    DECLARE DISK$IO$ERROR   LITERALLY   '18H',
            DRIVE$NOT$READY LITERALLY   '1EH';

    DECLARE ISIS$HDR$BLK LITERALLY   '204H';


    DECLARE RTC LITERALLY '0FFH';   /* REAL TIME CLOCK */
    DECLARE BOOT LITERALLY '2';
    /* INPUT FROM RTC IS A BYTE. THE SECOND BIT FROM THE RIGHT
       CORRESPONDS TO THE BOOT SWITCH. IF THIS BIT IS 1 THE SWITCH IS
       ON, AND IF IT IS 0 THE  SWITCH IS OFF.
    */

    DECLARE MDSMON  LITERALLY   '0',
            BTSTRP  LITERALLY   '8';


    CI: PROCEDURE BYTE;
        GOTO 0F803H;
    END;

    RI: PROCEDURE BYTE;
        GOTO 0F806H;
    END;

    CO: PROCEDURE(C);
        DECLARE C BYTE;
        GOTO 0F809H;
    END;

    PO: PROCEDURE(C);
        DECLARE C BYTE;
        GOTO 0F80CH;
    END;

    LO: PROCEDURE(C);
        DECLARE C BYTE;
        GOTO 0F80FH;
    END;

    IOCHK: PROCEDURE BYTE;
        GOTO 0F815H;
    END;

    IOSET: PROCEDURE(C);
        DECLARE C BYTE;
        GOTO 0F818H;
    END;

    CSTS: PROCEDURE BYTE;
        GOTO 0F812H;
    END;


    
    DECLARE INITIO$BASE ADDRESS INITIAL(6), INITIO BASED INITIO$BASE BYTE;

    /*
       THE ERR PROCEDURE IS USED TO HANDLE ERROR CONDIITONS.
           AN ERROR MESSAGE IS ISSUED TO THE CONSOLE, WHICH FOR
           DISK ERRORS HAS EXTENDED CONTENT
       CONTROL THEN PASSES TO THE MDS MONITOR

       ERROR$TYPE IS THE ERROR NUMBER WHICH IDENTIFIES THE PARTICUALAR
              TYPE OF ERROR, SUCH AS DISK I/O ERROR
    */

    ERR: PROCEDURE(SEVERITY, ERROR$TYPE);
        DECLARE (SEVERITY, ERROR$TYPE, I, IMAX) BYTE;
        DECLARE PC BASED USER$STACK$PTR ADDRESS;
    DECLARE MSG1(8) BYTE INITIAL(CR, LF, 'ERROR '),
        MSG2(3) BYTE, /* ERROR NUMBER GOES HERE */
        MSG3(9) BYTE INITIAL(' USER PC '),
        MSG4(4) BYTE, /* USER PC IN HEX GOES HERE */
        MSG5(2) BYTE INITIAL(CR, LF),
        MSG6(5) BYTE INITIAL('FDCC='),
        MSG7(4) BYTE, /* FDCC ERROR DATA GOES HERE */
        MSG8(2) BYTE INITIAL(CR, LF);

        IF (SEVERITY := SEVERITY OR GLOBAL$SEVERITY) <> WARNING THEN
        DO;
            CALL NUMOUT(ERROR$TYPE, 10, 0, .MSG2, 3);
            CALL NUMOUT(PC,16,'0',.MSG4,4);
            CALL IOSET((IOCHK AND CMSK) OR (INITIO AND 3));
            IMAX = 25;  /* NUMBER OF CHARACTERS IN NORMAL ERROR MESSAGE */
            IF ERROR$TYPE = DISK$IO$ERROR THEN
            DO;
                IMAX = 36;
                CALL NUMOUT(FDCC$ERROR$TYPE, 16, '0', .MSG7, 4);
            END;
            DO I = 0 TO IMAX;
                CALL CO(MSG1(I));
            END;
        END;
        ELSE
        DO;
            USER$STATUS = ERROR$TYPE;
            STACKPTR = USER$STACK$PTR;
        END;
        IF SEVERITY >= ABORT THEN
        DO;
            IF DEBUG$TOGGLE THEN
                GOTO MDSMON;    /* EXIT VIA MONITOR */
            GOTO BTSTRP;        /* EXIT VAI SOFTWARE BOOTSTRAP */
        END;
    END;



    /*
       DISKIO PROVIDES ACCESS TO THE FDCC
       CONTROLLER 1 = BASE ADDRESS 78H (DRIVES 0, 1 FOR SD)
       CONTROLLER 2 = BASE ADDRESS 88H (DRIVES 2, 3 FOR SD)

       DRIVE: AN INTEGER 0-3, SPECIFYING THE DISK TO BE ACCESSED
       IOPB:  THE ADDRESS OF A PARAMETER BLOCK TO BE SENT TO THE
          FDCC CONTROLLER. THIS PARAMETER MUST BE SET UP
          AS IF IT WERE FOR DRIVE 0; IF 'DRIVE' SELECTS
          ANOTHER DRIVE, 'DISKIO' WILL SET ALL THE NECESSARY
          BITS

       THE CALLER PROVIDES A PARAMETER BLOCK SPECIFYING SOME
       VALID DISK OPERATION ON DRIVE 0 AND AN INTEGER DRIVE SELECT VALUE
       IN THIS BOOT CODE ONLY READ AND RECAL ARE USED
       THE PROCEDURE WAITS FOR THE CONTROLLER TO GO UNBUSY, THEN
       PERFORMS THE DESIRED ACTION. IN CASE OF A CONTROLLER ERROR,
       THE DISK DRIVE IS RECALIBRATED AND THE ACTION IS TRIED AGAIN.
       IF SUCCESSFUL COMPLETION CANNOT BE OBTAINED AFTER 'MAX$RETRIES'
       ATTEMPTS, A FATAL ERROR OCCURS, OTHERWISE A NORMAL RETURN IS MADE

    */
        DECLARE FDCC$STATUS$0   LITERALLY   '78H',
                FDCC$STATUS$1   LITERALLY   '88H',
                RESULT$TYPE$0   LITERALLY   '79H',
                RESULT$TYPE$1   LITERALLY   '89H',
                RESULT$BYTE$0   LITERALLY   '7BH',
                RESULT$BYTE$1   LITERALLY   '8BH',
                LOW$ADDRESS$0   LITERALLY   '79H',
                LOW$ADDRESS$1   LITERALLY   '89H',
                HIGH$ADDRESS$0  LITERALLY   '7AH',
                HIGH$ADDRESS$1  LITERALLY   '8AH';

        DECLARE MAX$RETRIES     LITERALLY   '10',
                DISK$DONE       LITERALLY   '4',
                READ$COMMAND    LITERALLY   '4',
                WRITE$COMMAND   LITERALLY   '6',
                RECALIBRATE     LITERALLY   '3';

        DECLARE IOCW    LITERALLY '0',
                IOINS   LITERALLY '1',
                NSEC    LITERALLY '2',
                TADR    LITERALLY '3',
                SADR    LITERALLY '4',
                BUFLO   LITERALLY '5',
                BUFHI   LITERALLY '6';


    DISKIO: PROCEDURE(DRIVE, IOPB);
        /* THIS PROCEDURE ISSUES THE IOPB TO THE DISK CONTROLLER, IN THE */
        /* CASE OF THE 8271 IT ALSO TRANSFERS THE DATA ON A BYTE BY BYTE BASIS */
        DECLARE DRIVE BYTE; /* DRIVE NUMBER: ASSUMES VALUE 0,1,2,3 */
        DECLARE IOPB ADDRESS;   /* POINTER TO THE PARAMATER BLOCK NAMED DCB */
        DECLARE DCB BASED IOPB (7) BYTE; 

        DECLARE TEMPA(0) ADDRESS, (TEMP2, TEMP1, JUNK) BYTE;

        /* RECALIBRATE COMMAND */
        DECLARE RECAL$PB(5) BYTE INITIAL(80H, RECALIBRATE, 0, 0, 0);

        DECLARE I BYTE;     /* INDEX VARIABLE IN FOR STATEMENTS */
        DECLARE IVAL BYTE;  /* INTERRUPT MASK VALUE */

        DISK$STAT: PROCEDURE BYTE; /* RETURN THE DISK DRIVE STATUS */
            IF ROR(DRIVE, 1) THEN    /* DRIVE 1 */
                RETURN INPUT(FDCC$STATUS$1);
            RETURN INPUT(FDCC$STATUS$0);
        END;


        R$TYPE: PROCEDURE BYTE; /* RETURN THE RESULT TYPE OF A DISK OPERATION */
            IF ROR(DRIVE, 1) THEN
                RETURN INPUT(RESULT$TYPE$1);
            RETURN INPUT(RESULT$TYPE$0);
        END;

        
        R$BYTE: PROCEDURE BYTE; /* RETURN THE REULT BYTE OF A DISK OPERATION */
            IF ROR(DRIVE, 1) THEN
                RETURN INPUT(RESULT$BYTE$1);
            RETURN INPUT(RESULT$BYTE$0);
        END;

        /*
           START$IO OUTPUTS THE ADDRESS OF THE IOPB TO THE DISK CONTROLLER
        */
        START$IO: PROCEDURE(IOPB);
            DECLARE IOPB ADDRESS;

            IF ROR(DRIVE, 1) THEN
            DO;
                OUTPUT(LOW$ADDRESS$1) = LOW(IOPB);
                OUTPUT(HIGH$ADDRESS$1) = HIGH(IOPB);
            END;
            ELSE
            DO;
                OUTPUT(LOW$ADDRESS$0) = LOW(IOPB);
                OUTPUT(HIGH$ADDRESS$0) = HIGH(IOPB);
            END;
        END;



        IVAL = INPUT(0FCH);
        OUTPUT(0FCH) = IVAL OR 2; /* PREVENT  REENTRANCY */

        RECAL$PB(IOINS) = RECALIBRATE;
        RECAL$PB(SADR) = 0;
        IF DRIVE THEN
        DO;
            DCB(IOINS) = DCB(IOINS) OR 30H;
            DCB(SADR) = DCB(SADR) OR 20H;
            RECAL$PB(IOINS) = RECALIBRATE OR 30H; 
            RECAL$PB(SADR) = 20H;
        END;
        
        DO I = 0 TO MAX$RETRIES;

            DO WHILE (DISK$STAT AND DISK$DONE) <> 0;
                TEMP1 = R$TYPE;
                TEMP1 = R$BYTE;
            END;
            /* IF DISK DRIVE NOT READY, GIVE FATAL ERROR */
            IF (DISK$STAT AND ((DRIVE AND 1) + 1)) = 0 THEN
                CALL ERR(ABORT, DRIVE$NOT$READY);

            CALL START$IO(IOPB);
            DO WHILE (DISK$STAT AND DISK$DONE) = 0; 
                ;
            END;
            TEMP1 = R$TYPE;
            IF (TEMP2 := R$BYTE) = 0 THEN
            DO;
                OUTPUT(0FCH) = IVAL;    /* RESTORE INTERRUPT 1 */
                RETURN;
            END;
            CALL START$IO(.RECAL$PB);
            DO WHILE (DISK$STAT AND DISK$DONE) = 0;
                ;
            END;
        END;
        FDCC$ERROR$TYPE = TEMPA;
        CALL ERR(ABORT, DISK$IO$ERROR);
    END;


    /*
     ASBIO: ACCOMPLISHES THE TRANSFER OF 128 BYTES OF DATA FROM THE DISK 
       COMMAND  MUST BE THE NUMERIC VALUE OF THE FDCC COMMAND
                DESIRED. (LITERALS 'READ$COMMAND' AND 'WRITE$COMMAND'
                EXIST FOR THE COMMON OPERATIONS.)
       DISK     THE DRIVE FROM WHICH TO READ
       BLOCK    DISKETTE BLOCK NUMBER, A TRACK NUMBER (0-76)
                IN THE HIGH ORDER 8 BITS AND A SECTORE NUMBER (1-26)
                IN THE LOW ORDER 8 BITS
       BUFFER$PTR   THE ADDRESS OF A 128 BYTE BUFFER IN RAM
    */
    ABSIO: PROCEDURE (COMMAND, DISK, BLOCK, BUFFER$PTR);
        DECLARE (COMMAND, DISK) BYTE, (BLOCK, BUFFER$PTR) ADDRESS;
        /* VALUE OF 'DISK'  MUST BE 0 - 1 */
        DECLARE DCB(10) BYTE INITIAL(80H);

        DCB(IOINS) = COMMAND;
        DCB(NSEC) = 1;   /* IF THIS VALUE CHANGES IN THE FUTURE, */
                /* THE 8271 DRIVER MUST BE CHANGED */
        DCB(TADR) = HIGH(BLOCK);
        DCB(SADR) = LOW(BLOCK);
        DCB(BUFLO) = LOW(BUFFER$PTR);
        DCB(BUFHI) = HIGH(BUFFER$PTR);
        CALL DISKIO(DISK, .DCB);
    END;

    ABS$READ: PROCEDURE(BLOCK, BUFFER);
        DECLARE (BLOCK, BUFFER) ADDRESS;

        CALL ABSIO(READ$COMMAND, A$DEVICE, BLOCK, BUFFER);
    END;

    ABS$WRITE: PROCEDURE(BLOCK, BUFFER);
        DECLARE (BLOCK, BUFFER) ADDRESS;

       CALL ABSIO(WRITE$COMMAND, A$DEVICE, BLOCK, BUFFER);
    END;

    /*

        ALDADR LOADS THE ABSOLUTE ISIS FILE INTO MEMORY
        HDRBLK - LOCATION OF ISIS FILE

        RETURNS - ADDRESS WHERE FILE IS LOADED
        THE FORMAT OF THE FILE IS BASICALLY THE CONTENT RECORDS
        FROM AN NORMAL ISIS EXECUTABLE WITH THE RECORD TYPE, SEGMENT ID AND CRC REMOVED
    */

    ALDADR: PROCEDURE(HDRBLK) ADDRESS;
        /* LOAD INTO MEMORY THE ABS LOAD FILE AT 'HDRBLK' */
        DECLARE HDRBLK ADDRESS;
        DECLARE BUF(128) BYTE, BUFPTR BYTE;
        DECLARE POINTERS(64) ADDRESS, PTRPTR BYTE;
        DECLARE LOADADR ADDRESS, TARGET BASED LOADADR BYTE;
        DECLARE LENGTH ADDRESS;

        DECLARE FLINK   LITERALLY   '1';    /* INDEXES INTO THE POINTERS ARRAY */

        L1B: PROCEDURE; /* LOAD 1 BYTE FROM BUFFER INTO MEMORY */
            TARGET = BUF(BUFPTR);   
            BUFPTR = BUFPTR + 1;
            LENGTH = LENGTH - 1;
            LOADADR = LOADADR + 1;
        END;

        G128B: PROCEDURE(BUFADR); /* GET 128 BYTES INTO BUFFER AT BUFADR */
            DECLARE BUFADR ADDRESS;

            IF (PTRPTR := PTRPTR + 1) = 64 THEN
            DO;
                IF POINTERS(FLINK) = 0 THEN
                    GOTO MDSMON;
                CALL ABSIO(READ$COMMAND, 0, POINTERS(FLINK), .POINTERS);
                PTRPTR = 2;
            END;
            IF POINTERS(PTRPTR) = 0 THEN
                GOTO MDSMON;
            CALL ABSIO(READ$COMMAND, 0, POINTERS(PTRPTR), BUFADR);
        END;

        G1B: PROCEDURE BYTE;    /* GET 1 BYTE */
            IF (BUFPTR AND 7FH) = 0 THEN
            DO;
                CALL G128B(.BUF);
                BUFPTR = 0;
            END;    
            BUFPTR = BUFPTR + 1;
            RETURN BUF(BUFPTR - 1);
        END;

        G2B: PROCEDURE ADDRESS; /* GET 2 BYTES */
            RETURN G1B + (256 * G1B);
        END;




        POINTERS(FLINK) = HDRBLK;   /* INITIALISZE G128B */
        PTRPTR = 63;
        BUFPTR = 0;

    START$LOADING$NEXT$RECORD:
        DO WHILE TRUE;
            LENGTH = G2B;
            LOADADR = G2B;
            IF LENGTH = 0 THEN
                RETURN LOADADR;
            DO WHILE BUFPTR <> 128;
                IF LENGTH > 0 THEN
                    CALL L1B;
                ELSE
                    GOTO START$LOADING$NEXT$RECORD;
            END;
            DO WHILE LENGTH >= 128;
                CALL G128B(LOADADR);
                LOADADR = LOADADR + 128;
                LENGTH = LENGTH - 128;
            END;
            
            BUFPTR = 0;
            IF LENGTH <> 0 THEN
            DO;
                CALL G128B(.BUF);
                DO WHILE LENGTH > 0;
                    CALL L1B;
                END;
            END;
        END;
        /* CANNOT REACH HERE !! */
    END; 


    T0BOOT:
    TEMP = INPUT(RESULT$TYPE$0);
    TEMP = INPUT(RESULT$BYTE$0);
    ENABLE;
    DO WHILE (INPUT(RTC) AND BOOT) <> 0;
        ;
    END;
    GLOBAL$SEVERITY = WARNING;
    DEBUG$TOGGLE = TRUE;
    START$ADDR = ALDADR(ISIS$HDR$BLK);
    CALL CONSOL(.MEMORY, .MEMORY, .USER$STATUS);
    CALL NUMOUT(VERSION$LEVEL, 16, 0, .SIGN$V, 2);
    CALL NUMOUT(EDIT$LEVEL, 16, 0, .SIGN$E, 2);
    CALL WRITE(0, .ISIS$SIGNON, 19, .USERSTATUS);
    CALL EXIT;


END;
EOF;
isis.t0.patch
388E 32 31 45 44 37 33 37 31 32 34 32 45 37 30 34 45 32 43 34
38A1 36 32 35 32 45 x 03 37 31 32 33 37 30 32 31 32 39 0D 0A 7F
38B5 20 3A 31 44 35 45 46 31 30 x 04 37 31 34 45 32 43 34 36 32
38CA 35 32 45 45 37 35 45 43 44 42 35 34 44 43 33 30 39 35 46
38DD 32 31 37 30 37 34 34 45 32 43 34 36 43 44 37 42 34 45 30
38F0 45 32 43 43 44 32 38 34 42 46 43 0D 0A 7F 20 3A 31 44 35
3903 46 30 45 30 30 34 46 43 35 30 45 30 44 43 44 32 38 34 42
3916 44 31 42 33 32 46 30 46 44 32 32 31 35 46 30 45 30 31 43
3929 44 33 30 34 32 32 41 37 30 37 34 32 33 32 32 37 30 37 34
393C 43 33 42 44 35 45 39 30 0D 0A 7F 20 3A 31 44 35 46 32 42
394F 30 30 43 39 32 31 38 34 37 34 37 31 32
APPEND
32 46 34 46 37 38 32 46 32 44 37 31 32 33 37 37 32 45 38 31 37
45 30 46 44 32 37 45 35 46 32 43 34 45 32 43 34 36 43 44 30 46
34 45 43 33 39 39 35 46 32 43 34 45 32 43 34 36 31 41 0D 0A 7F
20 3A 31 44 35 46 38 32 30 30 32 35 32 45 45 34 37 31 32 33 37
30 32 34 32 45 37 45 34 45 32 43 34 36 32 31 45 37 37 30 35 45
43 44 39 34 34 44 32 31 44 46 37 30 37 37 32 31 38 38 37 34 34
45 32 43 34 36 45 46 0D 0A 7F 20 3A 31 44 35 46 39 46 30 30 32
31 45 37 37 30 35 45 43 44 42 33 34 33 32 34 32 45 38 38 37 37
32 33 37 30 32 31 44 46 37 30 39 36 34 46 37 38 44 45 30 30 42
31 43 41 44 33 35 46 32 31 38 36 37 34 34 45 41 37 0D 0A 7F 20
3A 31 44 35 46 42 43 30 30 32 43 34 36 32 35 32 45 42 32 37 31
32 33 37 30 32 31 44 46 37 30 34 45 30 36 30 30 32 31 38 38 37
34 35 45 32 43 35 36 43 44 36 45 34 37 32 41 38 36 37 34 32 33
32 32 38 36 31 42 0D 0A 7F 20 3A 31 44 35 46 44 39 30 30 37 34
32 41 38 32 37 34 32 33 32 32 38 32 37 34 45 42 37 42 44 36 30
30 35 46 37 41 44 45 30 30 42 33 43 38 43 33 33 36 35 46 43 39
30 31 38 41 37 34 43 44 38 33 35 31 43 44 45 30 0D 0A 7F 20 3A
31 44 35 46 46 36 30 30 35 39 34 36 43 44 42 44 35 44 32 46 30
46 44 32 30 35 36 30 30 45 30 39 43 44 33 30 34 32 32 31 44 44
37 30 37 45 44 36 30 30 44 36 30 31 39 46
mask.plm
mask: do;
declare maskArray(*) byte public data(80h,40h,20h,10h,8,4,2,1);
end;
meq.plm
MEQ: DO;

meq: procedure(mPtr, fptr) byte public;
	declare (mPtr, fptr) address;
	declare m based mPtr (10) byte;
	declare f based fptr (10) byte;
	declare i byte;

	do i = 0 to 9;
		if m(i) = '?' then
		do;
			if f(i) = 0 then
				return 0;
		end;
		else if m(i) <> '*' then
		do;
			if m(i) <> f(i) then
				return 0;
		end;
	end;
	return 0ffh;
end;
end;

monitr.plm

MONITOR: DO;
Monitor: procedure public;
  declare sp address;
  declare wrd based sp address;
  sp = stackptr;
  wrd = 8;
  stackptr = stackptr - 2;
  sp = stackptr;
  wrd = 0;
end;
end;
mvasci.plm
MOVEASCII: DO;
MoveAscii: procedure(dst, src, cnt) public;
    declare (dst, src) address, cnt byte, i byte;
    declare dch based dst (1) byte, sch based src (1) byte;

    do i = 0 to cnt - 1;
        dch(i) = sch(i);
    end;
end;
end;
numout.plm
numout: do;
declare digits(*) byte data('0123456789ABCDEF');

NumOut: procedure(value, base, lc, bufAdr, width) public;
	declare (value, bufAdr) address, (base, lc, width) byte;
	declare i byte;
	declare buf based bufAdr (1) byte;

	do i = 1 to width;
		buf(width - i) = digits(value mod base);
		value = value / base;
	end;

	i = 0;
	do while buf(i) = '0' and i < width - 1;
		buf(i) = lc;
		i = i + 1;
	end;
end;
end;
p0019.asm
	name	@P0019
	public	@P0019
	cseg

@P0019:			; hl = hl & de
	mov	a,e
	ana	l
	mov	l,a
	mov	a,d
	ana	h
	mov	h,a
	ret
	end

p0029.asm
	name	@P0029
	public	@P0029, @P0030
	cseg

@P0029:			; de = de / hl, hl = de % hl
	mov	b,h
	mov	c,l
@P0030:			; de = de / bc, hl = de % bc
	lxi	h,0
	mvi	a,10H
L0007:
	push	psw
	dad	h
	xchg
	sub	a
	dad	h
	xchg
	adc	l
	sub	c
	mov	l,a
	mov	a,h
	sbb	b
	mov	h,a
	inx	d
	jnc	L0019
	dad	b
	dcx	d
L0019:
	pop	psw
	dcr	a
	jnz	L0007
	ret
	end
p0095.asm
	name	@P0095
	public	@P0095
	cseg

@P0095:			; hl = de - hl
	mov	a,e
	sub	l
	mov	l,a
	mov	a,d
	sbb	h
	mov	h,a
	ret
	end
p0100.asm
	name	@P0100
	public	@P0100
	cseg

@P0100:			; hl = w[de] - bc
	ldax	d
	sub	c
	mov	l,a
	inx	d
	ldax	d
	sbb	b
	mov	h,a
	ret
	end
path.plm
path: do;
$include(path.ipx)

declare devTab(*) byte data('F0F1F2F3TITOVIVOI1O1TRHRR1R2TPHPP1P2LPL1BBCICO');
declare lastpath(15) byte;

declare TRUE	literally '0ffh',
	FALSE	literally '0';

PATH: procedure(filename, pn) byte public;
	declare (filename, pn) address;
	declare pathPtr address, devPair address, (loByte, hiByte) byte at (.devPair),
		devPtr address, (noName, pl, i) byte;
	declare pnByte based pn (10) byte;
	declare fileChar based filename (1) byte, pathChar based pathPtr (1) byte;
	declare devTabPair based devPtr address;

	isFileNameChar: procedure byte;
		return 'A' <= fileChar(0) and fileChar(0) <= 'Z' or
		   '0' <= fileChar(0) and fileChar(0) <= '9' or
		   'a' <= fileChar(0) and fileChar(0) <= 'z';
	end;


	devPtr = .devTab;
	do i = 0 to 9;
		pnByte(i) = 0;
	end;
	do while fileChar(0) = ' ';
		filename = filename + 1;
	end;

	pathptr = filename;
	if pathChar(0) = ':' then
	do;
		pnByte(0) = 255;
		if fileChar(3) <> ':' then
			return 4;
		filename = filename + 1;
		loByte = uppercase(fileChar(0));
		filename = filename + 1;
		hiByte = uppercase(fileChar(0));
		filename = filename + 2;
		i = 0;
		do while i < last(devTab);
			if devTabPair =  devPair then
				pnByte(0) = shr(i, 1);
			i = i + 2;
			devPtr = devPtr + 2;
		end;
		if pnByte(0) = 255 then
			return 5;
	end;
	noName = TRUE;
	i = 1;
	do while i < 7;
		if isFileNameChar then
		do;
			pnByte(i) = uppercase(fileChar(0));
			filename = filename + 1;
			noName = FALSE;
		end;
		i = i + 1;
	end;
	if fileChar(0) = '.' then
	do;
		filename = filename + 1;
		i = 7;
		do while i < 10;
			if isFileNameChar then
			do;
				pnByte(i) = uppercase(fileChar(0));
				filename = filename + 1;
			end;
			i = i + 1;
		end;
	end;
	if pnByte(0) <= 3 and noName then
		return 17h;
	
	pl = 255;
	do while pathPtr < filename;
		lastpath(pl := pl + 1) = pathChar(0);
		pathPtr = pathPtr + 1;
	end;
	if lastpath(pl) = '.' then
		return 1ch;
	lastpath(pl + 1) = ' ';
	if isFileNameChar or fileChar(0) = '.' or fileChar(0) = ':' then
		return 4;
	return 0;
end;
end;

reperr.plm
REPORTERROR: DO;
$include(reperr.ipx)

declare msg(*) byte DATA(0, 0,
	2, 'ILLEGAL AFTN ARGUMENT', 0,
	4, 'INCORRECTLY SPECIFIED FILE', 0,
	5, 'UNRECOGNIZED DEVICE NAME', 0,
	6, 'ATTEMPT TO WRITE TO INPUT DEVICE', 0,
	8, 'ATTEMPT TO READ FROM OUTPUT DEVICE', 0,
	0AH, 'NOT ON SAME DISK', 0,
	0BH, 'FILE ALREADY EXISTS', 0,
	0CH, 'FILE IS ALREADY OPEN', 0,
	0DH, 'NO SUCH FILE', 0,
	0EH, 'WRITE PROTECTED', 0,
	11H, 'NOT A DISK FILE', 0,
	12H, 'ILLEGAL ISIS COMMAND', 0,
	13H, 'ATTEMPTED SEEK ON NON-DISK FILE', 0,
	14H, 'ATTEMPTED BACK SEEK TOO FAR', 0,
	15H, 'CAN', 27H, 'T RESCAN', 0,
	16H, 'ILLEGAL ACCESS MODE TO OPEN', 0,
	17H, 'MISSING FILENAME', 0,
	19H, 'ILLEGAL ECHO FILE', 0,
	1AH, 'ILLEGAL ATTRIBUTE IDENTIFIER', 0,
	1BH, 'ILLEGAL SEEK COMMAND', 0,
	1CH, 'MISSING EXTENSION', 0,
	1FH, 'CAN', 27H, 'T SEEK ON WRITE ONLY FILE', 0,
	20H, 'CAN', 27H, 'T DELETE OPEN FILE', 0,
	23H, 'SEEK PAST EOF', 0,
	0C9H, 'UNRECOGNIZED SWITCH', 0,
	0CAH, 'UNRECOGNIZED DELIMITER', 0,
	0CBH, 'INVALID SYNTAX', 0,
	0CCH, 'PREMATURE EOF', 0,
	0CEH, 'ILLEGAL DISKETTE LABEL', 0,
	0D0H, 'CHECKSUM ERROR', 0,
	0D1H, 'RELO FILE SEQUENCE ERROR', 0,
	0D2H, 'INSUFFICIENT MEMORY', 0,
	0D3H, 'RECORD TOO LONG', 0,
	0D4H, 'ILLEGAL RELO RECORD', 0,
	0D5H, 'FIXUP BOUNDS ERROR', 0,
	0D6H, 'ILLEGAL SUBMIT PARAMETER', 0,
	0D7H, 'ARGUMENT TOO LONG', 0,
	0D8H, 'TOO MANY PARAMETERS', 0,
	0D9H, 'OBJECT RECORD TOO SHORT', 0,
	0DAH, 'ILLEGAL RECORD FORMAT', 0,
	0DBH, 'PHASE ERROR', 0
	);

reportError: procedure(errNum) public;
	declare errNum address;
	declare numberBuffer(3) byte, i address, status address;
 

	if errNum <> 0 then
	do;
		i = 0;
		do while i < size(msg);
			if errNum = msg(i) and msg(i + 1) <> 0 then
			do;
				i = i + 1;
				call write(0, .(' '), 1, .status);
				do while msg(i) <> 0;
					call write(0, .msg(i), 1, .status);
					i = i + 1;
				end;
				call write(0, .(0dh, 0ah), 2, .status);
				return;
			end;
			else
			do;
				do while msg(i) <> 0;
					i = i + 1;
				end;
				i = i + 1;
			end;
		end;
	call error(errNum);
	end;
end;
end;

scnblk.plm
SCANBLANK: DO;
$include(scnblk.ipx)

Scanblank: procedure(ptr) address public;
	declare ptr address, ch based ptr byte;

	do while (1);
		ptr = delimit(ptr);
		if ch = '*' or ch = '?' then
			ptr = ptr + 1;
		else
			return ptr;
	end;
end;
end;
seq.plm
SEQ: DO;
seq: procedure(s1, s2, cnt) byte public;
	declare (s1,s2) address, cnt byte;
	declare s1a based s1(1) byte;
	declare s2a based s2(1) byte;
	declare i byte;
	cnt = cnt - 1;
	do i = 0 to cnt;
		if s1a(i) <> s2a(i) then
			return 0;
	end;
	return 0ffh;
end;
end;

setblk.plm
SetBlock: do;
$include(setblk.ipx)
SetBlock: procedure(adr) public;
	declare adr address;
	declare byt byte;

	adr = high(adr) * 26 + low(adr) - 1;
x:  /* de optmise */
	byt = shr(adr, 3);
/* newer compilers use de rather than bc to index into bitmap,
   older code was mov c,m ! mvi b,0 ! lxi h,bitmap ! dad b
   newer code is  mvi d,0 ! lxi h,bitmap ! dad b
   use an enable to pad out code to align, fix with patch later
*/
    ENABLE;
	bitmap(byt) = bitmap(byt) or maskArray(low(adr) and 7);
end;
end;
unpath.plm
unpath: do;

declare devTab(*) byte data('F0F1F2F3TITO',
			     'VIVOI1O1TRHRR1R2',
			     'TPHPP1P2LPL1BBCICO');

Unpath:	procedure(int, ext) public;
	declare (int, ext) address;
	declare i byte;
	declare intName based int (1) byte;
	declare extName based ext (1) byte;

	extName(0) = ':';
	extName(1) = devTab(intName(0) + intName(0));
	extName(2) = devTab(intName(0) + intName(0) + 1);
	extName(3) = ':';	
	ext = ext + 4;
	do i = 0 to 5;
		if (extName(0) := intName(i + 1)) <> 0 then
			ext = ext + 1; 
	end;
	if intName(7) <> 0 then
	do;
		extName(0) = '.';
		ext = ext + 1;
	end;
	do i = 0 to 2;
		if (extName(0) := intName(i + 7)) <> 0 then
			ext = ext + 1; 
	end;
	extName(0) = ' ';
end;
end;

upcase.plm
UPPERCASE: DO;
uppercase: procedure(char) byte public;
	declare char byte;
	if char < 'a' then
		return char;
	if char > 'z' then
		return char;
	return char and 0dfh;
end;
end;

wrdir.plm
WriteDirectory: do;
$include(wrdir.ipx)

declare file(5) structure(name(9) byte) data(
                         'ISIS',0,0,'DIR',
					     'ISIS',0,0,'MAP',
					     'ISIS',0,0,'T0',0,
					     'ISIS',0,0,'BIN',
					     'ISIS',0,0,'LAB');

WriteDirectory: procedure(drive) public;
	declare	drive byte, i byte, jj address, dirBuf(64) address,
		direct(8) DIRECT$T;

   
    do i = 0 to 255;
        bitmap(i) = 0;
    end;
    call clearBuf(.dirBuf);
    dirBuf(2) = 1;
    do i = 2 to 23;
        dirbuf(i + 1) = dirbuf(i) + 1;
    end;
    call absio(CMD$WRITE, drive, 18h, .dirbuf);
    call clearBuf(.dirbuf);

    dirbuf(2) = 1ah;
    do i = 2 to 1;
        dirbuf(i + 1) = dirbuf(i) + 1;
    end;

    call absio(CMD$WRITE, drive, 19h, .dirbuf);
    call clearBuf(.dirbuf);

    dirbuf(2) = 102h;
    do i = 2 to 25;
        dirbuf(i + 1) = dirbuf(i) + 1;
    end;
    call absio(CMD$WRITE, drive, 101h, .dirbuf);
    call clearBuf(.dirbuf);

    dirbuf(2) = 202h;
    do i = 2 to 2;
        dirbuf(i + 1) = dirbuf(i) + 1;
    end;
    call absio(CMD$WRITE, drive, 201h, .dirbuf);
    call clearBuf(.dirbuf);

    call absio(CMD$WRITE, drive, 204h, .dirbuf);

    call clearBuf(.direct);	

	/* isis.dir */
	call moveascii(.direct(0).file, .file(0), 9);
    direct(0).blk = 25;

	direct(0).hdrblk = 101h;	/* linkage at t1 s1 */
    direct(0).empty = 0;
	direct(0).attrib = 1;
	direct(0).eof$count = 128;

	/* isis.map */
	call moveascii(.direct(1).file, .file(1), 9);
	direct(1).blk = 2;
	direct(1).hdrblk = 201h;	/* linkage at t2 s1 */
    direct(1).empty = 0;
	direct(1).attrib = 1;
	direct(1).eof$count = 128;

	/* isis.t0 */
	call moveascii(.direct(2).file, .file(2), 9);
	direct(2).blk = 17h;
	direct(2).hdrblk = 18h;		/* linkage at t0 s24 */
    direct(2).empty = 0;
	direct(2).attrib = 1;
	direct(2).eof$count = 128;

	/* isis.lab */
	call moveascii(.direct(3).file, .file(4), 9);
    direct(3).blk = 1;
	direct(3).hdrblk = 19h;		/* linkage at t0 s25 */
    direct(3).empty = 0;
	direct(3).attrib = 1;
	direct(3).eof$count = 128;

	/* isis.bin */
	call moveascii(.direct(4).file, .file(3), 9);
    direct(4).blk = 0;
	direct(4).hdrblk = 204h;
    direct(4).empty = 0;
	direct(4).attrib = 3;
	direct(4).eof$count = 128;

	/* flag as no further entries */
	do i = 5 to 7;
		direct(i).empty = 7fh;
	end;

    call absio(CMD$WRITE, drive, 102h, .direct);
    call clearBuf(.direct);

	do i = 0 to 7;
		direct(i).empty = 7fh;
	end;

	do i = 2 to 25;
		call absio(6, drive, 101h + i, .direct);
	end;
    call SetBlock(101h);
    
	do jj = 102h to 11Ah;
        call SetBlock(jj);
    end;

    call SetBlock(201h);
	do jj = 202h to 203h;
        call SetBlock(jj);
    end;

    call SetBlock(18h);
    do jj = 1 to 17h;
        call SetBlock(jj);
    end;

    call SetBlock(19h);
    do jj = 1Ah to 1Ah;
        call SetBlock(jj);
    end;

    call SetBlock(204h);
    call Absio(CMD$WRITE, drive, 202h, .bitmap);
    call Absio(CMD$WRITE, drive, 203h, .bitmap + 128);

end;
end;
