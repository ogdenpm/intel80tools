link.pex
LIT             'LITERALLY'
ERR2            '2'		/* Illegal AFTN Argument */
ERR3            '3'		/* Too many Open files */
ERR4            '4'		/* Incorrectly speficied file */
ERR5            '5'		/* Unrecognised device name */
ERR9            '9'		/* Disk directory full */
ERR12           '0CH'		/* File is already Open */
ERR13           '0DH'		/* No such file */
ERR14           '0EH'		/* Write protected */
ERR17           '11H'		/* Not a disk file */
ERR19           '13H'		/* Attempted Seek on non-disk file */
ERR20           '14H'		/* Attemted back Seek too far */
ERR21           '15H'		/* Can''t rescan */
ERR22           '16H'		/* Illegal access mode to Open */
ERR23           '17H'		/* Missing filename */
ERR27           '1BH'		/* Illegal Seek command */
ERR28           '1CH'		/* Missing extension */
ERR31           '1FH'		/* can''t Seek on Write only file */
ERR32           '20H'		/* Can''t delete Open file */
ERR34           '22H'		/* Illegal Load command */
ERR35           '23H'		/* Seek past EOF */
ERR203          '0CBH'		/* Invalid syntax */
ERR204          '0CCH'		/* Premature EOF */
ERR208          '0D0H'		/* Checksum Error */
ERR210          '0D2H'		/* Insufficient memory */
ERR211          '0D3H'		/* Record too long */
ERR212          '0D4H'		/* Illegal relo record */
ERR213          '0D5H'		/* Fixup bounds Error */
ERR218          '0DAH'		/* Illegal record format */
ERR219          '0DBH'		/* Phase Error */
ERR220          '0DCH'		/* No EOF */
ERR221          '0DDH'		/* Segment too large */
ERR224          '0E0H'		/* Bad record sequence */
ERR225          '0E1H'		/* Invalid name */
ERR226          '0E2H'		/* Name too long */
ERR227          '0E3H'		/* Left parenthesis expected */
ERR228          '0E4H'		/* Right parenthesis expected */
ERR229          '0E5H'		/* Unrecognised control */
ERR233          '0E9H'		/* 'TO' expected */
ERR234          '0EAH'		/* Duplicate file name */
ERR235          '0EBH'		/* Not a library */
ERR236          '0ECH'		/* Too many common segments */
ERR238          '0EEH'		/* Illegal stack content record */
ERR239	        '0EFH'		/* No module header record */

/* relocatable record types */
R$MODHDR        '2'
R$MODEND        '4'
R$CONTENT       '6'
R$LINENO        '8'
R$EOF	        '0EH'
R$ANCESTOR      '10H'
R$LOCALS        '12H'
R$PUBLICS       '16H'
R$EXTNAMES      '18H'
R$EXTREF        '20H'
R$RELOC	        '22H'
R$INTERSEG      '24H'
R$LIBLOCS       '26H'
R$LIBNAMES      '28H'
R$LIBDICT       '2AH'
R$LIBHDR        '2CH'
R$COMDEF        '2EH'

/* segment types */
SEG$ABS         '0'
SEG$CODE        '1'
SEG$DATA        '2'
SEG$STACK       '3'
SEG$MEMORY      '4'
SEG$RESERVE     '5'		/* reserved for future Intel use */
SEG$NAMCOM      '6'
SEG$BLANK       '255'

/* fixup types */
FIX$UNDEF       '0'
FIX$LOW	        '1'
FIX$HI	        '2'
FIX$BOTH        '3'

/* alignment types */
ALN$UNDEF       '0'
ALN$INPAGE      '1'
ALN$PAGE        '2'
ALN$BYTE        '3'
ALN$NONE        '255'		/* special value used to indicate named common procssed or gap */

/* module type */
MT$NOTMAIN      '0'
MT$MAIN         '1'

/* flags */
F$ALNMASK       '0FH'
F$SCOPEMASK     '0F0H'
F$EXTERN        '40H'
F$PUBLIC        '80H'

/* misc */
TRUE            '0FFH'
FALSE           '0'
CR              '0DH'

/* user types */
COMINFO$T       'STRUCTURE (COMINFO$T1,COMINFO$T2)'
COMINFO$T1      'hashLink ADDRESS, flags BYTE, linkedSeg BYTE'
COMINFO$T2      'len ADDRESS, segOrderLink ADDRESS, name(1) BYTE'
HASH$T          'STRUCTURE (hashLink ADDRESS, flags BYTE, linkedSeg BYTE, val ADDRESS, link ADDRESS, name(1) BYTE)'
LIBRARY$T       'STRUCTURE (link ADDRESS, modlist ADDRESS, publicsMode BYTE, hasModules BYTE, name(1) BYTE)'
MODULE$T        'STRUCTURE (MODULE$T1,MODULE$T2)'
MODULE$T1       'link ADDRESS, blk ADDRESS, byt ADDRESS, symlist ADDRESS'
MODULE$T2       'scode ADDRESS, sdata ADDRESS, name(1) BYTE'
SPATH$T         'STRUCTURE (deviceId BYTE, name(6) BYTE, ext(3) BYTE, deviceType BYTE, driveType BYTE)'
SYMBOL$T        'STRUCTURE (SYMBOL$T1,SYMBOL$T2)'
SYMBOL$T1       'hashLink ADDRESS, flags BYTE, linkedSeg BYTE, offsetOrSym ADDRESS'
SYMBOL$T2       'nxtSymbol ADDRESS, name(1) BYTE'
RECORD$ST	'STRUCTURE (type BYTE, len ADDRESS, rec(1) BYTE)'	/* start of a record */
COMSEGINFO$T    'STRUCTURE (combine BYTE, lenOrLinkedSeg ADDRESS)'
OMFNAME$T	'STRUCTURE (len BYTE, name(1) BYTE)'			/* structure of an OMF name */
SEGFRAG$T       'STRUCTURE (link ADDRESS, bot ADDRESS, top ADDRESS)'

/* common based vars */
cmdbuf          BS..cmd$p
cmdch           B..cmd$p
comdefInfo      "COMINFO$T"..comdefInfo$p
comSegInfo	"COMSEGINFO$T"S..comSegInfo$p
erec            B..erec$p
hmodule         "MODULE$T"..hmodule$p
inOMFName       "OMFNAME$T"..in$p
inRecord        "RECORD$ST"..inRecord$p
module          "MODULE$T"..curModule
objFile         "LIBRARY$T"..curObjFile
outOMFName      "OMFNAME$T"..out$p
outRecord       "RECORD$ST"..outRecord$p
rbytes          BS..in$p
rwords          AS..in$p
segFrag         "SEGFRAG$T"..segFrag$p
symbol          "SYMBOL$T"..symbol$p

$file(system.lib)
IOPEN           '0'
ICLOSE          '1'
IDELETE         '2'
IREAD           '3'
IWRITE          '4'
ISEEK           '5'
ILOAD           '6'
IRENAME         '7'
ICONSOL         '8'
IEXIT           '9'
IATTRIB         '10'
IRESCAN         '11'
IERROR          '12'
IWHOCON         '13'
ISPATH          '14'
delete          P(A path$p,A status$p)
rescan          P(A conn,A status$p)
spath           P(A path$p,A info$p,A status$p)
memck           PA


$file(binasc.plm)
BinAsc          P(A num,B base,B padch,A bufp,B width)

$file(errrpt.plm)
FileError    P(A errCode,A file,B errExit)

$file(isis.plm)
Close           P(A conn,A status$p)
Error           P(A Error$num)
Exit            P
Load            P(A path$p,A Load$offset,A switch,A entry$p,A status$p)
Open            P(A conn$p,A path$p,A access,A echo,A status$p)
Read            P(A conn,A buff$p,A count,A actual$p,A status$p)
Seek            P(A conn,A mode,A block$p,A byte$p,A status$p)
Write           P(A conn,A buff$p,A count,A status$p)

$file(isisen.asm)
isis            P(B type,A parameter$ptr)

$file(lineuc.plm)
CrStrUpper      P(A PCH)

$file(link.plm)
actRead         A
alignType       BS
membot        A
buf$p           A
comdefInfo$p    A
CRLF            BS
curModule       A
curObjFile      A
mapWanted           B
DUMMYREC        BS
ebuf$p          A
modEndOffset       A
modEndSegId        B
eout$p          A
erec$p          A
filePath        BS
hashTab      AS
headSegOrderLink A
headUnresolved  A
inBlk           A
inb$p           A
inByt           A
inCRC           B
inFileName      BS
in$p            A
inRecord$p      A
linkTmpFile     BS
maxExternCnt    A
outTranId       B
outTranVn       B
modEndModTyp   B
outModuleName      BS
npbuf           A
objFileHead     A
out$p           A
pad$4565        A
printFileName   BS
printFileNo     A
inFile          A
recErrMsg       BS
recLen          A
recNum          A
sbuf$p          A
segLen          AS
segmap          BS
sout$p          A
statusIO        A
symbol$p        A
tmpfilefd       A
tofilefd        A
toFileName      BS
topHeap         A
unresolved      A
VERSION         BS
BadRecordSeq    P
ConOutStr       P(A pstr,A count)
FatalErr        P(B errCode)
Lookup            P(A pstr,A pitem$ref,B mask)B
HashF            P(A pstr)B
IllFmt   P
IllegalRelo     P
Pstrcpy         P(A psrc,A pdst)
WAEFnAndMod     P(A buff$p,A count)
WriteAndEcho    P(A buff$p,A count)
WriteBytes      P(A buf$p,A count)
WriteCRLF       P

$file(link1a.plm)
GetLow       P(A count)A
GetHigh         P(A count)A
ChkRead         P(A cnt)
CloseObjFile    P
GetRecord       P
Position          P(A blk,A byt)
OpenObjFile     P

$file(link3.plm)
ChainUnresolved P
CreateFragment  P(B seg,A bot,A top)
ExpectType      P(B type)
P1CommonSegments P
P1LibScan       P
P1LibUserModules P
P1StdSegments   P
Pass1COMDEF     P
Pass1CONTENT    P
Pass1EXTNAMES   P
P1ModEnd     P
P1ModHdr     P
Pass1PUBNAMES   P
Phase1          P
PrimeRecord     P
P1Records    P(B newModule)
ReadBlkByt      P
ReadName        PB
SelectInSeg     P(B seg)B
SkipRecord      P
WriteBaseSizeAlign P(A baddr,A bsize,B align)
WriteStats      P

$file(link3a.plm)
controls        BS
AddFileToInputList P
CheckFile       P
ChkLP           P
ChkRP           P
ErrNotDiscFile  P
ExpectChar      P(B ch,B errCode)
ExpectComma     P
FatalCmdLineErr P(A errCode)
GetInputListItem P
GetModuleName   P(A pstr)
ParseCmdLine    P
ParseControl    P
ReadCmdLine     P
SkipNonArgChars P(A arg1w)

$file(linkov.plm)
modName         BS
msgrefin        BS
outRecord$p     A
OVERLAYVERSION  BS
AddExtMap       P(A sym$p)
Emit$ANCESTOR   P
EmitCOMDEF      P
EmitEnding      P
EmitEXTNAMES    P
EmitMODHDR      P
EmitPUBLICS     P
EndRecord       P
ExtendRec       P(A cnt)B
FlushTo         P
GetSymbol$p     P(A symId)A
InitExternsMap  P
InitRecord      P(B type)
PageInExtMap    P
PageOutExtMap   P
Pass2ANCESTOR   P
Pass2COMDEF     P
Pass2CONTENT    P
Pass2EXTNAMES   P
Pass2LINENO     P
Pass2LOCALS     P
Pass2MODHDR     P
Phase2          P
SeekExtMap      P
SelectOutSeg    P(B seg)B

$file(merge.pl)

$file(mkfnam.plm)
MakeFullName    P(A pinfo,A pstr)

$file(MemMov.asm)
MemMov          P(A cnt,A srcp,A dstp)

$file(pstafn.plm)
ScanBlank         P(A pch)A

$file(pstfn.plm)
Delimit    P(A pch)A

$file(skpspc.plm)
Deblank         P(A pch)A

$file(strequ.plm)
Strequ          P(A str1p,A str2p,B cnt)B

$file(wrerr.plm)
ReportError     P(A errCode)
binasc.plm
$xref
/*	Copyright (c) 2012 by Mark Ogden
	Released into the public domain for academic historic interest
	only and not for commercial gain. */
bin2a:
DO;
DECLARE hexdigits(*) BYTE DATA ('0123456789ABCDEF');

BinAsc: PROCEDURE(num, base, padch, bufp, width) PUBLIC;
	DECLARE num ADDRESS;
	DECLARE (base, padch) BYTE;
	DECLARE bufp ADDRESS;
	DECLARE width BYTE;

	DECLARE i BYTE;
	DECLARE buf BASED bufp (1) BYTE;

	DO i = 1 TO width;
		buf(width - i) = hexdigits(num MOD base);
		num = num / base;
	END;
	i = 0;
	DO WHILE buf(i) = '0' AND i < width - 1;
		buf(i) = padch;
		i = i + 1;
	END;
END BinAsc;
END;
errrpt.plm
$xref
/*	Copyright (c) 2012 by Mark Ogden
	Released into the public domain for academic historic interest
	only and not for commercial gain. */
errrpt:
DO;
$include(errrpt.ipx)

FileError: PROCEDURE(errCode, file, errExit) PUBLIC;
	DECLARE errCode ADDRESS;
	DECLARE file ADDRESS;
	DECLARE errExit BYTE;
	DECLARE status ADDRESS;

	IF errCode <> 0 THEN
	DO;
		file = Deblank(file);
		CALL Write(0, .(' '), 1, .status);
		CALL Write(0, file , ScanBlank(file) - file, .status);
		CALL Write(0, .(','), 1, .status);
		CALL ReportError(errCode);
		IF errExit THEN
			CALL Exit;
	END;
END FileError;
END;
isis.plm
$xref
/*	Copyright (c) 2012 by Mark Ogden
	Released into the public domain for academic historic interest
	only and not for commercial gain. */
isissub:
DO;
$include(isis.ipx)

Close: procedure (conn, status$p) public;
    declare (conn, status$p) address;
    CALL ISIS(ICLOSE, .conn);
end Close;


Error: procedure (Error$num) public;
    declare (Error$num) address;
    declare err address;
    err = .err;
    CALL ISIS(IERROR, .Error$num);
end Error;

Exit: procedure public;
	DECLARE exitarg ADDRESS;
	exitarg = .exitarg;
	CALL ISIS(IEXIT, .exitarg);
end Exit;

Load: procedure (path$p, Load$offset, switch, entry$p, status$p) public;
    declare (path$p, Load$offset, switch, entry$p, status$p) address;
    CALL ISIS(ILOAD, .path$p);
end Load;


Open: procedure (conn$p, path$p, access, echo, status$p) public;
    declare (conn$p, path$p, access, echo, status$p) address;
    CALL ISIS(IOPEN, .conn$p);
end Open;


Read: procedure (conn, buff$p, count, actual$p, status$p) public;
    declare (conn, buff$p, count, actual$p, status$p) address;
    CALL ISIS(IREAD, .conn);
end Read;

Seek: procedure (conn, mode, block$p, byte$p, status$p) public;
    declare (conn, mode, block$p, byte$p, status$p) address;
    CALL ISIS(ISEEK, .conn);
end Seek;

Write: procedure (conn, buff$p, count, status$p) public;
    declare (conn, buff$p, count, status$p) address;
    CALL ISIS(IWRITE, .conn);
end Write;



END;
lineuc.plm
$xref
/*	Copyright (c) 2012 by Mark Ogden
	Released into the public domain for academic historic interest
	only and not for commercial gain. */
lineuc:
DO;
$include(lineuc.ipx)

CrStrUpper: PROCEDURE(PCH) PUBLIC;
	DECLARE PCH ADDRESS;
	DECLARE CH BASED PCH BYTE;

	ToUpper: PROCEDURE(CH) BYTE;
		DECLARE CH BYTE;

		IF CH < 'a' THEN
			RETURN CH;
		IF CH > 'z' THEN
			RETURN CH;
		RETURN CH AND 0DFH;
	END ToUpper;

	DO WHILE CH <> CR;
		CH = ToUpper(CH);
		PCH = PCH + 1;
	END;




END CrStrUpper;
END;
link.plm
$xref
/*	Copyright (c) 2012 by Mark Ogden
	Released into the public domain for academic historic interest
	only and not for commercial gain. */
link:
DO;
$INCLUDE(link.ipx)

DECLARE
	inFile ADDRESS PUBLIC,
	tofilefd ADDRESS PUBLIC,
	printFileNo ADDRESS PUBLIC,
	pad$4565 ADDRESS PUBLIC,
	tmpfilefd ADDRESS PUBLIC,
	statusIO ADDRESS PUBLIC,
	actRead ADDRESS PUBLIC,
	inFileName(16) BYTE PUBLIC,
	toFileName(16) BYTE PUBLIC,
	printFileName(16) BYTE PUBLIC,
	filePath(16) BYTE PUBLIC,
	linkTmpFile(16) BYTE PUBLIC,
	mapWanted BYTE PUBLIC,
	outModuleName(32) BYTE PUBLIC,
	modEndModTyp BYTE PUBLIC,
	outTranId BYTE PUBLIC,
	outTranVn BYTE PUBLIC,
	modEndSegId BYTE PUBLIC,
	modEndOffset ADDRESS PUBLIC,
	segLen(6) ADDRESS PUBLIC,
	alignType(6) BYTE PUBLIC,
	segmap(256) BYTE PUBLIC,
	membot ADDRESS PUBLIC,
	topHeap ADDRESS PUBLIC,
	inRecord$p ADDRESS PUBLIC,
	erec$p ADDRESS PUBLIC,
	in$p ADDRESS PUBLIC,
	recNum ADDRESS PUBLIC,
	recLen ADDRESS PUBLIC,	
	npbuf ADDRESS PUBLIC,
	sbuf$p ADDRESS PUBLIC,
	buf$p ADDRESS PUBLIC,
	ebuf$p ADDRESS PUBLIC,
	sout$p ADDRESS PUBLIC,
	out$p ADDRESS PUBLIC,
	eout$p ADDRESS PUBLIC,
	objFileHead ADDRESS PUBLIC,
	curObjFile ADDRESS PUBLIC,
	curModule ADDRESS PUBLIC,
	hashTab(128) ADDRESS PUBLIC,
	headSegOrderLink ADDRESS PUBLIC,
	comdefInfo$p ADDRESS PUBLIC,
	symbol$p ADDRESS PUBLIC,
	unresolved ADDRESS PUBLIC,
	maxExternCnt ADDRESS PUBLIC,
	headUnresolved ADDRESS PUBLIC,
	CRLF (2) BYTE PUBLIC INITIAL (0DH, 0AH),
	recErrMsg(*) BYTE PUBLIC INITIAL (' RECORD TYPE XXH, RECORD NUMBER *****', 0DH, 0AH),
					/*	     13-^		32-^	    */
	inBlk ADDRESS PUBLIC,
	inByt ADDRESS PUBLIC,
	inb$p ADDRESS PUBLIC,
	inCRC BYTE PUBLIC;

/* explicit declare here because inRecord$p and curModule defined after the include file */
declare	inRecord based inRecord$p  RECORD$ST, 
	module based curModule MODULE$T;


DECLARE COPYRIGHT(*) BYTE DATA('(C) 1976, 1977, 1979 INTEL CORP'),
	VERSION(*) BYTE PUBLIC DATA('V3.0'),
	DUMMYREC(*) BYTE PUBLIC DATA(0,0,0);

/* EXTERNALS */
DECLARE overlayVersion(4) BYTE EXTERNAL;

ReportError: PROCEDURE(errcode) EXTERNAL;
	DECLARE errcode ADDRESS;
END ReportError;

BinAsc: PROCEDURE(num, base, padch, bufp, width) EXTERNAL;
	DECLARE num ADDRESS, (base, padch) BYTE, bufp ADDRESS, width BYTE;
END BinAsc;

MemMov: PROCEDURE(cnt, srcp, dstp) EXTERNAL;
	DECLARE (cnt, srcp, dstp) ADDRESS;
END MemMov;

Strequ: PROCEDURE(str1p, str2p, cnt) BYTE EXTERNAL;
	DECLARE (str1p, str2p) ADDRESS;
	DECLARE cnt BYTE;
END Strequ;

FileError: PROCEDURE(errCode, file, errExit) EXTERNAL;
	DECLARE errCode ADDRESS;
	DECLARE file ADDRESS;
	DECLARE errExit BYTE;
END FileError;

ParseCmdLine: PROCEDURE EXTERNAL;
END ParseCmdLine;

Phase1: PROCEDURE EXTERNAL;
END Phase1;

Phase2: PROCEDURE EXTERNAL;
END Phase2;

ConOutStr: PROCEDURE(pstr, count) PUBLIC;
	DECLARE pstr ADDRESS;
	DECLARE count ADDRESS;
	
	CALL Write(0, pstr, count, .statusIO);
END ConOutStr;

FatalErr: PROCEDURE(errCode) PUBLIC;
	DECLARE errCode BYTE;

	CALL ConOutStr(.(' '), 1);
	CALL ConOutStr(.inFileName(1), inFileName(0));
	IF curModule > 0 THEN
	DO;
		CALL ConOutStr(.('('), 1);
		CALL ConOutStr(.module.name(1), module.name(0));
		CALL ConOutStr(.(')'), 1);
	END;
	CALL ConOutStr(.(','), 1);
	CALL ReportError(errCode);
	CALL BinAsc(inRecord.type, 16, '0', .recErrMsg(13), 2);
	IF recNum > 0 THEN
		CALL BinAsc(recNum, 10, ' ', .recErrMsg(32), 5);
	CALL ConOutStr(.recErrMsg, LENGTH(recErrMsg));
	CALL Exit;
END FatalErr;

IllFmt: PROCEDURE PUBLIC;
	CALL FatalErr(ERR218);	/* Illegal record format */
END IllFmt;

IllegalRelo: PROCEDURE PUBLIC;
	CALL FatalErr(ERR212);	/* Illegal relo record */
END IllegalRelo;

BadRecordSeq: PROCEDURE PUBLIC;
	CALL FatalErr(ERR224);	/* Bad record sequence */
END BadRecordSeq;

Pstrcpy: PROCEDURE(psrc, pdst) PUBLIC;
	DECLARE psrc ADDRESS;
	DECLARE pdst ADDRESS;
	DECLARE str BASED psrc(1) BYTE;

	CALL MemMov(str(0) + 1, psrc, pdst);
END Pstrcpy;

HashF: PROCEDURE(pstr) BYTE PUBLIC;
	DECLARE pstr ADDRESS;
	DECLARE str BASED pstr (1) BYTE;
	DECLARE (i, j) BYTE;

	j = 0;
	DO i = 0 TO str(0);
		j = ROR(j, 1) XOR str(i);
	END;
	RETURN j AND 07FH;
END HashF;

Lookup: PROCEDURE(pstr, pitem$ref, mask) BYTE PUBLIC;
	DECLARE (pstr, pitem$ref) ADDRESS, mask BYTE;
	DECLARE p ADDRESS;
	DECLARE i BYTE;
	DECLARE str BASED pstr(1) BYTE;
	DECLARE pitem BASED pitem$ref ADDRESS;	/* dereferenced out param */
	DECLARE item BASED p HASH$T;

	i = str(0) + 1;		/* size of string including length byte */
	pitem = (p := .hashTab(HashF(pstr)));
	p = item.hashLink;
	DO WHILE p > 0;		/* chase down the list to look for the name */
		pitem = p;
		IF (item.flags AND mask) <> ALN$UNDEF THEN	/* ignore undef entries */
			IF Strequ(pstr, .item.name, i) THEN
				RETURN TRUE;
		p = item.hashLink;	/* next */
	END;
	RETURN FALSE;
END Lookup;

WriteBytes: PROCEDURE(buf$p, count) PUBLIC;
	DECLARE buf$p ADDRESS;
	DECLARE count ADDRESS;
	
	CALL Write(printFileNo, buf$p, count, .statusIO);
	CALL FileError(statusIO, .printFileName(1), TRUE);
END WriteBytes;

WriteCRLF: PROCEDURE PUBLIC;
	CALL WriteBytes(.CRLF, 2);
END WriteCRLF;

WriteAndEcho: PROCEDURE(buff$p, count) PUBLIC;
	DECLARE buff$p ADDRESS;
	DECLARE count ADDRESS;
	
	CALL WriteBytes(buff$p, count);
	IF printFileNo > 0 THEN
		CALL ConOutStr(buff$p, count);
END WriteAndEcho;

WAEFnAndMod: PROCEDURE(buff$p, count) PUBLIC;
	DECLARE buff$p ADDRESS;
	DECLARE count ADDRESS;

	CALL WriteAndEcho(buff$p, count);
	CALL WriteAndEcho(.inFileName(1), inFileName(0));
	CALL WriteAndEcho(.('('), 1);
	CALL WriteAndEcho(.module.name(1), module.name(0));
	CALL WriteAndEcho(.(')',0DH, 0AH), 3);
END WAEFnAndMod;

main:
	CALL ParseCmdLine;
	CALL Phase1;
	CALL Load(.filePath(1), 0, 0, .actRead, .statusIO);	/* Load the overlay */
	CALL FileError(statusIO, .filePath(1), TRUE);
	IF NOT Strequ(.VERSION, .overlayVersion, 4) THEN	/* make sure it is valid */
		CALL FileError(ERR219, .filePath(1), TRUE);	/* phase Error */
	CALL Phase2;
	CALL Close(printFileNo, .statusIO);
	CALL Exit;

END link;

link1a.plm
$xref
/*	Copyright (c) 2012 by Mark Ogden
	Released into the public domain for academic historic interest
	only and not for commercial gain. */
link1a:
DO;
$include(link1a.ipx)

GetHigh: PROCEDURE(count) ADDRESS PUBLIC;
	DECLARE count ADDRESS;

	IF topHeap - membot >= count THEN
		RETURN (membot := membot + count) - count;
	CALL FileError(ERR210, .toFilename(1), TRUE);	/* Insufficient memory */
END GetHigh;

GetLow: PROCEDURE(count) ADDRESS PUBLIC;
	DECLARE count ADDRESS;
	IF topHeap - membot >= count THEN
		RETURN (topHeap := topHeap - count);
	CALL FileError(ERR210, .toFilename(1), TRUE);	/* Insufficient memory */
END GetLow;

ChkRead: PROCEDURE(cnt) PUBLIC;	/* make sure next cnt bytes are in the input buffer */
	DECLARE cnt ADDRESS;
	DECLARE bcnt ADDRESS;
	
	/* see if enough bytes in the i/o buf. if not shuffle down and reload more */
	IF (bcnt := ebuf$p - buf$p) < cnt THEN
	DO;
		CALL MemMov(bcnt, buf$p, sbuf$p);
		CALL Read(inFile, sbuf$p + bcnt, npbuf - bcnt, .actRead, .statusIO);
		CALL FileError(statusIO, .inFileName(1), TRUE);
		/* calculare new inBlk and inByt */
		inBlk = inBlk + (inByt + buf$p - sbuf$p) / 128;
		inByt = (inByt + buf$p - sbuf$p) MOD 128;
		IF (bcnt := bcnt + actRead) < cnt THEN
			CALL FileError(ERR204, .inFileName(1), TRUE);    /* Premature EOF */
		/* mark the new end */
		ebuf$p = (buf$p := sbuf$p) + bcnt;
	END;
END ChkRead;

GetRecord: PROCEDURE PUBLIC;
	DECLARE ch BASED inb$p BYTE;
	DECLARE bcnt ADDRESS;
	DECLARE erec BASED erec$p BYTE;
	DECLARE (s, e) ADDRESS AT(.inRecord$p);

	IF (bcnt := ebuf$p - buf$p) >= 4 THEN
	DO;
		inRecord$p = buf$p;
		/*erec$p = inRecord$p + inRecord.len + 2;	/* type + data + crc */
		e = s + inRecord.len + 2;	/* type + data + crc */
	END;
	ELSE
	DO;
		inRecord$p = .DUMMYREC;
		erec$p = 0FFFFH;
	END;
	IF erec$p >= ebuf$p THEN
		IF inRecord.len <= 1025 THEN	/* should be able to get all of record in buffer */
		DO;
			CALL ChkRead(bcnt + 1);
			inRecord$p = buf$p;
			IF (e := s + inRecord.len + 2) >= ebuf$p THEN /* redundant - done in ChkRead */
				CALL FileError(ERR204, .inFileName(1), TRUE);	/* premature EOF */
		END;
	recLen = inRecord.len;
	in$p =  inRecord$p + 3;
	buf$p = erec$p + 1;
	recNum = recNum + 1;
	IF inRecord.type > R$COMDEF OR inRecord.type THEN	/* > 2EH or odd */
		CALL IllegalRelo;
	IF inRecord.type = R$CONTENT THEN			/* content handled specially */
		RETURN;
	IF inRecord.type >= R$LIBLOCS  AND inRecord.type <= R$LIBDICT THEN
		return;						/* library records handled specially */
	IF recLen > 1025 THEN
		CALL FatalErr(ERR211);	/* record too long */
	inCRC = 0;					/* test checksum */
	DO inb$p = .inRecord.type TO .erec;
		inCRC = inCRC + ch;
	END;
	IF inCRC <> 0 THEN
		CALL FatalErr(ERR208);	/* checksum Error */
END GetRecord;

Position: PROCEDURE(blk, byt) PUBLIC;	/* Seek in input buffer */
	DECLARE (blk, byt) ADDRESS;

	/* check if already in memory, if so update buf$p only */
	IF inBlk <= blk AND blk <= (inByt + (ebuf$p - sbuf$p))  / 128 + inBlk THEN
	DO;
		IF (buf$p := sbuf$p + (blk - inBlk) * 128 + (byt - inByt))
		    >= sbuf$p AND buf$p < ebuf$p THEN
			RETURN;
	END;
	CALL Seek(inFile, 2, .blk, .byt, .statusIO);		/* Seek on disk */
	CALL FileError(statusIO, .inFileName(1), TRUE);
	recNum = 0;						/* reset vars and Read at least 1 byte */
	buf$p = ebuf$p;
	CALL ChkRead(1);
	inBlk = blk;
	inByt = byt;
END Position;

OpenObjFile: PROCEDURE PUBLIC;
	CALL Pstrcpy(.objfile.name(0), .inFilename(0));		/* copy the user supplied file name */
	inFileName(inFileName(0)+1) = ' ';			/* terminate with a space */
	CALL Open(.inFile, .inFileName(1), 1, 0, .statusIO);	/* Open the file */
	CALL FileError(statusIO, .inFileName(1), TRUE);
	recNum, curModule = 0;					/* reset vars and Read at least 1 byte */
	buf$p = ebuf$p;
	CALL ChkRead(1);
	inBlk, inByt = 0;
END OpenObjFile;

CloseObjFile: PROCEDURE PUBLIC;					/* Close file and link to next one */
	CALL Close(inFile, .statusIO);
	CALL FileError(statusIO, .inFileName(1), TRUE);
	curObjFile = objFile.link;
END CloseObjFile;

END link1a;
link3.plm
$xref
/*	Copyright (c) 2012 by Mark Ogden
	Released into the public domain for academic historic interest
	only and not for commercial gain. */
link3:
DO;
$include(link3.ipx)
DECLARE msgmultdef(*) BYTE INITIAL(' - MULTIPLELY DEFINED, DUPLICATE IN ');
DECLARE msgmore1main(*) BYTE INITIAL('MORE THAN 1 MAIN MODULE, CONFLICT IN ');
DECLARE msgmodnotinlib(*) BYTE INITIAL('MODULE NOT IN LIBRARY, LOOKING FOR ');
DECLARE msgbadcom(*) BYTE INITIAL('/ - UNEQUAL COMMON LENGTH, CONFLICT IN ');
DECLARE msglinkmap(*) BYTE INITIAL(0DH, 0AH, 'LINK MAP OF MODULE ');
DECLARE msgwrittento(*) BYTE INITIAL(0Dh, 0Ah, 'WRITTEN TO FILE ');
DECLARE msgmodtype(*) BYTE INITIAL(0Dh, 0Ah, 'MODULE IS A MAIN MODULE');
DECLARE msgnotmain(*) BYTE INITIAL(0Dh, 0Ah, 'MODULE IS NOT A MAIN MODULE');
DECLARE msgcomSegInfo(*) BYTE INITIAL(0Dh, 0Ah, 0Ah, 'SEGMENT INFORMATION:',
			       0Dh, 0Ah, 'START   STOP LENGTH REL NAME', 0Dh, 0Ah);
DECLARE msgmodincluded(*) BYTE INITIAL(0Dh, 0Ah, 0Ah,'INPUT MODULES INCLUDED:', 0Dh, 0Ah);
DECLARE msgunresolved(*) BYTE INITIAL(0Dh, 0Ah, 'UNRESOLVED EXTERNAL NAMES:', 0Dh, 0Ah);
DECLARE spc14(*) BYTE INITIAL('              ');
DECLARE a$range(*) BYTE INITIAL ('XXXXH  XXXXH  ');
DECLARE	a$size(*) BYTE INITIAL('XXXXH  X  ');
DECLARE msgGap(*) BYTE INITIAL('  *GAP*');
DECLARE msgOverlap(*) BYTE INITIAL('  *OVERLAP*');
DECLARE aInpageSegment(*) BYTE INITIAL('  *INPAGE SEGMENT > 256 BYTES*');
DECLARE msgPublics(*) BYTE INITIAL(' (PUBLICS)');
DECLARE slash2 (2) BYTE INITIAL ('//');
DECLARE aAbsolute(*) BYTE INITIAL('ABSOLUTE', 'CODE    ', 'DATA    ', 'STACK   ', 'MEMORY  ');
DECLARE	a$types(*) BYTE INITIAL(' AIPB');

DECLARE segUsed(6) BYTE,
	segToUse BYTE INITIAL(SEG$BLANK - 1),
	noCommonSeen BYTE INITIAL(TRUE),
	initTraiIdVn BYTE INITIAL(TRUE),
	comSegInfo$p ADDRESS INITIAL(0),
	segFrags(6) ADDRESS,
	segFrag$p ADDRESS,
	(curSegFrag$p, prevSegFrag$p) ADDRESS,
	tailSegOrderLink ADDRESS,
	nxtSymbol$p ADDRESS,
	hmodule$p ADDRESS,
	publicsMode BYTE,
	moreRecords BYTE,
	haveModuleHdr BYTE,
	inSegCombine BYTE,
	curseg BYTE,
	dummyrec BYTE,
	inSegLen ADDRESS,
	seg$i ADDRESS,
	symcnt ADDRESS,
	newUnresolved ADDRESS,
	externCnt ADDRESS,
	inSegOffset ADDRESS;

/* explicit declare of base vars as bases defined after include */
declare	comSegInfo based comSegInfo$p (256) COMSEGINFO$T,
	hmodule based hmodule$p MODULE$T,
	segFrag based segFrag$p SEGFRAG$T;

PrimeRecord: PROCEDURE PUBLIC;
	/* save the record type and con inRecord to believe it is a real record */
	dummyrec = inRecord.type;
	inRecord$p = .dummyrec;
	/* set live buf$p to where we have procssed to - keeps in buffer */
	buf$p = in$p;
END PrimeRecord;

SkipRecord: PROCEDURE PUBLIC;
	DO WHILE ebuf$p - buf$p < recLen;		/* Read in off disk if needed */
		recLen = recLen - (ebuf$p - buf$p);
		buf$p = ebuf$p;
		CALL ChkRead(1);
	END;
	buf$p = buf$p + recLen;				/* update buf$p to start of next record */
END SkipRecord;

ReadName: PROCEDURE BYTE PUBLIC;
	DECLARE len BASED in$p BYTE;	/* string length byte */

	CALL ChkRead(1);		/* make sure 1 char there */
	in$p = buf$p;			/* set to start of name */
	IF recLen < 2 THEN		/* only CRC left ? */
	DO;
		buf$p = buf$p + recLen;	/* advance and flag no more */
		RETURN recLen := 0;
	END;
	CALL ChkRead(len + 1);		/* check all of the name is there */
	in$p = buf$p;			/* in case it has moved */
	IF recLen < len + 1 THEN	/* overran */
		CALL IllFmt;
	buf$p = buf$p + len + 1;	/* past name */
	recLen = recLen - (len + 1);	/* account for name */
					/* in$p points to the name */
	RETURN TRUE;			/* Read a name */
END ReadName;

/* Read in 4 byte block num and byte num in$p points to the data, buf$p beyond it */
ReadBlkByt: PROCEDURE PUBLIC;
	IF recLen < DOUBLE(4) THEN
		CALL IllFmt;
	CALL ChkRead(4);
	buf$p = (in$p := buf$p) + DOUBLE(4);
	recLen = recLen - DOUBLE(4);
END ReadBlkByt;

/* get next record, test type, and Error if not as expected */
ExpectType: PROCEDURE(type) PUBLIC;
	DECLARE type BYTE;

	CALL GetRecord;
	recNum = 0;
	IF type <> inRecord.type THEN
		CALL BadRecordSeq;
END ExpectType;

/* print segment base, size and alignment */
WriteBaseSizeAlign: PROCEDURE(baddr, bsize, align) PUBLIC;
	DECLARE baddr ADDRESS;
	DECLARE bsize ADDRESS;
	DECLARE align BYTE;

	CALL WriteCRLF;
	IF (align := align + 1) <= 1 THEN	/* ALN$NONE or ALN$UNDEF */
	DO;	/* insert start and stop in hex */
		CALL BinAsc(baddr, 16, '0', .a$range, 4);	/* 'XXXXH  XXXXH  ' */
		CALL BinAsc(baddr + bsize - 1, 16, '0', .a$range(7), 4);
		CALL WriteBytes(.a$range, 14);	/* print start and stop */
	END;
	ELSE	/* replace start / stop with spaces */
		CALL WriteBytes(.spc14, LENGTH(spc14));
	/* format the size in hex */
	CALL BinAsc(bsize, 16, ' ', .a$size, 4);
	/* insert the align type ' AIPB' */
	a$size(7) = a$types(align);
	CALL WriteBytes(.a$size, 10);	/* print the size */
END WriteBaseSizeAlign;

/* wrtie module statistics */
WriteStats: PROCEDURE PUBLIC;
	DECLARE i BYTE;

	IF NOT mapWanted THEN	/* user doesn't want */
		RETURN;
	CALL WriteBytes(.msglinkmap, LENGTH(msglinkmap));	/* '\r\nLINK MAP OF MODULE ' */
	CALL WriteBytes(.outModuleName(1), outModuleName(0));		/* module name */
	CALL WriteBytes(.msgwrittento, LENGTH(msgwrittento));	/* '\r\nWRITTEN TO FILE ' */
	CALL WriteBytes(.toFileName(1), toFileName(0));		/* file name */
	IF modEndModTyp = MT$NOTMAIN THEN
		CALL WriteBytes(.msgnotmain, LENGTH(msgnotmain));	/* '\r\nMODULE IS NOT A MAIN MODULE' */
	ELSE
		CALL WriteBytes(.msgmodtype, LENGTH(msgmodtype));	/* '\r\nMODULE IS A MAIN MODULE' */
	CALL WriteBytes(.msgcomSegInfo, LENGTH(msgcomSegInfo));		/* '\r\n\nSEGMENT INFORMATION\r\n' */
									/* 'START   STOP LENGTH REL NAME\r\n */
	DO curseg = SEG$CODE TO SEG$MEMORY;	/* regular segments */
		IF segLen(curseg) > 0 THEN	/* segment is used */
		DO;
			CALL WriteBaseSizeAlign(0, segLen(curseg), alignType(curseg));
			CALL WriteBytes(.aAbsolute(SHL(curseg, 3)), 8);	/* print 8 character seg name shl(3) is *8 */
			IF alignType(curseg) = ALN$INPAGE AND segLen(curseg) > 256 THEN
				CALL WriteBytes(.aInPageSegment, LENGTH(aInPageSegment));	/* '  *INPAGE SEGMENT > 256 BYTES*' */
			segFrag$p = segFrags(curseg);
			DO WHILE segFrag$p > 0;				/* print the details for any gap fragments */
				CALL WriteBaseSizeAlign(segFrag.bot, segFrag.top - segFrag.bot + 1, ALN$NONE); 
				CALL WriteBytes(.aAbsolute(SHL(curseg, 3)), 8);
				CALL WriteBytes(.msgGap, LENGTH(msgGap));	/* note the gap */
				segFrag$p = segFrag.link;		/* loop till done */
			END;
		END;
	END;
	comdefInfo$p = headSegOrderLink;				/* common block segments */
	DO WHILE comdefInfo$p > 0;
		CALL WriteBaseSizeAlign(0, comdefInfo.len, comdefInfo.flags);		/* print size info */
		CALL WriteBytes(.slash2, 1);						/* add the name at the end */
		CALL WriteBytes(.comdefInfo.name(1), comdefInfo.name(0));
		CALL WriteBytes(.slash2, 1);
		IF comdefInfo.flags = ALN$INPAGE AND comdefInfo.len > 256 THEN		/* warn of problems */
			CALL WriteBytes(.aInpageSegment, LENGTH(aInPageSegment));	/* inpage segment > 256 bytes */
		comdefInfo$p = comdefInfo.segOrderLink;
	END;
	IF segLen(0) > 0 THEN								/* handle blank common */
	DO;
		CALL WriteBaseSizeAlign(0, segLen(0), alignType(0));
		CALL WriteBytes(.slash2, 2);						/* // */
		IF alignType(0) = 1 AND segLen(0) > 256 THEN
			CALL WriteBytes(.aInpageSegment, LENGTH(aInPageSegment));	/* inpage segment > 256 bytes */
	END;
	seg$i = 0;			/* seg$i used high water mark for over lap detection - start at address 0 */
	segFrag$p = segFrags(0);	/* frags for SEG$ABS are real data blocks */
	DO WHILE segFrag$p > 0;		/* go throught them */
		CALL WriteBaseSizeAlign(segFrag.bot, segFrag.top - segFrag.bot + 1, 0);	/* print the sizes and segment */
		CALL WriteBytes(.aAbsolute, 8);
		IF segFrag.bot < seg$i THEN				/* check for overlap */
			CALL WriteBytes(.msgOverlap, LENGTH(msgOverlap));
		IF segFrag.top >= seg$i THEN				/* update the high water mark for next block */
			seg$i = segFrag.top + 1;
		segFrag$p = segFrag.link;		/* to next fragment */
	END;	/* do while */
	CALL WriteBytes(.msgmodincluded, LENGTH(msgmodincluded));	/* '\r\n\nINPUT MODULES INCLUDED:\r\n' */ 
	curObjFile = objFileHead;					/* go over each file processed */
	DO WHILE curObjFile > 0;
		curModule = objFile.modlist;				/* and each module processed */
		DO WHILE curmodule > 0;
			IF NOT objFile.publicsMode OR module.symlist > 0 THEN	/* ignore if publics only and nothing loaded */
			DO;
				CALL WriteBytes(.(' '), 1);			/* ' filename(modulename)' */
				CALL WriteBytes(.objFile.name(1), objFile.name(0));
				CALL WriteBytes(.('('), 1);
				CALl WriteBytes(.module.name(1), module.name(0));
				CALL WriteBytes(.(')'), 1);
				IF objFile.publicsMode THEN			/* note publics only */
					CALL WriteBytes(.msgPublics, LENGTH(msgPublics));
				CALL WriteCRLF;
			END;
			curModule = module.link;
		END;
		curObjFile = objFile.link;
	END;
END WriteStats;

ChainUnresolved: PROCEDURE PUBLIC;	/* creates a chain of unresolved externals */
	DECLARE (p, toChain) ADDRESS;
	DECLARE symbola BASED p SYMBOL$T;
	DECLARE link BASED nxtSymbol$p ADDRESS;

	IF unresolved = 0 THEN		/* nothing to Write */
		RETURN;
	CALL WriteAndEcho(.msgunresolved, LENGTH(msgunresolved));	/* '\r\nUNRESOLVED EXTERNAL NAMES:\r\n' */
	toChain = unresolved;
	DO seg$i = 0 TO 127;		/* traverse all of the HashF chains */
		symbol$p = hashTab(seg$i);
		DO WHILE symbol$p > 0;	/* traverse the single HashF chain */
			IF symbol.flags = F$EXTERN THEN		/* we have an extern */
			DO;
				nxtSymbol$p = .headUnresolved;	/* Lookup where to insert this symbol on the list */
				p = headUnresolved;
				DO WHILE p > 0;			/* scan whole list if necessary */
					IF symbola.offsetOrSym > symbol.offsetOrSym THEN
						goto insert;	/* passed insert point using sym num */
					nxtSymbol$p = .symbola.nxtSymbol;
					p = symbola.nxtSymbol;
				END;
			insert:
				symbol.nxtSymbol = link;	/* add to the unresolved chain */
				link = .symbol.hashLink;
				IF (toChain := toChain - 1) = 0 THEN		/* done */
					RETURN;
			END;
			symbol$p = symbol.hashLink;
		END; /* DO WHILE */
	END;	/* DO .. TO */
END ChainUnresolved;

/* inserts a block of data into segment list at proper address */
CreateFragment: PROCEDURE(seg, bot, top) PUBLIC;
	DECLARE seg BYTE;
	DECLARE (bot, top) ADDRESS;
	DECLARE curSegFrag BASED curSegFrag$p STRUCTURE (link ADDRESS, bot ADDRESS, top ADDRESS);
	DECLARE prevSegFrag BASED prevSegFrag$p STRUCTURE (link ADDRESS, bot ADDRESS, top ADDRESS);
	DECLARE link BASED prevSegFrag$p ADDRESS;

	IF NOT mapWanted THEN		/* we are not creating a map so ignore */
		RETURN;
	segFrag$p = GetHigh(size(curSegFrag));	/* allocate and initialise the fragment */
	segFrag.bot = bot;
	segFrag.top = top;
	prevSegFrag$p = .segFrags(seg);		/* separate lists for each segment */
	curSegFrag$p = segFrags(seg);
	/* look for insert point or reach the end */
	DO WHILE curSegFrag$p > 0;
		IF curSegFrag.bot > bot THEN
			goto insert;
		prevSegFrag$p = .curSegFrag.link;	/* next */
		curSegFrag$p = curSegFrag.link;
	END;
insert:
	segFrag.link = prevSegFrag.link;		/* insert this fragment */
	prevSegFrag.link = .segFrag.link;
END CreateFragment;

P1CommonSegments: PROCEDURE PUBLIC;
	IF curseg = SEG$BLANK THEN	/* blank common */
	DO;
		IF segUsed(0) THEN	/* record seen in slot 0 */
			CALL IllFmt;
		segUsed(0) = TRUE;
		IF inSegLen > segLen(0) THEN	/* record max size */
			segLen(0) = inSegLen;
		IF alignType(0) = ALN$UNDEF THEN
			alignType(0) = inSegCombine;
		ELSE IF alignType(0) <> ALN$BYTE OR inSegCombine <> ALN$BYTE THEN
			alignType(0) = ALN$PAGE;	/* if not both byte align make page align */
	END;
	ELSE
	DO;
		IF noCommonSeen THEN	/* we have commons so far so allocate mapping table */
		DO;
			IF comSegInfo$p = 0 THEN	/* no table allocated so allocate one */
				comSegInfo$p = GetHigh(size(comSegInfo));
			DO seg$i = 0 TO last(comSegInfo);	/* initialise */
				comSegInfo(seg$i).combine = ALN$UNDEF;
			END;
			noCommonSeen = 0;
		END;
		IF comSegInfo(curseg).combine <> ALN$UNDEF THEN	/* duplicate */
			CALL IllFmt;
		comSegInfo(curseg).combine = inSegCombine;	/* save combine and size */
		comSegInfo(curseg).lenOrLinkedSeg = inSegLen;
	END;
END P1CommonSegments;

P1StdSegments: PROCEDURE PUBLIC;
	DECLARE (prevLen, segLoadBase) ADDRESS;

	IF segUsed(curseg) THEN		/* duplicate seg size info */
		CALL IllFmt;
	segUsed(curseg) = 0FFH;		/* note seen */
	IF curseg = SEG$ABS OR curseg > SEG$MEMORY THEN
		CALL IllFmt;
	IF inSegLen = 0 THEN		/* nothing to do */
		RETURN;
	IF curseg = SEG$CODE OR curseg = SEG$DATA THEN
	DO;
		IF alignType(curseg) = ALN$UNDEF THEN	/* first seg */
		DO;
			alignType(curseg) = inSegCombine;
			segLen(curseg) = inSegLen;
			segLoadBase = 0;
		END;
		ELSE
		DO;
			prevLen = segLen(curseg);
			DO CASE inSegCombine - 1;
				DO;	/* IN PAGE */
					IF LOW(prevLen) + inSegLen <= 100H THEN		/* if fits in current page */
						segLoadBase = prevLen + inSegLen;	/* calculate the base */
					ELSE						/* else start new page */
						segLoadBase = ((prevLen + 0FFH) AND 0FF00H) + inSegLen;

					IF alignType(curseg) <> ALN$INPAGE OR segLoadBase > 100H THEN	/* check if we should use page align */
						alignType(curseg) = ALN$PAGE;
				END;
				DO;	/* PAGE */
					alignType(curseg) = ALN$PAGE;			/* calculate new page */
					segLoadBase = ((prevLen + 0FFH) AND 0FF00H) + inSegLen;
				END;
				DO;	/* BYTE */
					IF alignType(curseg) = ALN$INPAGE THEN		/* if were in page we now have to assume page align */
						alignType(curseg) = ALN$PAGE;
					segLoadBase = prevLen + inSegLen;		/* Lookup out Load address */
				END;
			END;
			segLen(curseg) = segLoadBase;					/* update the overall seg len */
			IF (segLoadBase := segLoadBase - inSegLen) > prevLen THEN	/* backup to start of this Load address */
				CALL CreateFragment(curseg, prevLen, segLoadBase - 1);	/* not contiguous so create fragment */
			IF segLen(curseg) < segLoadBase THEN				/* oops we went over 64k */
				CALL FatalErr(ERR221);	/* segment too large */
		END;
		IF curseg = SEG$CODE THEN		/* update the code / data base address */
			module.scode = segLoadBase;
		ELSE
			module.sdata = segLoadBase;
	END;
	ELSE
	DO;	/* SEG$STACK or SEG$MEMORY or SEG$RESERVE */
		IF alignType(curseg) = ALN$UNDEF THEN		/* set initial combine */
			alignType(curseg) = inSegCombine;
		ELSE IF alignType(curseg) <> ALN$BYTE OR inSegCombine <> ALN$BYTE THEN	/* ALN$PAGE if not both ALN$BYTE */
			alignType(curseg) = ALN$PAGE;
		segLen(curseg) = segLen(curseg) + inSegLen;	/* length is additive */
	END;
END P1StdSegments;

/*
	select requested seg, setting inSegOffset to point to base
	returns returns seg - note for common len is replaced by final linked seg
	after the comdef records have been processed
*/

SelectInSeg: PROCEDURE(seg) BYTE PUBLIC;
	DECLARE seg BYTE;

	inSegOffset = 0;
	IF seg = SEG$CODE THEN
		inSegOffset = module.scode;
	ELSE IF seg = SEG$DATA THEN
		inSegOffset = module.sdata;
	ELSE IF seg >= SEG$NAMCOM AND seg <> SEG$BLANK THEN
	DO;
		IF noCommonSeen THEN	/* selecting common when none exists !! */
			CALL IllFmt;
		IF comSegInfo(seg).combine = ALN$NONE THEN	/* named common has been seen so ok */
			RETURN comSegInfo(seg).lenOrLinkedSeg;
		IF comSegInfo(seg).combine <> ALN$UNDEF THEN
			CALL BadRecordSeq;
		CALL IllFmt;
	END;
	RETURN seg;
END SelectInSeg;

P1ModHdr: PROCEDURE PUBLIC;
	/* structure of individual segdefs in the MODHDR */
	DECLARE sdef BASED in$p STRUCTURE (segId BYTE, len ADDRESS, combine BYTE); 
	/* and the two X  fields */
	DECLARE reserved BASED in$p STRUCTURE (tranId BYTE, tranVn BYTE);

	IF haveModuleHdr THEN			/* catch multiple header errors */
		CALL BadRecordSeq;
	haveModuleHdr = TRUE;
	nxtSymbol$p = .module.symlist;
	IF publicsMode THEN			/* not loading data */
		RETURN;
	in$p = in$p + inOMFName.len + 1;	/* past module name */
	IF initTraiIdVn THEN			/* copy x1x2 data */
	DO;
		initTraiIdVn = 0;
		outTranId = reserved.tranId;
		outTranVn = reserved.tranVn;
	END;
	IF reserved.tranId <> outTranId THEN	/* propgate none 0 only if same */
		outTranId = 0;
	IF reserved.tranVn <> outTranVn THEN
		outTranVn = 0;
	in$p = in$p + 2;			/* past the x1 x2 */
	module.scode = segLen(SEG$CODE);	/* code and data offsets of this module */
	module.sdata = segLen(SEG$DATA);
	noCommonSeen = TRUE;			/* first call */
	DO seg$i = SEG$ABS TO SEG$RESERVE;
		segUsed(seg$i) = 0;
	END;
	DO WHILE in$p < .erec;		/* while more segments */
		IF (inSegCombine := sdef.combine) - 1 > 2 THEN	/* only ALN$INPAGE - ALN$BYTE valid */
			CALL IllFmt;
		inSegLen = sdef.len;
		IF (curseg := sdef.segId) >= SEG$NAMCOM THEN
			CALL P1CommonSegments;
		ELSE
			CALL P1StdSegments;
		in$p = in$p + size(sdef);	/* advance to next def */
	END;
END P1ModHdr;

P1ModEnd: PROCEDURE PUBLIC;
	DECLARE	inModend BASED in$p STRUCTURE (modtype BYTE, segid BYTE, offset ADDRESS);
	moreRecords = 0;
	IF publicsMode THEN
		RETURN;
	IF inModend.modtype = MT$MAIN THEN
		IF modEndModTyp <> MT$NOTMAIN THEN	/* duplicate main modules !! */
			CALL WAEFnAndMod(.msgmore1main, LENGTH(msgmore1main));
		ELSE
		DO;
			modEndModTyp = MT$MAIN;	/* record main and save entry point */
			modEndSegId = SelectInSeg(inModend.segid);
			modEndOffset = inSegOffset + inModend.offset;
		END;
	IF NOT noCommonSeen THEN	/* check common alignments */
		DO seg$i = 0 TO 255;
			IF comSegInfo(seg$i).combine + 1 > 1 THEN	/* only ALN$UNDEF & ALN$NONE valid */
				CALL BadRecordSeq;
		END;
END P1ModEnd;

Pass1CONTENT: PROCEDURE PUBLIC;	
	DECLARE	inContent BASED in$p STRUCTURE (seg BYTE, addr ADDRESS, bytes(1) BYTE);
	CALL PrimeRecord;
	CALL ChkRead(3);	/* make sure seg and address Read */
	in$p = buf$p;
	IF NOT publicsMode THEN	/* skip if just processing publics */
	DO;
		IF (curseg := inContent.seg) = SEG$ABS THEN	/* absolute record */
			CALL CreateFragment(SEG$ABS, inContent.addr, inContent.addr + recLen - 5);
		ELSE						/* relocatable record */
		DO;
			IF recLen > 1025 THEN		/* only abs > 1025 */
				CALL FatalErr(ERR211);	/* record too long */
			IF curseg = SEG$STACK THEN
				CALL FatalErr(ERR238);	/* illegal stack content record */
			IF curseg < SEG$NAMCOM THEN
			DO;
				IF NOT segUsed(curseg) THEN	/* seg was not defined in modhdr */
					CALL IllFmt;
			END;
			ELSE
			DO;
				IF curseg = 0FFH THEN	/* blank common */
				DO;
					IF NOT segUsed(0) THEN	/* set was not defined in modhdr */
						CALL IllFmt;
				END;
				ELSE
					curseg = SelectInSeg(curseg);
			END;
		END;
	END;
	CALL SkipRecord;	/* don't need the data on the first pass */
END Pass1CONTENT;

Pass1COMDEF: PROCEDURE PUBLIC;
	DECLARE segorderlink BASED tailSegOrderLink ADDRESS;
	DECLARE	inComdef BASED in$p STRUCTURE (segId BYTE, name(1) BYTE);

	IF publicsMode THEN	/* not needed */
		RETURN;
	IF noCommonSeen THEN	/* can't have common def if no common segments */
		CALL BadRecordSeq;
	DO WHILE in$p < .erec;
		IF (curseg := inComdef.segId) < SEG$NAMCOM OR curseg = SEG$BLANK THEN	/* not a named common */
			CALL IllFmt;
		IF comSegInfo(curseg).combine + 1 < 2 THEN	/* ALN$UNDEF and ALN$NONE invalid */
			CALL IllFmt;
		IF Lookup(.inComdef.name, .comdefInfo$p, F$ALNMASK) THEN	/* already exist ? */
		DO;
			/* if not both ALN$BYTE then make ALN$PAGE */
			IF comdefInfo.flags <> ALN$BYTE OR comSegInfo(curSeg).combine <> ALN$BYTE THEN
				comdefInfo.flags = ALN$PAGE;
			IF comdefInfo.len <> comSegInfo(curseg).lenOrLinkedSeg THEN	/* if not same size */
			DO;
				IF comSegInfo(curseg).lenOrLinkedSeg > comdefInfo.len THEN	/* set as max of sizes */
					comdefInfo.len = comSegInfo(curseg).lenOrLinkedSeg;
				CALL WriteAndEcho(.slash2, 1);			/* warning sizes are different */
				CALL WriteAndEcho(.comdefInfo.name(1), comdefInfo.name(0));
				CALL WAEFnAndMod(.msgbadcom, 27H);
			END;
		END;
		ELSE	/* new entry required */
		DO;
			comdefInfo.hashLink = GetLow(size(comdefInfo) + inComdef.name(0));
			comdefInfo$p = comdefInfo.hashLink;	/* link in and mark new end of chain */
			comdefInfo.hashLink = 0;
			comdefInfo.flags = comSegInfo(curseg).combine;	/* save the combine value */
			IF segToUse < SEG$NAMCOM THEN	/* check we haven't created too many segs in the linked file */
				CALL FatalErr(ERR236);	/* too many common segments */
			comdefInfo.linkedSeg = segToUse;	/* record the linked seg for this segment */
			segToUse = segToUse - 1;
			CALL Pstrcpy(.inComdef.name, .comdefInfo.name);	/* copy the name */
			comdefInfo.len = comSegInfo(curseg).lenOrLInkedSeg;		/* and size */
			comdefInfo.segOrderLink = segOrderLink;		/* chain into seg order */
			segOrderlink = .comdefInfo.hashLink;
			tailSegOrderLink = .comdefInfo.segOrderLink;
		END; /* ELSE */
		comSegInfo(curseg).combine = ALN$NONE;		/* flag as done */
		comSegInfo(curseg).lenOrLinkedSeg = comdefInfo.linkedSeg;	/* replace len with the linkedSeg */
		in$p = in$p + 2 + inComdef.name(0);			/* next name */
	END;	/* DO WHILE */
END Pass1COMDEF;

Pass1PUBNAMES: PROCEDURE PUBLIC;
	DECLARE inSegId BASED in$p BYTE;
	DECLARE inPubdef BASED in$p STRUCTURE (offset ADDRESS, name(1) BYTE /*, 0 */);

	MarkPublic: PROCEDURE;
		DECLARE link BASED nxtSymbol$p ADDRESS;

		symbol.flags = F$PUBLIC;	/* now public */
		symbol.linkedSeg = curseg;	/* location known */
		symbol.offsetOrSym = inSegOffset + inPubdef.offset;
		segmap(curseg) = 0FFH;		/* flag as used seg */
		symbol.nxtSymbol = link;	/* add to the publics chain */
		link = .symbol.hashLink;
		nxtSymbol$p = .symbol.nxtSymbol;
	END MarkPublic;

	IF (curseg := inSegId) <> SEG$ABS AND publicsMode THEN	/* publics only requires absolute targets */
		RETURN;
	curseg = SelectInSeg(curseg);	/* get the linked seg */
	in$p = in$p + 1;
	DO WHILE in$p < .erec;		/* while more public definitions */
		IF Lookup(.inPubdef.name, .symbol$p, F$SCOPEMASK) THEN	/* Lookup extern or public */
		DO;
			IF symbol.flags = F$PUBLIC THEN			/* Error if not same location */
			DO;
				IF curseg <> 0 OR symbol.linkedSeg <> curseg or symbol.offsetOrSym <> inPubdef.offset THEN
				DO;
					CALL WriteAndEcho(.symbol.name(1), symbol.name(0));
					CALL WAEFnAndMod(.msgmultdef, LENGTH(msgmultdef));
				END;
			END;
			ELSE
			DO;	/* was extern but we now have an address */
				unresolved = unresolved - 1;
				CALL MarkPublic;
			END;
		END;
		ELSE
		DO;	/* create a new entry */
			symbol.hashLink = GetLow(size(symbol) + inPubdef.name(0));
			symbol$p = symbol.hashLink;	/* add to HashF chain */
			symbol.hashLink = 0;
			CALL Pstrcpy(.inPubdef.name, .symbol.name);	/* add the name */
			CALL MarkPublic;				/* make it a public */
		END;
		in$p = in$p + 4 + inPubdef.name(0);			/* to next pubdef */
	END;	/* do while */
END Pass1PUBNAMES;

Pass1EXTNAMES: PROCEDURE PUBLIC;
	IF publicsMode THEN		/* skip if not wanted */
		RETURN;
	DO WHILE .erec > in$p;		/* while more external definitions */
		externCnt = externCnt + 1;	/* bump the number of externs */
		IF NOT Lookup(in$p, .symbol$p, F$SCOPEMASK) THEN	/* not currently extern or public */
		DO;
			symbol.hashLink = GetLow(size(symbol) + inOMFName.len);	/* create an entry */
			symbol$p = symbol.hashLink;		/* link in */
			symbol.hashLink = 0;
			symbol.flags = F$EXTERN;		/* extern and record symcnt number */
			symbol.offsetOrSym = (symcnt := symcnt + 1);
			CALL Pstrcpy(.inOMFName, .symbol.name);	/* copy name */
			unresolved = unresolved + 1;		/* one more to resolve */
			newUnresolved = newUnresolved + 1;
		END;
		in$p = in$p + 2 + inOMFName.len; /* 2 for len byte and extra 0 at end */
	END;
END Pass1EXTNAMES;

/* process pass 1 records */
P1Records: PROCEDURE(newModule) PUBLIC;
	DECLARE newModule BYTE;

	IF newModule THEN	/* create entry for new module */
	DO;
		hmodule.link = (curModule := GetLow(size(hmodule) + inOMFName.len));
		module.link, module.symlist = 0;
		CALL Pstrcpy(.inOMFName, .module.name);
		hmodule$p = curModule;
	END;
	externCnt = 0;
	recNum = 1;
	haveModuleHdr = 0;
	moreRecords = TRUE;
	DO WHILE moreRecords;
		DO CASE SHR(inRecord.type, 1);
			CALL IllegalRelo;	/* 0 */
			CALL P1ModHdr;		/* R$MODHDR */
			CALL P1ModEnd;		/* R$MODEND */
			CALL Pass1CONTENT;	/* R$CONTENT */
			;					/* R$LINENO */
			CALL IllegalRelo;	/* 0A */
			CALL IllegalRelo;	/* 0C */
			CALL FileError(ERR204, .inFileName(1), TRUE);	/* Premature R$EOF */
			;			/* R$ANCESTOR */
			;			/* R$LOCALS */
			CALL IllegalRelo;	/* 14 */
			CALL Pass1PUBNAMES;	/* R$PUBLICS */
			CALL Pass1EXTNAMES;	/* R$EXTNAMES */
			CALL IllegalRelo;	/* 1A */
			CALL IllegalRelo;	/* 1C */
			CALL IllegalRelo;	/* 1E */
			;			/* R$EXTREF */
			;			/* R$RELOC */
			;			/* R$INTERSEG */
			CALL BadRecordSeq;	/* R$LIBLOCS */
			CALL BadRecordSeq;	/* R$LIBNAMES */
			CALL BadRecordSeq;	/* R$LIBDICT */
			CALL BadRecordSeq;	/* R$LIBHDR */
			CALL Pass1COMDEF;	/* R$COMDEF */
		END;
		CALL GetRecord;
	END;
	IF externCnt > maxExternCnt THEN	/* get max of externs */
		maxExternCnt = externCnt;
	/* make sure next record is valid or EOF */
	IF inRecord.type <> R$EOF AND inRecord.type <> R$MODHDR AND inRecord.type <> R$LIBNAMES THEN
		CALL FatalErr(ERR220);	/* no EOF */
END P1Records;

P1LibScan: PROCEDURE PUBLIC;
	DECLARE pad(3) BYTE;
	DECLARE (blk, byt, blk2A, byt2A, modIdx, toResolve, i, libModulesToLoad , modlocs$p) ADDRESS;
	DECLARE modlocs BASED modlocs$p (1) STRUCTURE (blk ADDRESS, byt ADDRESS);
	DECLARE inLibloc BASED in$p STRUCTURE (blk ADDRESS, byt ADDRESS);
	DECLARE inLibhdr BASED in$p STRUCTURE (cnt ADDRESS, blk ADDRESS, byt ADDRESS);

	objFile.hasModules = TRUE;
	IF unresolved > 0 THEN
	DO;
		hmodule$p = .objFile.modlist;
		blk = inLibhdr.blk;		/* library header block */
		byt = inLibhdr.byt;		/* library header byte */
		CALL Position(blk, byt);	/* Seek to library module names record */
		CALL ExpectType(R$LIBNAMES);	/* get rec and validate type */ 
		CALL PrimeRecord;			/* save pointers */
		blk = (byt + recLen + 3) / 128 + blk; /* location of the libloc record */
		byt = (byt + recLen + 3) MOD 128;
		CALL SkipRecord;
		CALL ExpectType(R$LIBLOCS);	/* should have the locations */
		blk2A = blk + (byt + recLen + 3) / 128;	/* location of the libdic record */
		byt2A = (byt + recLen + 3) MOD 128;
		newUnresolved = unresolved;	/* first pass attempts to resolve all unresolved */
		DO WHILE newUnresolved > 0;	/* loop incase scan adds more externs that the lib can resolve */
			libModulesToLoad = 0;
			modlocs$p = GetHigh(0);		/* base memory of the new module locations info */
			CALL Position(blk2A, byt2A);	/* go to the libdic */
			CALL ExpectType(R$LIBDICT);
			CALL PrimeRecord;
			modIdx = 1;
			toResolve = newUnresolved;	/* 1st pass scans for all unresolved */
							/* later passes may finish quicker as only new unresolved */
							/* can be matched */
			newUnresolved = 0;
			/* scan the dictionary across all names or until no unresolved */
			DO WHILE ReadName AND toResolve > 0;
				IF inOMFName.len = 0 THEN	/* new module - 0 separates */
					modIdx = modIdx + 1;
				ELSE IF Lookup(in$p, .symbol$p, F$EXTERN) THEN	/* matched an unresolved external */
				DO;
					i = GetHigh(4);		/* adds to modlocs vector - return address is junked */
					modlocs(libModulesToLoad).blk = modIdx;	/* record the module id */
					libModulesToLoad = libModulesToLoad + 1;
					toResolve = toResolve - 1;
					DO WHILE ReadName AND inOMFName.len <> 0;	/* skip to next module's names */
					END;
					modIdx = modIdx + 1;
				END;
			END; /* DO WHILE */
			IF libModulesToLoad > 0 THEN	/* matched some modules */
			DO;
				CALL Position(blk, byt);	/* get the libloc data */
				CALL ExpectType(R$LIBLOCS);
				CALL PrimeRecord;
				modIdx = 0;
				DO i = 0 TO libModulesToLoad - 1;			/* for each module */
					DO WHILE modlocs(i).blk > modIdx;	/* step its location information */
						modIdx = modIdx + 1;
						CALL ReadBlkByt;
					END;
					modlocs(i).blk = inLibloc.blk;	/* save the location information */
					modlocs(i).byt = inLibloc.byt;
				END;
				DO i = 0 TO libModulesToLoad - 1;			/* process each module needed */
					CALL Position(modlocs(i).blk, modlocs(i).byt);		/* Seek module location in library */
					CALL ExpectType(R$MODHDR);
					CALL P1Records(TRUE);		/* creates a new module entry */
					module.blk = modlocs(i).blk;		/* record the module location */
					module.byt = modlocs(i).byt;		/* in the module data for phase 2 */
				END;
			END;
		END;	/* DO WHILE */
	END;
END P1LibScan;

P1LibUserModules: PROCEDURE PUBLIC;
	DECLARE (modIdx, i) ADDRESS, unmatched BYTE;
	DECLARE inLibloc BASED in$p STRUCTURE (blk ADDRESS, byt ADDRESS);
	DECLARE inLibhdr BASED in$p STRUCTURE (cnt ADDRESS, blk ADDRESS, byt ADDRESS);

	CALL Position(inLibhdr.blk, inLibhdr.byt);	/* Seek to the libnam section - libhdr is current rec */
	CALL ExpectType(R$LIBNAMES);
	CALL PrimeRecord;		/* record its a LIBNAM record and the start of the content */
	modIdx = 0;
	unmatched = TRUE;
	DO WHILE ReadName AND unmatched;	/* scan the library looking for specified modules */
		modIdx = modIdx + 1;	/* index for later into libloc data */
		unmatched = 0;		/* set flag for Exit if module not matched */
		curModule = objFile.modlist;	/* go over the supplied list of modules */
		DO WHILE curModule > 0;		
			IF module.scode = 0 THEN	/* not matched yet */
			DO;
				IF Strequ(in$p, .module.name, module.name(0) + 1) THEN
					module.scode = modIdx;	/* record matched module */
				ELSE
					unmatched = TRUE;	/* at least one module not matched */
			END;
			curModule = module.link;	/* next one */
		END;
	END;
	CALL SkipRecord;		/* skip any remaining names */
	CALL ExpectType(R$LIBLOCS);	/* expect the libloc record */
	CALL PrimeRecord;			/* tag where we are */
	DO i = 1 TO modIdx;		/* for all locations */
		CALL ReadBlkByt;	/* get the location info */
		curModule = objFile.modlist;	/* scan the module list to see if we need this one */
		DO WHILE curModule > 0;
			IF i = module.scode THEN
			DO;
				module.blk = inLibloc.blk;	/* put in the location info */
				module.byt = inLibloc.byt;
			END;
			curModule = module.link;	/* keep going */
		END;
	END;
	hmodule$p = .objFile.modlist;		/* pointer to remove missing modules from the chain */
	curModule = objFile.modlist;
	DO WHILE curModule > 0;
		IF module.scode = 0 THEN
		DO;
			CALL WAEFnAndMod(.msgmodnotinlib, LENGTH(msgmodnotinlib));	/* Module not in library, looking for */
			hmodule.link = module.link;	/* remove this module from the list */
		END;
		ELSE
		DO;
			CALL Position(module.blk, module.byt);	/* process the module */
			CALL ExpectType(R$MODHDR);
			CALL P1Records(FALSE);		/* module already known so don't create entry for it */
			hmodule$p = curModule;			/* this module remains on the list */
		END;
		curModule = module.link;		/* keep going */
	END;
END P1LibUserModules;

DECLARE controls BYTE EXTERNAL;

Phase1: PROCEDURE PUBLIC;
	membot = .controls;			/* use memory no longer needed */
	DO seg$i = SEG$ABS TO SEG$RESERVE;
		segFrags(seg$i) = 0;
	END;
	symcnt = 0;				/* no symbols */
	tailSegOrderLink = .headSegOrderLink;	/* no common segments */
	curObjFile = objFileHead;
	DO WHILE curObjFile > 0;		/* process each item in the input list */
		CALL OpenObjFile;		/* Open the file */
		publicsMode = objFile.publicsMode;
		CALL GetRecord;			/* Load the first record */
		IF inRecord.type = R$LIBHDR THEN	/* library? */	
		DO;
			IF objFile.hasModules THEN	/* user specified modules */
				CALL P1LibUserModules;
			ELSE
				CALL P1LibScan;		/* library scan */
		END;
		ELSE
		DO;
			IF inRecord.type = R$MODHDR THEN	/* simple object file */
			DO;
				IF objFile.hasModules THEN	/* oops user thought it was a library */
					CALL FatalErr(ERR235);	/* not a library */
				hmodule$p = .objFile.modlist;
				DO WHILE inRecord.type = R$MODHDR;	/* process each module in file */
					CALL P1Records(TRUE);	/* this is a new module */
				END;
				IF inRecord.type <> R$EOF THEN
					CALL FatalErr(ERR220);	/* no EOF */
			END;
			ELSE
				CALL FatalErr(ERR239);	/* no module header record */
		END;
		CALL CloseObjFile;
	END;
	CALL WriteStats;
	CALL ChainUnresolved;
END Phase1;

END link3;
link3a.plm
$xref
/*	Copyright (c) 2012 by Mark Ogden
	Released into the public domain for academic historic interest
	only and not for commercial gain. */
link3a:
DO;
$include(link3a.ipx)


DECLARE controls(*) BYTE PUBLIC DATA(1, 3, 'MAP', 2, 4, 'NAME', 3, 5, 'PRINT');
DECLARE cin(*) BYTE DATA(':CI: ');
DECLARE cout(*) BYTE DATA(5, ':CO: ');

DECLARE info SPATH$T,
	login(*) BYTE INITIAL(0CH, 'ISIS-II OBJECT LINKER '),
	msgInvoked(*) BYTE INITIAL(' INVOKED BY:', 0DH, 0AH),
	msgtailerror(*) BYTE INITIAL('COMMAND TAIL ERROR NEAR #:'),
	linkTmpTemplate(*) BYTE INITIAL(0,'LINK', 0, 0,'TMP'),
	scmd$p ADDRESS,
	cmd$p ADDRESS;

/* explicit definition of based vars as based defined after include */
declare	cmdbuf based cmd$p (1) byte,
	cmdch based cmd$p byte;

FatalCmdLineErr: PROCEDURE(errCode) PUBLIC;
	DECLARE errCode ADDRESS;
	DECLARE scmd BASED scmd$p (1) BYTE;

	IF Delimit(cmd$p) = cmd$p THEN
	DO;				/* isn't a filename so a single char */
		IF cmdch <> 0DH THEN	/* don't skip past the EOL */
			cmd$p = cmd$p + 1;
	END;
	ELSE
		cmd$p = Delimit(cmd$p);
	cmdch = '#';	/* mark after Error */
	CALL ConOutStr(.msgtailerror, 26);
	CALL ReportError(errCode);
	CALL ConOutStr(.scmd, cmd$p - .scmd + 1);
	CALL ConOutStr(.CRLF, 2);
	CALL Exit;
END FatalCmdLineErr;


SkipNonArgChars: PROCEDURE(arg1w) PUBLIC;
	DECLARE arg1w ADDRESS;

	cmd$p = Deblank(arg1w);
	DO WHILE cmdch = '&';		/* skip continuation lines */
		cmd$p = Deblank(cmd$p + 5);
	END;
END SkipNonArgChars;


ExpectChar: PROCEDURE(ch, errCode) PUBLIC;
	DECLARE ch BYTE;
	DECLARE errCode BYTE;

	CALL SkipNonArgChars(cmd$p);
	IF cmdch = ch THEN
		CALL SkipNonArgChars(cmd$p+1);
	ELSE
		CALL FatalCmdLineErr(errCode);
END ExpectChar;


ChkLP: PROCEDURE PUBLIC;
	CALL ExpectChar('(', ERR227);	/* left parenthesis expected */
END ChkLP;


ChkRP: PROCEDURE PUBLIC;
	CALL ExpectChar(')', ERR228);	/* right parenthesis expected */
END ChkRP;


ExpectComma: PROCEDURE PUBLIC;
	CALL ExpectChar(',', ERR203);	/* Invalid syntax */
END ExpectComma;


CheckFile: PROCEDURE PUBLIC;
	CALL spath(cmd$p, .info, .statusIO);
	IF statusIO > 0 THEN
		CALL FatalCmdLineErr(statusIO);
	CALL SkipNonArgChars(Delimit(cmd$p));
END CheckFile;


ErrNotDiscFile: PROCEDURE PUBLIC;
	CALL MakeFullName(.info, .inFileName(1));
	CALL FileError(ERR17, .inFileName(1), TRUE);	/* not a disk file */
END ErrNotDiscFile;


GetModuleName: PROCEDURE(pstr) PUBLIC;
	DECLARE pstr ADDRESS;
	DECLARE str BASED pstr (1) BYTE;

	IF cmdch < '?' OR cmdch > 'Z' THEN
		CALL FatalCmdLineErr(ERR225);	/* invalid name */
	str(0) = 0;

	DO WHILE '0' <= cmdch AND cmdch <= '9' OR '?' <= cmdch AND cmdch <= 'Z';
		str(0) = str(0) + 1;
		IF str(0) > 31 THEN
			CALL FatalCmdLineErr(ERR226);	/* name too long */
		str(str(0)) = cmdch;	
		cmd$p = cmd$p + 1;
	END;
END GetModuleName;


AddFileToInputList: PROCEDURE PUBLIC;
	CALL MakeFullName(.info, .inFileNAme(1));
	inFileName(0) = Delimit(.inFileName(1)) - .inFileName(1);
	IF objFileHead = 0 THEN
		objFileHead, curObjFile = GetLow(size(objFile) + inFileName(0));
	ELSE
	DO;
		objFile.link = GetLow(size(objFile) + inFileName(0));
		curObjFile = objFile.link;	
	END;
	objFile.link, objFile.modlist = 0;
	objFile.publicsMode = 0;
	objFile.hasModules = 0;
	CALL Pstrcpy(.inFileName, .objFile.name);
END AddFileToInputList;


GetInputListItem: PROCEDURE PUBLIC;
	DECLARE curModuleName(32) BYTE;
	IF Strequ(cmd$p, .('PUBLICS'), 7) THEN
	DO;
		cmd$p = Delimit(cmd$p);	/* past the PUBLICS */
		CALL ChkLP;			/* (file */
		CALL CheckFile;
		IF info.deviceType <> 3 THEN	/* must be disk file */
			CALL ErrNotDiscFile;
		CALL AddFileToInputList;
		objFile.publicsMode = TRUE;	/* record PUBLICS */
		DO WHILE cmdCh = ',';		/* process any more PUBLICS files */
			CALL ExpectComma;
			CALL CheckFile;
			IF info.deviceType <> 3 THEN
				CALL ErrNotDiscFile;
			CALL AddFileToInputList;
			objFile.publicsMode = TRUE;
		END;
		CALL ChkRP;			/* Close with ) */
	END;
	ELSE
	DO;
		CALL CheckFile;			/* check we have a disk file */
		IF info.deviceType <> 3 THEN
			CALL ErrNotDiscFile;
		CALL AddFileToInputList;
		IF cmdCh = '(' THEN		/* check if we have a module list */
		DO;
			CALL ChkLP;		/* gobble up the ( */
			objFile.hasModules = TRUE;	/* note have module list */
			CALL GetModuleName(.curModuleName);
			curModule = (objFile.modList := GetLow(size(module) + curModuleName(0)));
			module.link, module.symlist, module.scode = 0;
			CALL Pstrcpy(.curModuleName, .module.name);
			CALL SkipNonArgChars(cmd$p);
			DO WHILE cmdch = ',';		/* get more modules if specified */
				CALL ExpectComma;
				CALL GetModuleName(.curModuleName);
				module.link = GetLow(size(module) + curModuleName(0));
				curModule = module.link;
				module.link, module.symlist, module.scode = 0;
				CALL Pstrcpy(.curModuleName, .module.name);
				CALL SkipNonArgChars(cmd$p);
			END;
			CALL ChkRP;
		END;
	END;
END GetInputListItem;


ParseControl: PROCEDURE PUBLIC;
	DECLARE (i, j, k) BYTE;
	/* a controls item has format
		index, strlen, string
	*/
	k = Delimit(cmd$p) - cmd$p;	/* control string len */
	i= 0;
	j= 0;
	IF k > 0 THEN		/* there is a control */
		DO WHILE i < 18;	/* size of the controls table */
			IF k = controls(i+1) AND Strequ(cmd$p, .controls(i + 2), k) THEN
			DO;	/* found */
				j = controls(i);
				i = 18;	/* force Exit */
			END;
			ELSE
				i = i + controls(i+1) + 2;
		END;

	IF j = 0 THEN		/* not found */
		CALL FatalCmdLineErr(ERR229);	/* Unrecognised control */
	CALL SkipNonArgChars(cmd$p + k);	/* past the control */
	DO CASE j - 1;
		mapWanted = TRUE;	/* MAP */
		DO;		/* NAME(modulename) */
			CALL ChkLP;
			CALL GetModuleName(.outModuleName);
			CALL ChkRP;
		END;
		DO;		/* PRINT(file) */
			CALL ChkLP;
			CALL CheckFile;
			CALL MakeFullName(.info, .printFileName(1));
			printFileName(0) = Delimit(.printFileName(1)) - .printFileName(1);
			CALL ChkRP;
		END;
	END;
END ParseControl;


ReadCmdLine: PROCEDURE PUBLIC;
	CALL Read(1, cmd$p, 128, .actRead, .statusIO);
	CALL FileError(statusIO, .cin, TRUE);
	cmdbuf(actRead) = 0DH;
	CALL CrStrUpper(cmd$p);
END ReadCmdLine;


ParseCmdLine: PROCEDURE PUBLIC;
	DECLARE scmdch BASED scmd$p BYTE;
	DECLARE (p, q) ADDRESS;

	membot = .MEMORY;
	topHeap = memck;
	IF HIGH(memck - .MEMORY) - 1 >= 40H THEN
		npbuf = 3072;
	ELSE
		npbuf = 1056;
	sbuf$p = GetLow(npbuf);
	ebuf$p, buf$p = sbuf$p + npbuf;
	scmd$p = GetHigh(0);	/* alloc 0 length buffer below heap. Will fix later */
	scmdch = '-';		/* put - at start of command buf */
	CALL rescan(1, .statusIO);	/* rescan the command line */
	cmd$p = scmd$p + 1;	/* insert point */
	CALL ReadCmdLine;	/* Read the command line */
	cmd$p = Deblank(cmd$p);	/* skip space and any DEBUG prefix */
	IF Strequ(cmd$p, .('DEBUG '), 6) THEN
		cmd$p = Deblank(cmd$p + 6);
	q = cmd$p;
	CALL CheckFile;		/* reads the invoking filename */
	info.ext(0) = 'O';	/* generate the overlay name */
	info.ext(1) = 'V';
	info.ext(2) = 'L';
	CALL MakeFullName(.info, .filePath(1));	/* make into a normalised file name */
	filePath(0) = Delimit(.filePath(1)) - .filePath(1);	/* add the pascal style string len */
	cmd$p = q;		/* back to the start of the invoking command to keep for listing */

	DO WHILE cmdch <> 0DH;		/* collect until end of a non continued line */
		IF cmdch = '&' THEN
		DO;
			p = cmd$p;	/* mark where the & is */
			cmd$p = Deblank(cmd$p + 1);
			IF cmdch <> 0DH THEN
				CALL FatalCmdLineErr(ERR203);	/* invalid syntax */
			cmd$p = p;	/* back to the & */
			CALL ConOutStr(.('**'), 2);	/* prompt user for more */
			cmdbuf(1) = 0DH; 	/* put the \r\n** in the buffer */
			cmdbuf(2) = 0AH;
			cmdbuf(3) = '*';
			cmdbuf(4) = '*';
			cmd$p = cmd$p + 5;	/* point to insert next line */
			CALL ReadCmdLine;	/* get the line */
		END;
		ELSE
			cmd$p = cmd$p + 1;	/* next char */
	END;	/* DO WHILE */

	CALL ConOutStr(.login(1), size(login) - 1);	/* put login message minus form feed */
	CALL ConOutStr(.VERSION, 4);
	CALL ConOutStr(.CRLF, 2);
	p =  GetHigh(cmd$p - .scmdch + 2);		/* formally allocate the memory for the command line */
	CALL SkipNonArgChars(Delimit(q));		/* skip the invoking app name */
	objFileHead = 0;				/* end of link file list marker */
	CALL GetInputListItem;				/* get the first file to link */
	DO WHILE cmdch = ',';				/* get any more in the list */
		CALL ExpectComma;
		CALL GetInputListItem;
	END;

	IF Strequ(cmd$p, .('TO '), 3) OR Strequ(cmd$p, .('TO&'), 3) THEN	/* need TO or TO& */
	DO;
		CALL SkipNonArgChars(cmd$p + 2);	/* past the TO */
		q = cmd$p;				/* start of filename */
		CALL CheckFile;				/* target must be a disk file or :BB: */
		IF info.deviceType <> 3 AND info.deviceId <> 22 THEN /* file or :BB: */
			CALL ErrNotDiscFile;
		cmd$p = q;				/* reset */
		CALL MakeFullName(.info, .toFileName(1));	/* get the full filename */
		toFileName(0) = Delimit(.toFileName(1)) - .toFileName(1);
		curObjFile = objFileHead;		/* check target isn't a file we are linking from */
		DO WHILE curObjFile > 0;
			IF Strequ(.toFileName, .objFile.name, toFileName(0) + 1) AND NOT objFile.publicsMode THEN
				CALL FatalCmdLineErr(ERR234);	/* Duplicate file name */
			curObjFile = objFile.link;
		END;
		CALL SkipNonArgChars(Delimit(cmd$p));
	END;
	ELSE
		CALL FatalCmdLineErr(ERR233);	/* 'TO' expected */

	/* put the temp file on the same disk as the target (or :BB:) */
	linkTmpTemplate(0) = info.deviceId;
	CALL MakeFullName(.linkTmpTemplate, .linkTmpFile(1));
	linkTmpFile(0) = Delimit(.linkTmpFile(1)) - .linkTmpFile(1);
	/* at this point we have the input and output files so process the options */
	/* create a default module name from the target file name */
	outModuleName(0) = 0;
	DO WHILE info.name(outModuleName(0)) <> 0 AND outModuleName(0) < 6;
		outModuleName(0) = outModuleName(0) + 1;
		outModuleName(outModuleName(0)) = info.name(outModuleName(0)-1);
	END;
	/* print to :CO: if not specified */
	CALL Pstrcpy(.cout, .printFileName);
	mapWanted = 0;	/* default is no map file */
	DO WHILE cmdCh <> 0DH;	/* while there are controls */
		CALL ParseControl;
	END;
	DO p = 0 TO 127;
		hashTab(p) = 0;
	END;
	DO p = SEG$ABS TO SEG$RESERVE;
		segLen(p) = 0;
		alignType(p) = 0;
	END;
	DO p = 0 TO 255;
		segmap(p) = 0;		/* mark seg as unused */
	END;
	outTranId = 0;
	outTranVn = 0;
	modEndModTyp = 0;
	modEndSegId = 0;
	modEndOffset, headSegOrderLink, unresolved, maxExternCnt, headUnresolved = 0;
	/* Open print file (could be console) */
	CALL Open(.printFileNo, .printFileName(1), 2, 0, .statusIO);
	CALL FileError(statusIO, .printFileName(1), TRUE);
	/* if printing to other than console, log the login & command line */
	IF printFileNo > 0 THEN
	DO;
		CALL WriteBytes(.login, size(login));
		CALL WriteBytes(.VERSION, 4);
		CALL WriteBytes(.msgInvoked, 14);
		CALL WriteBytes(.scmdch, cmd$p - .scmdch + 2);
	END;
END ParseCmdLine;

END link3a;
linkov.plm
$xref
/*	Copyright (c) 2012 by Mark Ogden
	Released into the public domain for academic historic interest
	only and not for commercial gain. */
linkovl: DO;
$include(linkov.ipx)

DECLARE COPYRIGHT(*) BYTE DATA('(C) 1976, 1977, 1979 INTEL CORP');
DECLARE OVERLAYVERSION(*) BYTE PUBLIC DATA('V3.0');
DECLARE zero ADDRESS DATA(0);
DECLARE fakeModhdr(1) BYTE DATA(6);
DECLARE space BYTE DATA(' ');

DECLARE msgrefin(*) BYTE PUBLIC INITIAL(' - REFERENCED IN ');

DECLARE modName(32) BYTE PUBLIC,
	ancestorNameNotSet BYTE,
	fixType BYTE,
	segIdx BYTE,
	pad(3) BYTE,
	segId ADDRESS,
	outRelocOffset ADDRESS,
	extMap$p ADDRESS INITIAL(0),
	externsCount ADDRESS INITIAL(0),
	externsBase ADDRESS INITIAL(0),
	externsEnd ADDRESS INITIAL(0),
	haveTmpFile BYTE INITIAL(0),
	outRecord$p ADDRESS PUBLIC;

/* based types to get to input and output record start info */
DECLARE	inRecord BASED inRecord$p STRUCTURE (type BYTE, len ADDRESS, rec(1) BYTE);
DECLARE outRecord BASED outRecord$p STRUCTURE(type BYTE, len ADDRESS, rec(1) BYTE);
/* generic based type to map to OMF style name at current location in input and output records */
DECLARE inOMFName BASED in$p STRUCTURE (len BYTE, name(1) BYTE);
DECLARE outOMFName BASED out$p STRUCTURE (len BYTE, name(1) BYTE);


SeekExtMap: PROCEDURE PUBLIC;
	DECLARE blk ADDRESS;

	blk = SHR(externsBase, 6);	/* divide 64 as each entry is a word */
	CALL Seek(tmpfilefd, 2, .blk, .zero, .statusIO);
	CALL FileError(statusIO, .linkTmpFile(1), TRUE);
END SeekExtMap;

PageOutExtMap: PROCEDURE PUBLIC;
	IF externsBase >= externsEnd THEN	/* update end boundary in case of partial page */
		externsEnd = externsEnd + 128;
	CALL SeekExtMap;
	CALL Write(tmpfilefd, extMap$p, 256, .statusIO);
	CALL FileError(statusIO, .linkTmpFile(1), TRUE);
END PageOutExtMap;

PageInExtMap: PROCEDURE PUBLIC;
	CALL SeekExtMap;
	CALL Read(tmpfilefd, extMap$p, 256, .actRead, .statusIO);
	CALL FileError(statusIO, .linkTmpFile(1), TRUE);
	IF actRead <> 256 THEN
		CALL FileError(ERR204, .linkTmpFile(1), TRUE);
END PageInExtMap;

AddExtMap: PROCEDURE(sym$p) PUBLIC;
	DECLARE sym$p ADDRESS;
	DECLARE extMap BASED extMap$p(1) ADDRESS;

	IF (externsCount AND 0FF80H) <> externsBase THEN	/* memory cache full */
	DO;
		IF NOT haveTmpFile THEN				/* if no tmp file create it */
		DO;
			CALL delete(.linkTmpFile(1), .statusIO);
			CALL Open(.tmpfilefd, .linkTmpFile(1), 3, 0, .statusIO);
			CALL FileError(statusIO, .linkTmpFile(1), TRUE);
			haveTmpFile = TRUE;
		END;
		CALL PageOutExtMap;
		IF (externsBase := externsCount AND 0FF80H) < externsEnd THEN
			CALL PageInExtMap;			/* if the page exists get it from disk */
	END;
	extMap(externsCount - externsBase) = sym$p;	/* record the symbol mapping */
	externsCount = externsCount + 1;
END AddExtMap;

GetSymbol$p: PROCEDURE(symId) ADDRESS PUBLIC;
	DECLARE symId ADDRESS;
	DECLARE extMap BASED extMap$p (1) ADDRESS;

	IF symId >= externsCount THEN	/* out of range */
		CALL IllFmt;
	IF (symId AND 0FF80H) <> externsBase THEN	/* not in memory */
	DO;
		CALL PageOutExtMap;			/* Write out current */
		externsBase = symId AND 0FF80H;		/* set new base */
		CALL PageInExtMap;			/* get relevant page */
	END;
	RETURN extMap(symId - externsBase);		/* return the symbol$p */
END GetSymbol$p;

InitExternsMap: PROCEDURE PUBLIC;
	IF extMap$p = 0 THEN	/* not already allocated */
	DO;
		IF maxExternCnt > 128 THEN	/* max 128 extern entries in memory */
			extMap$p = GetLow(100H);
		ELSE
			extMap$p = GetLow(maxExternCnt * 2);
	END;
	externsCount, externsBase, externsEnd = 0;
END InitExternsMap;

FlushTo: PROCEDURE PUBLIC;
	CALL Write(tofilefd, sout$p, out$p - sout$p, .statusIO);
	CALL FileError(statusIO, .toFileName(1), TRUE);
	out$p = sout$p;
END FlushTo;

InitRecord: PROCEDURE(type) PUBLIC;
	DECLARE type BYTE;

	IF eout$p - out$p < 1028 THEN
		CALL FlushTo;
	outRecord$p = out$p;
	outRecord.type = type;
	out$p = out$p + 3;
END InitRecord;

EndRecord: PROCEDURE PUBLIC;
	DECLARE crc BYTE;
	DECLARE pch ADDRESS;
	DECLARE ch BASED pch BYTE;
	DECLARE crcCH BASED out$p BYTE;

	IF (outRecord.len := out$p - .outRecord.type - 2) > 1025 THEN
		CALL FileError(ERR211, .toFileName(1), TRUE);	/* Record to long */
	crc = 0;
	DO pch = .outRecord.type TO out$p - 1;	/* calculate and insert crc */
		crc = crc + ch;
	END;
	crcCH = -crc;
	out$p = out$p + 1;
END EndRecord;

ExtendRec: PROCEDURE(cnt) BYTE PUBLIC;
	DECLARE cnt ADDRESS;
	DECLARE type BYTE;

	IF out$p + cnt - .outRecord.type < 1028 THEN	/* room in buffer */
		RETURN FALSE;
	type = outRecord.type;	/* type for extension record */
	CALL EndRecord;		/* Close off the current record */
	CALL InitRecord(type);	/* and prepare another */
	RETURN TRUE;
END ExtendRec;

EmitMODHDR: PROCEDURE PUBLIC;
	DECLARE reserved BASED out$p STRUCTURE (tranId BYTE, tranVn BYTE);
	DECLARE sdef BASED out$p STRUCTURE (segid BYTE, len ADDRESS, combine BYTE);

	EmitMODHDR$comSegInfo: PROCEDURE(segid, len, combine);
		DECLARE (segid, combine) BYTE, len ADDRESS;

		IF ExtendRec(size(sdef)) THEN	/* make sure enough room */
			CALL FileError(ERR226, .toFileName(1), TRUE);	/* mod hdr too long */
		sdef.segid = segid;		/* emit segid, name, combine and size */
		sdef.len = len;
		sdef.combine = combine;
		out$p = out$p + size(sdef);
	END EmitMODHDR$comSegInfo;

	CALL InitRecord(R$MODHDR);
	CALL Pstrcpy(.outModuleName, .outOMFName);	/* copy the module name */
	out$p = out$p + outModuleName(0) + 1;
	reserved.tranId = outTranId;		/* the two reserved bytes */
	reserved.tranVn = outTranVn;
	out$p = out$p + 2;
	DO segIdx = SEG$CODE TO SEG$MEMORY;	/* regular segments */
		IF segLen(segIdx) > 0 THEN
			CALL EmitMODHDR$comSegInfo(segIdx, segLen(segIdx), alignType(segIdx));
	END;
	IF segLen(0) > 0 THEN		/* unamed common segment */
		CALL EmitMODHDR$comSegInfo(SEG$BLANK, segLen(0), alignType(0));
	comdefInfo$p = headSegOrderLink;
	DO WHILE comdefInfo$p > 0;		/* named common segments */
		CALL EmitMODHDR$comSegInfo(comdefInfo.linkedSeg, comdefInfo.len, comdefInfo.flags);
		comdefInfo$p = comdefInfo.segOrderLink;
	END;
	CALL EndRecord;
END EmitMODHDR;

EmitEnding: PROCEDURE PUBLIC;
	DECLARE	outModend BASED out$p STRUCTURE (modtype BYTE, segid BYTE, offset ADDRESS);
	CALL InitRecord(R$MODEND);	/* init the record */
	outModend.modtype = modEndModTyp; /* fill in the mod type, start seg and offset */
	outModend.segid = modEndSegId;
	outModend.offset = modEndOffset;
	out$p = out$p + size(outModend);	/* advance past the data inserted */
	CALL EndRecord;			/* finalise */
	CALL InitRecord(R$EOF);		/* emit and EOF record as well */
	CALL EndRecord;
	CALL FlushTo;			/* make sure all on disk */
END EmitEnding;

EmitCOMDEF: PROCEDURE PUBLIC;
	DECLARE	outComdef BASED out$p STRUCTURE (seg BYTE, name(1) BYTE);
	IF headSegOrderLink = 0 THEN	/* no named common */
		RETURN;
	CALL InitRecord(R$COMDEF);	/* prep the record */
	comdefInfo$p = headSegOrderLink;	/* chase down the definitions in seg order */
	DO WHILE comdefInfo$p > 0;
		IF ExtendRec(DOUBLE(2) + comdefInfo.name(0)) THEN	/* overflow to another record if needed */
			;		/* IF really not needed here as there are no issues with overflowing */
		outComdef.seg = comdefInfo.linkedSeg;	/* copy the seg and name */
		CALL Pstrcpy(.comdefInfo.name, out$p + 1);
		out$p = out$p + size(outComdef) + comdefInfo.name(0);	/* advance output pointer */
		comdefInfo$p = comdefInfo.segOrderLink;	/* pickup next entry */
	END;
	CALL EndRecord;		/* finalise */
END EmitCOMDEF;

EmitPUBLICS: PROCEDURE PUBLIC;
	DECLARE obuf BASED out$p (1) BYTE;
	DECLARE outSegId BASED out$p STRUCTURE (seg BYTE);
	DECLARE outPubdef  BASED out$p STRUCTURE (offset ADDRESS, name(1) BYTE /*, 0 */);

	DO segIdx = 0 TO 255;			/* scan all segs */
		IF segmap(segIdx) THEN		/* seg used */
		DO;
			CALL InitRecord(R$PUBLICS);	/* init the record */
			outSegId.seg = segIdx;		/* seg needed */
			out$p = out$p + 1;
			curObjFile = objFileHead;	/* scan all files */
			DO WHILE curObjFile > 0;
				curModule = objFile.modlist;
				DO WHILE curModule > 0;	/* and all modules */
					symbol$p = module.symlist;
					DO WHILE symbol$p > 0;	/* and all symbols */
						IF symbol.linkedSeg = segIdx THEN	/* this symbol in the right seg */
						DO;
							IF ExtendRec(DOUBLE(4) + symbol.name(0)) THEN	/* makes sure enough room in record */
							DO;
								outSegId.seg = segIdx;	/* overflowed to new record so add the segid */
								out$p = out$p + 1;
							END;
							outPubdef.offset = symbol.offsetOrSym;	/* Write the offset */
							CALL Pstrcpy(.symbol.name, .outPubdef.name);	/* and the name */
							obuf(symbol.name(0) + 3) = 0;		/* add the extra 0 reserved byte */
							out$p = out$p + 4 + symbol.name(0);	/* account for data added */
						END;
						symbol$p = symbol.nxtSymbol;	/* loop to next symbol */
					END;
					curModule = module.link;	/* next module*/
				END;
				curObjFile = objFile.link;	/* next file */
			END;
			CALL EndRecord;				/* finish any Open record */
		END;
	END;
END EmitPUBLICS;

EmitEXTNAMES: PROCEDURE PUBLIC;
	DECLARE buf BASED out$p(1) BYTE;

	IF headUnresolved = 0 THEN		/* no unresolved */
		RETURN;
	CALL InitRecord(R$EXTNAMES);		/* init the record */
	unresolved = 0;
	symbol$p = headUnresolved;
	DO WHILE symbol$p > 0;
		IF ExtendRec(DOUBLE(2) + symbol.name(0)) THEN	/* check room for len, symbol and 0 */
			;					/* no need for special action on extend */
		CALL Pstrcpy(.symbol.name, .outOMFName);	/* copy the len + symbol */
		buf(symbol.name(0) + 1) = 0;			/* add a 0 */
		out$p = out$p + 2 + symbol.name(0);		/* advance past inserted data */
		symbol.offsetOrSym = unresolved;		/* record the final ext sym id */
		unresolved = unresolved + 1;			/* for next symbol */
		symbol$p = symbol.nxtSymbol;
	END;
	CALL EndRecord;						/* clean closure of record */
END EmitEXTNAMES;

Emit$ANCESTOR: PROCEDURE PUBLIC;
	IF ancestorNameNotSet THEN					/* we have a module name to use */
	DO;
		CALL InitRecord(R$ANCESTOR);			/* init the record */
		CALL Pstrcpy(.modName, .outOMFName);		/* copy name */
		out$p = out$p + modName(0) + 1;
		CALL EndRecord;
		ancestorNameNotSet = 0;				/* it is now set */
	END;
END Emit$ANCESTOR;

SelectOutSeg: PROCEDURE(seg) BYTE PUBLIC;
	DECLARE seg BYTE;
	outRelocOffset = 0;		/* only code and data modules are relative to module location */
	IF seg = SEG$CODE THEN
		outRelocOffset = module.scode;
	ELSE IF seg = SEG$DATA THEN
		outRelocOffset = module.sdata;
	return segmap(seg);		/* return seg mapping */
END SelectOutSeg;

Pass2MODHDR: PROCEDURE PUBLIC;
	CALL Pstrcpy(.inOMFName, .modName);	/* Read in the module name */
	ancestorNameNotSet = TRUE;		/* note the ancestor record has not been written */
	DO segId = 0 TO 255;			/* init the segment mapping */
		segmap(segId) = segId;
	END;
	CALL GetRecord;
END Pass2MODHDR;

Pass2COMDEF: PROCEDURE PUBLIC;
	DECLARE	inComdef BASED in$p STRUCTURE (seg BYTE, name(1) BYTE);
	DO WHILE in$p < .erec;		/* while more common definitions */
		IF NOT Lookup(.inComdef.name, .comdefInfo$p, F$ALNMASK) THEN	/* check found */
			CALL FatalErr(ERR219);	/* Phase Error */
		segmap(inComdef.seg) = comdefInfo.linkedSeg;			/* record the final linked seg where this goes */
		in$p = in$p + 2 + inComdef.name(0);				/* past this def */
	END;
	CALL GetRecord;	
END Pass2COMDEF;

Pass2EXTNAMES: PROCEDURE PUBLIC;
	DO WHILE in$p < .erec;		/* while more external definitions */
		IF NOT Lookup(in$p, .symbol$p, F$SCOPEMASK) THEN	/* get the name */
			CALL FatalErr(ERR219);	/* phase Error - didn't Lookup !!! */
		CALL AddExtMap(symbol$p);
		IF symbol.flags = F$EXTERN THEN	/* still an extern */
		DO;				/* Write the unresolved reference info */
			CALL WriteAndEcho(.space, 1);
			CALL WriteAndEcho(.symbol.name(1), symbol.name(0));
			CALL WAEFnAndMod(.msgrefin, 17);	/* ' - REFERENCED IN ' */
		END;
		in$p = in$p + 2 + inOMFName.len;	/* 2 for len and extra 0 */
	END;
	CALL GetRecord;
END Pass2EXTNAMES;

Pass2CONTENT: PROCEDURE PUBLIC;
	DECLARE (outContentSeg, crc) BYTE;
	DECLARE (savedOut$p, savedRecLen, outContentRelocOffset, inContentStart, inContentEnd, bytes2Read, p) ADDRESS;
	DECLARE (headextern$p, headReloc$p, fixup$p, reloc$p, markheap) ADDRESS;
	DECLARE bfixup BASED p BYTE;
	DECLARE wfixup BASED p ADDRESS;
	DECLARE ch BASED p BYTE;
	DECLARE fixup BASED fixup$p STRUCTURE(link ADDRESS, typeAndSeg ADDRESS, relocList ADDRESS);
	DECLARE extFixup BASED reloc$p STRUCTURE(link ADDRESS, offset ADDRESS, sym ADDRESS);
	DECLARE reloc BASED reloc$p STRUCTURE(link ADDRESS, offset ADDRESS);
	DECLARE	outContent BASED out$p STRUCTURE (seg BYTE, offset ADDRESS, bytes(1) BYTE);
	DECLARE	inFixtype BASED in$p BYTE;
	DECLARE	inExtref BASED in$p STRUCTURE (sym ADDRESS, offset ADDRESS);
	DECLARE	outFixtype BASED out$p BYTE;
	DECLARE	outExtref BASED out$p STRUCTURE (sym ADDRESS, offset ADDRESS);
	DECLARE	inOffset BASED in$p ADDRESS;
	DECLARE	inSegId BASED in$p BYTE;
	DECLARE	outInterseg BASED out$p STRUCTURE (seg BYTE, fixType BYTE); 
	DECLARE	outOffset BASED out$p Address;

	BoundsChk: PROCEDURE(addr);
		DECLARE addr ADDRESS;
		IF addr < inContentStart OR inContentEnd < addr THEN
			CALL FatalErr(ERR213);	/* fixup bounds Error */
	END BoundsChk;

	GetTypeAndSegHead: PROCEDURE(afixup$p, typeAndSeg);
		DECLARE afixup$p ADDRESS;
		DECLARE typeAndSeg ADDRESS;
		DECLARE afixup BASED afixup$p STRUCTURE(link ADDRESS, typeAndSeg ADDRESS, relocList ADDRESS);

		fixup$p = afixup.link;	/* chase down the fixup chain matching seg and fixup type */
		DO WHILE fixup$p > 0;
			IF fixup.typeAndSeg = typeAndSeg THEN	/* found existing list */
				RETURN;
			afixup$p = .fixup.link;			/* step along */
			fixup$p = fixup.link;
		END;
		fixup$p = GetHigh(size(afixup));			/* add to the list */
		fixup.link = afixup.link;
		afixup.link = fixup$p;
		fixup.typeAndSeg = typeAndSeg;			/* save the typeAndSeg */
		fixup.relocList = 0;
	END GetTypeAndSegHead;


	AddRelocFixup: PROCEDURE(seg, addr);
		DECLARE seg BYTE, addr ADDRESS;
		CALL GetTypeAndSegHead(.headReloc$p, seg * 256 + fixType);	/* add to reloc list */
		reloc$p = GetHigh(size(reloc));
		reloc.link = fixup.relocList;
		fixup.relocList = reloc$p;
		reloc.offset = addr + outContentRelocOffset;
	END AddRelocFixup;

	inRecord$p = .fakeModhdr;	/* keep inRecord$p pointing to a modhdr */
	CALL InitRecord(R$CONTENT);	/* init record */
	outRecord.len, savedRecLen = recLen;	/* output length same as input length */
	savedOut$p = out$p;		/* saved start of record */
	crc = HIGH(recLen) + R$CONTENT + LOW(recLen);	/* initialise crc */
	buf$p = in$p;

	DO WHILE recLen > 0;		/* process all of the record */
		IF savedRecLen > 1025 THEN	/* flush current output buf */
			CALL FlushTo;
		IF (bytes2Read := recLen) > npbuf THEN	/* Read in at most npbuf bytes */
			bytes2Read = npbuf;
		CALL ChkRead(bytes2Read);	/* Load them into memory */
		CALL MemMov(bytes2Read, buf$p, out$p);	/* copy to the output buf */
		DO p = out$p TO out$p + bytes2Read - 1;	/* update the CRC */
			crc = crc + ch;
		END;
		buf$p = buf$p + bytes2Read;	/* advance the pointers */
		out$p = out$p + bytes2Read;
		recLen = recLen - bytes2Read;
	END;
	IF crc <> 0 THEN
		CALL FatalErr(ERR208);	/* Checksum Error */
	CALL GetRecord;			/* prime next record */
	IF savedRecLen > 1025 THEN	/* we can't fix up a big record */
		RETURN;

	headextern$p, headReloc$p = 0;	/* initialise the fixup chains */
	savedOut$p = (out$p := savedOut$p) + 3;		/* skip seg and offset */
	outContentSeg = SelectOutSeg(outContent.seg);	/* get the mapped link segment */
	outContentRelocOffset = outRelocOffset;		/* and the content reloc base */
	inContentEnd = (inContentStart := outContent.offset) + savedRecLen - 5;	/* the address range */
	outContent.seg = outContentSeg;			/* update the out seg & address values */
	outContent.offset = inContentStart + outContentRelocOffset;
	markheap = GetHigh(0);				/* get heap marker */

	/* process the relocate records */
	DO WHILE inRecord.type = R$EXTREF OR inRecord.type = R$RELOC OR inRecord.type = R$INTERSEG;
		IF inRecord.type = R$EXTREF THEN
		DO;
			IF (fixType := inFixtype) - 1 > 2 THEN	/* make sure combine is valid */
				CALL IllFmt;
			in$p = in$p + 1;		/* past the record byte */
			DO WHILE in$p < .erec;		/* process all of the extref fixups */
				CALL BoundsChk(inExtref.offset);	/* check fixup valid */
				IF fixType = FIX$BOTH THEN
					CALL BoundsChk(inExtref.offset + 1);	/* check upper byte also in range */
				symbol$p = GetSymbol$p(inExtref.sym);		/* get symbol entry for the ext symid */
				IF symbol.flags = F$PUBLIC THEN			/* is a PUBLIC so resolved */
				DO;
					p = inExtref.offset - inContentStart + savedOut$p;	/* Lookup fixup address in buffer */
					DO CASE fixType - 1;			/* relocate to segs current base */
					bfixup = bfixup + LOW(symbol.offsetOrSym);
					bfixup = bfixup + HIGH(symbol.offsetOrSym);
					wfixup = wfixup + symbol.offsetOrSym;
					END;
					IF symbol.linkedSeg <> SEG$ABS THEN		/* if not ABS add a fixup entry */
						CALL AddRelocFixup(symbol.linkedSeg, inExtref.offset);
				END;
				ELSE						/* is an extern still */
				DO;
					CALL GetTypeAndSegHead(.headextern$p, fixType);	/* add to extern list, seg not needed */
					reloc$p = GetHigh(size(extFixup));	/* allocate the extFixup descriptor */
					extFixup.link = fixup.relocList;		/* chain it in */
					fixup.relocList = reloc$p;
					extFixup.offset = inExtref.offset + outContentRelocOffset;	/* add in the location */
					extFixup.sym = symbol.offsetOrSym;	/* and the symbol id */
				END;
				in$p = in$p + 4;
			END;
		END;
		ELSE	/* reloc or interseg */
		DO;
			segIdx = outContentSeg;			/* get default reloc seg */
			outRelocOffset = outContentRelocOffset;	/* and reloc base to that of the content record */
			IF inRecord.type = R$INTERSEG THEN	/* if we are interseg then update the reloc seg */
			DO;
				segIdx = SelectOutSeg(inSegId);	/* also updates the outRelocOffset */
				in$p = in$p + 1;
			END;
			IF segIdx = 0 THEN			/* ABS is illegal */
				CALL IllFmt;
			IF (fixType := inFixtype) - 1 > 2 THEN	/* bad fix up type ? */
				CALL IllFmt;
			in$p = in$p + 1;			/* past fixup */
			DO WHILE in$p < .erec;			/* process all of the relocates */
				CALL BoundsChk(inOffset);	/* fixup in range */
				IF fixType = FIX$BOTH THEN	/* and 2nd byte for both byte fixup */
					CALL BoundsChk(inOffset + 1);
				p = inOffset - inContentStart + savedOut$p;	/* location of fixup */
				DO CASE fixType - 1;		/* relocate to seg current base */
				bfixup = bfixup + LOW(outRelocOffset);
				bfixup = bfixup + HIGH(outRelocOffset);
				wfixup = wfixup + outRelocOffset;
				END;
				CALL AddRelocFixup(segIdx, inOffset);	/* add a new reloc fixup */
				in$p = in$p + 2;
			END;
		END;
		CALL GetRecord;	/* next record */
	END;
	out$p = out$p + savedRecLen - 1;
	CALL EndRecord;				/* finish the content record */
	fixup$p = headextern$p;			/* process the extern lists */
	DO WHILE fixup$p > 0;
		CALL InitRecord(R$EXTREF);	/* create a extref record */
		outFixtype = LOW(fixup.typeAndSeg);	/* set the fix type */
		out$p = out$p + 1;
		reloc$p = fixup.relocList;	/* process all of the extref of this fixtype */
		DO WHILE reloc$p > 0;
			IF ExtendRec(4) THEN	/* make sure we have room */
			DO;			/* if not add the fixtype to the newly created follow on record */
				outFixtype = LOW(fixup.typeAndSeg);
				out$p = out$p + 1;
			END;
			outExtref.sym = extFixup.sym;	/* put the sym number */
			outExtref.offset = extFixup.offset;	/* and the fixup location */
			out$p = out$p + 4;		/* update to reflect 4 bytes written */
			reloc$p = extFixup.link;	/* chase the list */
		END;
		CALL EndRecord;			/* Close any Open record */
		fixup$p = fixup.link;		/* look for next fixtype list */
	END;
	fixup$p = headReloc$p;			/* now do the relocates */
	DO WHILE fixup$p > 0;
		CALL InitRecord(R$INTERSEG);	/* interseg record */
		outInterseg.seg = HIGH(fixup.typeAndSeg);	/* fill in segment */
		outInterseg.fixtype = LOW(fixup.typeAndSeg);	/* and fixtype */
		out$p = out$p + 2;
		reloc$p = fixup.relocList;	/* chase down the references */
		DO WHILE reloc$p > 0;
			IF ExtendRec(2) THEN	/* two bytes or create follow on record */
			DO;			/* fill in follow on record */
				outInterseg.seg = HIGH(fixup.typeAndSeg);
				outInterseg.fixtype = LOW(fixup.typeAndSeg);
				out$p = out$p + 2;
			END;
			outOffset = extFixup.offset;	/* set the fill the offset */
			out$p = out$p + 2;
			reloc$p = extFixup.link;	/* next record */
		END;
		CALL EndRecord;
		fixup$p = fixup.link;
	END;
	membot = markheap;		/* return heap */

END Pass2CONTENT;

Pass2LINENO: PROCEDURE PUBLIC;
	DECLARE	inSegId BASED in$p BYTE;
	DECLARE	inLineno BASED in$p STRUCTURE (offset ADDRESS, linnum ADDRESS);
	DECLARE	outSegId BASED out$p BYTE;
	DECLARE	outLineno BASED out$p STRUCTURE (offset ADDRESS, linnum ADDRESS);

	CALL Emit$ANCESTOR;		/* make sure we have a valid ancestor record */
	CALL InitRecord(R$LINENO);
	outSegId = SelectOutSeg(inSegId);	/* add the seg id info */
	out$p = out$p + 1;
	in$p = in$p + 1;
	DO WHILE in$p < .erec;		/* while more public definitions */
		outLineno.offset = outRelocOffset + inLineno.offset;	/* relocate the offset */
		outLineno.linnum = inLineno.linnum;			/* copy the line number */
		out$p = out$p + 4;
		in$p = in$p + 4;
	END;
	CALL EndRecord;
	CALL GetRecord;
END Pass2LINENO;

Pass2ANCESTOR: PROCEDURE PUBLIC;
	CALL Pstrcpy(.inOMFName, .modName);	/* copy the module name over and mark as valid */
	ancestorNameNotSet = TRUE;		/* note it isn't written yet */
	CALL GetRecord;
END Pass2ANCESTOR;

Pass2LOCALS: PROCEDURE PUBLIC;
	DECLARE inSegId BASED in$p BYTE;
	DECLARE inLocals BASED in$p STRUCTURE (offset ADDRESS, name(1) BYTE /*, 0 */);
	DECLARE outSegId BASED out$p BYTE;
	DECLARE outLocals BASED out$p STRUCTURE (offset ADDRESS, name(1) BYTE /*, 0 */);

	CALL Emit$ANCESTOR;			/* emit ancestor if needed */
	CALL InitRecord(R$LOCALS);		/* init locals record */
	outSegId = SelectOutSeg(inSegId);	/* map the segment and set up relocation base */
	out$p = out$p + 1;
	in$p = in$p + 1;
	/* note the code below relies on the source file having records <1025 */
	DO WHILE in$p < .erec;		/* while more local definitions */
		outLocals.offset = outRelocOffset + inLocals.offset;	/* Write offset and symbol */
		CALL Pstrcpy(.inLocals.name, .outLocals.name);
		outLocals.name(inLocals.name(0) + 1) = 0;
		out$p = out$p + 4 + inLocals.name(0);			/* advance out and in pointers */
		in$p = in$p + 4 + inLocals.name(0);
	END;
	CALL EndRecord;			/* clean end */
	CALL GetRecord;			/* next record */
END Pass2LOCALS;

/* process pass 2 records */
Phase2: PROCEDURE PUBLIC;
	IF (membot := .MEMORY) > topHeap THEN				/* check that memory still ok after overlay */
		CALL FileError(ERR210, .toFileName(1), TRUE);	/* insufficient memory */
	sout$p, out$p = GetLow(npbuf);				/* reserve the output buffer */
	eout$p = sout$p + npbuf;
	CALL InitExternsMap;
	CALL Open(.tofilefd, .toFileName(1), 2, 0, .statusIO);		/* target file */
	CALL FileError(statusIO, .toFileName(1), TRUE);
	CALL EmitMODHDR;						/* process the simple records */
	CALL EmitCOMDEF;
	CALL EmitPUBLICS;
	CALL EmitEXTNAMES;
	curObjFile = objFileHead;					/* process all files */
	DO WHILE curObjFile > 0;
		IF objfile.publicsMode THEN				/* don't need to do anything more for publics only file */
			curObjFile = objfile.link;
		ELSE
		DO;
			CALL OpenObjFile;				/* Open file */
			curModule = objfile.modlist;			/* for each module in the file */
			DO WHILE curModule > 0;
				CALL GetRecord;				/* Read modhdr */
				IF objfile.hasmodules THEN		/* if we have modules Seek to the current module's location */
				DO;
					CALL Position(module.blk, module.byt);
					CALL GetRecord;			/* and Load its modhdr */
				END;
				IF inRecord.type <> R$MODHDR THEN
					CALL FatalErr(ERR219); /* phase Error */
				CALL InitExternsMap;			/* prepare for processing this module's extdef records */
				DO WHILE inRecord.type <> R$MODEND;	/* run through the whole module */
					DO CASE SHR(inRecord.type, 1);
					CALL IllegalRelo;
					CALL Pass2MODHDR;	/* R$MODHDR */
					;			/* R$MODEND */
					CALL Pass2CONTENT;	/* R$CONTENT */
					CALL Pass2LINENO;
					CALL IllegalRelo;
					CALL IllegalRelo;
					CALL FileError(ERR204, .inFileName(1), TRUE); /* 0E Premature EOF */
					CALL Pass2ANCESTOR;
					CALL Pass2LOCALS;
					CALL IllegalRelo;
					CALL GetRecord;
					CALL Pass2EXTNAMES;
					CALL IllegalRelo;
					CALL IllegalRelo;
					CALL IllegalRelo;
					CALL BadRecordSeq;
					CALL BadRecordSeq;
					CALL BadRecordSeq;
					CALL BadRecordSeq;
					CALL BadRecordSeq;
					CALL BadRecordSeq;
					CALL BadRecordSeq;
					CALL Pass2COMDEF;		/* 2E */
					END;
				END;
				curModule = module.link;
			END;
			CALL CloseObjFile;
		END; /* of else */
	END;	/* of do while */
	CALL EmitEnding;	/* Write final modend and EOF record */
	CALL Close(tofilefd, .statusIO);
	CALL FileError(statusIO, .toFileName(1), TRUE);
	IF haveTmpFile THEN		/* clean any tmp file up */
	DO;
		CALL Close(tmpfilefd, .statusIO);
		CALL FileError(statusIO, .linkTmpFile(1), TRUE);
		CALL delete(.linkTmpFile(1), .statusIO);
	END;
END Phase2;

END linkovl;
mkfnam.plm
$xref
/*	Copyright (c) 2012 by Mark Ogden
	Released into the public domain for academic historic interest
	only and not for commercial gain. */
mkfnam:
DO;
$include(mkfnam.ipx)

DECLARE devices(*) BYTE DATA('F0F1F2F3F4F5TITO',
			     'VIVOI1O1TRHRR1R2',
			     'TPHPP1P2LPL1BBCI',
			     'COF6F7F8F9');

MakeFullName: PROCEDURE(pinfo, pstr) PUBLIC;
	DECLARE (pinfo, pstr) ADDRESS;
	DECLARE str BASED pstr(1) BYTE;
	DECLARE ch BASED pstr BYTE;
	DECLARE inf BASED pinfo SPATH$T;
	DECLARE i BYTE;
	str(0) = ':';
	str(1) = devices(inf.deviceId + inf.deviceId);
	str(2) = devices(inf.deviceId + inf.deviceId + 1);
	str(3) = ':';
	pstr = pstr + 4;
	DO i = 0 TO 5;
		IF (ch := inf.name(I)) <> 0 THEN
			pstr = pstr + 1;
	END;
	IF inf.ext(0) <> 0 THEN
	DO;
		ch = '.';
		pstr = pstr + 1;
	END;
	DO i = 0 TO 2;
		IF (ch := inf.ext(I)) <> 0 THEN
			pstr = pstr + 1;
	END;
	ch = ' ';
END MakeFullName;
END;
pstafn.plm
$xref
/*	Copyright (c) 2012 by Mark Ogden
	Released into the public domain for academic historic interest
	only and not for commercial gain. */
pstafn:
DO;
$include(pstafn.ipx)

ScanBlank: PROCEDURE(pch) ADDRESS PUBLIC;
	DECLARE pch ADDRESS;
	DECLARE ch BASED pch BYTE;

	DO WHILE 1;
		pch = Delimit(pch);
		IF ch = '*' OR ch = '?' THEN
			pch = pch + 1;
		ELSE
			RETURN pch;
	END;
END ScanBlank;
END;
pstfn.plm
$xref
/*	Copyright (c) 2012 by Mark Ogden
	Released into the public domain for academic historic interest
	only and not for commercial gain. */
pstfn:
DO;
Delimit: PROCEDURE(pch) ADDRESS PUBLIC;
	DECLARE pch ADDRESS;
	DECLARE ch BASED PCH BYTE;

	DO WHILE ch = ':' OR ch = '.' OR (ch >= '0' AND ch <= '9') OR (ch >= 'A' AND ch <= 'Z');
		pch = pch + 1;
	END;
	RETURN pch;
END Delimit;
END;
skpspc.plm
$xref
/*	Copyright (c) 2012 by Mark Ogden
	Released into the public domain for academic historic interest
	only and not for commercial gain. */
skpspc:
DO;

Deblank: PROCEDURE(pch) ADDRESS PUBLIC;
	DECLARE pch ADDRESS;
	DECLARE ch BASED pch BYTE;

	DO WHILE ch = ' ';
		pch = pch + 1;
	END;
	RETURN pch;
END Deblank;

END;
strequ.plm
$xref
/*	Copyright (c) 2012 by Mark Ogden
	Released into the public domain for academic historic interest
	only and not for commercial gain. */
strtst:
DO;
Strequ: PROCEDURE(str1p, str2p, cnt) BYTE PUBLIC;
	DECLARE (str1p, str2p) ADDRESS;
	DECLARE cnt BYTE;
	DECLARE i BYTE;
	DECLARE str1 BASED str1p (1) BYTE;
	DECLARE str2 BASED str2p (1) BYTE;


	cnt = cnt - 1;
	DO i = 0 TO cnt;
		IF str1(i) <> str2(i) THEN
			RETURN 0;
	END;
	RETURN 0FFH;
END Strequ;
END;
wrerr.plm
$xref
/*	Copyright (c) 2012 by Mark Ogden
	Released into the public domain for academic historic interest
	only and not for commercial gain. */
wrerr:
DO;
$include(wrerr.ipx)

DECLARE errStrTable(*) BYTE DATA (
	2,'ILLEGAL AFTN ARGUMENT',0,
	3,'TOO MANY OPEN FILES',0,
	4,'INCORRECTLY SPECIFIED FILE',0,
	5,'UNRECOGNIZED DEVICE NAME',0,
	9,'DISK DIRECTORY FULL',0,
	12,'FILE IS ALREADY OPEN',0,
	13,'NO SUCH FILE',0,
	14,'WRITE PROTECTED',0,
	17,'NOT A DISK FILE',0,
	19,'ATTEMPTED SEEK ON NON-DISK FILE',0,
	20,'ATTEMPTED BACK SEEK TOO FAR',0,
	21,'CAN''T RESCAN',0,
	22,'ILLEGAL ACCESS MODE TO OPEN',0,
	23,'MISSING FILENAME',0,
	27,'ILLEGAL SEEK COMMAND',0,
	28,'MISSING EXTENSION',0,
	31,'CAN''T SEEK ON WRITE ONLY FILE',0,
	32,'CAN''T DELETE OPEN FILE',0,
	34,'ILLEGAL LOAD COMMAND',0,
	35,'SEEK PAST EOF',0,
	203,'INVALID SYNTAX',0,
	204,'PREMATURE EOF',0,
	208,'CHECKSUM ERROR',0,
	210,'INSUFFICIENT MEMORY',0,
	211,'RECORD TOO LONG',0,
	212,'ILLEGAL RELO RECORD',0,
	213,'FIXUP BOUNDS ERROR',0,
	218,'ILLEGAL RECORD FORMAT',0,
	219,'PHASE ERROR',0,
	220,'NO EOF',0,
	221,'SEGMENT TOO LARGE',0,
	224,'BAD RECORD SEQUENCE',0,
	225,'INVALID NAME',0,
	226,'NAME TOO LONG',0,
	227,'LEFT PARENTHESIS EXPECTED',0,
	228,'RIGHT PARENTHESIS EXPECTED',0,
	229,'UNRECOGNIZED CONTROL',0,
	233,'''TO'' EXPECTED',0,
	234,'DUPLICATE FILE NAME',0,
	235,'NOT A LIBRARY',0,
	236,'TOO MANY COMMON SEGMENTS',0,
	238,'ILLEGAL STACK CONTENT RECORD',0,
	239,'NO MODULE HEADER RECORD',0,
	0);


ReportError: PROCEDURE(errCode) PUBLIC;
	DECLARE errCode ADDRESS;
	DECLARE i ADDRESS;
	DECLARE status ADDRESS;

	IF LOW(errCode) <> 0 THEN
	DO;
	    i = 0;
	    DO WHILE i < LENGTH(errStrTable);
		IF LOW(errCode) = errStrTable(i) THEN
		DO;
			CALL Write(0, .(' '), 1, .status);
			DO WHILE errStrTable(i := i + 1) <> 0;
				CALL Write(0, .errStrTable(i), 1, .status);
			END;
			CALL Write(0, .(0DH, 0AH), 2, .status);
			RETURN;
		END;
		ELSE DO;
			DO WHILE errStrTable(i := i + 1) <> 0;
			END;
			i = i + 1;
		END;
            END;
	    CALL Error(errCode);	/* pass to ISIS */
	END;
END ReportError;



END;
isisen.asm
	PUBLIC ISIS

	ASEG
ISIS	EQU 40h
	END
memmov.asm
	PUBLIC MemMov
	CSEG
; mem$move(count, src$p, dst$p)
MemMov: pop	h
	xthl
	push	b
	mov	b, h
	mov	c, l
	pop	h
	dcx	b
	mov	a, e
	sub	l
	mov	a, d
	jz	l410F
	sbb	h
	jmp	l4111

l410F:	sbb	h
	rz

l4111:	push	h
	lxi	h, l4167
	jc	l4121
	pop	h
	dad	b
	push	h
	xchg
	dad	b
	xchg
	lxi	h, l4190

l4121:	inx	b
	mov	a, b
	rrc
	rrc
	rrc
	mov	b, a
	mvi	a, 7
	ana	c
	push	psw
	xra	c
	rrc
	rrc
	rrc
	xra	b
	ani	1Fh
	xra	b
	mov	c, a
	mvi	a, 1Fh
	ana	b
	mov	b, a
	inr	b
	inr	c
	pop	psw
	rlc
	rlc
	push	b
	cma
	mov	c, a
	mvi	b, 0FFh
	inx	b
	dad	b
	pop	b
	xthl
	ret

l4147:	mov	a, m
	stax	d
	inx	h
	inx	d
	mov	a, m
	stax	d
	inx	h
	inx	d
	mov	a, m
	stax	d
	inx	h
	inx	d
	mov	a, m
	stax	d
	inx	h
	inx	d
	mov	a, m
	stax	d
	inx	h
	inx	d
	mov	a, m
	stax	d
	inx	h
	inx	d
	mov	a, m
	stax	d
	inx	h
	inx	d
	mov	a, m
	stax	d
	inx	h
	inx	d

l4167:	dcr	c
	jnz	l4147
	dcr	b
	jnz	l4147
	ret

l4170:	mov	a, m
	stax	d
	dcx	h
	dcx	d
	mov	a, m
	stax	d
	dcx	h
	dcx	d
	mov	a, m
	stax	d
	dcx	h
	dcx	d
	mov	a, m
	stax	d
	dcx	h
	dcx	d
	mov	a, m
	stax	d
	dcx	h
	dcx	d
	mov	a, m
	stax	d
	dcx	h
	dcx	d
	mov	a, m
	stax	d
	dcx	h
	dcx	d
	mov	a, m
	stax	d
	dcx	h
	dcx	d

l4190:	dcr	c
	jnz	l4170
	dcr	b
	jnz	l4170
	ret
	END
