/*
    THE SOURCE BELOW NEEDS TO BE COMPILED WITH THE FORTRAN CROSS COMPILER
    UNFORTUNATELY INTEL SEEM TO HAVE USED A LATER VERSION THAT SUPPORTED
    'AT' AND DID NOT FILL UNINITIALISED DATA WITH ZEROS

    THE PERL ROUTINE LOADANDFIX.PL LOADS THE HEX FILE CREATED, 
    AND REPLACES UNITIALISED AND DATA PAST MEMORY WITH THE
    BYTES IN THE ORIGINAL ISIS.T0 FILE
*/
3000H: DO; 

    DECLARE BOOLEAN LITERALLY 'BYTE';
    DECLARE TRUE    LITERALLY '0FFH';
    DECLARE CMSK    LITERALLY '0FCH';
    DECLARE CR  LITERALLY '0DH',
            LF  LITERALLY '0AH';

    DECLARE T0VER DATA(2, 20H);     /* ISIS.T0 VERSION ? */
    DECLARE (USER$STATUS, USER$STACKPTR, START$ADDR) ADDRESS;
    DECLARE A$DEVICE BYTE;
    DECLARE MEMBASE ADDRESS INITIAL(0);
    DECLARE BYTE$AT BASED MEMBASE (1) BYTE;
    DECLARE VERSION$LEVEL   LITERALLY   'BYTE$AT(3EH)',
            EDIT$LEVEL      LITERALLY   'BYTE$AT(3FH)';
    DECLARE TEMP BYTE;
    DECLARE ISIS$SIGNON(12) BYTE INITIAL(CR, LF, 'ISIS-II, V'),
            SIGN$V(2) BYTE, /* VERSION NUMBER */
            SIGN$DOT(1) BYTE INITIAL('.'),
            SIGN$E(2) BYTE,  /* EDIT NUMBER */
            SIGN$CRLF(2) BYTE INITIAL (CR, LF);
3200H:
    DECLARE COPYRIGHT DATA('(C) 1975,1976 INTEL CORP');

    ISIS: PROCEDURE(CMD, PARAM$P);
        DECLARE CMD BYTE, PARAM$P ADDRESS;
        GOTO 40H;
    END ISIS;

    READ: PROCEDURE(CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P) ADDRESS;

        CALL ISIS(3, .CONN);
    END;

    WRITE: PROCEDURE(CONN, BUFF$P, COUNT, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, STATUS$P) ADDRESS;

        CALL ISIS(4, .CONN);
    END;

    EXIT: PROCEDURE;
        DECLARE STATUS ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(9, .STATUS);
    END;

    CONSOL: PROCEDURE(CI$P, CO$P, STATUS$P);
        DECLARE (CI$P, CO$P, STATUS$P) ADDRESS;
        CALL ISIS(8, .CI$P);
    END;

    NUMOUT: PROCEDURE(VALUE, BASE, LC, BUFADR, WIDTH);
        DECLARE (VALUE, BUFADR) ADDRESS, (BASE, LC, WIDTH) BYTE; 
        DECLARE DIGITS DATA('0123456789ABCDEF');
        DECLARE I BYTE;
        DECLARE BUF BASED BUFADR (1) BYTE;

        DO I = 1 TO WIDTH;
            BUF(WIDTH - I) = DIGITS(VALUE MOD BASE);
            VALUE = VALUE / BASE;   
        END;

        I = 0;
        DO WHILE BUF(I) = '0' AND I < WIDTH - 1;
            BUF(I) = LC;
            I = I + 1;
        END;
    END;



    /* THE FOLLOWING FOUR VARIABLES ARE USED IN THE ERR PROCEDURE */
    DECLARE STATUS ADDRESS;     /* ERROR NUMBERS ARE PLACED HERE */
    DECLARE DEBUG$TOGGLE BOOLEAN;   /* GOVERNES ACTION WHEN ERROR OCCURS */
    DECLARE GLOBAL$SEVERITY BYTE;   /* OVERRIDES NORMAL ERROR SEVERITY */
    DECLARE FDCC$ERROR$TYPE ADDRESS;    /* HAS DATA ON DISK I/O ERRORS */

    /* USEFUL LITERALS */
    DECLARE WARNING LITERALLY '0',
            MESSAGE LITERALLY '1',
            ABORT   LITERALLY '2';

    DECLARE DISK$IO$ERROR   LITERALLY   '18H',
            DRIVE$NOT$READY LITERALLY   '1EH';

    DECLARE ISIS$HDR$BLK LITERALLY   '204H';


    DECLARE RTC LITERALLY '0FFH';   /* REAL TIME CLOCK */
    DECLARE BOOT LITERALLY '2';
    /* INPUT FROM RTC IS A BYTE. THE SECOND BIT FROM THE RIGHT
       CORRESPONDS TO THE BOOT SWITCH. IF THIS BIT IS 1 THE SWITCH IS
       ON, AND IF IT IS 0 THE  SWITCH IS OFF.
    */

    DECLARE MDSMON  LITERALLY   '0',
            BTSTRP  LITERALLY   '8';


    CI: PROCEDURE BYTE;
        GOTO 0F803H;
    END;

    RI: PROCEDURE BYTE;
        GOTO 0F806H;
    END;

    CO: PROCEDURE(C);
        DECLARE C BYTE;
        GOTO 0F809H;
    END;

    PO: PROCEDURE(C);
        DECLARE C BYTE;
        GOTO 0F80CH;
    END;

    LO: PROCEDURE(C);
        DECLARE C BYTE;
        GOTO 0F80FH;
    END;

    IOCHK: PROCEDURE BYTE;
        GOTO 0F815H;
    END;

    IOSET: PROCEDURE(C);
        DECLARE C BYTE;
        GOTO 0F818H;
    END;

    CSTS: PROCEDURE BYTE;
        GOTO 0F812H;
    END;


    
    DECLARE INITIO$BASE ADDRESS INITIAL(6), INITIO BASED INITIO$BASE BYTE;

    /*
       THE ERR PROCEDURE IS USED TO HANDLE ERROR CONDIITONS.
           AN ERROR MESSAGE IS ISSUED TO THE CONSOLE, WHICH FOR
           DISK ERRORS HAS EXTENDED CONTENT
       CONTROL THEN PASSES TO THE MDS MONITOR

       ERROR$TYPE IS THE ERROR NUMBER WHICH IDENTIFIES THE PARTICUALAR
              TYPE OF ERROR, SUCH AS DISK I/O ERROR
    */

    ERR: PROCEDURE(SEVERITY, ERROR$TYPE);
        DECLARE (SEVERITY, ERROR$TYPE, I, IMAX) BYTE;
        DECLARE PC BASED USER$STACK$PTR ADDRESS;
    DECLARE MSG1(8) BYTE INITIAL(CR, LF, 'ERROR '),
        MSG2(3) BYTE, /* ERROR NUMBER GOES HERE */
        MSG3(9) BYTE INITIAL(' USER PC '),
        MSG4(4) BYTE, /* USER PC IN HEX GOES HERE */
        MSG5(2) BYTE INITIAL(CR, LF),
        MSG6(5) BYTE INITIAL('FDCC='),
        MSG7(4) BYTE, /* FDCC ERROR DATA GOES HERE */
        MSG8(2) BYTE INITIAL(CR, LF);

        IF (SEVERITY := SEVERITY OR GLOBAL$SEVERITY) <> WARNING THEN
        DO;
            CALL NUMOUT(ERROR$TYPE, 10, 0, .MSG2, 3);
            CALL NUMOUT(PC,16,'0',.MSG4,4);
            CALL IOSET((IOCHK AND CMSK) OR (INITIO AND 3));
            IMAX = 25;  /* NUMBER OF CHARACTERS IN NORMAL ERROR MESSAGE */
            IF ERROR$TYPE = DISK$IO$ERROR THEN
            DO;
                IMAX = 36;
                CALL NUMOUT(FDCC$ERROR$TYPE, 16, '0', .MSG7, 4);
            END;
            DO I = 0 TO IMAX;
                CALL CO(MSG1(I));
            END;
        END;
        ELSE
        DO;
            USER$STATUS = ERROR$TYPE;
            STACKPTR = USER$STACK$PTR;
        END;
        IF SEVERITY >= ABORT THEN
        DO;
            IF DEBUG$TOGGLE THEN
                GOTO MDSMON;    /* EXIT VIA MONITOR */
            GOTO BTSTRP;        /* EXIT VAI SOFTWARE BOOTSTRAP */
        END;
    END;



    /*
       DISKIO PROVIDES ACCESS TO THE FDCC
       CONTROLLER 1 = BASE ADDRESS 78H (DRIVES 0, 1 FOR SD)
       CONTROLLER 2 = BASE ADDRESS 88H (DRIVES 2, 3 FOR SD)

       DRIVE: AN INTEGER 0-3, SPECIFYING THE DISK TO BE ACCESSED
       IOPB:  THE ADDRESS OF A PARAMETER BLOCK TO BE SENT TO THE
          FDCC CONTROLLER. THIS PARAMETER MUST BE SET UP
          AS IF IT WERE FOR DRIVE 0; IF 'DRIVE' SELECTS
          ANOTHER DRIVE, 'DISKIO' WILL SET ALL THE NECESSARY
          BITS

       THE CALLER PROVIDES A PARAMETER BLOCK SPECIFYING SOME
       VALID DISK OPERATION ON DRIVE 0 AND AN INTEGER DRIVE SELECT VALUE
       IN THIS BOOT CODE ONLY READ AND RECAL ARE USED
       THE PROCEDURE WAITS FOR THE CONTROLLER TO GO UNBUSY, THEN
       PERFORMS THE DESIRED ACTION. IN CASE OF A CONTROLLER ERROR,
       THE DISK DRIVE IS RECALIBRATED AND THE ACTION IS TRIED AGAIN.
       IF SUCCESSFUL COMPLETION CANNOT BE OBTAINED AFTER 'MAX$RETRIES'
       ATTEMPTS, A FATAL ERROR OCCURS, OTHERWISE A NORMAL RETURN IS MADE

    */
        DECLARE FDCC$STATUS$0   LITERALLY   '78H',
                FDCC$STATUS$1   LITERALLY   '88H',
                RESULT$TYPE$0   LITERALLY   '79H',
                RESULT$TYPE$1   LITERALLY   '89H',
                RESULT$BYTE$0   LITERALLY   '7BH',
                RESULT$BYTE$1   LITERALLY   '8BH',
                LOW$ADDRESS$0   LITERALLY   '79H',
                LOW$ADDRESS$1   LITERALLY   '89H',
                HIGH$ADDRESS$0  LITERALLY   '7AH',
                HIGH$ADDRESS$1  LITERALLY   '8AH';

        DECLARE MAX$RETRIES     LITERALLY   '10',
                DISK$DONE       LITERALLY   '4',
                READ$COMMAND    LITERALLY   '4',
                WRITE$COMMAND   LITERALLY   '6',
                RECALIBRATE     LITERALLY   '3';

        DECLARE IOCW    LITERALLY '0',
                IOINS   LITERALLY '1',
                NSEC    LITERALLY '2',
                TADR    LITERALLY '3',
                SADR    LITERALLY '4',
                BUFLO   LITERALLY '5',
                BUFHI   LITERALLY '6';


    DISKIO: PROCEDURE(DRIVE, IOPB);
        /* THIS PROCEDURE ISSUES THE IOPB TO THE DISK CONTROLLER, IN THE */
        /* CASE OF THE 8271 IT ALSO TRANSFERS THE DATA ON A BYTE BY BYTE BASIS */
        DECLARE DRIVE BYTE; /* DRIVE NUMBER: ASSUMES VALUE 0,1,2,3 */
        DECLARE IOPB ADDRESS;   /* POINTER TO THE PARAMATER BLOCK NAMED DCB */
        DECLARE DCB BASED IOPB (7) BYTE; 

        DECLARE TEMPA(0) ADDRESS, (TEMP2, TEMP1, JUNK) BYTE;

        /* RECALIBRATE COMMAND */
        DECLARE RECAL$PB(5) BYTE INITIAL(80H, RECALIBRATE, 0, 0, 0);

        DECLARE I BYTE;     /* INDEX VARIABLE IN FOR STATEMENTS */
        DECLARE IVAL BYTE;  /* INTERRUPT MASK VALUE */

        DISK$STAT: PROCEDURE BYTE; /* RETURN THE DISK DRIVE STATUS */
            IF ROR(DRIVE, 1) THEN    /* DRIVE 1 */
                RETURN INPUT(FDCC$STATUS$1);
            RETURN INPUT(FDCC$STATUS$0);
        END;


        R$TYPE: PROCEDURE BYTE; /* RETURN THE RESULT TYPE OF A DISK OPERATION */
            IF ROR(DRIVE, 1) THEN
                RETURN INPUT(RESULT$TYPE$1);
            RETURN INPUT(RESULT$TYPE$0);
        END;

        
        R$BYTE: PROCEDURE BYTE; /* RETURN THE REULT BYTE OF A DISK OPERATION */
            IF ROR(DRIVE, 1) THEN
                RETURN INPUT(RESULT$BYTE$1);
            RETURN INPUT(RESULT$BYTE$0);
        END;

        /*
           START$IO OUTPUTS THE ADDRESS OF THE IOPB TO THE DISK CONTROLLER
        */
        START$IO: PROCEDURE(IOPB);
            DECLARE IOPB ADDRESS;

            IF ROR(DRIVE, 1) THEN
            DO;
                OUTPUT(LOW$ADDRESS$1) = LOW(IOPB);
                OUTPUT(HIGH$ADDRESS$1) = HIGH(IOPB);
            END;
            ELSE
            DO;
                OUTPUT(LOW$ADDRESS$0) = LOW(IOPB);
                OUTPUT(HIGH$ADDRESS$0) = HIGH(IOPB);
            END;
        END;



        IVAL = INPUT(0FCH);
        OUTPUT(0FCH) = IVAL OR 2; /* PREVENT  REENTRANCY */

        RECAL$PB(IOINS) = RECALIBRATE;
        RECAL$PB(SADR) = 0;
        IF DRIVE THEN
        DO;
            DCB(IOINS) = DCB(IOINS) OR 30H;
            DCB(SADR) = DCB(SADR) OR 20H;
            RECAL$PB(IOINS) = RECALIBRATE OR 30H; 
            RECAL$PB(SADR) = 20H;
        END;
        
        DO I = 0 TO MAX$RETRIES;

            DO WHILE (DISK$STAT AND DISK$DONE) <> 0;
                TEMP1 = R$TYPE;
                TEMP1 = R$BYTE;
            END;
            /* IF DISK DRIVE NOT READY, GIVE FATAL ERROR */
            IF (DISK$STAT AND ((DRIVE AND 1) + 1)) = 0 THEN
                CALL ERR(ABORT, DRIVE$NOT$READY);

            CALL START$IO(IOPB);
            DO WHILE (DISK$STAT AND DISK$DONE) = 0; 
                ;
            END;
            TEMP1 = R$TYPE;
            IF (TEMP2 := R$BYTE) = 0 THEN
            DO;
                OUTPUT(0FCH) = IVAL;    /* RESTORE INTERRUPT 1 */
                RETURN;
            END;
            CALL START$IO(.RECAL$PB);
            DO WHILE (DISK$STAT AND DISK$DONE) = 0;
                ;
            END;
        END;
        FDCC$ERROR$TYPE = TEMPA;
        CALL ERR(ABORT, DISK$IO$ERROR);
    END;


    /*
     ASBIO: ACCOMPLISHES THE TRANSFER OF 128 BYTES OF DATA FROM THE DISK 
       COMMAND  MUST BE THE NUMERIC VALUE OF THE FDCC COMMAND
                DESIRED. (LITERALS 'READ$COMMAND' AND 'WRITE$COMMAND'
                EXIST FOR THE COMMON OPERATIONS.)
       DISK     THE DRIVE FROM WHICH TO READ
       BLOCK    DISKETTE BLOCK NUMBER, A TRACK NUMBER (0-76)
                IN THE HIGH ORDER 8 BITS AND A SECTORE NUMBER (1-26)
                IN THE LOW ORDER 8 BITS
       BUFFER$PTR   THE ADDRESS OF A 128 BYTE BUFFER IN RAM
    */
    ABSIO: PROCEDURE (COMMAND, DISK, BLOCK, BUFFER$PTR);
        DECLARE (COMMAND, DISK) BYTE, (BLOCK, BUFFER$PTR) ADDRESS;
        /* VALUE OF 'DISK'  MUST BE 0 - 1 */
        DECLARE DCB(10) BYTE INITIAL(80H);

        DCB(IOINS) = COMMAND;
        DCB(NSEC) = 1;   /* IF THIS VALUE CHANGES IN THE FUTURE, */
                /* THE 8271 DRIVER MUST BE CHANGED */
        DCB(TADR) = HIGH(BLOCK);
        DCB(SADR) = LOW(BLOCK);
        DCB(BUFLO) = LOW(BUFFER$PTR);
        DCB(BUFHI) = HIGH(BUFFER$PTR);
        CALL DISKIO(DISK, .DCB);
    END;

    ABS$READ: PROCEDURE(BLOCK, BUFFER);
        DECLARE (BLOCK, BUFFER) ADDRESS;

        CALL ABSIO(READ$COMMAND, A$DEVICE, BLOCK, BUFFER);
    END;

    ABS$WRITE: PROCEDURE(BLOCK, BUFFER);
        DECLARE (BLOCK, BUFFER) ADDRESS;

       CALL ABSIO(WRITE$COMMAND, A$DEVICE, BLOCK, BUFFER);
    END;

    /*

        ALDADR LOADS THE ABSOLUTE ISIS FILE INTO MEMORY
        HDRBLK - LOCATION OF ISIS FILE

        RETURNS - ADDRESS WHERE FILE IS LOADED
        THE FORMAT OF THE FILE IS BASICALLY THE CONTENT RECORDS
        FROM AN NORMAL ISIS EXECUTABLE WITH THE RECORD TYPE, SEGMENT ID AND CRC REMOVED
    */

    ALDADR: PROCEDURE(HDRBLK) ADDRESS;
        /* LOAD INTO MEMORY THE ABS LOAD FILE AT 'HDRBLK' */
        DECLARE HDRBLK ADDRESS;
        DECLARE BUF(128) BYTE, BUFPTR BYTE;
        DECLARE POINTERS(64) ADDRESS, PTRPTR BYTE;
        DECLARE LOADADR ADDRESS, TARGET BASED LOADADR BYTE;
        DECLARE LENGTH ADDRESS;

        DECLARE FLINK   LITERALLY   '1';    /* INDEXES INTO THE POINTERS ARRAY */

        L1B: PROCEDURE; /* LOAD 1 BYTE FROM BUFFER INTO MEMORY */
            TARGET = BUF(BUFPTR);   
            BUFPTR = BUFPTR + 1;
            LENGTH = LENGTH - 1;
            LOADADR = LOADADR + 1;
        END;

        G128B: PROCEDURE(BUFADR); /* GET 128 BYTES INTO BUFFER AT BUFADR */
            DECLARE BUFADR ADDRESS;

            IF (PTRPTR := PTRPTR + 1) = 64 THEN
            DO;
                IF POINTERS(FLINK) = 0 THEN
                    GOTO MDSMON;
                CALL ABSIO(READ$COMMAND, 0, POINTERS(FLINK), .POINTERS);
                PTRPTR = 2;
            END;
            IF POINTERS(PTRPTR) = 0 THEN
                GOTO MDSMON;
            CALL ABSIO(READ$COMMAND, 0, POINTERS(PTRPTR), BUFADR);
        END;

        G1B: PROCEDURE BYTE;    /* GET 1 BYTE */
            IF (BUFPTR AND 7FH) = 0 THEN
            DO;
                CALL G128B(.BUF);
                BUFPTR = 0;
            END;    
            BUFPTR = BUFPTR + 1;
            RETURN BUF(BUFPTR - 1);
        END;

        G2B: PROCEDURE ADDRESS; /* GET 2 BYTES */
            RETURN G1B + (256 * G1B);
        END;




        POINTERS(FLINK) = HDRBLK;   /* INITIALISZE G128B */
        PTRPTR = 63;
        BUFPTR = 0;

    START$LOADING$NEXT$RECORD:
        DO WHILE TRUE;
            LENGTH = G2B;
            LOADADR = G2B;
            IF LENGTH = 0 THEN
                RETURN LOADADR;
            DO WHILE BUFPTR <> 128;
                IF LENGTH > 0 THEN
                    CALL L1B;
                ELSE
                    GOTO START$LOADING$NEXT$RECORD;
            END;
            DO WHILE LENGTH >= 128;
                CALL G128B(LOADADR);
                LOADADR = LOADADR + 128;
                LENGTH = LENGTH - 128;
            END;
            
            BUFPTR = 0;
            IF LENGTH <> 0 THEN
            DO;
                CALL G128B(.BUF);
                DO WHILE LENGTH > 0;
                    CALL L1B;
                END;
            END;
        END;
        /* CANNOT REACH HERE !! */
    END; 


    T0BOOT:
    TEMP = INPUT(RESULT$TYPE$0);
    TEMP = INPUT(RESULT$BYTE$0);
    ENABLE;
    DO WHILE (INPUT(RTC) AND BOOT) <> 0;
        ;
    END;
    GLOBAL$SEVERITY = WARNING;
    DEBUG$TOGGLE = TRUE;
    START$ADDR = ALDADR(ISIS$HDR$BLK);
    CALL CONSOL(.MEMORY, .MEMORY, .USER$STATUS);
    CALL NUMOUT(VERSION$LEVEL, 16, 0, .SIGN$V, 2);
    CALL NUMOUT(EDIT$LEVEL, 16, 0, .SIGN$E, 2);
    CALL WRITE(0, .ISIS$SIGNON, 19, .USERSTATUS);
    CALL EXIT;


END;
EOF;
