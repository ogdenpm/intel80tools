isis40.pex
# common control characters
CONTROL$E	'5',
BELL		'7',
BS		'8',
CR		'0dh'
LF		'0ah'
CONTROL$P	'10h'
CONTROL$Q	'11h'
CONTROL$R	'12h'
CONTROL$S	'13h'
CONTROL$X	'18h'
CONTROL$Z	'1ah'
ESC		'1bh'
DELKEY		'7fh'

# boolean literals
BOOLEAN		'BYTE'
TRUE		'0ffh'
FALSE		'0'

# console literals
AFTN$CONSOL$IN	'11'
AFTN$CONSOL$OUT	'10'
READ$MODE	'1'
WRITE$MODE	'2'

# seek options
SEEK$RETURN	'0'
SEEK$BACKWARD	'1'
SEEK$ABS	'2'
SEEK$FORWARD	'3'
SEEK$EOF	'4'

# common types
DCB$T		'structure(iocw BYTE, ioins BYTE, nsec BYTE, tadr BYTE, sadr BYTE, buf ADDRESS)'

# error codes
OK	'0'	/* No error detected. */
NO$FREE$BUFFER	'1'	/* Insufficient space in buffer area for a required buffer. */
BAD$AFT$NO	'2'	/* AFTN does not specify an open file. */
AFT$FULL	'3'	/* Attempt to open more than 6 files simultaneously. */
BAD$PATH	'4'	/* Illegal pathname specification. */
BAD$DEVICE	'5'	/* Illegal or unrecognized device specification */
CANT$WRITE	'6'	/* Attempt to write to a file open for input. */
DISK$FULL	'7'	/* Operation aborted: insufficient disk space. */
CANT$READ	'8'	/* Attempt to read from a file open for output. */
DIRECTORY$FULL	'9'	/* No more room in disk directory. */
DIFFERENT$DISK	'10'	/* Pathnames do not specify the same disk. */
MULTIDEFINED	'11'	/* Cannot rename file; name already in use. */
ALREADY$OPEN	'12'	/* Attempt to open a file already open. */
NO$SUCH$FILE	'13'	/* No such file. */
WRITE$PROTECT	'14'	/* Attempt to open for writing or to delete or rename a write-protected file. */
ISIS$OVERWRITE	'15'	/* Attempt to load into ISIS-II area or buffer area. */	
BAD$LOAD$FORMAT	'16'	/* Illegal format record. */	
NON$DISK$FILE	'17'	/* Attempt to rename/delete a non-disk file. */	
BAD$COMMAND	'18'	/* Unrecognized system call. */	
NON$DISK$SEEK	'19'	/* Attempt to seek on a non-disk file. */	
LONG$BACK$SEEK	'20'	/* Attempt to seek backward past beginning of a file */	
CANT$RESCAN	'21'	/* Attempt to rescan a non-lined file. */	
BAD$ACCESS	'22'	/* Illegal ACCESS parameter to OPEN or access mode impossible for file specified. */	
NULL$FILENAME	'23'	/* No filename specified for a disk file. */		
DISK$IO$ERROR	'24'	/* Disk error (see below). */		
BAD$ECHO	'25'	/* Incorrect specification of echo file to OPEN */	
BAD$ATTRIB	'26'	/* Incorrect SWID argument in ATTRIB system call */		
BAD$SEEK$ARG	'27'	/* Incorrect MODE argument in SEEK system call. */		
NULL$EXTENSION	'28'	/* Null file extension. */
CONSOLE$EOF	'29'	/* End of file on console input. */
DRIVE$NOT$READY	'30'	/* Drive not ready. */
SEEK$ON$WRITE	'31'	/* Attempted seek on write-only (output) file. */
CANT$DELETE	'32'	/* Can't delete an open file. */
BAD$PARAMETER	'33'	/* Illegal system call parameter. */
BAD$RETSW	'34'	/* Bad RETSW argument to LOAD. */
SEEK$PAST$EOF	'35'	/* Attempt to extend a file opened for input by seeking past end-of-file */

WARNING		'0'
MESSAGE		'1'
ABORT		'2'
CMSK		'0fch'

# attributes
INVISIBLE$ATTRIBUTE	'1'
SYSTEM$ATTRIBUTE	'2'
WRITEP$ATTRIBUTE	'4'
FORMAT$ATTRIBUTE	'80h'

$file(aft.plm)
AFT$BOTTOM	'10'
AFT$CONSOLE	'11'
AFT$PROTECT	'12'
AFT$LAST	'17'
CI$AFT		'1'
CO$AFT		'0'
F0DEV		'0'
F1DEV		'1'
F2DEV		'2'
F3DEV		'3'
F4DEV		'4'
F5DEV		'5'
F6DEV		'6'
F7DEV		'7'
F8DEV		'8'
F9DEV		'9'
CIDEV		'27'
CODEV		'28'
BBDEV		'26'
AFT$T1		'empty BYTE, device BYTE, access BYTE, edit BYTE, lbuf ADDRESS'
AFT$T2		'dbuf ADDRESS, pbuf ADDRESS, data$ptr BYTE, i$no ADDRESS, ptr$ptr BYTE'
AFT$T3		'eofcnt BYTE, ptr$change BYTE, data$change BYTE, blk ADDRESS, blk$seq ADDRESS'
AFT$T4		'ptr$blk ADDRESS, hdr$blk ADDRESS, data$blk$count ADDRESS, dbuf$read BYTE'
AFT$T		'structure(AFT$T1, AFT$T2, AFT$T3, AFT$T4)'
a$access$p      A
a$blk$count$p   A
a$blk$seqno$p   A
a$data$blk$p    A
a$data$change$p A
a$data$ptr$p    A
a$dbuf$p        A
a$dbuf$read$p   A
a$dev$p         A
a$edit$p        A
a$empty$p       A
a$eof$data$ptr$p A
aft             "AFT$T"(18)
a$hdr$blk$p     A
a$i$no$p        A
a$lbuf$p        A
a$pbuf$p        A
a$ptr$blk$p     A
a$ptr$change$p  A
a$ptr$ptr$p     A
datum$base      A
pointer$base    A
aft$window      P(B slot$number)
get$aft$slot    PB
a$empty		B..a$empty$p
a$device	B..a$dev$p
a$access	B..a$access$p
a$edit		B..a$edit$p
a$dbuf          A..a$dbuf$p
a$lbuf		A..a$lbuf$p
a$pbuf          A..a$pbuf$p
a$data$ptr	B..a$data$ptr$p
a$i$no		A..a$i$no$p
a$ptr$ptr	B..a$ptr$ptr$p
a$eof$data$ptr	B..a$eof$data$ptr$p
a$ptr$change	B..a$ptr$change$p
a$data$change	B..a$data$change$p
a$blk$count	A..a$blk$count$p
a$blk$seqno	A..a$blk$seqno$p
a$ptr$blk	A..a$ptr$blk$p
a$hdr$blk	A..a$hdr$blk$p
a$data$blk	A..a$data$blk$p
a$dbuf$read	B..a$dbuf$read$p

BLINK		'0'
FLINK		'1'
links		A(64)..pointer$base

$file(alloc.plm)
current$bitmap  B
sectorsTable    BS
tracksTable     BS
free$block      P(B diskNum,A trackSector)
get$block       P(B diskNum)A
map$read        P
map$write       P(B diskNum)
bitmapByte      B..bitmapByte$p

$file(attrib.plm)
attrib          P(A file$ptr,A swid,"BOOLEAN" value)

$file(buffer.plm)
buffer$table    BS
clear$buf       P(A buf$address)
get$buf         PA
pack$aft$buf    PA
return$buf      P(A buf$address)

$file(close.plm)
close           P(B aftn)

$file(consol.plm)
alt$cidev       B
cold$cidev      B
cur$consol$in   BS
cur$consol$out  BS
console         P(A infile,A outfile)
whocon          P(B aftn,A bufferloc)

$file(delete.plm)
del             P(B disknum)
delete          P(A pathname)
dlook$pn        P

$file(direct.plm)
DIRECT$T1	'empty BOOLEAN, file(6) BYTE, ext(3) BYTE, attrib BYTE'
DIRECT$T2	'eof$count BYTE, blk ADDRESS, hdr$blk ADDRESS'
DIRECT$T	'structure(DIRECT$T1, DIRECT$T2)'
direct          "DIRECT$T"
direct$i$no     A
dirPtr          A
#dnum            A
fndFre          B
inoPtr          A
dir$clos        P(B aftn)
dlook           P(A fn)"BOOLEAN"
#fndDir          P(A fname,A datum)B

$file(disk2.asm)
dk$stat		PB
r$type		PB
r$byte		PB
strt$io		P(A iopb)

$file(diskio.asm)
absread		'abs$rd'
abswrite	'abs$wr'
CMD$RECAL	'3'
CMD$READ	'4'
CMD$WRITE	'6'
absio		P(B command,B disk,A block,A buffer$ptr)
abs$rd		P(A block, A buffer$ptr)
abs$wr		P(A block, A buffer$ptr)
dk$cf$tb	B(10)
rdy$msk		B(10)
unit$mp		B(10)
dk$ct$tb	B(10)
dkcont		B
track		B
sector		B
diskio		P(B drive, A iopb)


$file(error.plm)
c$dk$sat        A
debug$Toggle    B
errdrv          B
global$severity B
abortx          P(B errcode)
err             P(B severity,B error$type)
warn            P(B errcode)

$file(exit.plm)
# rename of plm to asm 6 char name
close$all	'clsall'
cli             BS
clsall          P(B aft$start)
exit            P

$file(fndrir.asm)
fnDir		P(A fname,A datum)B
dnum		A

$file(isis.plm)
userStatus$p    A
isis            P(B command,A parameter$block)
userStatus      A..userStatus$p

$file(load.plm)
R$CONTENT       '6'
R$RELOC         '22H'
load            P(A pathname,A bias,A retsw,A entry$p)

$file(loc62.asm)
isis$E		B
vec0E		A
CI		PB
CO		P(B val)
CSTS		PB
IOCHK		PB
IOSET		P(B val)
isis40		P(B command,A parameter$block)
LO		P(B val)
PO		P(B val)
RI		PB
vec0B		A
usrSP		A
sysStk		BS
usrStk		B

$file(reboot.plm)
reboot		P


$file(memck.asm)
memck		PA

$file(open.plm)
open            P(A pathname,A access$mode,A lined$aft)B

$file(path.plm)
pn              BS
pn2             BS
chk$pn$disk$file P(A filename)
chk$write$protect P
path            P(A pathname,A pn$p)B
unpath          P(A pathname$p,A pn$p)
write$dir$entry P
xpath           P(A p1,A p2)

$file(rename.plm)
rename          P(A old$file,A new$file)

$file(rescan.plm)
rescan          P(B aftn)

$file(rw1.asm)
usrSys		P(A buffer$p,A buffer,A datum$base)
sysUsr		P(A buffer$p,A buffer,A datum$base)

$file(rw.plm)
ACCESS$READ     '1'
MAXLL           '122'
adp$dif         B
datapp          A
adjust$eof      P
chk$eof         P
lined           P(B aftn,A buffer,A count,A actual$p)
read            P(B aftn,A buffer,A count,A actual$p)
write           P(B aftn,A buffer,A count)

$file(seek.plm)
rewind          P
save$data$blk   P
save$pointer$block P
seek            P(B aftn,A mode,A blockptr,A byteptr)

$file(jmpto.asm)
jmpto		P(A entry,A stack)

$file(trap0b.asm)
trap0b		P

$file(trap.asm)
trap		P
loc62.asm
	name loc62
	public	vec0B
	public	vec0E
	public	isis40		; isis cseg
	public	usrSP, sysStk, usrStk
	public	IOCHK		; bios entry points
	public	IOSET
	public	CI
	public	RI
	public	CO
	public	PO
	public	LO
	public	CSTS

	extrn	isis
	extrn	reboot

	ASEG
	org 0bh
vec0B:	ret			; trap routine ?
	db	0
	ds	1
vec0E:	dw	0

CI	equ	0F803H
RI	equ	0F806H
CO	equ	0F809H
PO	equ	0F80CH
LO	equ	0F80FH
CSTS	equ	0F812H
IOCHK	equ	0F815H
IOSET	equ	0F818H


	CSEG			; this will be located @3Eh
	dw	4		; isis version?
isis40:	jmp	isis

	DSEG
usrSP:	ds	2
	db	0c7h,0c7h,0c7h,0c7h,0c7h
	db	0c7h,0c7h,0c7h,0c7h,0c7h
	db	0c7h,0c7h,0c7h,0c7h,0c7h
	db	0c7h,0c7h,0c7h,0c7h,0c7h
	db	0c7h,0c7h,0c7h,0c7h,0c7h
	db	0c7h,0c7h,0c7h,0c7h,0c7h
	db	0c7h,0c7h,0c7h,0c7h,0c7h
	db	0c7h,0c7h,0c7h,0c7h,0c7h
sysstk:
	ds	16
usrstk:

	end
reboot.plm
reboot: do;
$include(reboot.ipx)

declare bootLd DCB$T data(80h, 4, 26, 0, 1, .MEMORY);

reboot: procedure public interrupt 1;
	output(0fch) = 0fch;
	vec0B = 0c9h;		/* return instruction */
	stackptr = .sysStk;
	call close$all(AFT$BOTTOM);
	call diskio(cli(2) and 0fh, .bootLd);
	call jmpto(.MEMORY, STACKPTR);
end;

end;
eof
isis.plm
isis:
do;
$include(:f0:isis.ipx)

DECLARE copyRight(*) BYTE DATA('(C)1979INTELCORP'),
	retParamIdx(*) BYTE DATA( 5, 2, 2, 5, 4, 5, 5, 3, 3, 1, 4, 2, 2, 3, 3), 
	paramType(5) ADDRESS DATA(1000111110001010B,	/* bit set if parameter needs to check for */
				  1111001100111110B,	/* address below MEMORY (3000H) */
				  1100001101000000B,
				  0000100001110000B,
				  0000000011010010B);


DECLARE userStatus$p ADDRESS PUBLIC;
DECLARE userStatus BASED userStatus$p ADDRESS;

isis: PROCEDURE(command, parameter$block) PUBLIC;
	DECLARE command BYTE, parameter$block ADDRESS;
	DECLARE param BASED parameter$block (5) ADDRESS;
	DECLARE i BYTE;
	DECLARE sysParam(6) ADDRESS;	/* parameters - parameter 0 not used */
	DECLARE param1 ADDRESS AT (.sysParam(1)),
		param2 ADDRESS AT (.sysParam(2)),
		param3 ADDRESS AT (.sysParam(3)),
		param4 ADDRESS AT (.sysParam(4)),
		param5 ADDRESS AT (.sysParam(5));

	aft$check: PROCEDURE;
		DECLARE aftn ADDRESS AT (.sysParam(1));
		aftn = aftn + AFT$BOTTOM;
		if aftn >= AFT$LAST+1 OR aftn < AFT$BOTTOM OR aft(aftn).empty then
			call warn(BAD$AFT$NO);
	end;

	usrSP = STACKPTR;
	STACKPTR = .usrStk;	/* defined in loc62.asm */
	if command = 'D' then
		call diskio(param(0), param(1));
	else
	do;
		do i = 0 to 4;
			if shr(paramType(i), command + 1) then /* check if an address parameter */
				if (param(i) < .MEMORY) then
					call abortx(BAD$PARAMETER);
			sysParam(i+1) = param(i);
		end;

		userStatus$p = sysParam(retParamIdx(command));	/* get the return status address */
		userStatus = 0;
		global$severity = 0;
		if command >= 15 then		/* MAX$COMMAND */
			call abortx(BAD$COMMAND);
		do case command;
		do;		/* 0 - OPEN */
			DECLARE aftn$value BASED param1 ADDRESS;
			aftn$value = 0FFh;
			aftn$value = open(param2, param3, param4);	/* file, access, mode */
		end;
		do;		/* 1 - CLOSE */
			call aft$check;
			if param1 >= AFT$PROTECT then			/* aftn */
				call close(param1); 
		end;
		call delete(param1);	/* 2 - DELETE - file */
		do;			/* 3 - READ */
			call aft$check;
			if aft(param1).edit = 0 then
				call read(param1, param2, param3, param4);	/* aftn, buffer, count, actual */
			else
				call lined(param1, param2, param3, param4);	/* aftn, buffer, count, actual */
		end;
		do;			/* 4 - WRITE */
			call aft$check;
			call write(param1, param2, param3);	/* aftn, buffer, count */
		end;
		do;			/* 5 - SEEK */
			call aft$check;
			call seek(param1, param2, param3, param4);	/* aftn, mode, blockp, bytep */
		end;
		call load(param1, param2, param3, param4);	/* 6 - SEEK - file, base, retsw, entry */
		call rename(param1, param2);		/* 7 - RENAME - file1, file2 */
		call console(param1, param2);		/* 8 - CONSOLE - file1, file2 */
		call exit;				/* 9 - EXIT */
		call attrib(param1, param2, param3);	/* 10 - ATTRIB - file, swid, swvalue */
		do;			/* 11 - RESCAN */
			call aft$check;
			call rescan(param1);		/* aftn */
		end;
		call err(MESSAGE, param1);	/* 12 - ERROR - MESSAGE, errnum */ 
		call whocon(param1, param2);	/* 13 - WHOCON - aftn, buffer */
		do;			/* 14 - PATH */
			DECLARE devNo BASED param2 BYTE;
			userStatus = path(param1, param2);	/* file, buffer */
			if devNo >= AFT$BOTTOM then		/* fix up internal to published device numbers */
				devNo = devNo - 4;
			else if devNo >= F6DEV AND devNo <= F9DEV then
				if dk$cf$tb(0) = 4 then	/* hard disk */
					devNo = devNo + 19;
				else 
					userStatus = BAD$PATH;
		end;
		end;
	end;
	STACKPTR = usrSP;
end;
end;
eof

aft.plm
aft:
do;

$include(:f0:aft.ipx)

DECLARE	aft$current BYTE INITIAL(0ffh);
DECLARE	pointer$base ADDRESS PUBLIC,
	datum$base ADDRESS PUBLIC,
	a$empty$p ADDRESS PUBLIC,
	a$dev$p ADDRESS PUBLIC,
	a$access$p ADDRESS PUBLIC,
	a$edit$p ADDRESS PUBLIC,
	a$lbuf$p ADDRESS PUBLIC,
	a$dbuf$p ADDRESS PUBLIC,
	a$data$ptr$p ADDRESS PUBLIC,
	a$i$no$p ADDRESS PUBLIC,
	a$pbuf$p ADDRESS PUBLIC,
	a$ptr$ptr$p ADDRESS PUBLIC,
	a$eof$data$ptr$p ADDRESS PUBLIC,
	a$ptr$change$p ADDRESS PUBLIC,
	a$data$change$p ADDRESS PUBLIC,
	a$blk$count$p ADDRESS PUBLIC,
	a$blk$seqno$p ADDRESS PUBLIC,
	a$ptr$blk$p ADDRESS PUBLIC,
	a$hdr$blk$p ADDRESS PUBLIC,
	a$data$blk$p ADDRESS PUBLIC,
	a$dbuf$read$p ADDRESS PUBLIC;

DECLARE aft(18) STRUCTURE (
		empty	BYTE,
		device	BYTE,
		access	BYTE,
		edit	BYTE,
		lbuf	ADDRESS,
		dbuf	ADDRESS,
		pbuf	ADDRESS,
		data$ptr BYTE,
		i$no	ADDRESS,
		ptr$ptr	BYTE,
		eofcnt	BYTE,
		ptr$change BYTE,
		data$change BYTE,
		blk ADDRESS,
		blk$seq	ADDRESS,
		ptr$blk	ADDRESS,
		hdr$blk	ADDRESS,
		data$blk$count ADDRESS,
		dbuf$read BYTE) PUBLIC INITIAL(
			0, 0, 3, 0, 0, 0, 0, 80h, 0, 0, 80h, 0, 0, 19h, 0, 101h, 101h, 102h, 0,
			0, 1, 3, 0, 0, 0, 0, 80h, 0, 0, 80h, 0, 0, 19h, 0, 101h, 101h, 102h, 0,
			0, 2, 3, 0, 0, 0, 0, 80h, 0, 0, 80h, 0, 0, 19h, 0, 101h, 101h, 102h, 0,
			0, 3, 3, 0, 0, 0, 0, 80h, 0, 0, 80h, 0, 0, 19h, 0, 101h, 101h, 102h, 0,
			0, 4, 3, 0, 0, 0, 0, 80h, 0, 0, 80h, 0, 0, 19h, 0, 101h, 101h, 102h, 0,
			0, 5, 3, 0, 0, 0, 0, 80h, 0, 0, 80h, 0, 0, 19h, 0, 101h, 101h, 102h, 0,
			0, 6, 3, 0, 0, 0, 0, 80h, 0, 0, 80h, 0, 0, 19h, 0, 101h, 101h, 102h, 0,
			0, 7, 3, 0, 0, 0, 0, 80h, 0, 0, 80h, 0, 0, 19h, 0, 101h, 101h, 102h, 0,
			0, 8, 3, 0, 0, 0, 0, 80h, 0, 0, 80h, 0, 0, 19h, 0, 101h, 101h, 102h, 0,
			0, 9, 3, 0, 0, 0, 0, 80h, 0, 0, 80h, 0, 0, 19h, 0, 101h, 101h, 102h, 0,
			0FFh, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0FFh, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0FFh, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0FFh, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0FFh, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0FFh, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0FFh, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0FFh, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);			

DECLARE a$dbuf BASED a$dbuf$p ADDRESS,
	a$pbuf BASED a$pbuf$p ADDRESS;


aft$window: PROCEDURE(slot$number) PUBLIC;
	DECLARE slot$number BYTE;

	if aft$current <> slot$number then
	do;	
		a$empty$p = .aft(aft$current := slot$number).empty;
		a$dev$p = a$empty$p + 1;
		a$access$p = a$dev$p + 1;
		a$edit$p = a$access$p + 1;
		a$lbuf$p = a$edit$p + 1;
		a$data$ptr$p = a$lbuf$p + 6;
		a$i$no$p = a$data$ptr$p + 1;
		a$ptr$ptr$p = a$i$no$p + 2;
		a$eof$data$ptr$p = a$empty$p + 14;
		a$ptr$change$p = a$eof$data$ptr$p + 1;
		a$data$change$p = a$ptr$change$p + 1;
		a$blk$count$p = a$data$change$p + 1;
		a$blk$seqno$p = a$blk$count$p + 2;
		a$ptr$blk$p = a$blk$seqno$p + 2;
		a$hdr$blk$p = a$ptr$blk$p + 2;
		a$data$blk$p = a$hdr$blk$p + 2;
		a$dbuf$read$p = a$data$blk$p + 2;
	end;
	a$dbuf$p = .aft(slot$number).dbuf;
	a$pbuf$p = a$dbuf$p + 2;
	pointer$base = a$pbuf;
	datum$base = a$dbuf;

end;


get$aft$slot: PROCEDURE BYTE PUBLIC;
	DECLARE i BYTE;

	do i = AFT$BOTTOM to AFT$LAST;
		if aft(i).empty then
			return i;
	end;
	call abortx(AFT$FULL);
end;
end;
eof;

attrib.plm
attrib:
do;
	
$include(:f0:attrib.ipx)

attrib:	PROCEDURE(file$ptr, swid, value) PUBLIC;
	DECLARE (file$ptr, swid) ADDRESS;
	DECLARE value BOOLEAN;
	DECLARE mask(*) BYTE DATA (INVISIBLE$ATTRIBUTE,
                                   SYSTEM$ATTRIBUTE,
                                   WRITEP$ATTRIBUTE,
                                   FORMAT$ATTRIBUTE);

	if swid > 3 then
		call warn(BAD$ATTRIB);
	call chk$pn$disk$file(file$ptr);
	call dlook$pn;
	direct.attrib = direct.attrib and (not mask(low(swid)));
	if value then
		direct.attrib = direct.attrib or mask(low(swid));
	call dir$clos(pn(0));
end;
end;
eof;

close.plm
close:
do;
$include(close.ipx)



DECLARE	caseMap(*) BYTE DATA (0,0,0,0,0,0,0,0,0,0,	/* F0-F9 */
			      1,2,1,2,1,2,1,1,1,1,	/* TI, TO, VI, VO, I1, O1, TR, HR, T1, T2 */
			      3,3,3,3,4,4,1,1,1);	/* TP, HP, P1, P2, LP, L1, BB, CI, CO */

DECLARE	t$blk	ADDRESS,
	t$eof	BYTE,
	zero	ADDRESS INITIAL(0),
	bytes	ADDRESS INITIAL(0);

close: PROCEDURE(aftn) PUBLIC;
	DECLARE aftn BYTE;
	DECLARE i ADDRESS;

	call aft$window(aftn);
	if a$empty then
		return;
	if a$edit <> 0 then
		call return$buf(a$lbuf);
	do case caseMap(a$device);
		do;	/* 0 - disk */
			call save$data$blk;
			call save$pointer$block;
			call return$buf(a$pbuf);
			call return$buf(a$dbuf);
			if a$access >= 2 then
			do;
				call adjust$eof;
				t$eof = a$eof$data$ptr;
				t$blk = a$blk$count;
				bytes = a$i$no * 16;
				call map$write(a$device);
				aft(a$device).dbuf = a$dbuf;		/* let device use returned buffers */
				aft(a$device).pbuf = a$pbuf;
				call aft$window(a$device);
				call rewind;		/* get to dir header */
				call seek(a$device, SEEK$ABS, .zero, .bytes);	/* seek to file entry */
				call read(a$device, .direct, 16, .i);		/* read the dir entry */
				direct.eof$count = t$eof;
				direct.blk = t$blk;
				a$data$ptr = a$data$ptr - DOUBLE(16);
				call dir$clos(a$device);
			end;
		end;
		;	/* 1 */
		;	/* 2 */
		do i = 0 to 119;	/* 3 output 120 nulls */
			call write(aftn, .(0), 1);
		end;
		;	/* 4 */
	end;
	aft(aftn).empty = TRUE;
end;	
end;
eof
consol.plm
consol:
DO;
$include(consol.ipx)

DECLARE cur$consol$in  (12) BYTE PUBLIC,
	cur$consol$out (12) BYTE PUBLIC;

DECLARE	cold$consol$in(5)  BYTE INITIAL(':XI: '),
	cold$consol$out(5) BYTE INITIAL(':XO: ');

DECLARE	cold$start$flag BOOLEAN INITIAL (TRUE);

DECLARE (cold$cidev, alt$cidev) BYTE PUBLIC;

console: PROCEDURE(infile, outfile) PUBLIC;
	DECLARE (infile, outfile) ADDRESS;
	DECLARE instring based infile BYTE,
		outstring based outfile BYTE;
	DECLARE temp BYTE;
	DECLARE tdrv(2) BYTE DATA ('TV');	/* T or V is 1st letter of device name */
	DECLARE initio BYTE AT (6);

	if cold$start$flag then
	do;
	  cold$consol$in(1), cold$consol$out(1) = tdrv(initio and 1);
	  infile = .cold$consol$in;
	  outfile = .cold$consol$out;
	end;
	
	global$severity = ABORT;
	call xpath(outfile, .pn);
	if pn(0) <> CODEV then
	do;
	  call close(AFTN$CONSOL$OUT);
	  temp = open(outfile, WRITE$MODE, FALSE);
	  call xpath(outfile, .cur$consol$out);
	end;
	call xpath(infile, .pn);
	if pn(0) <> CIDEV then 
	do;
	  call close(AFTN$CONSOL$IN);
	  temp = open(infile, READ$MODE, 100h);
	  if cold$start$flag then
	    cold$cidev = aft(AFTN$CONSOL$IN).device;
	  alt$cidev = cold$cidev;
	  call xpath(infile, .cur$consol$in);
	end;
	cold$start$flag = FALSE;
end;


whocon:	PROCEDURE(aftn, bufferloc) PUBLIC;
	DECLARE aftn BYTE;
	DECLARE bufferloc ADDRESS;
	DECLARE nameloc ADDRESS;

	nameloc = .cur$consol$out;
	if aftn then
	do;
	  if (aftn := aft(AFTN$CONSOL$IN).device) <> cur$consol$in(0) then
	    nameloc = .aftn;
	  else
	    nameloc = .cur$consol$in;
	end;
	call unpath(nameloc, bufferloc);
end;
end;
eof
delete.plm
delete:
DO;
$include(delete.ipx)

dlook$pn: PROCEDURE PUBLIC;
    if not dlook(.pn) then
	call warn(NO$SUCH$FILE);
end;

DECLARE i BYTE;		/* shared temp counter */

del: PROCEDURE(disknum) PUBLIC;
    DECLARE disknum BYTE;
    DECLARE blockno ADDRESS DATA (0);
    DECLARE byteno ADDRESS DATA(16 /* size(DIRECT) */);
    DECLARE temp ADDRESS;
    DECLARE buf based TEMP (64) ADDRESS;

    /* internal delete routing
	disknum = F0DEV .. F9DEV
	direct must contain the directory entry for an existing file or disk.
	aft slot for the appropriate directory must have buffers;
	and these buffers must be setup for directory reading and
	writing. These buffers will be clobbered
    */


     direct.empty = TRUE;
     call dir$clos(disknum);
     call seek(disknum, 1, .blockno, .byteno);	/* save location of directory entry */
     temp = a$dbuf;	/* temp -> a buffer we not exists based a$dbuf$p */
     do while direct.hdr$blk <> 0;
	call free$block(disknum, direct.hdr$blk);
	call absio(CMD$READ, disknum, direct.hdr$blk, temp);
	direct.hdr$blk = buf(FLINK);
	do i = 2 to 63;
	    if buf(i) <> 0 then
		call free$block(disknum, buf(i));
	end;
     end;
     call absio(CMD$READ, disknum, a$data$blk, a$dbuf);	/* last 2 based vars */
     call map$write(disknum);
end;


delete: PROCEDURE(pathname) PUBLIC;
	DECLARE pathname ADDRESS;

	call chk$pn$disk$file(pathname);
	call dlook$pn;
	call chk$write$protect;
	do i = AFT$BOTTOM to AFT$LAST;
	    call aft$window(i);
	    if (not a$empty) and (a$device = pn(0)) and (a$i$no = direct$i$no) then
		call warn(CANT$DELETE);	
	end;
	call del(pn(0));
end;
end;
eof
diskio.plm
diskio: do;
$include(diskio.ipx)

DECLARE CMD$RECAL   LITERALLY   '3';
DECLARE CMD$READ    LITERALLY   '4';
DECLARE CMD$WRITE   LITERALLY   '6';
DECLARE DD$TYPE     LITERALLY   '1',
        SD$TYPE     LITERALLY   '2',
	ISD$TYPE    LITERALLY   '3',
	HD$TYPE     LITERALLY	'4';

DECLARE MAX$RETRIES LITERALLY   '10';

DECLARE rcal$pb STRUCTURE(iocw BYTE, ioins BYTE, nsec BYTE, tadr BYTE, sadr BYTE)
		          INITIAL(80h, CMD$RECAL, 1, 0, 0);
DECLARE absdcb DCB$T INITIAL(80h, 0, 1, 0, 0, 0);
DECLARE dk$cf$tb(10) BYTE PUBLIC,
        rdy$msk(10) BYTE PUBLIC,
        unit$mp(10) BYTE PUBLIC,
        dk$ct$tb(10) BYTE PUBLIC,  /* disk controller table */
        dkcont BYTE PUBLIC,
        track BYTE PUBLIC,
        sector BYTE PUBLIC;



 diskio: PROCEDURE(drive, iopb) PUBLIC;
     DECLARE drive BYTE, iopb ADDRESS;
     DECLARE temp ADDRESS, (temp2, temp1) BYTE at(.temp);
     DECLARE dcb BASED iopb DCB$T;
     DECLARE i BYTE,
             diskHW BYTE,
             realTk ADDRESS,
             ival BYTE,
             sd$drv BYTE;

     track = dcb.tadr;
     sector = dcb.sadr;

     ival = input(0fch);
     output(0fch) = ival or 2;

     dkcont = dk$ct$tb(drive);
     sd$drv = FALSE;
     diskHW = dk$cf$tb(drive);
     if diskHW = SD$TYPE AND (1 = 1 AND drive) then    /* SD disk (Not ISD) & odd numbered drive */
     do;
         sd$drv = TRUE;
         dcb.sadr = dcb.sadr OR 20h;     /* set selector flag */
     end;
     if diskHW = 4 then  /* hard disk */
     do;
         realTk = DOUBLE(dcb.tadr) * 2;
         if dcb.sadr > 72 then   /* then map to odd track number */
         do;
             realTk = realTk + 1;
             dcb.sadr = dcb.sadr - 72;
         end;
         if dcb.sadr < 37 then
             dcb.ioins = dcb.ioins OR 8; /* select head */
         else
             dcb.sadr = dcb.sadr - 36;
         if realTk > 255 then
             dcb.sadr = dcb.sadr + 80h;  /* track extension bit */
         dcb.tadr = realTk;  
     end;
     dcb.ioins = dcb.ioins OR unit$mp(drive);
     do i = 0 to MAX$RETRIES;    /* 0-10 */
         do while (dk$stat AND 4) <> 0;
             temp1 = r$type; 
             temp1 = r$byte;
         end;
         if (dk$stat AND rdy$msk(drive)) = 0 then
             call abortx(DRIVE$NOT$READY);
         call strt$io(iopb);
         temp1 = r$type;
         if (temp2 := r$byte) = 0 then
         do;
             output(0fch) = ival;
             return;
         end;
         if sd$drv then
             rcal$pb.sadr = rcal$pb.sadr OR 20h;
         rcal$pb.ioins = rcal$pb.ioins OR unit$mp(drive);
         call strt$io(.rcal$pb);
     end;
     errDrv = drive;
     vec$0E, c$dk$sat = temp;
     output(0fch) = ival;
     call trap0B;
     output(0fch) = ival OR 2;
     call abortx(DISK$IO$ERROR);
 end;

absio: PROCEDURE(cmd, disk, block, buffer)  PUBLIC;
     DECLARE (cmd, disk) BYTE, (block, buffer) ADDRESS;
     absdcb.ioins = cmd;
     absdcb.tadr = high(block);
     absdcb.sadr = low(block);
     absdcb.buf = buffer;
     call diskio(disk, .absdcb);
end;

abs$rd: PROCEDURE(block, buffer) PUBLIC;
     DECLARE (block, buffer) ADDRESS;
     call absio(CMD$READ, a$device, block, buffer);
end;

abs$wr: PROCEDURE(block, buffer) PUBLIC;
     DECLARE (block, buffer) ADDRESS;
     call absio(CMD$WRITE, a$device, block, buffer);
end;
end;
eof

error.plm
error:
do;
$include(error.ipx)


DECLARE	pad ADDRESS,	/* padding to align to isis.bin */
	debug$Toggle BYTE PUBLIC,
	global$severity BYTE PUBLIC,
	c$dk$sat ADDRESS PUBLIC;

DECLARE	msg1(7) BYTE INITIAL(CR, LF, 'ERROR'),
	msg2(4) BYTE, /* error number goes here */
	msg3(9) BYTE INITIAL(' USER PC '),
	msg4(4) BYTE, /* user pc in hex goes here */
	msg5(9) BYTE INITIAL(CR, LF, 'STATUS='),
	msg6(4) BYTE, /* drive status goes here */
	msg7(5) BYTE INITIAL(CR, LF, 'D= '),
	errdrv	BYTE PUBLIC, /* drive goes here */
	msg9(3) BYTE INITIAL(' T='),
	msg10(1) BYTE,	/* track goes here */
	msg11(3) BYTE INITIAL('   '),
	msg12(3) BYTE INITIAL(' S='),
	msg13(1) BYTE,	/* sector goes here */
	msg14(5) BYTE INITIAL('   ', CR, LF);


DECLARE	initio BYTE AT (6);

err: PROCEDURE(severity, error$type) PUBLIC;
	DECLARE (severity, error$type, i, imax) BYTE;
	DECLARE pc BASED usrSP ADDRESS;

	num: PROCEDURE(value, base, bufaddr);
		DECLARE value ADDRESS, base BYTE, bufaddr ADDRESS;
		DECLARE buf based bufaddr(4) BYTE;
		DECLARE (div, digit) ADDRESS, (i, asciiOffset) BYTE;
		do i = 1 to 4;
			asciiOffset = '0';
			div = value / base;
			digit = value - div * base;
			if digit > 9 then
				asciiOffset = '7';
			buf(4 - i) = digit + asciiOffset;
			value = div;
		end;
		do i = 0 to 2;
			if buf(i) = '0' then
				buf(i) = ' ';
			else
				return;
		end;
	end;


	if (severity := severity or global$severity) <> WARNING then	/* b55 */
	do;
		call num(error$type, 10, .msg2);
		call num(pc, 16, .msg4);	
		call ioset((iochk AND CMSK) OR (initio AND 3));
		imax = 25;	/* number of characters in normal error message */
		if error$type = DISK$IO$ERROR then	/* B2f */
		do;
			if high(c$dk$sat) <> 0 then
				c$dk$sat = 128;
			imax = 58;
			call num(c$dk$sat, 16, .msg6);
			errdrv = errdrv or '0';	/* convert drive to ascii number */
			call num(track, 10, .msg10);
			call num(sector, 10, .msg13);
		end;
		do i = 0 to imax;
			call co(msg1(i));
		end;
	end;
	else
	do;
		userStatus = error$type;
		STACKPTR = usrSP;
	end;
	if severity >= ABORT then
	do;
		if debug$toggle then
			call trap;	/* trap to monitor */
		call reboot;
	end;
end;




abortx: PROCEDURE(errcode) PUBLIC;
	DECLARE errcode BYTE;
	call err(ABORT, errcode);
end;

warn: PROCEDURE(errcode) PUBLIC;
	DECLARE errcode BYTE;
	call err(WARNING, errcode);
end;

end;
eof;

exit.plm
exit:
do;
$include(exit.ipx)

DECLARE cli(*) BYTE PUBLIC INITIAL(':F0:ISIS.CLI ');

close$all: PROCEDURE(aft$start) PUBLIC;
	DECLARE aft$start BYTE;
	DECLARE i BYTE;

	do i = aft$start to AFT$LAST;
		call close(i);
	end;
end;

exit: PROCEDURE PUBLIC;

	vec0B = 0c9H;	/* return instruction */
	call close$all(12);	/* aft$prot? */
	call map$write(current$bitmap);
	current$bitmap = 0ffh;
	global$severity = ABORT;
	call load(.cli, 0, 1, 0);
end exit;
end;
eof

load.plm
load:
do;
$include(load.ipx)

DECLARE	R$MODHDR	LITERALLY	'2',
	R$MODEND	LITERALLY	'4',
	R$CONTENT	LITERALLY	'6',
	R$LINENO	LITERALLY	'8',
	R$EOF		LITERALLY	'0EH',
	R$ANCESTOR	LITERALLY	'10H',
	R$LOCALS	LITERALLY	'12H',
	R$PUBLICS	LITERALLY	'16H',
	R$EXTNAMES	LITERALLY	'18H',
	R$EXTREF	LITERALLY	'20H',
	R$RELOC		LITERALLY	'22H',
	R$INTERSEG	LITERALLY	'24H',
	R$LIBLOCS	LITERALLY	'26H',
	R$LIBNAMES	LITERALLY	'28H',
	R$LIBDICT	LITERALLY	'2AH',
	R$LIBHDR	LITERALLY	'2CH',
	R$COMDEF	LITERALLY	'2EH';

load: PROCEDURE(pathname, bias, retsw, entry$p) PUBLIC;
	DECLARE (pathname, bias, retsw, entry$p) ADDRESS;
	DECLARE entry BASED entry$p ADDRESS;
	DECLARE (aftn, i, retsw$b) BYTE;
	DECLARE record STRUCTURE(type BYTE, length ADDRESS);
	DECLARE modend STRUCTURE(modtype BYTE, segid BYTE, load$addr ADDRESS);
	DECLARE content STRUCTURE(segid BYTE, load$addr ADDRESS) AT (.modend);
	DECLARE checksum BYTE AT (.modend); 
	DECLARE actual ADDRESS, pad ADDRESS;
	DECLARE blockno ADDRESS, user$bottom ADDRESS, buffer$top ADDRESS;

	bounds$test: PROCEDURE(addr, len);
		DECLARE (addr, len) ADDRESS;
		if addr >= 18h AND addr <= 3fh AND addr + len <= 40h then
			return;
		if user$bottom > addr then
			user$bottom = addr;	/* first address will update this if applicable */
		if buffer$top > addr OR addr + len  < addr then
			call abortx(ISIS$OVERWRITE);
	end;

	blockno = 0;
	user$bottom = 0ffffh;
	if retsw > 2 then
		call warn(BAD$RETSW);

	aftn = AFT$BOTTOM +  open(pathname, 1, 0);	/* open$read */
	if (retsw$b := retsw) <> 0 then
		user$bottom = memck;
	buffer$top = pack$aft$buf;
	do while TRUE;
		call read(aftn, .record, 3, .actual);	/* read record type and length */
		if actual < 3 OR record.type >= R$RELOC OR record.type then	/* short, relocate or odd type */
			call abortx(BAD$LOAD$FORMAT);
		if record.type > R$CONTENT then
			call seek(aftn, SEEK$FORWARD, .blockno, .record.length);	/* skip record */
		else
		do;
			do case shr(record.type,1);
			call abortx(BAD$LOAD$FORMAT);	/* case 0 */
			call seek(aftn, SEEK$FORWARD, .blockno, .record.length);	/* case 1 - R$MODHDR skip */
			do;	/* case 2 - R$MODEND */
				call read(aftn, .modend, size(modend), .actual);
				modend.load$addr = modend.load$addr + bias;
				if modend.modtype = 1 then		/* system */
					call bounds$test(modend.load$addr, 0);
				else
					modend.load$addr = 0;
				call close(aftn);
				user$bottom = user$bottom AND 0ff80h;
				do i = 0 to 18;
					buffer$table(i) = buffer$table(i) AND 0FEh; /* assume available or in use */
					if user$bottom <= .MEMORY(shl(DOUBLE(i), 7)) then
						buffer$table(i) = 1;	/* not available */
				end;
				if retsw$b = 0 then
				do;
					entry = modend.load$addr;
					return;
				end;
				if retsw$b = 1 then
				do;
					debug$toggle = FALSE;
					call jmpto(modend.load$addr, usrSP + 2);	/* wastes the return address */
				end;
				STACKPTR = memck;	
				entry$p = STACKPTR;
				entry = modend.load$addr;
				debug$toggle = TRUE;
				call trap;
			end;
			do;	/* case 3 - R$CONTENT */
				call read(aftn, .content, 3, .actual);
				if content.segId <> 0 then
					call abortx(BAD$LOAD$FORMAT);
				record.length = record.length - 4;		/* don't include header and crc */
				content.load$addr = content.load$addr + bias;
				call bounds$test(content.load$addr, record.length);
				call read(aftn, content.load$addr, record.length, .actual);
				if actual < record.length then
					call abortx(BAD$LOAD$FORMAT);
				call read(aftn, .checksum, 1, .actual);
			end;
			end;	/* of case */
		end;	/* of else */
	end;
end;
end;
eof

open.plm
open:
do;
$include(open.ipx)

DECLARE supportedAccess(*) BYTE DATA(3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
				     1, 2, 1, 2, 1, 2, 1, 1, 1, 1,
				     2, 2, 2, 2, 2, 2, 3, 1, 2);

open: PROCEDURE(pathname, access$mode, lined$aft) BYTE PUBLIC;
	DECLARE (pathname, access$mode, lined$aft) ADDRESS;
	DECLARE (aftn, reqAccess, found, temp, i) BYTE;
	DECLARE temp$buf ADDRESS;
	DECLARE bytes BASED temp$buf (128) BYTE;
	DECLARE addr BASED temp$buf (64) ADDRESS;

	transfer$dir$aft: PROCEDURE;	/* copy data from directory to aft entry */
		a$eof$data$ptr = direct.eof$count;
		a$blk$count = direct.blk;
	end;


	if access$mode > 3 or (reqAccess := access$mode) = 0 then
		call warn(BAD$ACCESS);
	call xpath(pathname, .pn);
	if (i := supportedAccess(pn(0))) <> 3 then
		if i <> reqAccess then
			call warn(BAD$ACCESS);
	if pn(0) = CIDEV then
		return CI$AFT;
	if pn(0) = CODEV then
		return CO$AFT;
	call aft$window(aftn := get$aft$slot);
	a$access = reqAccess;
	a$edit = 0;
	if lined$aft <> 0 then
	do;
		a$edit = AFT$BOTTOM + low(lined$aft);
		if aft(a$edit).access <> 2 OR (reqAccess AND 1) = 0 then
			call warn(BAD$ECHO);
	end;
	if (a$device := pn(0)) <= F9DEV then
	do;
		found = dlook(.PN);
		if found then
			do i = AFT$BOTTOM TO AFT$LAST;
				call aft$window(i);
				if not a$empty then
					if a$i$no = direct$i$no and a$device = pn(0) then
						call warn(ALREADY$OPEN);
			end;
		call aft$window(aftn);
		temp = 0;
		a$i$no = direct$i$no;
		if reqAccess = 1 then
		do;
			if not found then
				call warn(NO$SUCH$FILE);
		end;
		else
		do;
			if not found then
			do;
				if direct$i$no = 0ffffh then
					call warn(DIRECTORY$FULL);
				direct.blk = 0;
				direct.eof$count = 128;
				direct.attrib = 0;
			end;
			call chk$write$protect;
			call transfer$dir$aft;
		end;
		a$hdr$blk = direct.hdr$blk;
		a$dbuf = get$buf;
		a$pbuf = get$buf;
		if reqAccess = 2 and found then
		do;
			call del(a$device);
			call aft$window(aftn);
			direct.blk = 0;
			direct.eof$count = 128;
		end;
		call transfer$dir$aft;

		if reqAccess <> 1 then	/* not read only */
		do;
			if (temp := not (reqAccess = 3 and found)) then
			do;
				direct.hdr$blk = get$block(a$device);
				a$hdr$blk = direct.hdr$blk;
			end;
			direct.empty = 0;
			call write$dir$entry;
		end;
		call aft$window(aftn);
		call rewind;
		if temp then	/* not update + new file */
		do;
			call clear$buf(a$pbuf);
			call map$write(a$device);
			call abswrite(a$hdr$blk, a$pbuf);
		end;
	end;
	else if a$device <> BBDEV then
	do;
		do i = AFT$BOTTOM to AFT$LAST;
			if not aft(i).empty then
				if a$device = aft(i).device then
					call warn(ALREADY$OPEN);
		end;
		if a$device >= 14h and a$device <= 17h then
			do i = 1 to 120;
				a$empty = FALSE;
				call write(aftn, .(0), 1);
			end;
	end;
	if lined$aft <> 0 then
	do;
		temp$buf, a$lbuf = get$buf;
		bytes(0) = LF;
		addr(63) = 0ff00h;
		bytes(125) = TRUE;
	end;
	a$empty = FALSE;
	return aftn - AFT$BOTTOM;
end;
end;
eof

path.plm
path:
do;
$include(path.ipx)

/*
	Abstract

	This is the module that understands the syntax of
	pathnames, and parses them

	Module Organisation

	The module contains the following components:

	1. 2 Global arrays, 'pn' and 'pn2', either of which is
	   sufficient to contain the 'internal form' of a pathname.
	   These are provided here for the convenient transitory
	   use by such subroutines as open, rename, delete etc.
	   The are not directly used by 'path'
	2. The byte procedure 'path', which converts a legal pathname
	   into internal form, returning an error number for the
	   type of pathname found. (0 means legal pathname, other
	   numbers indicates syntax errors in pathname.)
	3. The procedure 'xpath', whose only reason for existence is
	   to reduce the space used for calls to 'path' throughout
	   the program; it reduces code to test the result from
	   path and optionally call err, to a single point in the
	   program.
*/ 

/*
	Although accessed as a byte array the path structur has the format
	STRUCTURE(devNo BYTE, name(6) BYTE, ext(3) BYTE, devType BYTE, drvType BYTE)
*/

DECLARE deviceNames(29) STRUCTURE(name ADDRESS, type BYTE) DATA(
		'F0', 3, 'F1', 3, 'F2', 3, 'F3', 3,
		'F4', 3, 'F5', 3, 'F6', 3, 'F7', 3,
		'F8', 3, 'F9', 3, 'TI', 0, 'TO', 1,
		'VI', 0, 'VO', 1, 'I1', 0, 'O1', 1,
		'TR', 0, 'HR', 0, 'R1', 0, 'R2', 0,
		'TP', 1, 'HP', 1, 'P1', 1, 'P2', 1,
		'LP', 1, 'L1', 1, 'BB', 2, 'CI', 0,
		'CO', 1);

DECLARE pn(12) BYTE PUBLIC, pn2(12) BYTE PUBLIC;
	
path: PROCEDURE(pathname, pn$p) BYTE PUBLIC;
	DECLARE (pathname, pn$p) ADDRESS;
	DECLARE pn BASED pn$p (12) BYTE;	/* byte version of path structure */
	DECLARE pathCh BASED pathname BYTE;	/* char of pathname points to */
	DECLARE pathArray BASED pathname (1) BYTE;
	DECLARE devname ADDRESS, (second, first) BYTE AT (.devname);
	DECLARE null$name BYTE;
	DECLARE i BYTE, imax BYTE;


	toupper: PROCEDURE(ch) BYTE;
		DECLARE ch BYTE;
		if ch < 'a' then
			return ch;
		if ch > 'z' then
			return ch;
		return ch AND 0DFh;
	end;

	non$terminate: PROCEDURE BOOLEAN;
		return (pathCh >= 'A' AND pathCh <= 'Z')
		    OR (pathCh >= '0' AND pathCh <= '9')
		    OR (pathCh >= 'a' AND pathCh <= 'z');
	end;

	parse: PROCEDURE;
		do while i < imax;
			if non$terminate then
			do;
				pn(i) = toupper(pathCh);
				pathname = pathname + 1;
				if i < 2 then
					null$name = FALSE;
			end;
			i = i + 1;
		end;
	end;


	do i = 0 to last(pn);	/* clear pn */
		pn(i) = 0;
	end;
	do while pathCh = ' ';	/* skip leading space */
		pathname = pathname + 1;
	end;
	if pathCh = ':' then
	do;
		pn(0) = 0FFH;
		if pathArray(3) <> ':' then
			return BAD$PATH;
		pathname = pathname + 1;	/* past ':' */
		first = toupper(pathCh);
		pathname = pathname + 1;
		second = toupper(pathCh);
		pathname = pathname + 2;

		do i = 0 to last(deviceNames);
			if deviceNames(i).name = devname then
				pn(0) = i;	/* save device number */
		end;
		if pn(0) = 0ffh then
			return BAD$DEVICE;
	end;
	pn(11) = 0FFh;
	if (pn(10) := deviceNames(pn(0)).type) = 3 then /* random access device */
		pn(11) = dk$cf$tb(pn(0));

	null$name = TRUE;
	i = 1;
	imax = 7;
	call parse;
	if pathCh = '.' then
	do;
		pathname = pathname + 1;
		imax = 10;
		call parse;
		if pn(7) = 0 then
			return NULL$EXTENSION;
	end;
	if pn(0) <= F9DEV and null$name then
		return NULL$FILENAME;
	if non$terminate  OR pathCh = '.' OR pathCh = ':' then
		return BAD$PATH;
	return OK;
end;



xpath: PROCEDURE(p1, p2) PUBLIC;
	DECLARE (p1, p2) ADDRESS;
	DECLARE status ADDRESS;

	if (status := path(p1, p2)) <> 0 then
		call warn(status);
end;


unpath: PROCEDURE(pathname$p, pn$p) PUBLIC;
	DECLARE (pathname$p, pn$p) ADDRESS;
	DECLARE pathname BASED pathname$p (12) BYTE;
	DECLARE pn BASED pn$p (12) BYTE;
	DECLARE i BYTE, devname ADDRESS;

	pn(0) = ':';
	devname = deviceNames(pathname(0)).name;
	pn(1) = high(devname);
	pn(2) = low(devname);
	pn(3) = ':';
	pn$p = pn$p + 4;
	do i = 0 to 5;	/* copy file name */
		if (pn(0) := pathname(i + 1)) <> 0 then
			pn$p = pn$p + 1;
	end;
	if pathname(7) <> 0 then
	do;
		pn(0) = '.';
		pn$p = pn$p + 1;
	end;
	do i = 0 to 2;
		if (pn(0) := pathname(i + 7)) <> 0 then
			pn$p = pn$p + 1;
	end;
	pn(0) = ' ';
end;

chk$write$protect: PROCEDURE PUBLIC;
	if (direct.attrib and (WRITEP$ATTRIBUTE or FORMAT$ATTRIBUTE)) <> 0 then
		call warn(WRITE$PROTECT);
end;

write$dir$entry: PROCEDURE PUBLIC;
	DECLARE i BYTE;
	do i = 0 to 8;
		direct.file(i) = pn(i+1);
	end;
	call dir$clos(a$device);
end;	

chk$pn$disk$file: PROCEDURE(filename) PUBLIC;
	DECLARE filename ADDRESS;

	call xpath(filename, .pn);
	if pn(0) > F9DEV then
		call warn(NON$DISK$FILE);
	call aft$window(pn(0));
end;
end;
eof

rename.plm
rename:
do;
$include(rename.ipx)

rename: PROCEDURE(old$file, new$file) PUBLIC;
	DECLARE (old$file, new$file) ADDRESS;
	DECLARE i BYTE;			/* no longer used but needed to align with isis.bin */
	DECLARE already$exists BOOLEAN;
	

	call xpath(old$file, .pn2);
	call chk$pn$disk$file(new$file);
	if pn(0) <> pn2(0) then
		call warn(DIFFERENT$DISK);
	already$exists = dlook(.pn);
	if NOT dlook(.pn2) then
		call warn(NO$SUCH$FILE);
	call chk$write$protect;
	if already$exists then
		call warn(MULTIDEFINED);
	call write$dir$entry;
end;
end;
eof

rescan.plm
rescan:
DO;

$include(rescan.ipx)

rescan: PROCEDURE(aftn) PUBLIC;
	DECLARE aftn BYTE;
	DECLARE temp ADDRESS, bytes BASED temp(128) BYTE,
			      addr BASED temp(64) ADDRESS;

	call aft$window(aftn);
	temp = a$lbuf;
	if a$edit <> 0 AND NOT bytes(125) then
		addr(63) = 0;	/* lptr = 0, lptr = false */
	else
		call warn(CANT$RESCAN);
end;
end;
eof

rw.plm
rw:
do;

$include(rw.ipx)

DECLARE ACCESS$READ	LITERALLY	'1',
	ACCESS$WRITE	LITERALLY	'2';

DECLARE	MAXLL		LITERALLY	'122';	/* maximum line length */

DECLARE iobyteMasks(*) BYTE DATA(0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh,
				 0FCh, 0FCh, 0FCh, 0FCh, 0FCh, 0FCh, 0F3h, 0F3h, 0F3h, 0F3h,
				 0CFh, 0CFh, 0CFh, 0CFh, 3Fh, 3Fh, 0FFh, 0FFh, 0FFh);
DECLARE iobyteFlags(*) BYTE DATA(0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				 0, 0, 1, 1, 3, 3, 0, 4, 8, 0Ch,
				 0, 10h, 20h, 30h, 80h, 0C0h, 0, 0, 0);
DECLARE devClass(*) BYTE DATA(0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			      0FFh, 1, 0FFh, 1, 0FFh, 1, 0EFh, 0EFh, 0EFh, 0EFh,
			      2, 2, 2, 2, 3, 3, 4, 0FFh, 0FFh);
DECLARE specialChars(*) byte DATA(0, DELKEY, CONTROL$Z, CONTROL$R, CONTROL$X, CR, LF, ESC, CONTROL$E, CONTROL$P);


DECLARE	count$diff ADDRESS,
	eof$dif BYTE,
	adp$dif BYTE PUBLIC,
	datapp	ADDRESS PUBLIC, /* interface to usrSys & sysUsr asm routines */
	create BYTE INITIAL(0),
	newptrblk ADDRESS,
	iostat BYTE;
	

chk$eof: PROCEDURE PUBLIC;
	if a$access = ACCESS$READ then	/* 1 */
	do;
		a$blk$seqno = a$blk$count;
		a$data$ptr = a$eof$data$ptr;
		call WARN(SEEK$PAST$EOF);

	end;
end;

adjust$eof: PROCEDURE PUBLIC;
	if a$blk$seqno <> 0 AND a$data$ptr = 0 then
	do;
		if not ((a$eof$data$ptr < 128 AND a$blk$seqno - 1 = a$blk$count) OR a$blk$count < a$blk$seqno - 1) then
			return;
	end;
	else
	do;
		if not ((a$eof$data$ptr < a$data$ptr AND a$blk$seqno = a$blk$count) OR a$blk$seqno > a$blk$count) then
			return;
	end;
	call chk$eof;
	a$blk$count = a$blk$seqno;
	a$eof$data$ptr = a$data$ptr;
end;



rw: PROCEDURE(aftn, buffer, count, actual$p, reading);
	DECLARE aftn BYTE, (buffer, count, actual$p) ADDRESS, reading BYTE;
	DECLARE actual BASED actual$p ADDRESS;
	DECLARE temp ADDRESS, non$sector$request BYTE, work$buf ADDRESS;
	DECLARE newlinks BASED temp (64) ADDRESS;

	do while count > actual;
		if a$blk$count <= a$blk$seqno AND reading AND a$data$ptr = a$eof$data$ptr then
			return;
		if a$data$ptr = 128 then
		do;
			call save$data$blk;
			a$data$ptr = 0;
			a$dbuf$read = FALSE;
			a$blk$seqno = a$blk$seqno + 1;
			a$ptr$ptr = a$ptr$ptr + 1;
			if a$ptr$ptr = 64 then
			do;
				if links(FLINK) = 0 then
				do;
					newptrblk = get$block(a$device);
					links(FLINK) = newptrblk;	
					create = TRUE;
					a$ptr$change = TRUE;
					call clear$buf(temp := a$dbuf);
					newlinks(0) = a$ptr$blk;	/* save forward link */
					call map$write(a$device);
					call abswrite(newptrblk, a$dbuf);
				end;

				call save$pointer$block;
				if create then
				do;
					create = FALSE;
					call clear$buf(temp := a$pbuf);
					newlinks(0) = a$ptr$blk;
				end;
				else
				do;
					call absread(newptrblk := links(FLINK), a$pbuf);
				end;
				a$ptr$blk = newptrblk;
				a$ptr$ptr = 2;
			end;
		end;

		adp$dif = 128 - a$data$ptr;
		if a$blk$count <= a$blk$seqno AND READING then
		do;
			eof$dif = a$eof$data$ptr - a$data$ptr;
			if adp$dif > eof$dif then
				adp$dif = eof$dif;
		end;
		countdiff = count - actual;
		if adp$dif > count$diff then	/* check if more in buffer than needed */
			adp$dif = count$diff;


		actual = actual + adp$dif;
		non$sector$request = adp$dif <> 128;
		adp$dif = adp$dif + a$data$ptr;
		work$buf = buffer;
		if non$sector$request then
			work$buf = a$dbuf;
		a$data$blk = links(a$ptr$ptr);
		if a$data$blk = 0 then
		do;
			if reading then
				call clear$buf(work$buf);
			else
			do;
				if non$sector$request then
					call clear$buf(work$buf);
				a$ptr$change = TRUE;
				links(a$ptr$ptr), a$data$blk =  get$block(a$device);
			end;
		end;
		else if a$dbuf$read then
			non$sector$request = TRUE;
		else if non$sector$request OR reading then
			call abs$read(a$data$blk, work$buf);

		if non$sector$request then
		do;
			a$dbuf$read = TRUE;
			datapp = a$data$ptr$p;
			if reading then
				call sysUsr(.buffer, buffer, datum$base);
			else
			do;
				a$data$change = TRUE;
				call usrSys(.buffer, buffer, datum$base);
			end;
			a$data$ptr = adp$dif;
		end;
		else
		do;
			if not reading then
				call abswrite(a$data$blk, work$buf);
			a$data$ptr = 128;
			buffer = buffer + 128;
		end;
	end; /* of do while */
	call adjust$eof;
end;



non$disk$select: PROCEDURE;
	/*
	   set logical file assignments to use monitor routines
	   for doing byte at a time I/O devices
	*/
	call ioset(((iostat := iochk) AND iobyteMasks(a$device)) or iobyteFlags(a$device));
end;


read: PROCEDURE(aftn, buffer, count, actual$p) PUBLIC;
	DECLARE aftn BYTE, (buffer, count, actual$p) ADDRESS;
	DECLARE actual BASED actual$p ADDRESS;
	DECLARE bytes BASED buffer BYTE;

	actual = 0;
	call aft$window(aftn);
	if (a$access AND 1) = 0 then	/* not read */
		call warn(CANT$READ);
	if a$device = 26 then		/* BB */
		return;
	call non$disk$select;
	if a$device <= F9DEV then
	do;
		call rw(aftn, buffer, count, actual$p, TRUE);
		return;
	end;

	do while actual <> count;
		if devClass(a$device) <> 0efh then
			bytes = ci;
		else
		do;
			bytes = ri;
			if CARRY then
				goto done;
		end;
		buffer = buffer + 1;
		actual = actual + 1;
	end;
done:
	call ioset(iostat);
end;



write: PROCEDURE(aftn, buffer, count) PUBLIC;
	DECLARE aftn byte, (buffer, count) ADDRESS;
	DECLARE bytes BASED buffer BYTE;
	DECLARE actual ADDRESS, i BYTE;

	call aft$window(aftn);
	if (a$access and 2) = 0 then
		call warn(CANT$WRITE);
	if a$device = 26 then	/* BB */
		return;
	call non$disk$select;

	do while count <> 0;
		do case devClass(a$device);
		do;		/* case 0 */
			actual = 0;
			call rw(aftn, buffer, count, .actual, FALSE);
			return;
		end;
		do;		/* case 1 */
			call CO(bytes);
			if csts then
			do;
				do i = 0 to 255;	/* delay a little */
				end;
				if csts then
					if (ci AND 7fh) = CONTROL$S then
						do while (ci AND 7fh) <> CONTROL$Q;
						end;

			end;
		end;
		call po(bytes);		/* case 2 */
		call lo(bytes);		/* case 3 */
		end;

		count = count - 1;
		buffer = buffer + 1;
	end;
	call ioset(iostat);
end;



lined: PROCEDURE(aftn, buffer, count, actual$p) PUBLIC;
	DECLARE aftn BYTE, (buffer, count, actual$p) ADDRESS;
	DECLARE actual BASED actual$p ADDRESS;
	DECLARE lbuf ADDRESS,
		in$mode BYTE,
		lit$mode BYTE,
		lptr BYTE,
		char BYTE,
		i BYTE,		/* note read clobbers selector as well */
		selector BYTE;
	DECLARE obuf BASED buffer (1) BYTE;
	DECLARE bytes BASED lbuf (128) BYTE;
	DECLARE addr BASED lbuf (64) ADDRESS;


	echo: PROCEDURE(char);		/* nested sub of lined */
		DECLARE char BYTE;
		call write(a$edit, .char, 1);
		call aft$window(aftn);
	end;

	echoCRLF: PROCEDURE;
		call echo(CR);
		call echo(LF);
	end;

	lineReset: PROCEDURE;		/* nested in lined */
		in$mode = FALSE;
		lptr = 0;
	end;


	lit$mode = FALSE;
	lbuf = aft(aftn).lbuf;
	lptr = bytes(126);
	in$mode = bytes(127);

	do while in$mode;
		call read(aftn, .char, 1, .i);
		if i = 0 then
		do;
			if aftn = AFT$CONSOLE then	/* 11 */
				call abortx(CONSOLE$EOF);
			char = CONTROL$Z;
		end;
		bytes(125) = FALSE;
		char = char AND 7fh;
		if char <> LF then
			call echo(bytes(lptr) := char);

		selector = 0;
		do i = 0 to 9;
			if char = specialChars(i) then
				selector = i;
		end;	
		selector = selector and not lit$mode;
		lit$mode = FALSE;
		do case selector;
			lptr = lptr + 1;	/* case 0 - normal */
			do;			/* case 1, rubout */
				if lptr <> 0 then
				do;
					lptr = lptr - 1;
					if aft(a$edit).device = 13 then
					do;
						call echo(BS);
						bytes(lptr) = ' ';
						call echo(' ');
						call echo(BS);
					end;
					else
						call echo(bytes(lptr));
				end;
				else
					call echo(BELL);
			end;
			do;			/* case 2 - control-Z */
				actual = 0;
				bytes(125) = TRUE;
				addr(63) = 0ff00h;
				call echoCRLF;
				return;
			end;
			do;			/* case 3 - control-R */
				call echoCRLF;
				call write(a$edit, .bytes, lptr);
			end;
			do;			/* case 4 - control-X */
				lptr = 0;
				call echo('#');
				call echoCRLF;
			end;
			do;			/* case 5 - CR */
				bytes(lptr := lptr + 1) = LF;
				call echo(LF);
				call lineReset;
			end;
			do;			/* case 6 - LF */
				if lptr <> 0 then
				do;
					call echo(bytes(lptr) := char);
					call lineReset;
				end;
			end;
			do;			/* case 7 -  ESC */
				call echo(0);
				call echo('$');
				call lineReset;
			end;
			do;			/* case 8 - Control-E */
				if aftn = AFT$CONSOLE then
				do;
					i = aft(AFT$CONSOLE).device;
					aft(AFT$CONSOLE).device = alt$cidev;
					alt$cidev = i;
					call echo('^');
					call echo('E');
				end;
			end;
			lit$mode = TRUE;	/* case 8 - control-P */
		end; /* of case */
		if lptr = 122 then
			call lineReset;
	end;

	actual = 0;
	do while actual < count and not in$mode;
		if lptr < MAXLL then	/* 122 */
		do;
			if (obuf(actual) := bytes(lptr)) = LF OR bytes(lptr) = ESC then
			do;
				in$mode = TRUE;
				lptr = -1;
			end;

			actual = actual + 1;
			lptr = lptr + 1;
		end;
		else
		do;
			in$mode = TRUE;
			lptr = 0;
		end;
	end;
	bytes(126) = lptr;
	bytes(127) = in$mode;
end;



end;
eof
seek.plm
seek:
do;
$include(seek.ipx)

save$data$blk: PROCEDURE PUBLIC;
	if a$data$change then
	do;
		call abswrite(a$data$blk, a$dbuf);
		a$data$change = FALSE;
	end;
end;

save$pointer$block: PROCEDURE PUBLIC;
	if a$ptr$change then
	do;
		call map$write(a$device);
		call abswrite(a$ptr$blk, a$pbuf);
		a$ptr$change = FALSE;
	end;
end;

rewind:	PROCEDURE PUBLIC;
	a$data$ptr = 128;
	a$ptr$ptr = 1;
	a$data$change = FALSE;
	a$dbuf$read = FALSE;
	a$ptr$change = FALSE;
	a$blk$seqno, a$data$blk = 0;
	call absread(a$ptr$blk := a$hdr$blk, a$pbuf);
end;

seek: PROCEDURE(aftn, mode, blockptr, byteptr) PUBLIC;
	DECLARE aftn BYTE, (mode, blockptr, byteptr) ADDRESS;
	DECLARE lowMode BYTE AT (.mode);
	DECLARE blk BASED blockptr ADDRESS, byt BASED byteptr ADDRESS;
	DECLARE plusMinus ADDRESS,
		orig$byte ADDRESS, lo$byte BYTE AT (.orig$byte),
		blockno ADDRESS, temp ADDRESS, forward BYTE;

	if mode > SEEK$EOF then
		call warn(BAD$SEEK$ARG);
	call aft$window(aftn);
	if a$device = BBDEV then
		return;

	if a$device > F9DEV then
		call warn(NON$DISK$SEEK);

	if a$access = WRITE$MODE then	/* 2 */
		call warn(SEEK$ON$WRITE);
	if lowMode = SEEK$RETURN then	/* 0 - SEEK$RETURN */
	do;
		byt = a$data$ptr;	
		if (blk := a$blk$seqno - 1) = 0FFFFh then
		do;
			blk, byt = 0;
		end;
		return;
	end;
	
	blockno = (blk AND 07fffh) + shr((orig$byte := byt), 7);
	lo$byte = lo$byte and 7fh;
	if lowMode = SEEK$EOF then
	do;
		lowMode = SEEK$ABS;
		lo$byte = a$eof$data$ptr;
		if (blockno := a$blk$count - 1) = 0FFFFh then
		do;
			blockno, lo$byte = 0;
		end;
	end;
	if lowMode = SEEK$ABS then
	do;
		if (blockno OR a$blk$seqno OR lo$byte) <> 0 then
		do;
			blockno = blockno + 1;
		end;
		else
			lo$byte = 128;
		lowMode = SEEK$BACKWARD;
		if blockno > a$blk$seqno then
		do;
			lowMode = SEEK$FORWARD;
			blockno = blockno - a$blk$seqno;
		end;
		else if blockno < a$blk$seqno then
			blockno = a$blk$seqno - blockno;
		else
		do;
			blockno = 0;
			if lo$byte > a$data$ptr then
				lowMode = SEEK$FORWARD;	/* seek within block */
		end;
	end;
	else
	do;
		if lowMode = SEEK$BACKWARD then
			lo$byte = -lo$byte;
		
		lo$byte = a$data$ptr + lo$byte;
		if lo$byte > 128 then
		do;
			blockno = blockno + 1;
			lo$byte = lo$byte - 128;
		end;
	end;
	a$data$ptr = lo$byte;
	if (forward := lowMode = SEEK$FORWARD) then
		call adjust$eof;

	do while blockno > 0;
		call save$data$blk;
		a$dbuf$read = FALSE;
		blockno = blockno - 1;
		if forward then
		do;
			plusMinus = 1;
			if a$ptr$ptr = 63 then
			do;
				if (temp := links(FLINK)) = 0 then
				do;
					call chk$eof;
					links(FLINK), temp = get$block(a$device);
					a$ptr$change = TRUE;
					call save$pointer$block;
					call clear$buf(a$pbuf);
					links(BLINK) = a$ptr$blk;
					call abswrite(temp, a$pbuf);
				end;
				else
				do;
					call save$pointer$block;
					call absread(temp, a$pbuf);
				end;
				a$ptr$ptr = 1;
				a$ptr$blk = temp;
			end;
		end;
		else if a$data$ptr = 128 then
		do;
			plusMinus = 0;
			a$data$ptr = 0;
		end;
		else
		do;
			plusMinus = 0FFFFH;	/* -1 */
			if a$ptr$ptr - 1 < 2 then 
				if links(BLINK) <> 0 then
				do;
					call save$pointer$block;
					a$ptr$ptr = 64;
					call absread((a$ptr$blk := links(BLINK)), a$pbuf);
				end;
				else
				do;
					a$ptr$ptr = 1;
					a$blk$seqno = 0;
					goto error;
			
				end;
		end;
		a$blk$seqno = a$blk$seqno + plusMinus;
		a$ptr$ptr = a$ptr$ptr + low(plusMinus);
		call adjust$eof;
	end;

error:
	if a$blk$seqno = 0 AND a$data$ptr <> 128 then
	do;
		a$data$ptr = 128;
		call warn(LONG$BACK$SEEK);
	end;
end;
end;
eof
alloc.plm
alloc:
do;
$include(alloc.ipx)

DECLARE	tracksTable(10) BYTE PUBLIC,	/* initialised by boot routines */
	sectorsTable(10) BYTE PUBLIC,
	bitmapBuffer(128) BYTE,
	current$bitmap BYTE PUBLIC INITIAL(0ffh),
	map$change BYTE INITIAL(FALSE),
	baseTrackSector ADDRESS,
	baseSector BYTE AT (.baseTrackSector),
	baseTrack BYTE AT (.baseTrackSector + 1),
	bitmapIndex ADDRESS,
	lowBitMapIndex BYTE AT (.bitmapIndex),
	map$dcb DCB$T INITIAL(80h, 4, 1, 2, 2, .bitmapBuffer),
	current$part BYTE INITIAL(0ffh),
	base$part BYTE INITIAL(0),
	next$part BYTE INITIAL(0),
	bitmapByte$p ADDRESS INITIAL(0),
	(lowBitmapByte$p, highBitmapByte$p) BYTE AT (.bitmapByte$p),
	bitmapByte BASED bitmapByte$p BYTE,
	bitmapBit BYTE,
	command BYTE,
	disk BYTE,
	tracksPerDisk BYTE,
	sectorsPerTrack BYTE;


mapio:	PROCEDURE;
	map$change = FALSE;
	map$dcb.ioins = command;	/* set up command */
	map$dcb.tadr = 2;		/* set up partition */
	map$dcb.sadr = current$part + 2;
	call diskio(disk, .map$dcb);
end;


map$write: PROCEDURE(diskNum) PUBLIC;
	DECLARE diskNum BYTE;

	disk = diskNum;
	if  disk = current$bitmap AND map$change then
	do;
		command = CMD$WRITE;	
		call mapio;
	end;
end;

		

map$read: PROCEDURE PUBLIC;
	DECLARE temp BYTE;

	temp = disk <> current$bitmap;
	if current$part <> next$part or temp then
	do;
		if temp then
		do;
			base$part = 0;
			bitmapIndex = 0;
			baseTrackSector = 1;
		end;
		temp = disk;
		call map$write(current$bitmap);
		disk = temp;
		command = CMD$READ;
		current$part = next$part;
		current$bitmap = disk;
		call mapio;
	end;
end;


set$num$sect$trk: PROCEDURE;
	sectorsPerTrack = sectorsTable(disk);
	tracksPerDisk = tracksTable(disk);
end;



get$block: PROCEDURE(diskNum) ADDRESS PUBLIC;
	DECLARE diskNum BYTE;
	DECLARE trackSector ADDRESS,
		sector BYTE AT (.trackSector),
		track BYTE AT (.trackSector + 1);

	disk = diskNum;
	call set$num$sect$trk;
	next$part = base$part;
	if disk <> current$bitmap then
		next$part = 0;
	call map$read;
	bitmapBit = ror(1, lowBitmapIndex and 7);
	do track = baseTrack TO tracksPerDisk;
		do sector = baseSector TO sectorsPerTrack;
			bitmapByte$p = .bitmapBuffer(SHR(bitmapIndex, 3));
			if bitmapByte = 0ffh  AND bitmapBit then	/* no free entry */
			do;
				bitmapIndex = bitmapIndex + 8;
				sector = sector + 7;			/* the do loop adds 1 */
				if sector > sectorsPerTrack then
				do;
					sector = sector - sectorsPerTrack;
					track = track + 1;
					if track > tracksPerDisk then	
						goto full;
				end;
			end;
			else
			do;
				if ((bitmapBit := ROR(bitmapBit, 1)) AND bitmapByte) = 0 then	/* found a slot */
				do;
					map$change = TRUE;
					bitmapByte = bitmapByte OR bitmapBit;
					base$part = current$part;
					return (baseTrackSector := trackSector);
				end;
				bitmapIndex = bitmapIndex + 1;
			end;
			if bitmapIndex > 03ffh then
			do;
				next$part = current$part + 1;
				call map$read;
				bitmapIndex = 0;
			end;
		end;
		baseSector = 1;	
	end;
full:
	call abortx(DISK$FULL);
end;


free$block: PROCEDURE(diskNum, trackSector) PUBLIC;
	DECLARE disknum BYTE, trackSector ADDRESS;
	DECLARE (sector, track) BYTE AT (.trackSector);
	DECLARE temp BYTE;

	disk = disknum;
	call set$num$sect$trk;
	bitmapByte$p = track * sectorsPerTrack + sector - 1;
	next$part = shr(highBitmapByte$p, 2);
	if bitmapByte$p < bitmapIndex + shl(double(base$part),10) then
	do;
		base$part = next$part;
		bitmapIndex = bitmapByte$p AND 03ffh;
		baseTrackSector = trackSector;
	end;
	call map$read;
	temp = lowBitmapByte$p;
	bitmapByte$p = .bitmapBuffer(shr(bitmapByte$p and 03ffh, 3));
	bitmapByte = bitmapByte AND not ROR(80h, temp and 7);
	map$change = TRUE;
end;
end;
eof

buffer.plm
buffer:
DO;

/*
	ABSTRACT
		This module contains routines for obtaining, clearing
		releasing and packing buffers of 128 bytes each.

	MODULE ORGANISATION
		This module contains an llocation table ('buffer$table') and
		4 subroutines
		Buffers are allocted in RAM, starting at ".MEMORY" and
		working upwards (to the user's program origin point).
		'buffer$table' contains 19 entries, allowing maximum buffer
		usage for 6 open files (all lined input files, 3 buffers each),
		plus 1 buffer for the console.

	INVARIANTS
		Each entry in 'buffer$table' is initialised to '0'; legal
		values are 0, 1 and 2 with the following meanings
		0 - corresponding buffer is available, but not allocated.
		1 - corresponding buffer is not available, because it is
		    in the current user RAM area
		2 - corresponding buffer is in use.

		Entries change when buffes are obtained or released (via
		get$buf and return$buf), or when then user's program origin
		point is changed (by making a call to the 'load' subroutine).
*/

$include(buffer.ipx)

DECLARE buffer$table(19) BYTE PUBLIC INITIAL(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
DECLARE i BYTE;

clear$buf: PROCEDURE(buf$address) PUBLIC;
	DECLARE buf$address ADDRESS;
	DECLARE buffer BASED buf$address (128) BYTE;

	do i = 0 to 127;
		buffer(i) = 0;
	end;
end;

return$buf: PROCEDURE(buf$address) PUBLIC;
	DECLARE buf$address ADDRESS;

	buffer$table(shr(buf$address - .MEMORY, 7)) = 0;
end;




get$buf: PROCEDURE ADDRESS PUBLIC;
	do i = 0 to last(buffer$table);
		if buffer$table(i) = 0 then
		do;
			buffer$table(i) = 2;
			return .MEMORY + shl(DOUBLE(i), 7);
		end;
	end;
	call abortx(NO$FREE$BUFFER);	/* 1 */
end;

/*
	ABSTRACT
		This routine reassigns buffer space and moves buffer
		contents as necessary, to ensure that there is no unused
		buffer space below the area occupied by the highest buffer
		in use.


	RETURNS
		The address of the first (lowest) byte in the first
		(lowest) unallocated buffer. THis information is the "top of
		buffer area" described in the mds-dos operator's manual.

	DESCRIPTION
		For every AFT entry which is a currently assigned
		buffer address, the buffer is returned (using 'return$buf')
		and is replace by a new buffer (using 'get$buf'). If the new
		buffer is a different one than the one returned, then the
		data from the old is moved into the new.
*/



pack$aft$buf: PROCEDURE ADDRESS PUBLIC;
	DECLARE (i, j, index) BYTE;
	DECLARE buffer$top ADDRESS;
	DECLARE bptr ADDRESS, bufadr BASED bptr ADDRESS;
	DECLARE new$badr ADDRESS, new$datum BASED new$badr(128) BYTE,
		old$badr ADDRESS, old$datum BASED old$badr(128) BYTE;

	buffer$top = .MEMORY;
	do i = AFT$BOTTOM to AFT$LAST;
		if not aft(i).empty then
		do index = 0 to 4 BY 2;
			bptr = .aft(i).pbuf - index;
			j = shr(bufadr - .MEMORY, 7);
			if j <= last(buffer$table) and buffer$table(j) = 2 then
			do;
				old$badr = bufadr;
				call return$buf(old$badr);
				if buffer$top < (new$badr := getbuf) then
					buffer$top = new$badr;
				if new$badr <> old$badr then
				do;
					do j = 0 to 127;
						new$datum(j) = old$datum(j);
					end;
					bufadr = new$badr;
				end;
			end;
		end;	/* of loop to handle each buffer p, d, l */
	end;	/* of look to traverse aft */
	return buffer$top + 128;
end;
end;
eof

rw1.asm
	CSEG
	public	usrSys
	public	sysUsr
	extrn	datapp
	extrn	adpdif

; usrSys: PROCEDURE(buffer$p, buffer, datum$base)
usrSys:		
	push	d		; datum$base
	lhld	datapp
	mov	e, m		; e = a$data$ptr
	lda	adpdif
	mov	m, a		; a$data$ptr = adp$dif	- save final a$data$ptr value
	mvi	d, 0
	pop	h		; datum$base + e - stort of data to copy
	dad	d
	mov	d, a		; d = adp$dif

usloop:
	mov	a, d		; copy until we reach new end
	cmp	e
	jz	updbuf
	ldax	b		; buffer
	mov	m, a		; datum buffer
	inx	h
	inx	b
	inr	e		; advance data$ptr
	jmp	usloop


sysUsr:
	push	d		; as per usrSys
	lhld	datapp
	mov	e, m
	lda	adpdif
	mov	m, a
	mvi	d, 0
	pop	h
	dad	d
	mov	d, a

suloop:
	mov	a, d
	cmp	e
	jz	updbuf
	mov	a, m		; datum buffer
	stax	b		; buffer
	inx	h
	inx	b
	inr	e
	jmp	suloop

updbuf:
	pop	h	; return address
	xthl		; buffer$p
	mov	m, c	; save the updated buffer
	inx	h
	mov	m, b
	ret

	end;

direct.plm
direct:
do;

/*
	ABSTRACT
		All knowledge about the format and location of a diskette
		directory is contained by this module

	Module organisation
		The module contains a data adara, which normally contains
		the information from a single entry in a diskette directory
		and the procedures dir$close and dlook

	Invariants
		On every diskette, the directory file is partitioned into
		'entries' containing 16 bytes of data each.
		The various byte- and address-variables within an entry are
		given descriptive names (see the structure 'direct' below).
		at all times, teh following must be true:

		1.  direct.empty = false => the entry contains meaningful data
		2.  (direct.empty = true(0ffh)) => the directory slot is empty.
		3.  (direct.empty = true(07fh)) => the directory slot and all
		further directory slots are empty;
*/

$include(direct.ipx)

/* interface to assembler support code */
DECLARE	fndFre	BYTE PUBLIC;	/* logical flag used to indicate if a
				   free dir slot has been allocated */
DECLARE	inoPtr	ADDRESS PUBLIC;	/* is setup to point to direct$i$no */
DECLARE dirPtr ADDRESS PUBLIC;	/* is setup to point to the direct */

DECLARE dnum ADDRESS EXTERNAL;
fndDir: PROCEDURE(fname, datum) BYTE EXTERNAL;
	DECLARE fname ADDRESS, datum ADDRESS;
END;

/* end of asm interface */




DECLARE	direct structure (
	empty	    BOOLEAN,	/* flag to indicate whether directory entry is used */
	file(6)	    BYTE,	/* file name */
	ext(3)	    BYTE,	/* extension */
	attrib	    BYTE,	/* file attributes */
	eof$count   BYTE,	/* character count, last data block */
	blk   ADDRESS,	/* number of block in file */
	hdr$blk	    ADDRESS)	/* address of first pointer block */
	PUBLIC;

DECLARE	direct$i$no ADDRESS PUBLIC;	/* directory entry pointer */



dir$clos: PROCEDURE(aftn) PUBLIC;
	DECLARE aftn BYTE;

	/*
	    This procedure assumes that aftwindow has been called
	    correctly setting up the appropriate directory slot
	    and that teh dbuffer and pbuffer have correct data
	    but need not be returned to the pool
	*/

	call write(aftn, .direct, size(direct));
	call abswrite(a$data$blk, a$dbuf);	/* both based vars */
end;


dlook: PROCEDURE(fn) BOOLEAN PUBLIC;
	DECLARE fn ADDRESS;
	DECLARE blockno ADDRESS DATA(0);
	DECLARE rcount BYTE;
	/* The location at (rcount + 1) is modified by the procedure read,
	   hence byteno must always follow the declaration of rcount
	*/
	DECLARE byteno ADDRESS;
	DECLARE array based fn(12) BYTE;
	DECLARE (i, aftn) BYTE;
	DECLARE return$value BOOLEAN;

	/*
	  This procedure is used to lookup a file name in a
	  disk directory. The device number of the disk
	  is contained in fn(0), the six characters of the
	  file name are in fn(1) through fn(6), and the
	  three characters of the file extension are in
	  fn(7) through fn(9)

	  The procedure returns 'TRUE' if the file is found,
	  with direct$i$no pointing to the entry of the file in the
	  directory

	  otherwise, the procedure returns 'FALSE', and direct$i$no points
	  at a blank slot in the directory. The directory marker is
	  adjusted so taht it points at the beginning of the entry
	  pointed to by direct$i$no.

	  If the directory is full, direct$i$no = 0ffffh
	*/
	call aft$window(aftn := a$device);
	pointer$base, a$pbuf = get$buf;
	datum$base, a$dbuf = get$buf;
	call rewind;
	direct$i$no = 0ffffh;
	dirPtr = .direct;
	inoPtr = .direct$i$no;
	rcount = 1;
	fndFre = FALSE;
	dnum, return$value = 0;

	do while rcount <> 0;
		call read(aftn, a$dbuf, 128, .rcount);
		if (i := fndDir(fn + 1, datum$base)) = 07fh then /* no more entries */
			goto done;	/* break */
		if i = 0ffh then	/* found */
		do;
			return$value = TRUE;
			rcount = 0;
		end;
	end;
done:
	if direct$i$No <> 0ffffh then
	do;
		byteno = direct$i$no * size(direct);
		call seek(aftn, SEEK$ABS, .blockno, .byteno);
	end;
	call return$buf(a$dbuf);
	call return$buf(a$pbuf);
	return return$value;
end;
end;
eof

disk2.asm
	CSEG
	public	dkstat	; dk$stat
	public	rtype	; r$type
	public	rbyte	; r$byte
	public	strtio	; strt$io
	extrn	dkcont	; disk controller

IOCDR1	equ	0F821h
IOCCOM	equ	0F841h
IOCDR2	equ	0F844h

; controller
NOCONT	equ	0
CONT1	equ	1
CONT2	equ	2
CONTIN	equ	3	; integrated single density
CONTHD	equ	4

; and their IO port bases (ISD handled separately)
BASE1	equ	78h
BASE2	equ	88h
BASEHD	equ	68h


; IOC INTERFACE COMMANDS
IOCS	equ	0c1h		; IOC INPUT DBB STATUS PORT
IOCC	equ	0c1h		; IOC OUTPUTY CONTROL COMMAND PORT
IOCI	equ	0c0h		; IOC INPUT DATA (FROM DBB) PORT
IOCO	equ	0c0h		; IOC OUTPUT DATA (TO DBB) PORT
F0	equ	00000100B	; FLAG 0 - SLAVE IS BUSY, MASTER IS LOCKED OUT
IBF	equ	00000010B	; SLAVE INPUT BUFFER IS FULL
OBF	equ	00000001B	; SLAVE OUTPUT BUFFER IS FULL
WPBC	equ	15h		; write parameter block command
WPCC	equ	16h		; write parameter block command continuation
WDBC	equ	17h		; write data block command
WDCC	equ	18h		; reserved
RDBC	equ	19h		; read data block command
RDCC	equ	1ah		; reserved
RRSTS	equ	1bh		; read result status command
RDSTS	equ	1ch		; read device status command

; PSEUDO INTERRUPT INSTRUCTIONS
DISABL	equ	0dh		; disable interrupts
ENABL	equ	05h		; enable interrupts
CPUC	equ	0ffh		; port for these instructions

; DISK INSTRUCTIONS
SEEK	equ	1		; seek instruction
FORMAT	equ	2		; format instruction
RECAL	equ	3		; recalibrate instruction
READ	equ	4		; read data instruction
VERIFY	equ	5		; verify crc instruction
WRITE	equ	6		; write data instruction
WRITED	equ	7		; write deleted data instruction

; Layout of the I/O parameter block (IOPB)
;	Only the first five bytes of the IOPB are transmitted to the ISD
;	IOCW	BYTE	channel word
;	IOINS	BYTE	diskette instruction
;	NSEC	BYTE	number of sectors
;	TADR	BYTE	track address
;	SADR	BYTE 	sector address
;	BUF	ADDRESS	buffer address

dkstat:	lda	dkcont
	ora	a
	rz			; not present
	cpi	CONTHD
	jz	statHD		; hard disk
	cpi	CONTIN
	jnz	dkst1		; jump if not isd
	mvi	b, RDSTS	; use bios to get ISD status
	call	IOCDR1
	ret

dkst1:	cpi	CONT2
	jnz	dkst2
	in	BASE2		; controller 2
	ret

dkst2:	in	BASE1		; controller 1
	ret

statHD:	in	BASEHD
	ret




rtype:	lda	dkcont
	cpi	CONTHD		
	jz	typeHD		; hard disk
	cpi	CONTIN
	jnz	type1		; jump if not isd
	xra	a	; no result type for ISD
	ret

type1:	cpi	CONT2
	jnz	type2
	in	BASE2 + 1	; controller 2
	ret

type2:	in	BASE1 + 1	; controller 1
	ret

typeHD:	in	BASEHD + 1
	ret



rbyte:
	lda	dkcont
	cpi	CONTHD
	jz	byteHD		; hard disk
	cpi	CONTIN
	jnz	rbyte1		; jump if not isd
	mvi	b, RRSTS	; isd use bios
	call	IOCDR1
	ret

rbyte1:	cpi	CONT2
	jnz	rbyte2
	in	BASE2 + 3	; controller 2
	ret

rbyte2:	in	BASE1 + 3	; controller 1
	ret

byteHD:	in	BASEHD + 3
	ret



strtio:	lda	dkcont
	cpi	CONTHD
	jz	strtHD		; hard disk
	cpi	CONTIN
	jnz	strt1		; not isd
	call	isddr		; use standard code
	ret

strt1:	cpi	CONT2
	jnz	strt2
	mov	a, c		; controller 2
	out	BASE2 + 1
	mov	a, b
	out	BASE2 + 2
	jmp	wait

strt2:	mov	a, c		; controller 1
	out	BASE1 + 1
	mov	a, b
	out	BASE1 + 2
	jmp	wait

strtHD:	mov	a, c		; hard disk
	out	BASEHD + 1
	mov	a, b
	out	BASEHD + 2

wait:	call	dkstat		; wait till i/o done
	ani	4
	jz	wait
	ret

; code is a direct lift from the Intellec series II interface document

;***************************************************************
;* PROCEDURE NAME = ISDDR (IHTEGRATED SINGLE DENSITY DISK DRIVER)
;* PROCESS: TRANSMIT THE IOPB; ONE BYTE AT A TIME, TO THE ISD
;* 	    IF THE INSTRUCTION TO THE OISK IS A OATA TRAHSFER
;*	    (I E READ DATA, FORMAT, WRITE DATA, WRITE DELETED
;*	    DATA) THEN TRAHSFER THE DATA. ONE BYTE AT A TIME
;*	    TO/FROH THE ISD
;* IHPUT:   B-REG COHTAIHS MSB OF IOPB
;*	    C-REG COHTAIHS LSB OF IOPB
;* OUTPUT:  THE IOPB IS TRANSMITTED TO THE ISD DATA IS TRANSFERED
;*	    TO/FROM THE ISD AS REQUIRED
;***************************************************************

isddr:
	push	b		; save the iopb
	inx	b
	ldax	b		; test ioins
	cpi	READ
	jnz	isd1		; jump if not read
	pop	h		; get the iobp
	push	h		; save again
	inx	h
	inx	h
	mov	d, m		; d = number of sectors
	pop	h
	push	d		; save the number of sectors
	call	triopb		; issue the command
	inx	h		; get the buffer address into hl
	mov	e, m
	inx	h
	mov	d, m
	xchg
	mvi	b, RDBC		; issue the read data block command
	call	IOCCOM
	pop	d		; recover the number of sectors	

rdlp1:
	mvi	e, 128		; read a sector (128 bytes)

rdlp2:
	in	IOCS		; wait for byte available
	ani	F0 or IBF or OBF
	cpi	OBF		; test for slave done; somethign for the master
	jnz	rdlp2		; loop until slave is ready
	in	IOCI		; get the byte from the DBB
	mov	m, a		; save to buffer
	inx	h
	dcr	e		; loop for one sector
	jnz	rdlp2
	dcr	d		; loop for number of sectors
	jnz	rdlp1
	mvi	a, ENABL		; enable interrupts
	out	CPUC
	ret
	;----------------------------------------------------------------------
isd1:				; here if not a read so test for
	cpi	FORMAT		; FORMAT, WRITE pr WRITED 
	jz	isd2
	cpi	WRITE
	jz	isd2
	cpi	WRITED
	jnz	isd3		; must be a SEEK, RECALB or VERIFY

isd2:
	pop	h		; recover iopb
	push	h		; save again
	inx	h
	mov	a, m
	cpi	FORMAT
	inx	h
	jz	isd2a		; don't use sector count for format
	mov	c, m		; pick up sector count
	jmp	isd2b

isd2a:
	mvi	c, 1		; format has only single sector

isd2b:
	inx	h
	inx	h
	inx	h
	mov	e, m
	inx	h
	mov	d, m
	xchg			; hl = buffer
	mvi	b, WDBC		; load wite data block command
	call	IOCCOM		; output the command
	call	iocrdy		; wait till slave is idle
	mov	a, c		; number of sectors to be written
	out	IOCO

wrlp1:
	push	psw
	mvi	d, 128		; sector length

wrlp2:
	call	iocrdy		; wait will slave is idle
	mov	a, m		; write the data byte
	out	IOCO
	inx	h		; advance buffer
	dcr	d
	jnz	wrlp2
	pop	psw		; number of sectors
	dcr	a
	jnz	wrlp1		; loop till all written
	mvi	a, ENABL	; enable interrupts
	out	CPUC

isd3:
	pop	h		; hl = iopb
	call	triopb		; send the iopb
	ret

;------
iocrdy:	in	IOCS		; get the status
	ani	F0 or OBF or IBF; look till ready
	jnz	iocrdy
	ret

;***************************************************************
;* Procedure name: TRIOPB (transmit IOPB to ISD)
;* Process: Transmit the IOPB to the 8271 integrated single density
;*	    controller this procedure is called only bu procedure ISDDR
;* Input: HL contains address of the IOPB
;* Output: Transmit the IOPB
;*	   HL points to SADR of IOPB
;* Modified: A, FLAGS, B, C, D, HL
; *
;***************************************************************
triopb:				; transfer$iopb$to$isd
	mov	c, m		; the iocw 
	mvi	b, WPBC		; issue first byte
	call	IOCDR2
	mvi	d, 4		; send the remaining 4 bytes

trloop:
	inx	h		
	mov	c, m
	mvi	b, WPCC
	call	IOCDR2
	dcr	d
	jnz	trloop

trwait:	call	dkstat		; see if the bit indicating operation
	ani	4		; compete is set
	jz	trwait		; loop until done
	ret

	end;

jmpto.asm
	CSEG
	public	jmpto
;	
;	jmpto: PROCEDURE(entry, sysstk) PROCEDURE PUBLIC;
;		STACKPTR = sysstk;
;		goto entry;
;	end;
jmpto:	xchg
	sphl
	mov	h,b
	mov	l,c
	pchl
	end;

trap0b.asm
	CSEG
	public	trap0B
	extrn	vec0B

trap0B:	jmp	vec0B
	end

trap.asm

	CSEG
	public	trap
trap:			; exit via mds monitor
	pop	h	; waste the return address
	jmp	0
	end

fnddir.asm

	CSEG
	public	fndDir
	public	dnum
	extrn	dirPtr
	extrn	fndFre
	extrn	inoPtr


; fndDir: PROCEDURE(fname, datum) PUBLIC BYTE; DECLARE fname ADDRESS, datum ADDRESS; END;

; direct.empty flag values
OPEN	equ	0
FREE	equ	0ffh
UNUSED	equ	07fh;

datum:	dw	0
dnum:	dw	0	

fndDir:
	xchg		; hl = datum
	mvi	e, 8	; 8 directory entries to match

dloop:
	shld	datum	; save passed in fn
	mov	a, m	; empty
	cpi	UNUSED	; never	used
	jz	skip
	ora	a
	jnz	skip	; 0 if open
	mvi	d, 9	; compare file names
	push	b	; save start of filename to match

cmpnam:
	inx	h
	ldax	b
	cmp	m
	jnz	nomat
	inx	b
	dcr	d
	jnz	cmpnam
	pop	b	; passed in filename
	mvi	d, 10h	; size of directory entry
	lhld	dirPtr	; copy the matched directory entry
	push	h
	pop	b
	lhld	datum

cpydir:	
	mov	a, m
	stax	b
	inx	h
	inx	b
	dcr	d
	jnz	cpydir
	call	setino
	mvi	a, FREE
	ret

skip:
	push	psw
	call	chk1st
	pop	psw
	rz			; return if never used,	shouldn't be any more after this
	push	b		; re-push filename to use common code

nomat:				; didn't match	
	pop	b		; restore filename
	lhld	dnum		; next dnum
	inx	h
	shld	dnum
	push	d		; save iteration count
	lxi	d, 10h		; next dir entry
	lhld	datum
	dad	d
	pop	d		; restore iteration count
	dcr	e		; we only have 8 directory entries in a buffer
	jnz	dloop
	xra	a		; not found in this dir	block
	ret

; end of fndDir

chk1st:
	lda	fndFre		; see if first free slot found
	ora	a
	rnz			; no then don't update
	cma			; mark as 1st now found
	sta	fndFre

setino:				; copy dnum of this slot either match or 1st free
	push	h
	push	d
	lhld	dnum
	xchg
	lhld	inoPtr
	mov	m, e
	inx	h
	mov	m, d
	pop	d
	pop	h
	ret

	end

memck.asm
	CSEG
	public	memck
memck:		
	call	0F81BH
	mov	h, b
	mov	l, a
	ret

	end


