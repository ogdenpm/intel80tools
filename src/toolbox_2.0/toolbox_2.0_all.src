csd/chklod.csd
;----------------------------CHKLOD.GSD-----------------------------;
NOTE CHKLOD

PLM80 %0CHKLOD.P80 SET(%1VERSION)
STOPIF %0CHKLOD.LST
PLM80 %0CINVOK.P80
STOPIF %0CINVOK.LST
PLM80 %0CMOVEM.P80
STOPIF %0CMOVEM.LST
PLM80 %0CGREAT.P80
STOPIF %0CGREAT.LST
PLM80 %0CDIREC.P80
STOPIF %0CDIREC.LST
ASM80 %0CSORT2.A80
STOPIF %0CSORT2.LST

LINK %0CHKLOD.OBJ, %0CINVOK.OBJ, %0CMOVEM.OBJ, &
    %0CGREAT.OBJ, %0CSORT2.OBJ, %0CDIREC.OBJ, &
    %0FNAMES.LIB, %0UTIL.LIB, %0SYS.LIB, &
    %0SYSTEM.LIB, %0PLM80.LIB  &
    TO %0CHKLOD.LNK

LOCATE %0CHKLOD.LNK TO %0CHKLOD PURGE

;--------------------------END CHKLOD.GSD---------------------------;
csd/clean.csd
;---------------------------CLEAN.GSD---------------------------;
NOTE CLEAN

PLM80 %0CLEAN.P80 SET(%1VERSION)
STOPIF %0CLEAN.LST

LINK %0CLEAN.OBJ, %0SYSTEM.LIB, %0PLM80.LIB  &
    TO %0CLEAN.LNK

LOCATE %0CLEAN.LNK TO %0CLEAN PURGE

;-------------------------END CLEAN.GSD-------------------------;
csd/compar.csd
;----------------------------COMPAR.GSD--------------------------;
NOTE COMPAR

PLM80 %0COMPAR.P80 SET(%1VERSION)
STOPIF %0COMPAR.LST
PLM80 %0TAIL.P80 SET(%1VERSION)
STOPIF %0TAIL.LST
PLM80 %0OUT.P80
STOPIF %0OUT.LST
ASM80 %0M3.A80
STOPIF %0M3.LST
ASM80 %0DIVIDE.A80
STOPIF %0DIVIDE.LST

LINK %0COMPAR.OBJ, %0TAIL.OBJ, %0OUT.OBJ,  &
    %0M3.OBJ, %0DIVIDE.OBJ, &
    %0SYSTEM.LIB, %0PLM80.LIB  &
    TO %0COMPAR.LNK

LOCATE %0COMPAR.LNK TO %0COMPAR PURGE

;--------------------------END COMPAR.GSD------------------------;
csd/consol.csd
;------------------------CONSOL.CSD------------------------;
NOTE CONSOL

PLM80 %0CONSOL.P80 SET(%1VERSION)
STOPIF %0CONSOL.LST

LINK %0CONSOL.OBJ, %0CUSP5.LIB,  &
    %0PLM80.LIB, %0SYSTEM.LIB  &
    TO %0CONSOL.LNK

LOCATE %0CONSOL.LNK TO %0CONSOL PURGE

;----------------------END CONSOL.CSD----------------------;
csd/dcopy.csd
;---------------------------DCOPY.CSD---------------------------;
NOTE DCOPY

PLM80 %0DCOPY.P80 SET(%1VERSION)
STOPIF %0DCOPY.LST

LINK %0DCOPY.OBJ, %0SYSTEM.LIB, &
    %0CUSP5.LIB, %0PLM80.LIB TO %0DCOPY.LNK

LOCATE %0DCOPY.LNK TO %0DCOPY PURGE

;-------------------------END DCOPY.CSD-------------------------;
csd/dsort.csd
;-----------------------------DSORT.GSD-------------------------------;
NOTE DSORT

PLM80 %0DSORT.P80 SET(%1VERSION)
STOPIF %0DSORT.LST

LINK %0DSORT.OBJ, %0CUSP6.LIB,  &
    %0SYSTEM.LIB, %0PLM80.LIB  &
    TO %0DSORT.LNK

LOCATE %0DSORT.LNK TO %0DSORT PURGE

;---------------------------END DSORT.GSD-----------------------------;
csd/else.csd
;----------------------------ELSE.GSD----------------------------;
NOTE ELSE

PLM80 %0ELSE.P80 SET(%1VERSION)
STOPIF %0ELSE.LST

LINK %0ELSE.OBJ, %0CUSP8.LIB, &
    %0SYSTEM.LIB, %0PLM80.LIB  &
    TO %0ELSE.LNK

LOCATE %0ELSE.LNK TO %0ELSE PURGE

;--------------------------END ELSE.GSD--------------------------;
csd/endif.csd
;---------------------------ENDIF.CSD---------------------------;
NOTE ENDIF

PLM80 %0ENDIF.P80 SET(%1VERSION)
STOPIF %0ENDIF.LST

LINK %0ENDIF.OBJ,  &
    %0SYSTEM.LIB, %0PLM80.LIB  &
    TO %0ENDIF.LNK

LOCATE %0ENDIF.LNK TO %0ENDIF PURGE

;-------------------------END ENDIF.CSD-------------------------;
csd/errs.csd
;---------------------------ERRS.CSD---------------------------;
NOTE ERRS

PLM80 %0ERRS.P80 SET(%1VERSION)
STOPIF %0ERRS.LST

LINK %0ERRS.OBJ, &
    %0UTIL.LIB, %0SYS.LIB, %0PLM80.LIB  &
    TO %0ERRS.LNK

LOCATE %0ERRS.LNK TO %0ERRS PURGE

;-------------------------END ERRS.CSD-------------------------;
csd/exit.csd
;----------------------------EXIT.GSD----------------------------;
NOTE EXIT

PLM80 %0EXIT.P80 SET(%1VERSION)
STOPIF %0EXIT.LST

LINK %0EXIT.OBJ,  &
    %0SYSTEM.LIB, %0PLM80.LIB  &
    TO %0EXIT.LNK

LOCATE %0EXIT.LNK TO %0EXIT  PURGE

;--------------------------END EXIT.GSD--------------------------;
csd/ganef.csd
;---------------------------GANEF.CSD---------------------------;
NOTE GANEF

PLM80 %0GANEF.P80 SET(%1VERSION)
STOPIF %0GANEF.LST

LINK %0GANEF.OBJ,  &
    %0CUSP2.LIB, %0SYSTEM.LIB, %0PLM80.LIB  &
    TO %0GANEF.LNK

LOCATE %0GANEF.LNK TO %0GANEF PURGE

;-------------------------END GANEF.CSD-------------------------;
csd/genpex.csd
;---------------------------GENPEX.CSD---------------------------;
NOTE GENPEX

PLM80 %0GENPEX.P80 SET(%1VERSION)
STOPIF %0GENPEX.LST

LINK %0GENPEX.OBJ,  &
    %0FNAMES.LIB, %0UTIL.LIB, %0SYS.LIB, %0PLM80.LIB  &
    TO %0GENPEX.LNK

LOCATE %0GENPEX.LNK TO %0GENPEX PURGE

;-------------------------END GENPEX.CSD-------------------------;
csd/goto.csd
;----------------------------GOTO.GSD----------------------------;
NOTE GOTO

PLM80 %0GOTO.P80 SET(%1VERSION)
STOPIF %0GOTO.LST

LINK %0GOTO.OBJ, %0CUSP8.LIB,  &
    %0SYSTEM.LIB, %0PLM80.LIB  &
    TO %0GOTO.LNK

LOCATE %0GOTO.LNK TO %0GOTO  PURGE

;--------------------------END GOTO.GSD--------------------------;
csd/gtolbx.csd
;gtolbx.csd
;
; all tools are generated with:
;  PLM80 V4.0     LINK   V3.0
;  ASM80 V4.1     LOCATE V3.0
;
; parm 0: source, libraries device = %0
; parm 1: "X" or "V" version = %1
; parm 2: CSD files device = %2
;
consol , %2gtolbx.out
submit %2CHKLOD(%0,%1)
submit %2CLEAN(%0,%1)
submit %2COMPAR(%0,%1)
submit %2CONSOL(%0,%1)
submit %2DCOPY(%0,%1)
submit %2DSORT(%0,%1)
submit %2ELSE(%0,%1)
submit %2ENDIF(%0,%1)
submit %2ERRS(%0,%1)
submit %2EXIT(%0,%1)
submit %2GANEF(%0,%1)
submit %2GENPEX(%0,%1)
submit %2GOTO(%0,%1)
submit %2HDBACK(%0,%1)
submit %2IF(%0,%1)
submit %2LAST(%0,%1)
submit %2LATEST(%0,%1)
submit %2LOOP(%0,%1)
submit %2LOWER(%0,%1)
submit %2MERG80(%0,%1)
submit %2MERG86(%0,%1)
submit %2MRKOBJ(%0,%1)
submit %2NOTE(%0,%1)
submit %2PACK(%0,%1)
submit %2PASSIF(%0,%1)
submit %2RELAB(%0,%1)
submit %2RESCAN(%0,%1)
submit %2RETURN(%0,%1)
submit %2SORT(%0,%1)
submit %2STOPIF(%0,%1)
submit %2UNPACK(%0,%1)
submit %2UPPER(%0,%1)
submit %2WAIT(%0,%1)
submit %2WHICH(%0,%1)
submit %2XLATE2(%0,%1)
consol , :vo:
csd/hdback.csd
;-------------------------HDBACK.CSD--------------------------;
NOTE HDBACK

PLM80 %0HDBACK.P80 SET(%1VERSION)
STOPIF %0HDBACK.LST
PLM80 %0HDFILS.P80
STOPIF %0HDFILS.LST

LINK %0HDBACK.OBJ, %0HDFILS.OBJ, %0UTIL.LIB, &
    %0PLM80.LIB, %0SYSTEM.LIB   &
    TO %0HDBACK.LNK

LOCATE %0HDBACK.LNK TO %0HDBACK PURGE

;-----------------------END HDBACK.CSD------------------------;
csd/if.csd
;----------------------------IF.GSD----------------------------;
NOTE IF

PLM80 %0IF.P80 SET(%1VERSION)
STOPIF %0IF.LST

LINK %0IF.OBJ, %0CUSP8.LIB, &
    %0SYSTEM.LIB, %0PLM80.LIB  &
    TO %0IF.LNK

LOCATE %0IF.LNK TO %0IF PURGE

;--------------------------END IF.GSD--------------------------;
csd/last.csd
;---------------------------LAST.CSD---------------------------;
NOTE LAST

PLM80 %0LAST.P80 SET(%1VERSION)
STOPIF %0LAST.LST

LINK %0LAST.OBJ,  &
    %0UTIL.LIB, %0SYS.LIB, %0SYSTEM.LIB, %0PLM80.LIB  &
    TO %0LAST.LNK

LOCATE %0LAST.LNK TO %0LAST  PURGE

;-------------------------END LAST.CSD-------------------------;
csd/latest.csd
;---------------------------LATEST.GSD---------------------------;
NOTE LATEST

PLM80 %0LATEST.P80 SET(%1VERSION)
STOPIF %0LATEST.LST

LINK %0LATEST.OBJ, %0UTIL.LIB, %0SYS.LIB, &
    %0SYSTEM.LIB, %0PLM80.LIB   &
    TO %0LATEST.LNK

LOCATE %0LATEST.LNK TO %0LATEST PURGE

;-------------------------END LATEST.GSD-------------------------;
csd/loop.csd
;-------------------------LOOP.CSD---------------------------;
NOTE LOOP

PLM80 %0LOOP.P80 SET(%1VERSION)
STOPIF %0LOOP.LST

LINK %0LOOP.OBJ,  &
    %0SYSTEM.LIB, %0PLM80.LIB  &
    TO %0LOOP.LNK

LOCATE %0LOOP.LNK TO %0LOOP PURGE

;-----------------------END LOOP.CSD-------------------------;
csd/lower.csd
;---------------------------LOWER.CSD---------------------------;
NOTE LOWER

PLM80 %0LOWER.P80 SET(%1VERSION)
STOPIF %0LOWER.LST

LINK %0LOWER.OBJ,  &
    %0UNIXIO.LIB, %0SYSTEM.LIB, %0PLM80.LIB  &
    TO %0LOWER.LNK

LOCATE %0LOWER.LNK TO %0LOWER PURGE

;-------------------------END LOWER.CSD-------------------------;
csd/merg80.csd
;---------------------------MERG80.CSD---------------------------;
NOTE MERG80

PLM80 %0MERG80.P80 SET(%1VERSION)
STOPIF %0MERG80.LST
ASM80 %0BLTSYM.A80
STOPIF %0BLTSYM.LST
ASM80 %0SORT2.A80
STOPIF %0SORT2.LST

LINK %0MERG80.OBJ, %0BLTSYM.OBJ, %0SORT2.OBJ, &
    %0FNAMES.LIB, %0UTIL.LIB, %0SYS.LIB, &
    %0PLM80.LIB TO %0MERG80.LNK

LOCATE %0MERG80.LNK TO %0MERG80 PURGE

;-------------------------END MERG80.CSD-------------------------;
csd/merg86.csd
;----------------------------MERG86.GSD--------------------------;
NOTE MERG86

PLM80 %0MERG86.P80 SET(%1VERSION)
STOPIF %0MERG86.LST
ASM80 %0BSYM86.A80
STOPIF %0BSYM86.LST
ASM80 %0SORT2.A80
STOPIF %0SORT2.LST

LINK %0MERG86.OBJ, %0BSYM86.OBJ, %0SORT2.OBJ, &
    %0FNAMES.LIB, %0UTIL.LIB, %0SYS.LIB, &
    %0PLM80.LIB TO %0MERG86.LNK

LOCATE %0MERG86.LNK TO %0MERG86 PURGE

;--------------------------END MERG86.GSD------------------------;
csd/mrkobj.csd
;---------------------------MRKOBJ.GSD------------------------------;
NOTE MRKOBJ

PLM80 %0MRKOBJ.P80 SET(%1VERSION)
STOPIF %0MRKOBJ.LST
PLM80 %0MINVOK.P80
STOPIF %0MINVOK.LST
PLM80 %0MFILER.P80
STOPIF %0MFILER.P80

LINK %0MRKOBJ.OBJ, %0MINVOK.OBJ, %0MFILER.OBJ, &
    %0FNAMES.LIB, %0UTIL.LIB, %0SYS.LIB, %0PLM80.LIB  &
    TO %0MRKOBJ.LNK

LOCATE %0MRKOBJ.LNK TO %0MRKOBJ PURGE

;-------------------------END MRKOBJ.GSD----------------------------;
csd/note.csd
;----------------------------NOTE.GSD----------------------------;
NOTE NOTE

PLM80 %0NOTE.P80 SET(%1VERSION)
STOPIF %0NOTE.LST

LINK %0NOTE.OBJ,  &
    %0SYSTEM.LIB, %0PLM80.LIB  &
    TO %0NOTE.LNK

LOCATE %0NOTE.LNK TO %0NOTE PURGE

;--------------------------END NOTE.GSD--------------------------;
csd/pack.csd
;---------------------------PACK.CSD------------------------;
NOTE PACK

PLM80 %0PACK.P80 SET(%1VERSION)
STOPIF %0PACK.LST
PLM80 %0PACKER.P80
STOPIF %0PACKER.LST

LINK %0PACK.OBJ, %0PACKER.OBJ, %0CUSP6.LIB, &
    %0PLM80.LIB, %0SYSTEM.LIB  &
    TO %0PACK.LNK

LOCATE %0PACK.LNK TO %0PACK PURGE

;-------------------------END PACK.CSD----------------------;
csd/passif.csd
;-------------------------PASSIF.GSD------------------------;
NOTE PASSIF

PLM80  %0PASSIF.P80 SET(%1VERSION)
STOPIF %0PASSIF.LST
PLM80  %0CLI.P80 SET(%1VERSION)
STOPIF %0CLI.LST
PLM80  %0ERRMSG.P80
STOPIF %0ERRMSG.LST
PLM80  %0FUNC.P80
STOPIF %0FUNC.LST
PLM80  %0REPORT.P80
STOPIF %0REPORT.LST
PLM80  %0TOKENS.P80
STOPIF %0TOKENS.LST

LINK %0PASSIF.OBJ, %0CLI.OBJ, %0ERRMSG.OBJ, &
    %0FUNC.OBJ, %0REPORT.OBJ, %0TOKENS.OBJ, &
    %0UTIL.LIB, %0SYSTEM.LIB, %0PLM80.LIB  &
    TO %0PASSIF.LNK

LOCATE %0PASSIF.LNK TO %0PASSIF PURGE

;-----------------------END PASSIF.GSD----------------------;
csd/relab.csd
;-------------------------RELAB.CSD---------------------------;
NOTE RELAB

PLM80 %0RELAB.P80 SET(%1VERSION)
STOPIF %0RELAB.LST

LINK %0RELAB.OBJ, &
    %0SYSTEM.LIB, %0PLM80.LIB  &
    TO %0RELAB.LNK

LOCATE %0RELAB.LNK TO %0RELAB PURGE

;-----------------------END RELAB---------------------------;
csd/rescan.csd
;---------------------------RESCAN.CSD---------------------------;
NOTE RESCAN

PLM80 %0RESCAN.P80 SET(%1VERSION)
STOPIF %0RESCAN.LST

LINK %0RESCAN.OBJ,  &
    %0PLM80.LIB, %0SYSTEM.LIB  &
    TO %0RESCAN.LNK

LOCATE %0RESCAN.LNK TO %0RESCAN  PURGE

;-------------------------END RESCAN.CSD-------------------------;
csd/return.csd
;----------------------------RETURN.GSD----------------------------;
NOTE RETURN

PLM80 %0RETURN.P80 SET(%1VERSION)
STOPIF %0RETURN.LST

LINK %0RETURN.OBJ, %0CUSP8.LIB, &
    %0SYSTEM.LIB, %0PLM80.LIB  &
    TO %0RETURN.LNK

LOCATE %0RETURN.LNK TO %0RETURN PURGE

;--------------------------END RETURN.GSD--------------------------;
csd/sort.csd
;---------------------------SORT.CSD---------------------------;
NOTE SORT

PLM80 %0SORT.P80 SET(%1VERSION)
STOPIF %0SORT.LST

LINK %0SORT.OBJ,  &
    %0SYSTEM.LIB, %0PLM80.LIB  &
    TO %0SORT.LNK

LOCATE %0SORT.LNK TO %0SORT PURGE

;-------------------------END SORT.CSD-------------------------;
csd/stopif.csd
;---------------------------STOPIF.GSD---------------------------;
NOTE STOPIF

PLM80 %0STOPIF.P80 SET(%1VERSION)
STOPIF %0STOPIF.LST IGNOREWARNING

LINK %0STOPIF.OBJ, &
    %0SYSTEM.LIB, %0PLM80.LIB  &
    TO %0STOPIF.LNK

LOCATE %0STOPIF.LNK TO %0STOPIF PURGE

;-------------------------END STOPIF.GSD-------------------------;
csd/unpack.csd
;--------------------------UNPACK.CSD------------------------;
NOTE UNPACK

PLM80 %0UNPACK.P80 SET(%1VERSION)
STOPIF %0UNPACK.LST
PLM80 %0UNPAKR.P80
STOPIF %0UNPAKR.LST

LINK %0UNPACK.OBJ, %0UNPAKR.OBJ, %0CUSP6.LIB, &
    %0PLM80.LIB, %0SYSTEM.LIB  &
    TO %0UNPACK.LNK

LOCATE %0UNPACK.LNK TO %0UNPACK PURGE

;------------------------END UNPACK.CSD----------------------;
csd/upper.csd
;---------------------------UPPER.CSD---------------------------;
NOTE UPPER

PLM80 %0UPPER.P80 SET(%1VERSION)
STOPIF %0UPPER.LST

LINK %0UPPER.OBJ,  &
    %0UTIL.LIB, %0SYS.LIB, %0SYSTEM.LIB,  %0PLM80.LIB  &
    TO %0UPPER.LNK

LOCATE %0UPPER.LNK TO %0UPPER  PURGE

;-------------------------END UPPER.CSD-------------------------;
csd/wait.csd
;----------------------------WAIT.GSD----------------------------;
NOTE WAIT

PLM80 %0WAIT.P80 SET(%1VERSION)
STOPIF %0WAIT.LST

LINK %0WAIT.OBJ,  &
    %0SYSTEM.LIB, %0PLM80.LIB  &
    TO %0WAIT.LNK

LOCATE %0WAIT.LNK TO %0WAIT PURGE

;--------------------------END WAIT.GSD--------------------------;
csd/which.csd
;-----------------------WHICH.GSD---------------------------;
NOTE WHICH

PLM80 %0WHICH.P80 SET(%1VERSION)
STOPIF %0WHICH.LST

LINK %0WHICH.OBJ,  &
    %0SYSTEM.LIB, %0PLM80.LIB  &
    TO %0WHICH.LNK

LOCATE %0WHICH.LNK TO %0WHICH PURGE

;---------------------END WHICH.GSD-------------------------;
csd/xlate2.csd
;-------------------------------XLATE2.GSD----------------------------;
NOTE XLATE2

PLM80 %0XLATE2.P80 SET(%1VERSION)
STOPIF %0XLATE2.LST

LINK %0XLATE2.OBJ, %0UTIL.LIB, %0SYS.LIB, &
    %0SYSTEM.LIB, %0PLM80.LIB  &
    TO %0XLATE2.LNK

LOCATE %0XLATE2.LNK TO %0XLATE2 PURGE

;-----------------------------END XLATE2.GSD--------------------------;
cusp2/cusp2_all.src
?absio.plm
ABSIO: DO;
/* b1=01, b2=10, CODE(3DH) byte, DATA(DH) byte, STACK(4H) byte, MEMORY(0H) byte,*/
DECLARE DCB$T LITERALLY 'STRUCTURE (iocw BYTE, ioins BYTE, nsec BYTE, tadr BYTE, sadr BYTE, buf ADDRESS)';

diskio: procedure(disk, dcb$ptr) external; declare (disk, dcb$ptr) address; end;

absio: procedure(cmd, disk, block, buffer) public;
	declare (cmd, disk) byte, (block, buffer) address;
	declare dcb DCB$T;

	dcb.iocw = 80H;
	dcb.ioins = cmd;
	dcb.nsec = 1;
	dcb.tadr = high(block);
	dcb.sadr = low(block);
	dcb.buf = buffer;
	call diskio(disk, .dcb);
end;
end;
?alloc.plm
ALLOC: DO;
/* b1=01, b2=10, CODE(8H) byte, DATA(10DH) byte, STACK(0H) byte, MEMORY(0H) byte,*/
DECLARE DCB$T LITERALLY 'STRUCTURE (iocw BYTE, ioins BYTE, nsec BYTE, tadr BYTE, sadr BYTE, buf ADDRESS)';

declare
	bitmap(256) byte public,
	currentBitmap byte public initial(0ffh),
	mapChange byte public initial(0),
	lastBlock address public,
	(lastSector, lastTrack) byte public at (.lastBlock),
	lastCounter address public,
	mapDcb DCB$T initial(80H, 0, 2, 2, 2, 0),	/* I suspect this should be public */
	maskArray(*) byte public data(80H, 40H, 20H, 10H, 8, 4, 2, 1);
end;

?clrbuf.plm
CLEARBUF: DO;
/* b1=01, b2=10, CODE(28H) byte, DATA(3H) byte, STACK(0H) byte, MEMORY(0H) byte,*/

clearbuf: procedure(buf$ptr) public;
	declare buf$ptr address, i byte,
		buf based buf$ptr (1) byte;

	do i = 0 to 127;
		buf(i) = 0;
	end;
end;
end;

?d.plm
D: DO;
/* b1=01, b2=10, CODE(595H) byte, DATA(133H) byte, STACK(8H) byte, MEMORY(0H) byte,*/
open: procedure (conn$p, path$p, access, echo, status$p) external;
    declare (conn$p, path$p, access, echo, status$p) address;
end open;

read: procedure (conn, buff$p, count, actual$p, status$p) external;
    declare (conn, buff$p, count, actual$p, status$p) address;
end read;

write: procedure (conn, buff$p, count, status$p) external;
    declare (conn, buff$p, count, status$p) address;
end write;

close: procedure (conn, status$p) external;
    declare (conn, status$p) address;
end close;

delimit: procedure(ptr) address external; declare ptr address; end;

numout: procedure(val, base, lc, bufAdr, width) external;
	declare (val, bufAdr) address, (base, lc, width) byte;
end;

meq: procedure(mPtr, fPtr) byte external ; declare (mPtr,fPtr) address; end;
unpath:	procedure(int, ext) external; declare (int, ext) address; end;
deblank: procedure(ptr) address external; declare ptr address; end;

declare direct structure(status byte, name(6) byte, ext(3) byte, attributes byte,
			 byte$in$lastblk byte, blksUsed address,
			 linkSec byte, linkTrk byte) external;
declare directIno address external;

population: procedure(bufferLoc, cnt) address external;
	declare bufferLoc address, cnt byte;
end;

declare isisMapFile(*) byte data(':F :ISIS.MAP '),
	mapDrive byte at (.isisMapFile(2)),
	isisLabFile(*) byte data(':F :ISIS.LAB '),
	labDrive byte at (.isisLabFile(2)),
	isisDirFile(*) byte data(':F :ISIS.DIR '),
	dirDrive byte at (.isisDirFile(2)),
	CRLF(*) byte data(0DH, 0AH),
	blksUsedMsg(*) byte data('XXXX/2002 BLOCKS USED', 0DH, 0AH),
	dirOfMsg(*) byte data('DIRECTORY OF '),
	dirHeader(*) byte data('NAME  .EXT BLKS   LENGTH ATTR', 0DH, 0AH);

D: procedure(drive, conn, arg3b, arg4b, arg5w) public;
	declare (drive, conn, arg3b, arg4b) byte, arg5w address;
	declare	(dconn, status, actual, unused)	address,
		(sectUsed, highFileSize, lowFileSize) address,
		totalSectUsed address,
		mapBuf(251) byte,
		strbuf(15) byte,
		path(15) byte,
		(i, j) byte;

	bigAdd: procedure(arg1w);
		declare arg1w address;
		lowFileSize = lowFileSize + arg1w;
		if lowFileSize > 9999 then
		do;
			lowFileSize = lowFileSize - 10000;
			highFileSize = highFileSize + 1;
		end;
	end;	


	totalSectUsed = 0;
	mapDrive, labDrive, dirDrive = drive + '0';
	call open(.dconn, .isisLabFile, 1, 0, .status);
	strbuf(0) = drive;
	call read(dconn, .strbuf(1), 9, .actual, .status);
	call write(conn, .dirOfMsg, size(dirOfMsg), .status);
	call unpath(.strbuf, .path);
	i = delimit(.path) - .path;
	call write(conn, .path, i, .status);
	call write(conn, .CRLF, 2, .status);
	call close(dconn, .status);
	if (not arg3b) + 0 then	/* + 0 to trick the optimiser */
		call write(conn, .dirHeader, size(dirHeader), .status);
	call open(.dconn, .isisDirFile, 1, 0, .status);
	actual = 16;
	direct.status = actual;
	do while actual = double(16) and direct.status <> 07FH;
		call read(dconn, .direct, 16, .actual, .status);
		if actual = double(16) and (not direct.status) and
		   ((direct.attributes and 1) = 0 or arg4b) and
		   meq(arg5w, .direct) then
		   do;
			do i = 0 to 8;
				if direct.name(i) = 0 then
					direct.name(i) = ' ';
			end;
			i = 9;
			if arg3b then	
				do while direct.name(i - 1) = ' ';
					i = i - 1;
				end;
			if not arg3b or i > 6 then
				j = 6;
			else
				j = i;	
			call write(conn, .direct.name, j, .status);
			if arg3b then
			do;
				if i > 6 then
				do;
					call write(conn, .('.'), 1, .status);
					call write(conn, .direct.ext, i - 6, .status);
				end;
			end;
			else
			do;
				if direct.ext(0) <> ' ' then
					call write(conn, .('.'), 1, .status);
				call write(conn, .direct.ext, 3, .status);
				if direct.ext(0) = ' ' then
					call write(conn, .(' '), 1, .status); 
				sectUsed = direct.blksUsed;
x: /* force optimiser to reload sectUsed */
				if sectUsed > 0 then	/* add in link sectors used */
					sectUsed = sectUsed + (sectUsed + 61) / 62;
				else
					sectUsed = 1;	/* has at least one link sector */
				totalSectUsed = totalSectUsed + sectUsed;
				call numout(sectUsed, 10, ' ', .strbuf, 5);
				call write(conn, .strbuf, 5, .status);
				sectUsed = direct.blksUsed;
				lowFileSize, highFileSize = 0;
				if sectUsed > 0 then
				do;
					sectUsed = sectUsed - 1;
					call bigAdd(direct.byte$in$lastblk);
					do while sectUsed > 0;
						sectUsed = sectUsed - 1;
						call bigAdd(128);
					end;
				end;
				if highFileSize <> 0 then
				do;
					call numout(highFileSize, 10, ' ', .strbuf, 5);
					call numout(lowFileSize, 10, '0', .strbuf(5), 4);
				end;
				else
					call numout(lowFileSize, 10, ' ', .strbuf, 9);
				call write(conn, .strbuf, 9, .status);
				if direct.attributes <> 0 then
				do;
					do i = 0 to 4;
						strbuf(i) = ' ';
					end;
					if (direct.attributes and 4) <> 0 then
						strbuf(1) = 'W';
					if (direct.attributes and 2) <> 0 then
						strbuf(2) = 'S';
					if (direct.attributes and 1) <> 0 then
						strbuf(3) = 'I';
					if (direct.attributes and 80h) <> 0 then
						strbuf(4) = 'F';
					call write(conn, .strbuf, 5, .status);
				end;
			end;
			call write(conn, .CRLF, 2, .status);
		end;
	end;

	call close(dconn, .status);
	if (not arg3b) + 0 then
	do;
		call numout(totalSectUsed, 10, ' ', .strbuf, 15);
		call write(conn, .strbuf, 15, .status);
		call write(conn, .CRLF, 2, .status);
	end;
	call open(.dconn, .isisMapFile, 1, 0, .status);
	call read(dconn, .mapBuf, 251, .actual, .status);
	call numout(population(.mapBuf, 251), 10, 0, .blksUsedMsg, 4);
	call write(conn, .blksUsedMsg, 23, .status);
	call close(conn, .status);
end;
end;

?dblank.plm
DEBLANK: DO;
/* b1=01, b2=10, CODE(1DH) byte, DATA(2H) byte, STACK(0H) byte, MEMORY(0H) byte,*/
deblank: procedure(str) address public;
	declare str address;
	declare c based str byte;

	do while (c = ' ');
		str = str + 1;
	end;
	return str;
end;

end;
?direct.plm
DIRECT: DO;
/* b1=01, b2=10, CODE(0H) byte, DATA(11H) byte, STACK(0H) byte, MEMORY(0H) byte,*/
declare	DIRECT(16) byte public,
	DIRECTINO byte public;
end;


?diskio.plm
DISKIO: DO;
/* b1=01, b2=10, CODE(1FH) byte, DATA(8H) byte, STACK(2H) byte, MEMORY(0H) byte,*/
isis: procedure(syscmd, param$p) external; declare syscmd byte, param$p address; end;

diskio: procedure(disk, dcb$p) public;
	declare (disk, dcb$p) address; 
	declare param structure(disk address, dcb$p address);
	
	param.disk = disk;
	param.dcb$p = dcb$p;
	call isis(44H, .param);
end;
end;
?dlimit.plm
DELIMIT: DO;
/* b1=01, b2=10, CODE(4FH) byte, DATA(2H) byte, STACK(4H) byte, MEMORY(0H) byte,*/
delimit: procedure(ptr) address public;
	declare ptr address, ch based ptr byte;

	do while ch = ':' or ch = '.' or
		 ('0' <= ch and ch <= '9') or
		 ('A' <= ch and ch <= 'Z');
		ptr = ptr + 1;
	end;
	return ptr;
end;
end;
?dmeq.plm
DMEQ: DO;
/* b1=01, b2=10, CODE(B0H) byte, DATA(11H) byte, STACK(8H) byte, MEMORY(0H) byte,*/
declare TRUE	literally '0FFH',
	FALSE	literally '0';

read: procedure (conn, buff$p, count, actual$p, status$p) external;
    declare (conn, buff$p, count, actual$p, status$p) address;
end read;

seek: procedure (conn, mode, block$p, byte$p, status$p) external;
    declare (conn, mode, block$p, byte$p, status$p) address;
end seek;

meq: procedure(A, B) byte external ; declare (A,B) address; end;

dmeq: procedure (dir$aftn, search$arg, initial$i$no, dir$entry) byte public;
    declare dir$aftn byte, (search$arg, initial$i$no, dir$entry) address;
    declare (byteNo, blockNo, actual, status) address;
    declare (pad, searching) byte;
    declare dirFlag based dir$entry byte;

	blockNo = 0;
	byteNo = initial$i$no * 16;
	call seek(dir$aftn, 2, .blockNo, .byteNo, .status);

	searching = TRUE;
	do while searching;
		call read(dir$aftn, dir$entry, 16, .actual, .status);
		searching = not meq(search$arg, dir$entry);
		initial$i$no = initial$i$no + 1;
		if dirFlag = 7Fh or actual = 0 then
		do;
			initial$i$no = 201;
			searching = FALSE;
		end;
	end;
		
	return initial$i$no;
end;
/* native plm80 v1.0 inlines @P0101 here */
end;
?filerr.plm
FILEERROR: DO;

/* b1=01, b2=10, CODE(8EH) byte, DATA(7H) byte, STACK(6H) byte, MEMORY(0H) byte,*/
write: procedure (conn, buff$p, count, actual$p) external;
    declare (conn, buff$p, count, actual$p) address;
end write;

exit: procedure external; end exit;

deblank: procedure(str) address external; declare str address; end;
scanblank: procedure(ptr) address external; declare ptr address; end;
reporterror: procedure(status) external; declare status address; end;

fileerror: procedure(status, ptr, callExit) public;
	declare (status, ptr) address, callExit byte;
	declare actual address;

	if status <> 0 then
	do;
		ptr = deblank(ptr);
		call write(0, .(' '), 1, .actual);
		call write(0, ptr, scanblank(ptr) - ptr, .actual);
		call write(0, .(','), 1, .actual);
		call reporterror(status);
		if callExit then
			call exit;
	end;
end;
/* native plm v1.0 inlines @P0095 and @P0101 here */ 
end;
?fmttrk.plm
FORMATTRACK: DO;
/* b1=01, b2=10, CODE(128H) byte, DATA(42H) byte, STACK(4H) byte, MEMORY(0H) byte,*/

diskio: procedure(disk, dcb$p) external; declare disk address, dcb$p address; end;

formatTrack: procedure(disk,sTrack,eTrack,interleave) public;
	declare (disk,sTrack,eTrack,interleave) byte;
	declare (i,j,k) byte, trackBuf(52) byte,
	dcb structure(iocw byte, ioins byte, nsec byte, tadr byte, sadr byte, buf address);


	dcb.iocw = 0c0h;
	dcb.ioins = 2;
	
	do i = 1 to 51 by 2;
		trackBuf(i) = 0c7h;	
	end;
	j = 0;
	do k = sTrack to eTrack;
		do i = 0 to 51 by 2;
			trackBuf(i) = 0;
		end;
		do i = 1 to 26;
			j = (j + interleave) mod 26;
			do while trackBuf(j + j) <> 0;
				j = (j + 1) mod 26;
			end;
			trackBuf(j + j) = i;
		end;
		dcb.tadr = k;
		dcb.buf = .trackBuf;
		call diskio(disk, .dcb);
	end;
end;
/* native plm80 v1.0 inlines @P0029 here */
end;
?forupp.plm
FORCEUPPER: DO;
/* b1=01, b2=10, CODE(25H) byte, DATA(2H) byte, STACK(2H) byte, MEMORY(0H) byte,*/
declare CR literally '0DH';

uppercase: procedure(ch) byte external; declare ch byte; end;

forceupper: procedure(bufferPtr) public;
	declare bufferPtr address, ch based bufferPtr byte;

	do while ch <> CR;
		ch = uppercase(ch);
		bufferPtr = bufferPtr + 1;
	end;
end;
end;
?meq.plm
MEQ: DO;
/* b1=01, b2=10, CODE(50H) byte, DATA(5H) byte, STACK(2H) byte, MEMORY(0H) byte,*/

meq: procedure(mPtr, fptr) byte public;
	declare (mPtr, fptr) address;
	declare m based mPtr (10) byte;
	declare f based fptr (10) byte;
	declare i byte;

	do i = 0 to 9;
		if m(i) <> '?' then
		do;
			if m(i) <> f(i) then
				return 0;
		end;
	end;
	return 0ffh;
end;
end;

?monitr.plm
MONITOR: DO;
/* b1=01, b2=10, CODE(28H) byte, DATA(2H) byte, STACK(0H) byte, MEMORY(0H) byte,*/
MONITOR: procedure public;
	declare sp address, wrd based sp address;
	sp = STACKPTR;
x: /* force reload of sp */
	wrd = 8;	
	STACKPTR = STACKPTR  - 2;
	sp = STACKPTR;
y: /* force reload of sp */
	wrd = 0;
end;
end;
?mvasci.plm
MOVEASCII: DO;
/* b1=01, b2=10, CODE(3FH) byte, DATA(6H) byte, STACK(2H) byte, MEMORY(0H) byte,*/
moveascii: procedure(dst, src, cnt) public;
	declare (dst, src) address, cnt byte, i byte;
	declare dch based dst (1) byte, sch based src (1) byte;

	do i = 0 to cnt - 1;
		dch(i) = sch(i);
	end;
end;
end;
?numout.plm
NUMOUT: DO;
/* b1=01, b2=10, CODE(C9H) byte, DATA(8H) byte, STACK(6H) byte, MEMORY(0H) byte,*/

declare digits(*) byte data('0123456789ABCDEF');

numout: procedure(val, base, lc, bufAdr, width) public;
	declare (val, bufAdr) address, (base, lc, width) byte; 
	declare i byte;
	declare buf based bufAdr (1) byte;

	do i = 1 to width;
		buf(width - i) = digits(val mod base);
		val = val / base;	
	end;

	i = 0;
	do while buf(i) = '0' and i < width - 1;
		buf(i) = lc;
		i = i + 1;
	end;
end;
/* native plm80 v1.0 inlines @0029 here */
end;
?path.plm
PATH: DO;
/* b1=01, b2=10, CODE(245H) byte, DATA(1CH) byte, STACK(6H) byte, MEMORY(0H) byte,*/

uppercase: procedure(sch) byte external; declare sch byte; end;

declare devTab(*) byte data('F0F1F2F3TITOVIVOI1O1TRHRR1R2TPHPP1P2LPL1BBCICO');
declare lastpath(15) byte;

declare TRUE	literally '0ffh',
	FALSE	literally '0';

PATH: procedure(filename, pn) byte public;
	declare (filename, pn) address;
	declare pathPtr address, devPair address, (loByte, hiByte) byte at (.devPair),
		devPtr address, (noName, pl, i) byte;
	declare pnByte based pn (10) byte;
	declare fileChar based filename (1) byte, pathChar based pathPtr (1) byte;
	declare devTabPair based devPtr address;

	isFileNameChar: procedure byte;
		return 'A' <= fileChar(0) and fileChar(0) <= 'Z' or
		   '0' <= fileChar(0) and fileChar(0) <= '9' or
		   'a' <= fileChar(0) and fileChar(0) <= 'z';
	end;


	devPtr = .devTab;
	do i = 0 to 9;
		pnByte(i) = 0;
	end;
	do while fileChar(0) = ' ';
		filename = filename + 1;
	end;

	pathptr = filename;
	if pathChar(0) = ':' then
	do;
		pnByte(0) = 255;
		if fileChar(3) <> ':' then
			return 4;
		filename = filename + 1;
		loByte = uppercase(fileChar(0));
		filename = filename + 1;
		hiByte = uppercase(fileChar(0));
		filename = filename + 2;
		i = 0;
		do while i < last(devTab);
			if devTabPair =  devPair then
				pnByte(0) = shr(i, 1);
			i = i + 2;
			devPtr = devPtr + 2;
		end;
		if pnByte(0) = 255 then
			return 5;
	end;
	noName = TRUE;
	i = 1;
	do while i < 7;
		if isFileNameChar then
		do;
			pnByte(i) = uppercase(fileChar(0));
			filename = filename + 1;
			noName = FALSE;
		end;
		i = i + 1;
	end;
	if fileChar(0) = '.' then
	do;
		filename = filename + 1;
		i = 7;
		do while i < 10;
			if isFileNameChar then
			do;
				pnByte(i) = uppercase(fileChar(0));
				filename = filename + 1;
			end;
			i = i + 1;
		end;
	end;
	if pnByte(0) <= 3 and noName then
		return 17h;
	
	pl = 255;
	do while pathPtr < filename;
		lastpath(pl := pl + 1) = pathChar(0);
		pathPtr = pathPtr + 1;
	end;
	if lastpath(pl) = '.' then
		return 1ch;
	lastpath(pl + 1) = ' ';
	if isFileNameChar or fileChar(0) = '.' or fileChar(0) = ':' then
		return 4;
	return 0;
end;
/* native plm80 v1.0 inlines @P0098 and @P0099 here */
end;

?popula.plm
POPULATION: DO;
/* b1=01, b2=10, CODE(81H) byte, DATA(9H) byte, STACK(2H) byte, MEMORY(0H) byte,*/

declare bitCnt(*) byte data(0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4);


population: procedure(bufferLoc, cnt) address public;
	declare bufferLoc address, cnt byte;
	declare total address, lowNibble byte, highNibble byte,
		(i, lastByte) byte;
	declare buffer based bufferLoc (1) byte;

	total = 0;
	lastByte = cnt - 1;
	do i = 0 to lastByte;
		lowNibble = buffer(i) and 0fh;		
		highNibble = ror(buffer(i), 4) and 0fh;
x: /* force optimiser to reload highNibble */
		total = total + bitCnt(lowNibble) + bitCnt(highNibble);
	end;
	return total;
end;
end;

?reperr.plm
REPORTERROR: DO;
/* b1=01, b2=10, CODE(471H) byte, DATA(9H) byte, STACK(6H) byte, MEMORY(0H) byte,*/
error: procedure(errNum) external; declare errNum address; end;

write: procedure(aftn, buf$ptr, len, status$ptr) external;
   declare (aftn, buf$ptr, len, status$ptr) address;
end write;

numout: procedure(val, base, lead, buf$ptr, len) external;
	declare (val, buf$ptr) address, (base, lead, len) byte; 
end numout;

declare msg(*) byte DATA(0, 0,
	2, 'ILLEGAL AFTN ARGUMENT', 0,
	4, 'INCORRECTLY SPECIFIED FILE', 0,
	5, 'UNRECOGNIZED DEVICE NAME', 0,
	6, 'ATTEMPT TO WRITE TO INPUT DEVICE', 0,
	8, 'ATTEMPT TO READ FROM OUTPUT DEVICE', 0,
	0AH, 'NOT ON SAME DISK', 0,
	0BH, 'FILE ALREADY EXISTS', 0,
	0CH, 'FILE IS ALREADY OPEN', 0,
	0DH, 'NO SUCH FILE', 0,
	0EH, 'WRITE PROTECTED', 0,
	11H, 'NOT A DISK FILE', 0,
	12H, 'ILLEGAL ISIS COMMAND', 0,
	13H, 'ATTEMPTED SEEK ON NON-DISK FILE', 0,
	14H, 'ATTEMPTED BACK SEEK TOO FAR', 0,
	15H, 'CAN''T RESCAN', 0,
	16H, 'ILLEGAL ACCESS MODE TO OPEN', 0,
	17H, 'MISSING FILENAME', 0,
	19H, 'ILLEGAL ECHO FILE', 0,
	1AH, 'ILLEGAL ATTRIBUTE IDENTIFIER', 0,
	1BH, 'ILLEGAL SEEK COMMAND', 0,
	1CH, 'MISSING EXTENSION', 0,
	1FH, 'CAN''T SEEK ON WRITE ONLY FILE', 0,
	20H, 'CAN''T DELETE OPEN FILE', 0,
	23H, 'SEEK PAST EOF', 0,
	0C9H, 'UNRECOGNIZED SWITCH', 0,
	0CAH, 'UNRECOGNIZED DELIMITER', 0,
	0CBH, 'INVALID SYNTAX', 0,
	0CCH, 'PREMATURE EOF', 0,
	0CEH, 'ILLEGAL DISKETTE LABEL', 0,
	0D0H, 'CHECKSUM ERROR', 0,
	0D1H, 'RELO FILE SEQUENCE ERROR', 0,
	0D2H, 'INSUFFICIENT MEMORY', 0,
	0D3H, 'RECORD TOO LONG', 0,
	0D4H, 'ILLEGAL RELO RECORD', 0,
	0D5H, 'FIXUP BOUNDS ERROR', 0,
	0D6H, 'ILLEGAL SUBMIT PARAMETER', 0,
	0D7H, 'ARGUMENT TOO LONG', 0,
	0D8H, 'TOO MANY PARAMETERS', 0,
	0D9H, 'OBJECT RECORD TOO SHORT', 0,
	0DAH, 'ILLEGAL RECORD FORMAT', 0,
	0DBH, 'PHASE ERROR', 0
	);

reporterror: procedure(errNum) public;
	declare errNum address;
	declare numberBuffer(3) byte, i address, status address;
 

	if errNum <> 0 then
	do;
		i = 0;
		do while i < size(msg);
			if errNum = msg(i) and msg(i + 1) <> 0 then
			do;
				i = i + 1;
				call write(0, .(' '), 1, .status);
				do while msg(i) <> 0;
					call write(0, .msg(i), 1, .status);
					i = i + 1;
				end;
				call write(0, .(0dh, 0ah), 2, .status);
				return;
			end;
			else
			do;
				do while msg(i) <> 0;
					i = i + 1;
				end;
				i = i + 1;
			end;
		end;
	call error(errNum);
	end;
end;
/* native plm80 v1.0 inlines @0101 here */
end;
?scanin.plm
/* b1=01, b2=10, CODE(1A0H) byte, DATA(FH) byte, STACK(4H) byte, MEMORY(0H) byte,*/
SCANIN: do;
declare hexDigits(*) byte data('0123456789ABCDEF');

scanInteger: procedure(buf$p) address public;
	declare buf$p address;
	declare buf based buf$p address;
	declare (s, pastNum$p, endNum$p) address;
	declare (i, radix, digit) byte;
	declare (newValue, curValue) address;
	declare c based s byte;

	s = buf;	
	do while c = ' ';
		s = s + 1;
	end;
	buf = s;
	do while '0' <= c and c <= '9' or 'A' <= c and c <= 'F';
		s = s + 1;
	end;

	endNum$p = s;
	pastNum$p = s + 1;
	if c = 'H' then
		radix = 16;
	else if c = 'O' or c = 'Q' then
		radix = 8;
	else
	do;
		pastNum$p = s;
		endNum$p, s = s - 1;
x:		if c = 'B' then		/* force reload of s */
			radix = 2;
		else
		do;
			radix = 10;
			if c <> 'D' then	/* include last digit */
				endNum$p = endNum$p + 1;
		end;
	end;
	s = buf;
	newValue, curValue = 0;	
	do while s < endNum$p;
		do i = 0 to 15;
			if c = hexdigits(i) then
				digit = i;
		end;
		if digit >= radix then
			return 0;
		newValue = curValue * radix + digit;
y:		if newValue < curValue then	/* force reload of newValue */
			return 0;
		curValue = newValue;
		s = s + 1;
	end;		
	buf = pastNum$p;
	return newValue;
end;
/* native plm80 v1.0 inlines @P0034 and @P0098 here */
end;
?scnblk.plm
SCANBLANK: DO;
/* b1=01, b2=10, CODE(3AH) byte, DATA(2H) byte, STACK(2H) byte, MEMORY(0H) byte,*/
delimit: procedure(ptr) address external; declare ptr address; end;

scanblank: procedure(ptr) address public;
	declare ptr address, ch based ptr byte;

	do while (1);
		ptr = delimit(ptr);
		if ch = '*' or ch = '?' then
			ptr = ptr + 1;
		else
			return ptr;
	end;
end;
end;
?seq.plm
SEQ: DO;
/* b1=01, b2=10, CODE(48H) byte, DATA(6H) byte, STACK(2H) byte, MEMORY(0H) byte,*/
seq: procedure(s1, s2, cnt) byte public;
	declare (s1,s2) address, cnt byte;
	declare s1a based s1(1) byte;
	declare s2a based s2(1) byte;
	declare i byte;
	cnt = cnt - 1;
	do i = 0 to cnt;
		if s1a(i) <> s2a(i) then
			return 0;
	end;
	return 0ffh;
end;
end;
?setblk.plm
SETBLOCK: DO;
/* b1=01, b2=10, CODE(6AH) byte, DATA(3H) byte, STACK(2H) byte, MEMORY(0H) byte,*/
declare bitmap(1) byte external;

declare	currentBitMap byte external,
	mapChange byte external,
	lastBlock address external,
	lastSector byte external,
	lastTrack byte external,
	lastCounter byte external,
	mapDcb(1) byte external,
	maskArray(1) byte external; /* 80h, 40h, 20h, 10h, 8, 4, 2, 1 */

setblock: procedure(blk) public;
	declare blk address;
	declare idx byte;

	
	blk = high(blk) * 26 + low(blk) - 1;
x:	idx = shr(blk, 3);
/* native plm80 v1.0 generates code using bc to index into bitmap. later versions use de */
/* code difference is:
	v1.0		later versions
	mov c,m				; e already contains m so saves 1 byte
	mvi b,0		mvi d,0
	lxi h,BITMAP	lxi h,BITMAP
	dad b		dad d
    insert ENABLE to force realign and then post compile patch
*/
    ENABLE;
	bitmap(idx) = bitmap(idx) or maskArray(low(blk) and 7);

end;
/* native plm80 v1.0 inlines @P0034 and @P0091 here */
end;
?tabwrt.plm
TABWRITE: DO;
/* b1=01, b2=10, CODE(B5H) byte, DATA(DH) byte, STACK(6H) byte, MEMORY(0H) byte,*/

declare TAB	literally '9',
	CR	literally '0dh';

write: procedure (conn, buff$p, count, status$p) external;
    declare (conn, buff$p, count, status$p) address;
end write;

tabwrite: procedure(col$p, conn, buf$p, len, status$p) public;
	declare (col$p, conn, buf$p, len, status$p) address;
	declare (outchar, spcs, i) byte;
	declare col based col$p byte;
	declare ch based buf$p byte;

	do while len <> 0;
		spcs = ch = TAB and (7 - (col and 7));
		outchar = ch;
		buf$p = buf$p + 1;
		len = len - 1;
x:		if outchar = TAB then
			outchar = ' ';
		do i = 0 to spcs;
			if ch = CR then
				col = 0;
			if ch >= ' ' then
				col = col + 1;
			call write(conn, .outchar, 1, status$p);
		end;
	end;
end;
end;
?unpath.plm
UNPATH: DO;
/* b1=01, b2=10, CODE(104H) byte, DATA(5H) byte, STACK(2H) byte, MEMORY(0H) byte,*/

declare devTab(*) byte data('F0F1F2F3TITO',
			     'VIVOI1O1TRHRR1R2',
			     'TPHPP1P2LPL1BBCICO');

unpath:	procedure(int, ext) public;
	declare (int, ext) address;
	declare i byte;
	declare intName based int (1) byte;
	declare extName based ext (1) byte;

	extName(0) = ':';
	extName(1) = devTab(intName(0) + intName(0));
	extName(2) = devTab(intName(0) + intName(0) + 1);
	extName(3) = ':';	
	ext = ext + 4;
	do i = 0 to 5;
		if (extName(0) := intName(i + 1)) <> 0 then
			ext = ext + 1; 
	end;
	if intName(7) <> 0 then
	do;
		extName(0) = '.';
		ext = ext + 1;
	end;
	do i = 0 to 2;
		if (extName(0) := intName(i + 7)) <> 0 then
			ext = ext + 1; 

	end;
	extName(0) = ' ';
end;
end;
?upcase.plm
UPPERCASE: DO;
/* b1=01, b2=10, CODE(23H) byte, DATA(1H) byte, STACK(0H) byte, MEMORY(0H) byte,*/
uppercase: procedure(char) byte public;
	declare char byte;
	if char < 'a' then
		return char;
	if char > 'z' then
		return char;
	return char and 0dfh;
end;
end;
?wpath.plm
wpath: DO;
/* b1=01, b2=10, CODE(2A1H) byte, DATA(1CH) byte, STACK(6H) byte, MEMORY(0H) byte,*/

uppercase: procedure(sch) byte external; declare sch byte; end;

declare TRUE literally '0ffh',
	FALSE literally '0';

declare	devTab(*) byte data ('F0F1F2F3TITOVIVOI1O1TRHRR1R2TPHPP1P2LPL1BBCICO');

declare lastPathnameParsed(15) byte;

wpath: procedure(pathnamePtr, pn) byte public;
	declare (pathnamePtr, pn) address;
	declare (ptr, addr, devPtr) address,
		(lo, hi) byte at (.addr),
		devPair based devPtr address;
	declare	(nullName, pl, i) byte;
	declare path based pn(1) byte;
	declare sch based pathnamePtr byte;
	declare s based pathnamePtr(1) byte;
	declare tch based ptr byte;

	nonTerminator: procedure byte;
		return 'A' <= sch and sch <= 'Z' or
		   '0' <= sch and sch <= '9' or
		    sch = '?' or sch = '*' or
		   'a' <= sch and sch <= 'z';
	end;

	devPtr = .devTab;
	do i = 0 to 9;
		path(i) = 0;
	end;
	do while sch = ' ';
		pathnamePtr = pathnamePtr + 1;
	end;
	ptr = pathnamePtr;
	if sch = ':' then
	do;
		path(0) = TRUE;
		if s(3) <> ':' then
			return 4;
		pathnamePtr = pathnamePtr + 1;
		lo = uppercase(sch);
		pathnamePtr = pathnamePtr + 1;
		hi = uppercase(sch);
		pathnamePtr = pathnamePtr + 2;

		i = 0;
		do while i < last(devTab);
			if devPair = addr then
				path(0) = shr(i, 1);
			i = i + 2;
			devPtr = devPtr + 2;
		end;
		if path(0) = 255 then
			return 5;
	end;

	nullName = TRUE;
	i = 1;
	do while i < 7;
		if nonTerminator then
		do;
			path(i) = uppercase(sch);
			if sch = '*' then
				do while i < 7;
					path(i) = '?';
					i = i + 1;
				end;
			pathnamePtr = pathnamePtr + 1;
			nullName = FALSE;
		end;
		i = i + 1;
	end;
	if sch = '.' then
	do;
		pathnamePtr = pathnamePtr + 1;
		i = 7;
		do while i < 10;
			if nonTerminator then
			do;
				path(i) = uppercase(sch);
				if sch = '*' then
					do while i < 10;
						path(i) = '?';
						i = i + 1;
					end;
				pathnamePtr = pathnamePtr + 1;
			end;
			i = i + 1;
		end;	
	end;
	if path(0) <= 3 and nullName then
		return 17h;
	pl = 255;
	do while ptr < pathnamePtr;
		lastPathnameParsed(pl := pl + 1) = tch;
		ptr = ptr + 1;
	end;
	if lastPathnameParsed(pl) = '.' then
		return 1ch;
	lastPathnameParsed(pl + 1) = ' ';	
	if nonTerminator or sch = '.' or sch = ':' then
		return 4;
	return 0;
end;
/* native plm80 v1.0 inlines @P0098 and @P0099 here */
end;
?wrtdir.plm
WRITEDIRECTORY: DO;
/* b1=01, b2=10, CODE(3CEH) byte, DATA(104H) byte, STACK(6H) byte, MEMORY(0H) byte,*/
absio: procedure(cmd, disk, block, buffer) external;
	declare (cmd, disk) byte, (block, buffer) address;
end;
clearbuf: procedure(buf$ptr) external;
	declare buf$ptr address;
end;
moveascii: procedure(dst, src, cnt) external;
	declare (dst, src) address, cnt byte;
end;
setblock: procedure(adr) external; declare adr address; end;

declare bitmap(1) byte external;
/* following are declared but not used */
declare	currentBitMap byte external,
	mapChange byte external,
	lastBlock address external,
	lastSector byte external,
	lastTrack byte external,
	lastCounter byte external,
	mapDcb(1) byte external,
	maskArray(1) byte external;

declare	dirFile(*) byte data('ISIS', 0, 0, 'DIR'),
	mapFile(*) byte data('ISIS', 0, 0, 'MAP'),
	t0File(*) byte data('ISIS', 0, 0, 'T0', 0),
	binFile(*) byte data('ISIS', 0, 0, 'BIN'),
	labFile(*) byte data('ISIS', 0, 0, 'LAB');

writeDirectory: procedure(disk) public;
	declare	disk byte, i byte, jj address, dirBuf(64) address,
		direct(8) structure(empty byte, file(9) byte, attrib byte,
				    eof$count byte, blk address, hdrBlk address);

	do i = 0 to 255;
		bitmap(i) = 0;
	end;
	call clearbuf(.dirBuf);
	dirbuf(2) = 1;
	do i = 2 to 23;
		dirBuf(i + 1) = dirBuf(i) + 1;
	end;
	call absio(6, disk, 24, .dirBuf);
	call clearbuf(.dirBuf);
	dirbuf(2) = 26;
	do i = 2 to 1;	/* ??? */
		dirBuf(i + 1) = dirBuf(i) + 1;
	end;
	call absio(6, disk, 25, .dirBuf);
	call clearbuf(.dirBuf);
	dirBuf(2) = 102h;
	do i = 2 to 25;
		dirBuf(i + 1) = dirBuf(i) + 1;
	end;
	call absio(6, disk, 101h, .dirBuf);
	call clearbuf(.dirBuf);
	dirBuf(2) = 202h;
	do i = 2 to 2;
		dirBuf(i + 1) = dirBuf(i) + 1; 
	end;
	call absio(6, disk, 201h, .dirBuf);
	call clearbuf(.dirBuf);
	call absio(6, disk, 204h, .dirBuf);
	call clearBuf(.direct);
	call moveAscii(.direct(0).file, .dirFile, 9);
	direct(0).blk = 25;
	direct(0).hdrBlk = 101h;
	direct(0).empty = 0;
	direct(0).attrib = 1;
	direct(0).eof$count = 80h;
	call moveAscii(.direct(1).file, .mapFile, 9);
	direct(1).blk = 2;
	direct(1).hdrBlk = 201h;
	direct(1).empty = 0;
	direct(1).attrib = 1;
	direct(1).eof$count = 80h;
	call moveAscii(.direct(2).file, .t0File, 9);
	direct(2).blk = 23;
	direct(2).hdrBlk = 18h;
	direct(2).empty = 0;
	direct(2).attrib = 1;
	direct(2).eof$count = 80h;
	call moveAscii(.direct(3).file, .labFile, 9);
	direct(3).blk = 1;
	direct(3).hdrBlk = 19h;
	direct(3).empty = 0;
	direct(3).attrib = 1;
	direct(3).eof$count = 80h;
	call moveAscii(.direct(4).file, .binFile, 9);
	direct(4).blk = 0;
	direct(4).hdrBlk = 204h;
	direct(4).empty = 0;
	direct(4).attrib = 3;
	direct(4).eof$count = 80h;
	do i = 5 to 7;
		direct(i).empty = 7fh;
	end;
	call absio(6, disk, 102h, .direct);	
	call clearBuf(.direct);
	do i = 0 to 7;
		direct(i).empty = 7fh;
	end;
	do i = 2 to 25;
		call absio(6, disk, 101h + i, .direct);
	end;
	call setblock(101h);
	do jj = 102h to 11ah;
		call setblock(jj);
	end;
	call setblock(201h);
	do jj = 202h to 203h;
		call setblock(jj);
	end;
	call setblock(18h);
	do jj = 1 to 17h;
		call setblock(jj);
	end;
	call setblock(19h);
	do jj = 1ah to 1ah;
		call setblock(jj);
	end;
	call setblock(204h);
	call absio(6, disk, 202h, .bitmap);
	call absio(6, disk, 203h, .bitmap +  80h);
end;
/* native plm80 v1.0 inlines @P0103 and @P0104 here */
end;
?p0029.asm
	name	@P0029
	public	@P0029, @P0030
	cseg

@P0029:			; de = de / hl, hl = de % hl
	mov	b,h
	mov	c,l
@P0030:			; de = de / bc, hl = de % bc
	lxi	h,0
	mvi	a,10H
L0007:
	push	psw
	dad	h
	xchg
	sub	a
	dad	h
	xchg
	adc	l
	sub	c
	mov	l,a
	mov	a,h
	sbb	b
	mov	h,a
	inx	d
	jnc	L0019
	dad	b
	dcx	d
L0019:
	pop	psw
	dcr	a
	jnz	L0007
	ret
	end
?p0095.asm
	name	@P0095
	public	@P0095
	cseg

@P0095:			; hl = de - hl
	mov	a,e
	sub	l
	mov	l,a
	mov	a,d
	sbb	h
	mov	h,a
	ret
	end
?p0100.asm
	name	@P0100
	public	@P0100
	cseg

@P0100:			; hl = w[de] - bc
	ldax	d
	sub	c
	mov	l,a
	inx	d
	ldax	d
	sbb	b
	mov	h,a
	ret
	end
?setblk.patch
h                   # force MEMORY to exist
l                   # remove library references
tp                  # mark as PLM
v 10                # version 1.0
n c 0               # write non conformant entry location
p 002C 4E 06        # source for patch reason
p 0032 09
?plmv1.patch
h                   # force MEMORY to exist
l                   # remove library references
tp                  # mark as PLM
v 10                # version 1.0
n c 0               # write non conformant entry location
cusp2/makefile
# common makefile info
ITOOLS ?=../../..
ifdef LIB
	TARGETDIR = ../$(LIB)/
endif
TARGETS=$(TARGETDIR)cusp2.lib
unexport ISIS_F1

include $(ITOOLS)/tools/isis.mk

REF = $(call ipath,toolbox,1.0)

PLM80 = 3.1

PLMFLAGS=code
ASMFLAGS=


OBJS= alloc.ob1 direct.ob1 absio.ob1 clrbuf.ob1 d.obx dblank.ob1 \
	diskio.ob1 dlimit.ob1 dmeq.obx filerr.obx fmttrk.obx \
	forupp.ob1 mvasci.ob1 monitr.ob1 meq.ob1 numout.obx path.obx \
	popula.ob1 reperr.obx scnblk.ob1 scanin.obx seq.ob1 setblk.obx \
	tabwrt.obx upcase.ob1 unpath.ob1 wrtdir.obx wpath.obx
#
# pretend to be PLM v1.0
%.ob1: %.plm
	$(call plm80,$@,$<)
	$(ITOOLS)/tools/fixobj -v 10 $@ $@



all::
	$(MAKE) $(TARGETS)

$(TARGETDIR)cusp2.lib: $(OBJS)
	$(call lib,$@, $^)

# special builds requiring inline library files
%.obx: %.obj
	$(call link-nocheck,$@,$^ $(plm80.lib))
	$(ITOOLS)/tools/fixobj -p plmv1.patch $@ $@

d.obx: d.obj p0029.obj p0095.obj p0100.obj
	$(call link-nocheck,$@,$^ $(plm80.lib))
	$(ITOOLS)/tools/fixobj -p plmv1.patch $@ $@


filerr.obx: filerr.obj p0095.obj
	$(call link-nocheck,$@,$^ $(plm80.lib),name(FILEERROR))
	$(ITOOLS)/tools/fixobj -p plmv1.patch $@ $@

fmttrk.obx: fmttrk.obj p0029.obj
	$(call link-nocheck,$@,$^ $(plm80.lib),name(FORMATTRACK))
	$(ITOOLS)/tools/fixobj -p plmv1.patch $@ $@

numout.obx: numout.obj p0029.obj
	$(call link-nocheck,$@,$^ $(plm80.lib))
	$(ITOOLS)/tools/fixobj -p plmv1.patch $@ $@


reperr.obx: reperr.obj p0100.obj
	$(call link-nocheck,$@,$^ $(plm80.lib),name(REPORTERROR))
	$(ITOOLS)/tools/fixobj -p plmv1.patch $@ $@

setblk.obx: setblk.obj setblk.patch
	$(call link-nocheck,$@,setblk.obj $(plm80.lib),name(SETBLOCK))
	$(ITOOLS)/tools/fixobj -p setblk.patch $@ $@

tabwrt.obx: tabwrt.obj
	$(call link-nocheck,$@,$^ $(plm80.lib),name(TABWRITE))
	$(ITOOLS)/tools/fixobj -p plmv1.patch $@ $@

wrtdir.obx: wrtdir.obj
	$(call link-nocheck,$@,$^ $(plm80.lib),name(WRITEDIRECTORY))
	$(ITOOLS)/tools/fixobj -p plmv1.patch $@ $@
cusp5/cusp5_all.src
?absio.plm
ABSIO: DO;
DECLARE DCB$T LITERALLY 'STRUCTURE (iocw BYTE, ioins BYTE, nsec BYTE, tadr BYTE, sadr BYTE, buf ADDRESS)';

diskio: procedure(disk, dcb$ptr) external; declare (disk, dcb$ptr) address; end;

absio: procedure(cmd, disk, block, buffer) public;
	declare (cmd, disk) byte, (block, buffer) address;
	declare dcb DCB$T;

	dcb.iocw = 80H;
	dcb.ioins = cmd;
	dcb.nsec = 1;
	dcb.tadr = high(block);
	dcb.sadr = low(block);
	dcb.buf = buffer;
	call diskio(disk, .dcb);
end;
end;
?alloc.plm
ALLOC: DO;
DECLARE DCB$T LITERALLY 'STRUCTURE (iocw BYTE, ioins BYTE, nsec BYTE, tadr BYTE, sadr BYTE, buf ADDRESS)';

declare
	bitmap(512) byte public,
	currentBitmap byte public initial(0ffh),
	mapChange byte public initial(0),
	lastBlock address public,
	(lastSector, lastTrack) byte public at (.lastBlock),
	lastCounter address public,
	mapDcb DCB$T initial(80H, 0, 4, 2, 2, 0),	/* I suspect this should be public */
	maskArray(*) byte public data(80H, 40H, 20H, 10H, 8, 4, 2, 1);
end;
?chklab.plm
CHECKLABEL: DO;

write: procedure (conn, buff$p, count, status$p) external;
    declare (conn, buff$p, count, status$p) address;
end write;

getDisk: procedure(arg1b) external;
	declare arg1b byte;
end;

getLabel: procedure(lab, device) external;
	declare lab address, device byte;
end;

seq: procedure(s1, s2, cnt) byte external;
	declare (s1,s2) address, cnt byte;
end;

CHECKLABEL: procedure(arg1w, arg2b, arg3b) public;
	declare arg1w address, (arg2b, arg3b) byte;
	declare status address, lab(11) byte;

	do while (1);
		call GETDISK(arg3b);
		if arg2b > 5 then
			return;
		call GETLABEL(.lab, arg2b);
		if SEQ(arg1w, .lab, 9) then
			return;
		lab(0) = arg2b + '0';
		call WRITE(0, .('WRONG DISKETTE IN DRIVE '), 24, .status);
		call WRITE(0, .lab, 1, .status);
		call WRITE(0, .(0DH, 0AH), 2, .status);
	end;
end;

end;
?clrbuf.plm
CLEARBUF: DO;

clearbuf: procedure(buf$ptr) public;
	declare buf$ptr address, i byte,
		buf based buf$ptr (1) byte;

	do i = 0 to 127;
		buf(i) = 0;
	end;
end;
end;
?cpyrit.plm
COPYRIGHT: DO;
end;
?d.plm
D: DO;
sFileError: procedure(status, filename) external;
	declare (status, filename) address;
end;
open: procedure (conn$p, path$p, access, echo, status$p) external;
    declare (conn$p, path$p, access, echo, status$p) address;
end open;

read: procedure (conn, buff$p, count, actual$p, status$p) external;
    declare (conn, buff$p, count, actual$p, status$p) address;
end read;

write: procedure (conn, buff$p, count, status$p) external;
    declare (conn, buff$p, count, status$p) address;
end write;

close: procedure (conn, status$p) external;
    declare (conn, status$p) address;
end close;

delimit: procedure(ptr) address external;
	declare ptr address, ch based ptr byte;
end;

NumOut: procedure(value, base, lc, bufAdr, width) external;
	declare (value, bufAdr) address, (base, lc, width) byte;
end;

meq: procedure(mPtr, fptr) byte external;
	declare (mPtr, fptr) address;
end;

unpath:	procedure(int, ext) external;
	declare (int, ext) address;
end;

deblank: procedure(ptr) address external;
	declare ptr address;
end;

spath: procedure (path$p, info$p, status$p) external;
    declare (path$p, info$p, status$p) address;
end spath;

declare direct structure(status byte, name(6) byte, ext(3) byte, attrib byte, eof$count byte,
			 blk address, hdrBlk address) external;
declare directIno address external;

Population: procedure(bufferLoc, len) address external;
	declare (bufferLoc, len) address;
end;

declare singleDrive byte external;

declare isisDrive(*) byte initial(':FX:', 0),
	isisMapFile(*) byte initial(':F :ISIS.MAP '),
	isisLabFile(*) byte initial(':F :ISIS.LAB '),
	isisDirFile(*) byte initial(':F :ISIS.DIR ');

declare	crlf(2) byte data(0DH, 0AH),
	blksUsedMsg(*) byte data('XXXX/YYYY BLOCKS USED', 0DH, 0AH),
	dirOfMsg(*) byte data('DIRECTORY OF '),
	dirHeader(*) byte data('NAME  .EXT BLKS   LENGTH ATTR', 0DH, 0AH);

D: procedure(drive, conn, arg3b, arg4b, arg5w) public;
	declare (drive, conn, arg3b, arg4b) byte, arg5w address;
	declare (dconn, status, actual, unused) address,
		(sectUsed, highFileSize, lowFileSize) address,
		totalSectUsed address,
		mapBuf(512) byte,
		strBuf(15) byte,
		path(15) byte,
		(i, j) byte,
		mapBufSize address,
		driveType byte;

	bigAdd: procedure(n);
		declare n address;
		lowFileSize = lowFileSize + n;
		if lowFileSize > 9999 then
		do;
			lowFileSize = lowFileSize - 10000;
			highFileSize = highFileSize + 1;
		end;
	end;	

	isisDrive(2) = drive + '0';

	call Spath(.isisDrive, .mapBuf, .status);
	if mapBuf(11) = 1 then	/* driveType */
		driveType = 0ffh;	/* DD */
	else
		driveType = 0;	/* SD */
		
	do i = 0 to last(mapBuf);
		mapBuf(i) = 0;
	end;
	
	totalSectUsed = 0;
	isisMapFile(2), isisLabFile(2), isisDirFile(2) = drive + '0';
	call Open(.dconn, .isisLabFile, 1, 0, .status);
	call sFileError(status, .isisLabFile);
	strBuf(0) = drive;
	call Read(dconn, .strBuf(1), 9, .actual, .status);
	call Write(conn, .dirOfMsg, 13, .status);
	call Unpath(.strBuf, .path);
	i = Delimit(.path) - .path;
	call Write(conn, .path, i, .status);
	call Write(conn, .crlf, 2, .status);
	call close(dconn, .status);
	if (not arg3b) then
		call Write(conn, .dirHeader, size(dirHeader), .status);
	call Open(.dconn, .isisDirFile, 1, 0, .status);
	actual = size(direct);
	direct.status = actual;
	do while actual = size(direct) and direct.status <> 07fh;
		call read(dconn, .direct, size(direct), .actual, .status);
		if actual = size(direct) and (not direct.status) and
		   ((direct.attrib and 1) = 0 or arg4b) and
		   meq(arg5w, .direct) then
		   do;
			do i = 0 to 8;
				if direct.name(i) = 0 then
					direct.name(i) = ' ';
			end;
			i = 9;
			if arg3b then	
				do while direct.name(i - 1) = ' ';
					i = i - 1;
				end;
			if not arg3b or i > 6 then
				j = 6;
			else	
				j = i;
			call Write(conn, .direct.name, j, .status);
			if arg3b then
			do;
				if i > 6 then
				do;
					call Write(conn, .('.'), 1, .status);
					call Write(conn, .direct.ext, i - 6, .status);
				end;
			end;
			else
			do;
				if direct.ext(0) <> ' ' then
					call Write(conn, .('.'), 1, .status);
				call Write(conn, .direct.ext, 3, .status);
				if direct.ext(0) = ' ' then
					call Write(conn, .(' '), 1, .status);
				sectUsed = direct.blk;
				if sectUsed > 0 then
					sectUsed = sectUsed + (sectUsed + 61) / 62;
				else
					sectUsed = 1;
				totalSectUsed = totalSectUsed + sectUsed;
				call NumOut(sectUsed, 10, ' ', .strBuf, 5);
				call Write(conn, .strBuf, 5, .status);
				sectUsed = direct.blk;
				lowFileSize, highFileSize = 0;
				if sectUsed > 0 then
				do;
					sectUsed = sectUsed - 1;
					call bigAdd(direct.eof$count);
					do while sectUsed > 0;
						sectUsed = sectUsed - 1;
						call bigAdd(128);
					end;
				end;

				if highFileSize <> 0 then
				do;
					call NumOut(highFileSize, 10, ' ', .strBuf, 5);
					call NumOut(lowFileSize, 10, '0', .strBuf(5), 4);
				end;
				else
					call NumOut(lowFileSize, 10, ' ', .strBuf, 9);
				call Write(conn, .strBuf, 9, .status);
				if direct.attrib <> 0 then
				do;
					do i = 0 to 4;
						strbuf(i) = ' ';
					end;
					if (direct.attrib and 4) <> 0 then
						strbuf(1) = 'W';
					if (direct.attrib and 2) <> 0 then
						strbuf(2) = 'S';
					if (direct.attrib and 1) <> 0 then
						strbuf(3) = 'I';
					if (direct.attrib and 80h) <> 0 then
						strbuf(4) = 'F';
					call write(conn, .strbuf, 5, .status);
				end;
			end;
			call Write(conn, .crlf, 2, .status);
		end;	
	end;
	call Close(dconn, .status);
	if not arg3b then
	do;
		call NumOut(totalSectUsed, 10, ' ', .strBuf, 15);
		call Write(conn, .strBuf, 15, .status);
		call Write(conn, .crlf, 2, .status);
	end;
	call Open(.dconn, .isisMapFile, 1, 0, .status);	
	if driveType then
		mapBufSize = 512;
	else
		mapBufSize = 256;
	call Read(dconn, .mapBuf, mapBufSize, .actual, .status);
	call NumOut(Population(.mapBuf, mapBufSize), 10, 0, .blksUsedMsg, 4);
	if driveType then
		call NumOut(4004, 10, 0, .blksUsedMsg + 5, 4);
	else
		call NumOut(2002, 10, 0, .blksUsedMsg + 5, 4);
	call Write(conn, .blksUsedMsg, length(blksUsedMsg), .status);
	call Close(conn, .status);
	return;
end;
end;
?dblank.plm
DEBLANK: DO;
deblank: procedure(str) address public;
	declare str address;
	declare c based str byte;

	do while (c = ' ');
		str = str + 1;
	end;
	return str;
end;

end;
?direct.plm
DIRECT: DO;
declare	DIRECT(16) byte public,
	DIRECTINO byte public;
end;
?diskio.plm
DISKIO: DO;
isis: procedure(syscmd, param$p) external; declare syscmd byte, param$p address; end;

diskio: procedure(disk, dcb$p) public;
	declare (disk, dcb$p) address; 
	declare param structure(disk address, dcb$p address);
	
	param.disk = disk;
	param.dcb$p = dcb$p;
	call isis(44H, .param);
end;
end;
?dlimit.plm
DELIMIT: DO;
delimit: procedure(ptr) address public;
	declare ptr address, ch based ptr byte;

	do while ch = ':' or ch = '.' or
		 ('0' <= ch and ch <= '9') or
		 ('A' <= ch and ch <= 'Z');
		ptr = ptr + 1;
	end;
	return ptr;
end;
end;
?dmeq.plm
/* b1=01, b2=31, CODE(A3H) byte, DATA(12H) byte, STACK(8H) byte, MEMORY(0H) byte,*/
DMEQ: DO;
declare TRUE	literally '0FFH',
	FALSE	literally '0';

read: procedure (conn, buff$p, count, actual$p, status$p) external;
    declare (conn, buff$p, count, actual$p, status$p) address;
end read;

seek: procedure (conn, mode, block$p, byte$p, status$p) external;
    declare (conn, mode, block$p, byte$p, status$p) address;
end seek;

meq: procedure(A, B) byte external ; declare (A,B) address; end;

dmeq: procedure (dir$aftn, search$arg, initial$i$no, dir$entry) byte public;
    declare (dir$aftn, search$arg, initial$i$no, dir$entry) address;
    declare (byteNo, blockNo, actual, status) address;
    declare (pastDir, searching) byte;
    declare dirFlag based dir$entry byte;

	blockNo = 0;
	byteNo = initial$i$no * 16;
	call seek(dir$aftn, 2, .blockNo, .byteNo, .status);

	searching = TRUE;
	do while searching;
		call read(dir$aftn, dir$entry, 16, .actual, .status);
		searching = not meq(search$arg, dir$entry);
		initial$i$no = initial$i$no + 1;
		if dirFlag = 7Fh or actual = 0 then
		do;
			initial$i$no = 201;
			searching = FALSE;
		end;
	end;
		
	return initial$i$no;
end;
end;
?ferror.plm
FILEERROR: DO;

write: procedure (conn, buff$p, count, actual$p) external;
    declare (conn, buff$p, count, actual$p) address;
end write;

exit: procedure external; end exit;

deblank: procedure(str) address external; declare str address; end;
WDelimit: procedure(ptr) address external; declare ptr address; end;
reporterror: procedure(status) external; declare status address; end;

fileerror: procedure(status, ptr, callExit) public;
	declare (status, ptr) address, callExit byte;
	declare actual address;

	if status <> 0 then
	do;
		ptr = deblank(ptr);
		call write(0, .(' '), 1, .actual);
		call write(0, ptr, WDelimit(ptr) - ptr, .actual);
		call write(0, .(','), 1, .actual);
		call reporterror(status);
		if callExit then
			call exit;
	end;
end;
end;
?fmttrk.plm
FORMATTRACK: DO;

diskio: procedure(disk, dcb$p) external; declare disk address, dcb$p address; end;
declare diskType byte external;


formatTrack: procedure(disk,sTrack,eTrack,interleave) public;
	declare (disk,sTrack,eTrack,interleave) byte;
	declare (i,j,k) byte, trackBuf(104) byte,
	dcb structure(iocw byte, ioins byte, nsec byte, tadr byte, sadr byte, buf address),
	spt byte, tbufLast byte;

	if diskType then
	do;
		spt = 52;
		tBufLast = 103;		
	end;
	else
	do;
		spt = 26;
		tBufLast = 51;
	end;

	dcb.iocw = 0c0h;
	dcb.ioins = 2;
	
	do i = 1 to tBufLast by 2;
		trackBuf(i) = 0c7h;	
	end;
	j = 0;
	do k = sTrack to eTrack;
		do i = 0 to tbufLast by 2;
			trackBuf(i) = 0;
		end;
		do i = 1 to spt;
			j = (j + interleave) mod spt;
			do while trackBuf(j + j) <> 0;
				j = (j + 1) mod spt;
			end;
			trackBuf(j + j) = i;
		end;
		dcb.tadr = k;
		dcb.buf = .trackBuf;
		call diskio(disk, .dcb);
	end;
end;
end;
?forupp.plm
FORCEUPPER: DO;
/* b1=01, b2=10, CODE(25H) byte, DATA(2H) byte, STACK(2H) byte, MEMORY(0H) byte,*/
declare CR literally '0DH';

uppercase: procedure(ch) byte external; declare ch byte; end;

forceupper: procedure(bufferPtr) public;
	declare bufferPtr address, ch based bufferPtr byte;

	do while ch <> CR;
		ch = uppercase(ch);
		bufferPtr = bufferPtr + 1;
	end;
end;
end;
?getdsk.plm
GetDisk: do;

Write: procedure(conn, buff$p, count, status$p) external;
         declare conn address, buff$p address, count address, status$p address; end;

Read: procedure(conn, buff$p, count, actual$p, status$p) external;
        declare conn address, buff$p address, count address, actual$p address, status$p address; end;


declare source(3) structure(name(6) byte) data('SYSTEM', 'SOURCE', 'OUTPUT');

GetDisk: procedure(n) public;
	declare n byte;
	declare buf(128) byte, status address, junk address, actual address;

	call Write(0, .('LOAD '), 5, .status);
	call Write(0, .source(n), 6, .status);
	call Write(0, .(' DISKETTE, THEN TYPE (CR)'), 25, .status);
	call Read(1, .buf, 128, .actual, .status);
end;
end;
?getlab.plm
GETLABEL: DO;

read: procedure (conn, buff$p, count, actual$p, status$p) external;
    declare (conn, buff$p, count, actual$p, status$p) address;
end read;

open: procedure (conn$p, path$p, access, echo, status$p) external;
    declare (conn$p, path$p, access, echo, status$p) address;
end open;

close: procedure (conn, status$p) external;
    declare (conn, status$p) address;
end close;

SFileError: procedure(status, name$p) external;
	declare (status, name$p) address;
end;

declare isisLabFile(*) byte initial(':FX:ISIS.LAB', 0);

GetLabel: procedure(labBuf, drive) public;
	declare labBuf address, drive byte;
	declare (status, actual, conn) address;

	if drive <= 5 then
	do;
		isisLabFile(2) = drive + '0';
		call Open(.conn, .isisLabFile, 1, 0, .status);
		call SFileError(status, .isisLabFile);
		call Read(conn, labBuf, 9, .actual, .status);
		call SFileError(status, .isisLabFile);
		call Close(conn, .status);
		call SFileError(status, .isisLabFile);
	end;
end;
end;
?meq.plm
/* b1=01, b2=31, CODE(76H) byte, DATA(5H) byte, STACK(2H) byte, MEMORY(0H) byte,*/
MEQ: DO;

meq: procedure(mPtr, fptr) byte public;
	declare (mPtr, fptr) address;
	declare m based mPtr (10) byte;
	declare f based fptr (10) byte;
	declare i byte;

	do i = 0 to 9;
		if m(i) = '?' then
		do;
			if f(i) = 0 then
				return 0;
		end;
		else if m(i) <> '*' then
		do;
			if m(i) <> f(i) then
				return 0;
		end;
	end;
	return 0ffh;
end;
end;

?monitr.plm
MONITOR: DO;
MONITOR: procedure public;
	declare sp address, wrd based sp  address;

	sp = STACKPTR;
	wrd = 8;	
/*
    code below should be -2, but the compilers optimised this to
    dcx x2. Using -3 forces the code sequence and a post build
    patch fixes the 3 back to a 2
*/
	STACKPTR = STACKPTR - 3;
	sp = STACKPTR;
	wrd = 0;
end;
end;
?mvasci.plm
MOVEASCII: DO;
moveascii: procedure(dst, src, cnt) public;
	declare (dst, src) address, cnt byte, i byte;
	declare dch based dst (1) byte, sch based src (1) byte;

	do i = 0 to cnt - 1;
		dch(i) = sch(i);
	end;
end;
end;
?numout.plm
NUMOUT: DO;

declare digits(*) byte data('0123456789ABCDEF');

numout: procedure(val, base, lc, bufAdr, width) public;
	declare (val, bufAdr) address, (base, lc, width) byte; 
	declare i byte;
	declare buf based bufAdr (1) byte;

	do i = 1 to width;
		buf(width - i) = digits(val mod base);
		val = val / base;	
	end;

	i = 0;
	do while buf(i) = '0' and i < width - 1;
		buf(i) = lc;
		i = i + 1;
	end;
end;
end;
?path.plm
PATH: DO;
moveascii: procedure(dst, src, cnt) external;
	declare (dst, src) address, cnt byte;
end;

Spath: procedure(filename, info$p, status$p) external;
	declare (filename, info$p, status$p) address;
end;

PATH: procedure(filename, pn) byte public;
	declare (filename, pn) address;
	declare info(12) byte, status byte;

	call Spath(filename, .info, .status);	/* bug? status only a byte */
	call MoveAscii(pn, .info, 10);
	return status;
end;
end;
?popula.plm
POPULATION: DO;

declare bitCnt(*) byte data(0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4);


population: procedure(bufferLoc, length) address public;
	declare (bufferLoc, length) address;
	declare total address, (lowNibble, highNibble) byte,
		(i, lastByte) address;
	declare buffer based bufferLoc (1) byte;

	total = 0;
	lastByte = length - 1;
	do i = 0 to lastByte;
		lowNibble = buffer(i) and 0fh;		
		highNibble = ror(buffer(i), 4) and 0fh;
		total = total + bitCnt(lowNibble) + bitCnt(highNibble);
	end;
	return total;
end;
end;
?reperr.plm
REPORTERROR: DO;

error: procedure(errNum) external; declare errNum address; end;

write: procedure(aftn, buf$ptr, len, status$ptr) external;
   declare (aftn, buf$ptr, len, status$ptr) address;
end write;

numout: procedure(val, base, lead, buf$ptr, len) external;
	declare (val, buf$ptr) address, (base, lead, len) byte; 
end numout;

declare msg(*) byte DATA(0, 0,
	2, 'ILLEGAL AFTN ARGUMENT', 0,
	4, 'INCORRECTLY SPECIFIED FILE', 0,
	5, 'UNRECOGNIZED DEVICE NAME', 0,
	6, 'ATTEMPT TO WRITE TO INPUT DEVICE', 0,
	8, 'ATTEMPT TO READ FROM OUTPUT DEVICE', 0,
	9, 'DISK DIRECTORY FULL', 0,
	0AH, 'NOT ON SAME DISK', 0,
	0BH, 'FILE ALREADY EXISTS', 0,
	0CH, 'FILE IS ALREADY OPEN', 0,
	0DH, 'NO SUCH FILE', 0,
	0EH, 'WRITE PROTECTED', 0,
	11H, 'NOT A DISK FILE', 0,
	12H, 'ILLEGAL ISIS COMMAND', 0,
	13H, 'ATTEMPTED SEEK ON NON-DISK FILE', 0,
	14H, 'ATTEMPTED BACK SEEK TOO FAR', 0,
	15H, 'CAN''T RESCAN', 0,
	16H, 'ILLEGAL ACCESS MODE TO OPEN', 0,
	17H, 'MISSING FILENAME', 0,
	19H, 'ILLEGAL ECHO FILE', 0,
	1AH, 'ILLEGAL ATTRIBUTE IDENTIFIER', 0,
	1BH, 'ILLEGAL SEEK COMMAND', 0,
	1CH, 'MISSING EXTENSION', 0,
	1FH, 'CAN''T SEEK ON WRITE ONLY FILE', 0,
	20H, 'CAN''T DELETE OPEN FILE', 0,
	23H, 'SEEK PAST EOF', 0,
	0C9H, 'UNRECOGNIZED SWITCH', 0,
	0CAH, 'UNRECOGNIZED DELIMITER', 0,
	0CBH, 'INVALID SYNTAX', 0,
	0CCH, 'PREMATURE EOF', 0,
	0CEH, 'ILLEGAL DISKETTE LABEL', 0,
	0D0H, 'CHECKSUM ERROR', 0,
	0D1H, 'RELO FILE SEQUENCE ERROR', 0,
	0D2H, 'INSUFFICIENT MEMORY', 0,
	0D3H, 'RECORD TOO LONG', 0,
	0D4H, 'ILLEGAL RELO RECORD', 0,
	0D5H, 'FIXUP BOUNDS ERROR', 0,
	0D6H, 'ILLEGAL SUBMIT PARAMETER', 0,
	0D7H, 'ARGUMENT TOO LONG', 0,
	0D8H, 'TOO MANY PARAMETERS', 0,
	0D9H, 'OBJECT RECORD TOO SHORT', 0,
	0DAH, 'ILLEGAL RECORD FORMAT', 0,
	0DBH, 'PHASE ERROR', 0
	);

reporterror: procedure(errNum) public;
	declare errNum address;
	declare numberBuffer(3) byte, i address, status address;
 

	if errNum <> 0 then
	do;
		i = 0;
		do while i < size(msg);
			if errNum = msg(i) and msg(i + 1) <> 0 then
			do;
				i = i + 1;
				call write(0, .(' '), 1, .status);
				do while msg(i) <> 0;
					call write(0, .msg(i), 1, .status);
					i = i + 1;
				end;
				call write(0, .(0dh, 0ah), 2, .status);
				return;
			end;
			else
			do;
				do while msg(i) <> 0;
					i = i + 1;
				end;
				i = i + 1;
			end;
		end;
	call error(errNum);
	end;
end;
end;
?scanin.plm
scanIn: do;

declare digits(*) byte data('0123456789ABCDEF');

ScanInteger: procedure(ptrPtr) address public;
	declare ptrPtr address;
	declare ptr based ptrPtr address;
	declare (scanPtr, updatePtr, stopPtr) address;
	declare (i, radix, increment) byte;
	declare (nVal, oVal) address;
	declare c based scanPtr byte;

	scanPtr = ptr;
	do while c = ' ';
		scanPtr = scanPtr + 1;
	end;
	ptr = scanPtr;
	do while '0' <= c and c <= '9' or 'A' <= c and c <= 'F';
		scanPtr = scanPtr + 1;
	end;

	stopPtr = scanPtr;
	updatePtr = scanPtr + 1;
	if c = 'H' then
		radix = 16;
	else if c = 'O' or c = 'Q' then
		radix = 8;
	else
	do;
		updatePtr = scanPtr;
		stopPtr, scanPtr = scanPtr - 1;
		if c = 'B' then
			radix = 2;
		else
		do;
			radix = 10;
			if c <> 'D' then	/* include last increment */
				stopPtr = stopPtr + 1;
		end;
	end;
	scanPtr = ptr;
	nVal, oVal = 0;
	do while scanPtr < stopPtr;
		do i = 0 to 15;
			if c = digits(i) then
				increment = i;
		end;
		if increment >= radix then
			return 0;
		nVal = oVal * radix + increment;
		if nVal < oVal then
			return 0;
		oVal = nVal;
		scanPtr = scanPtr + 1;
	end;
	ptr = updatePtr;
	return nVal;
end;
end;
?seq.plm
SEQ: DO;
seq: procedure(s1, s2, cnt) byte public;
	declare (s1,s2) address, cnt byte;
	declare s1a based s1(1) byte;
	declare s2a based s2(1) byte;
	declare i byte;
	cnt = cnt - 1;
	do i = 0 to cnt;
		if s1a(i) <> s2a(i) then
			return 0;
	end;
	return 0ffh;
end;
end;
?serror.plm
SFileError: do;
declare boolean literally 'byte';

Write: procedure(conn, buff$p, count, status$p) external;
         declare conn address, buff$p address, count address, status$p address; end;

Exit: procedure external; end;

deblank: procedure(ptr) address external; declare ptr address; end;

WDelimit: procedure(ptr) address external; declare ptr address; end;

GetDisk: procedure(n) external; declare n byte; end;

ReportError: procedure(errNum) external; declare errNum address; end;

declare singleDrive boolean external;

SFileError: procedure(status, name$p) public;
	declare (status, name$p) address;
	declare lStatus address;

	if status <> 0 then
	do;
		if singleDrive then
			call GetDisk(0);
		name$p = Deblank(name$p);
		call Write(0, .(' '), 1, .lStatus);
		call Write(0, name$p, WDelimit(name$p) - name$p, .lStatus);
		call Write(0, .(','), 1, .lStatus);
		call ReportError(status);
		call Exit;
	end;
end;
end;
?setblk.plm
SETBLOCK: DO;

declare bitmap(1) byte external,
	currentBitmap byte external,
	mapChange byte external,
	lastBlock address external,
	lastSector byte external,
	lastTrack byte external,
	lastCounter address external,
	maskArray(1) byte external,
	diskType byte external;

setBlock: procedure(adr) public;
	declare adr address;
	declare (bit, byt) address;
	declare spt byte;

	if diskType then
		spt = 52;
	else
		spt = 26;

	bit = high(adr) * spt + low(adr) - 1;
	byt = shr(bit, 3);
x: /* force reload of byt */
	bitmap(byt) = bitmap(byt) or maskArray(low(bit) and 7);
end;
end;
?tabwrt.plm
TABWRITE: DO;
/* b1=01, b2=31, CODE(A7H) byte, DATA(DH) byte, STACK(6H) byte, MEMORY(0H) byte,*/

declare TAB	literally '9',
	CR	literally '0dh';

write: procedure (aft, buff$p, count, status) external;
    declare (aft, buff$p, count, status) address;
end write;

tabwrite: procedure(columnPtr, aft, bufferPtr, count, status) public;
	declare (columnPtr, aft, bufferPtr, count, status) address;
	declare (printChar, i, j) byte;
	declare column based columnPtr byte;
	declare ch based bufferPtr byte;

	do while count <> 0;
		i = ch = TAB and (7 - (column and 7));
		printChar = ch;
		bufferPtr = bufferPtr + 1;
		count = count - 1;
		if printChar = TAB then
			printChar = ' ';
		do j = 0 to i;
			if ch = CR then
				column = 0;
			if ch >= ' ' then
				column = column + 1;
			call write(aft, .printChar, 1, status);
		end;
	end;
end;
end;

?unpath.plm
UNPATH: DO;

declare devTab(*) byte data('F0F1F2F3F4F5TITO',
			     'VIVOI1O1TRHRR1R2',
			     'TPHPP1P2LPL1BBCICO');

unpath:	procedure(int, ext) public;
	declare (int, ext) address;
	declare i byte;
	declare intName based int (1) byte;
	declare extName based ext (1) byte;

	extName(0) = ':';
	extName(1) = devTab(intName(0) + intName(0));
	extName(2) = devTab(intName(0) + intName(0) + 1);
	extName(3) = ':';	
	ext = ext + 4;
	do i = 0 to 5;
		if (extName(0) := intName(i + 1)) <> 0 then
			ext = ext + 1; 
	end;
	if intName(7) <> 0 then
	do;
		extName(0) = '.';
		ext = ext + 1;
	end;
	do i = 0 to 2;
		if (extName(0) := intName(i + 7)) <> 0 then
			ext = ext + 1; 

	end;
	extName(0) = ' ';
end;
end;
?upcase.plm
UPPERCASE: DO;
uppercase: procedure(char) byte public;
	declare char byte;
	if char < 'a' then
		return char;
	if char > 'z' then
		return char;
	return char and 0dfh;
end;
end;
?wdlmt.plm
WDELIMIT: DO;
/* b1=01, b2=31, CODE(63H) byte, DATA(2H) byte, STACK(4H) byte, MEMORY(0H) byte,*/
wdelimit: procedure(ptr) address public;
	declare ptr address;
	declare ch based ptr byte;

	do while (ch = ':' or ch = '.' or ch = '*' or ch = '?' or
		  ('0' <= ch and ch <= '9') or ('A' <= ch and ch <= 'Z'));
		ptr = ptr + 1;
	end;
	return ptr;
end;
end;

?wpath.plm
WPATH: DO;

uppercase: procedure(sch) byte external; declare sch byte; end;

declare TRUE literally '0ffh',
	FALSE literally '0';

declare	devTab(*) byte data ('F0F1F2F3F4F5TITO',
			      'VIVOI1O1TRHRR1R2',
			      'TPHPP1P2LPL1BBCI',
			      'CO');

declare lastPathnameParsed(15) byte;

wpath: procedure(pathnamePtr, pn) byte public;
	declare (pathnamePtr, pn) address;
	declare (ptr, addr, devPtr) address,
		(lo, hi) byte at (.addr),
		devPair based devPtr address;
	declare	(nullName, pl, i) byte;
	declare path based pn(1) byte;
	declare sch based pathnamePtr byte;
	declare s based pathnamePtr(1) byte;
	declare tch based ptr byte;

	nonTerminator: procedure byte;
		return 'A' <= sch and sch <= 'Z' or
		   '0' <= sch and sch <= '9' or
		    sch = '?' or sch = '*' or
		   'a' <= sch and sch <= 'z';
	end;

	devPtr = .devTab;
	do i = 0 to 9;
		path(i) = 0;
	end;
	do while sch = ' ';
		pathnamePtr = pathnamePtr + 1;
	end;
	ptr = pathnamePtr;
	if sch = ':' then
	do;
		path(0) = TRUE;
		if s(3) <> ':' then
			return 4;
		pathnamePtr = pathnamePtr + 1;
		lo = uppercase(sch);
		pathnamePtr = pathnamePtr + 1;
		hi = uppercase(sch);
		pathnamePtr = pathnamePtr + 2;

		i = 0;
		do while i < last(devTab);
			if devPair = addr then
				path(0) = shr(i, 1);
			i = i + 2;
			devPtr = devPtr + 2;
		end;
		if path(0) = 255 then
			return 5;
	end;

	nullName = TRUE;
	i = 1;
	do while i < 7;
		if nonTerminator then
		do;
			path(i) = uppercase(sch);
			if sch = '*' then
				do while i < 7;
					path(i) = '*';
					i = i + 1;
				end;
			pathnamePtr = pathnamePtr + 1;
			nullName = FALSE;
		end;
		i = i + 1;
	end;
	if sch = '.' then
	do;
		pathnamePtr = pathnamePtr + 1;
		i = 7;
		do while i < 10;
			if nonTerminator then
			do;
				path(i) = uppercase(sch);
				if sch = '*' then
					do while i < 10;
						path(i) = '*';
						i = i + 1;
					end;
				pathnamePtr = pathnamePtr + 1;
			end;
			i = i + 1;
		end;	
	end;
	if path(0) <= 5 and nullName then
		return 17h;
	pl = 255;
	do while ptr < pathnamePtr;
		lastPathnameParsed(pl := pl + 1) = tch;
		ptr = ptr + 1;
	end;
	if lastPathnameParsed(pl) = '.' then
		return 1ch;
	lastPathnameParsed(pl + 1) = ' ';	
	if nonTerminator or sch = '.' or sch = ':' then
		return 4;
	return 0;
end;
end;

?wrtdir.plm

WRITEDIRECTORY: DO;

declare bitmap(512) byte external;
/* following are declared but not used */
declare	currentBitMap byte external,
	mapChange byte external,
	lastBlock address external,
	lastSector byte external,
	lastTrack byte external,
	lastCounter byte external,
	maskArray(1) byte external;

setblock: procedure(adr) external; declare adr address; end;

clearbuf: procedure(buf$ptr) external;
	declare buf$ptr address;
end;

absio: procedure(cmd, disk, block, buffer) external;
	declare (cmd, disk) byte, (block, buffer) address;
end;
moveascii: procedure(dst, src, cnt) external;
	declare (dst, src) address, cnt byte;
end;

declare diskType byte external;

declare	dirFile(*) byte data('ISIS', 0, 0, 'DIR'),
	mapFile(*) byte data('ISIS', 0, 0, 'MAP'),
	t0File(*) byte data('ISIS', 0, 0, 'T0', 0),
	binFile(*) byte data('ISIS', 0, 0, 'BIN'),
	labFile(*) byte data('ISIS', 0, 0, 'LAB');

writeDirectory: procedure(disk) public;
	declare	disk byte, i byte, jj address, dirBuf(64) address,
		direct(8) structure(empty byte, file(9) byte, attrib byte,
				    eof$count byte, blk address, hdrBlk address);
	declare countBitMapSectors byte, binHdrBlk address;

	currentBitmap = disk;
	if diskType then
	do;
		countBitMapSectors = 4;
		binHdrBlk = 206h;
	end;
	else
	do;
		countBitMapSectors = 2;
		binHdrBlk = 204h;
	end;
	do jj = 0 to last(bitmap);
		bitmap(jj) = 0;
	end;

	call clearbuf(.dirBuf);
	dirbuf(2) = 1;
	do i = 2 to 23;
		dirBuf(i + 1) = dirBuf(i) + 1;
	end;
	call absio(6, disk, 24, .dirBuf);
	call clearbuf(.dirBuf);
	dirbuf(2) = 26;
	if diskType then
	do;
		do i = 2 to 27;
			dirBuf(i + 1) = dirBuf(i) + 1;
		end;
		dirBuf(29) = 11Bh;
		do i = 2 to 26;
			dirBuf(i + 27 + 1) = dirbuf(i + 27) + 1;
		end;	
	end;
	call absio(6, disk, 25, .dirBuf);
	call clearbuf(.dirBuf);

	dirBuf(2) = 102h;
	do i = 2 to 25;
		dirBuf(i + 1) = dirBuf(i) + 1;
	end;
	call absio(6, disk, 101h, .dirBuf);
	call clearbuf(.dirBuf);

	dirBuf(2) = 202h;
	do i = 2 to countBitMapSectors;
		dirBuf(i + 1) = dirBuf(i) + 1; 
	end;
	call absio(6, disk, 201h, .dirBuf);
	call clearbuf(.dirBuf);

	call absio(6, disk, binHdrBlk, .dirBuf);
	call clearBuf(.direct);

	call moveAscii(.direct(0).file, .dirFile, 9);
	direct(0).blk = 25;
	direct(0).hdrBlk = 101h;
	direct(0).empty = 0;
	direct(0).attrib = 1;
	direct(0).eof$count = 80h;

	call moveAscii(.direct(1).file, .mapFile, 9);
	direct(1).blk = countBitMapSectors;
	direct(1).hdrBlk = 201h;
	direct(1).empty = 0;
	direct(1).attrib = 1;
	direct(1).eof$count = 80h;

	call moveAscii(.direct(2).file, .t0File, 9);
	direct(2).blk = 23;
	direct(2).hdrBlk = 18h;
	direct(2).empty = 0;
	direct(2).attrib = 1;
	direct(2).eof$count = 80h;

	call moveAscii(.direct(3).file, .labFile, 9);
	if diskType then
		direct(3).blk = 53;
	else
		direct(3).blk = 1;
	direct(3).hdrBlk = 19h;
	direct(3).empty = 0;
	direct(3).attrib = 1;
	direct(3).eof$count = 80h;

	call moveAscii(.direct(4).file, .binFile, 9);
	direct(4).blk = 0;
	direct(4).hdrBlk = binHdrBlk;
	direct(4).empty = 0;
	direct(4).attrib = 3;
	direct(4).eof$count = 80h;

	do i = 5 to 7;
		direct(i).empty = 7fh;
	end;
	call absio(6, disk, 102h, .direct);	
	call clearBuf(.direct);
	do i = 0 to 7;
		direct(i).empty = 7fh;
	end;
	do i = 2 to 25;
		call absio(6, disk, 101h + i, .direct);
	end;
	call setblock(101h);
	do jj = 102h to 11ah;
		call setblock(jj);
	end;
	call setblock(201h);
	do jj = 202h to 202h +  countBitMapSectors - 1;
		call setblock(jj);
	end;
	call setblock(18h);
	do jj = 1 to 17h;
		call setblock(jj);
	end;
	call setblock(19h);
	if diskType then
	do;
		do jj = 1ah to 34h;
			call setblock(jj);
		end;
		do jj = 11bh to 134h;
			call setblock(jj);
		end;
	end;
	else
		call setblock(1ah);
	call setblock(binHdrBlk);
	call absio(6, disk, 202h, .bitmap);
	call absio(6, disk, 203h, .bitmap +  80h);
	if diskType then
	do;
		call absio(6, disk, 204h, .bitmap + 100h);
		call absio(6, disk, 205h, .bitmap + 180h);
	end;
end;
end;
?monitr.patch
p 0013 02       # source for details
cusp5/makefile
ITOOLS ?= ../../..
ifdef LIB
	TARGETDIR = ../$(LIB)/
endif
TARGETS=$(TARGETDIR)cusp5.lib
unexport ISIS_F1

include $(ITOOLS)/tools/isis.mk

PLMFLAGS = code

OBJS = alloc.obj direct.obj absio.obj clrbuf.obj chklab.obj d.obj dblank.obj\
       diskio.obj dlimit.obj dmeq.obj ferror.obj fmttrk.obj forupp.obj\
       getdsk.obj getlab.obj mvasci.obj monitr.obx meq.obj numout.obj path.obj\
       popula.obj reperr.obj scanin.obj serror.obj seq.obj setblk.obj\
       tabwrt.obj upcase.obj unpath.obj wrtdir.obj wdlmt.obj wpath.obj\
       cpyrit.obj

REF = $(call ipath,toolbox,1.0)

PLMFLAGS = code
PLM80 = 3.1

all::
	$(MAKE) $(TARGETS)

$(TARGETDIR)cusp5.lib: $(OBJS)
	$(call lib,$@,$^)

%.obx: %.obj %.patch
	$(ITOOLS)/tools/fixobj -p $*.patch $*.obj $@
cusp6/cusp6_all.src
?absio.plm
ABSIO: DO;
/* b1=01, b2=10, CODE(3DH) byte, DATA(DH) byte, STACK(4H) byte, MEMORY(0H) byte,*/
DECLARE DCB$T LITERALLY 'STRUCTURE (iocw BYTE, ioins BYTE, nsec BYTE, tadr BYTE, sadr BYTE, buf ADDRESS)';

diskio: procedure(disk, dcb$ptr) external; declare (disk, dcb$ptr) address; end;

absio: procedure(cmd, disk, block, buffer) public;
	declare (cmd, disk) byte, (block, buffer) address;
	declare dcb DCB$T;

	dcb.iocw = 80H;
	dcb.ioins = cmd;
	dcb.nsec = 1;
	dcb.tadr = high(block);
	dcb.sadr = low(block);
	dcb.buf = buffer;
	call diskio(disk, .dcb);
end;
end;

?alloc.plm
ALLOC: DO;
declare	mapBase address public,
	maskArray(*) byte public data(80H, 40H, 20H, 10H, 8, 4, 2, 1);
end;
?chklab.plm
CHECKLABEL: DO;

write: procedure (conn, buff$p, count, status$p) external;
    declare (conn, buff$p, count, status$p) address;
end write;

getDisk: procedure(arg1b) external;
	declare arg1b byte;
end;

getLabel: procedure(lab, device) external;
	declare lab address, device byte;
end;

seq: procedure(s1, s2, cnt) byte external;
	declare (s1,s2) address, cnt byte;
end;

CHECKLABEL: procedure(matchLab, device, disk) public;
	declare matchLab address, (device, disk) byte;
	declare status address, lab(11) byte;

	if device >  9 then
		return;

	do while (1);
		call GETDISK(disk);
		
		call GETLABEL(.lab, device);
		if SEQ(matchLab, .lab, 9) then
			return;
		lab(0) = device + '0';
		call WRITE(0, .('WRONG DISKETTE IN DRIVE '), 24, .status);
		call WRITE(0, .lab, 1, .status);
		call WRITE(0, .(0DH, 0AH), 2, .status);
	end;
end;

end;
?clrbuf.plm
clearbuf: DO;

clearbuf: procedure(buf$ptr) public;
    declare buf$ptr address, i byte,
        buf based buf$ptr (1) byte;

    do i = 0 to 127;
        buf(i) = 0;
    end;
end;
end;
?cpyrit.plm
COPYRIGHT: DO;
end;
?d.plm
D: DO;
sFileError: procedure(status, filename) external;
    declare (status, filename) address;
end;
open: procedure (conn$p, path$p, access, echo, status$p) external;
    declare (conn$p, path$p, access, echo, status$p) address;
end open;

read: procedure (conn, buff$p, count, actual$p, status$p) external;
    declare (conn, buff$p, count, actual$p, status$p) address;
end read;

write: procedure (conn, buff$p, count, status$p) external;
    declare (conn, buff$p, count, status$p) address;
end write;

close: procedure (conn, status$p) external;
    declare (conn, status$p) address;
end close;

delimit: procedure(ptr) address external;
    declare ptr address, ch based ptr byte;
end;

NumOut: procedure(value, base, lc, bufAdr, width) external;
    declare (value, bufAdr) address, (base, lc, width) byte;
end;

YPath: procedure(int, ext) external;
    declare (int, ext) address;
end;

deblank: procedure(ptr) address external;
    declare ptr address;
end;

spath: procedure (path$p, info$p, status$p) external;
    declare (path$p, info$p, status$p) address;
end spath;

Population: procedure(bufferLoc, len) address external;
    declare (bufferLoc, len) address;
end;

meq: procedure(mPtr, fptr) byte external;
    declare (mPtr, fptr) address;
end;

memck: procedure address external; end;

declare diskType byte external;
declare wcUsed byte external;




declare isisMapFile(*) byte initial(':F :ISIS.MAP '),
    isisLabFile(*) byte initial(':F :ISIS.LAB '),
    isisDirFile(*) byte initial(':F :ISIS.DIR '),
    blksUsedMsg(*) byte initial('XXXXX/YYYYY BLOCKS USED', 0DH, 0AH),
    dirHeader(*) byte initial('NAME  .EXT  BLKS   LENGTH ATTR', 0DH, 0AH);

declare	crlf(2) byte data(0DH, 0AH),
    dirOfMsg(*) byte data('DIRECTORY OF ');

D: procedure(drive, conn, packedListing, attribMask, twoCol, summary, fNamePat) public;
    declare (drive, conn, packedListing, attribMask, twoCol, summary) byte, fNamePat address;
    declare (dconn, status, actual) address,
        (sectUsed, highFileSize, lowFileSize) address,
        totalSectUsed address,
        strBuf(15) byte,
        path(15) byte,
        (i, j) byte,
        maxDirectPtr address, maxDirCount address,
        (mapBufSize, maxBlocks, curDirCount) address,
        colTwo byte, directPtr address;

        
    declare direct based directPtr structure(status byte, name(6) byte, ext(3) byte,
                      attrib byte, eof$count byte, blk address, hdrBlk address);

    bigAdd: procedure(n);
        declare n address;
        lowFileSize = lowFileSize + n;
        if lowFileSize > 9999 then
        do;
            highFileSize = highFileSize + lowFileSize / 10000;
            lowFileSize = lowFileSize mod 10000;
        end;
    end;

    loadDir: procedure;
        declare i byte;

        directPtr = .MEMORY;
        do while directPtr < maxDirectPtr;
            call READ(dconn, directPtr, 128, .actual, .status);
            do i = 1 to 8;
                if not direct.status then
                do;
                    if (direct.attrib and not attribMask) or
                        not Meq(fNamePat, .direct) then
                       direct.status = 0ffh;
                    else if not wcUsed then
                    do;
                        curDirCount = maxDirCount;
                        MEMORY(directPtr - .MEMORY + size(direct)) = 7fh;
                        return;
                    end;
                end;
                else if direct.status = 7fh then
                do;
                    curDirCount = maxDirCount;
                    directPtr = .MEMORY;
                    return;
                end;
                directPtr = directPtr + size(direct);
            end;
            curDirCount = curDirCount + 8;
            if curDirCount = maxDirCount then
                maxDirectPtr = directPtr;
        end;
        direct.status = 7fh;
        directPtr = .MEMORY;
    end;





    maxDirCount = 200;
    mapBufSize = 251;
    maxBlocks = 2002;
    if diskType = 1 then	/* DD */
    do;
        mapBufSize = 501;
        maxBlocks = 4004;
    end;
    else if diskType = 4 then /* HD */
    do;
        maxDirCount = 992;
        mapBufSize = 3600;
        maxBlocks = 28800;
    end;

    isisMapFile(2), isisLabFile(2), isisDirFile(2) = drive + '0';
    call Open(.dconn, .isisLabFile, 1, 0, .status);
    call sFileError(status, .isisLabFile);
    strBuf(0) = drive;
    call Read(dconn, .strBuf(1), 9, .actual, .status);
    call Write(conn, .dirOfMsg, 13, .status);
    call Ypath(.strBuf, .path);
    i = Delimit(.path) - .path;
    call Write(conn, .path, i, .status);
    call Write(conn, .crlf, 2, .status);
    call close(dconn, .status);
    if summary then
	;
    else
    do;
        if not packedListing then
        do;
		if twoCol then
		do;
		    call Write(conn, .dirHeader, size(dirHeader) - 2, .status);
		    call Write(conn, .('      '), 6, .status);
		end;
		call Write(conn, .dirHeader, size(dirHeader), .status);
        end;
        call Open(.dconn, .isisDirFile, 1, 0, .status);
        totalSectUsed = 0;
        colTwo = 0ffh;
        maxDirectPtr = memck - 128;	/* make sure there is room for 1 last sector */
        curDirCount = 0;
        do while curDirCount <> maxDirCount;
            call loadDir;
            do while direct.status <> 7fh;
                if not direct.status then
                do;
                    if twoCol then
                        colTwo = not colTwo;
                    do i = 0 to 8;
                        if direct.name(i) = 0 then
                            direct.name(i) = ' ';
                    end;
                    i = 9;
                    if packedListing then	
                        do while direct.name(i - 1) = ' ';
                            i = i - 1;
                        end;
                    if not packedListing or i > 6 then
                        j = 6;
                    else	
                        j = i;
                    call Write(conn, .direct.name, j, .status);
                    if packedListing then
                    do;
                        if i > 6 then
                        do;
                            call Write(conn, .('.'), 1, .status);
                            call Write(conn, .direct.ext, i - 6, .status);
                            i = i + 1;
                        end;
                    end;
                    else
                    do;
                        if direct.ext(0) <> ' ' then
                            call Write(conn, .('.'), 1, .status);
                        call Write(conn, .direct.ext, 3, .status);
                        if direct.ext(0) = ' ' then
                            call Write(conn, .(' '), 1, .status);
                        sectUsed = direct.blk;
                        if sectUsed > 0 then
                            sectUsed = sectUsed + (sectUsed + 61) / 62;
                        else
                            sectUsed = 1;
                        totalSectUsed = totalSectUsed + sectUsed;
                        call NumOut(sectUsed, 10, ' ', .strBuf, 6);
                        call Write(conn, .strBuf, 6, .status);
                        sectUsed = direct.blk;
                        lowFileSize, highFileSize = 0;
                        if sectUsed > 0 then
                        do;
                            sectUsed = sectUsed - 1;
                            lowFileSize = direct.eof$count;
                            do while sectUsed >= 400;
                                sectUsed = sectUsed - 400;
                                call bigAdd(128 * 400);
                            end;
                        end;
                        call bigAdd(128 * sectUsed);
     
                        if highFileSize <> 0 then
                        do;
                            call NumOut(highFileSize, 10, ' ', .strBuf, 5);
                            call NumOut(lowFileSize, 10, '0', .strBuf(5), 4);
                        end;
                        else
                            call NumOut(lowFileSize, 10, ' ', .strBuf, 9);
                        call Write(conn, .strBuf, 9, .status);
                        if direct.attrib <> 0 or not colTwo then
                        do;
                            do i = 0 to 4;
                                strbuf(i) = ' ';
                            end;
                            if (direct.attrib and 4) <> 0 then
                                strbuf(1) = 'W';
                            if (direct.attrib and 2) <> 0 then
                                strbuf(2) = 'S';
                            if direct.attrib then
                                strbuf(3) = 'I';
                            if (direct.attrib and 80h) <> 0 then
                                strbuf(4) = 'F';
                            call write(conn, .strbuf, 5, .status);
                        end;
                        i = 10;
                    end;
                    if colTwo then
                        call Write(conn, .crlf, 2, .status);
                    else
                        call Write(conn, .('               '), 16 - i, .status);
                end;
                directPtr = directPtr + size(direct);
            end;
        end; 
        call Close(dconn, .status);
        if not colTwo then
            call Write(conn, .crlf, 2, .status);
    	if not packedListing then
    	do;
            if twoCol then
                i = 35;
            else
                i = 16;
            call NumOut(totalSectUsed, 10, ' ', .MEMORY, i);
            call Write(conn, .MEMORY, i, .status);
            call Write(conn, .crlf, 2, .status);
    	end;
    end; 
    call Open(.dconn, .isisMapFile, 1, 0, .status);
    call Read(dconn, .MEMORY, mapBufSize, .actual, .status);
    call NumOut(Population(.MEMORY, mapBufSize), 10, 0, .blksUsedMsg, 5);
    call NumOut(maxBlocks, 10, 0, .blksUsedMsg + 6, 5);
    call Write(conn, .blksUsedMsg, size(blksUsedMsg), .status);
    call Close(conn, .status);
end;
end;
?dblank.plm
DEBLANK: DO;
deblank: procedure(ptr) address public;
	declare ptr address, c based ptr byte;

	do while (c = ' ');
		ptr = ptr + 1;
	end;
	return ptr;
end;

end;
?direct.plm
DIRECT: DO;
declare DIRECT(16) byte public;
declare DIRECTINO address public;
end;
?diskio.plm
DISKIO: DO;
isis: procedure(syscmd, param$p) external; declare syscmd byte, param$p address; end;

diskio: procedure(disk, dcb$p) public;
	declare (disk, dcb$p) address; 
	declare param structure(disk address, dcb$p address);
	
	param.disk = disk;
	param.dcb$p = dcb$p;
	call isis(44H, .param);
end;
end;
?dlimit.plm
DELIMIT: DO;
delimit: procedure(ptr) address public;
	declare ptr address, ch based ptr byte;

	do while ch = ':' or ch = '.' or
		 ('0' <= ch and ch <= '9') or
		 ('A' <= ch and ch <= 'Z');
		ptr = ptr + 1;
	end;
	return ptr;
end;
end;
?dmeq.plm
DMEQ: DO;
declare TRUE	literally '0FFH',
	FALSE	literally '0';

read: procedure (conn, buff$p, count, actual$p, status$p) external;
    declare (conn, buff$p, count, actual$p, status$p) address;
end read;

seek: procedure (conn, mode, block$p, byte$p, status$p) external;
    declare (conn, mode, block$p, byte$p, status$p) address;
end seek;

meq: procedure(A, B) byte external ; declare (A,B) address; end;

ReportError: procedure(errNum) external;
	declare errNum address;
end;

declare diskType byte external;

dmeq: procedure (dirAftn, searchArg, initialINo, dirEntry) address public;
    declare (dirAftn, searchArg, initialINo, dirEntry) address;
    declare (byteNo, blockNo, actual, status) address;
    declare pastDir address, searching byte;
    declare dirFlag based dirEntry byte;

	blockNo = 0;
	byteNo = initialINo * 16;
	call seek(dirAftn, 2, .blockNo, .byteNo, .status);

	if status <> 0 then
		;
	if diskType = 4 then	/* hard disk */
		pastDir = 993;
	else
		pastDir = 201;
	
	searching = TRUE;
	do while searching;
		call read(dirAftn, dirEntry, 16, .actual, .status);
		if dirFlag = 7Fh or actual = 0 then
			return pastDir;
		searching = not meq(searchArg, dirEntry);
		initialINo = initialINo + 1;
	end;

	return initialINo;
end;
end;
?dtype.plm
DTYPE: DO;

Spath: procedure(path$p, info$p, status$p) external;
    declare (path$p, info$p, status$p) address;
end;

declare isisDrive(*) byte initial(':FX: ');

DType: procedure(drive) byte public;
    declare drive byte;
    declare status address, info(12) byte;

    if  drive > 9 then
        return 0;
    isisDrive(2) = drive + '0';
    call Spath(.isisDrive, .info, .status);
    return info(11);
end;
end;
?ferror.plm
FILEERROR: DO;

write: procedure (conn, buff$p, count, actual$p) external;
    declare (conn, buff$p, count, actual$p) address;
end write;

exit: procedure external; end exit;

deblank: procedure(str) address external; declare str address; end;
WDelimit: procedure(ptr) address external; declare ptr address; end;
reporterror: procedure(status) external; declare status address; end;

declare OK literally '0';

fileerror: procedure(status, ptr, callExit) public;
	declare (status, ptr) address;
	declare callExit byte;
	declare actual address;

	if status <> OK then
	do;
		ptr = deblank(ptr);
		call write(0, .(' '), 1, .actual);
		call write(0, ptr, WDelimit(ptr) - ptr, .actual);
		call write(0, .(','), 1, .actual);
		call reporterror(status);
		if callExit then
			call exit;
	end;
end;
end;
?fmttrk.plm
formatTrack: do;

declare DCB$T literally 'STRUCTURE (iocw BYTE, ioins BYTE, nsec BYTE, tadr BYTE, sadr BYTE, buf ADDRESS)';

Diskio: procedure(disk, dcb$p) external; declare disk address, dcb$p address; end;
declare diskType byte external;

FormatTrack: procedure(disk,sTrack,eTrack,interleave) public;
	declare (disk,interleave) byte, (sTrack, eTrack) address;
	declare curTrack address, (sectors, vTracks) byte;
	declare (i,j,interTrackSkew) byte, trackBuf(104) byte,
	dcb DCB$T;

	if diskType = 4 then	/* HD */
	do;
		sectors = 36;
		interTrackSkew = 17;
	end;
	else if diskType = 1 then	/* DD */
	do;
		sectors = 52;
		interTrackSkew = 7;
	end;
	else
	do;
		sectors = 26;
		interTrackSkew = 4;
	end;

	dcb.iocw = 0c0h;
	vTracks = sectors * 2 - 1;
	do i = 1 to vTracks by 2;
		trackBuf(i) = 0c7h;
	end;

	j = 0;

	if diskType = 4 then
	do;
		sTrack = sTrack * 4;
		eTrack = eTrack * 4 + 3;
	end;

	do curTrack = sTrack to eTrack;
		dcb.ioins = 2;
		do i = 0 to vTracks by 2;
			trackBuf(i) = 0;
		end;
		do i = 1 to sectors;
			j = (j + interleave) mod sectors;
			do while trackBuf(j * 2) <> 0;
				j = (j + 1) mod sectors;
			end;
			trackBuf(j + j) = i;
		end;
		if diskType <> 4 then
			dcb.tadr = curTrack;
		else
		do;
			dcb.tadr = curTrack / 4;
			dcb.sadr = (curTrack mod 4) * 36 + 1;
		end;
		dcb.buf = .trackBuf;
		call Diskio(disk, .dcb);
		j = j + interTrackSkew;
	end;
end;
end;
?forupp.plm
FORCEUPPER: DO;
declare CR literally '0DH';

uppercase: procedure(ch) byte external; declare ch byte; end;

forceupper: procedure(bufferPtr) public;
	declare bufferPtr address, ch based bufferPtr byte;

	do while ch <> CR;
		ch = uppercase(ch);
		bufferPtr = bufferPtr + 1;
	end;
end;
end;
?getdsk.plm
GetDisk: do;

Write: procedure(conn, buff$p, count, status$p) external;
         declare conn address, buff$p address, count address, status$p address; end;

Read: procedure(conn, buff$p, count, actual$p, status$p) external;
        declare conn address, buff$p address, count address, actual$p address, status$p address; end;


declare source(3) structure(name(6) byte) data('SYSTEM', 'SOURCE', 'OUTPUT');

GetDisk: procedure(n) public;
	declare n byte;
	declare buf(128) byte, status address, junk address, actual address;

	call Write(0, .('LOAD '), 5, .status);
	call Write(0, .source(n), 6, .status);
	call Write(0, .(' DISK, THEN TYPE (CR)'), 21, .status);
	call Read(1, .buf, 128, .actual, .status);
end;
end;
?getlab.plm
GETLABEL: DO;

read: procedure (conn, buff$p, count, actual$p, status$p) external;
    declare (conn, buff$p, count, actual$p, status$p) address;
end read;

open: procedure (conn$p, path$p, access, echo, status$p) external;
    declare (conn$p, path$p, access, echo, status$p) address;
end open;

close: procedure (conn, status$p) external;
    declare (conn, status$p) address;
end close;

SFileError: procedure(status, name$p) external;
	declare (status, name$p) address;
end;

declare isisLabFile(*) byte initial(':FX:ISIS.LAB', 0);

GetLabel: procedure(labBuf, device) public;
	declare labBuf address, device byte;
	declare (status, actual, conn) address;

	if device > 9 then
		return;
	isisLabFile(2) = device + '0';
	call Open(.conn, .isisLabFile, 1, 0, .status);
	call SFileError(status, .isisLabFile);
	call Read(conn, labBuf, 9, .actual, .status);
	call SFileError(status, .isisLabFile);
	call Close(conn, .status);
	call SFileError(status, .isisLabFile);
end;
end;
?meq.plm
MEQ: DO;
declare TRUE literally '0ffh';

meq: procedure(mPtr, fptr) byte public;
	declare (mPtr, fptr) address, i byte;
	declare m based mPtr (10) byte;
	declare f based fptr (10) byte;

	do i = 0 to 9;
		if m(i) = '?' then
		do;
			if f(i) = 0 then
				return 0;
		end;
		else if m(i) <> '*' then
		do;
			if m(i) <> f(i) then
				return not TRUE;
		end;
	end;
	return TRUE;
end;
end;

?monitr.plm
MONITOR: DO;
MONITOR: procedure public;
	declare sp address, wrd based sp  address;

	sp = STACKPTR;
	wrd = 8;	
/*
    code below should be -2 but compiler optimises this to
    dcx x2. using -3 generates the expected code sequence
    and a post build patch changes the 3 to a 2
*/
	STACKPTR = STACKPTR - 3;
	sp = STACKPTR;
	wrd = 0;
end;
end;
?mvasci.plm
MOVEASCII: DO;
moveascii: procedure(dst, src, cnt) public;
	declare (dst, src) address, cnt byte, i byte;
	declare dch based dst (1) byte, sch based src (1) byte;

	do i = 0 to cnt - 1;
		dch(i) = sch(i);
	end;
end;
end;
?numout.plm
NUMOUT: DO;


numout: procedure(value, base, lc, bufAdr, width) public;
	declare (value, bufAdr) address, (base, lc, width) byte; 
	declare i byte;
	declare buf based bufAdr (1) byte;
	declare digits(*) byte data('0123456789ABCDEF');

	do i = 1 to width;
		buf(width - i) = digits(value mod base);
		value = value / base;	
	end;

	i = 0;
	do while buf(i) = '0' and i < width - 1;
		buf(i) = lc;
		i = i + 1;
	end;
end;
end;
?path.plm
PATH: DO;
moveascii: procedure(dst, src, cnt) external;
	declare (dst, src) address, cnt byte;
end;

Spath: procedure(filename, info$p, status$p) external;
	declare (filename, info$p, status$p) address;
end;

PATH: procedure(filename, pn) byte public;
	declare (filename, pn) address;
	declare info(12) byte, status byte;

	call Spath(filename, .info, .status);	/* bug? status only a byte */
	call MoveAscii(pn, .info, 10);
	return status;
end;
end;
?popula.plm
population: do;

declare bitCnt(*) byte initial(
	0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,
	1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
	1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
	1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
	3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
	1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
	3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
	3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
	3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
	4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8);

Population: procedure(bufferLoc, length) address public;
	declare (bufferLoc, length, total) address,
	(i, t, l) byte;
	declare buffer based bufferLoc (1) byte;

	total = 0;
	do while length > 31;
		t = 0;
		do i = 0 to 30;
			t = t + bitCnt(buffer(i));
		end;
		total = total + t;
		bufferLoc = bufferLoc + 31;
		length = length - 31;
	end;
	l = length - 1;
	t = 0;
	do i = 0 to l;
		t = t + bitCnt(buffer(i));
	end;
	return total + t;
end;
end;
?reperr.plm
REPORTERROR: DO;

error: procedure(errNum) external; declare errNum address; end;

write: procedure(aftn, buf$ptr, len, status$ptr) external;
   declare (aftn, buf$ptr, len, status$ptr) address;
end write;

declare CR	literally '0dh';
declare LF	literally '0ah';

reporterror: procedure(errNum) public;
	declare errNum address;
	declare numberBuffer(3) byte;
	declare (i, status) address;
 
	declare msg(*) byte DATA(0, 0,
		2, 'ILLEGAL AFTN ARGUMENT', 0,
		4, 'INCORRECTLY SPECIFIED FILE', 0,
		5, 'UNRECOGNIZED DEVICE NAME', 0,
		6, 'ATTEMPT TO WRITE TO INPUT DEVICE', 0,
		8, 'ATTEMPT TO READ FROM OUTPUT DEVICE', 0,
		9, 'DISK DIRECTORY FULL', 0,
		0AH, 'NOT ON SAME DISK', 0,
		0BH, 'FILE ALREADY EXISTS', 0,
		0CH, 'FILE IS ALREADY OPEN', 0,
		0DH, 'NO SUCH FILE', 0,
		0EH, 'WRITE PROTECTED', 0,
		11H, 'NOT A DISK FILE', 0,
		12H, 'ILLEGAL ISIS COMMAND', 0,
		13H, 'ATTEMPTED SEEK ON NON-DISK FILE', 0,
		14H, 'ATTEMPTED BACK SEEK TOO FAR', 0,
		15H, 'CAN''T RESCAN', 0,
		16H, 'ILLEGAL ACCESS MODE TO OPEN', 0,
		17H, 'MISSING FILENAME', 0,
		19H, 'ILLEGAL ECHO FILE', 0,
		1AH, 'ILLEGAL ATTRIBUTE IDENTIFIER', 0,
		1BH, 'ILLEGAL SEEK COMMAND', 0,
		1CH, 'MISSING EXTENSION', 0,
		1FH, 'CAN''T SEEK ON WRITE ONLY FILE', 0,
		20H, 'CAN''T DELETE OPEN FILE', 0,
		23H, 'SEEK PAST EOF', 0,
		0C9H, 'UNRECOGNIZED SWITCH', 0,
		0CAH, 'UNRECOGNIZED DELIMITER', 0,
		0CBH, 'INVALID SYNTAX', 0,
		0CCH, 'PREMATURE EOF', 0,
		0CEH, 'ILLEGAL DISKETTE LABEL', 0,
		0D0H, 'CHECKSUM ERROR', 0,
		0D1H, 'RELO FILE SEQUENCE ERROR', 0,
		0D2H, 'INSUFFICIENT MEMORY', 0,
		0D3H, 'RECORD TOO LONG', 0,
		0D4H, 'ILLEGAL RELO RECORD', 0,
		0D5H, 'FIXUP BOUNDS ERROR', 0,
		0D6H, 'ILLEGAL SUBMIT PARAMETER', 0,
		0D7H, 'ARGUMENT TOO LONG', 0,
		0D8H, 'TOO MANY PARAMETERS', 0,
		0D9H, 'OBJECT RECORD TOO SHORT', 0,
		0DAH, 'ILLEGAL RECORD FORMAT', 0,
		0DBH, 'PHASE ERROR', 0,
		0EAH, 'CANNOT FORMAT FROM TARGET DRIVE', 0,
		0EBH, 'NON-DISK DEVICE', 0
		);


	if errNum <> 0 then
	do;
		i = 0;
		do while i < size(msg);
			if errNum = msg(i) and msg(i + 1) <> 0 then
			do;
				i = i + 1;
				call write(0, .(' '), 1, .status);
				do while msg(i) <> 0;
					call write(0, .msg(i), 1, .status);
					i = i + 1;
				end;
				call write(0, .(CR, LF), 2, .status);
				return;
			end;
			else
			do;
				do while msg(i) <> 0;
					i = i + 1;
				end;
				i = i + 1;
			end;
		end;
	call error(errNum);
	end;
end;
end;
?scanin.plm
scanIn: do;

declare digits(*) byte data('0123456789ABCDEF');

ScanInteger: procedure(ptrPtr) address public;
	declare ptrPtr address;
	declare ptr based ptrPtr address;
	declare (scanPtr, updatePtr, stopPtr) address;
	declare (i, radix, increment) byte;
	declare (nVal, oVal) address;
	declare c based scanPtr byte;

	scanPtr = ptr;
	do while c = ' ';
		scanPtr = scanPtr + 1;
	end;
	ptr = scanPtr;
	do while '0' <= c and c <= '9' or 'A' <= c and c <= 'F';
		scanPtr = scanPtr + 1;
	end;

	stopPtr = scanPtr;
	updatePtr = scanPtr + 1;
	if c = 'H' then
		radix = 16;
	else if c = 'O' or c = 'Q' then
		radix = 8;
	else
	do;
		updatePtr = scanPtr;
		stopPtr, scanPtr = scanPtr - 1;
		if c = 'B' then
			radix = 2;
		else
		do;
			radix = 10;
			if c <> 'D' then	/* include last increment */
				stopPtr = stopPtr + 1;
		end;
	end;
	scanPtr = ptr;
	nVal, oVal = 0;
	do while scanPtr < stopPtr;
		do i = 0 to 15;
			if c = digits(i) then
				increment = i;
		end;
		if increment >= radix then
			return 0;
		nVal = oVal * radix + increment;
		if nVal < oVal then
			return 0;
		oVal = nVal;
		scanPtr = scanPtr + 1;
	end;
	ptr = updatePtr;
	return nVal;
end;
end;
?seq.plm
SEQ: DO;

declare TRUE literally '0ffh';

seq: procedure(s1, s2, len) byte public;
	declare (s1,s2) address, (len, i) byte;
	declare s1a based s1(1) byte;
	declare s2a based s2(1) byte;

	len = len - 1;
	do i = 0 to len;
		if s1a(i) <> s2a(i) then
			return not TRUE;
	end;
	return TRUE;
end;
end;
?serror.plm
SFileError: do;
declare boolean literally 'byte';

Write: procedure(conn, buff$p, count, status$p) external;
         declare conn address, buff$p address, count address, status$p address; end;

Exit: procedure external; end;

deblank: procedure(ptr) address external; declare ptr address; end;

WDelimit: procedure(ptr) address external; declare ptr address; end;

GetDisk: procedure(n) external; declare n byte; end;

ReportError: procedure(errNum) external; declare errNum address; end;

declare singleDrive boolean external;

SFileError: procedure(status, name$p) public;
	declare (status, name$p) address;
	declare lStatus address;

	if status <> 0 then
	do;
		if singleDrive then
			call GetDisk(0);
		name$p = Deblank(name$p);
		call Write(0, .(' '), 1, .lStatus);
		call Write(0, name$p, WDelimit(name$p) - name$p, .lStatus);
		call Write(0, .(','), 1, .lStatus);
		call ReportError(status);
		call Exit;
	end;
end;
end;
?setblk.plm
SetBlock: do;
declare mapBase address external;
declare maskArray(1) byte external;
declare diskType byte external;

SetBlock: procedure(adr) public;
	declare adr address;
	declare (bit, byt) address, spt byte;
	declare bitmap based mapBase (1) byte;

	if diskType = 4 then
		spt = 90h;
	else if diskType = 1 then
		spt = 34h;
	else
		spt = 1ah;

	bit = high(adr) * spt + low(adr) - 1;
	byt = shr(bit, 3);
	bitmap(byt) = bitmap(byt) or maskArray(low(bit) and 7);
end;
end;
?setmap.plm
SetupMap: do;
declare CR literally '0dh';
declare LF literally '0ah';

Write: procedure(conn, buff$p, count, status$p) external;
         declare conn address, buff$p address, count address, status$p address; end;

Exit: procedure external; end;

Absio: procedure(cmd, disk, block, buffer) external;
         declare cmd byte, disk byte, block address, buffer address; end;

numout: procedure(val, base, lc, bufAdr, width) external;
          declare val address, base byte, lc byte, bufAdr address, width byte; end;

SetBlock: procedure(adr) external; declare adr address; end;

declare mapBase address external;
declare maskArray(1) byte external;
declare diskType byte external;

declare fatalMsg(*) byte initial(' FATAL',
/* 6 */		               ' BAD SPOT AT LOGICAL ADDRESS ( ',
/* 37 */		       '***, ',
/* 42 */		       '*** ), STATUS = ',
/* 58 */		       '****', CR, LF);

declare trap0B structure(jmp byte, target address) at (0bh),
	trap0E address at (0eh);

declare trap0BCodeLocation address data(.SetupMap + 0DCh);
declare bitmap based mapBase (1) byte;

SetupMap: procedure(disk) address public;
	declare disk byte;
	declare logicalTrackSector address,
		(logicalSector, logicalTrack) byte at (.logicalTrackSector),
		(readBuf, savedSP) address,
		savedTrap0B structure(jmp byte, target address),
		(badSectorCount, headFixItemPtr, nextFixItemPtr, fixItemPtr) address,
		j byte, (i, bitmapLast, status) address;
	declare fixItem based fixItemPtr structure(sector byte, driveErr address, next address);

	ChkFixedSectors: procedure;
		if (logicalTrack = 0 and (logicalSector < 1Ch or logicalSector = 58h or logicalSector > 72h))
		  or (logicalTrack = 1 and (logicalSector < 40h or (48h < logicalSector and logicalSector < 88h)))
		  or (logicalTrack = 2 and logicalSector < 20h) then
		do;
			call NumOut(logicalTrack, 10, 0, .fatalMsg(37), 3);
			call NumOut(logicalSector, 10, 0, .fatalMsg(42), 3);
			call NumOut(trap0E, 16, 0, .fatalMsg(58), 4);
			call Write(0, .fatalMsg, 64, .status);
			call Exit;
		end;
	end;


	AddBadSector: procedure;
		declare (p, q) address;
		call ChkFixedSectors;
		call SetBlock(logicalTrackSector);
		fixItemPtr, p = headFixItemPtr;
		fixItemPtr = fixItem.next;

		/* look for insert point p->sector <  logicalsector and logicalsector <= *fixItemPtr */
		do while fixItem.sector < logicalSector;
			p = fixItemPtr;
			fixItemPtr = fixItem.next;
		end;
		if fixItem.sector = logicalSector then	/* already in list */
			return;

		q = fixItemPtr;				/* insert into list and set values */
		fixItemPtr = p;
		fixItem.next = nextFixItemPtr;
		fixItemPtr = nextFixItemPtr;
		fixItem.sector = logicalSector;
		fixItem.driveErr = trap0E;
		fixItem.next = q;
		nextFixItemPtr = nextFixItemPtr + size(fixItem);	/* set up next item */
	end;


	if diskType = 4 then	/* HD */
		bitmapLast = 3711;
	else if diskType = 1 then	/* DD */
		bitmapLast = 511;
	else
		bitmapLast = 255;	/* SD */

	do i = 0 to bitmapLast;
		bitmap(i) = 0;
	end;

	if diskType <> 4 then
		return 0;
	badSectorCount = 0;
	headFixItemPtr = (readBuf := mapBase + 3712) + 128;
	savedSP = STACKPTR;
	savedTrap0B.jmp = trap0B.jmp;
	trap0B.jmp = 0c3h;
	savedTrap0B.target = trap0B.target;
	trap0B.target = trap0BCodeLocation;
	logicalTrack = 0;

nextTrack:
	fixItemPtr = headFixItemPtr;
	fixItem.next = fixItemPtr + size(fixItem);
	fixItemPtr = headFixItemPtr + size(fixItem);
	fixItem.sector = 145;	/* max sector + 1 */
	nextFixItemPtr = fixItemPtr + size(fixItem);
	logicalSector = 1;

nextSector:
	call Absio(4, disk, logicalTrackSector, readBuf);
	goto skipTrap;

newTrap0B:
	STACKPTR = savedSP;
	trap0B.jmp = savedTrap0B.jmp;
	trap0B.target = savedTrap0B.target;
	if trap0E <> 1 and trap0E <> 10 then
		call AddBadSector;
	else
	do;
		/* mark all of the track under this head as bad. Note 4 heads per logical  track */
		logicalSector = (logicalSector - 1) - ((logicalSector - 1) mod 36);	/* first sector for head */
		do j = 1 to 36;
			logicalSector = logicalSector + 1;
			call AddBadSector;
		end;
	end;

	trap0B.jmp = 0c3h;
	trap0B.target = trap0BCodeLocation;

skipTrap:
	if (logicalSector := logicalSector + 1) < 145 then
		goto nextSector;

	fixItemPtr = headFixItemPtr;
	fixItemPtr = fixItem.next;

	do while fixItem.sector < 145;
		call NumOut(logicalTrack, 10, 0, .fatalMsg(37), 3);
		call NumOut(fixItem.sector, 10, 0, .fatalMsg(42), 3);
		call NumOut(fixItem.driveErr, 16, 0, .fatalMsg(58), 4);
		call Write(0, .fatalMsg(6), 58, .status);
		if logicalTrack > 1 then
			badSectorCount = badSectorCount + 1;
		fixItemPtr = fixItem.next;
	end;
	if (logicalTrack := logicalTrack + 1) < 200 then
		goto nextTrack;

	trap0B.jmp = savedTrap0B.jmp;
	trap0B.target = savedTrap0B.target;
	return badSectorCount;
end;
end;

?tabwrt.plm
TABWRITE: DO;

declare TAB	literally '9',
	CR	literally '0dh';

write: procedure (aft, buff$p, count, status) external;
    declare (aft, buff$p, count, status) address;
end write;

tabwrite: procedure(columnPtr, aft, bufferPtr, count, status) public;
	declare (columnPtr, aft, bufferPtr, count, status) address;
	declare (printChar, i, j) byte;
	declare column based columnPtr byte;
	declare ch based bufferPtr byte;

	do while count <> 0;
		i = ch = TAB and (7 - (column and 7));
		printChar = ch;
		bufferPtr = bufferPtr + 1;
		count = count - 1;
		if printChar = TAB then
			printChar = ' ';
		do j = 0 to i;
			if ch = CR then
				column = 0;
			if ch >= ' ' then
				column = column + 1;
			call write(aft, .printChar, 1, status);
		end;
	end;
end;
end;

?trange.plm
TESTRANGE: DO;

FileError: procedure(status, ptr, callExit) external;
	declare (status, ptr) address, callExit byte;
end;

ReportError: procedure(status) external; declare status address; end;

Exit: procedure external; end exit;

declare TRUE literally '0ffh';

TestRange: procedure(device, buffer$p) byte public;
	declare device byte, buffer$p address;

	if device >= 25 then	/* diskdrive 6-9 */
		device = device - 19;	/* bring disks together */
	else if device > 5 then		/* shift others above disks */
		device = device + 4;

	if device <=  9 or buffer$p = 1 then
		return device;
	if buffer$p <> 0 then
		call FileError(0EBh, buffer$p, TRUE);
	else
	do;
		call ReportError(0EBh);
		call exit;
	end;
end;
end;
?unpath.plm
UNPATH: DO;

declare devTab(*) byte data('F0F1F2F3F4F5TITO',
			     'VIVOI1O1TRHRR1R2',
			     'TPHPP1P2LPL1BBCICO',
			     'F6F7F8F9');

unpath:	procedure(int, ext) public;
	declare (int, ext) address;
	declare i byte;
	declare intName based int (1) byte;
	declare extName based ext (1) byte;

	extName(0) = ':';
	extName(1) = devTab(intName(0) + intName(0));
	extName(2) = devTab(intName(0) + intName(0) + 1);
	extName(3) = ':';	
	ext = ext + 4;
	do i = 0 to 5;
		if (extName(0) := intName(i + 1)) <> 0 then
			ext = ext + 1; 
	end;
	if intName(7) <> 0 then
	do;
		extName(0) = '.';
		ext = ext + 1;
	end;
	do i = 0 to 2;
		if (extName(0) := intName(i + 7)) <> 0 then
			ext = ext + 1; 

	end;
	extName(0) = ' ';
end;
end;
?upcase.plm
UPPERCASE: DO;
uppercase: procedure(char) byte public;
	declare char byte;
	if char < 'a' then
		return char;
	if char > 'z' then
		return char;
	return char and 0dfh;
end;
end;
?wdelim.plm
WDELIMIT: DO;
/* b1=01, b2=31, CODE(63H) byte, DATA(2H) byte, STACK(4H) byte, MEMORY(0H) byte,*/
.CODE
WDELIMIT:	; public
	lxi	h,D$0001
	mov	m,b
	dcx	h
	mov	m,c
L$0006:
	lhld	D$0000
	mov	a,m
	sui	3AH
	sui	1
	sbb	a
	push	psw
	mov	a,m
	sui	2EH
	sui	1
	sbb	a
	pop	b
	mov	c,b
	ora	c
	push	psw
	mov	a,m
	sui	2AH
	sui	1
	sbb	a
	pop	b
	mov	c,b
	ora	c
	push	psw
	mov	a,m
	sui	3FH
	sui	1
	sbb	a
	pop	b
	mov	c,b
	ora	c
	push	psw
	mov	a,m
	sui	30H
	sbb	a
	cma
	push	psw
	mvi	a,39H
	sub	m
	sbb	a
	cma
	pop	b
	mov	c,b
	ana	c
	pop	b
	mov	c,b
	ora	c
	push	psw
	mov	a,m
	sui	41H
	sbb	a
	cma
	push	psw
	mvi	a,5AH
	sub	m
	sbb	a
	cma
	pop	b
	mov	c,b
	ana	c
	pop	b
	mov	c,b
	ora	c
	rar
	jnc	L$005F
	lhld	D$0000
	inx	h
	shld	D$0000
	jmp	L$0006
L$005F:
	lhld	D$0000
	ret
.DATA
D$0000:
	BYTE(1)
D$0001:
	BYTE(1)
MODEND: CODE 0000

?wdlmt.plm
WDELIMIT: DO;
/* b1=01, b2=31, CODE(63H) byte, DATA(2H) byte, STACK(4H) byte, MEMORY(0H) byte,*/
wdelimit: procedure(ptr) address public;
	declare ptr address;
	declare ch based ptr byte;

	do while (ch = ':' or ch = '.' or ch = '*' or ch = '?' or
		  ('0' <= ch and ch <= '9') or ('A' <= ch and ch <= 'Z'));
		ptr = ptr + 1;
	end;
	return ptr;
end;
end;

?wpath.plm
WPATH: DO;
uppercase: procedure(char) byte external;
	declare char byte;
end;

TestRange: procedure(device, buffer$p) byte external;
	declare device byte, buffer$p address;
end;

declare FALSE literally '0';
declare TRUE literally '0FFh';


declare lastPathNameParsed(15) byte;

/* the error return codes */
declare BADFILESPEC	literally '4';
declare UNKNOWNDEV	literally '5';
declare MISSINGFNAME	literally '17h';
declare MISSINGEXT	literally '1ch';
declare NOERROR		literally '0';

declare devTab(*) byte data('F0F1F2F3F4F5TITOVIVOI1O1',
			    'TRHRR1R2TPHPP1P2LPL1BBCICOF6F7F8F9');

WPath: procedure(pathNamePtr, pn, wc) byte public;
	declare (pathNamePtr, pn, wc) address;
	declare ptr address;
	declare	addr address, (hi, lo) byte at (.addr);
	declare	devPtr address, (nullName, pl, i) byte;
	declare pathName based pathNamePtr (1) byte;
	declare pnStr based pn (1) byte;
	declare wcFlag based wc byte;
	declare dev based devPtr address;
	declare ch based ptr byte;
	
	NonTerminator: procedure byte;
		return ('A' <= pathName(0) and pathName(0) <= 'Z') or
		       ('0' <= pathName(0) and pathName(0) <= '9') or
		       pathName(0) = '?' or pathName(0) = '*' or
		       ('a' <= pathName(0) and pathName(0) <= 'z');
	end;
	wcFlag = FALSE;
	devPtr = .devTab;
	do i = 0 to 9;
		pnStr(i) = 0;
	end;
	do while pathName(0) = ' ';
		pathNamePtr = pathNamePtr + 1;
	end;

	ptr = pathNamePtr;
	if pathName(0) = ':' then
	do;
		if pathName(3) <> ':' then
			return BADFILESPEC;	/* incorrectly specified file */
		pathNamePtr = pathNamePtr + 1;
		hi = Uppercase(pathName(0));
		pathNamePtr = pathNamePtr + 1;
		lo = Uppercase(pathName(0));
		pathNamePtr = pathNamePtr + 2;
		pnStr(0) = 0FFh;
		i = 0;
		do while i < 57;
			if dev = addr then
				pnStr(0) = shr(i, 1);
			i = i + 2;
			devPtr = devPtr + 2;
		end;
		if pnStr(0) = 0FFh then
			return UNKNOWNDEV;	/* unrecognized device pathName */
	end;
	nullName = TRUE;
	i = 1;
	do while i < 7;
		if NonTerminator then
		do;
			pnStr(i) = Uppercase(pathName(0));
			if pathName(0) = '*' then
				do while i < 7;
					wcFlag = TRUE;
					pnStr(i) = '*';
					i = i + 1;
				end;
			else if pathName(0) = '?' then
				wcFlag = TRUE;
			pathNamePtr = pathNamePtr + 1;
			nullName = FALSE;
		end;
		i = i + 1;
	end;
	if pathName(0) = '.' then
	do;
		pathNamePtr = pathNamePtr + 1;
		i = 7;
		do while i < 10;
			if NonTerminator then
			do;
				pnStr(i) = Uppercase(pathName(0));
				if pathName(0) = '*' then
					do while i < 10;
						wcFlag = TRUE;
						pnStr(i) = '*';
						i = i + 1;
					end;
				else if pathName(0) = '?' then
					wcFlag = TRUE;
				pathNamePtr = pathNamePtr + 1;
			end;
			i = i + 1;
		end;
	end;
	if TestRange(pnStr(0), 1) <= 9 and nullName then
		return MISSINGFNAME;	/*  missing filename */
	pl = 0FFh;
	do while ptr < pathNamePtr;
		lastPathNameParsed(pl := pl + 1) = ch;
		ptr = ptr + 1;
	end;
	if lastPathNameParsed(pl) = '.' then
		return MISSINGEXT;	/* missing extension */
	lastPathNameParsed(pl + 1) = ' ';
	if NonTerminator or pathName(0) = '.' or pathName(0) = ':' then
		return BADFILESPEC;	/* incorrectly specified file */
	return NOERROR;
end;
end;
?wrtdir.plm
WriteDirectory: do;
declare mapBase address external;

declare maskArray(1) byte external;

SetBlock: procedure(adr) external; declare adr address; end;

ClearBuf: procedure(buf$ptr) external; declare buf$ptr address; end;

Absio: procedure(cmd, disk, block, buffer) external;
         declare cmd byte, disk byte, block address, buffer address; end;

MoveAscii: procedure(dst, src, cnt) external; declare dst address, src address, cnt byte; end;

declare diskType byte external;

declare bitmap based mapBase (1) byte;

declare dirFile(9) byte data ('ISIS',0,0,'DIR'),
	mapFile(9) byte data ('ISIS',0,0,'MAP'),
	t0File(9) byte data ('ISIS',0,0,'T0',0),
	binFile(9) byte data ('ISIS',0,0,'BIN'),
	labFile(9) byte data ('ISIS',0,0,'LAB'),
	badFile(9) byte data ('ISIS',0,0,'BAD');

WriteDirectory: procedure(disk) public;
	declare	disk byte, binIdx byte, i byte, jj address, dirBuf(64) address,
		direct(8) structure(empty byte, file(9) byte, attrib byte,
				    eof$count byte, blk address, hdrBlk address) at(.dirBuf),
		countBitMapSectors byte, binHdrBlk address, countDirSectors byte;

	SetLinks: procedure(start, count, firstBlock);
		declare (start, count, firstBlock, ii) address;

		do ii = 0 to count - 1;
			dirBuf(start + ii) = firstBlock + ii;
			call setBlock(firstBlock + ii);
		end;
	end;

	FlushBlock: procedure(adr);
		declare adr address;

		call Absio(6, disk, adr, .dirBuf);
		call SetBlock(adr);
		call ClearBuf(.dirBuf);
	end;

	countDirSectors =  25;
	if diskType = 1 then
	do;
		countBitMapSectors = 4;
		binHdrBlk = 206h;
	end;
	else if diskType = 4 then
	do;
		countBitMapSectors = 29;
		binHdrBlk = 21fh;
		countDirSectors = 62;
	end;
	else
	do;
		countBitMapSectors = 2;
		binHdrBlk = 204h;
	end;

	jj = .bitmap - 128;
	if diskType = 4 then
		do i = 0 to countBitMapSectors - 1;
			call Absio(6, disk, i + 74h, (jj := jj + 128));
		end;
	/* set linkage for isis.t0 */
	call ClearBuf(.dirBuf);
	call SetLinks(2, 23, 1);
	call FlushBlock(18h);		
	/* set linkage for isis.lab */
	if diskType = 4 then		/* hard disk */
	do;
		dirBuf(1) = 58h;	/* next linkage is sector 58h */
		call SetLinks(2, 3Eh, 1Ah);	/* first part of isis.lab */ 
	end;
	else if diskType = 1 then
	do;
		call SetLinks(2, 27, 1Ah);	/* allocate 53 blocks in 2 groups */
		call SetLinks(1Dh, 26, 11Bh);
	end;
	else
		call SetLinks(2, 1, 1Ah);	/* allocate 1 block */

	call FlushBlock(19h);		/* write label linkage */
	if diskType = 4 then
	do;
		dirBuf(0) = 19h;	/* link to previous */
		call SetLinks(2, 26, 59h);
		call SetLinks(1ch, 9, 140h);
		call SetLinks(25h, 9, 188h);
		call FlushBlock(58h);	/* write label linkage */
	end;
	/* set linkage for isis.bad for hd only */
	if diskType = 4 then
	do;
		call SetLinks(2, countBitMapSectors, 74h);
		call FlushBlock(73h);
	end;

	/* set linkage for isis.dir */
	call SetLinks(2, countDirSectors, 102h);
	if diskType = 4 then
		dirBuf(1) = 149h;	/* link to next */
	call FlushBlock(101h);
	if diskType = 4 then
	do;
		dirBuf(0) = 101h;	/* link to previous */
		call SetLinks(2, countDirSectors, 14Ah);
		call FlushBlock(149h);
	end;

	/* set linkage for isis.map */
	call SetLinks(2, countBitMapSectors, 202h);
	call FlushBlock(201h);
	call FlushBlock(binHdrBlk);

	/* isis.dir */
	call MoveAscii(.direct(0).file, .dirFile, 9);
	if diskType = 4 then
		direct(0).blk = 124;	/* larger size */
	else
		direct(0).blk = 25;

	direct(0).hdrBlk = 101h;	/* linkage at t1 s1 */
	direct(0).attrib = 1;
	direct(0).eof$count = 128;

	/* isis.map */
	call MoveAscii(.direct(1).file, .mapFile, 9);
	direct(1).blk = countBitMapSectors;
	direct(1).hdrBlk = 201h;	/* linkage at t2 s1 */
	direct(1).attrib = 1;
	direct(1).eof$count = 128;

	/* isis.t0 */
	call MoveAscii(.direct(2).file, .t0File, 9);
	direct(2).blk = 17h;
	direct(2).hdrBlk = 18h;		/* linkage at t0 s24 */
	direct(2).attrib = 1;
	direct(2).eof$count = 128;

	/* isis.lab */
	call MoveAscii(.direct(3).file, .labFile, 9);
	if diskType = 1 then
		direct(3).blk = 35h;
	else if diskType = 4 then
		direct(3).blk = 6Ah;
	else
		direct(3).blk = 1;
	direct(3).hdrBlk = 19h;		/* linkage at t0 s25 */
	direct(3).attrib = 1;
	direct(3).eof$count = 128;

	/* isis.bad */
	if diskType = 4 then
	do;
		call MoveAscii(.direct(4).file, .badFile, 9);
		direct(4).blk = countBitMapSectors;
		direct(4).hdrBlk = 73h;
		direct(4).attrib = 1;
		direct(4).eof$count = 128;
		binIdx = 5;
	end;
	else
		binIdx = 4;

	/* isis.bin */
	call MoveAscii(.direct(binIdx).file, .binFile, 9);
	direct(binIdx).hdrBlk = binHdrBlk;
	direct(binIdx).attrib = 3;
	direct(binIdx).eof$count = 128;

	/* flag as no further entries */
	do i = binIdx + 1 to 7;
		direct(i).empty = 7fh;
	end;

	call FlushBlock(102h);
	do i = 0 to 7;
		direct(i).empty = 7fh;
	end;

	do i = 1 to countDirSectors - 1;
		call Absio(6, disk, 102h + i, .dirBuf);
	end;

	if diskType = 4 then
		do i = 0 to countDirSectors - 1;
			call Absio(6, disk, 14Ah + i, .dirBuf);
		end;

	jj = .bitmap - 128;
	do i = 0 to countBitMapSectors - 1;
		call Absio(6, disk, 202h + i, (jj := jj + 128));
	end;
end;
end;

?ypath.plm
ypath: do;
declare devTab(*) byte data('F0F1F2F3F4F5TITOVIVO',
		            'I1O1TRHRR1R2TPHPP1P2',
			    'LPL1BBCICOF6F7F8F9');


ypath: procedure(int$p, ext$p) public;
	declare (int$p, ext$p) address;
	declare i byte;
	declare intName based int$p (1) byte,
		extName based ext$p (1) byte;

	extName(0) = ':';
	i = intName(0);
	/* map internal device to formal device index */
	if i > 9 then
		i = i - 4;
	else if i > 5 then
		i = i + 19;

	extName(1) = devTab(i + i);
	extName(2) = devTab(i + i + 1);
	extName(3) = ':';
	ext$p = ext$p + 4;

	do i = 0 to 5;
		if (extName(0) := intName(i + 1)) <> 0 then
			ext$p = ext$p + 1;
	end;
	if intName(7) <> 0 then
	do;
		extName(0) = '.';
		ext$p = ext$p + 1;
	end;
	do i = 0 to 2;
		if (extName(0) := intName(i + 7)) <> 0 then
			ext$p = ext$p + 1;
	end;
	extName(0) = ' ';
end;
end;
?monitr.patch
p 0013 02       # see source for reason
cusp6/makefile
# common makefile info
ITOOLS ?=../../..
ifdef LIB
	TARGETDIR = ../$(LIB)/
endif
TARGETS=$(TARGETDIR)cusp6.lib
unexport ISIS_F1

include $(ITOOLS)/tools/isis.mk
PLM80 = 3.1
PLMFLAGS = code
REF = $(call ipath,toolbox,1.0)

OBJS =	alloc.obj direct.obj absio.obj clrbuf.obj chklab.obj d.obj\
	dblank.obj diskio.obj dlimit.obj dmeq.obj dtype.obj ferror.obj\
	fmttrk.obj forupp.obj getdsk.obj getlab.obj mvasci.obj\
	monitr.obx meq.obj numout.obj path.obj popula.obj reperr.obj\
	scanin.obj serror.obj seq.obj setblk.obj setmap.obj\
	tabwrt.obj trange.obj upcase.obj unpath.obj wrtdir.obj\
	wdlmt.obj wpath.obj ypath.obj cpyrit.obj

all::
	$(MAKE) $(TARGETS)

$(TARGETDIR)cusp6.lib: $(OBJS)
	$(call lib,$@,$^)

%.obx: %.obj %.patch
	$(ITOOLS)/tools/fixobj -p $*.patch $*.obj $@
cusp8/cusp8_all.src
?cpyrit.plm
COPYRIGHT: DO;
end;
?dblank.plm
DEBLANK: DO;
deblank: procedure(ptr) address public;
	declare ptr address, c based ptr byte;

	do while (c = ' ');
		ptr = ptr + 1;
	end;
	return ptr;
end;

end;
?dlimit.plm
DELIMIT: DO;
delimit: procedure(ptr) address public;
	declare ptr address, ch based ptr byte;

	do while ch = ':' or ch = '.' or
		 ('0' <= ch and ch <= '9') or
		 ('A' <= ch and ch <= 'Z');
		ptr = ptr + 1;
	end;
	return ptr;
end;
end;
?dmeq.plm
DMEQ: DO;
declare TRUE	literally '0FFH',
	FALSE	literally '0';

read: procedure (conn, buff$p, count, actual$p, status$p) external;
    declare (conn, buff$p, count, actual$p, status$p) address;
end read;

seek: procedure (conn, mode, block$p, byte$p, status$p) external;
    declare (conn, mode, block$p, byte$p, status$p) address;
end seek;

meq: procedure(A, B) byte external ; declare (A,B) address; end;

ReportError: procedure(errNum) external;
	declare errNum address;
end;

declare diskType byte external;

declare DIRMAX	literally '201';
declare HDDIRMAX literally '993';
declare HDTYPE	literally '4';
declare DIRSIZE literally '16';
declare OK	literally '0';

dmeq: procedure (dirAftn, searchArg, initialINo, dirEntry) address public;
    declare (dirAftn, searchArg, initialINo, dirEntry) address;
    declare (byteNo, blockNo) address;
    declare (actual, status) address;
    declare pastDir address;
    declare searching byte;
    declare dirFlag based dirEntry byte;

	if diskType = HDTYPE then	/* hard disk */
		pastDir = HDDIRMAX;
	else
		pastDir = DIRMAX;
	if pastDir - 1 <= initialINo then
		return pastDir;
	blockNo = 0;
	byteNo = initialINo * DIRSIZE;
	call seek(dirAftn, 2, .blockNo, .byteNo, .status);

	if status <> OK then
		call ReportError(status);
	
	searching = TRUE;
	do while searching;
		call read(dirAftn, dirEntry, DIRSIZE, .actual, .status);
		if dirFlag = 7Fh or actual = 0 then
			return pastDir;
		searching = not meq(searchArg, dirEntry);
		initialINo = initialINo + 1;
	end;

	return initialINo;
end;
end;
?ferror.plm
FILEERROR: DO;

write: procedure (conn, buff$p, count, actual$p) external;
    declare (conn, buff$p, count, actual$p) address;
end write;

exit: procedure external; end exit;

deblank: procedure(str) address external; declare str address; end;
WDelimit: procedure(ptr) address external; declare ptr address; end;
reporterror: procedure(status) external; declare status address; end;

declare OK literally '0';

fileerror: procedure(status, ptr, callExit) public;
	declare (status, ptr) address;
	declare callExit byte;
	declare actual address;

	if status <> OK then
	do;
		ptr = deblank(ptr);
		call write(0, .(' '), 1, .actual);
		call write(0, ptr, WDelimit(ptr) - ptr, .actual);
		call write(0, .(','), 1, .actual);
		call reporterror(status);
		if callExit then
			call exit;
	end;
end;
end;
?forupp.plm
FORCEUPPER: DO;
declare CR literally '0DH';

uppercase: procedure(ch) byte external; declare ch byte; end;

forceupper: procedure(bufferPtr) public;
	declare bufferPtr address, ch based bufferPtr byte;

	do while ch <> CR;
		ch = uppercase(ch);
		bufferPtr = bufferPtr + 1;
	end;
end;
end;
?meq.plm
MEQ: DO;
declare TRUE literally '0ffh';

meq: procedure(mPtr, fptr) byte public;
	declare (mPtr, fptr) address, i byte;
	declare m based mPtr (10) byte;
	declare f based fptr (10) byte;

	do i = 0 to 9;
		if m(i) = '?' then
		do;
			if f(i) = 0 then
				return 0;
		end;
		else if m(i) <> '*' then
		do;
			if m(i) <> f(i) then
				return not TRUE;
		end;
	end;
	return TRUE;
end;
end;

?numout.plm
NUMOUT: DO;


numout: procedure(value, base, lc, bufAdr, width) public;
	declare (value, bufAdr) address, (base, lc, width) byte; 
	declare i byte;
	declare buf based bufAdr (1) byte;
	declare digits(*) byte data('0123456789ABCDEF');

	do i = 1 to width;
		buf(width - i) = digits(value mod base);
		value = value / base;	
	end;

	i = 0;
	do while buf(i) = '0' and i < width - 1;
		buf(i) = lc;
		i = i + 1;
	end;
end;
end;
?popula.plm
population: do;

declare bitCnt(*) byte initial(
	0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,
	1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
	1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
	1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
	3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
	1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
	3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
	3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
	3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
	4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8);

Population: procedure(bufferLoc, length) address public;
	declare (bufferLoc, length, total) address,
	(i, t, l) byte;
	declare buffer based bufferLoc (1) byte;

	total = 0;
	do while length > 31;
		t = 0;
		do i = 0 to 30;
			t = t + bitCnt(buffer(i));
		end;
		total = total + t;
		bufferLoc = bufferLoc + 31;
		length = length - 31;
	end;
	l = length - 1;
	t = 0;
	do i = 0 to l;
		t = t + bitCnt(buffer(i));
	end;
	return total + t;
end;
end;
?reperr.plm
REPORTERROR: DO;

error: procedure(errNum) external; declare errNum address; end;

write: procedure(aftn, buf$ptr, len, status$ptr) external;
   declare (aftn, buf$ptr, len, status$ptr) address;
end write;

declare CR	literally '0dh';
declare LF	literally '0ah';

reporterror: procedure(errNum) public;
	declare errNum address;
	declare numberBuffer(3) byte;
	declare (i, status) address;
 
	declare msg(*) byte DATA(0, 0,
		2, 'ILLEGAL AFTN ARGUMENT', 0,
		4, 'INCORRECTLY SPECIFIED FILE', 0,
		5, 'UNRECOGNIZED DEVICE NAME', 0,
		6, 'ATTEMPT TO WRITE TO INPUT DEVICE', 0,
		8, 'ATTEMPT TO READ FROM OUTPUT DEVICE', 0,
		9, 'DISK DIRECTORY FULL', 0,
		0AH, 'NOT ON SAME DISK', 0,
		0BH, 'FILE ALREADY EXISTS', 0,
		0CH, 'FILE IS ALREADY OPEN', 0,
		0DH, 'NO SUCH FILE', 0,
		0EH, 'WRITE PROTECTED', 0,
		11H, 'NOT A DISK FILE', 0,
		12H, 'ILLEGAL ISIS COMMAND', 0,
		13H, 'ATTEMPTED SEEK ON NON-DISK FILE', 0,
		14H, 'ATTEMPTED BACK SEEK TOO FAR', 0,
		15H, 'CAN''T RESCAN', 0,
		16H, 'ILLEGAL ACCESS MODE TO OPEN', 0,
		17H, 'MISSING FILENAME', 0,
		19H, 'ILLEGAL ECHO FILE', 0,
		1AH, 'ILLEGAL ATTRIBUTE IDENTIFIER', 0,
		1BH, 'ILLEGAL SEEK COMMAND', 0,
		1CH, 'MISSING EXTENSION', 0,
		1FH, 'CAN''T SEEK ON WRITE ONLY FILE', 0,
		20H, 'CAN''T DELETE OPEN FILE', 0,
		23H, 'SEEK PAST EOF', 0,
		0C9H, 'UNRECOGNIZED SWITCH', 0,
		0CAH, 'UNRECOGNIZED DELIMITER', 0,
		0CBH, 'INVALID SYNTAX', 0,
		0CCH, 'PREMATURE EOF', 0,
		0CEH, 'ILLEGAL DISKETTE LABEL', 0,
		0D0H, 'CHECKSUM ERROR', 0,
		0D1H, 'RELO FILE SEQUENCE ERROR', 0,
		0D2H, 'INSUFFICIENT MEMORY', 0,
		0D3H, 'RECORD TOO LONG', 0,
		0D4H, 'ILLEGAL RELO RECORD', 0,
		0D5H, 'FIXUP BOUNDS ERROR', 0,
		0D6H, 'ILLEGAL SUBMIT PARAMETER', 0,
		0D7H, 'ARGUMENT TOO LONG', 0,
		0D8H, 'TOO MANY PARAMETERS', 0,
		0D9H, 'OBJECT RECORD TOO SHORT', 0,
		0DAH, 'ILLEGAL RECORD FORMAT', 0,
		0DBH, 'PHASE ERROR', 0,
		0EAH, 'CANNOT FORMAT FROM TARGET DRIVE', 0,
		0EBH, 'NON-DISK DEVICE', 0
		);


	if errNum <> 0 then
	do;
		i = 0;
		do while i < size(msg);
			if errNum = msg(i) and msg(i + 1) <> 0 then
			do;
				i = i + 1;
				call write(0, .(' '), 1, .status);
				do while msg(i) <> 0;
					call write(0, .msg(i), 1, .status);
					i = i + 1;
				end;
				call write(0, .(CR, LF), 2, .status);
				return;
			end;
			else
			do;
				do while msg(i) <> 0;
					i = i + 1;
				end;
				i = i + 1;
			end;
		end;
	call error(errNum);
	end;
end;
end;
?scanin.plm
scanIn: do;


ScanInteger: procedure(ptrPtr) address public;
	declare ptrPtr address;
	declare ptr based ptrPtr address;
	declare (scanPtr, updatePtr, stopPtr) address;
	declare (i, radix, increment) byte;
	declare (nVal, oVal) address;
	declare c based scanPtr byte;
	declare digits(*) byte data('0123456789ABCDEF');

	scanPtr = ptr;
	do while c = ' ';
		scanPtr = scanPtr + 1;
	end;
	ptr = scanPtr;
	do while '0' <= c and c <= '9' or 'A' <= c and c <= 'F';
		scanPtr = scanPtr + 1;
	end;

	updatePtr = (stopPtr := scanPtr) + 1;
	if c = 'H' then
		radix = 16;
	else if c = 'O' or c = 'Q' then
		radix = 8;
	else
	do;
		stopPtr, scanPtr = (updatePtr := scanPtr) - 1;
		if c = 'B' then
			radix = 2;
		else
		do;
			radix = 10;
			if c <> 'D' then	/* include last increment */
				stopPtr = stopPtr + 1;
		end;
	end;
	scanPtr = ptr;
	nVal, oVal = 0;
	do while scanPtr < stopPtr;
		do i = 0 to 15;
			if c = digits(i) then
				increment = i;
		end;
		if increment >= radix then
			return 0;
		nVal = oVal * radix + increment;
		if nVal < oVal then
			return 0;
		oVal = nVal;
		scanPtr = scanPtr + 1;
	end;
	ptr = updatePtr;
	return nVal;
end;
end;
?seq.asm
	name SEQ
	public SEQ
	cseg
; seq: procedure(s, t, cnt) byte public; declare (s, t, cnt) address; end;
TRUE	equ	0ffh
FALSE	equ	0

SEQ:	pop	h	; get s
	xthl
	xra	a
	sub	e
	mov	e,a	; cnt = -cnt
	mvi	a,0
	sbb	d
	mov	d,a
	ora	e
	mvi	a,TRUE	; true if zero length
	rz

seq1:	ldax	b	; compare chars
	cmp	m
	jz	seq2
	xra	a	; false if they don't match
	ret

seq2:	inx	b	; next char
	inx	h
	inr	e
	jnz	seq1	; more to do
	inr	d
	jnz	seq1
	mvi	a,TRUE	; have match
	ret
	end
?tabwrt.plm
TABWRITE: DO;

declare TAB	literally '9',
	CR	literally '0dh';

write: procedure (aft, buff$p, count, status) external;
    declare (aft, buff$p, count, status) address;
end write;

tabwrite: procedure(columnPtr, aft, bufferPtr, count, status) public;
	declare (columnPtr, aft, bufferPtr, count, status) address;
	declare (printChar, i, j) byte;
	declare column based columnPtr byte;
	declare ch based bufferPtr byte;

	do while count <> 0;
		i = ch = TAB and (7 - (column and 7));
		printChar = ch;
		bufferPtr = bufferPtr + 1;
		count = count - 1;
		if printChar = TAB then
			printChar = ' ';
		do j = 0 to i;
			if ch = CR then
				column = 0;
			if ch >= ' ' then
				column = column + 1;
			call write(aft, .printChar, 1, status);
		end;
	end;
end;
end;

?unpath.plm
UNPATH: DO;


unpath:	procedure(int, ext) public;
	declare (int, ext) address, i byte;
	declare intName based int (1) byte;
	declare extName based ext (1) byte;
	declare devTab(*) byte data('F0F1F2F3F4F5TITO',
				    'VIVOI1O1TRHRR1R2',
				    'TPHPP1P2LPL1BBCICO',
				    'F6F7F8F9SP');

	extName(0) = ':';
	extName(1) = devTab(intName(0) + intName(0));
	extName(2) = devTab(intName(0) + intName(0) + 1);
	extName(3) = ':';	
	ext = ext + 4;
	do i = 0 to 5;
		if (extName(0) := intName(i + 1)) <> 0 then
			ext = ext + 1; 
	end;
	if intName(7) <> 0 then
	do;
		extName(0) = '.';
		ext = ext + 1;
	end;
	do i = 0 to 2;
		if (extName(0) := intName(i + 7)) <> 0 then
			ext = ext + 1; 

	end;
	extName(0) = ' ';
end;
end;
?upcase.plm
UPPERCASE: DO;
declare UCMASK literally '0dfh';

uppercase: procedure(char) byte public;
	declare char byte;
	if char < 'a' then
		return char;
	if char > 'z' then
		return char;
	return char and UCMASK;
end;
end;
?wdlmt.plm
WDELIMIT: DO;
/* b1=01, b2=31, CODE(63H) byte, DATA(2H) byte, STACK(4H) byte, MEMORY(0H) byte,*/
wdelimit: procedure(ptr) address public;
	declare ptr address, ch based ptr byte;

	do while (ch = ':' or ch = '.' or ch = '*' or ch = '?' or
		  ('0' <= ch and ch <= '9') or ('A' <= ch and ch <= 'Z'));
		ptr = ptr + 1;
	end;
	return ptr;
end;
end;

?wpath.plm
WPATH: DO;
uppercase: procedure(char) byte external;
	declare char byte;
end;

TestRange: procedure(device, buffer$p) byte external;
	declare device byte, buffer$p address;
end;

declare FALSE literally '0';
declare TRUE literally '0FFh';


declare lastPathNameParsed(15) byte;

/* the error return codes */
declare BADFILESPEC	literally '4';
declare UNKNOWNDEV	literally '5';
declare MISSINGFNAME	literally '17h';
declare MISSINGEXT	literally '1ch';
declare NOERROR		literally '0';

declare devTab(*) byte data('F0F1F2F3F4F5TITOVIVOI1O1',
			    'TRHRR1R2TPHPP1P2LPL1BBCICOF6F7F8F9');

WPath: procedure(pathNamePtr, pn, wc) byte public;
	declare (pathNamePtr, pn, wc) address;
	declare ptr address;
	declare	addr address, (hi, lo) byte at (.addr);
	declare	devPtr address, (nullName, pl, i) byte;
	declare pathName based pathNamePtr (1) byte;
	declare pnStr based pn (1) byte;
	declare wcFlag based wc byte;
	declare dev based devPtr address;
	declare ch based ptr byte;
	
	NonTerminator: procedure byte;
		return ('A' <= pathName(0) and pathName(0) <= 'Z') or
		       ('0' <= pathName(0) and pathName(0) <= '9') or
		       pathName(0) = '?' or pathName(0) = '*' or
		       ('a' <= pathName(0) and pathName(0) <= 'z');
	end;
	wcFlag = FALSE;
	devPtr = .devTab;
	do i = 0 to 9;
		pnStr(i) = 0;
	end;
	do while pathName(0) = ' ';
		pathNamePtr = pathNamePtr + 1;
	end;

	ptr = pathNamePtr;
	if pathName(0) = ':' then
	do;
		if pathName(3) <> ':' then
			return BADFILESPEC;	/* incorrectly specified file */
		pathNamePtr = pathNamePtr + 1;
		hi = Uppercase(pathName(0));
		pathNamePtr = pathNamePtr + 1;
		lo = Uppercase(pathName(0));
		pathNamePtr = pathNamePtr + 2;
		pnStr(0) = 0FFh;
		i = 0;
		do while i < 57;
			if dev = addr then
				pnStr(0) = shr(i, 1);
			i = i + 2;
			devPtr = devPtr + 2;
		end;
		if pnStr(0) = 0FFh then
			return UNKNOWNDEV;	/* unrecognized device pathName */
	end;
	nullName = TRUE;
	i = 1;
	do while i < 7;
		if NonTerminator then
		do;
			pnStr(i) = Uppercase(pathName(0));
			if pathName(0) = '*' then
				do while i < 7;
					wcFlag = TRUE;
					pnStr(i) = '*';
					i = i + 1;
				end;
			else if pathName(0) = '?' then
				wcFlag = TRUE;
			pathNamePtr = pathNamePtr + 1;
			nullName = FALSE;
		end;
		i = i + 1;
	end;
	if pathName(0) = '.' then
	do;
		pathNamePtr = pathNamePtr + 1;
		i = 7;
		do while i < 10;
			if NonTerminator then
			do;
				pnStr(i) = Uppercase(pathName(0));
				if pathName(0) = '*' then
					do while i < 10;
						wcFlag = TRUE;
						pnStr(i) = '*';
						i = i + 1;
					end;
				else if pathName(0) = '?' then
					wcFlag = TRUE;
				pathNamePtr = pathNamePtr + 1;
			end;
			i = i + 1;
		end;
	end;
	if TestRange(pnStr(0), 1) <= 9 and nullName then
		return MISSINGFNAME;	/*  missing filename */
	pl = 0FFh;
	do while ptr < pathNamePtr;
		lastPathNameParsed(pl := pl + 1) = ch;
		ptr = ptr + 1;
	end;
	if lastPathNameParsed(pl) = '.' then
		return MISSINGEXT;	/* missing extension */
	lastPathNameParsed(pl + 1) = ' ';
	if NonTerminator or pathName(0) = '.' or pathName(0) = ':' then
		return BADFILESPEC;	/* incorrectly specified file */
	return NOERROR;
end;
end;
cusp8/makefile
ITOOLS ?=../../..
ifdef LIB
	TARGETDIR = ../$(LIB)/
endif
TARGETS=$(TARGETDIR)cusp8.lib
unexport ISIS_F1

include $(ITOOLS)/tools/isis.mk

REF = $(call ipath,toolbox,2.0)
PLMFLAGS = CODE DEBUG
PLM80 = 3.1

OBJS = dblank.obj dlimit.obj dmeq.obj ferror.obj forupp.obj meq.obj numout.obj\
       popula.obj reperr.obj scanin.obj tabwrt.obj upcase.obj wdlmt.obj\
       wpath.obj seq.obj unpath.obj cpyrit.obj

all::
	$(MAKE) $(TARGETS)

$(TARGETDIR)cusp8.lib: $(OBJS)
	$(call lib,$@,$^)

unpath.obj: PLM80=4.0
unpath.obj: PLMFLAGS = CODE
fnames/fnames_all.src
?cons5.plm
CONS5: DO;
/* b1=01, b2=31, CODE(2FH) byte, DATA(4AH) byte, STACK(2H) byte, MEMORY(0H) byte,*/
SETOB: procedure(ZZ1) external; declare (ZZ1) address; end;
OUTFILENAME: procedure(ZZ1) external; declare (ZZ1) address; end;
OUTCHAR: procedure(ZZ1) external; declare (ZZ1) byte; end;
OUTBLANK: PROCEDURE external; end;
OUTPRINT: procedure(ZZ1) external; declare (ZZ1) address; end;
ERRORMESSAGE: procedure(ZZ1) external; declare (ZZ1) address; end;

DECLARE BUF(*) BYTE INITIAL('FILE ERROR, '),
	NAMEBUF(58) BYTE;

FILEERRORMESSAGE: PROCEDURE(MSG, FNAME) public;
	DECLARE (MSG, FNAME) ADDRESS;

	call SETOB(.NAMEBUF);
	call OUTFILENAME(FNAME);
	call OUTCHAR('-');
	call OUTBLANK;
	call OUTPRINT(MSG);
	call ERRORMESSAGE(.BUF);
end;
end;
?driven.plm
DRIVEN: DO;
/* b1=01, b2=31, CODE(28H) byte, DATA(0H) byte, STACK(2H) byte, MEMORY(0H) byte,*/

setsc: procedure(a) external; declare a address; end;
declare scanp address external;
forcup: procedure byte external; end;
bumpscanp: procedure external; end;

drivenumber: procedure byte public;
	call setsc(scanp);
	if forcup <> ':' then
		return '0';
	call bumpscanp;
	if forcup <> 'F' then
		return 0C8H;
	call bumpscanp;
	return forcup;
end;
end;

?exroot.plm
EXROOT: DO;
/* b1=01, b2=31, CODE(3BH) byte, DATA(2H) byte, STACK(2H) byte, MEMORY(0H) byte,*/

SETSC: PROCEDURE(W) external;
	DECLARE W ADDRESS;
END;
SETOB: PROCEDURE(W) external;
	DECLARE W ADDRESS;
END;

DECLARE SCANP ADDRESS external;

FORCUP: PROCEDURE BYTE external;
END;

LTNMCH: PROCEDURE BYTE external;
END;
OUTSCANBYTE: PROCEDURE external;
END;
OUTCHAR: PROCEDURE(CH) external;
	DECLARE CH byte;
end;

EXTRACTROOT: PROCEDURE(W) public;
	DECLARE W ADDRESS;

	CALL SETSC(SCANP);
	CALL SETOB(W);
	if FORCUP = ':' then
		SCANP = SCANP + 4;
	do while LTNMCH;
		call OUTSCANBYTE;
	end;
	call OUTCHAR(0);
end;
end;

?input1.plm
INPUT1: DO;
/* b1=01, b2=31, CODE(3BH) byte, DATA(4H) byte, STACK(2H) byte, MEMORY(0H) byte,*/
FILEERRORMESSAGE: procedure(MSG,FILE) external; declare (MSG,FILE) address; end;
READI: procedure(ZZ1,ZZ2) external; declare (ZZ1,ZZ2) address; end;
declare ACTUAL address external;
declare FNAMEI address external;

READIWITHLIMIT: PROCEDURE(AFTN, CNT) public;
	declare (AFTN, CNT) address;

	call READI(AFTN, CNT);
	if ACTUAL = CNT then
	    call FILEERRORMESSAGE(.('FILE TOO BIG', 0), FNAMEI);
end;
end;

?newext.plm
NEWEXT: DO;
SETSC: procedure(ZZ1) external; declare (ZZ1) address; end;
SETOB: procedure(ZZ1) external; declare (ZZ1) address; end;
declare SCANP address external;
FILECH: procedure byte external; end;
FORCUP: procedure byte external; end;
OUTSCANBYTE: procedure external; end;
OUTCHAR: procedure(ZZ1) external; declare (ZZ1) byte; end;
OUTPRINT: procedure(ZZ1) external; declare (ZZ1) address; end;

NEWEXTENSION: procedure(FILENAME,EXT) public;
	declare (FILENAME,EXT) address;
	call SETSC(SCANP);
	call SETOB(FILENAME);
	do while FILECH and FORCUP <> '.';
		call OUTSCANBYTE;
	end;
	call OUTCHAR('.');
	call OUTPRINT(EXT);
	call OUTCHAR(0);
end;
end;

?out5.plm
OUT5: DO;

SCANWHILEBLANKS: procedure external; end;
FILECH: procedure byte external; end;
OUTCHAR: procedure(ZZ1) external; declare (ZZ1) byte; end;
SETSC: procedure(ZZ1) external; declare (ZZ1) address; end;
declare SCANP address external;


OUTFILENAME: procedure(FILENAME) public;
	declare (FILENAME) address;
	declare CH based SCANP byte;

	call SETSC(FILENAME);
	call SCANWHILEBLANKS;
	do while FILECH;
		call OUTCHAR(CH);
		SCANP = SCANP + 1;
	end;
end;
end;

?scan4.plm
SCAN4: DO;
/* b1=01, b2=31, CODE(90H) byte, DATA(6H) byte, STACK(4H) byte, MEMORY(0H) byte,*/
SCANWHILEBLANKS: procedure external; end;
SCANWHILE: procedure(PATH) external; declare (PATH) address; end;
FILECH: procedure byte external; end;
FORCUP: procedure byte external; end;
BUMPSCANP: procedure external; end;
ERRORMESSAGE: procedure(PATH) external; declare (PATH) address; end;
SCANEXPECT: procedure(PATH) external; declare (PATH) address; end;

declare FILENAMELIMIT byte public initial(15);


MOVEFILENAME: procedure(PATH) public;
	declare (PATH) address;
	declare CH based PATH byte;
	declare CHLEFT byte;
	
	CHLEFT = FILENAMELIMIT + 1;
	call SCANWHILEBLANKS;
	do while FILECH and (CHLEFT := CHLEFT - 1) > 0;
		CH = FORCUP;
		call BUMPSCANP;
		PATH = PATH + 1;
	end;
	if CHLEFT = 0 then
	do;
		call ERRORMESSAGE(.('FILE NAME TOO LONG', 0));
		call SCANWHILE(.FILECH);
	end;
	call SCANWHILEBLANKS;
	CH = 0;
end;

MOVEPARENSFILENAME: procedure(PATH) public;
	declare PATH address;

	call SCANWHILEBLANKS;
	call SCANEXPECT(.('(',0));
	call MOVEFILENAME(PATH);
	call SCANEXPECT(.(')',0));
	call SCANWHILEBLANKS;
end;
end;
?scan8.plm
SCAN8: DO;
/* b1=01, b2=31, CODE(4EH) byte, DATA(2H) byte, STACK(2H) byte, MEMORY(0H) byte,*/
FILECH: procedure byte external; end;
SCANUNTIL: procedure(ZZ1) external; declare (ZZ1) address; end;
declare SCANP address external;
declare SCANENDED byte external;
ERRORMESSAGE: procedure(STR) external; declare STR address; end;
SCANWHILE: procedure(FUNC) external; declare FUNC address; end;

OPENSCAN: procedure(FUNC) public;
	declare FUNC ADDRESS;

	call SCANUNTIL(.FILECH);
	if SCANENDED THEN
	    call ERRORMESSAGE(.('SCAN ERROR: FILE NAME EXPECTED', 0));
	call FUNC(SCANP, 3);
	call SCANWHILE(.FILECH);
end OPENSCAN;

end;
?ver10.plm
VERSIONNUMBER1P0: DO;
end;

fnames/makefile
# common makefile info
ITOOLS ?=../../..
ifdef LIB
	TARGETDIR = ../$(LIB)/
endif
TARGETS=$(TARGETDIR)fnames.lib
unexport ISIS_F1

include $(ITOOLS)/tools/isis.mk

REF = $(call ipath,toolbox,2.0)

PLM80 = 3.1

OBJS = ver10.obj driven.obj exroot.obj cons5.obj scan4.obj newext.obj scan8.obj out5.obj input1.obj

all::
	$(MAKE) $(TARGETS)

$(TARGETDIR)fnames.lib: $(OBJS)
	$(call lib,$@,$^)
src/bltsym.asm
        NAME BLTSYM

;     'Copyright 1981,1983 Intel Corporation'.  All rights reserved.
;      No part of this program or publication may be reproduced,
;      transmitted, transcribed, stored in a retrievel system, or
;      translated into any language or computer language, in any
;      form or by any means, electronic, mechanical, magnetic,
;      optical, chemical, manual or otherwise, without the prior
;      written permission of Intel Corporation, 3065 Bowers
;      Avenue, Santa Clara, California, 95051, Attn: Software
;      License Administration.

; BLTSYM: A "BC IS LESS THAN DE" ROUTINE WHICH WORKS
;  ON INTERNAL RECORDS PRODUCED BY THE MERGE PROGRAM.

        CSEG
        PUBLIC BLTSYM

BLTSYM:
        MOV H,B
        MOV L,C
        MOV C,M
        INX H
        MOV B,M
        XCHG
        MOV E,M
        INX H
        MOV D,M
        XCHG
        INX B
        INX B
        INX H
        INX H
CRUISE:
        LDAX B
        CMP M
        JC TRUE
        JNZ FALSE
        CPI 0
        INX H
        INX B
        JNZ CRUISE
        MOV A,C
        SUB L
        MOV A,B
        SBB H
        SBB A
        RET
TRUE:
        MVI A,0FFH
        RET
FALSE:
        SUB A
        RET

        END
src/bsym86.asm
        NAME BLTSYM

;     'Copyright 1981,1983 Intel Corporation'.  All rights reserved.
;      No part of this program or publication may be reproduced,
;      transmitted, transcribed, stored in a retrievel system, or
;      translated into any language or computer language, in any
;      form or by any means, electronic, mechanical, magnetic,
;      optical, chemical, manual or otherwise, without the prior
;      written permission of Intel Corporation, 3065 Bowers
;      Avenue, Santa Clara, California, 95051, Attn: Software
;      License Administration.

; BLTSYM: A "BC IS LESS THAN DE" ROUTINE WHICH WORKS
;  ON INTERNAL RECORDS PRODUCED BY THE mrg86 PROGRAM.

        CSEG
        PUBLIC BLTSYM

BLTSYM:
        MOV H,B
        MOV L,C
        MOV C,M
        INX H
        MOV B,M
        XCHG
        MOV E,M
        INX H
        MOV D,M
        XCHG
        INX B
        INX B
        INX B
        INX B
        INX H
        INX H
        INX H
        INX H
CRUISE:
        LDAX B
        CMP M
        JC TRUE
        JNZ FALSE
        CPI 0
        INX H
        INX B
        JNZ CRUISE
        MOV A,C
        SUB L
        MOV A,B
        SBB H
        SBB A
        RET
TRUE:
        MVI A,0FFH
        RET
FALSE:
        SUB A
        RET

        END
src/cdirec.plm
$TITLE('==>  C D I R E C  <==  CHKLOD')

CDIREC: DO;

/************************************************************************/
/*																		*/
/*     'Copyright 1981,1983 Intel Corporation'.  All rights reserved.	*/
/*      No part of this program or publication may be reproduced,		*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/


/*******  EXTERNALS  *******/

/*  SYS.LIB  */

DECLARE actual ADDRESS EXTERNAL;
DECLARE status ADDRESS EXTERNAL;
closei: PROCEDURE EXTERNAL; END;
ex: PROCEDURE EXTERNAL; END;
memck: PROCEDURE ADDRESS EXTERNAL; END;
openi: PROCEDURE (file$name$ptr) EXTERNAL; DECLARE file$name$ptr ADDRESS; END;
readi: PROCEDURE (dst,count) EXTERNAL; DECLARE (dst,count) ADDRESS; END;
writec: PROCEDURE (src,count) EXTERNAL; DECLARE (src,count) ADDRESS; END;
writeo: PROCEDURE (src,count) EXTERNAL; DECLARE (src,count) ADDRESS; END;

/* UTIL.LIB  */

DECLARE obuf$p ADDRESS EXTERNAL;
DECLARE scan$p ADDRESS EXTERNAL;
ddigch: PROCEDURE BYTE EXTERNAL; END;
out$char: PROCEDURE (char) EXTERNAL; DECLARE char BYTE; END;
out$crlf: PROCEDURE EXTERNAL; END;
out$print: PROCEDURE (ptr) EXTERNAL; DECLARE ptr ADDRESS; END;
scan$match: PROCEDURE (ptr) BYTE EXTERNAL; DECLARE ptr ADDRESS; END;
scan$while: PROCEDURE (proc$addr) EXTERNAL; DECLARE proc$addr ADDRESS; END;

/* SYSTEM.LIB */

load: PROCEDURE(file,bias,switch,entry,status) EXTERNAL;
  DECLARE (file,bias,switch,entry,status) ADDRESS; END;
getd: PROCEDURE (dir$id,conn$p,count,actual$p,table$p,status$p) EXTERNAL;
  DECLARE (dir$id,conn$p,count,actual$p,table$p,status$p) ADDRESS; END;

/* CHKLOD.P80 */

DECLARE marked$file$names$ptrs (512) ADDRESS EXTERNAL;

/* CINVOK.P80 */

DECLARE listing$not$to$co BYTE EXTERNAL;
DECLARE spath$file$info (12) BYTE EXTERNAL;
file$error$msg: PROCEDURE (file$name$ptr, msg$ptr) EXTERNAL;
  DECLARE (file$name$ptr, msg$ptr) ADDRESS; END;
spath$check: PROCEDURE (msg$ptr) EXTERNAL; DECLARE msg$ptr ADDRESS; END;

/* CGREAT.P80 */

DECLARE has$greatest$numeric$ext (512) BYTE EXTERNAL;
DECLARE last$index ADDRESS EXTERNAL;
numeric$extension: PROCEDURE ADDRESS EXTERNAL; END;

/* CMOVEM.P80 */

movem: PROCEDURE (count,src,dst) EXTERNAL;
  DECLARE (count,src,dst) ADDRESS; END;

/*******  END OF EXTERNALS  *******/

DECLARE true  LITERALLY '0FFH',
        false LITERALLY '0',
        null  LITERALLY '0',
        blank LITERALLY '20H',
        CR    LITERALLY '0DH',
        LF    LITERALLY '0AH';

DECLARE isis$dir$string (*) BYTE INITIAL (':F?:ISIS.DIR',0),
        ov0$name (*)        BYTE INITIAL(':F0:ISIS.OV0 ',0),
        wasted              ADDRESS,
        getd$conn           ADDRESS,
        reading$remote      BYTE,
        last$dir$byte       ADDRESS,
        dir$ptr             ADDRESS,
        dir$byte BASED dir$ptr BYTE,
        name$ptr            ADDRESS,
        name$byte BASED name$ptr BYTE,
        new$name$ptr        ADDRESS,
        new$name$byte BASED new$name$ptr BYTE,
        greatest$dir$ext    ADDRESS,
        load$name$ptr       ADDRESS,
        i                   ADDRESS,
        scan$byte BASED scan$p BYTE;



read$in$directory: PROCEDURE (drive$no);
  DECLARE drive$no BYTE;

  isis$dir$string(2) = drive$no;  /* drive$no is ASCII digit */
  scan$p = .isis$dir$string;  /* scan$p points to file name for spath$check */
  CALL spath$check (.('IS A BAD DIRECTORY NAME',0));
  IF spath$file$info(10) = 3 THEN  /* random access device */
   DO;
    IF spath$file$info(11) > 4 THEN  /* must use GETD */
      DO;
        CALL LOAD(.ov0$name,0,0,.wasted,.status);
        IF status <> 0 THEN
          CALL file$error$msg(.ov0$name,.('LOAD ',0));
        /* getd requires binary drive number */
        wasted = (memck-.memory)/16;
        getd$conn = 0;
        CALL GETD(drive$no-'0', .getd$conn, wasted, .actual, .memory, .status);
        IF status <> 0 THEN
          CALL file$error$msg (.isis$dir$string, .('GETD ',0));
        IF actual = wasted THEN
          CALL file$error$msg (.isis$dir$string,
                      .('TOO MANY DIRECTORY FILES TO PROCESS',0));
        reading$remote = true;
        last$dir$byte = .memory + (actual * 16);  /* actual is # of entries */
      END;
    ELSE   /* regular ISIS.DIR */
      DO;
        CALL openi (.isis$dir$string);
        CALL readi (.memory, 7000H);
        reading$remote = false;
        last$dir$byte = .memory + actual;
        CALL closei;
      END;
    dir$ptr = (new$name$ptr := .memory) - 16; /* set up for reading and
                                                 writing back names  */
   END;
  ELSE
    CALL file$error$msg (.isis$dir$string, .('NOT RANDOM ACCESS??',0));
END read$in$directory;



reformat$dir$names: PROCEDURE;

  /* reformat$dir$names finds all names with numeric extensions
     and recopies them in same form as load module names      */

  check$blank$and$move$char: PROCEDURE;
    IF name$byte = null THEN  /* change it to blank */
      new$name$byte = blank;
    ELSE new$name$byte = name$byte;
    name$ptr = name$ptr + 1;
    new$name$ptr = new$name$ptr + 1;
  END;

next$one:
  IF (dir$ptr := dir$ptr + 16) >= last$dir$byte THEN  /* read it all */
    RETURN;
  IF NOT reading$remote THEN  /* check presence byte */
    DO;
      IF dir$byte <> 0 THEN  /* either end of entries or inactive */
        DO;
          IF dir$byte = 7FH THEN
            RETURN;
          GO TO next$one;  /* must have been inactive */
        END;
    END;
  /* now pointing at next active entry
     check for numeric extension  */
  scan$p = dir$ptr + 10; /* point past extension */
  scan$byte = 0; /* kill char for numeric$extension */
  scan$p = dir$ptr + 7;  /* points at extension */
  IF numeric$extension = 0FFFFH THEN  /* not numeric */
    GO TO next$one;
  /* have a numeric extension, save the name
     reformat name to XXXXXX0XXX0, change zeroes to blanks  */
  name$ptr = dir$ptr + 1;  /* past presence byte */
  DO i = 1 TO 6;
    CALL check$blank$and$move$char;
  END;
  new$name$byte = null;  /* null after file name part */
  new$name$ptr = new$name$ptr + 1;
  DO i = 1 TO 3;
    CALL check$blank$and$move$char;  /* we know ext chars are not nulls, but */
  END;                               /* use check$blank$and$move$char anyway */
  new$name$byte = null;
  new$name$ptr = new$name$ptr + 6;  /* to next slot */
  GO TO next$one;
END reformat$dir$names;



find$dir$name: PROCEDURE ADDRESS;
  DECLARE current$name$ptr ADDRESS,
          return$name$ptr  ADDRESS,
          ext$val          ADDRESS;

  return$name$ptr = 0;
  current$name$ptr = .memory;  /* beginning of reformatted names */
  greatest$dir$ext = 0;
  DO WHILE current$name$ptr < new$name$ptr;
    scan$p = current$name$ptr;
    IF scan$match (load$name$ptr) THEN
      DO;
        scan$p = current$name$ptr + 7;  /* point at extension */
        /* we know all extensions are numeric,
           no need to check for 0FFFFH case  */
        IF (ext$val := numeric$extension) >= greatest$dir$ext THEN
          DO;
            greatest$dir$ext = ext$val;
            return$name$ptr = current$name$ptr;
          END;
      END;
    current$name$ptr = current$name$ptr + 16; /* to next name */
  END; /* while */
  RETURN return$name$ptr;
END find$dir$name;




process$a$directory: PROCEDURE (drive$no) PUBLIC;
  DECLARE drive$no       BYTE;
  DECLARE top$of$ram     ADDRESS;
  DECLARE out$buffer$ptr ADDRESS;
  DECLARE dir$name$ptr   ADDRESS;
  DECLARE no$discrepancies$found BYTE;

  flush$dir$info: PROCEDURE;
    CALL writec (out$buffer$ptr, obuf$p - out$buffer$ptr);
    IF listing$not$to$co THEN
      CALL writeo (out$buffer$ptr, obuf$p - out$buffer$ptr);
  END flush$dir$info;

  write$name$and$extension: PROCEDURE (source$mod);
    DECLARE source$mod BYTE;

    no$discrepancies$found = false;
    CALL out$print (.(CR,LF,'SOURCENAME:                  ',0));
    CALL out$print (load$name$ptr);
    CALL out$crlf;
    CALL out$print (.('LOAD MODULE VERSION LEVEL:      ',0));
    CALL out$print (load$name$ptr + 7);
    CALL out$crlf;
    CALL out$print (.('SOURCE MODULE VERSION LEVEL:    ',0));
    IF source$mod THEN
      CALL out$print (dir$name$ptr + 7);
    ELSE CALL out$print (.('NONE',0));
    CALL out$crlf;
    IF obuf$p > top$of$ram THEN
      DO;
        CALL out$print (.('*** RAN OUT OF MEMORY ***',CR,LF,0));
        CALL flush$dir$info;
        CALL ex;
      END;
  END write$name$and$extension;

  CALL read$in$directory (drive$no);
  CALL reformat$dir$names;

  obuf$p,
  out$buffer$ptr = new$name$ptr;  /* points after last rewritten entry */
  top$of$ram = memck - 100H;
  no$discrepancies$found = true;
  CALL out$print (.(CR,LF,'VERSION DISCREPANCIES FOUND - DRIVE ',0));
  CALL out$char (drive$no);
  CALL out$crlf;
  DO i = 0 TO last$index;
    IF has$greatest$numeric$ext (i) THEN  /* find same names in directory */
      DO;
        load$name$ptr = marked$file$names$ptrs (i);
        IF (dir$name$ptr := find$dir$name) = 0 THEN  /* didn't find one */
          CALL write$name$and$extension (false);
        ELSE  /* found one */
          DO;
            scan$p = load$name$ptr + 7;
            IF numeric$extension <> greatest$dir$ext THEN
              CALL write$name$and$extension (true);
          END;
      END;
  END;
  IF no$discrepancies$found THEN
    CALL out$print (.(CR,LF,'NO DISCREPANCIES FOUND',CR,LF,0));
  CALL flush$dir$info;
END process$a$directory;

END;
src/cgreat.plm
$TITLE('==>  C G R E A T  <==  CHKLOD')

CGREAT: DO;

/************************************************************************/
/*																		*/
/*     'Copyright 1981,1983 Intel Corporation'.  All rights reserved.	*/
/*      No part of this program or publication may be reproduced,		*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/


/*******  EXTERNALS  *******/

/*  UTIL.LIB  */

DECLARE obuf$p ADDRESS EXTERNAL;
DECLARE scan$p ADDRESS EXTERNAL;
ddigch: PROCEDURE BYTE EXTERNAL; END;
decin: PROCEDURE ADDRESS EXTERNAL; END;
forcup$string: PROCEDURE EXTERNAL; END;
out$chars: PROCEDURE (count,char) EXTERNAL; DECLARE (count,char) BYTE; END;
out$crlf: PROCEDURE EXTERNAL; END;
out$print: PROCEDURE (ptr) EXTERNAL; DECLARE ptr ADDRESS; END;
scan$match: PROCEDURE (ptr) BYTE EXTERNAL; DECLARE ptr ADDRESS; END;
scan$while: PROCEDURE (proc$addr) EXTERNAL; DECLARE proc$addr ADDRESS; END;

/*   SYS.LIB  */

writec: PROCEDURE (src,count) EXTERNAL; DECLARE (src,count) ADDRESS; END;
writeo: PROCEDURE (src,count) EXTERNAL; DECLARE (src,count) ADDRESS; END;

/* CSORT2.A80 */

sort: PROCEDURE (ptr,count,proc$addr) EXTERNAL;
  DECLARE (ptr,count,proc$addr) ADDRESS;
END;

/* CHKLOD.P80 */

DECLARE marked$file$names$ptrs (512) ADDRESS EXTERNAL;
DECLARE mfn$counter ADDRESS EXTERNAL;

/* CINVOK.P80 */

DECLARE listing BYTE EXTERNAL;
DECLARE sorting BYTE EXTERNAL;
DECLARE listing$not$to$co BYTE EXTERNAL;

/* CMOVEM.P80 */

movem: PROCEDURE (c,s,d) EXTERNAL; DECLARE (c,s,d) ADDRESS; END;

/*******  END OF EXTERNALS  *******/


/*******  PUBLICS  *******/

DECLARE has$greatest$numeric$ext (512) BYTE PUBLIC;
DECLARE last$index ADDRESS PUBLIC;

/*******  END OF PUBLICS  *******/


DECLARE true  LITERALLY '0FFH',
        false LITERALLY '0',
        null  LITERALLY '0',
        CR    LITERALLY '0DH',
        LF    LITERALLY '0AH';

DECLARE name1 (15) BYTE,
        name2 (15) BYTE;

DECLARE duplicate$flags (512) ADDRESS;
DECLARE top  ADDRESS,
        next ADDRESS;

DECLARE we$have$a$duplicate BYTE INITIAL (false);
DECLARE warning$string  (*) BYTE INITIAL (CR,LF,
        'WARNING: respecification of source version information encountered',
         CR,LF,0);


greater$than: PROCEDURE (sptr1,sptr2) BYTE;
  DECLARE (sptr1,sptr2) ADDRESS;
  DECLARE ptr1 BASED sptr1 ADDRESS,
          ptr2 BASED sptr2 ADDRESS;
  DECLARE (nptr1,nptr2) ADDRESS;
  DECLARE i BYTE;

  /* the sptr's (from sort) point to the
     file name ptrs, which point to the file names
  */
  nptr1 = (nptr1 := ptr1) + 4;  /* ignore leading :f?: field */
  nptr2 = (nptr2 := ptr2) + 4;
  CALL movem (11, nptr1, (scan$p := .name1));
  CALL forcup$string;     /* uppercase name for comparison */
  CALL movem (11, nptr2, (scan$p := .name2));
  CALL forcup$string;
  i = 0;
  DO WHILE name1(i) = name2(i);
    IF (i := i + 1) > 9 THEN
      RETURN true;
  END;
  RETURN (name1(i) > name2(i));
END greater$than;


sort$names$for$listing: PROCEDURE PUBLIC;

  CALL sort (.marked$file$names$ptrs, mfn$counter, .greater$than);
END sort$names$for$listing;



check$duplicate$file$names: PROCEDURE PUBLIC;
  DECLARE first BYTE;

  IF mfn$counter < 2 THEN  /* only one file name */
    RETURN;
  last$index = mfn$counter - 1;
  DO next = 0 TO last$index;  /* initialize array */
    duplicate$flags (next) = next;  /* each one duplicate of itself */
  END;

  DO top = 0 TO last$index - 1;
    CALL movem (15, marked$file$names$ptrs(top), (scan$p := .name1));
    CALL forcup$string;
    name1(10) = 0;    /* set dot to null */
    DO next = top + 1 TO last$index;
      IF duplicate$flags (next) = next THEN /* not same as anything else yet */
        DO;
          CALL movem (15, marked$file$names$ptrs(next), (scan$p := .name2));
          CALL forcup$string;
          name2(10) = 0;
          scan$p = .name2(4);  /* skip device part */
          IF scan$match (.name1(4)) THEN
            DO;
              duplicate$flags (next) = top;
              duplicate$flags (top) = 0FFFFH;
              we$have$a$duplicate = true;
            END;
        END;
    END;
  END;

  IF we$have$a$duplicate THEN
    DO;
      obuf$p = .memory;
      CALL out$print (.warning$string);
      DO top = 0 TO last$index - 1;
        IF duplicate$flags (top) = 0FFFFH THEN  /* this one same as others */
          DO;
            CALL out$print (.(CR,LF,'SOURCE FILE NAME: ',0));
            CALL out$print (marked$file$names$ptrs(top));
            CALL out$crlf;
            CALL out$print (.(' DUPLICATE NAMES: ',0));
            first = true;
            DO next = top + 1 TO last$index;
              IF duplicate$flags (next) = top THEN
                DO;
                  IF first THEN
                    first = false;
                  ELSE
                    CALL out$chars (18, ' ');
                  CALL out$print (marked$file$names$ptrs(next));
                  CALL out$crlf;
                END;
            END;
            CALL writec (.memory, obuf$p - .memory);
            IF listing$not$to$co THEN
              CALL writeo (.memory, obuf$p - .memory);
            obuf$p = .memory;
          END;
      END;
    END;
END check$duplicate$file$names;




numeric$extension: PROCEDURE ADDRESS PUBLIC;
  DECLARE start$scan ADDRESS;

  /*  assumes scan$p already pointing at extension chars
      returns 0FFFFH if not numeric extension
      otherwise returns decimal value             */

  start$scan = scan$p;
  CALL scan$while (.ddigch);
  IF (start$scan + 3) <> scan$p THEN
    RETURN 0FFFFH;
  ELSE
    DO;
      scan$p = start$scan;
      RETURN decin;
    END;
END numeric$extension;



get$greatest$numeric$exts: PROCEDURE PUBLIC;
  DECLARE last$name$equal$to$top ADDRESS,
          greatest$ext$val       ADDRESS,
          greatest$ext           ADDRESS,
          ext$val                ADDRESS;

  set$null$and$forcup: PROCEDURE (index);
    DECLARE index    ADDRESS,
            dot$ptr  ADDRESS,
            dot$byte BASED dot$ptr BYTE;
    dot$ptr = (scan$p := marked$file$names$ptrs(index)) + 6;
    dot$byte = null;
    CALL forcup$string;
  END set$null$and$forcup;

  IF (NOT listing) OR (NOT sorting) THEN  /* sort the names, easier to match */
    CALL sort$names$for$listing;

  /*  initialize array that marks greatest extensions
      and reset name ptrs past :f?: part    */

  last$index = mfn$counter - 1;
  DO next = 0 TO last$index;
    has$greatest$numeric$ext (next) = 80H;  /* haven't looked at it yet */
    marked$file$names$ptrs (next) = marked$file$names$ptrs (next) + 4;
  END;

  DO top = 0 TO last$index;
    IF has$greatest$numeric$ext (top) = 80H THEN
      DO;
        CALL set$null$and$forcup (top);
        last$name$equal$to$top = top;
        /* now mark off all file names equal to top's name
           since they're sorted, just go down the list  */
        DO WHILE true;
          IF (next := last$name$equal$to$top + 1) > last$index THEN /* top is last */
            GO TO no$more$duplicates;
          CALL set$null$and$forcup (next);
          IF scan$match (marked$file$names$ptrs(top)) THEN /* duplicate */
            last$name$equal$to$top = next;
          ELSE  /* not duplicate, give up */
            GO TO no$more$duplicates;
        END;
no$more$duplicates:
        /* find the greatest numeric extension for the current file name */
        greatest$ext$val = 0;
        greatest$ext = 0FFFFH;
        DO next = top TO last$name$equal$to$top;
          scan$p = marked$file$names$ptrs (next) + 7;  /* point at extension */
          IF (ext$val := numeric$extension) <> 0FFFFH THEN  /* it's numeric */
            DO;
              IF ext$val >= greatest$ext$val THEN  /* save this one */
                DO;
                  greatest$ext$val = ext$val;
                  greatest$ext = next;
                END;
            END;
        END;
        DO next = top TO last$name$equal$to$top;
          has$greatest$numeric$ext (next) = (next = greatest$ext);
        END;
      END;
  END; /* top = 0 TO last$index */
END get$greatest$numeric$exts;

END;
src/chklod.plm
$TITLE('==>  C H K L O D  <==  CHKLOD')

CHKLOD: DO;

/************************************************************************/
/*																		*/
/*     'Copyright 1981,1983 Intel Corporation'.  All rights reserved.	*/
/*      No part of this program or publication may be reproduced,		*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

$IF XVERSION
DECLARE PROPRIETARY(*) BYTE DATA ('INTEL PROPRIETARY SOFTWARE');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=X104',0);
$ELSE
DECLARE COPYRIGHT (*) BYTE DATA  ('COPYRIGHT 1981,1983 INTEL ');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.1',0);
$ENDIF



/*******  EXTERNALS  *******/

/* FNAMES.LIB */

out$file$name: PROCEDURE (ptr) EXTERNAL; DECLARE ptr ADDRESS; END;

/*  SYS.LIB  */

DECLARE actual ADDRESS EXTERNAL;
closei: PROCEDURE EXTERNAL; END;
ex: PROCEDURE EXTERNAL; END;
memck: PROCEDURE ADDRESS EXTERNAL; END;
readi: PROCEDURE (dst,count) EXTERNAL; DECLARE (dst,count) ADDRESS; END;
writec: PROCEDURE (src,count) EXTERNAL; DECLARE (src,count) ADDRESS; END;
writeo: PROCEDURE (src,count) EXTERNAL; DECLARE (src,count) ADDRESS; END;

/* UTIL.LIB  */

DECLARE scan$p ADDRESS EXTERNAL;
DECLARE obuf$p ADDRESS EXTERNAL;
console$in: PROCEDURE EXTERNAL; END;
error$message: PROCEDURE (ptr) EXTERNAL; DECLARE ptr ADDRESS; END;
file$ch: PROCEDURE BYTE EXTERNAL; END;
out$blank: PROCEDURE EXTERNAL; END;
out$char: PROCEDURE (char) EXTERNAL; DECLARE char BYTE; END;
out$crlf: PROCEDURE EXTERNAL; END;
out$print: PROCEDURE (ptr) EXTERNAL; DECLARE ptr ADDRESS; END;
out$scan$byte: PROCEDURE EXTERNAL; END;
scan$match: PROCEDURE (ptr) BYTE EXTERNAL; DECLARE ptr ADDRESS; END;

/* CINVOK.P80 */

DECLARE drive$specified BYTE EXTERNAL;
DECLARE dir$search (10) BYTE EXTERNAL;
DECLARE listing$file$name$ptr ADDRESS EXTERNAL;
DECLARE object$file$name$ptr ADDRESS EXTERNAL;
DECLARE listing BYTE EXTERNAL;
DECLARE sorting BYTE EXTERNAL;
process$invocation$line: PROCEDURE EXTERNAL; END;
file$error$msg: PROCEDURE (file$name$ptr, msg$ptr) EXTERNAL;
  DECLARE (file$name$ptr, msg$ptr) ADDRESS; END;

/* CMOVEM.P80 */

movem: PROCEDURE (count,src,dst) EXTERNAL;
  DECLARE (count,src,dst) ADDRESS; END;

/* CGREAT.P80 */

check$duplicate$file$names: PROCEDURE EXTERNAL; END;
get$greatest$numeric$exts: PROCEDURE EXTERNAL; END;
sort$names$for$listing: PROCEDURE EXTERNAL; END;

/* CDIREC.P80 */

process$a$directory: PROCEDURE (drive$no) EXTERNAL; DECLARE drive$no BYTE; END;

/*******  END OF EXTERNALS  *******/

/*******  PUBLICS  *******/

DECLARE marked$file$names$ptrs (512) ADDRESS PUBLIC;
DECLARE mfn$counter ADDRESS PUBLIC INITIAL (0);

/*******  END OF PUBLICS  *******/

DECLARE true  LITERALLY '0FFH',
        false LITERALLY '0',
        null  LITERALLY '0',
        CR    LITERALLY '0DH',
        LF    LITERALLY '0AH';

DECLARE scan$byte BASED scan$p BYTE,
        scan$word BASED scan$p ADDRESS,
        obuf$byte BASED obuf$p BYTE;

DECLARE end$of$filled$buffer   ADDRESS,
        mod$end$rec$type       BYTE,
        mrk$obj$rec$type       BYTE,
        record$length          ADDRESS,
        doing$8080$object      BYTE,
        i                      BYTE;

DECLARE marked$file$names (512) STRUCTURE (
         name (15) BYTE ),
        mfn$index   ADDRESS;

/* when looking at a comment or ancestor record,
   we've already gone past the type and record length fields,
   so the next two structures don't have them
*/
DECLARE arec$8080 BASED scan$p STRUCTURE (
         mnamlength      BYTE,
         mnamechksum (1) BYTE );

DECLARE crec$8086 BASED scan$p STRUCTURE (
         cclass            BYTE,
         cbits             BYTE,
         commentchksum (1) BYTE );

DECLARE could$be$marked$record BYTE INITIAL (false),
        first$buffer$byte      BYTE AT (.memory) INITIAL (0);

DECLARE source$file$string (*) BYTE INITIAL ('SOURCE_FILE=',0);
DECLARE blanks$and$null    (*) BYTE INITIAL ('              ',0);

DECLARE insert$source$msg (*) BYTE
         INITIAL (CR,LF,'insert source disk in drive ? and type <CR>...');
DECLARE no$marked$records$msg (*) BYTE
         INITIAL ('  NO MARKED RECORDS FOUND',0);

DECLARE library$msg  (*) BYTE INITIAL ('IS AN 808X LIBRARY',0),
        library$msg$type BYTE AT (.library$msg(9));
DECLARE not$obj$msg  (*) BYTE INITIAL ('IS NOT AN OBJECT MODULE',0);



its$a$library: PROCEDURE (type);
  DECLARE type BYTE;

  library$msg$type = type;
  CALL file$error$msg (object$file$name$ptr, .library$msg);
END its$a$library;


its$not$an$object$module: PROCEDURE;

  CALL file$error$msg (object$file$name$ptr, .not$obj$msg);
END its$not$an$object$module;



check$and$save$file$name: PROCEDURE;
  DECLARE saved$scan$p     ADDRESS;
  DECLARE mod$name$length  BYTE;
  DECLARE file$name$length BYTE;
  DECLARE chars$written    BYTE;

  could$be$marked$record = false;
  saved$scan$p = scan$p;
  IF doing$8080$object THEN
    DO;
      mod$name$length = arec$8080.mnamlength;
      scan$p = scan$p + 1;
      IF scan$match (.source$file$string) THEN  /* want this one */
        file$name$length = mod$name$length - 12;
      ELSE
        GO TO restore$scan$p;
    END;
  ELSE  /* 8086 */
    DO;
      IF crec$8086.cclass = 0FFH THEN
        IF crec$8086.cbits = 80H /* unpurgeable comment */  OR
           crec$8086.cbits = 0  THEN /* so far, so good */
          DO;
            scan$p = scan$p + 2;
            IF scan$match (.source$file$string) THEN  /* want this one */
              file$name$length = record$length - 15;
            ELSE
              GO TO restore$scan$p;
          END;
        ELSE GO TO restore$scan$p;
      ELSE GO TO restore$scan$p;
    END;
  mfn$index = mfn$counter;
  IF (mfn$counter := mfn$counter + 1) > 512 THEN
    CALL error$message (.('CANNOT PROCESS MORE THAN 512 MARKED FILE NAMES',0));
  obuf$p,
  marked$file$names$ptrs(mfn$index) = .marked$file$names(mfn$index);
  /* store file name in a directory listing style format */
  CALL movem (15, .blanks$and$null, obuf$p);  /* init storage area */
  IF scan$byte = ':' THEN  /* :f?: */
    DO;
      CALL out$scan$byte;
      CALL out$scan$byte;
      CALL out$scan$byte;
      CALL out$scan$byte;
      file$name$length = file$name$length - 4;
    END;
  ELSE  /* no leading file drive number, leave 4 blanks */
    obuf$p = obuf$p + 4;
  chars$written = 0;
  DO WHILE (scan$byte <> '.') AND (file$name$length > 0);
    CALL out$scan$byte;
    file$name$length = file$name$length - 1;
    chars$written = chars$written + 1;
  END;
  IF file$name$length = 0 THEN  /* no dot or extension, finished */
    GO TO restore$scan$p;
  /* otherwise, saw a dot, maybe less than 6 chars */
  obuf$p = obuf$p + (6 - chars$written);
  /* now just dump the rest */
  DO WHILE file$name$length > 0;
    CALL out$scan$byte;
    file$name$length = file$name$length - 1;
  END;

restore$scan$p:
  scan$p = saved$scan$p;
END check$and$save$file$name;


scan$whole$file: PROCEDURE;
  DECLARE new$scan$p ADDRESS;
  /* the whole file is in the buffer,
     just scan until modend record found */

  DO WHILE scan$byte <> mod$end$rec$type;
    IF scan$byte = mrk$obj$rec$type THEN
      could$be$marked$record = true;
    scan$p = scan$p + 1;
    record$length = scan$word;
    scan$p = scan$p + 2;
    IF could$be$marked$record THEN
      CALL check$and$save$file$name;
    /* check for possibility of missing modend record! */
    new$scan$p = scan$p + record$length;
    IF (new$scan$p >= end$of$filled$buffer)  /* but still less than 64K */
     OR (new$scan$p < scan$p) THEN  /* wrapped around 64K */
      CALL error$message (.('MISSING MODEND RECORD?!',0));
    scan$p = new$scan$p;
  END;
END scan$whole$file;


scan$and$buffer$file: PROCEDURE;
  DECLARE three$bytes$left$ptr ADDRESS,
          bytes$to$move        ADDRESS,
          bytes$left$in$buffer ADDRESS,
          too$much$file        ADDRESS;

  /* can't fit whole object file into buffer,
     must handle scanning to end of buffer, etc. */

  three$bytes$left$ptr = end$of$filled$buffer - 3;
  DO WHILE scan$byte <> mod$end$rec$type;
    IF scan$p >= three$bytes$left$ptr THEN  /* length field may not be here */
      DO;
        IF scan$p >= end$of$filled$buffer THEN  /* went too far, abort */
          DO;
            CALL error$message (.('UNABLE TO SCAN OBJECT FILE',0));
            CALL ex;
          END;
        /* OK here, move unscanned bytes to beginning and read again */
        bytes$to$move = end$of$filled$buffer - scan$p;
        CALL movem (bytes$to$move, scan$p, .memory);
        CALL readi (.memory + bytes$to$move, 7000H);
        scan$p = .memory;
        end$of$filled$buffer = .memory + bytes$to$move + actual;
        IF actual < 7000H THEN  /* all the rest of the file is in the buffer */
          DO;
            CALL scan$whole$file;  /* do it the easy way */
            RETURN;
          END;
        three$bytes$left$ptr = end$of$filled$buffer - 3;
      END;
    /* now OK to look at the record length */
    IF scan$byte = mrk$obj$rec$type THEN
      could$be$marked$record = true;
    scan$p = scan$p + 1;
    record$length = scan$word;
    scan$p = scan$p + 2;  /* bump past record field */
    /* record$length bytes may not have been read yet */
    bytes$left$in$buffer = end$of$filled$buffer - scan$p;
    IF could$be$marked$record THEN
      DO;
        IF bytes$left$in$buffer <= record$length THEN  /* get it all in */
          DO;
            CALL movem (bytes$left$in$buffer, scan$p, .memory);
            CALL readi (.memory + bytes$left$in$buffer, 7000H);
            scan$p = .memory;
            end$of$filled$buffer = .memory + bytes$left$in$buffer + actual;
            three$bytes$left$ptr = end$of$filled$buffer - 3;
          END;
        CALL check$and$save$file$name;
        IF actual < 7000H THEN
          DO;
            scan$p = scan$p + record$length;
            CALL scan$whole$file;
            RETURN;
          END;
      END;
    ELSE
      DO WHILE bytes$left$in$buffer <= record$length;
        CALL readi (.memory, 7000H);
        scan$p = .memory;
        end$of$filled$buffer = .memory + actual;
        record$length = record$length - bytes$left$in$buffer;
        IF actual < 7000H THEN
          DO;
            scan$p = scan$p + record$length;
            CALL scan$whole$file;
            RETURN;
          END;
        bytes$left$in$buffer = actual;
        three$bytes$left$ptr = end$of$filled$buffer - 3;
      END;
    /* whatever's left of this record is in the buffer now */
    scan$p = scan$p + record$length;
    /* now pointing at next record type byte */
  END;  /* WHILE scan$byte <> mod$end$rec$type */
  /* now we've found the modend record, but there's still more to read */
  bytes$to$move = end$of$filled$buffer - scan$p;
  CALL movem (bytes$to$move, scan$p, .memory);
  /* this is the last read, if it doesn't all fit, give up */
  too$much$file = 7000H - bytes$to$move + 1;
  CALL readi (.memory + bytes$to$move, too$much$file);
  IF actual = too$much$file THEN
    CALL error$message (.('CANNOT CHECK OBJECT MODULE SEQUENCE',0));
  scan$p = .memory;
  end$of$filled$buffer = .memory + bytes$to$move + actual;
END scan$and$buffer$file;


set$8080$rec$types: PROCEDURE;
  mod$end$rec$type = 004H;
  mrk$obj$rec$type = 010H;
  doing$8080$object = true;
END set$8080$rec$types;

set$8086$rec$types: PROCEDURE;
  mod$end$rec$type = 08AH;
  mrk$obj$rec$type = 088H;
  doing$8080$object = false;
END set$8086$rec$types;


/***************    MAINLINE CODE    ***************/

  CALL process$invocation$line;
  IF (memck-.memory+1) < 7000H THEN
    CALL error$message(.('NOT ENOUGH MEMORY',0));

  /* now object file has been opened for update */
  /* read the first byte to check for valid file */

  CALL readi (.memory, 1);
  IF first$buffer$byte = 002H THEN  /* 8080 module */
    CALL set$8080$rec$types;
  ELSE IF first$buffer$byte = 080H THEN  /* 8086 translator module */
    CALL set$8086$rec$types;
  ELSE IF first$buffer$byte = 082H THEN  /* 8086 linker module */
    CALL set$8086$rec$types;
  ELSE IF first$buffer$byte = 06EH THEN  /* 8086 locater module */
    CALL set$8086$rec$types;
  ELSE IF first$buffer$byte = 02CH THEN  /* 8080 library */
    CALL its$a$library('0');
  ELSE IF first$buffer$byte = 0A4H THEN  /* 8086 library */
    CALL its$a$library('6');
  ELSE CALL its$not$an$object$module;

  /* OK to read this object file, read it in */
  CALL readi (.memory + 1, 7000H);  /* 28K read */
  scan$p = .memory;
  end$of$filled$buffer = .memory + actual + 1;  /* points after last byte */
  IF actual < 7000H THEN  /* the whole file fit into the buffer */
    CALL scan$whole$file;
  ELSE  /* there's still more to read */
    CALL scan$and$buffer$file;

  /* done reading object file, close it */
  CALL closei;

  CALL check$duplicate$file$names;

  IF listing THEN
    DO;
      IF sorting THEN
        CALL sort$names$for$listing;
      obuf$p = .memory;
      CALL out$print (.(CR,LF,'LISTING OF ',0));
      CALL out$file$name (object$file$name$ptr);
      CALL out$crlf;
      CALL out$crlf;
      IF mfn$counter = 0 THEN
        DO;
          CALL out$print (.no$marked$records$msg);
          CALL out$crlf;
        END;
      ELSE
        DO mfn$index = 0 TO mfn$counter-1;
          CALL out$blank;
          CALL out$blank;
          CALL out$print (marked$file$names$ptrs(mfn$index));
          CALL out$crlf;
        END;
      CALL writeo (.memory, obuf$p - .memory);
    END;

  IF mfn$counter = 0 THEN  /* no point in doing anything else */
    DO;
      IF NOT listing THEN
        CALL error$message(.no$marked$records$msg(2));
      CALL ex;
    END;

  /* directory search stuff */

  IF drive$specified THEN  /* check all drives specified, no default */
    DO;
      CALL get$greatest$numeric$exts; /* set up names for directory matches */
      DO i = 0 TO 9;
        DO WHILE dir$search(i) > 0;
          insert$source$msg(30) = i + '0';
          CALL writec (.insert$source$msg, length(insert$source$msg));
          CALL console$in;
          CALL process$a$directory (insert$source$msg(30));
          dir$search(i) = dir$search(i) - 1;
        END;
      END;
    END;
  ELSE IF NOT listing THEN  /* only search default drive */
    DO;
      CALL get$greatest$numeric$exts; /* set up names for directory matches */
      CALL process$a$directory ('1');
    END;

  CALL ex;

END;
src/cinvok.plm
$TITLE('==>  C I N V O K  <==  CHKLOD')

CINVOK: DO;

/************************************************************************/
/*																		*/
/*     'Copyright 1981,1983 Intel Corporation'.  All rights reserved.	*/
/*      No part of this program or publication may be reproduced,		*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/


/*******  EXTERNALS *******/

/* FNAMES.LIB */

out$file$name: PROCEDURE (ptr) EXTERNAL; DECLARE ptr ADDRESS; END;

/*  UTIL.LIB  */

DECLARE obuf$p ADDRESS EXTERNAL;
DECLARE scan$p ADDRESS EXTERNAL;
ascbin: PROCEDURE BYTE EXTERNAL; END;
blnkch: PROCEDURE BYTE EXTERNAL; END;
console$in: PROCEDURE EXTERNAL; END;
ddigch: PROCEDURE BYTE EXTERNAL; END;
error$message: PROCEDURE (ptr) EXTERNAL; DECLARE ptr ADDRESS; END;
filech: PROCEDURE BYTE EXTERNAL; END;
out$blank: PROCEDURE EXTERNAL; END;
out$char: PROCEDURE (char) EXTERNAL; DECLARE char BYTE; END;
out$dec: PROCEDURE (value) EXTERNAL; DECLARE value ADDRESS; END;
out$print: PROCEDURE (ptr) EXTERNAL; DECLARE ptr ADDRESS; END;
scan$match: PROCEDURE (ptr) BYTE EXTERNAL; DECLARE ptr ADDRESS; END;
scan$until: PROCEDURE (proc$addr) EXTERNAL; DECLARE proc$addr ADDRESS; END;
scan$while: PROCEDURE (proc$addr) EXTERNAL; DECLARE proc$addr ADDRESS; END;
scan$while$blanks: PROCEDURE EXTERNAL; END;
termch: PROCEDURE BYTE EXTERNAL; END;

/*  SYS.LIB   */

DECLARE actual ADDRESS EXTERNAL;
DECLARE aftno ADDRESS EXTERNAL;
DECLARE fatal BYTE EXTERNAL;
DECLARE report BYTE EXTERNAL;
DECLARE status ADDRESS EXTERNAL;
ex: PROCEDURE EXTERNAL; END;
isis$cl: PROCEDURE (proc$code,block$ptr) EXTERNAL;
  DECLARE proc$code BYTE, block$ptr ADDRESS; END;
open$i: PROCEDURE (file$name$ptr) EXTERNAL;
  DECLARE file$name$ptr ADDRESS; END;
open$o: PROCEDURE (file$name$ptr) EXTERNAL;
  DECLARE file$name$ptr ADDRESS; END;

/*******  END OF EXTERNALS  *******/


DECLARE spath$code LITERALLY '14',
        null       LITERALLY '0',
        true       LITERALLY '0FFH',
        false      LITERALLY '0';


/*******  PUBLICS  *******/

DECLARE object$file$name$ptr  ADDRESS PUBLIC,
        listing$file$name$ptr ADDRESS PUBLIC,
        token$error$ptr       ADDRESS PUBLIC;

DECLARE listing         BYTE PUBLIC INITIAL (false),
        sorting         BYTE PUBLIC INITIAL (true),
        dir$search (10) BYTE PUBLIC INITIAL (0,0,0,0,0,
                                             0,0,0,0,0);

DECLARE its$a$token$error BYTE PUBLIC INITIAL (false);
DECLARE drive$specified   BYTE PUBLIC INITIAL (false);

DECLARE spath$file$info (12) BYTE PUBLIC;
DECLARE listing$not$to$co    BYTE PUBLIC;

/*******  END OF PUBLICS  *******/

DECLARE end$of$invok$line   ADDRESS;
DECLARE scan$byte BASED scan$p BYTE;

DECLARE spath$block  STRUCTURE (
         file$name$ptr ADDRESS,
         file$info$ptr ADDRESS,
         status$ptr    ADDRESS) INITIAL (0, .spath$file$info, .status);

DECLARE co$string         (*) BYTE INITIAL (':CO:',0);
DECLARE bad$file$name$msg (*) BYTE INITIAL ('IS A BAD FILE NAME',0);
DECLARE j BYTE;



file$error$msg: PROCEDURE (name$ptr, msg$ptr) PUBLIC;
  DECLARE (name$ptr, msg$ptr) ADDRESS;
  /*
    use free memory for building string,
    since we're going to exit anyways
  */
  obuf$p = .memory;
  IF its$a$token$error THEN
    CALL out$print (name$ptr);
  ELSE  /* file name */
    CALL out$file$name (name$ptr);
  CALL out$blank;
  CALL out$print (msg$ptr);
  IF status <> 0 THEN
    DO;
      CALL out$print(.(' STATUS = ',0));
      CALL out$dec(status);
    END;
  CALL out$char (null);
  CALL error$message (.memory);
  CALL ex;
END file$error$msg;



blank$or$term$or$null$char: PROCEDURE BYTE;
  /* returns true if scan$byte = blnkch OR scan$byte = termch
     OR scan$byte = null
  */
  IF blnkch THEN
    RETURN true;
  IF termch THEN
    RETURN true;
  IF scan$byte = null THEN
    RETURN true;
  RETURN false;
END blank$or$term$or$null$char;



spath$check: PROCEDURE (msg$ptr) PUBLIC;
  DECLARE msg$ptr ADDRESS;
  /*
    This checks for a valid file name, using SPATH,
    and advances scan$p past the token
  */
  spath$block.file$name$ptr = scan$p;
  CALL scan$while (.filech);   /* past file name */
  CALL isiscl (spath$code, .spath$block);
  IF status <> 0 THEN  /* bad file name */
    CALL file$error$msg (spath$block.file$name$ptr, msg$ptr);
END spath$check;



process$invocation$line: PROCEDURE PUBLIC;

  fatal,          /* all ISIS errors are fatal */
  report = TRUE;  /* automatic error reporting */

  CALL console$in;  /* read rest of line, set scan$p at the beginning */
  end$of$invok$line = scan$p + actual;
  CALL scan$while$blanks;

  /* now should be pointing at the object file name */

  object$file$name$ptr = scan$p;
  CALL spath$check (.bad$file$name$msg);

  /* loop till end of line, check and process tokens */

  DO WHILE scan$p < end$of$invok$line;
    CALL scan$while$blanks;  /* to next token */

    IF scan$match (.('LISTING',0)) OR
       scan$match (.('LT',0)) THEN  /* wants listing, check for TO filename */
      DO;
        listing = true;
        CALL scan$while$blanks;
        IF scan$match (.('TO',0)) THEN  /* should be filename now */
          DO;
            CALL scan$while$blanks;
            listing$file$name$ptr = scan$p;
            CALL spath$check (.bad$file$name$msg);
          END;
        ELSE  /* no TO, list to :CO:  */
          listing$file$name$ptr = .co$string;
      END;

    ELSE IF scan$match (.('NOSORT',0)) THEN
      sorting = false;

    ELSE IF ddigch THEN  /* number for file directory search */
      DO;
        drive$specified = true;
        j = ascbin;
        dir$search(j) = dir$search(j) + 1;
        scan$p = scan$p + 1;   /* past this number */
      END;

    ELSE IF termch OR (scan$byte = ';') THEN  /* end of line */
      GO TO no$more$tokens;

    ELSE  /* something bad */
      DO;
        token$error$ptr = scan$p;
        CALL scan$until (.blank$or$term$or$null$char);
        scan$byte = null;
        its$a$token$error = true;
        CALL file$error$msg (token$error$ptr,
                              .('IS AN INVALID COMMAND LINE TOKEN',0));
      END;

  END;  /* DO WHILE */

no$more$tokens:

  /* now open the files */

  CALL openi (object$file$name$ptr);
  IF listing THEN
    CALL openo (listing$file$name$ptr);
  listing$not$to$co = listing AND (aftno <> 0);

END process$invocation$line;

END;
src/clean.plm
$ TITLE('CLEAN -- NUMERIC SOURCE EXTENSION CLEANUP TOOL')

CLEAN$MOD:
DO;

/************************************************************************/
/*																		*/
/*     'Copyright 1981,1983 Intel Corporation'.  All rights reserved.	*/
/*      No part of this program or publication may be reproduced,		*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

$IF XVERSION
DECLARE PROPRIETARY(*) BYTE DATA ('INTEL PROPRIETARY SOFTWARE');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=X103',0);
$ELSE
DECLARE COPYRIGHT (*) BYTE DATA  ('COPYRIGHT 1981,1983 INTEL ');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.1',0);
$ENDIF


		/* ISIS.INC */

CLOSE: PROCEDURE (AFTN,STATUS) EXTERNAL; DECLARE (AFTN,STATUS) ADDRESS; END;
CO:	PROCEDURE (CHAR$CO) EXTERNAL; DECLARE CHAR$CO BYTE; END;
DELETE: PROCEDURE (FILE$NAME$PTR,STATUS) EXTERNAL;
	DECLARE (FILE$NAME$PTR,STATUS) ADDRESS; END;
ERROR: PROCEDURE (ERROR$NUMBER) EXTERNAL; DECLARE ERROR$NUMBER ADDRESS; END;
EXIT: PROCEDURE EXTERNAL; END;
GETD: PROCEDURE(DRIVE$NO,CONNECTION,COUNT,ACTUAL$ENTRY,BUFFER,STATUS) EXTERNAL;
    DECLARE DRIVE$NO  BYTE;
    DECLARE (CONNECTION,COUNT,ACTUAL$ENTRY,BUFFER,STATUS) ADDRESS; END;
LOAD: PROCEDURE (FILE,BIAS,CONTROL$OF$TRANSFER,ENTRY$POINT,STATUS) EXTERNAL;
	DECLARE (FILE,BIAS,CONTROL$OF$TRANSFER,ENTRY$POINT,STATUS) ADDRESS;	END;
MEMCK: PROCEDURE ADDRESS EXTERNAL; END;
OPEN: PROCEDURE(AFTN,FILENAME,ACCESS$MODE,LINE$EDIT$AFTN,ERROR) EXTERNAL;
	DECLARE (AFTN,FILENAME,ACCESS$MODE,LINE$EDIT$AFTN,ERROR) ADDRESS; END;
READ: PROCEDURE (AFTN,BUFFER,COUNT,ACTUAL,STATUS) EXTERNAL;
	DECLARE (AFTN,BUFFER,COUNT,ACTUAL,STATUS) ADDRESS; END;
SEEK: PROCEDURE (AFTN,MODE,BLOCKNO,BYTENO,STATUS) EXTERNAL;
	DECLARE (AFTN,MODE,BLOCKNO,BYTENO,STATUS) ADDRESS; END;
SPATH: PROCEDURE (FILE,BUFFER,STATUS) EXTERNAL;
	DECLARE (FILE,BUFFER,STATUS) ADDRESS; END;
WRITE: PROCEDURE (AFTN,BUFFER,COUNT,STATUS) EXTERNAL;
	DECLARE (AFTN,BUFFER,COUNT,STATUS) ADDRESS; END;

/*          LIT.INC          */

DECLARE					 LIT LITERALLY 'LITERALLY',
	BELL				 LIT '07H',				 /* plm */
	BLANK				 LIT '020H',			 /* plm */
    BOOLEAN				 LIT 'BYTE',			 /* plm */
	CHK					 LIT 'CALL CHECK$STATUS(STATUS)', /* plm */
    CO$ECHO$FILE		 LIT '0F00H',
	COLON			     LIT '03AH',			 /* plm */
    COMMA				 LIT '02CH',			 /* plm */
    CONSOLE$INPUT		 LIT  '1',
	CONSOLE$OUTPUT		 LIT '0',
	CONTROL$Z			 LIT  '01AH',			 /* plm */
	CR					 LIT '0DH',				 /* plm */
	CRLF				 LIT '0D0AH',			 /* plm */
	DOT					 LIT '02EH',				 /* plm */
    ENDDO				 LIT 'END',				 /* plm */
	ENDDOCASE			 LIT  'END',			 /* plm */
	ENDDOWHILE			 LIT  'END',			 /* plm */
    ENDIF				 LIT ' ',				 /* plm */
	END$LOOP			 LIT ' ',				 /* plm */
	EOF$CHAR			 LIT	 'CONTROL$Z',	 /* plm */
	ESC					 LIT		'01BH',		 /* plm */
	FALSE				 LIT '0H',				 /* plm */
	FOREVER 			 LIT 'WHILE 1',			 /* plm */
	GOTO$EOF			 LIT  '4',				 /* seek */
	LF					 LIT '0AH',				 /* plm */
	MOVE$BACKWARD		 LIT  '1',				 /* seek */
	NO$LINE$EDIT 		 LIT   '0',				 /* open */
	OPEN$FOR$READ		 LIT '1',				 /* open */
	OPEN$FOR$WRITE		 LIT '2',				 /* open */
	RETURN$POSITION		 LIT '0',				 /* seek */
    STRING 				 LIT '(*) BYTE DATA',	 /* seek */
	TAB					 LIT '09H',				 /* plm */
    TRANSFER$CONTROL	 LIT '1',				 /* load */
	TRUE				 LIT '0FFH',			 /* plm */
	USER$CI 			 LIT '0',
	ZERO				 LIT '30',				 /* plm */
    ZERO$BIAS			 LIT '0'				 /* load */ ;

/*        END LIT.INC        */
$ LIST
$ EJECT
/************************************************************/
/*															*/
/*			GLOBAL 					VARIABLES 				*/
/*															*/
/************************************************************/

/*	Based Structures. */

DECLARE DIR$ENTRY$PTR ADDRESS;
DECLARE DIR$ENTRY BASED DIR$ENTRY$PTR STRUCTURE
   (PRESENCE BYTE,
	FILENAME (6) BYTE,
	EXTENSION (3) BYTE,
	ATTRIBUTES BYTE,
	EOF$COUNT BYTE,
    NUMBER$DATA$BLOCKS ADDRESS,
	HEADER$BLOCK$POINTER ADDRESS);

DECLARE MEM$PTR ADDRESS;
DECLARE FILE BASED MEM$PTR STRUCTURE
     (NAME (6) BYTE,
	  LARGEST ADDRESS,
	  NEXT    ADDRESS,
	  EXT$PTR ADDRESS);

DECLARE EXT$PTR ADDRESS;
DECLARE EXTENSION BASED EXT$PTR STRUCTURE
	 (VALUE ADDRESS,
	  NEXT ADDRESS);

/* End of Based Structure Declarations. */

$IF XVERSION
DECLARE BANNER STRING
	('ISIS-II NUMERIC SOURCE EXTENSION CLEANUP TOOL, X103',CR,LF,LF,0);
$ELSE
DECLARE BANNER STRING
	('ISIS-II NUMERIC SOURCE EXTENSION CLEANUP TOOL, V1.1',CR,LF,LF,0);
$ENDIF

DECLARE (ACTUAL,STATUS) ADDRESS;
DECLARE MEM$TOP ADDRESS;
DECLARE MONITOR ADDRESS DATA (0);
DECLARE ASCII$DEVICE$NUMBER BYTE;
DECLARE CONNECTION ADDRESS INITIAL(0);
DECLARE END$OF$DIRECTORY ADDRESS;
DECLARE READING$REMOTE BYTE;

DECLARE BUCKET (256) ADDRESS;
DECLARE DIR$LENGTH ADDRESS;

DECLARE FREE$SPACE$BOTTOM ADDRESS;

$ EJECT

/************************************************************/
/*															*/
/*			UTILITY					PROCEDURES				*/
/*															*/
/************************************************************/

FIND$BLANK$OR$TAB:
	PROCEDURE (CHAR$PTR) ADDRESS PUBLIC;
	DECLARE CHAR$PTR ADDRESS,
		CHAR BASED CHAR$PTR BYTE;
	DO WHILE NOT ( CHAR = 20 OR CHAR = 9);
		CHAR$PTR = CHAR$PTR + 1;
	ENDDO;
	RETURN CHAR$PTR;
	END
FIND$BLANK$OR$TAB;

SKIP$BLANKS$N$TABS:
	PROCEDURE (CHAR$PTR) ADDRESS PUBLIC;
	DECLARE CHAR$PTR ADDRESS;
	DECLARE CHAR BASED CHAR$PTR BYTE;
	DO WHILE (CHAR=BLANK) OR (CHAR=TAB);
		CHAR$PTR = CHAR$PTR + 1;
	ENDDO;
	RETURN CHAR$PTR;
END SKIP$BLANKS$N$TABS;

FIND$CRLF:
	PROCEDURE (TEXT$PTR) ADDRESS PUBLIC;
	DECLARE TEXT$PTR ADDRESS,
			TEXT BASED TEXT$PTR ADDRESS;
	DO WHILE TEXT <> CRLF;
		TEXT$PTR = TEXT$PTR + 1;
	ENDDO;
	RETURN TEXT$PTR;
	END
FIND$CRLF;

FORCUP:
	PROCEDURE (START$PTR,NUM$CHAR);

	DECLARE START$PTR ADDRESS,
			NUM$CHAR BYTE,
			COUNT BYTE,
			CHAR BASED START$PTR BYTE;

	DO COUNT=1 TO NUM$CHAR;
		IF (CHAR>='a') AND (CHAR<='z') THEN
			CHAR = CHAR - 20H;
		ENDIF
		START$PTR = START$PTR + 1;
	ENDDO;
	END
FORCUP;

CHECK$STATUS:
	PROCEDURE (ISIS$STATUS) ;
	DECLARE ISIS$STATUS ADDRESS;
	IF ISIS$STATUS <> 0 THEN
		DO;
			CALL ERROR(ISIS$STATUS);
			CALL EXIT;
		ENDDO;
	ENDIF
	END
CHECK$STATUS;

NUMERAL:
	PROCEDURE (A$CHAR) BOOLEAN;
	DECLARE A$CHAR BYTE;
	IF A$CHAR >= '0' AND A$CHAR <= '9' THEN
		RETURN TRUE;
	ELSE
		RETURN FALSE;
	ENDIF
	END
NUMERAL;

NUMERIC$EXTENSION:
	PROCEDURE (PTR) BOOLEAN;

	/*	Given a pointer into memory, this procedure determines
		whether the byte pointed to, and the next two contiguous
		bytes, constitute a wholly numeric ascii sequence.			*/

	DECLARE PTR ADDRESS,
			CHAR BASED PTR (10) BYTE;
	DECLARE L BYTE;
	DO L=0 TO 2;
		IF NOT NUMERAL(CHAR(L)) THEN
			RETURN FALSE;
		ENDIF
	ENDDO;
	RETURN TRUE;
	END
NUMERIC$EXTENSION;

ISIS$TERMINATOR:
	PROCEDURE (A$CHAR) BOOLEAN;
	DECLARE A$CHAR BYTE;
	RETURN NOT 					(
		( (A$CHAR >= 'A') AND (A$CHAR <= 'Z') )    OR
		( (A$CHAR >= '0') AND (A$CHAR <= '9') )    OR
		(A$CHAR = ':')                             OR
		 (A$CHAR = '.')
					);
	END
ISIS$TERMINATOR;

STOP$EVERYTHING:
	PROCEDURE (MSG$PTR) ;

	/*	This procedure is used if a fatal error is detected.  It
		receives a parameter which is a pointer to an error message.
        It prints the error message, rings a bell, and exits. */

	DECLARE MSG$PTR ADDRESS,
			MSG BASED MSG$PTR (256) BYTE;
    DECLARE MSG$LENGTH ADDRESS;

    MSG$LENGTH = 0;

    /*	Allow no message to be longer than 255 bytes.  This is a useful
    	check if the 0 has been left off the end of the message. */

    DO WHILE (MSG(MSG$LENGTH) <> 0) AND (MSG$LENGTH < 255);
    	MSG$LENGTH = MSG$LENGTH + 1;
    ENDDO;

    CALL WRITE(CONSOLE$OUTPUT,MSG$PTR,MSG$LENGTH,.STATUS); CHK;
	CALL CO(BELL);
	CALL EXIT;

    END
STOP$EVERYTHING;

LEGIT$DISK$DESIGNATION:
	PROCEDURE (PARSEE$PTR) BOOLEAN;
	DECLARE PARSEE$PTR ADDRESS,
		CHAR BASED PARSEE$PTR (4) BYTE;

	RETURN
		(CHAR(0) = ':') AND
        (CHAR(1) = 'F') AND
        ((CHAR(2) >= '0') AND (CHAR(2) <= '9')) AND
        (CHAR(3) = ':');
	END
LEGIT$DISK$DESIGNATION;

CONVERT$FILENAME:
	PROCEDURE (INT$FILNAM$PTR,DEVICE$DESIG$CHAR) ADDRESS;

	/*	This procedure takes an "internal filename" and converts it to
		the regular form. It takes a pointer to the internal filename
		as parameter, and returns a pointer to the resultant regular
		filename. */

	DECLARE INT$FILNAM$PTR ADDRESS;
	DECLARE DEVICE$DESIG$CHAR BYTE;
	DECLARE FILNAM$CHAR BASED INT$FILNAM$PTR (20) BYTE;

    DECLARE LONG$BUF (20) BYTE;
    DECLARE RESULT$BUFFER (11) BYTE AT (.LONG$BUF(4));

    DECLARE K BYTE;
	DECLARE E BYTE;

	DO K=0 TO LAST(LONG$BUF);
		LONG$BUF(K) = BLANK;
	ENDDO;

    LONG$BUF(0),LONG$BUF(3) = COLON;
    LONG$BUF(1) = 'F';
    LONG$BUF(2) = DEVICE$DESIG$CHAR;

    K = 0;
	DO WHILE (FILNAM$CHAR(K) <> 0) AND (K < 6);
    	RESULT$BUFFER(K) = FILNAM$CHAR(K);
    	K = K + 1;
    ENDDO;

    IF FILNAM$CHAR(6) <> 0 THEN
    	RESULT$BUFFER(K) = DOT;
    ENDIF

    K = K + 1;
    E = 6;
    DO WHILE (FILNAM$CHAR(E) <> 0) AND (E <= 8);
    	RESULT$BUFFER(K) = FILNAM$CHAR(E);
    	K = K + 1;
    	E = E + 1;
    ENDDO;

    LONG$BUF(LAST(LONG$BUF)-2) = COMMA;
    LONG$BUF(LAST(LONG$BUF)) = 0;

    RETURN (.LONG$BUF);
    END
CONVERT$FILENAME;

FILE$LENGTH:
	PROCEDURE (FILE$NAME$PTR) ADDRESS;

    DECLARE FILENAME$PTR ADDRESS;
	DECLARE TMP$AFTN ADDRESS;
	DECLARE (BYTE$NO,BLOCK$NO) ADDRESS;

    CALL OPEN(.TMP$AFTN,FILE$NAME$PTR,OPEN$FOR$READ,NO$LINE$EDIT,.STATUS); CHK;
    CALL SEEK(TMP$AFTN,GOTO$EOF,.BLOCK$NO,.BYTE$NO,.STATUS); CHK;
    CALL SEEK(TMP$AFTN,RETURN$POSITION,.BLOCK$NO,.BYTE$NO,.STATUS); CHK;
    CALL CLOSE(TMP$AFTN,.STATUS); CHK;

    RETURN ((128 * (BLOCK$NO MOD 32768)) + BYTE$NO);
	END
FILE$LENGTH;

FREE$SPACE$TOP:
	PROCEDURE ADDRESS;
	RETURN (DIR$ENTRY$PTR - 1);
    END
FREE$SPACE$TOP;

WRITE$CO:
	PROCEDURE (TEXT$PTR) ;
	/*	This procedure that the parameter passed to it points to a
		text string which is terminated by a 0.  If write$co does
		not find a 0 within 256 bytes of the beginning of the
		string, then only those 256 bytes are written out. */

    DECLARE TEXT$PTR ADDRESS,
    		TEXT BASED TEXT$PTR (256) BYTE;
    DECLARE T ADDRESS;

    T = 0;
    DO WHILE (TEXT(T) <> 0) AND (T<=255);
    	T = T + 1;
    ENDDO;
    CALL WRITE(CONSOLE$OUTPUT,TEXT$PTR,T,.STATUS); CHK;
    END
WRITE$CO;

$ EJECT

/****************************************************************/
/*																*/
/*				MAIN					PROCEDURES				*/
/*																*/
/****************************************************************/

INITIALIZE:
	PROCEDURE;

	DECLARE I ADDRESS;

    CALL WRITE$CO(.BANNER);

    DO I=0 TO 255;
		BUCKET(I) = 0;
    ENDDO;

	MEM$TOP = MEM$CK - 13;

    FREE$SPACE$BOTTOM = .MEMORY + 1;

    END
INITIALIZE;

PARSE$COMMAND$TAIL:
	PROCEDURE;

	DECLARE (COMMAND$TAIL,WHOLE$COMMAND$LINE) (140) BYTE;
    DECLARE CHAR$PTR ADDRESS,
    		CHAR BASED CHAR$PTR BYTE;

	CALL READ(CONSOLE$INPUT,.COMMAND$TAIL,SIZE(COMMAND$TAIL),
            .ACTUAL,.STATUS); CHK;
	CHAR$PTR = .COMMAND$TAIL;
	CHAR$PTR = SKIP$BLANKS$N$TABS(CHAR$PTR);

	IF NUMERAL(CHAR) THEN
		ASCII$DEVICE$NUMBER = CHAR;
	ELSE
		CALL STOP$EVERYTHING
			(.('Syntax is "CLEAN ?", where ? is a number 0-9.',CR,LF,0));
	ENDIF
    END
PARSE$COMMAND$TAIL;

READ$IN$DIRECTORY:
	PROCEDURE;

	DECLARE DIRECTORY$NAME STRING
		(':F?:ISIS.DIR ');
	DECLARE ASCII$DEVICE$CHAR BYTE AT (.DIRECTORY$NAME(2));
    DECLARE DIR$AFTN ADDRESS;
	DECLARE DIR$ACTUAL ADDRESS;
    DECLARE BUFFER(12) BYTE;
    DECLARE COUNT ADDRESS ;
    DECLARE ACTUAL$ENTRY ADDRESS;
    DECLARE ENTRY ADDRESS;

	ASCII$DEVICE$CHAR = ASCII$DEVICE$NUMBER;
	CALL SPATH(.DIRECTORY$NAME, .BUFFER, .STATUS); CHK;
      IF BUFFER(10) = 3  AND  BUFFER(11) > 4  THEN
         DO;
            IF MEM$TOP < 0E800H  THEN
               CALL STOP$EVERYTHING
                    (.('insufficient  memory ', CR, LF,0));
            ELSE
               DO;
                 dir$entry$ptr = .memory;
                 COUNT = (0E800H - .MEMORY)/16;
                 CALL LOAD(.(':F0:ISIS.OV0 '),0,0,.ENTRY,.STATUS); CHK;
                 CALL GETD(ASCII$DEVICE$CHAR-'0',.CONNECTION,COUNT,
                          .ACTUAL$ENTRY,DIR$ENTRY$PTR,.STATUS); CHK;

                 IF ACTUAL$ENTRY >= COUNT  THEN
                    CALL STOP$EVERYTHING
                    (.('Remote directory too large.', CR,LF,0));
                 DO;  /* now move the whole thing up */
                   DECLARE (src$p,dst$p,i) ADDRESS;
                   dst$p = memtop;
                   src$p = dir$entry$ptr + (actual$entry*16);
                   DO i = 1 to actual$entry;
                     dst$p = dst$p - 16;
                     src$p = src$p - 16;
                     CALL MOVE(16,src$p,dst$p);
                   END;
                   dir$entry$ptr = dst$p;
                   end$of$directory = memtop;
                 END;
                 READING$REMOTE = TRUE;
               END;
         END;
      ELSE
         DO;
            DIR$LENGTH = FILE$LENGTH(.DIRECTORY$NAME);
            DIR$ENTRY$PTR = MEM$TOP - DIR$LENGTH + 1;
            IF DIR$LENGTH > MEM$TOP - .MEMORY THEN /* error condition */
                CALL STOP$EVERYTHING
                 (.('Disk directory too large for available memory',CR,LF,0));
            ENDIF

            CALL OPEN(.DIR$AFTN,.DIRECTORY$NAME,OPEN$FOR$READ,NO$LINE$EDIT,
                      .STATUS);  CHK;
            CALL READ(DIR$AFTN,DIR$ENTRY$PTR,DIR$LENGTH,.DIR$ACTUAL,.STATUS);
                                 CHK;
            IF DIR$ACTUAL <> DIR$LENGTH THEN
              CALL STOP$EVERYTHING
            (.('Seek and Read imply different value for directory.',CR,LF,0));
            ENDIF
            CALL CLOSE(DIR$AFTN,.STATUS); CHK;
            READING$REMOTE = FALSE;
            END$OF$DIRECTORY = DIR$ENTRY$PTR + DIR$ACTUAL;
         END;
    END
READ$IN$DIRECTORY;

HASH:
	PROCEDURE BYTE;
	/*	This procedure returns a hash value for the name part of a particular
		directory entry. */
	DECLARE NAME BASED DIR$ENTRY$PTR (6) BYTE;
	DECLARE L BYTE,
		HASH$VALUE BYTE;

    HASH$VALUE = NAME(0);
    DO L=1 TO 5;
    	IF NAME(L) <> 0 THEN
    		HASH$VALUE = ROL(HASH$VALUE,1) XOR NAME(L);
        ELSE
        	RETURN HASH$VALUE;
        ENDIF
    ENDDO;
    RETURN HASH$VALUE;
	END
HASH;

GET$SPACE:
	PROCEDURE (SPACE$NEEDED) ADDRESS;
	DECLARE RESULT ADDRESS;
	DECLARE SPACE$NEEDED ADDRESS;

	IF (SPACE$NEEDED <= FREE$SPACE$TOP - FREE$SPACE$BOTTOM + 1) AND
	   (FREE$SPACE$TOP >= FREE$SPACE$BOTTOM)
	   												THEN
		DO;
			RESULT = FREE$SPACE$BOTTOM;
			FREE$SPACE$BOTTOM = FREE$SPACE$BOTTOM + SPACE$NEEDED;
			RETURN RESULT;
		ENDDO;
	ELSE
		/*	out of space. */
		CALL STOP$EVERYTHING
			(.('Not enough free memory to process directory.',CR,LF,0));
	ENDIF
	END
GET$SPACE;

VAL$OF$EXT:
	PROCEDURE  ADDRESS;

	DECLARE DIR$EXT$PTR ADDRESS;
    DECLARE EXT$MASK BASED DIR$EXT$PTR (3) BYTE;
	DECLARE EXT$VAL ADDRESS,
			M BYTE;

	DIR$EXT$PTR = .DIR$ENTRY.EXTENSION;

    EXT$VAL = 0;
	DO M=0 TO 2;
		EXT$VAL = (EXT$VAL * 10) + EXT$MASK(M) - '0';
	ENDDO;

	RETURN EXT$VAL;
	END
VAL$OF$EXT;

COPY$NAME$PART:
	PROCEDURE;
	DECLARE P BYTE;
	DO P=0 TO 5;
		FILE.NAME(P) = DIR$ENTRY.FILE$NAME(P);
	ENDDO;
	END
COPY$NAME$PART;

$ EJECT

ENTER$FILE:
	PROCEDURE;
	DECLARE HASH$VAL BYTE;

/*	Here follow embedded procedures. */

FILL$IN$ENTRIES:
	PROCEDURE;
    CALL COPY$NAME$PART;
    EXT$PTR = GET$SPACE(SIZE(EXTENSION));
    EXTENSION.VALUE = VAL$OF$EXT;
    FILE.NEXT,EXTENSION.NEXT = 0;
    END
FILL$IN$ENTRIES;

INITIALIZE$EXTENSION:
	PROCEDURE;
	EXT$PTR,FILE.EXT$PTR = GET$SPACE(SIZE(EXTENSION));
    EXTENSION.NEXT = 0;
	EXTENSION.VALUE,FILE.LARGEST = VAL$OF$EXT;
    END
INITIALIZE$EXTENSION;

INITIALIZE$HASH$BUCKET:
	PROCEDURE;
	BUCKET(HASH$VAL),MEM$PTR = GET$SPACE(SIZE(FILE));
	EXT$PTR,FILE.EXT$PTR =     GET$SPACE(SIZE(EXTENSION));
    EXTENSION.NEXT,FILE.NEXT = 0;
	CALL COPY$NAME$PART;
	EXTENSION.VALUE,FILE.LARGEST = VAL$OF$EXT;
    END
INITIALIZE$HASH$BUCKET;

ENTER$EXTENSION:
	PROCEDURE;

	/*		Enter extension at beginning of list of extensions. */
    EXT$PTR = GET$SPACE(SIZE(EXTENSION));

    EXTENSION.VALUE = VAL$OF$EXT;
    EXTENSION.NEXT  = FILE.EXT$PTR;
    FILE.EXT$PTR    = EXT$PTR;

	IF EXTENSION.VALUE > FILE.LARGEST THEN
		FILE.LARGEST = EXTENSION.VALUE;
	ENDIF

    END
ENTER$EXTENSION;

ENTER$NEW$NAME:
	PROCEDURE;
	MEM$PTR = GET$SPACE(SIZE(FILE));
	FILE.NEXT = BUCKET(HASH$VAL);
	BUCKET(HASH$VAL) = MEM$PTR;
	CALL COPY$NAME$PART;
	CALL INITIALIZE$EXTENSION;
	END
ENTER$NEW$NAME;

NAMES$MATCH:
	PROCEDURE BOOLEAN;
	DECLARE Q BYTE;
	DO Q=0 TO 5;
		IF DIR$ENTRY.FILENAME(Q) <> FILE.NAME(Q) THEN
			RETURN FALSE;
        ENDIF
    ENDDO;
    RETURN TRUE;
    END
NAMES$MATCH;

/* End of embedded procedures. */

	HASH$VAL = HASH;
	IF BUCKET(HASH$VAL) = 0 THEN
         CALL INITIALIZE$HASH$BUCKET;
    ELSE
    	DO;
    		MEM$PTR = BUCKET(HASH$VAL);
    		loop$begin:
    			IF NAMES$MATCH THEN
    				CALL ENTER$EXTENSION;
    			ELSE IF (FILE.NEXT=0) THEN
    				CALL ENTER$NEW$NAME;
    			ELSE
    				DO;
    					MEM$PTR = FILE.NEXT;
    					GO TO loop$begin;
    				ENDDO;
    			ENDIF
    		end$loop
    	ENDDO;
    ENDIF
	END
ENTER$FILE;

$ EJECT

DELETEABLE$EXTENSION:
	PROCEDURE BOOLEAN;

EXTENSIONS$MATCH:
	PROCEDURE (PTR$1,PTR$2) BOOLEAN;

	DECLARE PTR$1 ADDRESS,
			EXT$1 BASED PTR$1 (3) BYTE;

	DECLARE PTR$2 ADDRESS,
			EXT$2 BASED PTR$2 (3) BYTE;
	DECLARE R BYTE;

	DO R=0 TO 2;
		IF EXT$1(R) <> EXT$2(R) THEN
			RETURN FALSE;
		ENDIF
	ENDDO;
	RETURN TRUE;

	END
EXTENSIONS$MATCH;

	RETURN EXTENSIONS$MATCH(.('BAK'),.DIR$ENTRY.EXTENSION) OR
           EXTENSIONS$MATCH(.('TMP'),.DIR$ENTRY.EXTENSION)  ;

	END
DELETEABLE$EXTENSION;

NUM$OUT:
	PROCEDURE (AN$AFTN,A$NUMBER) ;
	DECLARE (AN$AFTN,A$NUMBER) ADDRESS;
	DECLARE TMP$BUF (5) BYTE;
	DECLARE J BYTE;

	DO J=0 TO 4;
		TMP$BUF(4-J) = (A$NUMBER MOD 10) + '0';
		A$NUMBER = A$NUMBER / 10;
    ENDDO;

    J = 0;
    DO WHILE TMP$BUF(J) = ZERO;
    	J = J + 1;
    ENDDO;

	CALL WRITE(AN$AFTN,.TMP$BUF(J-1),(SIZE(TMP$BUF)-J+1),.STATUS); CHK;
	END
NUM$OUT;

DELETE$IT:
	PROCEDURE (INT$FIL$PTR) ;
	/*	The parameter, received by this procedure, points to an
		"internal form" of the filename. */

    DECLARE INT$FIL$PTR ADDRESS;

    DECLARE X$STATUS ADDRESS,
    		ASCII$FIL$PTR ADDRESS;

    ASCII$FIL$PTR = CONVERT$FILENAME(INT$FIL$PTR,ASCII$DEVICE$NUMBER);
	CALL WRITE$CO(ASCII$FIL$PTR);
    CALL DELETE(ASCII$FIL$PTR,.X$STATUS);

	IF X$STATUS = 0 THEN
		CALL WRITE$CO(.('DELETED',CR,LF,0));
    ELSE IF (X$STATUS=14) THEN
        CALL WRITE$CO(.('WRITE PROTECTED',CR,LF,0));
    ELSE
        DO;
             CALL WRITE$CO(.('ISIS ERROR ',0));
             CALL NUM$OUT(CONSOLE$OUTPUT,X$STATUS);
             CALL WRITE$CO(.(CR,LF,0));
        ENDDO;
	ENDIF

    END
DELETE$IT;

PROCESS$ONE$ENTRY:
	PROCEDURE;
	IF DELETEABLE$EXTENSION THEN
		CALL DELETE$IT(.DIR$ENTRY.FILENAME);
	ELSE IF NUMERIC$EXTENSION(.DIR$ENTRY.EXTENSION) THEN
		CALL ENTER$FILE;
	ENDIF
	/*	Notice that if the filename has neither a deletetable,
		not a numeric extension, then it is ignored. */
	END
PROCESS$ONE$ENTRY;

PROCESS$DIRECTORY:
	PROCEDURE;

	/* Main Directory Processing Loop. */

	DO WHILE  DIR$ENTRY$PTR < END$OF$DIRECTORY;
	   IF NOT READING$REMOTE  THEN
	     DO;
	        IF DIR$ENTRY.PRESENCE = 7FH  THEN
	           GO TO no$more$dir;
	        IF DIR$ENTRY.PRESENCE = 0FFH  THEN
	           GO TO bump$ptr;
	     END;
	   CALL PROCESS$ONE$ENTRY;

	   bump$ptr:
	   DIR$ENTRY$PTR = DIR$ENTRY$PTR + 16;
    ENDDO;

 no$more$dir:
	END
PROCESS$DIRECTORY;

RECONSTITUTE$FILENAME:
	PROCEDURE (COMPACT$EXT) ADDRESS;

	DECLARE COMPACT$EXT ADDRESS;

    DECLARE BUF (9) BYTE;
	DECLARE Z BYTE;

	DO Z=0 TO 5;
		BUF(Z) = FILE.NAME(Z);
	ENDDO;

	DO Z=0 TO 2;
		BUF(LAST(BUF)-Z) = (COMPACT$EXT MOD 10) + '0';
        COMPACT$EXT      = COMPACT$EXT / 10;
	ENDDO;
	RETURN (.BUF);

	END
RECONSTITUTE$FILENAME;

DELETE$A$NAMEFUL:
	PROCEDURE;
	EXT$PTR = FILE.EXT$PTR;

	begin$loop:
		/*	Don't delete the file with the largest extension. */
        IF EXTENSION.VALUE < FILE.LARGEST THEN
        	CALL DELETE$IT(RECONSTITUTE$FILENAME(EXTENSION.VALUE));
		ENDIF
        IF EXTENSION.NEXT<>0 THEN
			DO;
				EXT$PTR = EXTENSION.NEXT;
				GOTO begin$loop;
			ENDDO;
		ENDIF
	end$loop
	END
DELETE$A$NAMEFUL;

DELETE$A$BUCKET$FUL:
	PROCEDURE (BUCKET$INDEX) ;
	DECLARE BUCKET$INDEX ADDRESS;

	MEM$PTR = BUCKET(BUCKET$INDEX);
    loop$label:
		CALL DELETE$A$NAMEFUL;
		IF FILE.NEXT<>0 THEN
			DO;
				MEM$PTR = FILE.NEXT;
				GOTO loop$label;
			ENDDO;
		ENDIF
	end$loop
	END
DELETE$A$BUCKET$FUL;

DELETE$FILES:
	PROCEDURE;
	DECLARE WHICH$BUCKET ADDRESS;

    DO WHICH$BUCKET=0 TO 255;
		IF BUCKET(WHICH$BUCKET)<>0 THEN
			CALL DELETE$A$BUCKET$FUL(WHICH$BUCKET);
    	ENDIF
    ENDDO;
	END
DELETE$FILES;

$ EJECT

/****************************************************************/
/*																*/
/*			MAIN		LINE			CODE					*/
/*																*/
/****************************************************************/

CALL INITIALIZE;
CALL PARSE$COMMAND$TAIL;
CALL READ$IN$DIRECTORY;
CALL PROCESS$DIRECTORY;
CALL DELETE$FILES;
CALL EXIT;

END
CLEAN$MOD;
EOF
src/cli.plm
$ TITLE ('==> PASSIF -- CLIMOD -- COMMAND LINE INTERPRETOR <==')

CLI$MOD:
DO;

/************************************************************************/
/*																		*/
/*     'Copyright 1981,1983 Intel Corporation'.  All rights reserved.	*/
/*      No part of this program or publication may be reproduced,		*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

$ NOLIST

/*         LIT.INC          */

DECLARE					AS LITERALLY 'LITERALLY',
	AMPERSAND			AS '''&''',
	BELL				AS '07H',
	BLANK				AS '020H',
	BOOLEAN				AS 'BYTE',
	CHK					AS 'CALL CHECK$STATUS',
	CLEAR$CHAR			AS '01CH',
	CO$ECHO$FILE		AS '0F00H',
	COLON				AS ''':''',
	COMMA				AS '02CH',
	CONSOLE$INPUT		AS '1',
	CONSOLE$OUTPUT		AS '0',
	CONTROL$Z			AS '01AH',
	CR					AS '0DH',
	DOT					AS '''.''',
	END$DO				AS 'END',
	END$DO$CASE			AS 'END',
	END$DO$WHILE		AS 'END',
	END$IF				AS '   ',
	END$ITERATED$DO		AS 'END',
	END$LOOP			AS ' ',
	EOF$CHAR			AS 'CONTROL$Z',
	ESC					AS '01BH',
	FALSE				AS '0H',
	FF					AS '0CH',
	FOREVER				AS 'WHILE 1',
	FORMAT$ATTRIBUTE	AS '3',
	HASH$MARK			AS '''#''',
	INIT$STG			AS '(*) BYTE INITIAL',
	LEAD$IN$CHAR		AS '07EH',
	LF					AS '0AH',
	NO$LINE$EDIT		AS '0',
	NULL				AS '0FFFFH',
	OPEN$FOR$READ		AS '1',
	OPEN$FOR$WRITE		AS '2',
	OPEN$FOR$UPDATE		AS '3',
	PUB$STRING			AS '(*) BYTE PUBLIC DATA',
	RESET				AS '0',
	RETURN$MARKER$POS	AS '0',
	SEEK$2$EOF			AS '4',
	SEEK$BACKWARD$BY$N	AS '1',
	SEEK$FORWARD$BY$N	AS '3',
	SEEK$2$N			AS '2',
	SEMICOLON			AS ''';''',
	SET					AS '1',
	STRING				AS '(*) BYTE DATA',
	TAB					AS '09H',
	TRANSFER$CONTROL	AS '1',
	TRUE				AS '0FFH',
	UNDERBAR			AS '''_''',
	USER$CI				AS '0',
	WRITE$PROTECT$ATTRIBUTE 		AS '2',
	ZERO$BIAS			AS '0';

/*        ENDLIT.INC        */

/* ISIS.INC */
EXIT: PROCEDURE EXTERNAL; END;
WRITE: PROCEDURE (AFTN,BUFFER,COUNT,STATUS) EXTERNAL;
	DECLARE (AFTN,BUFFER,COUNT,STATUS) ADDRESS;	END;

/* END ISIS.INC */

/************************************************************/
/*															*/
/*              LITERALLY'S UNIQUE TO PASSIF                */
/*															*/
/************************************************************/

DECLARE
    MINIMUM$ACCEPTABLE$BANNER$LENGTH 	AS 		'73',
    MAXIMUM$TOKEN$LENGTH				AS		'70',
    BI									AS		'CALL BOMB$IF(STATUS)',

	FIRST$FIELD							AS		'0',
    SECOND$FIELD						AS		'28',
    THIRD$FIELD							AS		'54',

    RIGHT$PARENTHESIS 					AS		''')''',
    LEFT$PARENTHESIS 					AS		'''(''',
    RI									AS		'CALL REPORT$IF',
    UNRECOGNIZED$SWITCH$ERR 			AS		'201',
    QUESTION$MARK						AS		'''?''';


/*	MAIN.INC  */

DECLARE
    ACTUAL ADDRESS EXTERNAL,
    AFTN ADDRESS EXTERNAL,
    COMMAND$TAIL$BUF (250) BYTE EXTERNAL,
    DELIMITER BYTE EXTERNAL,
    FIRST$BLOCK$BUF (128) BYTE EXTERNAL,
    FIRST$OUTPUT$MSG$PTR ADDRESS EXTERNAL,
    FIRST$TIME$THROUGH BOOLEAN EXTERNAL,
    INITIALIZED$BANNER (74) BYTE EXTERNAL,
    PRINT$HASH$MARK BOOLEAN EXTERNAL,
    REPORT$FILE$ACTUAL ADDRESS EXTERNAL,
    REPORT$FILE$AFTN ADDRESS EXTERNAL,
    REPORT$FILE$STRING$BEGINNING ADDRESS EXTERNAL,
    SECOND$OUTPUT$MSG$PTR ADDRESS EXTERNAL,
    STATUS ADDRESS EXTERNAL,
    TMP$FILE$AFTN ADDRESS EXTERNAL,
    TMP$FILE$NAME (15) BYTE EXTERNAL,
    TOK$BUF (80) BYTE EXTERNAL;

DECLARE
    KEY$WORDS (10) STRUCTURE
     (LENGTH       BYTE,
      KEY$WORD(13)	BYTE,
      PROC$PTR	ADDRESS) EXTERNAL;

MOVE: PROCEDURE (COUNT,SOURCE$PTR,DEST$PTR) EXTERNAL;
	DECLARE (COUNT,SOURCE$PTR,DEST$PTR) ADDRESS; END;

/*	END MAIN.INC  */

/*	TOKENS.INC  */

GET$ARGUMENT: PROCEDURE (BUF$PTR,STATUS$PTR) BYTE EXTERNAL;
	DECLARE (BUF$PTR,STATUS$PTR) ADDRESS; END;

/*	END TOKENS.INC  */

/*	ERRMSG.INC  */

DECLARE
	BAD$SYNTAX$MSG 				(29)	BYTE	EXTERNAL,
	BOMB$IF$MSG$1    			(12)	BYTE	EXTERNAL,
	BOMB$IF$MSG$2				(40)	BYTE	EXTERNAL,
    DURING$ASSERTION$CHECK$MSG	(50)	BYTE	EXTERNAL,
    PASSIF$INVOKED$BY$MSG       (19)    BYTE    EXTERNAL,
    ZERO$LENGTH$FILE$MSG 		(40)	BYTE	EXTERNAL;

/*	END ERRMSG.INC  */

/*	REPORT.INC  */

REPORT$SYNTAX$ERROR: PROCEDURE EXTERNAL; END;
REPORT$ASSERTION$FAILURE$W$ISIS$ERR: PROCEDURE (STATUS) EXTERNAL;
	DECLARE STATUS ADDRESS; END;

/*	END REPORT.INC  */

$ LIST

$ EJECT

/************************************************************/
/*															*/
/*                        NOTES                             */
/*															*/
/************************************************************/

ENFORCE$DELIMITER:
	PROCEDURE(ENFORCEE) PUBLIC;
	DECLARE ENFORCEE BYTE;
    IF NOT DELIMITER=ENFORCEE THEN
		CALL REPORT$SYNTAX$ERROR;
	ENDIF
	END
ENFORCE$DELIMITER;

UDI$STRING$MATCH:
	PROCEDURE (STG$1$PTR,STG$2$PTR) BOOLEAN PUBLIC;

	/*	This procedure ascertains whether two UDI-type strings match. */

    DECLARE S BYTE;
    DECLARE (STG$1$PTR,STG$2$PTR) ADDRESS,
              STG$1		BASED STG$1$PTR			(100)		BYTE,
              STG$2		BASED STG$2$PTR			(100)		BYTE;

    DECLARE (STG$1$COUNT,STG$2$COUNT) BYTE;

	STG$1$COUNT = STG$1(0);
    STG$2$COUNT = STG$2(0);

    IF STG$1$COUNT <> STG$2$COUNT THEN
    	RETURN FALSE;
    ELSE
    	DO S=1 TO STG$1$COUNT;
			IF STG$1(S) <> STG$2(S) THEN
				RETURN FALSE;
			ENDIF
    	END$ITERATED$DO;
    ENDIF

    RETURN TRUE;
	END
UDI$STRING$MATCH;

$ EJECT

/************************************************************/
/*															*/
/*                      NEXT$ARG                            */
/*															*/
/************************************************************/

/*	The following variable will be equal to the number of bytes in
	command$tail$buf. */
DECLARE BUF$COUNT BYTE PUBLIC INITIAL (0);
DECLARE SINGLE$CHAR$UDI$STG (2) BYTE INITIAL (1,HASH$MARK);

NEXT$ARG:
	PROCEDURE PUBLIC;

	DECLARE BYTES$LEFT BYTE;

$ EJECT

    /************************************************************/
    /*														    */
    /*              PROCEDURES LOCAL TO  NEXT$ARG               */
    /*															*/
    /************************************************************/

    STUFF$COMMAND$TAIL$BUF$W$UDI$STG:
		PROCEDURE (UDI$STG$PTR);

        DECLARE UDI$STG$PTR ADDRESS,
        		UDI$STG BASED UDI$STG$PTR (100) BYTE;

        BYTES$LEFT = SIZE(COMMAND$TAIL$BUF) - BUF$COUNT;
        IF UDI$STG(0)<=BYTES$LEFT THEN
            DO;
                /*	Move data into command tail buffer. */
                CALL MOVE(/*count*/				UDI$STG(0),
                          /*source*/			.UDI$STG(1),
                          /*destination*/		.COMMAND$TAIL$BUF(BUF$COUNT));
                BUF$COUNT = BUF$COUNT + UDI$STG(0);
            ENDDO;
        ELSE
            DO;
                /*	Error condition  --  command tail buffer overflow. */
                CALL MOVE(/*count*/				BYTES$LEFT,
                          /*source*/			.UDI$STG(1),
                          /*destination*/		.COMMAND$TAIL$BUF(BUF$COUNT));
                BUF$COUNT = BUF$COUNT + BYTES$LEFT;
                CALL REPORT$SYNTAX$ERROR;
            ENDDO;
        ENDIF
    	END
    STUFF$COMMAND$TAIL$BUF$W$UDI$STG;

    ADD$CHAR$TO$ARG:
    	PROCEDURE (ADDEE);
		DECLARE ADDEE BYTE;
        SINGLE$CHAR$UDI$STG (1) = ADDEE;
		CALL STUFF$COMMAND$TAIL$BUF$W$UDI$STG(.SINGLE$CHAR$UDI$STG);
        END
    ADD$CHAR$TO$ARG;

$ EJECT

    /************************************************************/
    /*														    */
    /*         FIRST EXECUTABLE IN PROCEDURE NEXT$ARG           */
    /*															*/
    /************************************************************/

    /*	First, get the argument. */
    DELIMITER = GET$ARGUMENT(.TOK$BUF,.STATUS);

	/*	Set the byte following the last byte of the string to 0
		so that, when the token consists of an isis filename, it
		will be delimited. */
    TOK$BUF(TOK$BUF(0)+1) = 0;

    /*	Don't check status yet.  Wait until whatever string
		was returned has been moved in the argument buffer,
		so that a more complete error message is returned. */

    /*	Move the string to the command tail buffer. */
    CALL STUFF$COMMAND$TAIL$BUF$W$UDI$STG(.TOK$BUF);

    /*	Move the delimiter into the token buffer. */
    CALL ADD$CHAR$TO$ARG(DELIMITER);

    /*	Append a line-feed, if necessary. */
    IF DELIMITER = CR THEN
    	CALL ADD$CHAR$TO$ARG(LF);
    ENDIF

    IF STATUS<>0 THEN
		CALL REPORT$SYNTAX$ERROR;
	ENDIF

    END
NEXT$ARG;

$ EJECT

/************************************************************/
/*															*/
/*                INTERPRET$COMMAND$LINE                    */
/*															*/
/************************************************************/

DECLARE THE$STRING INIT$STG (1,BLANK);

INTERPRET$COMMAND$LINE:
	PROCEDURE PUBLIC;

	DECLARE INDEX BYTE;
    DECLARE SIGN$ON$MSG STRING
$IF XVERSION
    	('ISIS-II ASSERTION CHECKING UTILITY, X111',CR,LF);
$ELSE
    	('ISIS-II ASSERTION CHECKING UTILITY, V1.2',CR,LF);
$ENDIF

    SHOULDNT$HAVE$GOTTEN$THIS$FAR:
    	PROCEDURE;
        STATUS = UNRECOGNIZED$SWITCH$ERR;
        CALL REPORT$ASSERTION$FAILURE$W$ISIS$ERR(STATUS);
    	END
    SHOULDNT$HAVE$GOTTEN$THIS$FAR;

	UDI$CHAR:
		PROCEDURE (A$CHAR) ADDRESS;
        DECLARE A$CHAR BYTE;
		THE$STRING(1) = A$CHAR;
		RETURN (.THE$STRING);
		END
    UDI$CHAR;

    SIGN$ON$AND$EXIT:
		PROCEDURE;
        CALL WRITE(CONSOLE$OUTPUT,.SIGN$ON$MSG,SIZE(SIGN$ON$MSG),.STATUS);
        CALL EXIT;
		END
    SIGN$ON$AND$EXIT;

$ EJECT

    /************************************************************/
    /*															*/
    /*       FIRST EXECUTABLE IN INTERPRET$COMMAND$LINE         */
    /*															*/
    /************************************************************/

	/*	The first call to next$arg should return the name of the
		load module, which normally will be PASSIF.  The delimiter
		returned by this first call should be a blank.

		A legal exception to the above rule is if the PASSIF delimiter
		is a question mark. */

    CALL NEXT$ARG;
    IF DELIMITER=QUESTION$MARK OR delimiter=CR THEN
    	CALL SIGN$ON$AND$EXIT;
    ELSE
        CALL ENFORCE$DELIMITER(BLANK);
    ENDIF

    /*	This next call to next$arg should pick up a Passif keyword,
    	which will tell Passif what assertion checking function it is
    	to perform.  It is legal, however, for the next token to be
    	a question mark.  If it is, then Passif prints an identification
    	message and exits. */
    CALL NEXT$ARG;

    IF UDI$STRING$MATCH (UDI$CHAR(QUESTION$MARK),.TOK$BUF(0)) THEN
    	CALL SIGN$ON$AND$EXIT;
    ENDIF

    /*	All legal Passif command tails must have the first keyword
    	delimited by a parenthesis. */
    CALL ENFORCE$DELIMITER(LEFT$PARENTHESIS);

    DO INDEX=0 TO LAST(KEY$WORDS);
        IF UDI$STRING$MATCH(.TOK$BUF(0),.KEY$WORDS(INDEX).LENGTH) THEN
            DO;
                DECLARE AN$ADDRESS$SCALAR ADDRESS;
                AN$ADDRESS$SCALAR = KEY$WORDS(INDEX).PROC$PTR;
        		CALL AN$ADDRESS$SCALAR;
            ENDDO;
        ENDIF
    END$ITERATED$DO;

    /*	If any of the keywords matched, and the procedure was called, then
    	the program wouldn't have gotten this far, so the token in the
        command tail must not have matched any of the keywords. So. . .*/
    CALL SHOULDNT$HAVE$GOTTEN$THIS$FAR;

	END
INTERPRET$COMMAND$LINE;

END
CLI$MOD;
src/cmovem.plm
$TITLE('==>  C M O V E M  <==  CHKLOD')

CMOVEM:
DO;

/************************************************************************/
/*																		*/
/*     'Copyright 1981,1983 Intel Corporation'.  All rights reserved.	*/
/*      No part of this program or publication may be reproduced,		*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

movem: PROCEDURE (count,src,dst) PUBLIC;
  DECLARE (count,src,dst) ADDRESS;

  IF count <> 0 THEN
    CALL move (count, src, dst);
END movem;

END;
src/compar.plm
COMPAR: DO;

/************************************************************************/
/*																		*/
/*     'Copyright 1981,1983 Intel Corporation'.  All rights reserved.	*/
/*      No part of this program or publication may be reproduced,		*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

$IF XVERSION
DECLARE PROPRIETARY(*) BYTE DATA ('INTEL PROPRIETARY SOFTWARE');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=X103',0);
$ELSE
DECLARE COPYRIGHT (*) BYTE DATA  ('COPYRIGHT 1981,1983 INTEL ');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.1',0);
$ENDIF

    

/*  SOURCE COMPARE PROGRAM */
/* COMMAND SYNTAX: COMPAR <FILE1> TO <FILE2> [PRINT( <OUTFILE>)] &  */
/*                   [ SYNC( <NUMBER>)]                            */

/* EXTERNAL PROCEDURE DECLARATIONS */

MEMCK: PROCEDURE ADDRESS EXTERNAL;
END MEMCK;

CONVND: PROCEDURE(NUMBER,DIGITS) EXTERNAL;
  DECLARE (NUMBER,DIGITS) ADDRESS;
END CONVND;

READ:PROCEDURE(AFTN,BUFFER,LEN,ACTUAL,STATUS)EXTERNAL;
  DECLARE(AFTN,BUFFER,LEN,ACTUAL,STATUS) ADDRESS;
END READ;

EXIT: PROCEDURE EXTERNAL;
END EXIT;

CHECK$STATUS: PROCEDURE EXTERNAL;
END CHECK$STATUS;

COMMAND: PROCEDURE EXTERNAL;
END COMMAND;

DISPLAY: PROCEDURE(LEN,BUFFER) EXTERNAL;
  DECLARE
    LEN BYTE,
    BUFFER ADDRESS;
END DISPLAY;

NEW$LINE: PROCEDURE EXTERNAL;
END NEW$LINE;

BLANKS: PROCEDURE(LEN) EXTERNAL;
  DECLARE LEN BYTE;
END BLANKS;

DUMP: PROCEDURE EXTERNAL;
END DUMP;

/* LOCAL DECLARATIONS */

DECLARE
  SYNCPARM BYTE PUBLIC,
  POINTER LITERALLY 'ADDRESS',    /* WHEN USED AS POINTER */
  INDEX LITERALLY 'ADDRESS',    /* WHEN USED AS INDEX INTO BUFS */
  BOOLEAN LITERALLY 'BYTE',
  TRUE LITERALLY '0FFH',
  FALSE LITERALLY '0',
  CR LITERALLY '0DH',    /* ASCII */
  LF LITERALLY '0AH',    /* ASCII */

  OUT$AFTN ADDRESS PUBLIC,    /* AFTN OF LIST FILE */
  IDENTICAL BOOLEAN,    /* IF FILES COMPLETELY THE SAME */
  ACTUAL ADDRESS EXTERNAL,    /* RETURNED BY ISIS */
  STATUS ADDRESS EXTERNAL,    /* RETURNED BY ISIS */
  BUF$LENGTH ADDRESS,    /* AS LARGE AS POSSIBLE - I.E. (MEMCK-.MEMORY)/4 */

  FILE$NAME$0 (15) BYTE PUBLIC INITIAL('               '),
  FILE$NAME$1 (15) BYTE PUBLIC INITIAL('               '),
  RCD0 BYTE, /* INDEX IN QUEUE0 OF RECORD DESCRIPTOR */
  RCD1 BYTE, /* INDEX IN QUEUE1 OF RECORD DESCRIPTOR */
  NOMATCH BOOLEAN, /* FLAG USED IN SYNCRONIZATION */

  QUEUE0 STRUCTURE(    /* ONE QUEUE FOR EACH INPUT FILE */
                       /* RECORDS OLDEST -> NEXTH-1 ARE IN HASH TABLE */
                       /* RECORDS NEXTH -> NEXT-1 HAVE BEEN SCANNED BUT */
                       /* ARE NOT IN HASH TABLE.  NOTE THAT THE QUEUE WRAPS */
                       /* AROUND MOD 255.  255 = 0FFH IS THE NULL ADDRESS */
    OLDEST BYTE, /* OLDEST RECORD IN HASH TABLE */
    HCOUNT BYTE, /* NUMBER OF RECORDS IN HASH TABLE */
    NEXTH BYTE,  /* NEXT RECORD TO BE PLACED IN HASH TABLE */
    UCOUNT BYTE, /* NUMBER OF UNHASHED RECORDS IN QUEUE */
    NEXT BYTE,   /* NEXT AVAILABLE SLOT IN QUEUE */
    RECNUM ADDRESS, /* RECORD NUMBER OF OLDEST IN QUEUE */
    BUFA ADDRESS, /* ADDRESS OF BUFFER DESCRIPTOR FOR FILE USING */
                  /* USING THIS QUEUE */
    AFTN ADDRESS, /* AFTN OF FILE USING THIS QUEUE */

    /* THE FOLLOWING IDENTIFIERS REFER TO INDIVIDUAL RECORDS */

    ADDR(255) ADDRESS, /* ADDRESS OF INDIVIDUAL RECORD */
    LEN(255) BYTE, /* LENGTH OF RECCORD */
    CYCLE(255) BYTE, /* HASH ADDRESS OF RECORD */
    HLINK(255) BYTE, /* LINK FOR THE HASH TABLE BUCKETS */

    /* THE FOLLOWING ARRAY IS THE HASH TABLE, STORING UNMATCHED RECORDS */

    HTABLE(256) BYTE
    ),
  QUEUE1 STRUCTURE(    /* ONE QUEUE FOR EACH INPUT FILE */
                       /* RECORDS OLDEST -> NEXTH-1 ARE IN HASH TABLE */
                       /* RECORDS NEXTH -> NEXT-1 HAVE BEEN SCANNED BUT */
                       /* ARE NOT IN HASH TABLE.  NOTE THAT THE QUEUE WRAPS */
                       /* AROUND MOD 255.  255 = 0FFH IS THE NULL ADDRESS */
    OLDEST BYTE, /* OLDEST RECORD IN HASH TABLE */
    HCOUNT BYTE, /* NUMBER OF RECORDS IN HASH TABLE */
    NEXTH BYTE,  /* NEXT RECORD TO BE PLACED IN HASH TABLE */
    UCOUNT BYTE, /* NUMBER OF UNHASHED RECORDS IN QUEUE */
    NEXT BYTE,   /* NEXT AVAILABLE SLOT IN QUEUE */
    RECNUM ADDRESS, /* RECORD NUMBER OF OLDEST IN QUEUE */
    BUFA ADDRESS, /* ADDRESS OF BUFFER DESCRIPTOR FOR FILE USING */
                  /* USING THIS QUEUE */
    AFTN ADDRESS, /* AFTN OF FILE USING THIS QUEUE */

    /* THE FOLLOWING IDENTIFIERS REFER TO INDIVIDUAL RECORDS */

    ADDR(255) ADDRESS, /* ADDRESS OF INDIVIDUAL RECORD */
    LEN(255) BYTE, /* LENGTH OF RECCORD */
    CYCLE(255) BYTE, /* HASH ADDRESS OF RECORD */
    HLINK(255) BYTE, /* LINK FOR THE HASH TABLE BUCKETS */

    /* THE FOLLOWING ARRAY IS THE HASH TABLE, STORING UNMATCHED RECORDS */

    HTABLE(256) BYTE
    ),

  BUF$DSPTR(4) STRUCTURE (
    LOW$ADDR ADDRESS, /* ADDRESS OF BUFFER */
    HIGH$ADDR ADDRESS, /* HIGHEST ADDRESS IN BUFFER */
    NEXT$DSPTR ADDRESS, /* ADDRESS OF DSPTR OF FOLLOWING BUFFFER */
    PTR ADDRESS, /* CURRENT SCANNING POSITION */
    EOD ADDRESS /* END OF DATA IN BUFFER, NOT NECESSARILY END OF FILE */
    ),
  AFTN0 ADDRESS PUBLIC AT(.QUEUE0.AFTN), /* TO COMMUNICATE WITH COMMAND */
  AFTN1 ADDRESS PUBLIC AT(.QUEUE1.AFTN);

SPACEFAIL: PROCEDURE;

  /* CALLED WHEN THE PROGRAM RUNS OUT OF BUFFER OR QUEUE SPACE */

  CALL DISPLAY(45,.('***** NOT ENOUGH SPACE TO SYNCHRONIZE *****',CR,LF));
  CALL DUMP;
  CALL EXIT;

END SPACEFAIL;

HASH$INSERT: PROCEDURE(QA);

  /* PROCEDURE TO INSERT THE LAST RECORD RETURNED BY READRECORD */
  /* INTO THE HASH TABLE */

  DECLARE
    QA ADDRESS, /* POINTER TO BASE THE QUEUE */
    Q BASED QA STRUCTURE( /* THE LOCAL COPY OF THE QUEUE */
                       /* RECORDS OLDEST -> NEXTH-1 ARE IN HASH TABLE */
                       /* RECORDS NEXTH -> NEXT-1 HAVE BEEN SCANNED BUT */
                       /* ARE NOT IN HASH TABLE.  NOTE THAT THE QUEUE WRAPS */
                       /* AROUND MOD 255.  255 = 0FFH IS THE NULL ADDRESS */
      OLDEST BYTE, /* OLDEST RECORD IN HASH TABLE */
      HCOUNT BYTE, /* NUMBER OF RECORDS IN HASH TABLE */
      NEXTH BYTE,  /* NEXT RECORD TO BE PLACED IN HASH TABLE */
      UCOUNT BYTE, /* NUMBER OF UNHASHED RECORDS IN QUEUE */
      NEXT BYTE,   /* NEXT AVAILABLE SLOT IN QUEUE */
      RECNUM ADDRESS, /* RECORD NUMBER OF OLDEST IN QUEUE */
      BUFA ADDRESS, /* ADDRESS OF BUFFER DESCRIPTOR FOR FILE USING */
                    /* USING THIS QUEUE */
      AFTN ADDRESS, /* AFTN OF FILE USING THIS QUEUE */

      /* THE FOLLOWING IDENTIFIERS REFER TO INDIVIDUAL RECORDS */

      ADDR(255) ADDRESS, /* ADDRESS OF INDIVIDUAL RECORD */
      LEN(255) BYTE, /* LENGTH OF RECCORD */
      CYCLE(255) BYTE, /* HASH ADDRESS OF RECORD */
      HLINK(255) BYTE, /* LINK FOR THE HASH TABLE BUCKETS */

      /* THE FOLLOWING ARRAY IS THE HASH TABLE, STORING UNMATCHED RECORDS */

      HTABLE(256) BYTE
      ),
    RCD BYTE, /* RECORD TO BE PLACED IN HASH TABLE */
    CYCLE BYTE; /* HASH ADDRESS OF RCD */

  /* INCREMENT NEXTH */
  IF (RCD := Q.NEXTH) = 0FEH
  THEN Q.NEXTH = 0;
  ELSE Q.NEXTH = RCD + 1;

  /* REMOVE RECORD FROM READ SECTION OF QUEUE */
  Q.UCOUNT = Q.UCOUNT - 1;
  Q.HCOUNT = Q.HCOUNT + 1;

  CYCLE = Q.CYCLE(RCD);
  /* ADD RCD TO HTABLE(CYCLE)'S BUCKET */
  Q.HLINK(RCD) = Q.HTABLE(CYCLE);
  Q.HTABLE(CYCLE) = RCD;

END HASH$INSERT;

READRECORD: PROCEDURE(QA) BYTE;

/* THIS PROCEDURE RETURNS THE INDEX OF THE DESCRIPTOR IN THE QUEUE(FILE) */
/* OF THE NEXT RECORD */

  DECLARE
    QA ADDRESS, /* POINTER TO Q */
    Q BASED QA STRUCTURE ( /* THIS IS THE LOCAL VERSION OF QUEUE IN MAIN DO */
                           /* ONE QUEUE FOR EACH INPUT FILE */
                           /* RECORDS OLDEST -> NEXTH-1 ARE IN HASH TABLE */
                           /* RECORDS NEXTH -> NEXT-1 HAVE BEEN SCANNED BUT */
                        /* ARE NOT IN HASH TABLE.  NOTE THAT THE QUEUE WRAPS */
                        /* AROUND MOD 255.  255 = 0FFH IS THE NULL ADDRESS */
    OLDEST BYTE, /* OLDEST RECORD IN HASH TABLE */
    HCOUNT BYTE, /* NUMBER OF RECORDS IN HASH TABLE */
    NEXTH BYTE,  /* NEXT RECORD TO BE PLACED IN HASH TABLE */
    UCOUNT BYTE, /* NUMBER OF UNHASHED RECORDS IN QUEUE */
    NEXT BYTE,   /* NEXT AVAILABLE SLOT IN QUEUE */
    RECNUM ADDRESS, /* RECORD NUMBER OF OLDEST IN QUEUE */
    BUFA ADDRESS, /* ADDRESS OF BUFFER DESCRIPTOR FOR FILE USING */
                  /* USING THIS QUEUE */
    AFTN ADDRESS, /* AFTN OF FILE USING THIS QUEUE */

    /* THE FOLLOWING IDENTIFIERS REFER TO INDIVIDUAL RECORDS */

    ADDR(255) ADDRESS, /* ADDRESS OF INDIVIDUAL RECORD */
    LEN(255) BYTE, /* LENGTH OF RECCORD */
    CYCLE(255) BYTE, /* HASH ADDRESS OF RECORD */
    HLINK(255) BYTE, /* LINK FOR THE HASH TABLE BUCKETS */

    /* THE FOLLOWING ARRAY IS THE HASH TABLE, STORING UNMATCHED RECORDS */

    HTABLE(256) BYTE
    ),
   BUFA ADDRESS, /* ADDRESS OF BUFFER DESCRIPTOR */
    BUF BASED BUFA STRUCTURE( /* LOCAL COPY OF BUF$DSPTR */
      LOW$ADDR ADDRESS,
      HIGH$ADDR ADDRESS,
      NEXT$DSPTR ADDRESS,
      PTR ADDRESS,
      EOD ADDRESS),
    NEWBUFA ADDRESS, /* ADDRESS OF NEW BUFFER DESCRIPTOR */
    NEWBUF BASED NEWBUFA STRUCTURE( /* ANOTHER LOCAL COPY OF BUF$DSPTR */
      LOW$ADDR ADDRESS,
      HIGH$ADDR ADDRESS,
      NEXT$DSPTR ADDRESS,
      PTR ADDRESS,
      EOD ADDRESS),
    PTR ADDRESS, /* CURSOR POSITION FOR BUFFER SCAN */
    CHAR BASED PTR BYTE, /* CHARACTER IN INPUT BUFFER */
    EOD ADDRESS, /* END OF DATA IN BUFFER, NOT NECESSARILY END OF FILE */
    LEN BYTE, /* LENGTH OF RECORD */
    CYCLE BYTE, /* TO BE USED AS HASH ADDRESS, XOR OF BYTES OF RECORD */
    RCD BYTE; /* RECORD BEING RETURNED */
  IF /* THERE ARE RECORDS WAITING IN STORAGE */ Q.UCOUNT<>0
  THEN RETURN( Q.NEXTH );

  IF /* THERE IS NO ROOM IN THE QUEUE */ Q.HCOUNT = 0FFH
  THEN CALL SPACEFAIL;

  /* SCAN BUFFER */
  RCD = Q.NEXTH;
  BUFA = Q.BUFA;
  PTR = BUF.PTR;
  LEN = 0FFH; /* -1 */
  CYCLE = 0;
  EOD = BUF.EOD;
  DO WHILE PTR = EOD; /* NO MORE DATA IN BUFFER */
    IF EOD <= BUF.HIGH$ADDR /* TRUE END OF FILE */
    THEN RETURN(0FFH);
    /* READ IN SOME DATA */
    Q.BUFA = ( BUFA := BUF.NEXT$DSPTR );
    /* IF BUF NOT EMPTY ABORT */
    IF Q.HCOUNT <> 0
    THEN IF Q.ADDR(Q.OLDEST) >= BUF.LOW$ADDR
            AND Q.ADDR(Q.OLDEST) <= BUF.HIGH$ADDR
         THEN CALL SPACEFAIL;
    PTR = ( BUF.PTR := BUF.LOW$ADDR );
    CALL READ(Q.AFTN,PTR,BUF$LENGTH,.ACTUAL,.STATUS);
    CALL CHECK$STATUS;
    EOD = (BUF.EOD := PTR + ACTUAL);
  END;

  /* INCREMENT NEXT MOD 255 */
  IF Q.NEXT = 0FEH
  THEN Q.NEXT = 0;
  ELSE Q.NEXT = Q.NEXT + 1;
  Q.UCOUNT = 1;

  DO WHILE CHAR <> LF;
    LEN = LEN + 1;
    CYCLE = CYCLE XOR CHAR;
    PTR = PTR + 1;
    DO WHILE PTR = EOD; /* RUN OFF DATA IN BUFFER */
      IF PTR <= BUF.HIGH$ADDR /* END OF FILE */
      THEN DO;
        Q.ADDR(RCD) = BUF.PTR;
        BUF.PTR = PTR;
        PTR = PTR - 1;
        IF CHAR = CR
        THEN DO;
          Q.CYCLE(RCD) = CYCLE;
          Q.LEN(RCD) = LEN;
          END;
        ELSE DO;
          Q.CYCLE(RCD) = CYCLE XOR CR;
          Q.LEN(RCD) = LEN + 1;
          END;
        RETURN(RCD);
      END;
      NEWBUFA = BUF.NEXT$DSPTR;
      /* IF NEWBUF NOT EMPTY THEN ABORT */
      IF Q.HCOUNT <> 0
      THEN IF Q.ADDR(Q.OLDEST) >= NEWBUF.LOW$ADDR
              AND Q.ADDR(Q.OLDEST) <= NEWBUF.HIGH$ADDR
           THEN CALL SPACEFAIL;
      /* MOVE RECORD INTO NEWBUF */
      CALL MOVE(LEN+1,BUF.PTR,NEWBUF.LOW$ADDR);
      Q.BUFA  = ( BUFA := NEWBUFA );
      PTR  = (BUF.PTR := BUF.LOW$ADDR) + LEN + 1;
      CALL READ(Q.AFTN,PTR,BUF$LENGTH-LEN-1,.ACTUAL,.STATUS);
      CALL CHECK$STATUS;
      EOD = (BUF.EOD := PTR + ACTUAL);
    END;
  END;
  Q.ADDR(RCD) = BUF.PTR;
  BUF.PTR = PTR + 1;
  IF LEN = -1 /* ADJUST LENGTH FOR MISSING CARRIAGE RETURN */
  THEN Q.LEN(RCD) = 0;
  ELSE Q.LEN(RCD) = LEN;
  Q.CYCLE(RCD) = CYCLE;
  RETURN(RCD);
END READRECORD;

INITILIZE: PROCEDURE;

/* INITILIZE QUEUES, BUFFERS, AND HASH TABLES */

  DECLARE
    PLACE ADDRESS, /* USED FOR COMPUTING BUFFER ADDRESSES */
    I BYTE; /* LOOP INDEX */

  PLACE = .MEMORY + 2048;
  BUF$LENGTH = (MEMCK - PLACE)/4;

  DO I = 0 TO 3;
    BUF$DSPTR(I).LOW$ADDR = PLACE;
    PLACE = PLACE + BUF$LENGTH;
    BUF$DSPTR(I).PTR, BUF$DSPTR(I).EOD = PLACE;
    BUF$DSPTR(I).HIGH$ADDR = PLACE - 1;
  END;

  DO I = 0 TO 0FFH;
    QUEUE0.HTABLE(I) = 0FFH;
    QUEUE1.HTABLE(I) = 0FFH;
  END;

  QUEUE0.RECNUM, QUEUE1.RECNUM = 1;
  QUEUE0.OLDEST, QUEUE1.OLDEST, QUEUE0.HCOUNT, QUEUE1.HCOUNT, QUEUE0.NEXTH,
  QUEUE1.NEXTH, QUEUE0.UCOUNT, QUEUE1.UCOUNT, QUEUE0.NEXT, QUEUE1.NEXT = 0;

  BUF$DSPTR(0).NEXT$DSPTR, QUEUE0.BUFA = .BUF$DSPTR(1);
  BUF$DSPTR(1).NEXT$DSPTR = .BUF$DSPTR(0);
  BUF$DSPTR(2).NEXT$DSPTR, QUEUE1.BUFA = .BUF$DSPTR(3);
  BUF$DSPTR(3).NEXT$DSPTR = .BUF$DSPTR(2);

END INITILIZE;

PRINT: PROCEDURE(QA,PREFIX,DISP);

/* PRINT OUT THE RECORDS IN THE QUEUE UPTO RCD */
/* DELETE THESE RECORDS AND ALSO WIPE OUT THE HASH TABLE */

  DECLARE
    RCD BYTE, /* RECORD WHICH HAS BEEN MATCHED */
    QA ADDRESS, /* BASE FOR Q BELOW */
    Q BASED QA STRUCTURE( /* LOCAL COPY OF THE QUEUE */
                       /* RECORDS OLDEST -> NEXTH-1 ARE IN HASH TABLE */
                       /* RECORDS NEXTH -> NEXT-1 HAVE BEEN SCANNED BUT */
                       /* ARE NOT IN HASH TABLE.  NOTE THAT THE QUEUE WRAPS */
                       /* AROUND MOD 255.  255 = 0FFH IS THE NULL ADDRESS */
    OLDEST BYTE, /* OLDEST RECORD IN HASH TABLE */
    HCOUNT BYTE, /* NUMBER OF RECORDS IN HASH TABLE */
    NEXTH BYTE,  /* NEXT RECORD TO BE PLACED IN HASH TABLE */
    UCOUNT BYTE, /* NUMBER OF UNHASHED RECORDS IN QUEUE */
    NEXT BYTE,   /* NEXT AVAILABLE SLOT IN QUEUE */
    RECNUM ADDRESS, /* RECORD NUMBER OF OLDEST IN QUEUE */
    BUFA ADDRESS, /* ADDRESS OF BUFFER DESCRIPTOR FOR FILE USING */
                  /* USING THIS QUEUE */
    AFTN ADDRESS, /* AFTN OF FILE USING THIS QUEUE */

    /* THE FOLLOWING IDENTIFIERS REFER TO INDIVIDUAL RECORDS */

    ADDR(255) ADDRESS, /* ADDRESS OF INDIVIDUAL RECORD */
    LEN(255) BYTE, /* LENGTH OF RECCORD */
    CYCLE(255) BYTE, /* HASH ADDRESS OF RECORD */
    HLINK(255) BYTE, /* LINK FOR THE HASH TABLE BUCKETS */

    /* THE FOLLOWING ARRAY IS THE HASH TABLE, STORING UNMATCHED RECORDS */

    HTABLE(256) BYTE
    ),
    COUNT BYTE, /* COUNT OF MISMATCHED RECORDS PRINTED */
    PLACE BYTE, /* INDEX INTO QUEUE */
    DIGITS(6) BYTE, /* STORAGE FOR THE DIGITS OF Q.RECNUM */
    PREFIX ADDRESS, /* BASE FOR '#1:' OR '#2:' */
    FIRSTCH BASED PREFIX BYTE, /* FIRST CHARACTER OF PREFIX */
    DISP BYTE; /* POSITION OF FIRST MISMATCHED CHARACTER IN FIRST RECORD */

  PRINTLINE: PROCEDURE;
    CALL DISPLAY(3,PREFIX);
    CALL CONVND(Q.RECNUM,.DIGITS);
    CALL DISPLAY(6,.DIGITS);
    CALL DISPLAY(Q.LEN(PLACE),Q.ADDR(PLACE));
    CALL NEW$LINE;
    IF COUNT = 0
    THEN DO; /* PRINT OUT UP ARROW MARKING FIRST MISMATCHING CHARACTER */
      CALL BLANKS(DISP + 9);
      CALL DISPLAY(1, .('^'));
      CALL NEWLINE;
    END;
    IF PLACE = 0FEH
    THEN PLACE = 0;
    ELSE PLACE = PLACE + 1;
  END PRINTLINE;

  PLACE = Q.OLDEST;
  RCD = Q.NEXTH;
  COUNT = 0;
  IF RCD <> PLACE /* NO MISMATCHED LINES */
  THEN DO;
    FIRSTCH = '#';
    CALL PRINTLINE; /* PRINT FIRST LINE */
    Q.RECNUM = Q.RECNUM + 1;
    COUNT = 1;
    FIRSTCH = ' ';
    DO WHILE PLACE <> RCD; /* PRINT SUBSEQUENT MISMATCHED LINES */
      CALL PRINTLINE;
      Q.RECNUM = Q.RECNUM + 1;
      COUNT = COUNT + 1;
    END;
  END;
  FIRSTCH = '='; /* PRINT FIRST SYNC LINE */
  CALL PRINTLINE;

  /* DELETE PRINTED RECORDS FROM QUEUE */
  Q.UCOUNT = Q.UCOUNT + Q.HCOUNT - COUNT;
  Q.HCOUNT = 0;
  Q.OLDEST = Q.NEXTH;

  /* ZAP OUT HASH TABLE */
  DO PLACE = 0 TO 0FFH;
    Q.HTABLE(PLACE) = 0FFH;
  END;

END PRINT;

CLEANUP: PROCEDURE;

/* PROCEDURE TO PRINT OUT UNMATCHED RECORDS.  THE UNMATCHED RECORDS */
/* ARE DELETED FROM THE QUEUES IN THE PROCESS */

  DECLARE
    DIGITS(6) BYTE, /* DIGITS OF RECORD NUMBER FOR PRINTING */
    DISP BYTE, /* POSITION OF FIRST MISMATCHED CHARACTER OF :/
               /* OF FIRST LINE */
    LINE0A ADDRESS, /* BASE FOR LINE0 */
    LINE1A ADDRESS, /* BASE FOR LINE1 */
    LINE0 BASED LINE0A(1) BYTE, /* FIRST MISMATCHED LINE IN QUEUE0 */
    LINE1 BASED LINE1A(1) BYTE; /* FIRST MISMATCHED LINE IN QUEUE1 */

  /* FIND FIRST MISMATCHED CHARACTER OF FIRST LINES */
  DISP = 0;
  LINE0A = QUEUE0.ADDR(QUEUE0.OLDEST);
  LINE1A = QUEUE1.ADDR(QUEUE1.OLDEST);
  DO WHILE LINE0(DISP) = LINE1(DISP);
    DISP = DISP + 1;
  END;
  CALL DISPLAY(34,.('########## MISMATCH AT RECORD NO. '));
  CALL CONVND(QUEUE0.RECNUM,.DIGITS);
  CALL DISPLAY(5,.DIGITS);
  CALL DISPLAY(8,.(' FILE1: '));
  CALL DISPLAY(15,.FILE$NAME$0);
  CALL NEWLINE;
  CALL DISPLAY(34,.('##########          AT RECORD NO. '));
  CALL CONVND(QUEUE1.RECNUM,.DIGITS);
  CALL DISPLAY(5,.DIGITS);
  CALL DISPLAY(8,.(' FILE2: '));
  CALL DISPLAY(15,.FILE$NAME$1);
  CALL NEWLINE;
  CALL NEWLINE;
  CALL PRINT(.QUEUE0,.('#1:'),DISP);
  CALL DISPLAY(75,.(CR,LF,
'----------------------------------------------------------------------',
CR,LF,LF));
  CALL PRINT(.QUEUE1,.('#2:'),DISP);
  CALL DISPLAY(75,.(CR,LF,
'======================================================================',
CR,LF,LF));

CALL DUMP;

IDENTICAL = FALSE; /* FOR FINAL MESSAGE */

END CLEANUP;

FINISH: PROCEDURE(QA);

/* PROCEDURE TO FINIISH UP READING A FILE */
/* WHEN ALL OTHER PROCESSING IS DONE */

  DECLARE
    QA ADDRESS, /* BASE FOR QUEUE */
    Q BASED QA STRUCTURE( /* LOCAL COPY OF THE QUEUE */
                       /* RECORDS OLDEST -> NEXTH-1 ARE IN HASH TABLE */
                       /* RECORDS NEXTH -> NEXT-1 HAVE BEEN SCANNED BUT */
                       /* ARE NOT IN HASH TABLE.  NOTE THAT THE QUEUE WRAPS */
                       /* AROUND MOD 255.  255 = 0FFH IS THE NULL ADDRESS */
    OLDEST BYTE, /* OLDEST RECORD IN HASH TABLE */
    HCOUNT BYTE, /* NUMBER OF RECORDS IN HASH TABLE */
    NEXTH BYTE,  /* NEXT RECORD TO BE PLACED IN HASH TABLE */
    UCOUNT BYTE, /* NUMBER OF UNHASHED RECORDS IN QUEUE */
    NEXT BYTE,   /* NEXT AVAILABLE SLOT IN QUEUE */
    RECNUM ADDRESS, /* RECORD NUMBER OF OLDEST IN QUEUE */
    BUFA ADDRESS, /* ADDRESS OF BUFFER DESCRIPTOR FOR FILE USING */
                  /* USING THIS QUEUE */
    AFTN ADDRESS, /* AFTN OF FILE USING THIS QUEUE */

    /* THE FOLLOWING IDENTIFIERS REFER TO INDIVIDUAL RECORDS */

    ADDR(255) ADDRESS, /* ADDRESS OF INDIVIDUAL RECORD */
    LEN(255) BYTE, /* LENGTH OF RECCORD */
    CYCLE(255) BYTE, /* HASH ADDRESS OF RECORD */
    HLINK(255) BYTE, /* LINK FOR THE HASH TABLE BUCKETS */

    /* THE FOLLOWING ARRAY IS THE HASH TABLE, STORING UNMATCHED RECORDS */

    HTABLE(256) BYTE
    ),
    RCD BYTE; /* RECORD TO BE READ IN */

  /* CLEAR READ PORTION OF QUEUE */
  Q.HCOUNT = Q.HCOUNT + Q.UCOUNT;
  Q.UCOUNT = 0;
  Q.NEXTH = Q.NEXT;

  /* READ REST OF FILE */
  RCD = READRECORD(QA);
  DO WHILE RCD <> 0FFH AND Q.HCOUNT <> 0FFH;
    Q.UCOUNT = 0;
    Q.HCOUNT = Q.HCOUNT + 1;
    Q.NEXTH = Q.NEXT;
    RCD = READRECORD(QA);
  END;

  IF Q.HCOUNT = 0FFH THEN CALL SPACEFAIL;

  /* SEE TO IT THAT FINAL MATCH READS '^Z' */
  Q.ADDR(Q.NEXT) = .('^Z');
  Q.LEN(Q.NEXT) = 2;
  Q.NEXTH = Q.NEXT;

END FINISH;

TERMINATE: PROCEDURE;

/* TAKE ALL TERMINAL ACTIONS */
/* COMPLETE READING FILES */
/* SEE THAT ANY UNMATCHED RECORDS ARE PRINTED */
/* PRINT OUT FINAL MESSAGE */

  CALL FINISH(.QUEUE0); /* FINISH READING FILE1 */
  CALL FINISH(.QUEUE1); /* FINISH READING FILE2 */
  IF QUEUE0.HCOUNT <> 0 OR QUEUE1.HCOUNT <> 0
  THEN CALL CLEANUP;

  /* PRINT OUT FINAL MESSAGE */

  IF IDENTICAL
  THEN CALL DISPLAY(20,.(CR,LF,'FILES IDENTICAL',CR,LF,LF));
  ELSE CALL DISPLAY(17,.(CR,LF,'FILES DIFFER',CR,LF,LF));
  CALL DUMP;
  CALL EXIT;

END TERMINATE;

COMPARE: PROCEDURE(RCD0,Q0A,RCD1,Q1A)BYTE;

/* PROCEDURE TO COMPARE TWO RECORD */
/* THE ARGUMENTS ARE RCD0 -> QUEUE0 */
/*                   RCD1 -> QUEUE1 */

  DECLARE
    RCD0 BYTE, /* RECORD NUMBER IN QUEUE0 */
    RCD1 BYTE, /* RECORD NUMBER IN QUEUE1 */
    Q0A ADDRESS, /* POINTER TO Q0 TO BASE STRUCTURE */
    Q0 BASED Q0A STRUCTURE(/* ONE QUEUE FOR EACH INPUT FILE */
                       /* RECORDS OLDEST -> NEXTH-1 ARE IN HASH TABLE */
                       /* RECORDS NEXTH -> NEXT-1 HAVE BEEN SCANNED BUT */
                       /* ARE NOT IN HASH TABLE.  NOTE THAT THE QUEUE WRAPS */
                       /* AROUND MOD 255.  255 = 0FFH IS THE NULL ADDRESS */
    OLDEST BYTE, /* OLDEST RECORD IN HASH TABLE */
    HCOUNT BYTE, /* NUMBER OF RECORDS IN HASH TABLE */
    NEXTH BYTE,  /* NEXT RECORD TO BE PLACED IN HASH TABLE */
    UCOUNT BYTE, /* NUMBER OF UNHASHED RECORDS IN QUEUE */
    NEXT BYTE,   /* NEXT AVAILABLE SLOT IN QUEUE */
    RECNUM ADDRESS, /* RECORD NUMBER OF OLDEST IN QUEUE */
    BUFA ADDRESS, /* ADDRESS OF BUFFER DESCRIPTOR FOR FILE USING */
                  /* USING THIS QUEUE */
    AFTN ADDRESS, /* AFTN OF FILE USING THIS QUEUE */

    /* THE FOLLOWING IDENTIFIERS REFER TO INDIVIDUAL RECORDS */

    ADDR(255) ADDRESS, /* ADDRESS OF INDIVIDUAL RECORD */
    LEN(255) BYTE, /* LENGTH OF RECCORD */
    CYCLE(255) BYTE, /* HASH ADDRESS OF RECORD */
    HLINK(255) BYTE, /* LINK FOR THE HASH TABLE BUCKETS */

    /* THE FOLLOWING ARRAY IS THE HASH TABLE, STORING UNMATCHED RECORDS */

    HTABLE(256) BYTE
    ),
    Q1A ADDRESS, /* POINTER TO Q1 TO BASE STRUCTURE */
    Q1 BASED Q1A STRUCTURE( /* ONE QUEUE FOR EACH INPUT FILE */
                       /* RECORDS OLDEST -> NEXTH-1 ARE IN HASH TABLE */
                       /* RECORDS NEXTH -> NEXT-1 HAVE BEEN SCANNED BUT */
                       /* ARE NOT IN HASH TABLE.  NOTE THAT THE QUEUE WRAPS */
                       /* AROUND MOD 255.  255 = 0FFH IS THE NULL ADDRESS */
    OLDEST BYTE, /* OLDEST RECORD IN HASH TABLE */
    HCOUNT BYTE, /* NUMBER OF RECORDS IN HASH TABLE */
    NEXTH BYTE,  /* NEXT RECORD TO BE PLACED IN HASH TABLE */
    UCOUNT BYTE, /* NUMBER OF UNHASHED RECORDS IN QUEUE */
    NEXT BYTE,   /* NEXT AVAILABLE SLOT IN QUEUE */
    RECNUM ADDRESS, /* RECORD NUMBER OF OLDEST IN QUEUE */
    BUFA ADDRESS, /* ADDRESS OF BUFFER DESCRIPTOR FOR FILE USING */
                  /* USING THIS QUEUE */
    AFTN ADDRESS, /* AFTN OF FILE USING THIS QUEUE */

    /* THE FOLLOWING IDENTIFIERS REFER TO INDIVIDUAL RECORDS */

    ADDR(255) ADDRESS, /* ADDRESS OF INDIVIDUAL RECORD */
    LEN(255) BYTE, /* LENGTH OF RECCORD */
    CYCLE(255) BYTE, /* HASH ADDRESS OF RECORD */
    HLINK(255) BYTE, /* LINK FOR THE HASH TABLE BUCKETS */

    /* THE FOLLOWING ARRAY IS THE HASH TABLE, STORING UNMATCHED RECORDS */

    HTABLE(256) BYTE
    ),
    PTR0 ADDRESS, /* TO SCAN RECORD0 */
    PTR1 ADDRESS, /* TO SCAN RECORD1 */
    CHAR0 BASED PTR0 BYTE, /* IN RECORD0 */
    CHAR1 BASED PTR1 BYTE, /* IN RECORD1 */
    LEN BYTE, /* RECORD LENGTH */
    I BYTE; /* LOOP INDEX */

  PTR0 = Q0.ADDR(RCD0);
  PTR1 = Q1.ADDR(RCD1);

  IF Q0.CYCLE(RCD0) <> Q1.CYCLE(RCD1)
  THEN RETURN(FALSE);

  IF (LEN := Q0.LEN(RCD0) ) <> Q1.LEN(RCD1)
  THEN RETURN(FALSE);

  DO I = 1 TO LEN;
    IF CHAR0 <> CHAR1 THEN RETURN(FALSE);
    PTR0 = PTR0 + 1;
    PTR1 = PTR1 + 1;
  END;

  RETURN(TRUE);

END COMPARE;

MATCH: PROCEDURE(RCD,Q0A,Q1A) BYTE;

/* PROCEDURE TO DETERMINE IF SYNCPARM RECORDS IN Q0, LAST ONE RCD */
/* MATCH A GROUP OF RECORDS IN Q1. */
/* REFERENCE TO THE HASH TABLE IS MADE.  IF NO MATCH IS FOUND */
/* FALSE IS RETURNED. OTHERWIZE TRUE IS RETURNED */
/* Q0.NEXTH AND Q1.NEXTH ARE ADJUSTED TO POINT TO THE FIRST RECORDS */
/* OF THE MATCHED BLOCK FOR THE CONVENIENCE OF PRINT */

  DECLARE
    Q0A ADDRESS, /* BASE FOR Q0 */
    Q0 BASED Q0A STRUCTURE( /* FIRST LOCAL COPY OF QUEUE */
                       /* RECORDS OLDEST -> NEXTH-1 ARE IN HASH TABLE */
                       /* RECORDS NEXTH -> NEXT-1 HAVE BEEN SCANNED BUT */
                       /* ARE NOT IN HASH TABLE.  NOTE THAT THE QUEUE WRAPS */
                       /* AROUND MOD 255.  255 = 0FFH IS THE NULL ADDRESS */
    OLDEST BYTE, /* OLDEST RECORD IN HASH TABLE */
    HCOUNT BYTE, /* NUMBER OF RECORDS IN HASH TABLE */
    NEXTH BYTE,  /* NEXT RECORD TO BE PLACED IN HASH TABLE */
    UCOUNT BYTE, /* NUMBER OF UNHASHED RECORDS IN QUEUE */
    NEXT BYTE,   /* NEXT AVAILABLE SLOT IN QUEUE */

   RECNUM ADDRESS, /* RECORD NUMBER OF OLDEST IN QUEUE */
    BUFA ADDRESS, /* ADDRESS OF BUFFER DESCRIPTOR FOR FILE USING */
                  /* USING THIS QUEUE */
    AFTN ADDRESS, /* AFTN OF FILE USING THIS QUEUE */

    /* THE FOLLOWING IDENTIFIERS REFER TO INDIVIDUAL RECORDS */

    ADDR(255) ADDRESS, /* ADDRESS OF INDIVIDUAL RECORD */
    LEN(255) BYTE, /* LENGTH OF RECCORD */
    CYCLE(255) BYTE, /* HASH ADDRESS OF RECORD */
    HLINK(255) BYTE, /* LINK FOR THE HASH TABLE BUCKETS */

    /* THE FOLLOWING ARRAY IS THE HASH TABLE, STORING UNMATCHED RECORDS */

    HTABLE(256) BYTE
    ),
    Q1A ADDRESS, /* BASE FOR Q1 */
    Q1 BASED Q1A STRUCTURE( /* SECOND LOCAL COPY OF QUEUE */
                       /* RECORDS OLDEST -> NEXTH-1 ARE IN HASH TABLE */
                       /* RECORDS NEXTH -> NEXT-1 HAVE BEEN SCANNED BUT */
                       /* ARE NOT IN HASH TABLE.  NOTE THAT THE QUEUE WRAPS */
                       /* AROUND MOD 255.  255 = 0FFH IS THE NULL ADDRESS */
    OLDEST BYTE, /* OLDEST RECORD IN HASH TABLE */
    HCOUNT BYTE, /* NUMBER OF RECORDS IN HASH TABLE */
    NEXTH BYTE,  /* NEXT RECORD TO BE PLACED IN HASH TABLE */
    UCOUNT BYTE, /* NUMBER OF UNHASHED RECORDS IN QUEUE */
    NEXT BYTE,   /* NEXT AVAILABLE SLOT IN QUEUE */
    RECNUM ADDRESS, /* RECORD NUMBER OF OLDEST IN QUEUE */
    BUFA ADDRESS, /* ADDRESS OF BUFFER DESCRIPTOR FOR FILE USING */
                  /* USING THIS QUEUE */
    AFTN ADDRESS, /* AFTN OF FILE USING THIS QUEUE */

    /* THE FOLLOWING IDENTIFIERS REFER TO INDIVIDUAL RECORDS */

    ADDR(255) ADDRESS, /* ADDRESS OF INDIVIDUAL RECORD */
    LEN(255) BYTE, /* LENGTH OF RECCORD */
    CYCLE(255) BYTE, /* HASH ADDRESS OF RECORD */
    HLINK(255) BYTE, /* LINK FOR THE HASH TABLE BUCKETS */

    /* THE FOLLOWING ARRAY IS THE HASH TABLE, STORING UNMATCHED RECORDS */

    HTABLE(256) BYTE
    ),
    RCD BYTE, /* RECORD TO BE MATCHED */
    TEST BYTE, /* RECORD TO BE COMPARED AGAINST RCD */
    ANSWER BYTE, /* THE ANSWER IN BOOLEAN */
    ANSWER0 BYTE, /* FIRST MATCHED RECORD IN Q0 */
    ANSWER1 BYTE, /* FIRST MATCHED RECORD IN Q1 */
    SIZE BYTE, /* SIZE OF Q1 BELOW TEST */
    RCD0 BYTE, /* TEMPORARIES RCD0 AND RCD1 */
    RCD1 BYTE,
    COUNT BYTE; /* LOOP INDEX */

  /* NO MATCH YET */
  ANSWER = FALSE;

  /* IF Q0 DOESN'T HAVE SYNCPARM ENTRIES THEN GIVE UP */
  IF Q0.HCOUNT + 1 < SYNCPARM
  THEN RETURN(FALSE);

  /* SEARCH HASH TABLE */
  TEST = Q1.HTABLE(Q0.CYCLE(RCD));
  DO WHILE TEST <> 0FFH;
    /* COMPUTE SIZE OF QUEUE1 BELOW TEST BY WIERD MODULO ARITHMETIC */
    IF TEST >= Q1.OLDEST
    THEN SIZE = TEST - Q1.OLDEST + 1;
    ELSE SIZE = TEST - Q1.OLDEST;

    IF SIZE < SYNCPARM /* NO ROOM TO SYNC.  NOTE THAT THERE ISN'T ANY */
                       /* ROOM EITHER FOR ANY OTHER RECORD DOWN */
                       /* THE BUCKET */
    THEN GOTO DONE;

    /* COMPARE SYNCPARM RECORDS */
    IF NOT COMPARE(RCD,Q0A,TEST,Q1A)
    THEN GOTO DECEND;
    RCD0 = RCD;
    RCD1 = TEST;
    DO COUNT = 2 TO SYNCPARM;
      /* DECREMENT RCD0 AND RCD1 MODULO 0FEH */
      IF RCD0 = 0
      THEN RCD0 = 0FEH;
      ELSE RCD0 = RCD0 - 1;
      IF RCD1 = 0
      THEN RCD1 = 0FEH;
      ELSE RCD1 = RCD1 - 1;

      IF NOT COMPARE(RCD0,Q0A,RCD1,Q1A)
      THEN GOTO DECEND;
    END;
    /* WE HAVE A MATCH BUT THERE STILL CAN BE A LOWER MATCH */
    ANSWER = TRUE;
    ANSWER0 = RCD0;
    ANSWER1 = RCD1;
    DECEND:
    TEST = Q1.HLINK(TEST); /* DECEND THROUGH BUCKET */
  END;

  DONE:
  IF ANSWER /* THEN ADJUST NEXTH'S FOR PRINT */
  THEN DO;
    Q0.NEXTH = ANSWER0;
    Q1.NEXTH = ANSWER1;
  END;
  RETURN(ANSWER);

END MATCH;

DELETE1: PROCEDURE(QA);
  DECLARE QA ADDRESS, /* POINTER TO QUEUE */
    Q BASED QA STRUCTURE ( /* LOCAL COPY OF QUEUE */
      OLDEST BYTE,
      HCOUNT BYTE,
      NEXTH BYTE,
      UCOUNT BYTE,
      NEXT BYTE,
      RECNUM ADDRESS,
      BUFA ADDRESS,
      AFTN ADDRESS,
      ADDR(255) ADDRESS,
      LEN(255) BYTE,
      CYCLE(255) BYTE,
      HLINK(255) BYTE,
      HTABLE(255) BYTE);

  Q.RECNUM = Q.RECNUM + 1;
  Q.UCOUNT = Q.UCOUNT - 1;
  IF Q.OLDEST = 0FEH
  THEN Q.OLDEST = 0;
  ELSE Q.OLDEST = Q.OLDEST + 1;
  Q.NEXTH = Q.OLDEST;

END DELETE1;

/* MAIN START */

CALL COMMAND; /* READ IN COMMAND LINE AND OPEN FILES */
CALL INITILIZE; /* INITILIZE BUFFERS, QUEUES, HASH TABLES */

IDENTICAL = TRUE;    /* FILES IDENTICAL SO FAR */

/* MAIN LOOP */
DO WHILE TRUE;
  RCD0 = READRECORD(.QUEUE0);
  IF RCD0 = 0FFH /* EOF */
  THEN CALL TERMINATE;
  RCD1 = READRECORD(.QUEUE1);
  IF RCD1 = 0FFH /* EOF */
  THEN CALL TERMINATE;
  IF COMPARE(RCD0,.QUEUE0,RCD1,.QUEUE1)
  THEN DO;
    CALL DELETE1(.QUEUE0);
    CALL DELETE1(.QUEUE1);
    END;
  ELSE DO; /* TRY TO RESYNC */
    CALL HASH$INSERT(.QUEUE0); /* INSERT RCD0 AND RCD1 IN THEIR */
    CALL HASH$INSERT(.QUEUE1); /* RESPECTIVE HASH TABLES */
    NOMATCH = TRUE; /* FLAG TO SIGNAL WHEN MATCH TAKES PLACE */
    DO WHILE NOMATCH;
      RCD0 = READRECORD(.QUEUE0);
      IF RCD0 <> 0FFH /* EOF */
      THEN IF MATCH(RCD0,.QUEUE0,.QUEUE1)
           THEN DO;
             CALL CLEANUP;
             NOMATCH = FALSE;
             END;
           ELSE CALL HASH$INSERT(.QUEUE0);
      IF NOMATCH
      THEN DO;
        RCD1 = READRECORD(.QUEUE1);
        IF RCD1 = 0FFH /* EOF */
        THEN IF RCD0 = 0FFH /* EOF FOR BOTH FILES */
             THEN CALL TERMINATE;
             ELSE;
        ELSE IF MATCH(RCD1,.QUEUE1,.QUEUE0)
             THEN DO;
               CALL CLEANUP;
               NOMATCH = FALSE;
               END;
             ELSE CALL HASH$INSERT(.QUEUE1);
      END;
    END;
  END;
END;
END COMPAR;
src/consol.plm
CONSOLE:
DO;

/************************************************************************/
/*																		*/
/*     'Copyright 1981,1983 Intel Corporation'.  All rights reserved.	*/
/*      No part of this program or publication may be reproduced,		*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

$IF XVERSION
DECLARE PROPRIETARY(*) BYTE DATA ('INTEL PROPRIETARY SOFTWARE');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=X203',0);
$ELSE
DECLARE COPYRIGHT (*) BYTE DATA  ('COPYRIGHT 1981,1983 INTEL ');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V2.1',0);
$ENDIF

    
DECLARE VERSION$LEVEL LITERALLY '02H',
        EDIT$LEVEL LITERALLY '01H';

DECLARE VERSION (*) BYTE DATA (VERSION$LEVEL,EDIT$LEVEL);

$NOLIST
DECLARE TRUE LITERALLY '0FFH';
DECLARE FALSE LITERALLY '00H';
DECLARE BOOLEAN LITERALLY 'BYTE';
DECLARE FOREVER LITERALLY 'WHILE 1';

DECLARE
  NULL          LITERALLY '00H',
  CONTROL$C     LITERALLY '03H',
  CONTROL$E     LITERALLY '05H',
  BELL          LITERALLY '07H',
  TAB           LITERALLY '09H',
  LF            LITERALLY '0AH',
  VT            LITERALLY '0BH',
  FF            LITERALLY '0CH',
  CR            LITERALLY '0DH',
  CONTROL$P     LITERALLY '10H',
  CONTROL$Q     LITERALLY '11H',
  CONTROL$R     LITERALLY '12H',
  CONTROL$S     LITERALLY '13H',
  CONTROL$X     LITERALLY '18H',
  CONTROL$Z     LITERALLY '1AH',
  ESC           LITERALLY '1BH',
  QUOTE         LITERALLY '22H',
  LCA           LITERALLY '61H',
  LCZ           LITERALLY '7AH',
  ALT$MODE      LITERALLY '7DH',
  RUBOUT        LITERALLY '7FH';

    DECLARE WARNING         LITERALLY  '0',
            MESSAGE         LITERALLY  '1',
            ABORT           LITERALLY  '2';

    DECLARE OK              LITERALLY  '0'
    ,       NO$FREE$BUFFER  LITERALLY  '1'
    ,       BAD$AFT$NO      LITERALLY  '2'
    ,       AFT$FULL        LITERALLY  '3'
    ,       BAD$PATH        LITERALLY  '4'
    ,       BAD$DEVICE      LITERALLY  '5'
    ,       CANT$WRITE      LITERALLY  '6'
    ,       DISK$FULL       LITERALLY  '7'
    ,       CANT$READ       LITERALLY  '8'
    ,       DIRECTORY$FULL  LITERALLY  '9'
    ,       DIFFERENT$DISK  LITERALLY  '10'
    ,       MULTIDEFINED    LITERALLY  '11'
    ,       ALREADY$OPEN    LITERALLY  '12'
    ,       NO$SUCH$FILE    LITERALLY  '13'
    ,       WRITE$PROTECT   LITERALLY  '14'
    ,       ISIS$OVERWRITE  LITERALLY  '15'
    ,       BAD$LOAD$FORMAT LITERALLY  '16'
    ,       NON$DISK$FILE   LITERALLY  '17'
    ,       BAD$COMMAND     LITERALLY  '18'
    ,       NON$DISK$SEEK   LITERALLY  '19'
    ,       LONG$BACK$SEEK  LITERALLY  '20'
    ,       CANT$RESCAN     LITERALLY  '21'
    ,       ILLEGAL$ACCESS  LITERALLY  '22'
    ,       NULL$FILENAME   LITERALLY  '23'
    ,       DISK$IO$ERROR   LITERALLY  '24'
    ,       BAD$ECHO        LITERALLY  '25'
    ,       BAD$ATTRIB      LITERALLY  '26'
    ,       BAD$SEEK$ARG    LITERALLY  '27'
    ,       NULL$EXTENSION  LITERALLY  '28'
    ,       CONSOLE$EOF     LITERALLY  '29'
    ,       DRIVE$NOT$READY LITERALLY  '30'
    ,       SEEK$ON$WRITE   LITERALLY  '31'
    ,       CANT$DELETE     LITERALLY  '32'
    ,       ILLEGAL$PARAM   LITERALLY  '33'
    ,       BAD$RETSW       LITERALLY  '34'
    ,       SEEK$PAST$EOF   LITERALLY  '35'
    ,       UNRECOG$SWITCH  LITERALLY '201'
    ,       UNRECOG$DELIM   LITERALLY '202'
    ,       INVALID$SYNTAX  LITERALLY '203'
    ,       EARLY$EOF       LITERALLY '204'
    ,       BAD$LABEL       LITERALLY '206'
    ,       NO$END$STAT     LITERALLY '207'
    ,       CHECKSUM$ERROR  LITERALLY '208'
    ,       RELO$SEQ$ERR    LITERALLY '209'
    ,       INSUFF$MEMORY   LITERALLY '210'
    ,       REC$TOO$LONG    LITERALLY '211'
    ,       BAD$REC$TYP     LITERALLY '212'
    ,       FIXUP$BOUNDS    LITERALLY '213'
    ,       BAD$PARAM       LITERALLY '214'
    ,       ARG$TOO$LONG    LITERALLY '215'
    ,       TOO$MANY$PARAMS LITERALLY '216'
    ,       REC$TOO$SHORT   LITERALLY '217'
    ,       ILL$REC$FMT     LITERALLY '218'
    ,       PHASE$ERROR     LITERALLY '219'
    ,       NO$EOF          LITERALLY '220'
    ,       SEG$OVERFLOW    LITERALLY '221'
    ,       UNRECOG$REC     LITERALLY '222'
    ,       FIXUP$ERROR     LITERALLY '223'
    ,       ILL$REC$SEQ     LITERALLY '224'
    ,       BAD$MOD$NAME    LITERALLY '225'
    ,       LONG$MOD$NAME   LITERALLY '226'
    ,       NO$L$PAREN      LITERALLY '227'
    ,       NO$R$PAREN      LITERALLY '228'
    ,       UNRECOG$CONTROL LITERALLY '229'
    ,       DUP$SYMBOL      LITERALLY '230'
    ,       FILE$EXISTS     LITERALLY '231'
    ,       UNRECOG$COM     LITERALLY '232'
    ,       NO$TO           LITERALLY '233'
    ,       DUP$FILE$NAME   LITERALLY '234'
    ,       NOT$LIB$FILE    LITERALLY '235'
    ,       TOO$MANY$CMNS   LITERALLY '236'
    ,       MISSING$COMMON  LITERALLY '237'
    ,       STACK$CONTENT   LITERALLY '238'
    ,       NO$MODHDR       LITERALLY '239'
    ,       OUT$OF$RANGE    LITERALLY '240'
    ,       INV$OBJ$FILE    LITERALLY '241'
    ;

READ: PROCEDURE (AFT,BUFFER,COUNT,ACTUAL,STATUS) EXTERNAL;
  DECLARE (AFT,BUFFER,COUNT,ACTUAL,STATUS) ADDRESS; END READ;
FILE$ERROR: PROCEDURE (A,B,C) EXTERNAL;
  DECLARE (A,C) ADDRESS; DECLARE B BYTE; END FILE$ERROR;
DEBLANK: PROCEDURE (PTR) ADDRESS EXTERNAL; DECLARE PTR ADDRESS; END DEBLANK;
DELIMIT: PROCEDURE (PTR) ADDRESS EXTERNAL; DECLARE PTR ADDRESS; END DELIMIT;
CONSOL: PROCEDURE (A,B,C) EXTERNAL; DECLARE (A,B,C) ADDRESS; END CONSOL;
FORCE$UPPER: PROCEDURE (ADDR) EXTERNAL; DECLARE ADDR ADDRESS; END FORCE$UPPER;
EXIT: PROCEDURE EXTERNAL; END EXIT;
$LIST

DECLARE BUFFER(128) BYTE;
DECLARE (BUFFER$PTR,INPUT$PTR,OUTPUT$PTR) ADDRESS;
DECLARE CHAR BASED BUFFER$PTR BYTE;
DECLARE (ACTUAL,STATUS) ADDRESS;

CALL READ(1,.BUFFER,LENGTH(BUFFER),.ACTUAL,.STATUS);
BUFFER(ACTUAL) = CR;
CALL FORCE$UPPER(.BUFFER);
BUFFER$PTR = DEBLANK(.BUFFER);
INPUT$PTR = .(':CI: ');
OUTPUT$PTR = .(':CO: ');
IF CHAR <> ',' THEN
DO;
  INPUT$PTR = BUFFER$PTR;
  BUFFER$PTR = DEBLANK(DELIMIT(BUFFER$PTR));
END;
IF CHAR <> CR THEN
DO;
  IF CHAR <> ',' THEN CALL FILE$ERROR(INVALID$SYNTAX,BUFFER$PTR,TRUE);
  BUFFER$PTR,OUTPUT$PTR = DEBLANK(BUFFER$PTR+1);
  BUFFER$PTR = DEBLANK(DELIMIT(BUFFER$PTR));
  IF CHAR <> CR THEN CALL FILE$ERROR(INVALID$SYNTAX,BUFFER$PTR,TRUE);
END;
CALL CONSOL(INPUT$PTR,OUTPUT$PTR,.STATUS);
CALL FILE$ERROR(STATUS,.BUFFER,TRUE);
CALL EXIT;
END;

EOF
src/csort2.asm
$TITLE('==>  C S O R T 2  <==  CHKLOD')
$MACROFILE NOGEN

;     'Copyright 1981,1983 Intel Corporation'.  All rights reserved.
;      No part of this program or publication may be reproduced,
;      transmitted, transcribed, stored in a retrievel system, or
;      translated into any language or computer language, in any
;      form or by any means, electronic, mechanical, magnetic,
;      optical, chemical, manual or otherwise, without the prior
;      written permission of Intel Corporation, 3065 Bowers
;      Avenue, Santa Clara, California, 95051, Attn: Software
;      License Administration.

; SORT: PROCEDURE (PTR,COUNT,PROC$ADDR) EXTERNAL;
;   DECLARE (PTR,COUNT,PROC$ADDR) ADDRESS;
; END;
;
; SORT ACCEPTS AN ARRAY OF POINTERS AND SORTS THE POINTERS.
;   "COUNT" IS THE NUMBER OF POINTERS.
;   "PTR" IS THE LOCATION OF THE POINTERS
;   "PROC$ADDR" IS THE ADDRESS OF THE FOLLOWING PROCEDURE:
;
; GREATER$THAN: PROCEDURE (PTR1,PTR2);
;   DECLARE (PTR1,PTR2) ADDRESS;
;   ...
; END;
;
; "GREATER$THAN" ACCEPTS AS INPUT TWO POINTERS INTO THE ARRAY
;   OF POINTERS.  IT RETURNS TRUE IFF THE RECORD ASSOCIATED
;   WITH PTR1 IS GREATER THAN THE RECORD ASSOCIATED WITH PTR2.
;
; SORT SORTS THE POINTERS SO THAT THE ASSOCIATED RECORDS ARE IN
;   INCREASING ORDER.
$EJECT
        NAME SORT
        CSEG
        PUBLIC SORT

        MIDPOINT MACRO  ;; LOCATE POINTER IN THE MIDDLE OF THE ARRAY
        MOV A,L
        ADD E
        MOV C,A
        MOV A,H
        ADC D           ;; AC NOW EQUALS (HL+DE) -- NOW DIVIDE BY 2
        RAR
        MOV B,A
        MOV A,C
        RAR             ;; BA NOW EQUALS (HL+DE)/2 -- NOW INSURE THAT IT
                        ;;   HAS THE SAME PARITY AS ALL THE OTHER POINTERS
        XRA L
        ANI 0FEH
        XRA L
        MOV C,A         ;; BC IS THE ANSWER.
        ENDM

        CENTER MACRO    ;;SET HA TO (HL+BC)/2
        DAD B
        MOV A,H
        RAR
        MOV H,A
        MOV A,L
        RAR
        ENDM

        JFALSE MACRO PARAM    ;; JUMP IF BCGTDE WAS FALSE I.E. IF BC <= DE
        JNC PARAM
        ENDM

        SKIP1 MACRO        ;; SKIP NEXT 1 INSTRUCTION BYTE  -- WIPES OUT A
        DB (MVI A,0)
        ENDM

        SKIP2 MACRO        ;; SKIP NEXT 2 INSTRUCTION BYTES  -- WIPES OUT HL
        DB (LXI H,0)
        ENDM

        IFCROSS MACRO ADR  ;; JUMP TO ADR IF BC AND DE HAVE CROSSED.
        MOV A,E
        SUB C
        MOV A,D
        SBB B
        JC ADR
        ENDM
$EJECT
SORT:                 ; BC=COUNT   DE=PROC$ADDR   HL=???   S1=RET   S2=PTR
        XCHG
        SHLD PADDR    ; BC=COUNT   DE=???   HL=PROC$ADDR
        POP H
        XTHL          ; BC=COUNT   DE=???   HL=PTR
        MOV D,H
        MOV E,L       ; BC=COUNT   DE=START$PTR   HL=START$PTR
        DAD B
        DAD B
        DCX H
        DCX H
        XCHG          ; BC=COUNT   DE=END$PTR   HL=START$PTR

HDSORT:                ; INTERIOR SORT ROUTINE WHICH IS CALLED RECURSIVELY.
                      ; SORTS POINTERS AT HL THRU DE.     A,B,C IGNORED.

        MOV A,E
        SUB L
        MOV C,A
        MOV A,D
        SBB H
        RC            ; RETURN IF END$PTR < START$PTR
        ORA C
        RZ            ;   ...OR IF END$PTR = START$PTR
$EJECT
; THE TOPMOST POINTER IS GOING TO BE SWITCHED INTO ITS FINAL POSITION ON
; THE NEXT PAGE.  ON THIS PAGE, WE INCREASE THE PROBABILITY THAT THAT
; FINAL POSITION IS NEAR THE MIDDLE.  THIS SPEEDS THINGS UP.  WE DO SO
; BY LOOKING AT THE BOTTOM, MID, AND TOP POINTERS, AND SWITCHING THE
; SECOND HIGHEST OF THE THREE TO THE TOP POSITION.

                      ; POINTER ARRAY LOOKS LIKE THIS:
                      ; HL . . .    . . . DE
        PUSH H        ; S1 . . .    . . . DE
        MIDPOINT      ; S1 . . . BC . . . DE
        CALL BCGTDE
        CC SWITCH     ; GUARANTEES MID < TOP
        POP H         ; HL . . . BC . . . DE
        PUSH B        ; HL . . . S1 . . . DE
        MOV B,H
        MOV C,L       ; BC . . . S1 . . . DE
        CALL BCGTDE   ; BOTTOM > TOP?
        POP H         ; BC . . . HL . . . DE
        JC ALLSET     ; IF SO THEN TOP IS ALREADY GOOD
        XCHG          ; BC . . . DE . . . HL
        PUSH H        ; BC . . . DE . . . S1
        CALL BCGTDE
        CNC SWITCH    ; GUARANTEES TOP > BOTTOM > MID
        POP D         ; BC . . .    . . . DE
        CALL SWITCH   ; NOW BOTTOM > TOP > MID   SO TOP IS GOOD.
ALLSET:
        PUSH B
        PUSH D        ; S2=BC . . . . . . S1=DE
$EJECT
; IN THIS STAGE, SWITCHES OF POINTERS ARE MADE UNTIL THERE IS A
; SINGLE POINTER IN ITS FINAL POSITION, WITH ALL LESSER POINTERS
; TO THE LEFT AND ALL GREATER POINTERS TO THE RIGHT.

CMPF:
        CALL BCGTDE
        JFALSE CRUZF
        CALL SWITCH
CRUZB:
        DCX D
        DCX D
        IFCROSS RCURS2
CMPB:
        CALL BCGTDE
        JFALSE CRUZB
        CALL SWITCH
CRUZF:
        INX B
        INX B
        IFCROSS RCURS1

        JMP CMPF
$EJECT
; NOW WE CAN SPLIT THE SORT INTO TWO HALF SORTS AND DO THE HALF SORTS
; BY RECURSION.
; AN ADJUSTMENT OF BC OR DE MUST FIRST BE MADE, DEPENDING ON THE ENTRY POINT.

RCURS1:                  ; S2 . . . . . DE BC . . . . . S1
                         ;             GOOD
        DCX D
        DCX D
        SKIP2
RCURS2:                  ; S2 . . . . . DE BC . . . . . S1
                         ;                GOOD
        INX B
        INX B

; NOW COMPUTE WHICH HALF IS SMALLER AND DO IT FIRST.

RCURS:                   ; S2 . . . . . DE GOOD BC . . . . . S1
        MOV H,B
        MOV L,C
        POP B            ; S1 . . . . . DE      HL . . . . . BC
        XTHL             ; HL . . . . . DE      S1 . . . . . BC
        PUSH H           ; S1 . . . . . DE      S2 . . . . . BC
        CENTER
        SUB E
        MOV A,H
        SBB D
        POP H            ; HL . . . . . DE      S1 . . . . . BC
        JNC LEFT
RIGHT:
        XTHL             ; S1 . . . . . . DE   HL . . . BC
        PUSH D           ; S2 . . . . . . S1   HL . . . BC
        MOV D,B
        MOV E,C          ; S2 . . . . . . S1   HL . . . DE
        SKIP1
LEFT:
        PUSH B           ; HL . . . DE   S2 . . . . . . S1

        CALL HDSORT       ; SORT THE FIRST HALF
        POP D
        POP H            ; POP OFF THE POINTERS TO THE OTHER HALF
        JMP HDSORT        ; SORT THE OTHER HALF
$EJECT

SWITCH:           ; SWITCH WORD POINTED AT BY BC WITH WORD POINTED AT BY DE
                  ; SAVE B,C,D,E

        MOV H,B
        MOV L,C
        LDAX D
        MOV C,M
        MOV M,A
        XCHG
        MOV M,C
        INX H
        INX D
        LDAX D
        MOV C,M
        MOV M,A
        XCHG
        MOV M,C
        DCX D
        DCX H
        MOV C,L
        RET

        DSEG
BCGTDE:                  ; CALL EXTERNALLY-PASSED "BC GREATER THAN DE"
                         ; ROUTINE SO AS TO PRESERVE B,C,D,E AND RETURN
                         ; THE ANSWER IN THE CARRY FLAG (CARRY=TRUE)

        PUSH B
        PUSH D
        DB (CALL 0)
PADDR:
        DW 0
        RAR
        POP D
        POP B
        RET

        STKLN 100

$EJECT
        END
src/dcopy.plm
DCOPY: 
DO;

/************************************************************************/
/*																		*/
/*     'Copyright 1981,1983 Intel Corporation'.  All rights reserved.	*/
/*      No part of this program or publication may be reproduced,		*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

$IF XVERSION
DECLARE PROPRIETARY(*) BYTE DATA ('INTEL PROPRIETARY SOFTWARE');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=X215',0);
$ELSE
DECLARE COPYRIGHT (*) BYTE DATA  ('COPYRIGHT 1981,1983 INTEL ');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V2.2',0);
$ENDIF

    
/* LAST CHANGED 21-NOV-1978 */

DECLARE VERSION$LEVEL LITERALLY '02H',
           EDIT$LEVEL LITERALLY '19H';

DECLARE TRUE LITERALLY '0FFH';
DECLARE FALSE LITERALLY '00H';
DECLARE BOOLEAN LITERALLY 'BYTE';
DECLARE FOREVER LITERALLY 'WHILE 1';

/* SPECIAL ASCII CHARACTERS */

DECLARE
  NULL          LITERALLY '00H',
  CONTROL$C     LITERALLY '03H',
  CONTROL$E     LITERALLY '05H',
  BELL          LITERALLY '07H',
  TAB           LITERALLY '09H',
  LF            LITERALLY '0AH',
  VT            LITERALLY '0BH',
  FF            LITERALLY '0CH',
  CR            LITERALLY '0DH',
  CONTROL$P     LITERALLY '10H',
  CONTROL$Q     LITERALLY '11H',
  CONTROL$R     LITERALLY '12H',
  CONTROL$S     LITERALLY '13H',
  CONTROL$X     LITERALLY '18H',
  CONTROL$Z     LITERALLY '1AH',
  ESC           LITERALLY '1BH',
  QUOTE         LITERALLY '22H',
  LCA           LITERALLY '61H',
  LCZ           LITERALLY '7AH',
  ALT$MODE      LITERALLY '7DH',
  RUBOUT        LITERALLY '7FH';

    /* PREDECLARED DISK SECTORS. */

    /* PREDECLARED DISK SECTORS. */

    DECLARE
      T0$HDR$BLK     LITERALLY '0018H',
      T0$DATA$BLK0   LITERALLY '0001H',
      T0$DATA$BLKS   LITERALLY '23',
      LAB$HDR$BLK    LITERALLY '0019H',
      LAB$DATA$BLK0  LITERALLY '001AH',
      LAB$DATA$BLKS  LITERALLY '1',
      DIR$HDR$BLK    LITERALLY '0101H',
      DIR$DATA$BLK0  LITERALLY '0102H',
      DIR$DATA$BLKS  LITERALLY '25',
      MAP$HDR$BLK    LITERALLY '0201H',
      MAP$DATA$BLK0  LITERALLY '0202H',
      MAP$DATA$BLKS  LITERALLY '2',
      ISIS$HDR$BLK   LITERALLY '0204H';

    DECLARE
      FLINK LITERALLY '1',
      BLINK LITERALLY '0';

DECLARE MAX$RETRIES LITERALLY '10'; /* MAX FDCC ERROR RETRIES */

/* DISK CONTROLLER CONSTANTS. */

/* OUTPUT PORTS */

DECLARE LOW$ADDRESS$0   LITERALLY '79H',
        LOW$ADDRESS$1   LITERALLY '89H',
        HIGH$ADDRESS$0  LITERALLY '7AH',
        HIGH$ADDRESS$1  LITERALLY '8AH',
        STOP$DISK$0     LITERALLY '7BH',
        STOP$DISK$1     LITERALLY '8BH',
        CHANNEL$RESET$0 LITERALLY '7FH',
        CHANNEL$RESET$1 LITERALLY '8FH',

/* INPUT PORTS */

        FDCC$STATUS$0   LITERALLY '78H',
        FDCC$STATUS$1   LITERALLY '88H',
        RESULT$TYPE$0   LITERALLY '79H',
        RESULT$TYPE$1   LITERALLY '89H',
        RESULT$BYTE$0   LITERALLY '7BH',
        RESULT$BYTE$1   LITERALLY '8BH',

/* STATUS BITS */

        DISK$DONE       LITERALLY '4';

DECLARE SEEK$COMMAND    LITERALLY '1',
        FORMAT$COMMAND  LITERALLY '2',
        RECALIBRATE     LITERALLY '3',
        READ$COMMAND    LITERALLY '4',
        VERIFY$COMMAND  LITERALLY '5',
        WRITE$COMMAND   LITERALLY '6',
        WRITE$DEL       LITERALLY '7';

DECLARE IOCW            LITERALLY '0', /* CHANNEL WORD */
        IOINS           LITERALLY '1', /* I/O INSTRUCTIONS */
        NSEC            LITERALLY '2', /* NUMBER OF SECTORS */
        TADR            LITERALLY '3', /* TRACK ADDRESS, 0 TO 76 */
        SADR            LITERALLY '4', /* SECTOR ADDRESS, 1 TO 26 */
        BUFL            LITERALLY '5', /* LOW(BUFFER) */
        BUFU            LITERALLY '6', /* HIGH(BUFFER) */
        BNUM            LITERALLY '7', /* BLOCK NUMBER */
        NXTL            LITERALLY '9', /* LOW(NEXT$DCB) */
        NXTU            LITERALLY '8'; /* HIGH(NEXT$DCB) */

DECLARE /* DEVICE ACCESS MODES. */
  READ$MODE       LITERALLY '1',
  WRITE$MODE      LITERALLY '2',
  UPDATE$MODE     LITERALLY '3';

DECLARE VERSION(*) BYTE DATA (VERSION$LEVEL,EDIT$LEVEL);

DECLARE DCB(12) BYTE INITIAL (80H);
DECLARE DIGITS(16) BYTE INITIAL('0123456789ABCDEF');

MEMCK:
  PROCEDURE ADDRESS EXTERNAL;

  END MEMCK;

NUMOUT:
  PROCEDURE(VALUE,BASE,LC,BUFADR,WIDTH) EXTERNAL;
    DECLARE (VALUE,BUFADR) ADDRESS;
    DECLARE (BASE,LC,WIDTH) BYTE;

  END NUMOUT;

DEBLANK:
  PROCEDURE (PTR) ADDRESS EXTERNAL;
    DECLARE PTR ADDRESS;

  END DEBLANK;

FORCE$UPPER:
  PROCEDURE (BUFFER$PTR) EXTERNAL;
    DECLARE BUFFER$PTR ADDRESS;

  END FORCE$UPPER;

SCAN$INTEGER:
  PROCEDURE(PP) ADDRESS EXTERNAL;
    DECLARE PP ADDRESS;

  END SCAN$INTEGER;

OPEN:
  PROCEDURE (AFT,FILE,ACCESS,MODE,STATUS) EXTERNAL;
    DECLARE (AFT,FILE,ACCESS,MODE,STATUS) ADDRESS;

  END OPEN;

CLOSE:
  PROCEDURE (AFT,STATUS) EXTERNAL;
    DECLARE (AFT,STATUS) ADDRESS;

  END CLOSE;

READ:
  PROCEDURE (AFT,BUFFER,COUNT,ACTUAL,STATUS) EXTERNAL;
    DECLARE (AFT,BUFFER,COUNT,ACTUAL,STATUS) ADDRESS;

  END READ;

WRITE:
  PROCEDURE (AFT,BUFFER,COUNT,STATUS) EXTERNAL;
    DECLARE (AFT,BUFFER,COUNT,STATUS) ADDRESS;

  END WRITE;

ERROR:
  PROCEDURE (ERRNUM) EXTERNAL;
    DECLARE ERRNUM ADDRESS;

  END ERROR;

EXIT:
  PROCEDURE EXTERNAL;

  END EXIT;

DISKIO:
  PROCEDURE(DISK,IOPB) EXTERNAL;
    DECLARE (DISK,IOPB) ADDRESS;

  END DISKIO;

SPATH:
   PROCEDURE(FILE,BUFFER,STATUS) EXTERNAL;
     DECLARE (FILE,BUFFER,STATUS) ADDRESS;
   END SPATH;

ABSIO:
  PROCEDURE (COMMAND,DISK,BLOCK,BUFFER$PTR) EXTERNAL;
    DECLARE (COMMAND,DISK) BYTE;
    DECLARE (BLOCK,BUFFER$PTR) ADDRESS;

  END ABSIO;

DUMP:
  PROCEDURE;
    DECLARE (I,J,K) BYTE;
    DECLARE DIGITS(*) BYTE DATA ('0123456789ABCDEF');

    /* DISPLAY THE FIRST 128 BYTES OF "MEMORY" IN HEX AND ASCII */

    CO: PROCEDURE(C); DECLARE C BYTE;
      DECLARE STAT ADDRESS;
      CALL WRITE(0,.C,1,.STAT);
    END CO;
    DO I=0 TO 7;
      CALL CO(DIGITS(I));
      CALL CO(' ');
      DO J=I*16 TO (I*16)+15;
        CALL CO(' ');
        CALL CO(DIGITS(SHR(MEMORY(J),4)));
        CALL CO(DIGITS((MEMORY(J) AND 0FH)));
      END;
      CALL CO(' ');
      DO J=I*16 TO (I*16)+15;
        IF (K:=MEMORY(J)) >= ' ' AND K <= 7AH /* 'Z' */
        THEN CALL CO(K); ELSE CALL CO(' ');
      END;
      CALL CO(CR); /* CR */
      CALL CO(LF); /* LF */
    END;
  END DUMP;

JREAD:
  PROCEDURE(PTRPTR);
    DECLARE PTRPTR ADDRESS;
    DECLARE DISK BYTE;
    DECLARE (TRACK,SECTOR) ADDRESS;
     DECLARE READBUF (128) BYTE;

    TRACK = SCAN$INTEGER(.PTRPTR);
    SECTOR= SCAN$INTEGER(.PTRPTR);
    DISK = SCAN$INTEGER(.PTRPTR);
    CALL ABSIO(READ$COMMAND,DISK,TRACK*256+SECTOR,.READBUF);
  END JREAD;

DASH:
  PROCEDURE(LOTRAK);
  DECLARE (LOTRAK,TRACK) BYTE;
  CALL WRITE(0,.(CR,LF),2,.STAT);
  IF LOTRAK <> 0 THEN
  DO TRACK = 0 TO LOTRAK-1;
    IF (TRACK MOD 10) = 0 THEN CALL WRITE(0,.(' '),1,.STAT);
    CALL WRITE(0,.('-'),1,.STAT);
  END;
END DASH;

/* GENERATE PHYSICAL SECTOR TABLE FOR INTERLEAVE FACTOR */

GENSEC:
  PROCEDURE(INTLEAVE,NRSEC);
    DECLARE INTLEAVE BYTE;
    DECLARE NRSEC BYTE;
    DECLARE I BYTE;
    DECLARE INDEX BYTE;

    DO I = 0 TO NRSEC-1;
      SECTAB(I) = 0;
    END;
    INDEX = 0;
    DO I= 1 TO NRSEC;
      IF INDEX >= NRSEC THEN
      DO;
        INDEX = INDEX - NRSEC;
        DO WHILE SECTAB(INDEX) <> 0;
          INDEX = INDEX + 1;
        END;
      END;
      SECTAB(INDEX) = I;
      INDEX = INDEX + INTLEAVE;
    END;
  END GENSEC;

/*	FMTTRK.PEX */

FORMAT$TRACK:
	PROCEDURE (A,B,C,D) EXTERNAL;
    DECLARE (A,B,C,D) BYTE;
    END
FORMAT$TRACK;

/*	END  */
/*	FMTTRK.PEX */

DECLARE DISK$TYPE BYTE PUBLIC;
DECLARE BUF$IN(12) BYTE;
DECLARE STAT$IN ADDRESS;
DECLARE (TRACK,WLOTRAK,NTRAK,LOTRAK,HITRAK,SECTOR,NOUT) BYTE;
DECLARE (BUF0,BUF1,WBUF0,WBUF1) ADDRESS,
        CHAR0 BASED WBUF0 (1) BYTE, CHAR1 BASED WBUF1 (1) BYTE;
DECLARE (I,J) ADDRESS;
DECLARE MISCOMPARE BYTE;
DECLARE BUFPTR ADDRESS, CHAR BASED BUFPTR BYTE;
DECLARE TPTR ADDRESS;
DECLARE (ACTUAL,STAT) ADDRESS; /* FOR READ CALL */
DECLARE (COPY,VERIFY,FORMATSW,INTLEV$FLG) BOOLEAN;
DECLARE INTERLEAVE(77) BYTE;
DECLARE SOURCE LITERALLY '0', SINK LITERALLY '1';
DECLARE MSG(*) BYTE DATA(CR,LF,'LOAD DISKETTES AND TYPE ''CR''');
DECLARE UNIT BYTE; /* OUTPUT DEVICE */
DECLARE INPUT BYTE; /* INPUT DEVICE NUMBER, MASTER DISK LOCATION */
DECLARE OUTPUT(4) BYTE; /* OUTPUT DEVICE NUMBERS, 4 MAXIMUM FOR COPY DISK */
DECLARE OUTBUF(1) BYTE; /* BYTE TO HOLD ASCII CHAR FOR PRINTING
                             SOURCE DRIVE ON TERMINAL */
DECLARE TOBUF(5) BYTE; /* STRING CONTAINS DESTINATION DEVICES */
DECLARE TO$LENGTH BYTE;
DECLARE (VAR,DRV,L) BYTE ;
DECLARE SECTAB(52) BYTE;
DECLARE INDEX BYTE;
DECLARE INDEX$INCR BYTE;
DECLARE INDEX$RESET BYTE;
DECLARE MONITOR ADDRESS DATA (0); /* ENTRY POINT TO MONITOR */

/*
   ATTRIBUTE TABLE
  THE ATTRIBUTE TABLE IS USED AS TABLE LOOK UP FOR THE FORMAT, COPY
  AND VERIFY ATTRIBUTES
                 8      4     2       1
      2  1  0    FORMAT COPY  VERIFY  ERROR    TABLE ENTRY
  0                      X                      04H
  1         VO                   X              02H
  2      V               X       X              06H
  3      V  VO                          X       01H
  4   I             X    X                      0CH
  5   I     VO                          X       01H
  6   I  V          X    X       X              0EH
  7   I  V  VO                          X       01H

*/

DECLARE ATR(8) BYTE INITIAL(4,2,6,1,12,1,14,1);
DECLARE PATHNAME (15) BYTE INITIAL (':F0:ISIS.LAB   ');
DECLARE (MASK,TMASK) BYTE;

GOTO START; /* JUMP AROUND ERROR ROUTINE */
ERR:
  CALL WRITE(0,.('SYNTAX ERROR, REENTER COMMAND'),29,.STAT);
  CALL WRITE(0,.(CR,LF),2,.STAT);
  CALL WRITE(0,.('**'),2,.STAT);

START:

INPUT = 0; /* :F0: IS MASTER DRIVE , FOR DEFAULT*/
OUTPUT(0) = 1; /* :F1: IS COPY DRIVE, FOR DEFAULT*/
LOTRAK,HITRAK = 0FFH; /* SET FOR DEFAULT FLAG */
INTLEV$FLG = FALSE;
NOUT,MASK=0;

BUF0 = .MEMORY;
BUFPTR = BUF0;
CALL READ(1,BUF0,128,.ACTUAL,.STAT); /* CLEAR CONSOLE INPUT */
CALL FORCE$UPPER(BUF0);

/*
   COMMAND TAIL SCAN LOOP
*/

DO WHILE CHAR <> CR AND CHAR <>  LF;
  TPTR,BUFPTR = DEBLANK(BUFPTR);
  IF CHAR = ',' THEN GO TO ERR;
  IF CHAR = 'F' THEN
    DO;
      BUFPTR = DEBLANK(BUFPTR+1);
      IF CHAR = '=' THEN
      DO;
        BUFPTR = DEBLANK(BUFPTR+1);
        INPUT = SCAN$INTEGER(.BUFPTR);
      END;
    END;
  IF CHAR = 'T' THEN
  DO;
    BUFPTR = DEBLANK(BUFPTR+1);
    IF CHAR = '=' THEN
    DO;
      BUFPTR = BUFPTR+1;
      OUTPUT(NOUT) = SCAN$INTEGER(.BUFPTR);
      DO WHILE CHAR = ','; /* LOOK FOR OUTPUT DEVICE PARAMETERS */
        BUFPTR = DEBLANK(BUFPTR+1);
        NOUT = NOUT+1;
        IF NOUT = 4 THEN GOTO ERR;
        OUTPUT(NOUT) = SCAN$INTEGER(.BUFPTR);
      END;
    END;
  END;
  IF CHAR = '&' THEN
  DO;
    CALL WRITE(0,.('**'),2,.STAT);
    CALL READ(1,BUF0,128,.ACTUAL,.STAT);
    CALL FORCE$UPPER(BUF0);
    BUFPTR = BUF0;
  END;
  IF CHAR = 'V' THEN
  DO;
    TMASK = 2;
    BUFPTR = BUFPTR + 1;
    IF CHAR = 'O' THEN
    DO;
      TMASK = 1;
      BUFPTR = BUFPTR+1;
    END;
    MASK = MASK OR TMASK;
  END;
  IF CHAR = 'I' THEN
  DO;
    MASK = MASK OR 4;
    BUFPTR = DEBLANK(BUFPTR+1);
    IF CHAR = '=' THEN
    DO;
      INTLEV$FLG = TRUE; /* INTERLEAVE  PARAMETERS USER INPUT */
      BUFPTR = BUFPTR + 1;
      INTERLEAVE(0) = SCAN$INTEGER(.BUFPTR);
      I = 1;
      DO WHILE CHAR = ','; /* CHECK FOR INTERLEAVE PARAMETERS */
        BUFPTR = DEBLANK(BUFPTR+1);
        IF CHAR = '&' THEN
        DO;
          CALL WRITE(0,.('**'),2,.STAT);
          CALL READ(1,BUF0,128,.ACTUAL,.STAT);
          CALL FORCE$UPPER(BUF0);
          BUFPTR = BUF0;
        END;
        INTERLEAVE(I) = SCANINTEGER(.BUFPTR);
        I = I+1;
      END;

      J = I-1; /* INDEX OF LAST INTERLEAVE */
      DO I = I TO 76;
        INTERLEAVE(I) = INTERLEAVE(J);
      END;
    END;
  END;
  IF CHAR >= '0' AND CHAR <= '9' THEN
  DO;
    LOTRAK = SCAN$INTEGER(.BUFPTR);
    HITRAK = SCAN$INTEGER(.BUFPTR);
    IF HITRAK = 0 THEN HITRAK = LOTRAK; /* ONLY LOTRAK INPUT BY USER */
    IF LOTRAK < 0 OR HITRAK > 76 THEN GOTO ERR; /* ILLEGAL PARAMETER */
    IF HITRAK < LOTRAK THEN GOTO ERR;
  END;
IF TPTR=BUFPTR THEN BUFPTR = BUFPTR + 1;
END; /* END WHILE */

MASK = ATR(MASK); /* PROCESS ATTRIBUTES */
FORMAT$SW,COPY,VERIFY = TRUE; /* DEFAULT ATTRIBUTES */
IF (MASK AND 8) = 0 THEN FORMAT$SW = FALSE;
IF (MASK AND 4) = 0 THEN COPY = FALSE;
IF (MASK AND 2) = 0 THEN VERIFY = FALSE;
IF (MASK AND 1) = 1 THEN GOTO ERR;

IF LOTRAK = 0FFH THEN
DO;
  LOTRAK = 0;
  HITRAK = 76;
END;

$IF XVERSION
CALL WRITE(0,.('DCOPY X215'),10,.STAT);
$ELSE
CALL WRITE(0,.('DCOPY V2.2'),10,.STAT);
$ENDIF
CALL WRITE(0,.(CR,LF),2,.STAT);

PATHNAME(2) = INPUT + '0'; /* SET DEVICE NAME */
CALL SPATH(.PATHNAME,.BUF$IN,.STAT$IN); /* DETERMINE DRIVE TYPE
                                         BUF$IN(11) CONTAINS 1H FOR
                                         DOUBLE OR 2H FOR SINGLE DENSITY OR
                                         3H FOR INTEGRAL SINGLE DENSITY */

IF BUF$IN(11) = 01H THEN
DO;
  VAR = 52; 
  DISK$TYPE = TRUE; 
END;
ELSE IF BUF$IN(11) = 02H OR BUF$IN(11) = 03H THEN
DO;
  VAR = 26;
  DISK$TYPE = FALSE;
END;
ELSE DO;
  CALL WRITE(0,.('INVALID SOURCE DISK TYPE'),24,.STAT);
  CALL WRITE(0,.(CR,LF),2,.STAT);
  CALL EXIT;
END;

INDEX$INCR = 2;
NTRAK = 1; /* # OF TRACKS ABLE TO READ INTO MEM */
BUF1 = .MEMORY + (128*VAR*NTRAK);
OUTBUF(0) = INPUT + '0'; /* CONVERT SOURCE DRIVE # TO ASCII */
I = 0;
DO L = 0 TO NOUT; /* BUILD STRING CONTAINING DESTINATION DEVICE NUMBERS */
  TOBUF(I) = OUTPUT(L) + '0';
  TOBUF(I+1) = ',';
  I = I+2;
  TO$LENGTH = I-1; /* LENGTH OF DESTINATION DEVICE STRING */
END;

/*
  LOOP SO THAT 'DCOPY' DOES NOT NEED TO BE LOADED AFTER EACH
  DISK CREATION OR VERIFICATION
*/
LOOP:
IF FORMATSW THEN CALL WRITE(0,.('FORMAT '),7,.STAT);
IF COPY THEN CALL WRITE(0,.('COPY '),5,.STAT);
IF VERIFY THEN CALL WRITE(0,.('VERIFY'),6,.STAT);
CALL WRITE(0,.('  FROM = '),9,.STAT);
CALL WRITE(0,.OUTBUF,1,.STAT); /* WRITE INPUT DEVICE (FROM PARAMETER) */
CALL WRITE(0,.('  TO = '),7,.STAT);
CALL WRITE(0,.TOBUF,TO$LENGTH,.STAT); /* WRITE DESTINATION STRING */
CALL WRITE(0,.MSG,LENGTH(MSG),.STAT); /* LOAD DISKS, TYPE CR */
CALL READ(1,BUF0,122,.ACTUAL,.STAT); /* WAIT FOR HUMAN RESPONSE */
CALL FORCE$UPPER(BUF0);
BUFPTR = BUF0;
IF CHAR = 'E' THEN CALL EXIT; /* RETURN TO ISIS */
IF CHAR = 'E' THEN CALL MONITOR; /* ABOVE CALL EXECUTED BUT DRIVE 0
                                    IS NOT SYSTEM DISK, CALL MONITOR INSTEAD */
IF INTLEV$FLG = FALSE THEN
DO;
  CALL OPEN(.J,.PATHNAME,1,0,.I);
  IF I <>0 THEN DO; CALL ERROR(I); CALL EXIT; END;
  CALL READ(J,BUF1,128-77,.ACTUAL,.I);
  CALL READ(J,.INTERLEAVE,77,.ACTUAL,.I);
  CALL CLOSE(J,.I);
  DO I = 0 TO 76;
    INTERLEAVE(I) = INTERLEAVE(I) - '0';
  END;
END;
WLOTRAK = LOTRAK;

CALL DASH(LOTRAK);

/* COPY AND VERIFY LOOP */

DO TRACK = LOTRAK TO HITRAK ;
  IF (TRACK MOD 10) = 0 THEN CALL WRITE(0,.(' '),1,.STAT);
  CALL WRITE(0,.DIGITS(TRACK MOD 10),1,.STAT);
  IF TRACK = 39 THEN CALL WRITE(0,.(CR,LF),2,.STAT);

  /* ALWAYS READ IN 1 TRACK OF SOURCE */

  WBUF0 = BUF0;
  DCB(NSEC) = 1; /* READ 1 SEC AT A TIME */
  DCB(BNUM) = 0;
  DCB(IOINS) = READ$COMMAND;
  CALL GENSEC(INTERLEAVE(TRACK),VAR);
  DCB(TADR) = TRACK;
  INDEX = 0;
  INDEX$RESET = 1;
  DO I = 1 TO VAR;
    DCB(SADR) = SECTAB(INDEX);
    DCB(BUFL) = LOW(WBUF0);
    DCB(BUFU) = HIGH(WBUF0);
    CALL DISKIO(INPUT,.DCB); /* READ COMMAND */
    INDEX = INDEX + INDEX$INCR;
    IF INDEX >= VAR THEN
    DO;
      INDEX = INDEX$RESET;
      INDEX$RESET = INDEX$RESET + 1;
    END;
    WBUF0 = WBUF0 + 128;
  END;

  DO UNIT = 0 TO NOUT;
    /* TEST FOR SIMILIAR MEDIA TYPE */
    IF INPUT > 3 AND OUTPUT(UNIT) < 4 THEN GOTO ERR;
    IF INPUT < 4 AND OUTPUT(UNIT) > 3 THEN GOTO ERR;

    /* COPY TO OUTPUT(UNIT) IF COPY TRUE */
    IF COPY THEN
    DO;
      WBUF0 = BUF0;
      DCB(IOINS)= WRITE$COMMAND;
      DCB(TADR) = TRACK;
      INDEX = 0;
      INDEX$RESET = 1;
      IF FORMAT$SW THEN
      CALL FORMAT$TRACK(OUTPUT(UNIT),TRACK,TRACK,INTERLEAVE(TRACK));
      DO I = 1 TO VAR; /* WRITE A TRACK */
        DCB(SADR) = SECTAB(INDEX);
        DCB(BUFL) = LOW(WBUF0);
        DCB(BUFU) = HIGH(WBUF0);
        CALL DISKIO(OUTPUT(UNIT),.DCB);
        INDEX = INDEX + INDEX$INCR;
        IF INDEX >= VAR THEN
        DO;
          INDEX = INDEX$RESET;
          INDEX$RESET = INDEX$RESET + 1;
        END;
        WBUF0 = WBUF0 + 128;
      END;
    END;

    /* REREAD, IF VERIFY TRUE, FROM COPY DISK INTO WBUF1, VERIFY
       AGAINST WBUF0 */

    IF VERIFY THEN
    DO;
      WBUF1 = BUF1;
      DCB(TADR) = TRACK;
      DCB(IOINS) = READ$COMMAND;
      INDEX = 0;
      INDEX$RESET = 1;
      DO I = 1 TO VAR;
        DCB(SADR) = SECTAB(INDEX);
        DCB(BUFL) = LOW(WBUF1);
        DCB(BUFU) = HIGH(WBUF1);
        CALL DISKIO(OUTPUT(UNIT),.DCB); /* READ COMMAND */
        INDEX = INDEX + INDEX$INCR;
        IF INDEX >= VAR THEN
        DO;
          INDEX = INDEX$RESET;
          INDEX$RESET = INDEX$RESET + 1;
        END;
        WBUF1 = WBUF1 + 128;
      END;

      /* COMPARE MASTER TO REREAD OF WRITTEN DATA */

      MISCOMPARE = FALSE;
      WBUF0 = BUF0;
      WBUF1 = BUF1;
      DO SECTOR = 0 TO (VAR-1);
        J = 128*SECTOR + 127;
        DO I = J-127 TO J;
          IF CHAR0(I) <> CHAR1(I) THEN
          DO;
            MISCOMPARE = TRUE;
            I = J + 1; /* GO TO NEXT SECTOR */
            CALL WRITE(0,.(CR,LF),2,.STAT);
            CALL WRITE(0,.('DRIVE '),6,.STAT);
            DRV = OUTPUT(UNIT) + '0';
            CALL WRITE(0,.DRV,1,.STAT);
            CALL NUMOUT(TRACK,10,0,BUF1,4);
            CALL WRITE(0,.(' TRACK '),7,.STAT);
            CALL WRITE(0,BUF1,4,.STAT);
            CALL WRITE(0,.('  '),2,.STAT);
            CALL NUMOUT(SECTOR+1,16,'0',BUF1,4);
            CALL WRITE(0,BUF1,4,.STAT);
            CALL WRITE(0,.('H SECTOR MISCOMPARES'),20,.STAT);
          END;
        END;
      END;

      CHAR1(0) = 0;
      IF MISCOMPARE THEN
      DO WHILE CHAR1(0) <> 'C';
        CALL WRITE(0,.(CR,LF,'*'),3,.STAT);
        CALL READ(1,.CHAR1(0),128,.ACTUAL,.STAT);
        CALL FORCE$UPPER(.CHAR1(0));
        IF CHAR1(0) = 'E' THEN GOTO LOOP;
        IF CHAR1(0) >= 30H AND CHAR1(0) <= 39H THEN
        DO;
          CALL JREAD(.CHAR1(0));
          CALL DUMP;
        END;
      END;
      IF (CHAR1(0)='C') AND MISCOMPARE THEN
      DO;
        WLOTRAK = TRACK;
        IF UNIT = NOUT THEN WLOTRAK = WLOTRAK+1;
        CALL DASH(WLOTRAK);
        IF UNIT < NOUT THEN
        DO;
          IF (TRACK MOD 10) = 0 THEN CALL WRITE(0,.(' '),1,.STAT);
          CALL WRITE(0,.DIGITS(TRACK MOD 10),1,.STAT);
          IF TRACK = 39 THEN CALL WRITE(0,.(CR,LF),2,.STAT);
        END;
        GO TO RESTART;
      END;
    END; /* END IF VERIFY LOOP */

RESTART:
  END; /* END OF MULTIPLE OUTPUT DEVICE LOOP */
  END; /* END OF TRACK LOOP */
  IF HITRAK <> 76 THEN
  DO TRACK = HITRAK+1 TO 76;
    IF (TRACK MOD 10) = 0 THEN CALL WRITE(0,.(' '),1,.STAT);
    CALL WRITE(0,.('-'),1,.STAT);
    IF TRACK = 39 THEN CALL WRITE(0,.(CR,LF),2,.STAT);
  END;
  CALL WRITE(0,.(CR,LF),2,.STAT);

GO TO LOOP;

CALL EXIT;

END;
src/divide.asm
;     'Copyright 1981,1983 Intel Corporation'.  All rights reserved.
;      No part of this program or publication may be reproduced,
;      transmitted, transcribed, stored in a retrievel system, or
;      translated into any language or computer language, in any
;      form or by any means, electronic, mechanical, magnetic,
;      optical, chemical, manual or otherwise, without the prior
;      written permission of Intel Corporation, 3065 Bowers
;      Avenue, Santa Clara, California, 95051, Attn: Software
;      License Administration.
	CSEG
	PUBLIC DIVIDE
DIVIDE: PUSH PSW
	PUSH H
	LXI H,0 ; ANSWER = 0
	SHLD ANS
	LXI H,1 ;HL =1
; WHILE DE <= BC
LOOP1:  MOV A,D
	CMP B
	JC DN1
	JZ DN2
	JMP LOOP2
DN2:	MOV A,C
	CMP E
	JC LOOP2
DN1:	ANA A ; SHIFT HL RIGHT
	MOV A,L
	RAL
	MOV L,A
	MOV A,H
	RAL
	MOV H,A
	ANA A ; SHIFT DE LEFT
	MOV A,E
	RAL
	MOV E,A
	MOV A,D
	RAL
	MOV D,A
	JMP LOOP1
LOOP2:  ANA A ; SHIFT HL RIGHT
	MOV A,H
	RAR
	MOV H,A
	MOV A,L
	RAR
	MOV L,A
	JC RETURN ; IF HL = 0 RETURN
	ANA A ; SHIFT DE RIGHT
	MOV A,D
	RAR
	MOV D,A
	MOV A,E
	RAR
	MOV E,A
	MOV A,D ; IF DE <= BC
	CMP B
	JZ DIV3
	JNC LOOP2
	JMP DIV2
DIV3:	MOV A,C
	CMP E
	JC LOOP2
DIV2:   MOV A,C ; BC := BC - DE
	SUB E
	MOV C,A
	MOV A,B
	SBB D
	MOV B,A
	LDA ANS ; ANS := ANS + HL
	ADD H
	STA ANS
	LDA ANS + 1
	ADD L
	STA ANS + 1
	JMP LOOP2
RETURN: LHLD ANS
	MOV E,H
	MOV D,L
	POP H
	POP PSW
	RET
	
    DSEG
ANS:	DS 2 ; THE ANSWER IS ACCUMULATED HERE
    END
src/dsort.plm
DSORT:
DO;

/************************************************************************/
/*																		*/
/*     'Copyright 1981,1983 Intel Corporation'.  All rights reserved.	*/
/*      No part of this program or publication may be reproduced,		*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

$IF XVERSION
DECLARE PROPRIETARY(*) BYTE DATA ('INTEL PROPRIETARY SOFTWARE');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=X323',0);
$ELSE
DECLARE COPYRIGHT (*) BYTE DATA  ('COPYRIGHT 1981,1983 INTEL ');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V3.3',0);
$ENDIF


  /*********************************************************************

                          DSORT V3.2

     THIS PROGRAM SORTS A DIRECTORY ON AN ISIS-II FLOPPY OR HARD DISK.
     IT ASSUMES THAT THE HEADER BLOCK FOR THE ISIS.DIR FILE STARTS ON
     TRACK 1, SECTOR 1.  IF THAT EVER CHANGES, THEN THIS PROGRAM MUST
     ALSO CHANGE.
     THE SORTING ALGORITHM USED IS 'HEAPSORT', GIVEN ON PAGE 146,
     VOLUME 3, THE ART OF COMPUTER PROGRAMMING, BY KNUTH.

     CAPABILITY ADDED FOR SORTING ON DIFFERENT FIELDS.

  **********************************************************************/

  READ:   PROCEDURE(A,B,C,D,E) EXTERNAL; DECLARE(A,B,C,D,E) ADDRESS; END;
  WRITE:  PROCEDURE(A,B,C,D)   EXTERNAL; DECLARE(A,B,C,D)   ADDRESS; END;
  SPATH:  PROCEDURE(A,B,C)     EXTERNAL; DECLARE(A,B,C)     ADDRESS; END;
  EXIT:   PROCEDURE            EXTERNAL;                             END;
  MEMCK:  PROCEDURE ADDRESS    EXTERNAL;                             END;
  DEBLANK:PROCEDURE(A) ADDRESS EXTERNAL; DECLARE(A)         ADDRESS; END;
  ABSIO:  PROCEDURE(A,B,C,D)   EXTERNAL; DECLARE(A,B) BYTE,(C,D) ADDRESS; END;

  DECLARE BOOLEAN LITERALLY 'BYTE', TRUE LITERALLY '0FFH', FALSE LITERALLY '0';
  DECLARE CR LITERALLY '0DH', LF LITERALLY '0AH';
  DECLARE DIR$ENTRY LITERALLY
    'STRUCTURE(FN(10) BYTE, ATTRIB BYTE, EOF$COUNT BYTE,
     BLK$COUNT ADDRESS, HDR$BLK$SEC BYTE, HDR$BLK$TRK BYTE)';
  
  DECLARE FOREVER LITERALLY 'WHILE 1';
  DECLARE ISIS$DIR$BLK LITERALLY '0101H';
  DECLARE DISK$READ LITERALLY '4';
  DECLARE DISK$WRITE LITERALLY '6';
  
$IF XVERSION
  DECLARE SIGNON(*) BYTE DATA('ISIS-II Disk Directory Sorter X323', CR, LF);
$ELSE
  DECLARE SIGNON(*) BYTE DATA('ISIS-II Disk Directory Sorter V3.3', CR, LF);
$ENDIF
  
  DECLARE SYNMSG(*) BYTE DATA(
  'Command error, syntax is: DSORT <drive no> <E | L | S>', CR, LF);
  
  DECLARE MEMMSG(*) BYTE DATA('Insufficient memory to hold directory', CR, LF);
  DECLARE ISIS$DIR(*) BYTE INITIAL (':Fx:ISIS.DIR ');
  DECLARE DIR(1) DIR$ENTRY AT (.MEMORY);
  DECLARE SAVE DIR$ENTRY AT (.MEMORY);
  DECLARE DIR$PTR ADDRESS;
  DECLARE PTR$BLK(64) ADDRESS;
  DECLARE DATA$BLK$INDEX BYTE;
  DECLARE DISK BYTE;
  DECLARE (ACTUAL, STATUS) ADDRESS;
  DECLARE (X, L, R, NUM$ENTRIES) ADDRESS;

  DECLARE (CHAR BASED X) BYTE;
  DECLARE CMP$RESULT BOOLEAN;
  DECLARE THE$COMPARE ADDRESS;		/* THE PARTICULAR COMPARISON TO DO */

  NORM$CMP: PROCEDURE(APTR, BPTR);
    /*
     * THE NORMAL DSORT COMPARISON -
     *   SET CMP$RESULT TRUE IF THE DIRECTORY ENTRY ASSOCIATED WITH APTR IS
     *   'LESS THAN' THE DIRECTORY ENTRY ASSOCIATED WITH BPTR
     */

    DECLARE (APTR, BPTR) ADDRESS;
    DECLARE (A BASED APTR) DIR$ENTRY;
    DECLARE (B BASED BPTR) DIR$ENTRY;
    DECLARE I BYTE;

    I = 0;
    DO WHILE (I < 9) AND (A.FN(I) = B.FN(I));   /* COMPARE FILE NAMES */
      I = I + 1;
    END;
    CMP$RESULT =  (A.FN(I) < B.FN(I));
  END NORM$CMP;

  EXT$CMP: PROCEDURE(APTR, BPTR);
    /*
     * THE EXTENSION DSORT COMPARISON -
     *   SETS CMP$RESULT TRUE IF THE EXTENSION OF THE DIRECTORY ENTRY
     *   ASSOCIATED WITH APTR IS 'LESS THAN' THE EXTENSION OF THE DIRECTORY
     *   ENTRY ASSOCIATED WITH BPTR
     */

    DECLARE (APTR, BPTR) ADDRESS;
    DECLARE (A BASED APTR) DIR$ENTRY;
    DECLARE (B BASED BPTR) DIR$ENTRY;
    DECLARE I BYTE;

    I = 7;
    DO WHILE (I < 9) AND (A.FN(I) = B.FN(I));   /* COMPARE EXTENSIONS */
      I = I + 1;
    END;
    IF (A.FN(I) = B.FN(I)) THEN CALL NORM$CMP(A$PTR,B$PTR);
    				/* EXTENSION IS SAME, SO COMPARE NORMALLY */
    ELSE CMP$RESULT = (A.FN(I) < B.FN(I));
  END EXT$CMP;

  SIZE$CMP: PROCEDURE(APTR, BPTR);
    /*
     * THE SIZE DSORT COMPARISON -
     *   SETS CMP$RESULT TRUE IF THE SIZE OF THE DIRECTORY ENTRY
     *   ASSOCIATED WITH APTR IS 'LESS THAN' THE SIZE OF THE DIRECTORY
     *   ENTRY ASSOCIATED WITH BPTR. THE COMPARISON CONSIDERS ONLY THE
     *   BLK$COUNT AND EOF$COUNT FIELDS OF THE DIRECTORY ENTRY.
     */

    DECLARE (APTR, BPTR) ADDRESS;
    DECLARE (A BASED APTR) DIR$ENTRY;
    DECLARE (B BASED BPTR) DIR$ENTRY;

    IF (A.BLK$COUNT = B.BLK$COUNT) THEN DO;
       IF (A.EOF$COUNT = B.EOF$COUNT) THEN
           CALL NORM$CMP(A$PTR,B$PTR);
    				/* SIZE IS SAME, SO COMPARE NORMALLY */
       ELSE CMP$RESULT = (A.EOF$COUNT < B.EOF$COUNT);
    END;
    ELSE CMP$RESULT = (A.BLK$COUNT < B.BLK$COUNT);
  END SIZE$CMP;

  LOC$CMP: PROCEDURE(APTR, BPTR);
    /*
     * THE LOCATION DSORT COMPARISON -
     *   SETS CMP$RESULT TRUE IF THE LOCATION OF THE DIRECTORY ENTRY
     *   ASSOCIATED WITH APTR IS 'LESS THAN' THE LOCATION OF THE DIRECTORY
     *   ENTRY ASSOCIATED WITH BPTR. THE COMPARISON CONSIDERS ONLY THE
     *   POINTER BLOCK OF THE FIRST DATA SECTOR.
     */

    DECLARE (APTR, BPTR) ADDRESS;
    DECLARE (A BASED APTR) DIR$ENTRY;
    DECLARE (B BASED BPTR) DIR$ENTRY;

    IF (A.HDR$BLK$TRK = B.HDR$BLK$TRK) THEN DO;
       IF (A.HDR$BLK$SEC = B.HDR$BLK$SEC) THEN
           CALL NORM$CMP(A$PTR,B$PTR);
    				/* LOCATION IS SAME, SO COMPARE NORMALLY */
       ELSE CMP$RESULT = (A.HDR$BLK$SEC < B.HDR$BLK$SEC);
    END;
    ELSE CMP$RESULT = (A.HDR$BLK$TRK < B.HDR$BLK$TRK);
  END LOC$CMP;

  A$LT$B: PROCEDURE(APTR, BPTR) BOOLEAN;
    /** RETURNS TRUE IF THE DIRECTORY ENTRY ASSOCIATED WITH APTR IS ***
    *** 'LESS THAN' THE DIRECTORY ENTRY ASSOCIATED WITH BPTR        **/

    DECLARE (APTR, BPTR) ADDRESS;
    DECLARE (A BASED APTR) DIR$ENTRY;
    DECLARE (B BASED BPTR) DIR$ENTRY;
    DECLARE (AFMT, BFMT) BOOLEAN;
    DECLARE I BYTE;

    AFMT = (A.ATTRIB AND 80H) <> 0;     /* AFMT := TRUE IFF FORMAT FILE */
    BFMT = (B.ATTRIB AND 80H) <> 0;     /* BFMT LIKEWISE */
    IF AFMT AND NOT BFMT THEN RETURN TRUE;
    IF BFMT AND NOT AFMT THEN RETURN FALSE;

    CALL THE$COMPARE(A$PTR,B$PTR);	/* DO THE COMPARE */
    RETURN (CMP$RESULT);
  END A$LT$B;

  MOVE$B$TO$A: PROCEDURE(APTR, BPTR);
    /** MOVES THE DIRECTORY ENTRY ASSOCIATED WITH APTR TO THE ***
    *** DIRECTORY ENTRY ASSOCIATED WITH BPTR                  **/

    DECLARE (APTR, BPTR) ADDRESS;
    DECLARE (A BASED APTR) DIR$ENTRY;
    DECLARE (B BASED BPTR) DIR$ENTRY;
    DECLARE I BYTE;

    A.FN(0) = B.FN(0);
    A.FN(1) = B.FN(1);
    A.FN(2) = B.FN(2);
    A.FN(3) = B.FN(3);
    A.FN(4) = B.FN(4);
    A.FN(5) = B.FN(5);
    A.FN(6) = B.FN(6);
    A.FN(7) = B.FN(7);
    A.FN(8) = B.FN(8);
    A.FN(9) = B.FN(9);
    A.ATTRIB = B.ATTRIB;
    A.EOF$COUNT = B.EOF$COUNT;
    A.BLK$COUNT = B.BLK$COUNT;
    A.HDR$BLK$SEC = B.HDR$BLK$SEC;
    A.HDR$BLK$TRK = B.HDR$BLK$TRK;
  END MOVE$B$TO$A;

  SIFT: PROCEDURE(J);
    /** SIFT THE DIRECTORY ENTRY STORED IN 'SAVE' DOWNWARDS TO ***
    *** ITS PROPER PLACE IN THE HEAP. BEGIN THE COMPARISONS    ***
    *** WITH THE ENTRY INDEXED BY J                            **/

    DECLARE (I, J) ADDRESS;

    DO FOREVER;
      I = J;
      J = J + J;
      IF J <= R THEN DO;
        IF J < R THEN DO;
          IF A$LT$B(.DIR(J), .DIR(J + 1)) THEN J = J + 1;
        END;
        IF A$LT$B(.SAVE, .DIR(J)) THEN
          CALL MOVE$B$TO$A(.DIR(I), .DIR(J));
        ELSE DO;
          CALL MOVE$B$TO$A(.DIR(I), .SAVE);
          RETURN;
        END;
      END;
      ELSE DO;  /* J > R */
        CALL MOVE$B$TO$A(.DIR(I), .SAVE);
        RETURN;
      END;
    END;     /* FOREVER LOOP */
  END SIFT;

  REWIND$DIR: PROCEDURE;
    CALL ABSIO(DISK$READ, DISK, ISIS$DIR$BLK, .PTR$BLK);
    DIR$PTR = .DIR(1);
    DATA$BLK$INDEX = 1;
  END REWIND$DIR;

  NEXT$SECTOR: PROCEDURE;
    DATA$BLK$INDEX = DATA$BLK$INDEX + 1;
    IF DATA$BLK$INDEX > LAST(PTR$BLK) THEN DO;  /* END OF POINTER BLOCK */
      DATA$BLK$INDEX = 2;
      IF PTR$BLK(1) = 0 THEN  /* END OF FILE */
        RETURN;
      CALL ABSIO(DISK$READ, DISK, PTR$BLK(1), .PTR$BLK);
    END;
  END NEXT$SECTOR;

  MORE$ENTRIES: PROCEDURE BOOLEAN;
    IF DIR(NUM$ENTRIES).FN(0) = 7FH THEN
      RETURN FALSE;
    CALL NEXT$SECTOR;
    RETURN PTR$BLK(DATA$BLK$INDEX) <> 0;
  END MORE$ENTRIES;

  CALL WRITE(0, .SIGNON, LENGTH(SIGNON), .STATUS);
  CALL READ(1, .MEMORY, 122, .ACTUAL, .STATUS);   /* READ COMMAND TAIL */
  THE$COMPARE = .NORM$CMP;
  X = DEBLANK(.MEMORY);
  ISIS$DIR(2) = CHAR;
  X = DEBLANK(X + 1);
  IF CHAR = 'E' OR CHAR = 'e' THEN THE$COMPARE = .EXT$CMP;
  IF CHAR = 'S' OR CHAR = 's' THEN THE$COMPARE = .SIZE$CMP;
  IF CHAR = 'L' OR CHAR = 'l' THEN THE$COMPARE = .LOC$CMP;
  CALL SPATH(.ISIS$DIR, .MEMORY, .STATUS);   /* VALIDATE DRIVE NUMBER */
  IF (STATUS <> 0) THEN DO;
    /* NO DRIVE SPECIFIED OR INVALID SPECIFICATION */
    CALL WRITE(0, .SYNMSG, LENGTH(SYNMSG), .STATUS);
    CALL EXIT;
  END;

  /* READ IN THE ISIS.DIR FILE */

  DISK = ISIS$DIR(2) - '0';

  NUM$ENTRIES = 0;
  DIR(0).FN(0) = 0;
  CALL REWIND$DIR;
  DO WHILE MORE$ENTRIES;
    CALL ABSIO(DISK$READ, DISK, PTR$BLK(DATA$BLK$INDEX), DIR$PTR);
    DIR$PTR = DIR$PTR + 128;
    IF DIR$PTR > MEMCK THEN DO;  /* OUT OF MEMORY */
      CALL WRITE(0, .MEMMSG, LENGTH(MEMMSG), .STATUS);
      CALL EXIT;
    END;
    NUM$ENTRIES = NUM$ENTRIES + 8;  /* COUNT ENTRIES */
  END;
  ACTUAL = DIR$PTR;
  DO WHILE DIR(NUM$ENTRIES).FN(0) = 7FH;
    NUM$ENTRIES = NUM$ENTRIES - 1;
  END;

  /* BEGIN HEAPSORT */

  L = (NUM$ENTRIES / 2) + 1;
  R = NUM$ENTRIES;

  DO WHILE L > 1;   /* FORM ARRAY INTO A HEAP */
    L = L - 1;
    CALL MOVE$B$TO$A(.SAVE, .DIR(L));
    CALL SIFT(L);
  END;

  DO WHILE R > 1;   /* CONSTRUCT SORTED ARRAY */
    CALL MOVE$B$TO$A(.SAVE, .DIR(R));
    CALL MOVE$B$TO$A(.DIR(R), .DIR(1));
    R = R - 1;
    CALL SIFT(1);
  END;

  /* DEALLOCATE THE DELETED FILES */
  DO WHILE DIR(NUM$ENTRIES).FN(0);
    DIR(NUM$ENTRIES).FN(0) = 7FH;
    NUM$ENTRIES = NUM$ENTRIES - 1;
  END;

  /* WRITE THE ISIS.DIR FILE OUT */
  CALL REWIND$DIR;
  DO WHILE DIR$PTR < ACTUAL;
    CALL NEXT$SECTOR;
    CALL ABSIO(DISK$WRITE, DISK, PTR$BLK(DATA$BLK$INDEX), DIR$PTR);
    DIR$PTR = DIR$PTR + 128;
  END;
  CALL EXIT;
END DSORT;
src/else.plm
ELSE$MOD: DO;

/************************************************************************/
/*																		*/
/*     'Copyright 1981,1983 Intel Corporation'.  All rights reserved.	*/
/*      No part of this program or publication may be reproduced,		*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

$IF XVERSION
DECLARE PROPRIETARY(*) BYTE DATA ('INTEL PROPRIETARY SOFTWARE');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=X103',0);
$ELSE
DECLARE COPYRIGHT (*) BYTE DATA  ('COPYRIGHT 1981,1983 INTEL ');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.1',0);
$ENDIF


DECLARE	LIT		LITERALLY	'LITERALLY',
		DCL		LIT	'DECLARE',
		TRUE	LIT	'0FFH',
		FALSE	LIT	'000H',
		PROC	LIT	'PROCEDURE',
		PROCEND	LIT	'END',
		THENDO	LIT	'THEN DO;',
		ELSEIF	LIT	'END; ELSE IF',
		ELSEDO	LIT	'END; ELSE DO;',
		IFEND	LIT	'END',
		WHILEND	LIT	'END',
		CR		LIT	'0DH',
		LF		LIT	'0AH';

EXIT:	PROC EXTERNAL;											PROCEND;
READ:	PROC (A,B,C,D,E) EXTERNAL;	DCL (A,B,C,D,E) ADDRESS;	PROCEND;
WRITE:	PROC (A,B,C,D) EXTERNAL;	DCL (A,B,C,D) ADDRESS;		PROCEND;
SPATH:	PROC (A,B,C) EXTERNAL;		DCL (A,B,C) ADDRESS;		PROCEND;
DEBLANK:PROC (A) ADDRESS EXTERNAL;	DCL (A) ADDRESS;			PROCEND;
SEQ:	PROC (A,B,C) BYTE EXTERNAL;	DCL (A,B,C) ADDRESS;		PROCEND;
FORCE$UPPER:	PROC(A) EXTERNAL;	DCL (A) ADDRESS;			PROCEND;

DCL (STATUS, ACTUAL, AFTN1, AFTN2) ADDRESS;
DCL (CMND, CMND$PTR) ADDRESS, (CMND$CH BASED CMND$PTR) (1) BYTE;
DCL (PN1) STRUCTURE
	(DEV BYTE, NAME (6) BYTE, EXT (3) BYTE, DEV$TYPE BYTE, DRIVE$TYPE BYTE);
DCL (NESTED$IF) ADDRESS;

CALL READ (1, .MEMORY, 128, .ACTUAL, .STATUS); /* Skip command tail. */
NESTED$IF = 0;
DO WHILE TRUE;
	CALL WRITE (0, .('#'), 1, .STATUS);
	CALL READ (1, .MEMORY, 128, .ACTUAL, .STATUS);
	IF (STATUS <> 0) OR (ACTUAL = 0) THENDO
		CALL EXIT; /* Probably hit the end of the command file. */
	IFEND;
	MEMORY (ACTUAL - 1) = CR;
	CALL FORCE$UPPER (.MEMORY);
	CMND$PTR = DEBLANK (.MEMORY);
	IF SEQ (CMND$PTR, .('DEBUG '), 6) THENDO
		CMND$PTR = DEBLANK (CMND$PTR + 5); /* Skip the DEBUG. */
	IFEND;
	CALL SPATH (CMND$PTR, .PN1, .STATUS);
	IF STATUS = 0 THENDO
		IF SEQ (.PN1.NAME, .('IF', 0, 0, 0, 0, 0, 0, 0), 9) THENDO
			NESTED$IF = NESTED$IF + 1;
		ELSEIF SEQ (.PN1.NAME, .('ENDIF', 0, 0, 0, 0), 9) THENDO
			IF NESTED$IF = 0 THENDO
				CALL EXIT; /* Continue with the ENDIF part. */
			IFEND;
			NESTED$IF = NESTED$IF - 1;
		IFEND;
	IFEND;
WHILEND;

END ELSE$MOD;
src/endif.plm
ENDIF$MOD:DO;

/************************************************************************/
/*																		*/
/*     'Copyright 1981,1983 Intel Corporation'.  All rights reserved.	*/
/*      No part of this program or publication may be reproduced,		*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

$IF XVERSION
DECLARE PROPRIETARY(*) BYTE DATA ('INTEL PROPRIETARY SOFTWARE');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=X103',0);
$ELSE
DECLARE COPYRIGHT (*) BYTE DATA  ('COPYRIGHT 1981,1983 INTEL ');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.1',0);
$ENDIF



EXIT:PROCEDURE EXTERNAL;END;

CALL EXIT;

END;
src/errmsg.plm
$ TITLE('==> PASSIF -- ERRMSGMOD -- ERROR MESSAGE MODULE <==')

ERR$MSG$MOD:
DO;

/************************************************************************/
/*																		*/
/*     'Copyright 1981,1983 Intel Corporation'.  All rights reserved.	*/
/*      No part of this program or publication may be reproduced,		*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/


/*         LIT.INC          */

DECLARE					AS LITERALLY 'LITERALLY',
	PUB$STRING			AS '(*) BYTE PUBLIC DATA';

/*        ENDLIT.INC        */

/************************************************************/
/*															*/
/*           ERROR                MESSAGES                  */
/*															*/
/************************************************************/

DECLARE

	BAD$SYNTAX$MSG PUB$STRING
		('syntax error in command tail',0),

    BOMB$IF$MSG$1 PUB$STRING
		('Isis error ',0),

    BOMB$IF$MSG$2 PUB$STRING
        (' detected while processing report file.',0),

    DURING$ASSERTION$CHECK$MSG PUB$STRING
    	(' encountered while performing assertion checking.',0),

    PASSIF$INVOKED$BY$MSG PUB$STRING
    	('Passif invoked by:',0),

    ZERO$LENGTH$FILE$MSG PUB$STRING
    	('illegal file of zero length encountered',0);

END
ERR$MSG$MOD;
src/errs.plm
ERRS: 
DO;

/************************************************************************/
/*																		*/
/*     'Copyright 1981,1983 Intel Corporation'.  All rights reserved.	*/
/*      No part of this program or publication may be reproduced,		*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

$IF XVERSION
DECLARE PROPRIETARY(*) BYTE DATA ('INTEL PROPRIETARY SOFTWARE');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=X104',0);
$ELSE
DECLARE COPYRIGHT (*) BYTE DATA  ('COPYRIGHT 1981,1983 INTEL ');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.1',0);
$ENDIF

    

/* PEX */
DECLARE SCANP ADDRESS EXTERNAL;
DECLARE SCANBYTE BASED SCANP BYTE;
DECLARE TARLEN BYTE EXTERNAL;
DECLARE GIVEUP ADDRESS EXTERNAL;
CONSOLEIN :PROCEDURE  EXTERNAL;END;
FMOVE :PROCEDURE (ZZ1,ZZ2,ZZ3) EXTERNAL;DECLARE (ZZ1,ZZ2,ZZ3)ADDRESS;END;
PRINT :PROCEDURE (ZZ1) EXTERNAL;DECLARE (ZZ1)ADDRESS;END;
SCANWHILEBLANKS :PROCEDURE  EXTERNAL;END;
SETSC :PROCEDURE (ZZ1) EXTERNAL;DECLARE (ZZ1)ADDRESS;END;
SFOUND :PROCEDURE BYTE EXTERNAL;END;
DECLARE FATAL BYTE EXTERNAL;
DECLARE ACTUAL ADDRESS EXTERNAL;
CI :PROCEDURE BYTE EXTERNAL;END;
EX :PROCEDURE  EXTERNAL;END;
MEMCK :PROCEDURE ADDRESS EXTERNAL;END;
OPENI :PROCEDURE (ZZ1) EXTERNAL;DECLARE (ZZ1)ADDRESS;END;
READI :PROCEDURE (ZZ1,ZZ2) EXTERNAL;DECLARE (ZZ1,ZZ2)ADDRESS;END;
WRITEC :PROCEDURE (ZZ1,ZZ2) EXTERNAL;DECLARE (ZZ1,ZZ2)ADDRESS;END;
DECLARE FALSE LITERALLY'0';
DECLARE TRUE LITERALLY'255';
DECLARE CONTROL$C LITERALLY '03H';
/* ENDPEX */

DECLARE NOT$FIRST$TIME BYTE INITIAL (FALSE);
DECLARE READ$FINISHED BYTE INITIAL (FALSE);
DECLARE CLEAR$SCREEN (*) BYTE DATA (1DH,1FH,           /* DATAPOINT */
                                    1BH,'H',1BH,'M',   /* OMRON */
                                    7EH,1CH,           /* H-1510 */
                                    0CH,               /* H-1200 & VISITAR */
                                    1BH,'E',           /* BEEHIVE & EMDS */
                                    0DH,0AH,0);
DECLARE LINES BYTE;
DECLARE LINE$COUNT BYTE;
DECLARE TEMP ADDRESS;
DECLARE CAPACITY ADDRESS;
DECLARE TARGET(10) BYTE PUBLIC DATA (0AH,'*** ?????');

WAIT: PROCEDURE;
  IF NOT$FIRST$TIME THEN
   DO;
    IF ((CI AND 7FH) = CONTROL$C) THEN
     DO;
      CALL PRINT(.CLEAR$SCREEN(11)); /* CRLF */
      CALL EX;
     END;
   END;
  NOT$FIRST$TIME = TRUE;
END;

BUMP$LINES: PROCEDURE;
  IF ((LINE$COUNT := LINE$COUNT + 1) = 80) OR
     SCAN$BYTE = 0AH THEN
   DO;
    LINE$COUNT = 0;
    LINES = LINES + 1;
   END;
END;

FLUSH: PROCEDURE;
  TEMP = .MEMORY + GIVEUP - SCAN$P;
  CALL FMOVE(GIVEUP - SCAN$P, SCAN$P, .MEMORY);
  CAPACITY = MEMCK - TEMP;
  CALL READI(TEMP,CAPACITY);
  READ$FINISHED = (ACTUAL < CAPACITY);
  SCAN$P = .MEMORY;
  GIVEUP = TEMP + ACTUAL;
END;

BACK$PTR: PROCEDURE ADDRESS;
  CALL SET$SC(SCAN$P);
  LINES = 0;
  LINE$COUNT = 0;
   DO WHILE LINES < 5;
    IF (SCAN$P := SCAN$P - 1) = .MEMORY THEN RETURN .MEMORY;
    CALL BUMP$LINES;
   END;
  RETURN SCAN$P;
END;

FORWARD$PTR: PROCEDURE;
  LINES = 0;
  LINE$COUNT = 0;
   DO WHILE LINES < 15;
    IF (SCAN$P := SCAN$P + 1) = GIVE$UP THEN RETURN;
    CALL BUMP$LINES;
   END;
END;

FATAL = TRUE;
CALL CONSOLE$IN;
CALL SCAN$WHILE$BLANKS;
CALL OPENI(SCAN$P);
GIVE$UP = (SCAN$P := .MEMORY);
TARLEN = 9;
 DO WHILE NOT READ$FINISHED;
  CALL FLUSH;
SFOUND$LOOP:
  IF SFOUND THEN
   DO;
    CALL WAIT;
    CALL PRINT(.CLEAR$SCREEN);
    TEMP = BACK$PTR;
    CALL FORWARD$PTR;
    CALL WRITEC(TEMP, SCAN$P-TEMP);
    IF READ$FINISHED THEN
     DO;
      IF SCAN$P = GIVE$UP THEN CALL EX;
     END;
    ELSE IF SCAN$P  > GIVE$UP - 2048 THEN CALL FLUSH;
    GO TO SFOUND$LOOP;
   END;
  ELSE SCAN$P = GIVE$UP;
 END;
CALL WAIT;
CALL PRINT(.CLEAR$SCREEN);
CALL WRITEC(GIVEUP-223,223);
CALL EX;

END 
ERRS;
src/exit.plm
EXIT$MOD: DO;

/************************************************************************/
/*																		*/
/*     'Copyright 1981,1983 Intel Corporation'.  All rights reserved.	*/
/*      No part of this program or publication may be reproduced,		*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

$IF XVERSION
DECLARE PROPRIETARY(*) BYTE DATA ('INTEL PROPRIETARY SOFTWARE');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=X103',0);
$ELSE
DECLARE COPYRIGHT (*) BYTE DATA  ('COPYRIGHT 1981,1983 INTEL ');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.1',0);
$ENDIF


DECLARE	LIT		LITERALLY	'LITERALLY',
		DCL		LIT	'DECLARE',
		TRUE	LIT	'0FFH',
		FALSE	LIT	'000H',
		PROC	LIT	'PROCEDURE',
		PROCEND	LIT	'END',
		THENDO	LIT	'THEN DO;',
		ELSEIF	LIT	'END; ELSE IF',
		ELSEDO	LIT	'END; ELSE DO;',
		IFEND	LIT	'END',
		WHILEND	LIT	'END',
		CR		LIT	'0DH',
		LF		LIT	'0AH';

EXIT:	PROC EXTERNAL;											PROCEND;
READ:	PROC (A,B,C,D,E) EXTERNAL;	DCL (A,B,C,D,E) ADDRESS;	PROCEND;
CONSOL:	PROC (A,B,C) EXTERNAL;		DCL (A,B,C) ADDRESS;		PROCEND;
IOCHK:	PROC BYTE EXTERNAL;										PROCEND;

DCL (STATUS, ACTUAL) ADDRESS;
DCL (FILE1, FILE2) (15) BYTE;
DCL (COLD$START$CO) BYTE;

CALL READ (1, .MEMORY, 128, .ACTUAL, .STATUS); /* Skip command tail. */
COLD$START$CO = IOCHK AND 3;
IF COLD$START$CO = 0 THENDO /* Cold start CONSOL is tty. */
	CALL MOVE (5, .(':TI: '), .FILE1);
	CALL MOVE (5, .(':TO: '), .FILE2);
	CALL CONSOL (.FILE1, .FILE2, .STATUS);
ELSEIF COLD$START$CO = 1 THENDO /* Cold start CONSOL is crt. */
	CALL MOVE (5, .(':VI: '), .FILE1);
	CALL MOVE (5, .(':VO: '), .FILE2);
	CALL CONSOL (.FILE1, .FILE2, .STATUS);
IFEND;
CALL EXIT;

END EXIT$MOD;
src/func.plm
$ TITLE ('==> PASSIF -- FUNCMOD -- PERFORM MAJOR FUNCTIONS <==')

FUNC$MOD:
DO;

/************************************************************************/
/*																		*/
/*     'Copyright 1981,1983 Intel Corporation'.  All rights reserved.	*/
/*      No part of this program or publication may be reproduced,		*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

$ NOLIST

/*         LIT.INC          */

DECLARE					AS LITERALLY 'LITERALLY',
	AMPERSAND			AS '''&''',
	BELL				AS '07H',
	BLANK				AS '020H',
	BOOLEAN				AS 'BYTE',
	CHK					AS 'CALL CHECK$STATUS',
	CLEAR$CHAR			AS '01CH',
	CO$ECHO$FILE		AS '0F00H',
	COLON				AS ''':''',
	COMMA				AS '02CH',
	CONSOLE$INPUT		AS '1',
	CONSOLE$OUTPUT		AS '0',
	CONTROL$Z			AS '01AH',
	CR					AS '0DH',
	DOT					AS '''.''',
	END$DO				AS 'END',
	END$DO$CASE			AS 'END',
	END$DO$WHILE		AS 'END',
	END$IF				AS '   ',
	END$ITERATED$DO		AS 'END',
	END$LOOP			AS ' ',
	EOF$CHAR			AS 'CONTROL$Z',
	ESC					AS '01BH',
	FALSE				AS '0H',
	FF					AS '0CH',
	FOREVER				AS 'WHILE 1',
	FORMAT$ATTRIBUTE	AS '3',
	HASH$MARK			AS '''#''',
	INIT$STG			AS '(*) BYTE INITIAL',
	LEAD$IN$CHAR		AS '07EH',
	LF					AS '0AH',
	NO$LINE$EDIT		AS '0',
	NULL				AS '0FFFFH',
	OPEN$FOR$READ		AS '1',
	OPEN$FOR$WRITE		AS '2',
	OPEN$FOR$UPDATE		AS '3',
	PUB$STRING			AS '(*) BYTE PUBLIC DATA',
	RESET				AS '0',
	RETURN$MARKER$POS	AS '0',
	SEEK$2$EOF			AS '4',
	SEEK$BACKWARD$BY$N	AS '1',
	SEEK$FORWARD$BY$N	AS '3',
	SEEK$2$N			AS '2',
	SEMICOLON			AS ''';''',
	SET					AS '1',
	STRING				AS '(*) BYTE DATA',
	TAB					AS '09H',
	TRANSFER$CONTROL	AS '1',
	TRUE				AS '0FFH',
	UNDERBAR			AS '''_''',
	USER$CI				AS '0',
	WRITE$PROTECT$ATTRIBUTE 		AS '2',
	ZERO$BIAS			AS '0';

/*        ENDLIT.INC        */

/* ISIS.INC */

OPEN: PROCEDURE(AFTN,FILENAME,ACCESS$MODE,LINE$EDIT$AFTN,ERROR) EXTERNAL;
	DECLARE (AFTN,FILENAME,ACCESS$MODE,LINE$EDIT$AFTN,ERROR) ADDRESS; END;
MEMCK: PROCEDURE ADDRESS EXTERNAL; END;
READ: PROCEDURE (AFTN,BUFFER,COUNT,ACTUAL,STATUS) EXTERNAL;
	DECLARE (AFTN,BUFFER,COUNT,ACTUAL,STATUS) ADDRESS; END;
CLOSE: PROCEDURE (AFTN,STATUS) EXTERNAL; DECLARE (AFTN,STATUS) ADDRESS;	END;
DELETE:	PROCEDURE (FILE$NAME$PTR,STATUS) EXTERNAL;
	DECLARE (FILE$NAME$PTR,STATUS) ADDRESS;	END;
SPATH: PROCEDURE (FILE,BUFFER,STATUS) EXTERNAL;
	DECLARE (FILE,BUFFER,STATUS) ADDRESS; END;

/* END ISIS.INC */

/************************************************************/
/*															*/
/*              LITERALLY'S UNIQUE TO PASSIF                */
/*															*/
/************************************************************/

DECLARE
    MINIMUM$ACCEPTABLE$BANNER$LENGTH 	AS 		'73',
    MAXIMUM$TOKEN$LENGTH				AS		'70',
    BI									AS		'CALL BOMB$IF(STATUS)',

	FIRST$FIELD							AS		'0',
    SECOND$FIELD						AS		'28',
    THIRD$FIELD							AS		'54',

    RIGHT$PARENTHESIS 					AS		''')''',
    LEFT$PARENTHESIS 					AS		'''(''',
    RI									AS		'CALL REPORT$IF',
    UNRECOGNIZED$SWITCH$ERR 			AS		'201',
    QUESTION$MARK						AS		'''?''';


/*	MAIN.INC  */

DECLARE
    ACTUAL ADDRESS EXTERNAL,
    AFTN ADDRESS EXTERNAL,
    COMMAND$TAIL$BUF (250) BYTE EXTERNAL,
    DELIMITER BYTE EXTERNAL,
    FIRST$BLOCK$BUF (128) BYTE EXTERNAL,
    FIRST$OUTPUT$MSG$PTR ADDRESS EXTERNAL,
    FIRST$TIME$THROUGH BOOLEAN EXTERNAL,
    INITIALIZED$BANNER (74) BYTE EXTERNAL,
    PRINT$HASH$MARK BOOLEAN EXTERNAL,
    REPORT$FILE$ACTUAL ADDRESS EXTERNAL,
    REPORT$FILE$AFTN ADDRESS EXTERNAL,
    REPORT$FILE$STRING$BEGINNING ADDRESS EXTERNAL,
    SECOND$OUTPUT$MSG$PTR ADDRESS EXTERNAL,
    STATUS ADDRESS EXTERNAL,
    TMP$FILE$AFTN ADDRESS EXTERNAL,
    TMP$FILE$NAME (15) BYTE EXTERNAL,
    TOK$BUF (80) BYTE EXTERNAL;

DECLARE
    KEY$WORDS (10) STRUCTURE
    (LENGTH							BYTE,
    KEY$WORD	(13)				BYTE,
    PROC$PTR						ADDRESS) EXTERNAL;

MOVE: PROCEDURE (COUNT,SOURCE$PTR,DEST$PTR) EXTERNAL;
	DECLARE (COUNT,SOURCE$PTR,DEST$PTR) ADDRESS; END;

/*	END MAIN.INC  */

/*	ERRMSG.INC  */

DECLARE
	BAD$SYNTAX$MSG 				(29)	BYTE	EXTERNAL,
	BOMB$IF$MSG$1    			(12)	BYTE	EXTERNAL,
	BOMB$IF$MSG$2				(40)	BYTE	EXTERNAL,
    DURING$ASSERTION$CHECK$MSG	(50)	BYTE	EXTERNAL,
    PASSIF$INVOKED$BY$MSG       (19)    BYTE    EXTERNAL,
    ZERO$LENGTH$FILE$MSG 		(40)	BYTE	EXTERNAL;

/*	END ERRMSG.INC  */

/*	CLI.INC  */

DECLARE BUF$COUNT BYTE EXTERNAL;

UDI$STRING$MATCH: PROCEDURE (STG$1$PTR,STG$2$PTR) BOOLEAN EXTERNAL;
    DECLARE (STG$1$PTR,STG$2$PTR) ADDRESS; END;
ENFORCE$DELIMITER: PROCEDURE(ENFORCEE) EXTERNAL; DECLARE ENFORCEE BYTE;	END;
NEXT$ARG: PROCEDURE EXTERNAL; END;

/*	END CLI.INC  */

/*	REPORT.INC  */

REPORT$ISIS$ERROR: PROCEDURE (STATUS) EXTERNAL;	DECLARE STATUS ADDRESS;	END;
REPORT$ASSERTION$SUCCESS: PROCEDURE EXTERNAL; END;
REPORT$ASSERTION$FAILURE: PROCEDURE EXTERNAL; END;
REPORT$ASSERTION$FAILURE$W$ISIS$ERR: PROCEDURE (STATUS) EXTERNAL;
	DECLARE STATUS ADDRESS; END;
REPORT$ASSERTION$FAILURE$W$MSG:	PROCEDURE (OLD$STYLE$MSG$PTR) EXTERNAL;
	DECLARE OLD$STYLE$MSG$PTR ADDRESS; END;

/*	END REPORT.INC  */
$ LIST
$ EJECT

/************************************************************/
/*															*/
/*      PROCEDURES   PERFORMING   PASSIF   FUNCTIONS        */
/*															*/
/************************************************************/

/************************************************************/
/*															*/
/*                        NOTES                             */
/*															*/
/************************************************************/

/*

1.	The token ri is a "literal" abbreviation of "call report$if",
	which will call "report$assertion$failure$w$isis$err" if
	status does not equal 0.

*/


/************************************************************/
/*															*/
/*                   LOCAL VARIABLES                        */
/*															*/
/************************************************************/

DECLARE (THE$STRING$WAS$FOUND,THE$STRING$SHOULD$BE$THERE) BOOLEAN;


/************************************************************/
/*															*/
/*                   LOCAL PROCEDURES                       */
/*															*/
/************************************************************/

REPORT$IF:
	PROCEDURE;
	IF STATUS<>0 THEN
		CALL REPORT$ASSERTION$FAILURE$W$ISIS$ERR(STATUS);
	END$IF
	END
REPORT$IF;

it$is$spool$file: PROCEDURE(file$name$ptr,want$exist) BYTE;
	DECLARE file$name$ptr ADDRESS, want$exist BYTE;
	DECLARE test BYTE;
	DECLARE spath$info STRUCTURE (
			DEV BYTE,
			NAME(6) BYTE,
			EXT(3) BYTE,
			DEV$TYPE BYTE,
			DRIVE$TYPE BYTE);

	CALL spath(file$name$ptr,.spath$info,.status);
	IF spath$info.dev <> 29 THEN RETURN false;
	CALL open(.aftn,file$name$ptr,2,0,.status); /* must open for output */
	test = (status = 11);  /* file already exists */
	IF NOT test THEN
		DO;
			CALL close(aftn,.status);
			CALL delete(file$name$ptr,.status);
		END;
	IF (test XOR want$exist) THEN
		CALL report$assertion$failure;
	ELSE CALL report$assertion$success;
	RETURN true;
END;

$ EJECT

/************************************************************/
/*															*/
/*                     FILE$EXISTS                          */
/*															*/
/************************************************************/

FILE$EXISTS:
	PROCEDURE PUBLIC;

	CALL NEXT$ARG;
	CALL ENFORCE$DELIMITER(RIGHT$PARENTHESIS);

	IF it$is$spool$file(.tok$buf(1),true) THEN RETURN;

	CALL OPEN(.AFTN,.TOK$BUF(1),OPEN$FOR$READ,NO$LINE$EDIT,.STATUS);
    IF STATUS=13 THEN
    	CALL REPORT$ASSERTION$FAILURE;
    ELSE IF STATUS<>0 THEN
        CALL REPORT$ASSERTION$FAILURE$W$ISIS$ERR(STATUS);
    ELSE
    	DO;
			/*	See whether file is of zero length. */
			DECLARE SOME$SPACE BYTE;
            CALL READ(AFTN,.SOME$SPACE,SIZE(SOME$SPACE),.ACTUAL,.STATUS); RI;
            IF ACTUAL=0 THEN
                CALL REPORT$ASSERTION$FAILURE$W$MSG(.ZERO$LENGTH$FILE$MSG);
			ELSE
				CALL REPORT$ASSERTION$SUCCESS;
            END$IF
        ENDDO;
    END$IF

	END
FILE$EXISTS;

$ EJECT

/************************************************************/
/*															*/
/*                    FILE$ABSENT                           */
/*															*/
/************************************************************/

FILE$ABSENT:
	PROCEDURE PUBLIC;

    CALL NEXT$ARG;
    CALL ENFORCE$DELIMITER(RIGHT$PARENTHESIS);

	IF it$is$spool$file(.tok$buf(1),false) THEN RETURN;

    CALL OPEN(.AFTN,.TOK$BUF(1),OPEN$FOR$READ,NO$LINE$EDIT,.STATUS);
    IF STATUS=13 THEN
    	CALL REPORT$ASSERTION$SUCCESS;
	ELSE IF STATUS<>0 THEN
		CALL REPORT$ASSERTION$FAILURE$W$ISIS$ERR(STATUS);
    ELSE
    	CALL REPORT$ASSERTION$FAILURE;
    END$IF

	END
FILE$ABSENT;

$ EJECT

/************************************************************/
/*															*/
/*                    FILES$MATCH                           */
/*															*/
/************************************************************/

FILES$MATCH:
	PROCEDURE PUBLIC;

	DECLARE (AFTN$1,AFTN$2) ADDRESS;
    DECLARE (ACTUAL$1,ACTUAL$2) ADDRESS;

    DECLARE BUF$SIZ ADDRESS;

    DECLARE (BUF$1$BOT,BUF$1$TOP,BUF$2$BOT,BUF$2$TOP) ADDRESS;

    DECLARE (BUF$1$PTR,BUF$2$PTR) ADDRESS;
    DECLARE  BUF$1$BYTE BASED BUF$1$PTR BYTE,
    		 BUF$2$BYTE BASED BUF$2$PTR BYTE;

    /*	Pick up the first filename. */
	CALL NEXT$ARG;
	CALL ENFORCE$DELIMITER(COMMA);

    /*	Open it. */
	CALL OPEN(.AFTN$1,.TOK$BUF(1),OPEN$FOR$READ,NO$LINE$EDIT,.STATUS); RI;

    /*	Pick up the second filename. */
    CALL NEXT$ARG;
	CALL ENFORCE$DELIMITER(RIGHT$PARENTHESIS);

    /* Open it. */
    CALL OPEN(.AFTN$2,.TOK$BUF(1),OPEN$FOR$READ,NO$LINE$EDIT,.STATUS); RI;

    /*	Allocate buffers in free memory. */
	BUF$SIZ = ((MEM$CK-.MEMORY)/256) * 128;

    BUF$1$BOT = .MEMORY;
    BUF$1$TOP = .MEMORY + BUF$SIZ - 1;

    BUF$2$BOT = BUF$1$TOP + 1;
    BUF$2$TOP = BUF$2$BOT + BUF$SIZ - 1;

	/*	Now, compare the files. */

    /*	B E G I N N I N G   O F   C O M P A R I S O N   L O O P. */

	begin$loop:
        CALL READ(AFTN$1,BUF$1$BOT,BUF$SIZ,.ACTUAL$1,.STATUS);
        CALL REPORT$ISIS$ERROR(STATUS);

        CALL READ(AFTN$2,BUF$2$BOT,BUF$SIZ,.ACTUAL$2,.STATUS);
        CALL REPORT$ISIS$ERROR(STATUS);

        /*	Perform fast check which may spot mismatched files. */
        IF ACTUAL$1 <> ACTUAL$2 THEN
            CALL REPORT$ASSERTION$FAILURE;
        END$IF

        BUF$1$PTR = BUF$1$BOT;
    	BUF$2$PTR = BUF$2$BOT;

		DO WHILE BUF$1$PTR < BUF$1$BOT+ACTUAL$1;
			IF BUF$1$BYTE <> BUF$2$BYTE THEN
				CALL REPORT$ASSERTION$FAILURE;
        	END$IF
        	BUF$1$PTR = BUF$1$PTR + 1;
            BUF$2$PTR = BUF$2$PTR + 1;
        END$DO$WHILE;

        IF ACTUAL$1=BUF$SIZ THEN
        	/*	There may be more bytes to compare. */
            GOTO begin$loop;
        ELSE
        	/*	The comparison was successful. */
            CALL REPORT$ASSERTION$SUCCESS;
        END$IF
	end$loop

    /*	E N D   O F   C O M P A R I S O N   L O O P. */

    END
FILES$MATCH;

$ EJECT

/************************************************************/
/*															*/
/*                  STRING$IS$IN$FILE                       */
/*															*/
/************************************************************/

STRING$IS$IN$FILE:
	PROCEDURE;
	DECLARE STRING$BUF (85) BYTE;
	DECLARE STRING$LENGTH BYTE AT (.STRING$BUF(0));
    DECLARE FIRST$STRING$CHARACTER BYTE AT (.STRING$BUF(1));

    DECLARE IN$TOKEN STRING (2,'IN');
    DECLARE FILE$TOKEN STRING(4,'FILE');

    DECLARE (BUF$BOT,BUF$TOP) ADDRESS;
    DECLARE BUF$PTR ADDRESS,
    		BUF$CHAR BASED BUF$PTR (100) BYTE;

    DECLARE BYTES$LEFT$IN$BUFFER ADDRESS;
	DECLARE BUF$SIZ ADDRESS;
	DECLARE DONT$START$SEARCH$PAST$HERE ADDRESS;

$ EJECT

    /************************************************************/
    /*															*/
    /*           PROCEDURES LOCAL TO STRING$IS$IN$FILE          */
    /*															*/
    /************************************************************/

	PERFORM$FANCY$BUFFER$REFRESH:
		PROCEDURE;

		/*	The reason for the adjective "fancy" is because,
			before any more reading is done, the text currently
			left in the buffer is moved down to the bottom of
			the buffer, and more text is appended above it.
			We don't have to worry about the text destination
			area overlapping the text source area because the
			text source and destination areas are at the top and
			bottom of the i/o buffer area, respectively;  cannot
			exceed 80 bytes each, and the i/o buffer area is huge.

            After moving the block of text, the variables controlling
            the string matching and buffering are modified so that
            the string matching algorithim begins at the bottom of
            the buffer, and searches the chunk of text which was at
            the top.*/

		DECLARE TMP$ACTUAL ADDRESS;
		DECLARE TMP$COUNT ADDRESS;

        BYTES$LEFT$IN$BUFFER = STRING$LENGTH - 1;

        CALL MOVE(/*count*/			BYTES$LEFT$IN$BUFFER           ,
        		  /*source*/		(DONT$START$SEARCH$PAST$HERE+1),
        		  /*destination*/	BUF$BOT             )          ;

		TMP$COUNT = BUF$SIZ - BYTES$LEFT$IN$BUFFER;

        CALL READ(AFTN,
                 (BUF$BOT+BYTES$LEFT$IN$BUFFER),
                  TMP$COUNT,
                 .TMP$ACTUAL,
                 .STATUS);

        CALL REPORT$ISIS$ERROR(STATUS);

		/*	Now, modify the "search-controlling" to restart the search at
			the bottom of the buffer. */
		ACTUAL  = TMP$ACTUAL + BYTES$LEFT$IN$BUFFER;

		END
    PERFORM$FANCY$BUFFER$REFRESH;

    REPORT$ASSERTION$VERDICT:
    	PROCEDURE (THE$STRING$WAS$FOUND);
        DECLARE THE$STRING$WAS$FOUND BOOLEAN;

        IF NOT (THE$STRING$WAS$FOUND xor THE$STRING$SHOULD$BE$THERE) THEN
			CALL REPORT$ASSERTION$SUCCESS;
        ELSE
        	CALL REPORT$ASSERTION$FAILURE;
        END$IF
    	END
    REPORT$ASSERTION$VERDICT;

    STRING$MATCH$W$BUF:
		PROCEDURE;

		/*	This procedure is the only way to get a positive verdict
			on string matching.  There are many ways to get a negative
			verdict.

			This procedure is attempting to match a UDI string with a
			vanilla string, so the indices of the two strings in the
			matching loop below will be off by one.

        	We can start the string comparison checking at the second
        	byte because the code which calls this procedure has already
        	checked the first byte. */

        DECLARE INDEX BYTE;

        DO INDEX=1 TO STRING$LENGTH-1;
			IF STRING$BUF(INDEX+1)<>BUF$CHAR(INDEX) THEN
				RETURN;
            END$IF
        END$DO$WHILE;

        CALL REPORT$ASSERTION$VERDICT(TRUE);
        END
    STRING$MATCH$W$BUF;

    NORMAL$FILE$READ:
		PROCEDURE;
		CALL READ(AFTN,BUF$BOT,BUF$SIZ,.ACTUAL,.STATUS); RI;
		END
    NORMAL$FILE$READ;

    THERE$PROBABLY$IS$MORE$TEXT:
        PROCEDURE BOOLEAN;
            RETURN ACTUAL=BUF$SIZ;
        END
    THERE$PROBABLY$IS$MORE$TEXT;

$ EJECT

    /************************************************************/
    /*															*/
    /*           FIRST EXECUTABLE IN STRING$IS$IN$FILE          */
    /*															*/
    /************************************************************/

    /*	Grab the string. */
    CALL NEXT$ARG;
	CALL ENFORCE$DELIMITER(RIGHT$PARENTHESIS);

    /*	Move string to local buffer. */
    CALL MOVE(/*count*/				TOK$BUF(0)+1,
    		  /*source*/			.TOK$BUF(0),
    		  /*destination*/		.STRING$BUF);

	/*	Look for the "in". */
    CALL NEXT$ARG;
	CALL ENFORCE$DELIMITER(BLANK);
	IF NOT UDI$STRING$MATCH(.IN$TOKEN,.TOK$BUF) THEN
		CALL REPORT$ASSERTION$FAILURE$W$MSG(.BAD$SYNTAX$MSG);
    END$IF

	/*	Look for the "file". */
	CALL NEXT$ARG;
	CALL ENFORCE$DELIMITER(LEFT$PARENTHESIS);
    IF NOT UDI$STRING$MATCH(.FILE$TOKEN,.TOK$BUF) THEN
		CALL REPORT$ASSERTION$FAILURE$W$MSG(.BAD$SYNTAX$MSG);
    END$IF

	/*	Grab filename. */
	CALL NEXT$ARG;
	CALL ENFORCE$DELIMITER(RIGHT$PARENTHESIS);

    /*	Open file. */
    CALL OPEN(.AFTN,.TOK$BUF(1),OPEN$FOR$READ,NO$LINE$EDIT,.STATUS);
    CALL REPORT$ISIS$ERROR(STATUS);

    /*	Allocate buffers in free memory. */
	BUF$SIZ = ((MEM$CK-.MEMORY)/128)*128;
    BUF$BOT = .MEMORY;
    BUF$TOP = BUF$BOT + BUF$SIZ - 1;
	BUF$PTR = BUF$BOT;

$ EJECT

    /************************************************************/
    /*															*/
    /*                MAIN LOOP OF STRING$IS$IN$FILE            */
    /*															*/
    /************************************************************/

    /*	read in file. */
    CALL NORMAL$FILE$READ;

    continue$string$search:
        DONT$START$SEARCH$PAST$HERE = BUF$BOT + ACTUAL - STRING$LENGTH;

            /**************************************************/
            /*												  */
            /*	HERE FOLLOWS THE "SUB-LOOP" OF THE MAIN LOOP  */
            /*												  */
            /**************************************************/

            DO BUF$PTR = BUF$BOT TO DONT$START$SEARCH$PAST$HERE;
                IF BUF$CHAR(0) = FIRST$STRING$CHARACTER THEN
                    CALL STRING$MATCH$W$BUF;
                END$IF
            END$ITERATED$DO;

        IF THERE$PROBABLY$IS$MORE$TEXT THEN
        	DO;
        		CALL PERFORM$FANCY$BUFFER$REFRESH;
        		GOTO continue$string$search;
        	ENDDO;
        ELSE
            CALL REPORT$ASSERTION$VERDICT(FALSE);
        END$IF
	end$loop

	/*	The code should never get this far.  If text is exhausted, then
		the procedure which discovers that fact will call the procedure
		report$assertion$verdict, which will report the fact, and not
        return.  If the string matches, then, similarly, the string
        match procedure will call report$assertion$verdict, which will
        not return. */

    END
STRING$IS$IN$FILE;

$ EJECT

/************************************************************/
/*															*/
/*                  STRING$FOUND                            */
/*															*/
/************************************************************/

STRING$FOUND:
	PROCEDURE PUBLIC;
	THE$STRING$SHOULD$BE$THERE = TRUE;
    CALL STRING$IS$IN$FILE;
	END
STRING$FOUND;

/************************************************************/
/*															*/
/*                    STRING$ABSENT                         */
/*															*/
/************************************************************/

STRING$ABSENT:
	PROCEDURE PUBLIC;
	THE$STRING$SHOULD$BE$THERE = FALSE;
    CALL STRING$IS$IN$FILE;
	END
STRING$ABSENT;

END
FUNC$MOD;
src/ganef.plm
GANEF: DO;

/************************************************************************/
/*																		*/
/*     'Copyright 1981,1983 Intel Corporation'.  All rights reserved.	*/
/*      No part of this program or publication may be reproduced,		*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

$IF XVERSION
DECLARE PROPRIETARY(*) BYTE DATA ('INTEL PROPRIETARY SOFTWARE');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=X105',0);
$ELSE
DECLARE COPYRIGHT (*) BYTE DATA  ('COPYRIGHT 1981,1983 INTEL ');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.1',0);
$ENDIF



DECLARE	LIT		LITERALLY	'LITERALLY',
		DCL		LIT	'DECLARE',
		TRUE	LIT	'0FFH',
		FALSE	LIT	'000H',
		PROC	LIT	'PROCEDURE',
		PROCEND	LIT	'END',
		THENDO	LIT	'THEN DO;',
		ELSEIF	LIT	'END; ELSE IF',
		ELSEDO	LIT	'END; ELSE DO;',
		IFEND	LIT	'END',
		WHILEND	LIT	'END',
		CR		LIT	'0DH',
		LF		LIT	'0AH',
		ESC		LIT '1BH';


EXIT:	PROC EXTERNAL;											PROCEND;
OPEN:	PROC (A,B,C,D,E) EXTERNAL;	DCL (A,B,C,D,E) ADDRESS;	PROCEND;
READ:	PROC (A,B,C,D,E) EXTERNAL;	DCL (A,B,C,D,E) ADDRESS;	PROCEND;
WRITE:	PROC (A,B,C,D) EXTERNAL;	DCL (A,B,C,D) ADDRESS;		PROCEND;
CLOSE:	PROC (A,B) EXTERNAL;		DCL (A,B) ADDRESS;			PROCEND;
SPATH:	PROC (A,B,C) EXTERNAL;		DCL (A,B,C) ADDRESS;		PROCEND;
UNPATH:	PROC (A,B) EXTERNAL;		DCL (A,B) ADDRESS;			PROCEND;
DEBLANK:PROC (A) ADDRESS EXTERNAL;	DCL (A) ADDRESS;			PROCEND;
DELIMIT:PROC (A) ADDRESS EXTERNAL;	DCL (A) ADDRESS;			PROCEND;
SEQ:	PROC (A,B,C) BYTE EXTERNAL;	DCL (A,B,C) ADDRESS;		PROCEND;
ABSIO:	PROC (A,B,C,D) EXTERNAL;	DCL (A,B) BYTE,(C,D) ADDRESS;PROCEND;
NUMOUT:	PROC (A,B,C,D,E) EXTERNAL;	DCL (A,D) ADDRESS,(B,C,E) BYTE;PROCEND;
FILE$ERROR:	PROC (A,B,C) EXTERNAL;	DCL (A,B) ADDRESS;DCL (C) BYTE;PROCEND;
SCAN$INTEGER:	PROC (A) ADDRESS EXTERNAL;	DCL (A) ADDRESS;	PROCEND;
FORCE$UPPER:	PROC (A) EXTERNAL;	DCL (A) ADDRESS;			PROCEND;

DCL /* DEFAULT ISIS I/O DEVICES */
	CO$AFTN       LITERALLY '0',
	CI$AFTN       LITERALLY '1';

DCL /* DEVICE ACCESS MODES FOR OPEN */
	OPEN$READ     LITERALLY '1',
	OPEN$WRITE    LITERALLY '2',
	OPEN$UPDATE   LITERALLY '3';


DCL DISK$READ LITERALLY '4';
DCL DISK$WRITE LITERALLY '6';
DCL (ACTUAL, STATUS) ADDRESS;
DCL (DISK, DISK$LAST$READ, FROM$DISK, TO$DISK, MARK$DISK) BYTE;
DCL (I, BLOCK, TRACK, SECTOR, TRACK$LAST$READ, SECTOR$LAST$READ,
	MARK$TRACK, MARK$SECTOR) ADDRESS;
DCL PN$BLOCK STRUCTURE (DEVICE$NO BYTE, NAME (6) BYTE, EXT (3) BYTE,
	DEVICE$TYPE BYTE, DRIVE$TYPE BYTE);
DCL PARM (3) ADDRESS;
DCL (OFFSET, OFFSET1, FIND$LEN) ADDRESS;
DCL (BLANKS) (4) BYTE DATA ('    ');
DCL STR (5) BYTE;
DCL BUFFER (128) BYTE;
DCL HEADER$BUFFER (64) ADDRESS;
DCL FIND$BUFFER (128) BYTE;
DCL COMMAND (128) BYTE;
DCL CMND$PTR ADDRESS, CMND BASED CMND$PTR BYTE;
DCL RESTART LABEL;

WRITE$CO: PROC (STR, LEN);
DCL (STR, LEN) ADDRESS;
	CALL WRITE (CO$AFTN, STR, LEN, .STATUS);
PROCEND WRITE$CO;

WRITE$CRLF: PROC;
	CALL WRITE$CO (.(CR, LF), 2);
PROCEND WRITE$CRLF;

WRITE$CO$CRLF: PROC (STR, LEN);
DCL (STR, LEN) ADDRESS;
	CALL WRITE$CO (STR, LEN);
	CALL WRITE$CRLF;
PROCEND WRITE$CO$CRLF;

GET$COMMAND: PROC;
	CALL READ (CI$AFTN, .COMMAND, LENGTH (COMMAND), .ACTUAL, .STATUS);
	COMMAND (ACTUAL) = CR;
	CALL FORCE$UPPER (.COMMAND);
	CMND$PTR = DEBLANK (.COMMAND);
PROCEND GET$COMMAND;

CMND$ERROR: PROC;
	CALL WRITE$CO (.COMMAND, 1);
	CALL WRITE$CO$CRLF (.(' COMMAND FORMAT ERROR'), 21);
	GOTO RESTART;
PROCEND CMND$ERROR;

PARSE$BLOCK$NO: PROC;
	PARM (0) = TRACK;
	PARM (1) = SECTOR;
	PARM (2) = 0FFH;
	I = 0;
	CMND$PTR = DEBLANK (CMND$PTR + 1);
	DO WHILE CMND <> CR;
		IF I > 2 THENDO
			CALL CMND$ERROR;
		ELSEIF CMND = '-' THENDO
			CMND$PTR = CMND$PTR + 1;
		ELSEIF (CMND >= '0' AND CMND <= '9') OR (CMND >= 'A' AND CMND <= 'F') THENDO
			PARM (I) = SCAN$INTEGER (.CMND$PTR);
		ELSEDO
			CALL CMND$ERROR;
		IFEND;    
		I = I + 1;
		CMND$PTR = DEBLANK (CMND$PTR);
	WHILEND;
	IF PARM (2) <> 0FFH THENDO
		IF PARM (2) > 9 THENDO
			CALL CMND$ERROR;
		IFEND;
	IFEND;
	TRACK = PARM (0);
	SECTOR = PARM (1);
	DISK = PARM (2);
PROCEND PARSE$BLOCK$NO;

DISPLAY$BLOCK$NO: PROC;
	CALL WRITE$CO (.('TRACK='), 6);
	CALL NUMOUT (TRACK, 10, ' ', .STR, 3);
	STR (3) = ' ';
	CALL WRITE$CO (.STR, 4);
	CALL NUMOUT (TRACK, 16, '0', .STR (1), 2);
	STR (0) = '(';
	CALL WRITE$CO (.STR, 3);
	CALL WRITE$CO (.('H), SECTOR='), 11);
	CALL NUMOUT (SECTOR, 10, ' ', .STR, 3);
	STR (3) = ' ';
	CALL WRITE$CO (.STR, 4);
	CALL NUMOUT (SECTOR, 16, '0', .STR (1), 2);
	STR (0) = '(';
	CALL WRITE$CO (.STR, 3);
	CALL WRITE$CO (.('H), DISK= '), 10);
	STR (0) = DISK + '0';
	CALL WRITE$CO (.STR, 1);
PROCEND DISPLAY$BLOCK$NO;

DISPLAY$BUFFER: PROC;
	CALL DISPLAY$BLOCK$NO;
	CALL WRITE$CO$CRLF (.(CR, LF,
	'      0  1  2  3  4  5  6  7   8  9  A  B  C  D  E  F    0123456789ABCDEF'),
		75);
	OFFSET = 0;
	DO WHILE OFFSET < 128;
		CALL NUMOUT (OFFSET, 16, '0', .STR, 4);
		CALL WRITE$CO (.STR, 4);
		STR (0) = ' ';
		OFFSET1 = 0;
		DO WHILE OFFSET1 < 16;
			CALL NUMOUT (BUFFER (OFFSET + OFFSET1), 16, '0', .STR (1), 2);
			CALL WRITE$CO (.STR, 3);
			IF OFFSET1 = 7 THENDO
				CALL WRITE$CO (.BLANKS, 1);
			IFEND;
			OFFSET1 = OFFSET1 + 1;
		WHILEND;
		CALL WRITE$CO (.BLANKS, 4);
		OFFSET1 = 0;
		DO WHILE OFFSET1 < 16;
			IF (BUFFER (OFFSET + OFFSET1) >= ' ') AND (BUFFER (OFFSET + OFFSET1) <=
					126) THENDO
				CALL WRITE$CO (.BUFFER (OFFSET + OFFSET1), 1);
			ELSEDO
				CALL WRITE$CO (.('.'), 1);
			IFEND;
			OFFSET1 = OFFSET1 + 1;
		WHILEND;
		CALL WRITE$CRLF;
		OFFSET = OFFSET + 16;
	WHILEND;
PROCEND DISPLAY$BUFFER;

INVALID$BLOCK$NO: PROC BYTE;
DCL FILE$NAME (15) BYTE;
	IF DISK > 9 THENDO
		RETURN TRUE;
	IFEND;
	CALL MOVE (LENGTH (FILE$NAME), .(':F0:GANEF.TMP '), .FILE$NAME);
	FILE$NAME (2) = DISK + '0';
	CALL SPATH (.FILE$NAME, .PN$BLOCK, .STATUS);
	IF STATUS <> 0 THENDO
		RETURN TRUE;
	ELSEIF PN$BLOCK.DRIVE$TYPE = 0 THENDO
		RETURN TRUE;
	ELSEIF SECTOR < 1 THENDO
		RETURN TRUE;
	IFEND;
	IF PN$BLOCK.DRIVE$TYPE < 4 THENDO /* FLOPPY DRIVE */
		IF TRACK > 76 THENDO
			RETURN TRUE;
		IFEND;
		IF PN$BLOCK.DRIVE$TYPE = 1 THENDO /* DOUBLE DENSITY FLOPPY DRIVE */
			IF SECTOR > 52 THENDO
				RETURN TRUE;
			IFEND;
		ELSEIF SECTOR > 26 THENDO /* SINGLE DENSITY FLOPPY DRIVE */
			RETURN TRUE;
		IFEND;
	ELSEIF PN$BLOCK.DRIVE$TYPE = 4 THENDO /* 5440 HARD DISK DRIVE */
		IF TRACK > 199 THENDO
			RETURN TRUE;
		ELSEIF SECTOR > 144 THENDO
			RETURN TRUE;
		IFEND;
	ELSEIF PN$BLOCK.DRIVE$TYPE = 9 THENDO /* WINCHESTER DISK DRIVE */
		IF TRACK > 211 THENDO
			RETURN TRUE;
		ELSEIF SECTOR > 210 THENDO
			RETURN TRUE;
		IFEND;
	IFEND;
	RETURN FALSE;
PROCEND INVALID$BLOCK$NO;

VERIFY$BLOCK$NO: PROC;
	IF INVALID$BLOCK$NO THENDO
		IF STATUS <> 0 THENDO
			CALL WRITE$CO (.('INTERNAL ERROR: '), 16);
		ELSEIF PN$BLOCK.DRIVE$TYPE = 0 THENDO
			CALL WRITE$CO (.('NO CONTROLLER FOR DRIVE: '), 24);
		ELSEDO
			CALL WRITE$CO (.('INVALID BLOCK NO: '), 18);
		IFEND;
		CALL DISPLAY$BLOCK$NO;
		CALL WRITE$CRLF;
		GOTO RESTART;
	IFEND;
PROCEND VERIFY$BLOCK$NO;

READ$AND$DISPLAY$SECTOR: PROC;
	CALL VERIFY$BLOCK$NO;
	CALL ABSIO (DISK$READ, DISK, SHL (TRACK, 8) + SECTOR, .BUFFER);
	CALL DISPLAY$BUFFER;
	DISK$LAST$READ = DISK;
	TRACK$LAST$READ = TRACK;
	SECTOR$LAST$READ = SECTOR;
PROCEND READ$AND$DISPLAY$SECTOR;

DISPLAY$SECTOR: PROC;
	CALL PARSE$BLOCK$NO;
	IF DISK = 0FFH THENDO
		DISK = FROM$DISK;
	IFEND;
	CALL READ$AND$DISPLAY$SECTOR;
PROCEND DISPLAY$SECTOR;

DISPLAY$NEXT$SECTOR: PROC;
	IF TRACK$LAST$READ = 0FFFFH THENDO
		CALL WRITE$CO$CRLF (.('NO SECTOR''S BEEN READ YET'), 25);
		GOTO RESTART;
	IFEND;
	DISK = DISK$LAST$READ;
	TRACK = TRACK$LAST$READ;
	SECTOR = SECTOR$LAST$READ + 1;
	IF INVALID$BLOCK$NO THENDO
		TRACK = TRACK + 1;
		SECTOR = 1;
	IFEND;
	CALL READ$AND$DISPLAY$SECTOR;
PROCEND DISPLAY$NEXT$SECTOR;

WRITE$SECTOR: PROC;
	CMND$PTR = DEBLANK (CMND$PTR + 1);
	IF CMND = CR THENDO
		CALL WRITE$CO (.('WRITE TO '), 9);
		CALL DISPLAY$BLOCK$NO;
		CALL WRITE$CO (.(' ? '), 3);
		CALL GET$COMMAND;
		IF CMND <> 'Y' THENDO
			GOTO RESTART;
		IFEND;
	ELSEDO
		CMND$PTR = CMND$PTR - 1;
		CALL PARSE$BLOCK$NO;
		IF DISK = 0FFH THENDO
			DISK = TO$DISK;
		IFEND;
	IFEND;
	CALL VERIFY$BLOCK$NO;
	CALL ABSIO (DISK$WRITE, DISK, SHL (TRACK, 8) + SECTOR, .BUFFER);
PROCEND WRITE$SECTOR;

GET$STRING: PROC (BUF$PTR, OFFSET);
DCL (BUF$PTR, OFFSET) ADDRESS;
DCL BUFFER BASED BUF$PTR (128) BYTE;
DCL VAL BYTE;
	OFFSET = OFFSET AND 127;
	OFFSET1 = 0;
	CALL WRITE$CO$CRLF (.('TYPE INPUT IN HEX OR ASCII STRING'), 33);
	DO WHILE CMND <> ESC;
		CALL NUMOUT (OFFSET, 16, '0', .STR, 4);
		CALL WRITE$CO (.STR, 4);
		CALL NUMOUT (BUFFER (OFFSET), 16, '0', .STR (1), 2);
		STR (0) = ' ';
		STR (3) = '-';
		CALL WRITE$CO (.STR, 4);
		CALL GET$COMMAND;
		IF CMND = CR THENDO
			OFFSET = (OFFSET + 1) AND 127;
			OFFSET1 = OFFSET1 + 1;
		IFEND;
		DO WHILE (CMND <> ESC) AND (CMND <> CR);
			IF CMND = '''' THENDO
				CMND$PTR = CMND$PTR + 1;
				DO WHILE (CMND <> '''') AND (CMND <> CR) AND (CMND <> ESC);
					BUFFER (OFFSET) = CMND;
					OFFSET = (OFFSET + 1) AND 127;
					OFFSET1 = OFFSET1 + 1;
					CMND$PTR = CMND$PTR + 1;
				WHILEND;
				CMND$PTR = DEBLANK (CMND$PTR + 1);
			ELSEIF ((CMND >= '0') AND (CMND <= '9')) OR ((CMND >= 'A') AND (CMND <= 'F')) THENDO
				VAL = 0;
				DO WHILE ((CMND >= '0') AND (CMND <= '9')) OR ((CMND >= 'A') AND
						(CMND <= 'F'));
					VAL = SHL (VAL, 4);
					IF CMND <= '9' THENDO
						VAL = VAL + CMND - '0';
					ELSEDO
						VAL = VAL + CMND - 'A' + 10;
					IFEND;
					CMND$PTR = CMND$PTR + 1;
				WHILEND;
				I = 1;
				CMND$PTR = DEBLANK (CMND$PTR);
				IF CMND = '*' THENDO
					CMND$PTR = DEBLANK (CMND$PTR + 1);
					I = SCAN$INTEGER (.CMND$PTR);
					CMND$PTR = DEBLANK (CMND$PTR);
				IFEND;
				DO WHILE I > 0;
					BUFFER (OFFSET) = VAL;
					OFFSET = (OFFSET + 1) AND 127;
					OFFSET1 = OFFSET1 + 1;
					I = I - 1;
				WHILEND;
			ELSEIF CMND = '-' THENDO
				I = 1;
				CMND$PTR = DEBLANK (CMND$PTR + 1);
				IF CMND = '*' THENDO
					CMND$PTR = DEBLANK (CMND$PTR + 1);
					I = SCAN$INTEGER (.CMND$PTR);
					CMND$PTR = DEBLANK (CMND$PTR);
				IFEND;
				OFFSET = (OFFSET + I) AND 127;
				OFFSET1 = OFFSET1 + I;
			ELSEDO
				CALL WRITE$CO$CRLF (.('INVALID HEX INPUT'), 17);
				CMND = CR;
			IFEND;
		WHILEND;
	WHILEND;
	IF OFFSET1 <> 0 THENDO
		OFFSET1 = ((OFFSET1 - 1) AND 127) + 1;
	IFEND;
	CALL WRITE$CRLF;
PROCEND GET$STRING;

STRING$NOT$IN$BUFFER: PROC BYTE;
	OFFSET = 0;
	DO WHILE (128 - OFFSET) >= FIND$LEN;
		IF SEQ (.BUFFER (OFFSET), .FIND$BUFFER, FIND$LEN) THENDO
			RETURN FALSE;
		IFEND;
		OFFSET = OFFSET + 1;
	WHILEND;
	RETURN TRUE;
PROCEND STRING$NOT$IN$BUFFER;

FIND$SECTOR: PROC;
	CMND$PTR = DEBLANK (CMND$PTR + 1);
	IF CMND = CR THENDO
		IF TRACK$LAST$READ = 0FFFFH THENDO
			CALL WRITE$CO$CRLF (.('NO SECTOR''S BEEN READ YET'), 25);
			GOTO RESTART;
		IFEND;
		DISK = DISK$LAST$READ;
		TRACK = TRACK$LAST$READ;
		SECTOR = SECTOR$LAST$READ + 1;
		IF INVALID$BLOCK$NO THENDO
			TRACK = TRACK + 1;
			SECTOR = 1;
		IFEND;
	ELSEDO
		CMND$PTR = CMND$PTR - 1;
		CALL PARSE$BLOCK$NO;
		IF DISK = 0FFH THENDO
			DISK = FROM$DISK;
		IFEND;
	IFEND;
	CALL VERIFY$BLOCK$NO;
	CALL GET$STRING (.FIND$BUFFER, 0);
	IF OFFSET1 = 0 THENDO
		IF FIND$LEN = 0 THENDO
			CALL WRITE$CO$CRLF (.('NO STRING''S BEEN DEFINED YET'), 28);
			GOTO RESTART;
		IFEND;
	ELSEDO
		FIND$LEN = OFFSET1;
	IFEND;
	CALL ABSIO (DISK$READ, DISK, SHL (TRACK, 8) + SECTOR, .BUFFER);
	DO WHILE STRING$NOT$IN$BUFFER;
		SECTOR = SECTOR + 1;
		IF INVALID$BLOCK$NO THENDO
			CALL WRITE$CO (.('SCANNED TO '), 11);
			CALL DISPLAY$BLOCK$NO;
			CALL WRITE$CO (.(', CONTINUE ? '), 13);
			CALL GET$COMMAND;
			IF CMND <> 'Y' THENDO
				DISK$LAST$READ = DISK;
				TRACK$LAST$READ = TRACK;
				SECTOR$LAST$READ = SECTOR;
				GOTO RESTART;
			IFEND;
			TRACK = TRACK + 1;
			SECTOR = 1;
			IF INVALID$BLOCK$NO THENDO
				CALL WRITE$CO$CRLF (.('STRING NOT FOUND ON DISK'), 24);
				TRACK$LAST$READ, SECTOR$LAST$READ = 0FFFFH;
				GOTO RESTART;
			IFEND;
		IFEND;
		CALL ABSIO (DISK$READ, DISK, SHL (TRACK, 8) + SECTOR, .BUFFER);
	WHILEND;
	CALL DISPLAY$BUFFER;
	DISK$LAST$READ = DISK;
	TRACK$LAST$READ = TRACK;
	SECTOR$LAST$READ = SECTOR;
PROCEND FIND$SECTOR;

MARK$BLOCK$NO: PROC;
	CALL PARSE$BLOCK$NO;
	IF DISK = 0FFH THENDO
		DISK = FROM$DISK;
	IFEND;
	CALL VERIFY$BLOCK$NO;
	MARK$DISK = DISK;
	MARK$TRACK = TRACK;
	MARK$SECTOR = SECTOR;
PROCEND MARK$BLOCK$NO;

RECALL$BLOCK$NO: PROC;
	CMND$PTR = DEBLANK (CMND$PTR + 1);
	IF CMND <> CR THENDO
		CALL CMND$ERROR;
	IFEND;
	IF MARK$TRACK = 0FFFFH THENDO
		CALL WRITE$CO$CRLF (.('NO SECTOR''S BEEN MARKED YET'), 27);
		GOTO RESTART;
	IFEND;
	DISK = MARK$DISK;
	TRACK = MARK$TRACK;
	SECTOR = MARK$SECTOR;
	CALL READ$AND$DISPLAY$SECTOR;
PROCEND RECALL$BLOCK$NO;

ASSIGN$DISK: PROC;
	CMND$PTR = DEBLANK (CMND$PTR + 1);
	PARM (0) = FROM$DISK;
	PARM (1) = TO$DISK;
	DO WHILE CMND <> CR;
		IF CMND = 'R' THENDO
			CMND$PTR = DEBLANK (CMND$PTR + 1);
			IF CMND <> '=' THENDO
				CALL CMND$ERROR;
			IFEND;
			CMND$PTR = DEBLANK (CMND$PTR + 1);
			PARM (0) = SCAN$INTEGER (.CMND$PTR);
			CMND$PTR = DEBLANK (CMND$PTR);
		ELSEIF CMND = 'W' THENDO
			CMND$PTR = DEBLANK (CMND$PTR + 1);
			IF CMND <> '=' THENDO
				CALL CMND$ERROR;
			IFEND;
			CMND$PTR = DEBLANK (CMND$PTR + 1);
			PARM (1) = SCAN$INTEGER (.CMND$PTR);
			CMND$PTR = DEBLANK (CMND$PTR);
		ELSEDO
			CALL CMND$ERROR;
		IFEND;
	WHILEND;
	IF (PARM (0) > 9) OR (PARM (1) > 9) THENDO
		CALL CMND$ERROR;
	IFEND;
	FROM$DISK = PARM (0);
	TO$DISK = PARM (1);
	CALL WRITE$CO (.('READING FROM DRIVE '), 19);
	STR (0) = FROM$DISK + '0';
	CALL WRITE$CO (.STR, 1);
	CALL WRITE$CO (.(', WRITING TO DRIVE '), 19);
	STR (0) = TO$DISK + '0';
	CALL WRITE$CO$CRLF (.STR, 1);
PROCEND ASSIGN$DISK;

SUBSTITUTE$BUFFER: PROC;
	CMND$PTR = DEBLANK (CMND$PTR + 1);
	OFFSET = SCAN$INTEGER (.CMND$PTR);
	CMND$PTR = DEBLANK (CMND$PTR);
	IF CMND <> CR THENDO
		CALL CMND$ERROR;
	IFEND;
	CALL GET$STRING (.BUFFER, OFFSET);
	CALL DISPLAY$BUFFER;
PROCEND SUBSTITUTE$BUFFER;

TRANSFER$FILE: PROC;
DCL MORE$SECTORS BYTE;
DCL FILE$NAME (15) BYTE;
DCL FILE$AFTN ADDRESS;
	CMND$PTR = DEBLANK (CMND$PTR + 1);
	IF CMND = CR THENDO
		IF TRACK$LAST$READ = 0FFFFH THENDO
			CALL WRITE$CO$CRLF (.('NO SECTOR''S BEEN READ YET'), 25);
			GOTO RESTART;
		IFEND;
		DISK = DISK$LAST$READ;
		TRACK = TRACK$LAST$READ;
		SECTOR = SECTOR$LAST$READ;
	ELSEDO
		CMND$PTR = CMND$PTR - 1;
		CALL PARSE$BLOCK$NO;
		IF DISK = 0FFH THENDO
			DISK = FROM$DISK;
		IFEND;
	IFEND;
	CALL VERIFY$BLOCK$NO;
	CALL WRITE$CO (.('TRANSFER TO WHAT FILE ? '), 24);
	CALL GET$COMMAND;
	CALL SPATH (CMND$PTR, .PN$BLOCK, .STATUS);
	IF STATUS <> 0 THENDO
		CALL WRITE$CO$CRLF (.('INVALID FILE NAME'), 17);
		GOTO RESTART;
	IFEND;
	CALL UNPATH (.PN$BLOCK, .FILE$NAME);
	IF PN$BLOCK.DRIVE$TYPE = 0 THENDO
		CALL WRITE$CO (.('NO CONTROLLER FOR DRIVE: '), 24);
		CALL WRITE$CO$CRLF (.FILENAME (2), 1);
		GOTO RESTART;
	IFEND;
	IF (DISK + '0') = FILE$NAME (2) THENDO
		CALL WRITE$CO$CRLF (.('WARNING, READING AND WRITING TO SAME DISK'), 41);
	IFEND;
	CALL ABSIO (DISK$READ, DISK, SHL (TRACK, 8) + SECTOR, .HEADER$BUFFER);
	IF HEADER$BUFFER (0) <> 0 THENDO
		CALL WRITE$CO$CRLF (.('WARNING, NOT FIRST HEADER BLOCK'), 31);
	IFEND;
	CALL WRITE$CO (.('RESTORE FILE AT: '), 17);
	CALL DISPLAY$BLOCK$NO;
	CALL WRITE$CRLF;
	CALL WRITE$CO (.('TO FILE '), 8);
	CALL WRITE$CO (.FILE$NAME, DELIMIT (.FILE$NAME) - .FILE$NAME);
	CALL WRITE$CO (.(' ? '), 3);
	CALL GET$COMMAND;
	IF CMND <> 'Y' THENDO
		GOTO RESTART;
	IFEND;
	CALL OPEN (.FILE$AFTN, .FILE$NAME, OPEN$WRITE, 0, .STATUS);
	IF STATUS <> 0 THENDO
		CALL FILE$ERROR (STATUS, .FILE$NAME, FALSE);
		GOTO RESTART;
	IFEND;
	MORE$SECTORS = TRUE;
	DO WHILE MORE$SECTORS;
		I = 2;
		DO WHILE I < 64;
			IF MORE$SECTORS THENDO
				BLOCK = HEADER$BUFFER (I);
				IF BLOCK > 0 THENDO
					TRACK = HIGH (BLOCK);
					SECTOR = LOW (BLOCK);
					IF INVALID$BLOCK$NO THENDO
						CALL WRITE$CO$CRLF (.('INVALID POINTER ENCOUNTERED'), 27);
						MORE$SECTORS = FALSE;
					ELSEDO
						CALL ABSIO (DISK$READ, DISK, BLOCK, .BUFFER);
						CALL WRITE (FILE$AFTN, .BUFFER, 128, .STATUS);
						IF STATUS <> 0 THENDO
							CALL FILE$ERROR (STATUS, .FILE$NAME, FALSE);
							MORE$SECTORS = FALSE;
						IFEND;
					IFEND;
				ELSEDO
					MORE$SECTORS = FALSE;
				IFEND;
			IFEND;
			I = I + 1;
		WHILEND;
		IF MORE$SECTORS THENDO
			BLOCK = HEADER$BUFFER (1);
			IF BLOCK > 0 THENDO
				TRACK = HIGH (BLOCK);
				SECTOR = LOW (BLOCK);
				IF INVALID$BLOCK$NO THENDO
					CALL WRITE$CO$CRLF (.('INVALID POINTER ENCOUNTERED'), 27);
					MORE$SECTORS = FALSE;
				ELSEDO
					CALL ABSIO (DISK$READ, DISK, BLOCK, .HEADER$BUFFER);
				IFEND;
			ELSEDO
				MORE$SECTORS = FALSE;
			IFEND;
		IFEND;
	WHILEND;
	CALL CLOSE (FILE$AFTN, .STATUS);
	DISK$LAST$READ = DISK;
	TRACK$LAST$READ = TRACK;
	SECTOR$LAST$READ = SECTOR;
PROCEND TRANSFER$FILE;

BIT$MAP: PROC;
DCL SECTORS$PER$TRACK BYTE;
DCL BYTE$OFFSET ADDRESS;
	CALL PARSE$BLOCK$NO;
	IF DISK = 0FFH THENDO
		DISK = FROM$DISK;
	IFEND;
	CALL VERIFY$BLOCK$NO;
	IF PN$BLOCK.DRIVE$TYPE < 4 THENDO /* FLOPPY DRIVE */
		IF PN$BLOCK.DRIVE$TYPE = 1 THENDO /* DOUBLE DENSITY FLOPPY DRIVE */
			SECTORS$PER$TRACK = 52;
		ELSEDO /* SINGLE DENSITY FLOPPY DRIVE */
			SECTORS$PER$TRACK = 26;
		IFEND;
	ELSEIF PN$BLOCK.DRIVE$TYPE = 4 THENDO /* 5440 HARD DISK DRIVE */
		SECTORS$PER$TRACK = 144;
	ELSEIF PN$BLOCK.DRIVE$TYPE = 9 THENDO /* WINCHESTER DISK DRIVE */
		SECTORS$PER$TRACK = 210;
	IFEND;
	BYTE$OFFSET = TRACK * SECTORS$PER$TRACK + SECTOR - 1;
	CALL WRITE$CO (.('BIT MAP OFFSET OF: '), 19);
	CALL DISPLAY$BLOCK$NO;
	CALL WRITE$CRLF;
	CALL WRITE$CO (.('IS: SECTOR OFFSET= '), 19);
	CALL NUMOUT (SHR (HIGH (BYTE$OFFSET), 2), 10, ' ', .STR, 3);
	STR (3) = ' ';
	CALL WRITE$CO (.STR, 4);
	CALL NUMOUT (SHR (HIGH (BYTE$OFFSET), 2), 16, '0', .STR (1), 2);
	STR (0) = '(';
	CALL WRITE$CO (.STR, 3);
	CALL WRITE$CO (.('H), BYTE OFFSET= '), 17);
	CALL NUMOUT (SHR (BYTE$OFFSET AND 3FFH, 3), 10, ' ', .STR, 3);
	STR (3) = ' ';
	CALL WRITE$CO (.STR, 4);
	CALL NUMOUT (SHR (BYTE$OFFSET AND 3FFH, 3), 16, '0', .STR (1), 2);
	STR (0) = '(';
	CALL WRITE$CO (.STR, 3);
	CALL WRITE$CO (.('H), MASK= '), 10);
	CALL NUMOUT (ROR (80H, LOW (BYTE$OFFSET) AND 7), 16, '0', .STR, 2);
	CALL WRITE$CO (.STR, 2);
	CALL WRITE$CO$CRLF (.('H'), 1);
PROCEND BIT$MAP;

GET$OPERANDS: PROC;
	CMND$PTR = DEBLANK (CMND$PTR + 1);
	PARM (1) = SCAN$INTEGER (.CMND$PTR);
	CMND$PTR = DEBLANK (CMND$PTR);
	PARM (2) = SCAN$INTEGER (.CMND$PTR);
	CMND$PTR = DEBLANK (CMND$PTR);
	IF CMND <> CR THENDO
		CALL CMND$ERROR;
	IFEND;
PROCEND GET$OPERANDS;

DISPLAY$OPERAND: PROC;
	CALL NUMOUT (PARM (0), 10, ' ', .STR, 5);
	CALL WRITE$CO (.STR, 5);
	CALL WRITE$CO (.(' ('), 2);
	CALL NUMOUT (PARM (0), 16, '0', .STR, 4);
	CALL WRITE$CO (.STR, 4);
	CALL WRITE$CO$CRLF (.('H)'), 2);
PROCEND DISPLAY$OPERAND;

ADD$OPERANDS: PROC;
	CALL GET$OPERANDS;
	PARM (0) = PARM (1) + PARM (2);
	CALL DISPLAY$OPERAND;
PROCEND ADD$OPERANDS;

SUB$OPERANDS: PROC;
	CALL GET$OPERANDS;
	PARM (0) = PARM (1) - PARM (2);
	CALL DISPLAY$OPERAND;
PROCEND SUB$OPERANDS;

MULT$OPERANDS: PROC;
	CALL GET$OPERANDS;
	PARM (0) = PARM (1) * PARM (2);
	CALL DISPLAY$OPERAND;
PROCEND MULT$OPERANDS;

DIV$OPERANDS: PROC;
	CALL GET$OPERANDS;
	PARM (0) = PARM (1) / PARM (2);
	CALL DISPLAY$OPERAND;
PROCEND DIV$OPERANDS;

MOD$OPERANDS: PROC;
	CALL GET$OPERANDS;
	PARM (0) = PARM (1) MOD PARM (2);
	CALL DISPLAY$OPERAND;
PROCEND MOD$OPERANDS;

CALL GET$COMMAND; /* KILL THE COMMAND LINE */
$IF XVERSION
CALL WRITE$CO$CRLF (.('ISIS-II GANEF DISK TRASHER, X105'), 32);
$ELSE
CALL WRITE$CO$CRLF (.('ISIS-II GANEF DISK TRASHER, V1.1'), 32);
$ENDIF
DISK, DISK$LAST$READ, FROM$DISK, TO$DISK, MARK$DISK, FIND$LEN = 0;
TRACK, SECTOR, TRACK$LAST$READ, SECTOR$LAST$READ, MARK$TRACK, MARK$SECTOR = 0FFFFH;
FIND$BUFFER (0) = 0;
CALL MOVE (LAST (FIND$BUFFER), .FIND$BUFFER, .FIND$BUFFER (1));
RESTART:
DO WHILE TRUE;
	CALL WRITE$CO (.('*'), 1);
	CALL GET$COMMAND;
	IF (CMND = 'E') OR (CMND = 'Q') THENDO
		CALL EXIT;
	ELSEIF CMND = 'D' THENDO
		CALL DISPLAY$SECTOR;
	ELSEIF CMND = CR THENDO
		CALL DISPLAY$NEXT$SECTOR;
	ELSEIF CMND = 'W' THENDO
		CALL WRITE$SECTOR;
	ELSEIF CMND = 'S' THENDO
		CALL SUBSTITUTE$BUFFER;
	ELSEIF CMND = 'F' THENDO
		CALL FIND$SECTOR;
	ELSEIF CMND = 'B' THENDO
		CALL BIT$MAP;
	ELSEIF CMND = 'M' THENDO
		CALL MARK$BLOCK$NO;
	ELSEIF CMND = 'R' THENDO
		CALL RECALL$BLOCK$NO;
	ELSEIF CMND = 'A' THENDO
		CALL ASSIGN$DISK;
	ELSEIF CMND = 'T' THENDO
		CALL TRANSFER$FILE;
	ELSEIF CMND = '+' THENDO
		CALL ADD$OPERANDS;
	ELSEIF CMND = '-' THENDO
		CALL SUB$OPERANDS;
	ELSEIF CMND = '*' THENDO
		CALL MULT$OPERANDS;
	ELSEIF CMND = '/' THENDO
		CALL DIV$OPERANDS;
	ELSEIF CMND = '%' THENDO
		CALL MOD$OPERANDS;
	ELSEDO
		CALL WRITE$CO$CRLF (.('UNRECOGNIZED COMMAND'), 20);
	IFEND;
WHILEND;
END GANEF;
src/genpex.plm
$title('===> N P E X    (I N C L U D E   M A K E R)  <===')

npex: DO;

/************************************************************************/
/*																		*/
/*     'Copyright 1981,1983 Intel Corporation'.  All rights reserved.	*/
/*      No part of this program or publication may be reproduced,		*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

$IF XVERSION
DECLARE PROPRIETARY(*) BYTE DATA ('INTEL PROPRIETARY SOFTWARE');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=X108',0);
$ELSE
DECLARE COPYRIGHT (*) BYTE DATA  ('COPYRIGHT 1981,1983 INTEL ');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.1',0);
$ENDIF


  /****
   *
   *  PEX:
   *    program to create declarations for external routines and variables.
   *    has been extended to PLM86 in addition to accepting input for PLM80.
   *
   *    The added characters are:
   *         'A'  --  ADDRESS.
   *         'B'  --  BYTE.
   *         'I'  --  INTEGER.
   *         'W'  --  WORD.
   *         'R'  --  REAL.
   *         '@'  --  ADDRESS.
   *         'L'  --  LABEL.
   *         '"'  --  "other types"
   *
   *    The syntax for lines in the input file is as follows:
   *
   *       line      =  plm-var (proc-decl | var-decl).
   *       proc-decl = 'P'&param-list&type.
   *       var-decl  =  (type | '"' plm-var '"') [&'S'] [&'..'&plm-var].
   *       params    = (list-12 | '(' &(type | list-12) ... ')'.
   *       list-12   = '1' | '2'.
   *       type      = 'A' | 'B' | 'I' | 'W' | 'R' | '@' | 'L' | '"text"'.
   *
   *    To use, invoke this program as 
   *
   *      :Fx:NPEX <px-file-list> TO <src-file>
   *
   *    where
   *      <px-file-list> ::= <px-file> , ... .
   *      <src-file>     ::= { ISIS-II file name } .
   *      <px-file>      ::= { ISIS-II file name } .
   *
   ****/


declare NIL literally '0';
declare BOOLEAN literally 'byte';
declare CR literally '0DH';
declare LF literally '0AH';
declare FOREVER literally 'while (1)';
declare ENDDO literally 'end';
declare CHAR literally 'byte';
declare TRUE literally '0FFH';
declare FALSE literally '000H';
declare SCANP address external;
declare SCANBYTE BASED SCANP CHAR;
declare SCANADDR BASED SCANP address;
declare OBUFP address external;
declare SCANENDED BOOLEAN external;
BLNKCH:procedure BOOLEAN external;end;
BUMPSCANP:procedure external;end;
CONSOLEIN:procedure external;end;
DDIGCH:procedure byte external;end;
DECIN:procedure address external;end;
ERRORMESSAGE:procedure(ZZ1) external;declare ZZ1 address;end;
FILECH:procedure BOOLEAN external;end;
FILL:procedure(ZZ1,ZZ2,ZZ3) external;declare ZZ1 address,ZZ2 address,ZZ3 byte;end;
FMOVE:procedure(ZZ1,ZZ2,ZZ3) external;declare ZZ1 address,ZZ2 address,ZZ3 address;end;
FORCUP:procedure CHAR external;end;
FORCUPSTRING:procedure external;end;
LENSTRNUL:procedure(ZZ1) byte external;declare ZZ1 address;end;
LETRCH:procedure BOOLEAN external;end;
LTNMCH: procedure byte external; end;
OUTBLANK:procedure external;end;
OUTCHAR:procedure(ZZ1) external;declare ZZ1 CHAR;end;
OUTDEC:procedure(ZZ1) external;declare ZZ1 address;end;
OUTPRINT:procedure(ZZ1) external;declare ZZ1 address;end;
OUTSCANBYTE:procedure external;end;
OUTWRITE:procedure(ZZ1,ZZ2) external;declare ZZ1 address,ZZ2 byte;end;
PRINT:procedure(ZZ1) external;declare ZZ1 address;end;
PRINTCR:procedure(ZZ1) external;declare ZZ1 address;end;
PUTBLANK:procedure external;end;
PUTCRLF:procedure external;end;
SCANEXPECT:procedure(ZZ1) external;declare ZZ1 address;end;
SCANMATCH:procedure(ZZ1) BOOLEAN external;declare ZZ1 address;end;
SCANUNTIL:procedure(ZZ1) external;declare ZZ1 address;end;
SCANWHILE:procedure(ZZ1) external;declare ZZ1 address;end;
SCANWHILEBLANKS:procedure external;end;
SETOB:procedure(ZZ1) external;declare ZZ1 address;end;
SETSC:procedure(ZZ1) external;declare ZZ1 address;end;
SETSCANENDED:procedure external;end;
TERMCH:procedure BOOLEAN external;end;
TOKNCH:procedure BOOLEAN external;end;
declare STATUS byte external;
declare REPORT BOOLEAN external;
declare FATAL BOOLEAN external;
declare ACTUAL address external;
CLOSEI:procedure external;end;
DEL:procedure(ZZ1) external;declare ZZ1 address;end;
EX:procedure external;end;
ISIS:procedure(ZZ1,ZZ2) external;declare ZZ1 byte,ZZ2 address;end;
MEMCK:procedure address external;end;
OPENI:procedure(ZZ1) external;declare ZZ1 address;end;
OPENO:procedure(ZZ1) external;declare ZZ1 address;end;
READI:procedure(ZZ1,ZZ2) external;declare ZZ1 address,ZZ2 address;end;
WRITEC:procedure(ZZ1,ZZ2) external;declare ZZ1 address,ZZ2 address;end;
WRITEO:procedure(ZZ1,ZZ2) external;declare ZZ1 address,ZZ2 address;end;
EXTRACTROOT: procedure(ZZ1) external; declare (ZZ1) address; end;
FILEERRORMESSAGE:procedure(ZZ1,ZZ2) external;declare ZZ1 address,ZZ2 address;end;
MOVEFILENAME:procedure(ZZ1) external;declare ZZ1 address;end;
NEWEXTENSION:procedure(ZZ1,ZZ2) external;declare ZZ1 address,ZZ2 address;end;
OPENSCAN:procedure(ZZ1) external;declare ZZ1 address;end;
OUTFILENAME:procedure(ZZ1) external;declare ZZ1 address;end;
READIWITHLIMIT:procedure(ZZ1,ZZ2) external;declare ZZ1 address,ZZ2 address;end;
$eject

  DECLARE available            ADDRESS,    /* address of memory available for symbols */
          mem$top              ADDRESS,    /* last address usable */
          thread$head          ADDRESS,
          thread$end           ADDRESS,
          file$name$buffer(15) CHAR;

  DECLARE SYMBOL$TABLE$ENTRY LITERALLY
      'STRUCTURE(NEXT   ADDRESS,
                 MARK   BYTE,
                 THREAD ADDRESS,
                 STR(1) CHAR)',

          SYMBOL$TABLE$SIZE       LITERALLY '256',
          SYMBOL$TABLE$ENTRY$SIZE LITERALLY '5',
          SYMBOL$MAX              LITERALLY '40',
          MARKED                  LITERALLY '0FFH',
          UNMARKED                LITERALLY '0',

          symbol$length ADDRESS,
          hash$value    ADDRESS,

          symbol$table(SYMBOL$TABLE$SIZE) ADDRESS,
          symbol$buffer(256)              CHAR;


  DECLARE NULL$STRING                CHAR DATA(0),
          EXTERNAL$STRING(*)         CHAR DATA(' external',0),
          ADDRESS$VARIABLE$STRING(*) CHAR DATA(' address',0),
          BYTE$VARIABLE$STRING(*)    CHAR DATA(' byte',0),
          POINTER$VARIABLE$STRING(*) CHAR DATA(' pointer',0),
          REAL$VARIABLE$STRING(*)    CHAR DATA(' real',0),
          WORD$VARIABLE$STRING(*)    CHAR DATA(' word',0),
          INTEGER$VARIABLE$STRING(*) CHAR DATA(' integer',0),
          LABEL$STRING(*)            CHAR DATA(' label',0),
          DWORD$VARIABLE$STRING(*)   CHAR DATA(' dword',0),
          SELECTOR$VARIABLE$STRING(*)CHAR DATA(' selector',0);

  DECLARE put$symbol$flag BOOLEAN,
          src$file(15)    CHAR INITIAL (0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),
          src$root(15)    CHAR INITIAL (0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),
          ipx$file(15)    CHAR INITIAL (0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),
          px$file$list$p  ADDRESS INITIAL(.io$buff),
          include$count   ADDRESS INITIAL (0),
          include$begin   ADDRESS,
          io$buff(1024)   CHAR,
          io$buff$idx     ADDRESS INITIAL(0);
  DECLARE chars$on$line   BYTE,
          left$margin     BYTE INITIAL(1);
  DECLARE spath             LITERALLY '14',
          spath$buf(12)     BYTE,
          spath$parm$blk(3) ADDRESS INITIAL(.src$file,.spath$buf,.status),
          numeric$extension BYTE;

  DECLARE state  BYTE INITIAL(1),                /* first line cmd line */
          fsm(6) STRUCTURE(NEXT(6) BYTE) DATA(   /* used to scan files  */
          /* ? lf  $  /  *  A */
             0, 1, 0, 2, 0, 6,
             1, 1, 7, 2, 0, 6,
             0, 1, 0, 2, 3, 6,
             3, 4, 3, 3, 5, 3,
             3, 4, 8, 3, 5, 3,
             3, 4, 3, 0, 5, 3);
$eject

  /****
   *
   *  read$invocation$line:
   *    reads the invocation line into .MEMORY, going past "&" and prompting
   *  for further input with "**" if required
   *
   ****/


  read$invocation$line: PROCEDURE;

    obufp = .memory;
    DO
      FOREVER;
      CALL console$in;
      DO
        WHILE (scan$byte <> '&');
        IF (termch) THEN
          DO;
            CALL out$char(0);        /* terminating null */
            scanp = .memory;
            RETURN;
          END;
        CALL out$scan$byte;
      ENDDO;
      CALL print(.('**',0));
    ENDDO;

  END read$invocation$line;
$eject

  /****
   *
   *  read$px$file$list:
   *    reads in the names of all the files containing definitions into
   *  the array IO$BUFF.  the list is terminated by a NULL.  leaves
   *  SCANP pointing to the character following the last filename
   *
   ****/


  read$px$file$list: PROCEDURE;

    obufp = .io$buff;
    DO
      WHILE (obufp < .io$buff(last(io$buff)));
      CALL scan$while$blanks;
      DO
        WHILE (filech);
        CALL out$scan$byte;
      ENDDO;
      CALL out$blank;               /* file names separated by BLANK */
      CALL scan$while$blanks;
      IF (scan$byte = ',') THEN
        CALL bump$scanp;
      ELSE
        DO;
          CALL out$char(0);       /* terminate list with empty filename */
          RETURN;
        END;
    ENDDO;
    CALL error$message(.('too many files in <px-file-list>',0));

  END read$px$file$list;
$eject

  /****
   *
   *  read$ch:
   *    bumps scanp.  if scan$ended is set, reads more data into the buffer.
   *  when an EOF occurs, scanp is set to point to a null string
   *
   ****/

  read$ch: PROCEDURE;

    CALL bump$scan$p;
    IF (scan$ended) THEN
      DO;
        CALL readi(.io$buff, size(io$buff)-1);
        IF (actual = 0) THEN
          DO;
            scanp = .NULL$STRING;
            CALL set$scan$ended;
            RETURN;
          END;
        io$buff(actual) = 0;
        scanp           = .io$buff;
        CALL set$scan$ended;
      END;

  END read$ch;



  /****
   *
   *  full$line:
   *    assures that there is a TERMCH in the string pointed to by
   *  scanp.  moves data and reads more if required
   *
   ****/

  full$line: PROCEDURE;

    DECLARE temp ADDRESS;

    temp = scanp;
    CALL scan$until(.termch);
    scanp = temp;
    IF (scan$ended) THEN
      DO;
        temp = .io$buff(last(io$buff)) - scanp;
        CALL fmove(temp, scanp, .io$buff);
        CALL readi(.io$buff(temp), size(io$buff) - temp - 1);
        io$buff(actual + temp) = 0;
        scanp = .io$buff;        /* should check long line ... */
      END;
  CALL set$scan$ended;

  END full$line;
$eject

  /****
   *
   *  init$memory:
   *    initializes available and mem$top
   *
   ****/


  init$memory: PROCEDURE;

    DECLARE (m BASED mem$top) BYTE;

    thread$head = .memory;
    available   = .memory;
    mem$top     = memck;
    m           = 0;
    mem$top     = mem$top - 1;

  END init$memory;
$eject

  /****
   *
   *  file$name$line:
   *    returns TRUE and sets file$name$buffer to the file name if scanp points
   *    to a string which specifies a file name.
   *
   ****/


  file$name$line: PROCEDURE BOOLEAN;

    IF (scan$byte <> '$') THEN
      RETURN (FALSE);
    CALL bump$scan$p;
    CALL scan$while$blanks;
    IF (NOT scan$match(.('FILE',0))) THEN
      RETURN (FALSE);
    CALL scan$while$blanks;
    IF (scan$byte <> '(') THEN
      RETURN (FALSE);
    CALL fill(size(file$name$buffer), .file$name$buffer, 0);
    CALL bump$scan$p;
    IF numeric$extension THEN  /* only save root */
      DO;
        CALL scan$while$blanks;
        CALL extract$root(.file$name$buffer);
        CALL scan$while(.file$ch);
        CALL scan$while$blanks;
      END;
    ELSE
      DO;
        IF scan$byte = ':' THEN
          scanp = scanp + 4;
        CALL move$file$name(.file$name$buffer);
      END;
    IF (scan$byte <> ')') THEN
      RETURN (FALSE);
    CALL set$sc(.file$name$buffer);
    CALL forc$up$string;
    RETURN (TRUE);

  END file$name$line;
$eject

  /****
   *
   *  pex$file$matches$file$name:
   *    returns TRUE IF the file name passed in matches the file name in File-
   *    NameBuffer.
   *
   ****/


  pex$file$matches$file$name: PROCEDURE (px$name$ptr) BOOLEAN;

    DECLARE px$name$ptr ADDRESS;
    DECLARE px$name BASED px$name$ptr CHAR;

    IF (px$name = ':') THEN
      px$name$ptr= px$name$ptr + 4;

    CALL set$sc(.file$name$buffer);
    IF scan$match(px$name$ptr) THEN
    DO;
      scanp = px$name$ptr;
      RETURN (scan$match(.file$name$buffer));
    END;
    RETURN false;

  END pex$file$matches$file$name;



  /****
   *
   *  check$gap:
   *    errors out should space overflow.
   *
   ****/


  check$gap: PROCEDURE;

    IF (available >= mem$top) THEN
      CALL error$message(.('dynamic storage overflow.  too many PEX symbols',0));

  END check$gap;
$eject

  /****
   *
   *  point$scanp$to$next$line:
   *    advances scanp to the first character after the current END of line.
   *
   ****/

  point$scanp$to$next$line: PROCEDURE;

    CALL scan$until(.termch);
    CALL scan$while(.termch);

  END point$scanp$to$next$line;



  /****
   *
   *  find$include$file:
   *    searches for the word INCLUDE, then copies the file name to
   *  the area pointed to by obufp
   *
   ****/

  find$include$file: PROCEDURE;

    CALL full$line;
    DO
      WHILE (NOT termch);
      CALL read$ch;
      IF (scan$match(.('INCLUDE',0))) OR (scan$match(.('IC',0))) THEN
        DO;
          CALL scan$until(.filech);
          CALL out$file$name(scanp);
          CALL out$char(0);
          CALL scan$until(.termch);
          include$count = include$count + 1;
          available     = obufp;
          CALL check$gap;
          RETURN;
        END;
      IF (scan$match(.('LEFTMARGIN',0))) OR (scan$match(.('LM',0))) THEN
        DO;
          CALL scan$until(.ddigch);
          left$margin = LOW(decin);
        END;
    ENDDO;

  END find$include$file;
$eject

  /****
   *
   *                 S Y M B O L   -   T A B L E   S E C T I O N
   *
   ****/

  /****
   *
   *  init$symbol$table:
   *    sets all the entries in the symbol table to NIL
   *
   ****/


  init$symbol$table: PROCEDURE;

    DECLARE i ADDRESS;

    i = length(symbol$table);
    DO
      WHILE (i <> 0);
      i = i - 1;
      symbol$table(i) = NIL;
    ENDDO;

  END init$symbol$table;
$eject

  /****
   *
   *  get$id:
   *    copies the symbol currently being pointed to into symbol$buffer, converting
   *    from lower to upper case and discarding '$'.  A maximum of 32 characters
   *    is allowed.  scanp is left pointing to the character which halted the
   *    scan.
   *
   ****/


  get$id: PROCEDURE;

    symbol$length = 0;
    CALL set$ob(.symbol$buffer);
    DO
      WHILE (NOT scan$ended);
      IF (toknch) THEN
        DO;
          CALL out$char(forcup);
          symbol$length = symbol$length + 1;
        END;
      ELSE IF (scan$byte <> '$') THEN
        GOTO exit$loop;
      CALL bump$scanp;
    ENDDO;

exit$loop:;
    IF (symbol$length > SYMBOL$MAX) THEN
      CALL error$message(.('symbol greater than 40 characters long',0));

    CALL out$char(0);

  END get$id;
$eject

  /****
   *
   *  hash:
   *    sets hash$value to the hashed value of symbol$buffer;
   *
   ****/

  hash: PROCEDURE;

    DECLARE i BYTE;

    i = 0;
    CALL set$sc(.symbol$buffer);
    CALL set$scan$ended;
    DO
      WHILE (NOT scan$ended);
      i = i + scan$byte;
      CALL bump$scan$p;
    ENDDO;

    hash$value = i;

  END hash;



  /****
   *
   *  lookup$id:
   *    searches the symbol table for the entry with ID = symbol$buffer.
   *
   ****/


  lookup$id: PROCEDURE ADDRESS;

    DECLARE ptr         ADDRESS,
            p BASED ptr SYMBOL$TABLE$ENTRY;

    CALL hash;
    ptr = symbol$table(hash$value);
    CALL set$sc(0);
    DO
      WHILE (ptr <> NIL);
      scanp = .symbol$buffer;           /* this is NOT string equality */
      IF (scan$match(.p.STR(0))) THEN
        IF (scan$byte = 0) THEN
          RETURN (ptr);
      ptr = p.NEXT;
    ENDDO;

    RETURN (NIL);

  END lookup$id;
$eject

  /****
   *
   *  insert$pex$symbol:
   *    the string pointed to by scanp is inserted into the symbol table.
   *    NOTE:  the symbol tables grow towards mem$top from available.
   *
   ****/


  insert$pex$symbol: PROCEDURE (mark$value);

    DECLARE mark$value BYTE;

    DECLARE pex$data$string$ptr    ADDRESS,
            ste$p                  ADDRESS,
            ste$b BASED ste$p      SYMBOL$TABLE$ENTRY,
            pex$data$string$length ADDRESS;

    CALL get$id;
    CALL scan$while$blanks;
    pex$data$string$ptr = scanp;
    CALL scan$until(.termch);
    pex$data$string$length = scanp - pex$data$string$ptr;

    ste$p = available;
    obufp = .ste$b.STR(0);
    CALL out$print(.symbol$buffer);
    CALL out$char(0);
    CALL out$write(pex$data$string$ptr, pex$data$string$length);
    CALL out$char(0);
    available = obufp;
    CALL check$gap;

    CALL hash;
    ste$b.NEXT   = symbol$table(hash$value);
    ste$b.MARK   = mark$value;
    ste$b.THREAD = available;

    symbol$table(hash$value) = ste$p;

  END insert$pex$symbol;
$eject

  /****
   *
   *  mark$internal$references:
   *    assures that symbols containing references to other symbols (BASEd var-
   *    iables and literallys) are included in the declarations.
   *
   ****/


  mark$internal$references: PROCEDURE (mark$value, str$p) REENTRANT;

    DECLARE mark$value BYTE,
            str$p      ADDRESS;

    DECLARE save$scanp ADDRESS;

    save$scanp = scanp;
    scanp      = str$p;
    DO
      WHILE (scan$byte <> 0);
      IF (scan$byte = '.') THEN
        CALL find$and$mark(mark$value);
      ELSE IF ((scan$byte = '"') OR (scan$byte = '''')) THEN        /* only one level is allowed */
        DO
          WHILE (scan$byte <> 0);
          CALL find$and$mark(mark$value);
        ENDDO;
      CALL bump$scan$p;
    ENDDO;
    scanp = save$scanp;

  END mark$internal$references;
$eject

  /****
   *
   *  mark$id:
   *    looks up the symbol in symbol$buffer.  If found, sets MARK to the passed
   *    in value.
   *
   ****/


  mark$id: PROCEDURE (mark$value) REENTRANT;

    DECLARE mark$value BYTE;

    DECLARE ste$p             ADDRESS,
            ste$b BASED ste$p SYMBOL$TABLE$ENTRY,
            save$scanp        ADDRESS;

    save$scanp = scanp;
    ste$p = lookup$id;
    IF (ste$p <> NIL) THEN
      IF (ste$b.MARK <> mark$value) THEN
        DO;
          ste$b.MARK = mark$value;
          CALL mark$internal$references(mark$value, .ste$b.STR(1) + lenstrnul(.ste$b.STR));
          ste$p = ste$b.NEXT;
          DO
            WHILE (ste$p <> NIL);
            scanp = .symbol$buffer;
            IF (scan$match(.ste$b.STR(0))) THEN
              IF (scan$byte = 0) THEN
                DO;
                  ste$b.MARK = mark$value;
                  CALL mark$internal$references(mark$value, .ste$b.STR(1) + lenstrnul(.ste$b.STR));
                END;
            ste$p = ste$b.NEXT;
          ENDDO;
        END;
    scanp = save$scanp;

  END mark$id;



  /****
   *
   *  find$and$mark:
   *    bump scanp to the next letter, get the symbol and set its mark field to
   *    the passed in value.
   *
   ****/


  find$and$mark: PROCEDURE (mark$value) REENTRANT;

    DECLARE mark$value BYTE;

    CALL scan$until(.toknch);
    CALL get$id;
    CALL mark$id(mark$value);

  END find$and$mark;
$eject

  /****
   *
   *  flush$io$buff:
   *    dumps io$buff to the output file
   *
   ****/


  flush$io$buff: PROCEDURE;
  
    CALL writeo(.io$buff, io$buff$idx);
    io$buff$idx = 0;

  END flush$io$buff;




  /****
   *
   *  write$char:
   *    writes the character to the output file
   *
   ****/


  write$char: PROCEDURE (ch);

    DECLARE ch CHAR;

    io$buff(io$buff$idx) = ch;
    io$buff$idx          = io$buff$idx + 1;
    IF (io$buff$idx > last(io$buff)) THEN
      CALL flush$io$buff;
    chars$on$line = chars$on$line + 1;

  END write$char;



  /****
   *
   *  write$string:
   *    writes the null terminated string to the output file
   *
   ****/


  write$string: PROCEDURE (s$p);

    DECLARE s$p ADDRESS;

    CALL setsc(s$p);
    DO
      WHILE (scan$byte <> 0);
      CALL write$char(scan$byte);
      CALL bump$scan$p;
    ENDDO;

  END write$string;
$eject

  /****
   *
   *  write$number:
   *    writes the decimal ADDRESS using write$char.
   *
   ****/


  write$number: PROCEDURE (number);

    DECLARE number ADDRESS;

    DECLARE nbuff(6) CHAR;

    CALL fill(6, .nbuff, 0);
    CALL set$ob(.nbuff);
    CALL out$dec(number);
    CALL write$string(.nbuff);

  END write$number;
$eject

  write$declare: PROCEDURE;
    CALL write$string(.('declare ',0));
  END write$declare;

  write$semi: PROCEDURE;
    CALL write$char(';');
  END write$semi;

  write$comma: PROCEDURE;
    CALL write$char(',');
  END write$comma;

  write$lp: PROCEDURE;
    CALL write$char('(');
  END write$lp;

  write$rp: PROCEDURE;
    CALL write$char(')');
  END write$rp;

  write$crlf: PROCEDURE;
    CALL write$string(.(CR,LF,0));
    chars$on$line = 0;
  END write$crlf;

  write$left$margin: PROCEDURE;
    DECLARE i BYTE;
    IF left$margin = 0 THEN RETURN;
    i = left$margin - 1;
    DO WHILE i > 0;
      CALL write$char(' ');
      i = i - 1;
    END;
  END;


  /****
   *
   *  write$lit:
   *    writes the definition as a literally statement.
   *
   ****/


  write$lit: PROCEDURE;

    CALL write$left$margin;
    CALL write$declare;
    CALL write$string(.symbol$buffer);
    CALL write$string(.(' literally ',0));
    CALL write$string(scanp);
    CALL write$semi;
    CALL write$crlf;

  END write$lit;
$eject

  /****
   *
   *  chr$idx:
   *    returns an index of the character pointed to by scanp.
   *
   ****/


  chr$idx: PROCEDURE (s$p) ADDRESS;

    DECLARE s$p ADDRESS;

    DECLARE i             BYTE,
            s$b BASED s$p CHAR,
            ch            CHAR;

    i  = 1;
    ch = forcup;
    DO
      WHILE (s$b <> 0);
      IF (s$b = ch) THEN
        RETURN (i);
      s$p = s$p + 1;
      i   = i + 1;
    ENDDO;

    RETURN (0);

  END chr$idx;
$eject

  /****
   *
   *  quote$ch:
   *    returns TRUE if the scan$byte is a '"'
   *
   ****/


  quote$ch: PROCEDURE BOOLEAN;

    RETURN (scan$byte = '"');

  END quote$ch;



  /****
   *
   *  err$msg$flush:
   *    flushes the io$buff (to the IPX file) before reporting error and exit
   *
   ****/

  err$msg$flush: PROCEDURE(ptr);
    DECLARE ptr ADDRESS;
    CALL flush$io$buff;
    CALL error$message(ptr);
  END;




  /****
   *
   *  copy$to$symbol$buffer:
   *    copies into symbol$buffer from scanp until a '"' is seen.  appends
   *  a null onto the end
   *
   ****/

  copy$to$symbol$buffer: PROCEDURE;

    CALL bump$scan$p;
    CALL setob(.symbol$buffer);
    CALL out$blank;
    CALL scan$while$blanks;
    DO
      WHILE (NOT quote$ch);
      IF (scan$ended) THEN
        CALL err$msg$flush(.('trailing ''"'' left off of declaration',0));
      CALL out$scan$byte;
    END;
    CALL out$char(0);

  END copy$to$symbol$buffer;
$eject

  /****
   *
   *  write$var:
   *    writes a declaration for the variable with the given type.
   *
   ****/


  write$var: PROCEDURE;

    DECLARE TYPE$TBL(*) CHAR DATA('ABIWDS@R"L',0),
            TYPE$PTR(*) ADDRESS DATA(
              .NULL$STRING,
              .ADDRESS$VARIABLE$STRING,
              .BYTE$VARIABLE$STRING,
              .INTEGER$VARIABLE$STRING,
              .WORD$VARIABLE$STRING,
              .dword$variable$string,
              .selector$variable$string,
              .POINTER$VARIABLE$STRING,
              .REAL$VARIABLE$STRING,
              .symbol$buffer,
              .LABEL$STRING),
            idx ADDRESS,
      (based$ptr, array$ptr, bvar$ptr) ADDRESS;

    CALL write$left$margin;
    CALL write$declare;
    CALL write$string(.symbol$buffer);
    CALL set$ob(.symbol$buffer);
    idx = chr$idx(.TYPE$TBL);
    IF (scan$byte = '"') THEN
      CALL copy$to$symbol$buffer;
    CALL bump$scan$p;
$eject

    based$ptr, array$ptr, bvar$ptr= .NULL$STRING;
    DO
      WHILE (NOT scan$ended);

      CALL scan$while$blanks;
      IF (forcup = 'S') THEN
        DO;
          array$ptr = .('(1)',0);
          CALL bump$scan$p;
        END;
      ELSE IF (scan$addr = '..') THEN
        DO;
           based$ptr       = .(' BASED ',0);
           scanp, bvar$ptr = scanp + 2;
           CALL scan$until(.blnkch);
           IF (NOT scan$ended) THEN
             DO;
               scan$byte = 0;
               scanp     = scanp + 1;
             END;
        END;
      ELSE IF (NOT scan$ended) THEN
        DO;
          CALL print(scanp);
          CALL err$msg$flush(.('bad pex line',0));
        END;
    ENDDO;

    CALL write$string(based$ptr);
    CALL write$string(bvar$ptr);
    CALL write$string(array$ptr);

    CALL write$string(TYPE$PTR(idx));
    IF (bvar$ptr = .NULL$STRING) THEN
      CALL write$string(.EXTERNAL$STRING);
    CALL write$semi;
    CALL write$crlf;
  END write$var;
$eject

  /****
   *
   *  pex$error:
   *    prints an error message on the terminal and exits.
   *
   ****/


  pex$error:
    PROCEDURE;

    CALL print$cr(.('bad PEX line',0));
    CALL print(.symbol$buffer);
    CALL put$blank;
    CALL print$cr(scanp);
    CALL flush$io$buff;
    CALL ex;

  END pex$error;
$eject

  /****
   *
   *  write$proc:
   *    writes the declaration of a procedure.  The format of a procedure declar-
   *    ation is p[argument-list][type].  argument-list is either a string of
   *    '1' or '2', or '(' type-characters ')'.  type is type-character.
   *    type-character is one of the characters '@RIWAB"'.
   *
   ****/


  write$proc: PROCEDURE;

    DECLARE PARAM$TYPE$STRING(*)     CHAR DATA('ABWDS@IR"21',0),
            PARAM$1$2$TYPE$STRING(2) CHAR AT(.PARAM$TYPE$STRING(9)),
            PARAM$TYPE$TBL(*)        ADDRESS DATA(
              .NULL$STRING,
              .ADDRESS$VARIABLE$STRING,
              .BYTE$VARIABLE$STRING,
              .WORD$VARIABLE$STRING,
              .dword$variable$string,
              .selector$variable$string,
              .POINTER$VARIABLE$STRING,
              .INTEGER$VARIABLE$STRING,
              .REAL$VARIABLE$STRING,
              .symbol$buffer,
              .ADDRESS$VARIABLE$STRING,
              .BYTE$VARIABLE$STRING),
            ZZ$STRING(*)     CHAR DATA('ZZ',0),
            saved$scanp      ADDRESS,
            arg$end          ADDRESS,
            (i, j, params)   ADDRESS;

    check$line$len: PROCEDURE;
      IF chars$on$line > 71 THEN
        DO;
          CALL write$crlf;
          CALL write$left$margin;
          CALL write$string(.('  ',0));
        END;
    END;

    write$args: PROCEDURE (p);
      DECLARE p ADDRESS;
      CALL write$lp;
      DO
        FOREVER;
        CALL write$string(.ZZ$STRING);
        params = params + 1;
        CALL write$number(params);
        IF (quote$ch) THEN
          DO;
            CALL bump$scan$p;
            CALL scan$until(.quote$ch);
          END;
        CALL bump$scan$p;
        IF (chr$idx(p) = 0) THEN
          DO;
            CALL write$rp;
            RETURN;
          END;
        CALL write$comma;
        CALL check$line$len;
      ENDDO;
    END write$args;
$eject

    chars$on$line = 0;
    CALL bump$scan$p;
    CALL write$left$margin;
    CALL write$string(.symbol$buffer);
    CALL write$string(.(':procedure',0));
    params = 0;
    CALL scan$while$blanks;
    IF (scan$byte = '(') THEN
      DO;
        CALL bump$scan$p;
        saved$scanp = scanp;
        CALL write$args(.PARAM$TYPE$STRING);
        arg$end = scanp;
        IF (scan$byte <> ')') THEN
          CALL err$msg$flush(.('Missing closing '')'' in procedure definition',0));
        CALL bump$scan$p;
      END;
    ELSE IF ((scan$byte = '1') OR (scan$byte = '2')) THEN
      DO;
        saved$scanp = scanp;
        CALL write$args(.PARAM$1$2$TYPE$STRING);
        arg$end = scanp;
      END;
$eject

    CALL set$scan$ended;
    CALL scan$while$blanks;
    IF (quote$ch) THEN
      CALL copy$to$symbol$buffer;
    CALL write$string(PARAM$TYPE$TBL(chr$idx(.PARAM$TYPE$STRING)));
    CALL write$string(.EXTERNAL$STRING);
    CALL write$semi;
    CALL check$line$len;

    IF (params <> 0) THEN
      DO;
        CALL write$declare;
        scanp = saved$scanp;
        j     = 1;
        DO
          WHILE (scanp < arg$end);
          CALL write$string(.ZZ$STRING);
          CALL write$number(j);
          IF (scan$byte = '"') THEN
            CALL copy$to$symbol$buffer;
          CALL write$string(PARAM$TYPE$TBL(chr$idx(.PARAM$TYPE$STRING)));
          CALL bump$scan$p;
          j      = j + 1;
          params = params - 1;
          IF (params <> 0) THEN
            DO;
              CALL write$comma;
              CALL check$line$len;
            END;
          ELSE
            CALL write$semi;
        ENDDO;
      END;

    CALL write$string(.('end;',CR,LF,0));

  END write$proc;
$eject

  /****
   *
   *  write$dcl:
   *    The symbol being defined is placed into symbol$buffer.  The first
   *    non-blank character of the definition string (pointed to by
   *    id$text$ptr) is used to determine whether a variable, procedure
   *    or literal declaration is to be produced.
   *
   ****/


  write$dcl: PROCEDURE (id$p, id$text$p);

    DECLARE (id$p, id$text$p) ADDRESS;

    DECLARE prc           ADDRESS,
            PROC$TABLE(*) ADDRESS DATA(
              .pex$error,                  /* unknown character */
              .write$proc,                 /*  P  */
              .write$var,                  /*  A  */
              .write$var,                  /*  B  */
              .write$lit,                  /*  '  */
              .write$var,                  /*  @  */
              .write$var,                  /*  R  */
              .write$var,                  /*  W  */
              .WRITE$VAR,                  /*  d  */
              .WRITE$VAR,                  /*  s  */
              .write$var,                  /*  i  */
              .write$var,                  /*  "  */
              .write$var);                 /*  L  */

    scanp = id$text$p;
    CALL set$scan$ended;
    obufp = .symbol$buffer;
    CALL out$print(id$p);
    CALL out$char(0);
    CALL scan$while$blanks;
    prc = PROC$TABLE(chr$idx(.('PAB''@RWDSI"L',0)));
    CALL prc;

  END write$dcl;
$eject

  /****
   *
   *  dump$dcls:
   *    writes the declarations for all those entries whose MARK field
   *  is equal to MARK$VALUE
   *
   ****/


  dump$dcls: PROCEDURE (mark$value);

    DECLARE mark$value BYTE;

    DECLARE s$p           ADDRESS,
            sym$p         ADDRESS,
            col           BYTE,
            len           BYTE,
            s$b BASED s$p SYMBOL$TABLE$ENTRY;

    s$p = thread$head;
    col = 0;
    CALL put$crlf;
    DO
      WHILE (s$p < thread$end);
      IF (s$b.MARK = mark$value) THEN
        DO;
          sym$p = .s$b.STR;
          len   = lenstrnul(sym$p) + 1;
          col   = col + len;
          IF (col > 78) THEN            /* line end */
            DO;
              col = len;
              CALL put$crlf;
            END;
          CALL print(sym$p);
          CALL put$blank;
          CALL write$dcl(sym$p, sym$p + len);
        END;
      s$p = s$b.THREAD;
    ENDDO;
    CALL flush$io$buff;

  END dump$dcls;
$eject

  /****
   *
   *  class:
   *    returns the class of scan$byte
   *
   ****/


  class: PROCEDURE ADDRESS;

    IF (letrch) THEN
      RETURN (5);
    RETURN (chr$idx(.(LF,'$/*',0)));     /* all others are class 0 */

  END class;
$eject

  /****
   *
   *  Main module:
   *    initialize memory and symbol table.
   *    read in command line and get filenames for SRC$FILE and PX$FILEs.
   *    read in PX$FILEs, creating symbol table with all entries UNMARKed.
   *    read in SRC$FILE
   *    for each token until the END of the file, set its ste$b as MARKed.
   *    delete all UNMARKed STEs.
   *    transform the symbol table to preserve space.
   *    open SRC$FILE.IPX
   *    write the declarations.
   *    exit.
   *
   ****/


  FATAL, REPORT = TRUE;           /* blab about errors */
  CALL read$invocation$line;
  CALL read$px$file$list;
  CALL scan$while$blanks;
  CALL scan$expect(.('TO',0));
  CALL scan$while$blanks;
  CALL forc$up$string;
  CALL extract$root(.src$root);
  CALL move$file$name(.src$file);
  CALL ISIS(spath,.spath$parm$blk);
  scanp = .spath$buf(7);  /* first extension char */
  CALL scan$while(.ddigch);
  numeric$extension = (scanp = .spath$buf(10));
$IF XVERSION
  CALL printcr(.(CR,LF,'ISIS-II GENPEX X108',CR,LF,0));
$ELSE
  CALL printcr(.(CR,LF,'ISIS-II GENPEX V1.1',CR,LF,0));
$ENDIF
  CALL init$memory;
  CALL init$symbol$table;
$eject

  DO
    WHILE (lenstrnul(px$file$list$p) <> 0);

    scanp  = px$file$list$p;      /* get next file name in list */
    report = FALSE;               /* turn off error reporting   */
    CALL open$scan(.openi);       /* open it, advancing SCANP   */
    report = TRUE;                /* error report & bomb out if */
    IF (status <> 0) THEN         /* file couldn't be opened    */
      CALL file$error$message(.('could not open',0), px$file$list$p);

    CALL print(.('reading ',0));  /* display file name          */
    CALL writec(px$file$list$p, scanp - px$file$list$p);
    px$file$list$p = scanp + 1;   /* and remember new position  */
    CALL put$crlf;

    /* read in the <px-file> */
    CALL readi$with$limit(available, mem$top - available + 1);
    CALL closei;
    CALL fmove(actual, available, (scanp := mem$top - actual + 1));

    put$symbol$flag = TRUE;
    CALL set$scan$ended;
    DO
      WHILE (NOT scan$ended);
      IF (toknch) THEN
        DO;
          IF (put$symbol$flag) THEN
            CALL insert$pex$symbol(UNMARKED);
        END;
      ELSE IF (file$name$line) THEN
        DO;
          IF numeric$extension THEN  /* only match root */
            put$symbol$flag = NOT pex$file$matches$file$name(.src$root);
          ELSE
            put$symbol$flag = NOT pex$file$matches$file$name(.src$file);
        END;
      CALL point$scanp$to$next$line;
    ENDDO;
  ENDDO;
  thread$end = available;
$eject

  /*
   * scan the source file for identifiers appearing in the symbol table
   * and mark the symbol table entries as being used.
   */

  scanp = .src$file;              /* create the .IPX file name       */
  CALL new$extension(.ipx$file, .('IPX',0));
  REPORT, FATAL = FALSE;          /* make no noise if it isn't there */
  CALL del(.ipx$file);            /* delete previous .IPX file       */
  REPORT, FATAL = TRUE;
  CALL print(.('- - - -',CR,LF,'source: ',0));
  CALL printcr(.src$file);
  CALL openi(.src$file);
  include$begin, obufp = available;     /* remember file names here */
  scanp                = .NULL$STRING;  /* cause READ$CH to read in data */
  DO
    FOREVER;
    CALL read$ch;
    IF (scan$ended) THEN
      DO;
        CALL closei;
        status        = 0FFH;
        fatal,report  = FALSE;
        DO                /* open include files */
          WHILE (status <> 0);
          IF (include$count = 0) THEN
            DO;
              fatal, report = TRUE;
              GOTO exit$loop;
            END;
          include$count = include$count - 1;
          scanp         = include$begin;
          CALL print(.('source: ',0));
          CALL print$cr(scanp);
          CALL open$scan(.openi);
          include$begin = scanp + 1;
        ENDDO;
        fatal, report = TRUE;
        scanp         = .NULL$STRING;
      END;
    ELSE
      DO;
        state = fsm(state).NEXT(class);
        IF (state = 6) THEN
          DO;
            CALL full$line;
            CALL find$and$mark(MARKED);
            state = 0;
          END;
        ELSE IF (state > 6) THEN
          DO;
            CALL find$include$file;
            IF (state = 8) THEN
              state = 3;     /* continue scanning comment */
            ELSE
              state = 0;     /* otherwise start again */
          END;
      END;
  ENDDO;
exit$loop:;
$eject

  /*
   * write the declarations
   */

  CALL openo(.ipx$file);
  CALL dump$dcls(MARKED);

  CALL put$crlf;
  CALL ex;

END npex;
src/goto.plm
GOTO$MOD: DO;

/************************************************************************/
/*																		*/
/*     'Copyright 1981,1983 Intel Corporation'.  All rights reserved.	*/
/*      No part of this program or publication may be reproduced,		*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

$IF XVERSION
DECLARE PROPRIETARY(*) BYTE DATA ('INTEL PROPRIETARY SOFTWARE');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=X103',0);
$ELSE
DECLARE COPYRIGHT (*) BYTE DATA  ('COPYRIGHT 1981,1983 INTEL ');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.1',0);
$ENDIF


DECLARE	LIT		LITERALLY	'LITERALLY',
		DCL		LIT	'DECLARE',
		TRUE	LIT	'0FFH',
		FALSE	LIT	'000H',
		PROC	LIT	'PROCEDURE',
		PROCEND	LIT	'END',
		THENDO	LIT	'THEN DO;',
		ELSEIF	LIT	'END; ELSE IF',
		ELSEDO	LIT	'END; ELSE DO;',
		IFEND	LIT	'END',
		WHILEND	LIT	'END',
		CR		LIT	'0DH',
		LF		LIT	'0AH';

EXIT:	PROC EXTERNAL;											PROCEND;
READ:	PROC (A,B,C,D,E) EXTERNAL;	DCL (A,B,C,D,E) ADDRESS;	PROCEND;
WRITE:	PROC (A,B,C,D) EXTERNAL;	DCL (A,B,C,D) ADDRESS;		PROCEND;
SEEK:	PROC (A,B,C,D,E) EXTERNAL;	DCL (A,B,C,D,E) ADDRESS;	PROCEND;
SPATH:	PROC (A,B,C) EXTERNAL;		DCL (A,B,C) ADDRESS;		PROCEND;
DEBLANK:PROC (A) ADDRESS EXTERNAL;	DCL (A) ADDRESS;			PROCEND;
SEQ:	PROC (A,B,C) BYTE EXTERNAL;	DCL (A,B,C) ADDRESS;		PROCEND;
FORCE$UPPER:	PROC(A) EXTERNAL;	DCL (A) ADDRESS;			PROCEND;

DCL (STATUS, ACTUAL) ADDRESS;
DCL (CMND$PTR) ADDRESS, (CMND$CH BASED CMND$PTR) (1) BYTE;
DCL (PN1, PN2) STRUCTURE
	(DEV BYTE, NAME (6) BYTE, EXT (3) BYTE, DEV$TYPE BYTE, DRIVE$TYPE BYTE);

CMND$ERROR: PROC (MSG, MSGLEN);
DCL (MSG, MSGLEN) ADDRESS;
	CALL WRITE (0, .('Command tail error near #: '), 27, .STATUS);
	CALL WRITE (0, MSG, MSGLEN, .STATUS);
	CALL WRITE (0, .(' expected.', CR, LF), 12, .STATUS);
	CALL WRITE (0, .MEMORY, CMND$PTR - .MEMORY, .STATUS);
	CALL WRITE (0, .('#', CR, LF), 3, .STATUS);
	CALL EXIT;
PROCEND CMND$ERROR;

/* Read in the initial command line. */
CALL READ (1, .MEMORY, 128, .ACTUAL, .STATUS);
MEMORY (ACTUAL - 1) = CR;
CALL FORCE$UPPER (.MEMORY);

/* Scan the command line. */
CMND$PTR = DEBLANK (.MEMORY);
IF CMND$CH (0) = CR THENDO /* Null command tail. */
$IF XVERSION
	CALL WRITE (0, .('ISIS-II GOTO X103', CR, LF), 19, .STATUS);
$ELSE
	CALL WRITE (0, .('ISIS-II GOTO V1.1', CR, LF), 19, .STATUS);
$ENDIF
	CALL EXIT;
IFEND;
CALL SPATH (CMND$PTR, .PN1, .STATUS);
IF STATUS <> 0 THENDO /* Bad label. */
	CALL CMND$ERROR (.('<label>'), 7);
IFEND;

ACTUAL = 0;
CALL SEEK (1, 2, .ACTUAL, .ACTUAL, .STATUS); /* Rewind command file. */
IF STATUS <> 0 THENDO /* Can't seek, probably not in submit. */
	CALL EXIT;
IFEND;
DO WHILE TRUE;
	CALL WRITE (0, .('#'), 1, .STATUS);
	CALL READ (1, .MEMORY, 128, .ACTUAL, .STATUS);
	IF (STATUS <> 0) OR (ACTUAL = 0) THENDO
		CALL EXIT; /* Probably end of file. */
	IFEND;
	MEMORY (ACTUAL - 1) = CR;
	CALL FORCE$UPPER (.MEMORY);
	CMND$PTR = DEBLANK (.MEMORY);
	IF SEQ (CMND$PTR, .(';;'), 2) THENDO /* A possible label. */
		CMND$PTR = DEBLANK (CMND$PTR + 2);
		ACTUAL = 1;
		DO WHILE ACTUAL < 15;
			IF CMND$CH (ACTUAL) = ':' THENDO
				CMND$CH (ACTUAL) = ' ';
			IFEND;
			ACTUAL = ACTUAL + 1;
		WHILEND;
		CALL SPATH (CMND$PTR, .PN2, .STATUS);
		IF STATUS = 0 THENDO /* A valid label. */
			IF SEQ (.PN1, .PN2, 10) THENDO /* We found the label. */
				CALL EXIT;
			IFEND;
		IFEND;
	IFEND;
WHILEND;

END GOTO$MOD;
src/hdback.plm
HARD$DISK$BACKUP:  do;

/************************************************************************/
/*																		*/
/*     'Copyright 1981,1983 Intel Corporation'.  All rights reserved.	*/
/*      No part of this program or publication may be reproduced,		*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

$IF XVERSION
DECLARE PROPRIETARY(*) BYTE DATA ('INTEL PROPRIETARY SOFTWARE');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=X222',0);
$ELSE
DECLARE COPYRIGHT (*) BYTE DATA  ('COPYRIGHT 1981,1983 INTEL ');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V2.3',0);
$ENDIF

    


/**********************************************************************
 *                                                                    *
 * This program is designed to be used in backing up a hard disk      *
 * platter to floppy disks.  It allows wildcard filenames as well     *
 * as the additional selection based on the file attributes.          *
 * Invocation is as follows:                                          *
 *                                                                    *
 *    [:F#:]BACKUP filename [{W{0|1} I{0|1} S{0|1}}] [C] [DELETE]     *
 *        where:  filename ::= pathname | device                      *
 *                device ::= :Fn:                                     *
 *                                                                    *
 * The interpretation when an attribute is used is to backup the file *
 * only if there is a filename match and the attribute is set(reset)  *
 * By not specifying the attribute, the all of the attributes will    *
 * be ignored (except for the Format attribute).                      *
 * Files with the Format attribute will never be copied.              *
 *                                                                    *
 * The files are always transfered to drive 5 first, then drive 4,... *
 *                                                                    *
 * If the C switch is used, then the attributes of the target files   *
 * are retained in the backup files.                                  *
 *                                                                    *
 * if the DELETE switch is used, then all files without the format    *
 * attribute on the target disk will be deleted                       *
 *                                                                    *
 **********************************************************************/


/* The following literally declarations are used to map PLM80 into
   PLM86 code
*/

declare word literally 'address';
declare integer literally 'address';
declare pointer literally 'address';


declare as literally 'literally';
declare dcl as 'declare';

dcl boolean as 'byte';
dcl true as '0FFH';
dcl false as '0';
dcl ptr as 'word';
dcl nil as '0';
dcl character as 'byte';
dcl char2 as 'word';
dcl varying as '1';

dcl for as 'do';
dcl endfor as 'end';
dcl thenn as 'then do;';
dcl elseif as 'end; else if';
dcl elsee as 'end; else do;';
dcl endif as 'end';
dcl whilee as 'do while';
dcl endwhile as 'end';
dcl endproc as 'end';
dcl endmod as 'end';
dcl enddo as 'end';


dcl COMMA as ''',''';
dcl CR as '0DH';
dcl LF as '0AH';
dcl ESC as '1BH';
dcl AMPERSAND as '''&''';

$IF XVERSION
dcl VERSION(4) character initial('X222');
$ELSE
dcl VERSION(4) character initial('V2.3');
$ENDIF
dcl COMMAND$LINE(128) character;
dcl COMMAND$PTR ptr;
dcl COMMAND$LINE$LENGTH word;
dcl BACKUP$PARM$BLOCK structure(
    DEVICE(4) character,
    FILENAME(11) character,
    W$ATTR boolean,
    S$ATTR boolean,
    I$ATTR boolean,
    CHANGE$W byte,
    CHANGE$S byte,
    CHANGE$I byte,
    OUTPUT$LIST$ELEMENTS byte,
    OUTPUT$LIST(4) character);
dcl (ACTUAL, STATUS) word;
dcl SELECTED$DEVICE(10) boolean initial(
     false,false,false,false,false,false,false,false,false,false);

dcl DELETE$OPTION boolean public initial(false); /*default-- nodelete*/
DCL keep$attribs BOOLEAN PUBLIC INITIAL(FALSE);

EXIT: procedure external;
end EXIT;

READ: procedure(AFTN, BUF$PTR, LEN, ACTUAL$PTR, STATUS$PTR) external;
   dcl (AFTN,LEN) word;
   dcl (BUF$PTR, ACTUAL$PTR, STATUS$PTR) pointer;
end READ;

WRITE: procedure(AFTN, BUF$PTR, LEN, STATUS$PTR) external;
   dcl (AFTN, LEN) word;
   dcl (BUF$PTR, STATUS$PTR) pointer;
end WRITE;


write$co: PROCEDURE(buf$ptr,len) PUBLIC;
  DCL buf$ptr POINTER, len WORD;
  CALL write(0,buf$ptr,len,.status);
END write$co;

write$co$crlf: PROCEDURE PUBLIC;
  CALL write(0,.(CR,LF),2,.status);
END write$co$crlf;


ERROR: procedure(STRING$PTR, PTR1);
   dcl (STRING$PTR, PTR1) pointer;
   dcl STRING based STRING$PTR (varying) character;
   dcl I word;

   call write$co(.('ERROR, NEAR #, ',CR,LF),17);
   call write$co(.COMMAND$LINE, PTR1 - .COMMAND$LINE);
   call write$co(.('#'),1);
   call write$co(.COMMAND$LINE(PTR1 - .COMMAND$LINE),
                   COMMAND$LINE$LENGTH - (PTR1 - .COMMAND$LINE));
   call write$co$crlf;
   
   I = 0;
   whilee STRING(I) <> 0;
      I = I + 1;
   endwhile;
   if I <> 0 thenn
      call write$co(STRING$PTR,I);
      call write$co$crlf;
   endif;
   call EXIT;
end ERROR;


SIGN$ON: procedure(VERSION$PTR);
   dcl VERSION$PTR pointer;

   call write$co(.(CR,LF,'ISIS-II HARD-DISK BACKUP PROGRAM, '),36);
   call write$co(VERSION$PTR,4);
   call write$co$crlf;
end SIGN$ON;

DEBLANK: procedure(PTR1) pointer;
   dcl PTR1 pointer;
   dcl CHAR1 based PTR1 character;

   do while (CHAR1 = ' ') OR (char1 = 09H); /* HT */
      PTR1 = PTR1 + 1;
   enddo;
   return PTR1;
endproc DEBLANK;

GET$DEVICE: procedure(PTR1) pointer;
   dcl PTR1 pointer;
   dcl CHAR1 based PTR1 character;
   dcl DEFAULT$DEVICE(*) character data(':F0:');

   if CHAR1 = ':' thenn
      call move(length(BACKUP$PARM$BLOCK.DEVICE), PTR1, .BACKUP$PARM$BLOCK.DEVICE);
      PTR1 = PTR1 + 2;
      if CHAR1 >= '0' and CHAR1 <= '9' thenn
         SELECTED$DEVICE(CHAR1 - '0') = true;
      endif;
      PTR1 = PTR1 + 2;
   elsee
      call move(length(DEFAULT$DEVICE), .DEFAULT$DEVICE, .BACKUP$PARM$BLOCK.DEVICE);
      SELECTED$DEVICE(0) = true;
   endif;
   return PTR1;
endproc GET$DEVICE;

GET$FILENAME: procedure(PTR1) pointer;
   dcl PTR1 pointer;
   dcl CHAR1 based PTR1 character;
   dcl NULLS(*) character data(0,0,0,0,0,0,0,0,0,0,0,0);
   dcl INDEX byte;
   dcl DEFAULT$FILES(*) character data('*.*',0);
   
   call move(length(BACKUP$PARM$BLOCK.FILENAME), .NULLS,
                   .BACKUP$PARM$BLOCK.FILENAME);
   INDEX = 0;
   whilee true;
      if (CHAR1 >= 'A' and CHAR1 <= 'Z') or
         (CHAR1 >= '0' and CHAR1 <= '9') or
         CHAR1 = '*' or CHAR1 = '.' or CHAR1 = '?' thenn
         BACKUP$PARM$BLOCK.FILENAME(INDEX) = CHAR1;
      elsee
         if INDEX = 0 thenn /* no files specified, use *.* */
            call move(length(DEFAULT$FILES), .DEFAULT$FILES,
                        .BACKUP$PARM$BLOCK.FILENAME);
         endif;
         return PTR1;
      endif;
      PTR1 = PTR1 + 1;
      INDEX = INDEX + 1;
   endwhile;
   return PTR1;
endproc GET$FILENAME;

COLLECT$ATTRIBUTES: procedure(PTR1) pointer;
   dcl PTR1 pointer;
   dcl CHAR1 based PTR1 character;

   BACKUP$PARM$BLOCK.W$ATTR, BACKUP$PARM$BLOCK.S$ATTR,
        BACKUP$PARM$BLOCK.I$ATTR, BACKUP$PARM$BLOCK.CHANGE$W,
        BACKUP$PARM$BLOCK.CHANGE$S, BACKUP$PARM$BLOCK.CHANGE$I = 0;
   PTR1 = DEBLANK(PTR1);
   whilee true;
      if CHAR1 = 'W' thenn
         if BACKUP$PARM$BLOCK.W$ATTR <> 0 thenn
            call ERROR(.('ERROR -- W ATTRIBUTE ALREADY SPECIFIED',0), PTR1);
         endif;
         PTR1 = DEBLANK(PTR1 + 1);
         if CHAR1 = '1' thenn
            BACKUP$PARM$BLOCK.W$ATTR = true;
         elseif CHAR1 = '0' thenn
            BACKUP$PARM$BLOCK.W$ATTR = 80H;
         elseif CHAR1 = '?' or CHAR1 = '*' thenn
            BACKUP$PARM$BLOCK.W$ATTR = 0;
         elsee
            call ERROR(.('ERROR -- INVALID ATTRIBUTE VALUE',0), PTR1);
         endif;
         PTR1 = DEBLANK(PTR1 + 1);
         if CHAR1 = '=' thenn  /* attribute reset */
            PTR1 = DEBLANK(PTR1 + 1);
            if CHAR1 = '1' thenn
               BACKUP$PARM$BLOCK.CHANGE$W = true;
            elseif CHAR1 = '0' thenn
               BACKUP$PARM$BLOCK.CHANGE$W = 80H;
            elsee
               BACKUP$PARM$BLOCK.CHANGE$W = 0;
               call ERROR(.('ERROR -- INVALID ATTRIBUTE VALUE',0), PTR1);
            endif;
            PTR1 = DEBLANK(PTR1 + 1);
         elsee
            BACKUP$PARM$BLOCK.CHANGE$W = 0;
         endif;
      elseif CHAR1 = 'S' thenn
         if BACKUP$PARM$BLOCK.S$ATTR <> 0 thenn
            call ERROR(.('ERROR -- S ATTRIBUTE ALREADY SPECIFIED',0), PTR1);
         endif;
         PTR1 = DEBLANK(PTR1 + 1);
         if CHAR1 = '1' thenn
            BACKUP$PARM$BLOCK.S$ATTR = true;
         elseif CHAR1 = '0' thenn
            BACKUP$PARM$BLOCK.S$ATTR = 80H;
         elseif CHAR1 = '?' or CHAR1 =  '*' thenn
            BACKUP$PARM$BLOCK.S$ATTR = 0;
         elsee
            call ERROR(.('ERROR -- INVALID ATTRIBUTE VALUE',0), PTR1);
         endif;
         PTR1 = DEBLANK(PTR1 + 1);
         if CHAR1 = '=' thenn  /* attribute reset */
            PTR1 = DEBLANK(PTR1 + 1);
            if CHAR1 = '1' thenn
               BACKUP$PARM$BLOCK.CHANGE$S = true;
            elseif CHAR1 = '0' thenn
               BACKUP$PARM$BLOCK.CHANGE$S = 80H;
            elsee
               BACKUP$PARM$BLOCK.CHANGE$S = 0;
               call ERROR(.('ERROR -- INVALID ATTRIBUTE VALUE',0), PTR1);
            endif;
            PTR1 = DEBLANK(PTR1 + 1);
         elsee
            BACKUP$PARM$BLOCK.CHANGE$S = 0;
         endif;
      elseif CHAR1 = 'I' thenn
         if BACKUP$PARM$BLOCK.I$ATTR <> 0 thenn
            call ERROR(.('ERROR -- I ATTRIBUTE ALREADY SPECIFIED',0), PTR1);
         endif;
         PTR1 = DEBLANK(PTR1 + 1);
         if CHAR1 = '1' thenn
            BACKUP$PARM$BLOCK.I$ATTR = true;
         elseif CHAR1 = '0' thenn
            BACKUP$PARM$BLOCK.I$ATTR = 80H;
         elseif CHAR1 = '?' or CHAR1 = '*' thenn
            BACKUP$PARM$BLOCK.I$ATTR = 0;
         elsee
            call ERROR(.('ERROR -- INVALID ATTRIBUTE VALUE',0), PTR1);
         endif;
         PTR1 = DEBLANK(PTR1 + 1);
         if CHAR1 = '=' thenn  /* attribute reset */
            PTR1 = DEBLANK(PTR1 + 1);
            if CHAR1 = '1' thenn
               BACKUP$PARM$BLOCK.CHANGE$I = true;
            elseif CHAR1 = '0' thenn
               BACKUP$PARM$BLOCK.CHANGE$I = 80H;
            elsee
               BACKUP$PARM$BLOCK.CHANGE$I = 0;
               call ERROR(.('ERROR -- INVALID ATTRIBUTE VALUE',0), PTR1);
            endif;
            PTR1 = DEBLANK(PTR1 + 1);
         elsee
            BACKUP$PARM$BLOCK.CHANGE$I = 0;
         endif;
      elsee
         return PTR1;
      endif;
   endwhile;
endproc COLLECT$ATTRIBUTES;

COLLECT$OUTPUT$LIST: procedure(PTR1) pointer;
   dcl PTR1 pointer;
   dcl CHAR1 based PTR1 character;
   dcl OUTPUT$LIST$INDEX byte;

   if CHAR1 = 'T' thenn
      PTR1 = PTR1 + 1;
      if CHAR1 = 'O' thenn
         PTR1 = DEBLANK(PTR1 + 1);
         if not(CHAR1 >= '0' and CHAR1 <= '9') thenn
             call ERROR(.('DEVICE DIGIT EXPECTED',0), PTR1);
         endif;
         OUTPUT$LIST$INDEX = 0;
         whilee CHAR1 >= '0' and CHAR1 <= '9';
            if SELECTED$DEVICE(CHAR1 - '0') thenn
               call ERROR(.('DEVICE ALREADY SELECTED',0), PTR1);
            elsee
               SELECTED$DEVICE(CHAR1 - '0') = true;
               if OUTPUT$LIST$INDEX > last(BACKUP$PARM$BLOCK.OUTPUT$LIST) thenn
                  call ERROR(.('MAXIMUM OF 4 OUTPUT DEVICES EXCEEDED',0), PTR1);
               elsee
                  BACKUP$PARM$BLOCK.OUTPUT$LIST(OUTPUT$LIST$INDEX) = CHAR1;
                  BACKUP$PARM$BLOCK.OUTPUT$LIST$ELEMENTS = OUTPUT$LIST$INDEX;
                  OUTPUT$LIST$INDEX = OUTPUT$LIST$INDEX + 1;
               endif;
            endif;
            PTR1 = DEBLANK(PTR1 + 1);
            if CHAR1 = ',' thenn
               PTR1 = DEBLANK(PTR1 + 1);
            endif;
         endwhile;
      elsee
         call ERROR(.('"TO" EXPECTED',0), PTR1);
      endif;
   elsee
      BACKUP$PARM$BLOCK.OUTPUT$LIST$ELEMENTS = 0;
      BACKUP$PARM$BLOCK.OUTPUT$LIST(0) = '5';
   endif;
   return PTR1;
endproc COLLECT$OUTPUT$LIST;

collect$attrib$switch: PROCEDURE(ptr1) POINTER;
  DCL ptr1 POINTER;
  DCL char BASED ptr1 CHARACTER;

  ptr1 = deblank(ptr1);
  IF char = 'C' THEN
    DO;
      ptr1 = ptr1 + 1;
      keep$attribs = TRUE;
    END;
  RETURN ptr1;
END collect$attrib$switch;

COLLECT$DELETE$OPTION: procedure(PTR1) pointer;
   dcl PTR1 pointer;
   dcl PTR2 pointer;
   dcl CHAR based PTR2 character;
   dcl D$STRING(*) character data('DELETE');
   dcl I byte;

   DELETE$OPTION = false;
   PTR2 = DEBLANK(PTR1);
   for I = 0 to length(D$STRING)-1;
      if D$STRING(I) = CHAR thenn
         PTR2 = PTR2 + 1;
      elsee
         return PTR1;
      endif;
   endfor;
   DELETE$OPTION = true;
   return PTR2;
end COLLECT$DELETE$OPTION;

VERIFY$END$OF$LINE: procedure(PTR1);
   dcl PTR1 pointer;
   dcl CHAR1 based PTR1 character;

   PTR1 = DEBLANK(PTR1);
   if (CHAR1 <> CR) and (CHAR1 <> LF) and (CHAR1 <> ESC) thenn
      call ERROR(.('BAD SYNTAX',0), PTR1);
   endif;
endproc VERIFY$END$OF$LINE;

UPPER$CASE: procedure(PTR1);
   dcl PTR1 pointer;
   dcl CHAR based PTR1 character;

   char = char AND 7FH;
   do while not ((CHAR = CR) or (CHAR = ESC) or (CHAR = LF));
      if (CHAR >= 'a') and (CHAR <= 'z') thenn
         CHAR = CHAR - 20H;
      endif;
      PTR1 = PTR1 + 1;
      char = char AND 7FH;
   enddo;

end UPPER$CASE;

BACKUP$FILES: procedure(COMMAND$PTR) external;
   dcl COMMAND$PTR pointer;
end BACKUP$FILES;

call SIGN$ON(.VERSION);
call READ(1,.COMMAND$LINE, length(COMMAND$LINE), .COMMAND$LINE$LENGTH, .STATUS);
call UPPER$CASE(.COMMAND$LINE);
COMMAND$PTR = DEBLANK(.COMMAND$LINE);
COMMAND$PTR = GET$DEVICE(COMMAND$PTR);
COMMAND$PTR = GET$FILENAME(COMMAND$PTR);
COMMAND$PTR = DEBLANK(COMMAND$PTR);
COMMAND$PTR = COLLECT$ATTRIBUTES(COMMAND$PTR);
COMMAND$PTR = COLLECT$OUTPUT$LIST(COMMAND$PTR);
command$ptr = collect$attrib$switch(command$ptr);
COMMAND$PTR = COLLECT$DELETE$OPTION(COMMAND$PTR);
call VERIFY$END$OF$LINE(COMMAND$PTR);
call BACKUP$FILES(.BACKUP$PARM$BLOCK);
call write$co$crlf;
call EXIT;

end HARD$DISK$BACKUP;
src/hdfils.plm
BACKUP$DISK$FILES: do;

/************************************************************************/
/*																		*/
/*     'Copyright 1981,1983 Intel Corporation'.  All rights reserved.	*/
/*      No part of this program or publication may be reproduced,		*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/



/********************************************************************
 *                                                                  *
 * This module is responsible for validating the command line       *
 * syntax and performing the file copying.                          *
 *                                                                  *
 ********************************************************************/


/* The following literally declarations are used to map PLM80 into
   PLM86 code
*/

declare word literally 'address';
declare integer literally 'address';
declare pointer literally 'address';


declare as literally 'literally';
declare dcl as 'declare';

dcl boolean as 'byte';
dcl true as '0FFH';
dcl false as '0';
dcl ptr as 'word';
dcl nil as '0';
dcl character as 'byte';
dcl char2 as 'word';
dcl varying as '1';

dcl for as 'do';
dcl endfor as 'end';
dcl thenn as 'then do;';
dcl elseif as 'end; else if';
dcl elsee as 'end; else do;';
dcl endif as 'end';
dcl whilee as 'do while';
dcl endwhile as 'end';
dcl endproc as 'end';
dcl endmod as 'end';
dcl enddo as 'end';


dcl CR as '0DH';
dcl LF as '0AH';
dcl BEL as '07H';

ATTRIB: procedure(FILE$PTR, ATTR, ONOFF, STATUS$PTR) external;
   dcl (FILE$PTR, STATUS$PTR) pointer;
   dcl (ATTR, ONOFF) word;
endproc ATTRIB;

SPATH: procedure(FILE$PTR, BUFFER$PTR, STATUS$PTR) external;
   dcl (FILE$PTR,BUFFER$PTR,STATUS$PTR) pointer;
endproc SPATH;

OPEN: procedure(AFTN$PTR, FILE$PTR, ACCESS, MODE, STATUS$PTR) external;
   dcl (AFTN$PTR, FILE$PTR, STATUS$PTR) pointer;
   dcl (ACCESS,MODE) word;
endproc OPEN;

CLOSE: procedure(AFTN, STATUS$PTR) external;
   dcl AFTN word;
   dcl STATUS$PTR pointer;
endproc CLOSE;

DELETE: procedure(FILE$PTR, STATUS$PTR) external;
   dcl (FILE$PTR, STATUS$PTR) pointer;
endproc DELETE;

READ: procedure(AFTN, BUF$PTR, LEN, ACTUAL$PTR, STATUS$PTR) external;
   dcl (BUF$PTR, ACTUAL$PTR, STATUS$PTR) pointer;
   dcl (AFTN, LEN) word;
endproc READ;

WRITE: procedure(AFTN, BUF$PTR, LEN, STATUS$PTR) external;
   dcl (BUF$PTR, STATUS$PTR) pointer;
   dcl (AFTN, LEN) word;
endproc WRITE;

LOAD: procedure(FILE$PTR, BIAS, RETSW, ENTRY$PTR, STATUS$PTR) external;
   dcl (FILE$PTR, ENTRY$PTR, STATUS$PTR) pointer;
   dcl (BIAS, RETSW) word;
endproc LOAD;

GETD: procedure(DID, CONN$PTR, COUNT, ACTUAL$PTR, TABLE$PTR, STATUS$PTR) external;
   dcl (CONN$PTR, ACTUAL$PTR, TABLE$PTR, STATUS$PTR) pointer;
   dcl (DID, COUNT) word;
endproc GETD;

ERROR: procedure(ERR$NUM) external;
   dcl ERRNUM word;
endproc ERROR;

EXIT: procedure external;
endproc EXIT;

filinf: PROCEDURE(ftp,m,fip,sp) EXTERNAL; DCL(ftp,fip,sp) WORD, m BYTE; END;

out$decr: PROCEDURE(val,width) EXTERNAL; DCL val WORD, width BYTE; END;
out$dec: PROCEDURE(val) EXTERNAL; DCL val WORD; END;
out$char: PROCEDURE(char) EXTERNAL; DCL char BYTE; END;
out$blank: PROCEDURE EXTERNAL; END;
DECLARE obufp WORD EXTERNAL;

write$co: PROCEDURE(buf$ptr,len) EXTERNAL;
  DECLARE buf$ptr POINTER, len WORD; END;
write$co$crlf: PROCEDURE EXTERNAL; END;


dcl DELETE$OPTION boolean external;
DCL keep$attribs BOOLEAN EXTERNAL;

dcl ISIS$FILE$BLOCKS word;
dcl MAX$LIMIT word;
dcl MAX$FILES word;
dcl DIR$NAME structure(
   DEVICE(4) character,
   FILENAME(11) character) initial(':F0:ISIS.DIR   ');

dcl SPATH$BLOCK structure(
   DEVNO byte,
   FILE(6) character,
   EXT(3) character,
   DEV$TYPE byte,
   DRIVE$TYPE byte);
dcl DIR$AFTN word;
dcl DIR$BUF(1000) structure(
   PRESENCE byte,
   FILENAME(6) character,
   EXT(3) character,
   ATTRIBUTES byte,
   EOF$COUNT byte,
   NO$DATA$BLOCKS word,
   HEADER$BLOCK$PTR word);
dcl TARGET$DIR$BUF(10) structure(
   PRESENCE byte,
   FILENAME(6) character,
   EXT(3) character,
   ATTRIBUTES byte,
   EOF$COUNT byte,
   NO$DATA$BLOCKS word,
   HEADER$BLOCK$PTR word);
dcl COPY$BUFFER(16384) character;
dcl (ACTUAL, STATUS) word;
dcl OUTPUT$DEVICE(5) character initial(':F#: ');
dcl OUTPUT$LIST$INDEX byte;
dcl TEMP$FILE(*) character initial(':F#:TMP.TMP ');

DCL req$file$name(15) BYTE;
DCL no$ov0 BOOLEAN INITIAL(false);
DCL reading$remote BOOLEAN INITIAL(false);
DCL target$is$remote BOOLEAN INITIAL(false);
DCL changed$target$type BOOLEAN INITIAL(false);
DCL saw$remote$target BOOLEAN INITIAL(false);
DCL blank$string(*) CHARACTER INITIAL('               ');

DCL files$out(18) CHARACTER INITIAL('                  ');


UPPER$CASE: procedure(CHAR) character;
   dcl CHAR character;

   if CHAR >= 'a' and CHAR <= 'z' thenn
      return CHAR - ' ';
   elsee
      return CHAR;
   endif;
endproc UPPER$CASE;

UNPATH: procedure(FILENAME$PTR);
   dcl FILENAME$PTR pointer;
   dcl CHAR1 based FILENAME$PTR character;
   dcl (I,J) byte;
   dcl LOCAL$NAME(11) character;
   dcl STUFF$PTR pointer;

   STUFF$PTR = FILENAME$PTR;
   for I = 0 to last(LOCAL$NAME);
      LOCAL$NAME(I) = 0;
   endfor;
   /* process file part */
   for I = 0 to 5;
      if CHAR1 = '*' thenn
         for J = I to 5;
            LOCAL$NAME(J) = '*';
         endfor;
      elseif CHAR1 = 0 thenn
         go to UNDO;
      elsee
         for J = I to 5;
            LOCAL$NAME(J) = 0;
         endfor;
         LOCAL$NAME(I) = UPPER$CASE(CHAR1);
      endif;
      FILENAME$PTR = FILENAME$PTR + 1;
      if CHAR1 = '.' thenn
         go to UNDO;
      endif;
   endfor;
UNDO:
   if CHAR1 = '.' thenn
      FILENAME$PTR = FILE$NAME$PTR + 1;
   endif;
   if CHAR1 <> 0 thenn
      /* process extension */
      for I = 6 to 8;
         if CHAR1 = '*' thenn
            for J = I to 8;
               LOCAL$NAME(J) = '*';
            endfor;
         elsee
            if CHAR1 <> 0 thenn
               for J = I to 8;
                  LOCAL$NAME(J) = 0;
               endfor;
               LOCAL$NAME(I) = UPPER$CASE(CHAR1);
            endif;
         endif;
         FILENAME$PTR = FILENAME$PTR + 1;
      endfor;
   endif;
   call move(length(LOCAL$NAME), .LOCAL$NAME, STUFF$PTR);
endproc UNPATH;

REPATH: procedure(FILENAME$PTR);
   dcl FILENAME$PTR pointer;
   dcl CHAR$PTR pointer;
   dcl CHAR based CHAR$PTR character;
   dcl NAME (11) character;
   dcl (I,J) byte;

   J = 0;
   CHAR$PTR = FILENAME$PTR;
   for I = 0 to 5;
      if CHAR <> 0 thenn
         NAME(J) = CHAR;
         J = J + 1;
      endif;
      CHAR$PTR = CHAR$PTR + 1;
   endfor;
   if CHAR <> 0 thenn
      NAME(J) = '.';
      J = J + 1;
      for I = 0 to 2;
         if CHAR <> 0 thenn
            NAME(J) = CHAR;
            J = J + 1;
         endif;
         CHAR$PTR = CHAR$PTR + 1;
      endfor;
   endif;
   NAME(J) = ' ';
   call move(length(NAME), .NAME, FILENAME$PTR);
endproc REPATH;

MATCH$NAME: procedure(PTR1, PTR2) boolean;
   dcl (PTR1, PTR2) pointer;
   dcl CHR1 based PTR1 character;
   dcl CHR2 based PTR2 character;
   dcl I byte;

   for I = 0 to 8;
      if CHR1 <> CHR2 thenn
         if CHR2 = '?' thenn
            if CHR1 = 0 thenn
               return false;
            endif;
         elseif CHR2 <> '*' thenn
            return false;
         endif;
      endif;
      PTR1 = PTR1 + 1;
      PTR2 = PTR2 + 1;
   endfor;
   return true;
endproc MATCH$NAME;

dcl INVISIBLE$ATTR as '01H';
dcl SYSTEM$ATTR as '02H';
dcl WRITE$PROTECT$ATTR as '04H';
dcl FORMAT$ATTR as '80H';

MATCH$ATTRIBUTES: procedure(ATTR, W$ATTR, S$ATTR, I$ATTR) boolean;
   dcl ATTR byte;
   dcl (W$ATTR, S$ATTR, I$ATTR) boolean;

   if (ATTR and FORMAT$ATTR) <> 0 thenn
      return false;
   endif;
   if W$ATTR <> 0 thenn /* it has been set */
      if (W$ATTR xor ((ATTR and WRITE$PROTECT$ATTR) <> 0)) thenn
         return false;
      endif;
   endif;
   if S$ATTR <> 0 thenn
      if (S$ATTR xor ((ATTR and SYSTEM$ATTR) <> 0)) thenn
         return false;
      endif;
   endif;
   if I$ATTR <> 0 thenn
      if (I$ATTR xor ((ATTR and INVISIBLE$ATTR) <> 0)) thenn
         return false;
      endif;
   endif;
   return true;
endproc MATCH$ATTRIBUTES;

exit$if$bad$status: PROCEDURE;
   if STATUS <> 0 thenn
      call ERROR(STATUS);
      call EXIT;
   endif;
END;

DCL if$bad$exit LITERALLY 'CALL exit$if$bad$status';

REQUIRED$SPACE: procedure(DIR$INDEX) word;
   dcl DIR$INDEX word;
   dcl EOF$BLOCK word;
   DCL file$table STRUCTURE(
        aftn WORD,
        devno BYTE,
        file(6) BYTE,
        ext(3) BYTE,
        dev$type BYTE,
        drive$type BYTE);
   DCL file$info STRUCTURE(
        owner(15) BYTE,
        len(2) WORD,
        type BYTE,
        owner$access BYTE,
        world$access BYTE,
        create$time WORD,
        last$mod$time WORD,
        res(20) BYTE);

   isis$blocks$needed: PROCEDURE(num$bytes) WORD;
     DCL num$bytes WORD;
     IF num$bytes > (65535-127) THEN RETURN 521;
     IF num$bytes = 0 THEN RETURN 1;
     RETURN ((((num$bytes+127)/128)*63)+61)/62;
   END;

   remote$blocks$needed: PROCEDURE(num$bytes) WORD;
     DCL num$bytes WORD;
     DCL real$blocks WORD;
     IF num$bytes > (65535-2047) THEN RETURN 132;
     IF num$bytes = 0 THEN RETURN 4;
     real$blocks = (((num$bytes+2047)/2048)*4);
     RETURN (((real$blocks+3+3)/4)*4);
   END;

   IF NOT reading$remote THEN /* getd returned necessary block info */
     DO;
       if DIR$BUF(DIR$INDEX).EOF$COUNT <> 0 thenn
          EOF$BLOCK = 1;
       elsee
          EOF$BLOCK = 0;
       endif;
       return DIR$BUF(DIR$INDEX).NO$DATA$BLOCKS + 
              ((DIR$BUF(DIR$INDEX).NO$DATA$BLOCKS + 61)/62) + EOF$BLOCK;
     END;
   /* else must call file$info */
   CALL MOVE(9, .dir$buf(dir$index).filename, .req$file$name(4));
   CALL repath(.req$file$name(4));
   CALL spath(.req$file$name, .file$table.devno, .status);
   if$bad$exit;
   CALL open(.file$table.aftn, .req$file$name, 1, 0, .status);
   IF status = 70 THEN  /* no access rights */
     DO;
       dir$buf(dir$index).eof$count = 2; /* use as flag */
       RETURN 0;  /* will not transfer this file */
     END;
   ELSE if$bad$exit;
   CALL filinf(.file$table, 0, .file$info, .status);
   if$bad$exit;
   CALL close(file$table.aftn, .status);
   if$bad$exit;
   IF ((dir$index+1) MOD 10) = 0 THEN
     CALL write$co(.('.'),1);
   IF file$info.type = 1 THEN /* it's a directory file */
     DO;
       dir$buf(dir$index).eof$count = 1; /* use as flag */
       RETURN 0;  /* will not transfer this file */
     END;
   dir$buf(dir$index).eof$count = 0;
   IF target$is$remote THEN
     RETURN file$info.len(1)*130
           + remote$blocks$needed(file$info.len(0));
   ELSE
     RETURN file$info.len(1)*521
           + isis$blocks$needed(file$info.len(0));
endproc REQUIRED$SPACE;


TRANSFER$FILE: procedure(FROM$DEVICE$PTR, TO$DEVICE$PTR, NAME$PTR,
                         ATTR$W, ATTR$S, ATTR$I);
   dcl (FROM$DEVICE$PTR, TO$DEVICE$PTR, NAME$PTR) pointer;
   dcl (ATTR$W, ATTR$S, ATTR$I) byte;
   dcl OUT$NAME(15) character;
   dcl IN$NAME(15) character;
   dcl (OUT$AFTN, IN$AFTN) word;
   dcl NAME based NAME$PTR structure(
       FILE(6) character,
       EXT(3) character,
       attributes BYTE,
       remote$dir$flag BYTE); /* eof$count */
   dcl (I, INDEX) byte;
   dcl (ACTUAL) word;
   dcl W$ATTR as '2';
   dcl S$ATTR as '1';
   dcl I$ATTR as '0';
   dcl ON as '1';
   dcl OFF as '0';

   re$attr: PROCEDURE(spec,print$char,bit);
   DCL spec BYTE, print$char CHARACTER, bit BYTE;
     IF spec <> 0 thenn
        CALL write$co(.blank$string,1);
        CALL write$co(.print$char,1);
        IF spec thenn
           call ATTRIB(.IN$NAME, bit, ON, .STATUS);
           CALL write$co(.('1'),1);
        elsee
           call ATTRIB(.IN$NAME, bit, OFF, .STATUS);
           CALL write$co(.('0'),1);
        endif;
        if STATUS <> 0 thenn
           call ERROR(STATUS);
        endif;
     endif;
   END;

   call move(4,FROM$DEVICE$PTR, .IN$NAME);
   call move(4,TO$DEVICE$PTR, .OUT$NAME);
   INDEX = 4;
   for I = 0 to 5;
      if NAME.FILE(I) <> 0 thenn
         IN$NAME(INDEX), OUT$NAME(INDEX) = NAME.FILE(I);
         INDEX = INDEX + 1;
      endif;
   endfor;
   if not(NAME.EXT(0) = 0 or NAME.EXT(0) = ' ') thenn
      IN$NAME(INDEX), OUT$NAME(INDEX) = '.';
      INDEX = INDEX + 1;
      for I = 0 to 2;
         if NAME.EXT(I) <> 0 thenn
            OUT$NAME(INDEX), IN$NAME(INDEX) = NAME.EXT(I);
         elsee
            OUT$NAME(INDEX), IN$NAME(INDEX) = ' ';
         endif;
         INDEX = INDEX + 1;
      endfor;
   endif;
   IN$NAME(INDEX), OUT$NAME(INDEX) = ' ';
   INDEX = INDEX + 1;
   call write$co(.IN$NAME, INDEX);
   call write$co(.blank$string, (15 - INDEX));

   /* check for remote directory and no access rights */
   IF reading$remote THEN
     DO;
       IF name.remote$dir$flag = 1 THEN /* directory */
         DO;
           CALL write$co(.('  REMOTE DIRECTORY, NOT COPIED'),30);
           CALL write$co$crlf;
           RETURN;
         END;
       ELSE IF name.remote$dir$flag = 2 THEN /* no access */
         DO;
           CALL write$co(.('  INSUFFICIENT ACCESS RIGHTS, NOT COPIED'),40);
           CALL write$co$crlf;
           RETURN;
         END;
     END;

   call OPEN(.IN$AFTN, .IN$NAME, 1, 0, .STATUS);
   if STATUS <> 0 thenn
      call ERROR(STATUS);
      return;
   endif;
   call OPEN(.OUT$AFTN, .OUT$NAME, 2, 0, .STATUS);
   if STATUS <> 0 thenn
      call ERROR(STATUS);
      call CLOSE(IN$AFTN, .STATUS);
      return;
   endif;
   /* copy file */
   
   call READ(IN$AFTN,.COPY$BUFFER, length(COPY$BUFFER), .ACTUAL, .STATUS);
   if STATUS <> 0 thenn
      call ERROR(STATUS);
      call CLOSE(IN$AFTN, .STATUS);
      call CLOSE(OUT$AFTN,.STATUS);
      return;
   endif;
   whilee ACTUAL <> 0;
      call WRITE(OUT$AFTN, .COPY$BUFFER, ACTUAL, .STATUS);
      if STATUS <> 0 thenn
         call ERROR(STATUS);
         call CLOSE(IN$AFTN, .STATUS);
         call CLOSE(OUT$AFTN,.STATUS);
         return;
      endif;
      if ACTUAL > 1 thenn
         call write$co(.('.....'),(shr(ACTUAL-1, 12)+1));
      elsee
         call write$co(.('.'),1);
      endif;
      call READ(IN$AFTN,.COPY$BUFFER, length(COPY$BUFFER), .ACTUAL, .STATUS);
      if STATUS <> 0 thenn
         call ERROR(STATUS);
         call CLOSE(IN$AFTN, .STATUS);
         call CLOSE(OUT$AFTN,.STATUS);
         return;
      endif;
   endwhile;
   call CLOSE(IN$AFTN, .STATUS);
   call CLOSE(OUT$AFTN,.STATUS);
   /* retain attributes on output file */
   IF keep$attribs THEN
     DO;
       CALL write$co(.blank$string,1);
       IF (name.attributes AND write$protect$attr) = write$protect$attr THEN
         DO;
           CALL attrib(.out$name, w$attr, ON, .status);
           CALL write$co(.('W'),1);
         END;
       IF (name.attributes AND system$attr) = system$attr THEN
         DO;
           CALL attrib(.out$name, s$attr, ON, .status);
           CALL write$co(.('S'),1);
         END;
       IF (name.attributes AND invisible$attr) = invisible$attr THEN
         DO;
           CALL attrib(.out$name, i$attr, ON, .status);
           CALL write$co(.('I'),1);
         END;
     END;
   /* attribute input file if necessary */
   CALL re$attr(attr$w,'W',w$attr);
   CALL re$attr(attr$s,'S',s$attr);
   CALL re$attr(attr$i,'I',i$attr);
   call write$co$crlf;
   return;
endproc TRANSFER$FILE;

dcl CHANGE$1$MESSAGE(*) character data(CR,LF,BEL,'CHANGE DISK IN DRIVE ');
dcl CHANGE$MESSAGE(*) character data(CR,LF,BEL,'CHANGE DISKS IN DRIVES ');
dcl CHANGE$MESSAGE$2(*) character
        data(' AND TYPE <ESC> TO LEAVE, <CR> TO CONTINUE');

SWITCH$DISKS: procedure(MAX$LIST, INPUT$NO, OUTPUT$LIST$PTR, SIZE$BOOL);
   dcl SIZE$BOOL boolean;
   dcl MAX$LIST word;
   dcl INPUT$NO character;
   dcl OUTPUT$LIST$PTR pointer;
   dcl OUTPUT$LIST based OUTPUT$LIST$PTR (4) character;
   dcl TEMP$AFTN word;
   dcl BLKS(10) word data( 0, 4004, 2002, 2002, 28800, 0, 1276, 0, 0, 44520);
   dcl ISIS$BLKS(10) word data( 0, 109, 55, 55, 318, 0, 120, 0, 0, 465);
   dcl FILES(10) word data( 0, 196, 196, 196, 988, 0, 180, 0, 0, 988);
   dcl TARGET$DIR$CONN word;
   dcl TARGET$DIR$ENTRIES word;
   DCL old$target$type BYTE;
   
   OUTPUT$LIST$INDEX = OUTPUT$LIST$INDEX + 1;
   if OUTPUT$LIST$INDEX > MAX$LIST thenn
      if SIZE$BOOL thenn
         if MAX$LIST = 0 thenn /* only one output device */
            call write$co(.CHANGE$1$MESSAGE, length(CHANGE$1$MESSAGE));
            call write$co(.OUTPUT$LIST(0),1);
         elsee
            call write$co(.CHANGE$MESSAGE, length(CHANGE$MESSAGE));
            call write$co(.OUTPUT$LIST(0),1);
            for OUTPUT$LIST$INDEX = 1 to MAX$LIST - 1;
               call write$co(.(', '),2);
               call write$co(.OUTPUT$LIST(OUTPUT$LIST$INDEX),1);
            endfor;
            call write$co(.(' & '),3);
            call write$co(.OUTPUT$LIST(MAX$LIST),1);
         endif;
         call write$co(.CHANGE$MESSAGE$2, length(CHANGE$MESSAGE$2));
         call READ(1,.COPY$BUFFER,128,.ACTUAL,.STATUS);
         if ACTUAL = 1 thenn
            call write$co$crlf;
            call EXIT;
         endif;
         if MAX$LIST = 0 thenn /* only one output device */
            /* clear ISIS bit-map by opening file on source drive */
            TEMP$FILE(2) = INPUT$NO;
            call OPEN(.TEMP$AFTN, .TEMP$FILE, 2, 0, .STATUS);
            if$bad$exit;
            call CLOSE(TEMP$AFTN, .STATUS);
            if$bad$exit;
            call DELETE(.TEMP$FILE, .STATUS);
            if$bad$exit;
         endif;
      endif;
      OUTPUT$LIST$INDEX = 0;
   endif;
   DIR$NAME.DEVICE(2), OUTPUT$DEVICE(2) = OUTPUT$LIST(OUTPUT$LIST$INDEX);
   call SPATH(.OUTPUT$DEVICE, .SPATH$BLOCK, .STATUS);
   old$target$type = target$is$remote;
   IF (target$is$remote := (spath$block.drive$type = 6)) THEN
     saw$remote$target = TRUE;
   changed$target$type = (target$is$remote <> old$target$type);
   if SPATH$BLOCK.DEV$TYPE = 3 thenn
      MAX$LIMIT = BLKS(SPATH$BLOCK.DRIVE$TYPE);
      ISIS$FILE$BLOCKS = ISIS$BLKS(SPATH$BLOCK.DRIVE$TYPE);
      MAX$FILES = FILES(SPATH$BLOCK.DRIVE$TYPE);
   elsee /* non- disk device */
      MAX$LIMIT = 0FFFFH;
      ISIS$FILE$BLOCKS = 0;
      MAX$FILES = 0FFFFH;
   endif;
   if SIZE$BOOL thenn
      if DELETE$OPTION and (MAX$LIMIT <> 0FFFFH) thenn
         dcl I byte;
         dcl FILENAME(15) byte;
         IF no$ov0 THEN
           DO;
             IF spath$block.drive$type > 4 THEN
               DO;
                 CALL write$co(.(':F0:ISIS.OV0 IS MISSING',CR,LF),25);
                 CALL exit;
               END;
             call OPEN(.DIR$AFTN, .DIR$NAME, 1, 0, .STATUS);
             if$bad$exit;
           END;
         call write$co(.('DELETING TARGET DISK FILES ..'), 29);
         call MOVE(4, .(':F0:'), .FILENAME);
         FILENAME(2) = OUTPUT$DEVICE(2);
         TARGET$DIR$CONN = 0;
         TARGET$DIR$ENTRIES = length(TARGET$DIR$BUF);
         do while TARGET$DIR$ENTRIES = length(TARGET$DIR$BUF);
            IF no$ov0 THEN
              DO;
                TARGET$DIR$BUF(0).PRESENCE = 7FH;
                call READ(DIR$AFTN, .TARGET$DIR$BUF, size(TARGET$DIR$BUF),
                                        .ACTUAL, .STATUS);
                target$dir$entries = actual/16;
              END;
            ELSE call GETD(OUTPUT$DEVICE(2) - '0', .TARGET$DIR$CONN, 
                      length(TARGET$DIR$BUF), .TARGET$DIR$ENTRIES, 
                      .TARGET$DIR$BUF, .STATUS);
            if$bad$exit;
            CALL write$co(.('.'),1);
            I = 0;
            do while I < TARGET$DIR$ENTRIES;
              IF no$ov0 THEN
               DO;
                 if TARGET$DIR$BUF(I).PRESENCE = 7FH thenn
                   goto UNDO;
                 endif;
                 IF target$dir$buf(i).presence <> 0 THEN
                   GO TO skipit;
               END;
               if (TARGET$DIR$BUF(I).ATTRIBUTES and FORMAT$ATTR) = 0 thenn
                  call move(11, .TARGET$DIR$BUF(I).FILENAME, .FILENAME(4));
                  call REPATH (.FILENAME(4));
                  call DELETE(.FILENAME, .STATUS);
                  if$bad$exit;
               endif;
        skipit:
               I = I + 1;
            enddo;
         enddo;
UNDO:
         call write$co(.(' COMPLETED',CR,LF), 12);
      endif;
   endif;
endproc SWITCH$DISKS;
   
BACKUP$FILES: procedure(BLOCK$PTR) public;
   dcl BLOCK$PTR pointer;
   dcl BLOCK based BLOCK$PTR structure(
      DEVICE(4) character,
      FILENAME(11)character,
      W$ATTR boolean,
      S$ATTR boolean,
      I$ATTR boolean,
      CHANGE$W boolean,
      CHANGE$S boolean,
      CHANGE$I boolean,
      OUTPUT$LIST$ELEMENTS byte,
      OUTPUT$LIST(4) character);
   dcl DIR$INDEX word;
   dcl SPACE$USED word;
   dcl FILE$FOUND boolean;
   dcl FILES$COPIED word;
   dcl DISKS$NEEDED word;
   dcl NUM$BUF(5) character;
   dcl DIR$CONN word;
   dcl DIR$ENTRIES word;
   DCL dp BYTE;
   DCL wasted WORD;
   DCL actual$entries WORD;
   DCL total$files WORD;
   DCL current$dir$index WORD;
   DCL current$total WORD;
   DCL k BYTE;
   DCL move$left BYTE;

   /* get ready for GETD */
   call LOAD (.(':F0:ISIS.OV0 '), 0, 0, .wasted, .STATUS);
   IF status = 13 THEN
     no$ov0 = true;
   ELSE if$bad$exit;

   call SPATH(.BLOCK.DEVICE, .SPATH$BLOCK, .STATUS);
   if SPATH$BLOCK.DEV$TYPE <> 3 thenn
      call write$co(.('SOURCE DRIVE IS NOT A DISK',CR,LF),33);
      call EXIT;
   endif;

   IF no$ov0 THEN
     DO;
       IF spath$block.drive$type > 4 THEN
         DO;
           CALL write$co(.(':F0:ISIS.OV0 IS MISSING',CR,LF),25);
           CALL exit;
         END;
       call move(length(DIR$NAME.DEVICE), .BLOCK.DEVICE, .DIR$NAME.DEVICE);
       call OPEN(.DIR$AFTN, .DIR$NAME, 1, 0, .STATUS);
       if$bad$exit;
       call READ(DIR$AFTN, .DIR$BUF, size(DIR$BUF), .ACTUAL, .STATUS);
       if$bad$exit;
       call CLOSE(DIR$AFTN, .STATUS);
       dir$buf(actual/16).presence = 7FH;  /* in case of full directory */
       actual$entries,dir$entries = 0;
       DO WHILE dir$buf(actual$entries).presence <> 7FH;
         actual$entries = actual$entries + 1;
       END;
       DO WHILE dir$entries < actual$entries;
         IF dir$buf(dir$entries).presence = 0 THEN
           dir$entries = dir$entries + 1;
         ELSE
           DO;
             CALL MOVE((actual$entries-dir$entries-1)*16,
                        .dir$buf(dir$entries+1).presence,
                         .dir$buf(dir$entries).presence);
             actual$entries = actual$entries - 1;
           END;
       END;
     END;
   ELSE
     DO;
       DIR$CONN = 0;
       call GETD(BLOCK.DEVICE(2) - '0', .DIR$CONN, length(DIR$BUF), 
                 .DIR$ENTRIES, .DIR$BUF, .STATUS);
       if$bad$exit;
       IF dir$entries = length(dir$buf) THEN
         DO;
           CALL write$co(.('MORE THAN 999 FILES IN SOURCE DIRECTORY',CR,LF),41);
           CALL exit;
         END;
       actual$entries = 0;
       DO WHILE actual$entries < dir$entries;
         dir$buf(actual$entries).presence = 0; /* make it like isis.dir */
         actual$entries = actual$entries + 1;
       END;
       IF spath$block.drive$type = 6 THEN
         DO;
           reading$remote = true; /* load overlay for filinf calls */
           call LOAD (.(':F0:ISIS.OV1 '), 0, 0, .wasted, .STATUS);
           if STATUS <> 0 thenn
             IF status = 13 THEN
               CALL write$co(.(':F0:ISIS.OV1 IS MISSING',CR,LF),25);
             ELSE call ERROR(STATUS);
             call EXIT;
           endif;
           actual$entries = 0;
           DO WHILE actual$entries < dir$entries;
             dir$buf(actual$entries).attributes = 0; /* kill attributes */
             actual$entries = actual$entries + 1;
           END;
           CALL MOVE(4, .BLOCK.DEVICE, .req$file$name);
           CALL write$co(.('REMOTE SOURCE '),14);
         END;
     END;

   call UNPATH(.BLOCK.FILENAME);
   OUTPUT$LIST$INDEX = 254;
   move$left = 6;
   FILE$FOUND = false;
   DISKS$NEEDED, FILES$COPIED, DIR$INDEX = 0;
   SPACE$USED, MAX$LIMIT = 0;
   total$files, current$dir$index = 0;
   whilee DIR$INDEX < DIR$ENTRIES;
         if MATCH$NAME(.DIR$BUF(DIR$INDEX).FILENAME, .BLOCK.FILENAME) and
               MATCH$ATTRIBUTES(DIR$BUF(DIR$INDEX).ATTRIBUTES, BLOCK.W$ATTR,
                                          BLOCK.S$ATTR, BLOCK.I$ATTR) thenn
            FILE$FOUND = true;
            if ((DIR$BUF(DIR$INDEX).NO$DATA$BLOCKS:=REQUIRED$SPACE(DIR$INDEX))
                 + SPACE$USED >= MAX$LIMIT) or
                                 FILES$COPIED >= MAX$FILES thenn
               call SWITCH$DISKS(BLOCK.OUTPUT$LIST$ELEMENTS,
                                 BLOCK.DEVICE(2),
                                 .BLOCK.OUTPUT$LIST, false);
               dir$buf(current$dir$index).header$block$ptr = files$copied;
               IF files$copied > 9 THEN
                 move$left = 4;
               IF files$copied > 99 THEN
                 move$left = 2;
               current$dir$index = dir$index;
               DISKS$NEEDED = DISKS$NEEDED + 1;
               SPACE$USED = ISIS$FILE$BLOCKS;
               FILES$COPIED = 0;
               IF changed$target$type THEN /* recalculate required space
                                              for new target disk */
                 dir$buf(dir$index).no$data$blocks = required$space(dir$index);
            endif;
            SPACE$USED = SPACE$USED + DIR$BUF(DIR$INDEX).NO$DATA$BLOCKS;
            FILES$COPIED = FILES$COPIED + 1;
            total$files = total$files + 1;
            dir$buf(dir$index).presence = disks$needed;
         endif;
      DIR$INDEX = DIR$INDEX + 1;
   endwhile;
   dir$buf(current$dir$index).header$block$ptr = files$copied;
   IF files$copied > 9 THEN
     move$left = 4;
   IF files$copied > 99 THEN
     move$left = 2;
   IF total$files > 99 THEN
     move$left = move$left - 2;
   if not FILE$FOUND thenn
      call ERROR(13);
      call EXIT;
   endif;
   call write$co$crlf;
   IF saw$remote$target THEN
     CALL write$co
    (.('REMOTE TARGET DISKS ASSUMED TO BE FLIPPY DISKS WITH DEFAULT FORMAT',
          CR,LF),68);
   obufp = .num$buf;
   CALL out$decr(disks$needed,5);
   call write$co(.NUM$BUF,5);
   if DISKS$NEEDED = 1 thenn
      call write$co(.(' DISK REQUIRED FOR BACKUP',CR,LF),27);
   elsee
      call write$co(.(' DISKS REQUIRED FOR BACKUP',CR,LF),28);
   endif;
   IF reading$remote THEN /* reload ov0 for possible getd calls in switch$disks */
     call LOAD (.(':F0:ISIS.OV0 '), 0, 0, .wasted, .STATUS);
   OUTPUT$LIST$INDEX = 254;
   disks$needed, DIR$INDEX = 0;
   MAX$LIMIT = 0;
   files$copied, current$total = 0;
   whilee DIR$INDEX < DIR$ENTRIES;
      if (dp := DIR$BUF(DIR$INDEX).PRESENCE) > 0 thenn
        IF dp > disks$needed THENN
           call SWITCH$DISKS(BLOCK.OUTPUT$LIST$ELEMENTS, BLOCK.DEVICE(2),
                             .BLOCK.OUTPUT$LIST, true);
           disks$needed = disks$needed + 1;
           files$copied = 0;
           current$dir$index = dir$buf(dir$index).header$block$ptr;
        endif;
        files$copied = files$copied + 1;
        current$total = current$total + 1;
        obufp = .files$out(1);
        CALL out$dec(files$copied);
        CALL out$char(':');
        CALL out$dec(current$dir$index);
        CALL out$char('/');
        CALL out$dec(current$total);
        CALL out$char(':');
        CALL out$dec(total$files);
        k = .files$out(SIZE(files$out)) - obufp - move$left;
        DO WHILE k > 0;
          CALL out$blank;
          k = k - 1;
        END;
        call write$co(.files$out, SIZE(files$out)-move$left);
        call TRANSFER$FILE(.BLOCK.DEVICE, .OUTPUT$DEVICE,
                             .DIR$BUF(DIR$INDEX).FILENAME,
                             BLOCK.CHANGE$W, BLOCK.CHANGE$S, BLOCK.CHANGE$I);
      endif;
      DIR$INDEX = DIR$INDEX + 1;
   endwhile;

end BACKUP$FILES;
end BACKUP$DISK$FILES;
src/if.plm
IF$MOD: DO;

/************************************************************************/
/*																		*/
/*     'Copyright 1981,1983 Intel Corporation'.  All rights reserved.	*/
/*      No part of this program or publication may be reproduced,		*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

$IF XVERSION
DECLARE PROPRIETARY(*) BYTE DATA ('INTEL PROPRIETARY SOFTWARE');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=X103',0);
$ELSE
DECLARE COPYRIGHT (*) BYTE DATA  ('COPYRIGHT 1981,1983 INTEL ');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.1',0);
$ENDIF


DECLARE	LIT		LITERALLY	'LITERALLY',
		DCL		LIT	'DECLARE',
		TRUE	LIT	'0FFH',
		FALSE	LIT	'000H',
		PROC	LIT	'PROCEDURE',
		PROCEND	LIT	'END',
		THENDO	LIT	'THEN DO;',
		ELSEIF	LIT	'END; ELSE IF',
		ELSEDO	LIT	'END; ELSE DO;',
		IFEND	LIT	'END',
		WHILEND	LIT	'END',
		CR		LIT	'0DH',
		LF		LIT	'0AH';


EXIT:	PROC EXTERNAL;											PROCEND;
OPEN:	PROC (A,B,C,D,E) EXTERNAL;	DCL (A,B,C,D,E) ADDRESS;	PROCEND;
READ:	PROC (A,B,C,D,E) EXTERNAL;	DCL (A,B,C,D,E) ADDRESS;	PROCEND;
WRITE:	PROC (A,B,C,D) EXTERNAL;	DCL (A,B,C,D) ADDRESS;		PROCEND;
CLOSE:	PROC (A,B) EXTERNAL;		DCL (A,B) ADDRESS;			PROCEND;
delete:	PROC (a,b) EXTERNAL;		DCL (a,b) ADDRESS;			END;
SPATH:	PROC (A,B,C) EXTERNAL;		DCL (A,B,C) ADDRESS;		PROCEND;
UNPATH:	PROC (A,B) EXTERNAL;		DCL (A,B) ADDRESS;			PROCEND;
MEMCK:	PROC ADDRESS EXTERNAL;									PROCEND;
DEBLANK:PROC (A) ADDRESS EXTERNAL;	DCL (A) ADDRESS;			PROCEND;
DELIMIT:PROC (A) ADDRESS EXTERNAL;	DCL (A) ADDRESS;			PROCEND;
SEQ:	PROC (A,B,C) BYTE EXTERNAL;	DCL (A,B,C) ADDRESS;		PROCEND;
FORCE$UPPER:	PROC(A) EXTERNAL;	DCL (A) ADDRESS;			PROCEND;

DCL (STATUS, ACTUAL, AFTN1, AFTN2) ADDRESS;
DCL (CMND, CMND$PTR) ADDRESS, (CMND$CH BASED CMND$PTR) (1) BYTE;
DCL (STRING1, LEN1, STRING2, LEN2) ADDRESS;
DCL (STRING1$CH BASED STRING1, STRING2$CH BASED STRING2) (1) BYTE;
DCL (BUFFER1, BUFFER2) ADDRESS;
DCL (FILE1, FILE2) (15) BYTE;
DCL (PN1, PN2) STRUCTURE
	(DEV BYTE, NAME (6) BYTE, EXT (3) BYTE, DEV$TYPE BYTE, DRIVE$TYPE BYTE);
DCL (BUFSIZE) ADDRESS;
DCL (NOT$FOUND, TEST) BYTE;
DCL (MSG) (*) BYTE DATA ('<file> or <string>');


FIND$ELSE: PROC;
DCL (IFF) (*) BYTE DATA ('IF', 0, 0, 0, 0, 0, 0, 0);
DCL (NESTED$IF) ADDRESS;
	NESTED$IF = 0;
	DO WHILE TRUE;
		CALL WRITE (0, .('#'), 1, .STATUS);
		CALL READ (1, .MEMORY, 128, .ACTUAL, .STATUS);
		IF (STATUS <> 0) OR (ACTUAL = 0) THENDO
			CALL EXIT; /* Probably hit the end of the command file. */
		IFEND;
		MEMORY (ACTUAL - 1) = CR;
		CALL FORCE$UPPER (.MEMORY);
		CMND$PTR = DEBLANK (.MEMORY);
		IF SEQ (CMND$PTR, .('DEBUG '), 6) THENDO
			CMND$PTR = DEBLANK (CMND$PTR + 5); /* Skip the DEBUG. */
		IFEND;
		CALL SPATH (CMND$PTR, .PN1, .STATUS);
		IF STATUS = 0 THENDO
			IF SEQ (.PN1.NAME, .IFF, 9) THENDO /* A nested IF. */
				NESTED$IF = NESTED$IF + 1;
			ELSEIF SEQ (.PN1.NAME, .('ELSE', 0, 0, 0, 0, 0), 9) THENDO
				IF NESTED$IF = 0 THENDO /* Not part of a nested IF. */
					CMND$PTR = DEBLANK (DELIMIT (CMND$PTR));
					CALL SPATH (CMND$PTR, .PN1, .STATUS);
					IF STATUS = 0 THENDO
						IF SEQ (.PN1.NAME, .IFF, 9) THENDO /* Found ELSE IF. */
							CMND = DELIMIT (CMND$PTR);
							GOTO RESTART; /* Go process the IF command. */
						IFEND;
					IFEND;
					CALL EXIT; /* Continue with the ELSE part. */
				IFEND;
			ELSEIF SEQ (.PN1.NAME, .('ENDIF', 0, 0, 0, 0), 9) THENDO
				IF NESTED$IF = 0 THENDO
					CALL EXIT; /* Continue with the ENDIF part. */
				IFEND;
				NESTED$IF = NESTED$IF - 1;
			IFEND;
		IFEND;
	WHILEND;
PROCEND FIND$ELSE;

DOIT: PROC;
	IF NOT$FOUND THENDO
		TEST = NOT TEST;
	IFEND;
	IF TEST THENDO
		CALL EXIT;
	ELSEDO
		CALL FIND$ELSE;
	IFEND;
PROCEND DOIT;

FILE$EXISTS: PROC;
	IF pn1.dev = 29 THENDO  /* :sp: */
		CALL open(.aftn1,.file1,2,0,.status); /* must open for output */
		test = (status = 11);  /* file already exists */
		IF NOT test THENDO
			CALL close(aftn1,.status);
			CALL delete(.file1,.status);
		END;
	END;
    ELSE DO;
		CALL OPEN (.AFTN1, .FILE1, 1, 0, .STATUS);
		IF STATUS = 0 THENDO /* The file exists, now check its length. */
			CALL READ (AFTN1, .MEMORY, 1, .ACTUAL, .STATUS);
			TEST = (STATUS = 0) AND (ACTUAL > 0);
			CALL CLOSE (AFTN1, .STATUS);
		IFEND;
    END;
	CALL DOIT;
PROCEND FILE$EXISTS;

STRING$COMPARE: PROC;
	IF LEN1 <> LEN2 THENDO
		TEST = FALSE;
	ELSEDO
		TEST = SEQ (STRING1, STRING2, LEN1);
	IFEND;
	CALL DOIT;
PROCEND STRING$COMPARE;

STRING$EQUALS$FILE: PROC;
	CALL MOVE (LEN1, STRING1, .MEMORY); /* Save the string. */
	STRING1 = .MEMORY;
	STRING2 = .MEMORY + LEN1;
	CALL OPEN (.AFTN2, .FILE2, 1, 0, .STATUS);
	IF STATUS <> 0 THENDO
		CALL DOIT;
	IFEND;
	CALL READ (AFTN2, STRING2, LEN1, .LEN2, .STATUS); /* Read in file. */
	CALL CLOSE (AFTN2, .STATUS); /* No need to check status of read. */
	CALL STRING$COMPARE;
PROCEND STRING$EQUALS$FILE;

FILE$COMPARE: PROC;

	STOP: PROC;
		CALL CLOSE (AFTN1, .STATUS);
		CALL CLOSE (AFTN2, .STATUS);
		CALL DOIT;
	PROCEND STOP;

	IF SEQ (.PN1, .PN2, 10) THENDO /* Path names the same, assume equal. */
		TEST = TRUE;
		CALL DOIT;
	IFEND;
	BUFSIZE = SHR (BUFSIZE, 1); /* Divide it into two equal pieces. */
	BUFFER2 = BUFFER1 + BUFSIZE;
	CALL OPEN (.AFTN1, .FILE1, 1, 0, .STATUS);
	IF STATUS <> 0 THENDO
		CALL STOP;
	IFEND;
	CALL OPEN (.AFTN2, .FILE2, 1, 0, .STATUS);
	IF STATUS <> 0 THENDO
		CALL STOP;
	IFEND;
	DO WHILE TRUE;
		CALL READ (AFTN1, BUFFER1, BUFSIZE, .LEN1, .STATUS);
		IF STATUS <> 0 THENDO
			CALL STOP;
		IFEND;
		CALL READ (AFTN2, BUFFER2, BUFSIZE, .LEN2, .STATUS);
		IF STATUS <> 0 THENDO
			CALL STOP;
		IFEND;
		IF LEN1 <> LEN2 THENDO
			CALL STOP;
		IFEND;
		IF LEN1 = 0 THENDO
			TEST = TRUE;
			CALL STOP;
		IFEND;
		IF NOT SEQ (BUFFER1, BUFFER2, LEN1) THENDO
			CALL STOP;
		IFEND;
	WHILEND;
PROCEND FILE$COMPARE;

STRING$IN$STRING: PROC;
	IF (LEN1 = 0) OR (LEN2 = 0) THENDO /* Null string as operand always true. */
		TEST = TRUE;
		CALL DOIT;
	IFEND;
	DO WHILE TRUE;
		DO WHILE STRING2$CH (0) <> STRING1$CH (0);
			STRING2 = STRING2 + 1;
			LEN2 = LEN2 - 1;
			IF LEN2 = 0 THENDO /* Hit the end of the string. */
				CALL DOIT;
			IFEND;
		WHILEND;
		IF LEN2 < LEN1 THENDO
			CALL DOIT; /* Not enough chars left in right string. */
		IFEND;
		IF SEQ (STRING2, STRING1, LEN1) THENDO
			TEST = TRUE;
			CALL DOIT;
		IFEND;
		STRING2 = STRING2 + 1;
		LEN2 = LEN2 - 1; /* LEN2 must be >= 1, hence no need to check. */
	WHILEND;
PROCEND STRING$IN$STRING;

STRING$IN$FILE: PROC;
DCL (WHATS$LEFT) ADDRESS;

	CHECK$STATUS: PROC (LEN);
	DCL (LEN) ADDRESS;
		IF (STATUS <> 0) OR (LEN < LEN1) THENDO
			CALL CLOSE (AFTN2, .STATUS);
			CALL DOIT;
		IFEND;
		BUFFER1 = BUFFER2 + LEN;
		CMND$PTR = BUFFER2;
	PROCEND CHECK$STATUS;

	IF LEN1 = 0 THENDO /* Looking for a null string. */
		TEST = TRUE;
		CALL DOIT;
	IFEND;
	CALL MOVE (LEN1, STRING1, .MEMORY); /* Save the string. */
	STRING1 = .MEMORY;
	BUFFER2 = BUFFER2 + LEN1;
	BUFSIZE = BUFSIZE - LEN1;
	CALL OPEN (.AFTN2, .FILE2, 1, 0, .STATUS);
	IF STATUS <> 0 THENDO
		CALL DOIT;
	IFEND;
	CALL READ (AFTN2, BUFFER2, BUFSIZE, .ACTUAL, .STATUS);
	CALL CHECK$STATUS (ACTUAL);
	DO WHILE TRUE;
		DO WHILE CMND$CH (0) <> STRING1$CH (0);
			CMND$PTR = CMND$PTR + 1;
			IF CMND$PTR = BUFFER1 THENDO /* Hit the end of the buffer. */
				CALL READ (AFTN2, BUFFER2, BUFSIZE, .ACTUAL, .STATUS);
				CALL CHECK$STATUS (ACTUAL);
			IFEND;
		WHILEND;
		WHATS$LEFT = BUFFER1 - CMND$PTR;
		IF WHATS$LEFT < LEN1 THENDO /* Not enough bytes left in buffer. */
			CALL MOVE (WHATS$LEFT, CMND$PTR, BUFFER2);
			CALL READ (AFTN2, BUFFER2 + WHATS$LEFT, BUFSIZE - WHATS$LEFT, .ACTUAL, .STATUS);
			CALL CHECK$STATUS (ACTUAL + WHATS$LEFT);
		IFEND;
		IF SEQ (CMND$PTR, STRING1, LEN1) THENDO
			TEST = TRUE;
			CALL CLOSE (AFTN2, .STATUS);
			CALL DOIT;
		IFEND;
		CMND$PTR = CMND$PTR + 1;
	WHILEND;
PROCEND STRING$IN$FILE;

CMND$ERROR: PROC (MSG, MSGLEN);
DCL (MSG, MSGLEN) ADDRESS;
	CALL WRITE (0, .('Command tail error near #: '), 27, .STATUS);
	CALL WRITE (0, MSG, MSGLEN, .STATUS);
	CALL WRITE (0, .(' expected.', CR, LF), 12, .STATUS);
	CALL WRITE (0, .MEMORY, CMND$PTR - .MEMORY, .STATUS);
	CALL WRITE (0, .('#', CR, LF), 3, .STATUS);
	CALL EXIT;
PROCEND CMND$ERROR;

SCAN$STRING: PROC (STRING$PTR, LEN$PTR) BYTE;
DCL (STRING$PTR, LEN$PTR) ADDRESS,
	(STRING BASED STRING$PTR, LEN BASED LEN$PTR) ADDRESS,
	(CH) BYTE;
	CH = CMND$CH (0);
	IF (CH <> '''') AND (CH <> '"') THENDO /* Not a string. */
		RETURN FALSE;
	IFEND;
	CMND$PTR, STRING = CMND$PTR + 1;
	DO WHILE CMND$CH (0) <> CH;
		IF CMND$CH (0) = CR THENDO /* Reached the end of command. */
			IF CH = '''' THENDO
				CALL CMND$ERROR (.('"''"'), 3);
			ELSEDO
				CALL CMND$ERROR (.('''"'''), 3);
			IFEND;
		IFEND;
		CMND$PTR = CMND$PTR + 1;
	WHILEND;
	LEN = CMND$PTR - STRING;
	CMND$PTR = DEBLANK (CMND$PTR + 1);
	RETURN TRUE;
PROCEND SCAN$STRING;

SCAN$FILE: PROC (FILE$PTR, PN$PTR) BYTE;
DCL (FILE$PTR, PN$PTR) ADDRESS;
	CALL SPATH (CMND$PTR, PN$PTR, .STATUS);
	IF STATUS <> 0 THENDO
		RETURN FALSE;
	IFEND;
	CALL UNPATH (PN$PTR, FILE$PTR);
	CMND$PTR = DEBLANK (DELIMIT (CMND$PTR));
	RETURN TRUE;
PROCEND SCAN$FILE;


/* Read in the initial command line. */
CALL READ (1, (CMND := .MEMORY), 128, .ACTUAL, .STATUS);

RESTART: /* The restart point for the ELSE IF command. */

MEMORY (ACTUAL - 1) = CR;
CMND$PTR = CMND;
DO WHILE CMND$CH (0) <> CR;
	IF CMND$CH (0) = '&' THENDO
		CMND$CH (0) = ' ';
		CALL WRITE (0, .('**'), 2, .STATUS);
		CALL READ (1, CMND$PTR + 1, 128, .ACTUAL, .STATUS);
		CMND$CH (ACTUAL) = CR;
	IFEND;
	CMND$PTR = CMND$PTR + 1;
WHILEND;
CALL FORCE$UPPER (.MEMORY);

BUFSIZE = MEMCK - .MEMORY;
BUFFER1, BUFFER2 = .MEMORY;
/* Scan the command line. */
STRING1, STRING2, FILE1 (0), FILE2 (0) = 0;
NOT$FOUND, TEST = FALSE;
CMND$PTR = DEBLANK (CMND);
IF SEQ (CMND$PTR, .('NOT '), 4) THENDO
	NOT$FOUND = TRUE;
	CALL MOVE (8, .(':F0:NOT '), .FILE1); /* In case it was a file name. */
	CALL SPATH (.FILE1, .PN1, .STATUS);
	CMND$PTR = DEBLANK (CMND$PTR + 4);
IFEND;
IF CMND$CH (0) = CR THENDO /* Only a null command line or 'NOT' was found. */
	IF NOT NOT$FOUND THENDO /* Nothing on the command tail. */
$IF XVERSION
		CALL WRITE (0, .('ISIS-II IF X103', CR, LF), 17, .STATUS);
$ELSE
		CALL WRITE (0, .('ISIS-II IF V1.1', CR, LF), 17, .STATUS);
$ENDIF
		CALL EXIT;
	IFEND;
	NOT$FOUND = FALSE; /* The first parameter is the file 'NOT'. */
	CALL FILE$EXISTS; /* See if the file 'NOT' exists. */
ELSEIF CMND$CH (0) = '=' THENDO /* It better be preceded by 'NOT'. */
	IF NOT NOT$FOUND THENDO
		CALL CMND$ERROR (.MSG, 18);
	IFEND;
	NOT$FOUND = FALSE; /* The 'NOT' was a file name. */
	CMND$PTR = DEBLANK (CMND$PTR + 1);
	IF SCAN$FILE (.FILE2, .PN2) THENDO
		CALL FILE$COMPARE;
	ELSEDO
		CALL CMND$ERROR (.MSG, 6);
	IFEND;
ELSEIF SCAN$STRING (.STRING1, .LEN1) THENDO /* We have a string. */
	IF CMND$CH (0) = '=' THENDO
		CMND$PTR = DEBLANK (CMND$PTR + 1);
		IF SCAN$STRING (.STRING2, .LEN2) THENDO /* We have two strings. */
			CALL STRING$COMPARE;
		ELSEIF SCAN$FILE (.FILE2, .PN2) THENDO /* It's a file name. */
			CALL STRING$EQUALS$FILE;
		ELSEDO
			CALL CMND$ERROR (.MSG, 18);
		IFEND;
	ELSEIF SEQ (CMND$PTR, .('IN '), 3) THENDO
		CMND$PTR = DEBLANK (CMND$PTR + 2);
		IF SCAN$STRING (.STRING2, .LEN2) THENDO /* We have two strings. */
			CALL STRING$IN$STRING;
		ELSEIF SCAN$FILE (.FILE2, .PN2) THENDO /* It's a file name. */
			CALL STRING$IN$FILE;
		ELSEDO
			CALL CMND$ERROR (.MSG, 18);
		IFEND;
	ELSEDO /* Not '=' and not 'IN', command's in error. */
		CALL CMND$ERROR (.('''='' or ''IN'''), 11);
	IFEND;
ELSEIF SCAN$FILE (.FILE1, .PN1) THENDO /* Better be file name. */
	IF CMND$CH (0) = '=' THENDO /* We have more. */
		CMND$PTR = DEBLANK (CMND$PTR + 1);
		IF SCAN$FILE (.FILE2, .PN2) THENDO /* And it better be a file name. */
			CALL FILE$COMPARE;
		ELSEDO
			CALL CMND$ERROR (.MSG, 6);
		IFEND;
	IFEND;
	CALL FILE$EXISTS; /* Ignore rest of command, assume file test only. */
ELSEDO
	CALL CMND$ERROR (.MSG, 18);
IFEND;
CALL EXIT;

END IF$MOD;
src/last.plm
LAST: DO;

/************************************************************************/
/*																		*/
/*     'Copyright 1981,1983 Intel Corporation'.  All rights reserved.	*/
/*      No part of this program or publication may be reproduced,		*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

$IF XVERSION
DECLARE PROPRIETARY(*) BYTE DATA ('INTEL PROPRIETARY SOFTWARE');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=X103',0);
$ELSE
DECLARE COPYRIGHT (*) BYTE DATA  ('COPYRIGHT 1981,1983 INTEL ');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.1',0);
$ENDIF

    


$NOLIST
/* PEX */
MAX :PROCEDURE (ZZ1,ZZ2)ADDRESS EXTERNAL;DECLARE (ZZ1,ZZ2)ADDRESS;END;
DECLARE FATAL BYTE EXTERNAL;
DECLARE ACTUAL ADDRESS EXTERNAL;
DECLARE BLOKNO ADDRESS EXTERNAL;
DECLARE BYTENO ADDRESS EXTERNAL;
CLOSEI :PROCEDURE  EXTERNAL;END;
DECLARE ENDOFFILE LITERALLY'7FFFH';
EX :PROCEDURE  EXTERNAL;END;
OPENI :PROCEDURE (ZZ1) EXTERNAL;DECLARE (ZZ1)ADDRESS;END;
READC :PROCEDURE (ZZ1,ZZ2) EXTERNAL;DECLARE (ZZ1,ZZ2)ADDRESS;END;
READI :PROCEDURE (ZZ1,ZZ2) EXTERNAL;DECLARE (ZZ1,ZZ2)ADDRESS;END;
SBYTEI :PROCEDURE (ZZ1) EXTERNAL;DECLARE (ZZ1)ADDRESS;END;
WRITEC :PROCEDURE (ZZ1,ZZ2) EXTERNAL;DECLARE (ZZ1,ZZ2)ADDRESS;END;
DECLARE TRUE LITERALLY'255';
/* ENDPEX */
$LIST


FATAL = TRUE;
CALL READC(.MEMORY,128);
CALL OPENI(.MEMORY);
CALL SBYTEI(END$OF$FILE);
CALL SBYTEI(0);
CALL SBYTEI(MAX(-512,-(BLOKNO*128+BYTENO)));
CALL READI(.MEMORY,512);
CALL CLOSEI;
CALL WRITEC(.MEMORY,ACTUAL);
CALL EX;

END LAST;
src/latest.plm
LATEST$MOD:
DO;

/************************************************************************/
/*																		*/
/*     'Copyright 1981,1983 Intel Corporation'.  All rights reserved.	*/
/*      No part of this program or publication may be reproduced,		*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

$IF XVERSION
DECLARE PROPRIETARY(*) BYTE DATA ('INTEL PROPRIETARY SOFTWARE');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=X104',0);
$ELSE
DECLARE COPYRIGHT (*) BYTE DATA  ('COPYRIGHT 1981,1983 INTEL ');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.1',0);
$ENDIF


DECLARE LIT LITERALLY 'LITERALLY',
  DCL     LIT  'DECLARE',
  TRUE    LIT  '0FFH',
  FALSE   LIT  '000H',
  PROC    LIT  'PROCEDURE',
  ENDPROC LIT  'END;',
  THENN   LIT  'THEN DO;',
  ELLSE   LIT  'END; ELSE DO;',
  ELSIF   LIT  'END; ELSE IF',
  ENDIF   LIT  'END;',
  ENDDO   LIT  'END;',
  CR      LIT  '0DH',
  LF      LIT  '0AH',
  CRLF    LIT  '0DH,0AH',
  CHK     LIT  'CALL CHECK$ISIS$STATUS(STATUS)',
  NULL    LIT  '0',
  TOEND   LIT  '7FFFH',
  TOBEG   LIT  '08000H';

DCL PCNT$0$TYPE         LIT '0',
    PCNT$0$DOT$TYPE     LIT '1',
    PCNT$0$DOT$EXT$TYPE LIT '2',
    NUMB$0$TYPE         LIT '3';

DCL NAME$DOT$TYPE       LIT  '0',
    NAME$DOT$EXT$TYPE   LIT  '1',
    NAME$ONLY$TYPE      LIT  '2';

DCL UNKNOWN$TYPE        LIT  '10';

DCL NAME$ADDED          LIT  '1',
    NEW$LINE            LIT  '3',
    DONE                LIT  '0';

DCL NO$NUM$EXTENSION        LIT  '0';

EXIT: PROC EXTERNAL; END;
CO: PROC (CHR) EXTERNAL; DCL CHR BYTE; END;
READC: PROC (PTR,LEN) EXTERNAL; DCL (PTR,LEN) ADDRESS; END;
OPEN1: PROC (PTR,MO) EXTERNAL; DCL PTR ADDRESS,MO BYTE; END;
READ1: PROC (PTR,LEN) EXTERNAL; DCL (PTR,LEN) ADDRESS; END;
CLOSE1: PROC EXTERNAL; END;
SCANMATCH: PROC(P)BYTE EXTERNAL; DCL P ADDRESS; END;
SCAN$WHILE: PROC(P) EXTERNAL; DCL P ADDRESS; END;
TERM$CH: PROC BYTE EXTERNAL; END;
FMOVE: PROC (C,S,D) EXTERNAL; DCL (C,S,D) ADDRESS; END;
ERROR: PROC (ERROR$NO) EXTERNAL; DCL ERROR$NO ADDRESS; END;
MEM$CK: PROC ADDRESS EXTERNAL; END;
SPATH: PROC(FILE,BUFFER,STATUS) EXTERNAL;
       DCL (FILE,BUFFER,STATUS) ADDRESS; END;
LOAD: PROC(FILE,BIAS,SWITCH,ENTRY,STATUS) EXTERNAL;
      DCL (FILE,BIAS,SWITCH,ENTRY,STATUS) ADDRESS; END;
GETD: PROC(DRIVE,CON,COUNT,ACTUAL$COUNT,BUFFER,STATUS) EXTERNAL;
      DCL (DRIVE,CON,COUNT,ACTUAL$COUNT,BUFFER,STATUS) ADDRESS; END;
WRITE: PROC(AFTN,BUFFER,COUNT,STATUS) EXTERNAL;
       DCL (AFTN,BUFFER,COUNT,STATUS) ADDRESS; END;

DCL (STATUS,REPORT,ERRED,FATAL,ACTUAL) ADDRESS EXTERNAL;
DCL (SCANP,OBUFP)      ADDRESS EXTERNAL,
    LEADCHAR           BYTE    EXTERNAL;

DCL SCANBYTE BASED SCANP BYTE,
    SCANP$TMP ADDRESS;

/*********************************************
    G L O B A L   S T R U C T U R E S
*********************************************/
DCL NAMEINDEX ADDRESS INITIAL (0);
DCL MAXINDEX  LIT '200';
DCL NAME$LIST (MAXINDEX) STRUCTURE (
      DRIVE (4) BYTE,
      NAME  (6) BYTE,
      EXT   (3) BYTE,
      TYPE BYTE);

$EJECT
/*********************************************
       G L O B A L   V A R I A B L E S
*********************************************/

DCL READING$REMOTE BYTE;
DCL END$OF$DIRECTORY ADDRESS;
DCL MEM$TOP ADDRESS;
DCL MONITOR ADDRESS DATA (0);
DCL HALT$FLAG       BYTE INITIAL (FALSE);
DCL READBUF (129)   BYTE;
DCL MSG$BUF (128)   BYTE;
DCL BLANK$STR (16)  BYTE DATA('                ');
DCL NULLSTRING(16)  BYTE DATA(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
DCL NO$EXT$MSG (*) BYTE INITIAL(
'        has no numeric extension',CR,LF,0);
/*012345676890123456789012345678901234567890*/
DCL EXT$MSG    (*) BYTE  INITIAL(
 'greatest numeric extension is       .    ',CR,LF,0);
/*012345678901234567890123456789012345678901234567890*/

/*********************************************
     D I R E C T O R Y    G L O B A L S
*********************************************/
DCL DIR$TO$SEARCH BYTE;
DCL DIRECTORY$NAME (*) BYTE INITIAL(':F :ISIS.DIR ');
DCL DIR$BUF  (16384) BYTE;
DCL DIR$ENTRY$PTR ADDRESS,
    DIR$ENTRY BASED DIR$ENTRY$PTR STRUCTURE (
      PRESENCE BYTE,
      FILENAME (6) BYTE,
      EXTENSION (3) BYTE,
      ATTRIBUTES BYTE,
      EOF$COUNT BYTE,
      NUM$DATA$BLKS ADDRESS,
      HEADER$BLK$PTR ADDRESS);

$EJECT

/*********************************************
    C O M M O N      P R O C E D U R E S
*********************************************/

PRINT: PROC (PTR);
  DCL PTR ADDRESS,CHR BASED PTR BYTE;
  DO WHILE CHR <> NULL;
     CALL CO(CHR);
     PTR = PTR + 1;
  ENDDO
END PRINT;

PRINT$CR: PROC (PTR);
  DCL PTR ADDRESS;
  CALL PRINT(PTR);
  CALL PRINT(.(CR,LF,0));
END PRINT$CR;

PRINT$CR$EXIT: PROC (PTR);
  DCL PTR ADDRESS;
  CALL PRINT$CR(PTR);
  CALL EXIT;
END;

CHK$STATUS: PROC (PTR);
  DCL PTR ADDRESS;
  IF STATUS <> 0 THENN
     CALL PRINT(.('bad status ',0));
     CALL PRINT$CR$EXIT(PTR);
  ENDIF
END CHK$STATUS;

CHECK$ISIS$STATUS: PROC(ISIS$STATUS);
   DCL ISIS$STATUS ADDRESS;
   IF ISIS$STATUS <> 0  THEN
     DO;
       CALL ERROR(ISIS$STATUS);
       CALL EXIT;
     END;
END CHECK$ISIS$STATUS;

DEBLANK: PROC (PTR) ADDRESS;
 DCL PTR ADDRESS,CHR BASED PTR BYTE;
 DO WHILE CHR = ' ';
  PTR = PTR + 1;
 ENDDO
 RETURN PTR;
END DEBLANK;

LESSER$OF: PROC (VAL1,VAL2) ADDRESS;
  DCL (VAL1,VAL2) ADDRESS;
  IF VAL1 > VAL2 THENN
     RETURN VAL2;
  ELLSE
     RETURN VAL1;
  ENDIF
END LESSER$OF;

LET$CH$WP: PROC (CHAR) BYTE;
  DCL CHAR BYTE;
   RETURN
   ( (CHAR >= 'a' AND CHAR <= 'z') OR
     (CHAR >= 'A' AND CHAR <= 'Z')  );
END LET$CH$WP;

DIG$CH$WP: PROC (CHAR) BYTE;
  DCL CHAR BYTE;
  RETURN ((CHAR >= '0' AND CHAR <= '9'));
END DIG$CH$WP;

LET$OR$DIG$CH$WP: PROC (CHAR) BYTE;
  DCL CHAR BYTE;
  RETURN (LET$CH$WP(CHAR) OR DIG$CH$WP(CHAR));
END LET$OR$DIG$CH$WP;

DOT$CH$WP: PROC (CHAR) BYTE;
  DCL CHAR BYTE;
  RETURN (CHAR = '.');
END DOT$CH$WP;

COLON$CH$WP: PROC (CHAR) BYTE;
   DCL CHAR BYTE;
   RETURN (CHAR = ':');
END COLON$CH$WP;

FILE$CH$WP: PROC (CHAR) BYTE;
   DCL CHAR BYTE;
   RETURN( LET$OR$DIG$CH$WP(CHAR) OR DOT$CH$WP(CHAR) OR COLON$CH$WP(CHAR));
END FILE$CH$WP;

BLANK$CH$WP: PROC (CHAR) BYTE;
   DCL CHAR BYTE;
   RETURN (CHAR = ' ');
END BLANK$CH$WP;

LENGTH$OF: PROC (PROC$PTR) ADDRESS;
  DCL (PROC$PTR,TMP$PTR,LEN) ADDRESS;
  TMP$PTR = SCANP;
  CALL SCANWHILE(PROC$PTR);
  LEN = SCANP - TMP$PTR;
  SCANP = TMP$PTR;
  RETURN LEN;
END LENGTH$OF;

LET$CH: PROC BYTE;
  RETURN(LET$CH$WP(SCANBYTE));
END LET$CH;

DIG$CH: PROC BYTE;
  RETURN(DIG$CH$WP(SCANBYTE));
END DIG$CH;

LET$OR$DIG$CH: PROC BYTE;
  RETURN (LET$CH OR DIG$CH);
END LET$OR$DIG$CH;

DOT$CH: PROC BYTE;
  RETURN (SCANBYTE = '.');
END DOT$CH;

COLON$CH: PROC BYTE;
  RETURN (SCANBYTE = ':');
END COLON$CH;

FILE$CH: PROC BYTE;
   RETURN(LET$CH OR DIG$CH OR DOT$CH OR COLON$CH);
END FILE$CH;

BLANK$CH: PROC BYTE;
   RETURN(SCANBYTE = ' ');
END BLANK$CH;

NULL$CH: PROC BYTE;
   RETURN (SCANBYTE = NULL);
END NULL$CH;

ENFORCE$NO$TOKENS: PROC;
  DO WHILE NOT TERM$CH          ;
     IF NOT  BLANK$CH  THENN
       CALL PRINT$CR$EXIT(.('only blanks allowed after &',0));
     ENDIF
     SCANP = SCANP + 1;
  ENDDO
END ENFORCE$NO$TOKENS;

$EJECT

READ$IN$DIRECTORY: PROCEDURE;

    DECLARE BUFFER(12) BYTE;
    DECLARE ACTUAL$ENTRY ADDRESS;
    DECLARE ENTRY ADDRESS;
    DECLARE CONNECTION ADDRESS;

	DIRECTORY$NAME(2) = DIR$TO$SEARCH;
	CALL SPATH(.DIRECTORY$NAME, .BUFFER, .STATUS); CHK;
      IF BUFFER(10) = 3  AND  BUFFER(11) > 4  THEN
         DO;
            MEM$TOP = MEM$CK - 13;
            IF MEM$TOP < 0E800H  THEN
               CALL PRINT$CR$EXIT(.('insufficient  memory ', CR, LF,0));
            ELSE
               DO;
                 CALL LOAD(.(':F0:ISIS.OV0 '),0,0,.ENTRY,.STATUS); CHK;
                 connection = 0;
                 CALL GETD(DIR$TO$SEARCH-'0',.CONNECTION,SIZE(dir$buf)/16,
                          .ACTUAL$ENTRY,.DIR$BUF,.STATUS); CHK;

                 IF ACTUAL$ENTRY >= SIZE(dir$buf)/16 THEN
                    CALL PRINT$CR$EXIT
                           (.('Remote directory too large.', CR,LF,0));
                 READING$REMOTE = TRUE;
                 END$OF$DIRECTORY = .DIR$BUF + (ACTUAL$ENTRY*16);
               END;
         END;
      ELSE
         DO;
            CALL OPEN1(.DIRECTORY$NAME,1);  CHK;
            CALL READ1(.DIR$BUF,SIZE(DIR$BUF));  CHK;
            CALL CLOSE1; CHK;
            READING$REMOTE = FALSE;
            END$OF$DIRECTORY = .DIR$BUF + ACTUAL;
         END;
    END
READ$IN$DIRECTORY;


$EJECT

/**************************************************
  D I R E C T O R Y   M A N I P U L A T I N G
                P R O C E D U R E S
***************************************************/

GREATEST$EXT: PROC (NAME$PART$PTR) ADDRESS;
   DCL NAME$PART$PTR ADDRESS;
   DCL LEN$2 BYTE;
   DCL LARGEST$EXTENSION ADDRESS;
   DCL NUM$EXTENSION$FOUND BYTE;
   DCL EXT$PTR ADDRESS;

   NUMERIC$EXTENSION: PROC (PTR) BYTE;
        /*	Given a pointer into memory, this procedure determines
                whether the byte pointed to, and the next two contiguous
                bytes, constitute a wholly numeric ascii sequence.			*/
        DCL PTR ADDRESS, CHAR BASED PTR (3) BYTE;
        DCL L BYTE;
        DO L=0 TO 2;
                IF NOT (CHAR(L) >= '0' AND CHAR(L) <= '9')   THENN
                        RETURN FALSE;
                ENDIF
        ENDDO
        RETURN TRUE;
   END NUMERIC$EXTENSION;

   VALUE: PROC (DIR$EXT$PTR) ADDRESS;
        DCL DIR$EXT$PTR ADDRESS;
        DCL CHAR BASED DIR$EXT$PTR (3) BYTE;
        DCL T BYTE;
        DCL RESULT ADDRESS;
        RESULT = 0;
        DO T = 0 TO 2;
                RESULT = (RESULT * 10) + CHAR(T) - '0';
        ENDDO
        RETURN RESULT;
   END VALUE;

   NAME$PARTS$MATCH: PROC BYTE;
      DCL LEN$1 BYTE;
      DCL TMP$CHAR BYTE;
      DCL MATCH BYTE;
      SCANP = .DIR$ENTRY.FILENAME;
      LEN$1 = LESSER$OF(6,LENGTH$OF(.LET$OR$DIG$CH));
      SCANP = SCANP + LEN$1;
      TMP$CHAR = DIR$ENTRY.EXTENSION(0);
      SCAN$BYTE = 0;
      SCANP = NAME$PART$PTR;
      IF            LEN$1  <>  LEN$2          THENN
         DIR$ENTRY.EXTENSION(0) = TMP$CHAR;
         RETURN FALSE;
      ELLSE
         MATCH = SCAN$MATCH(.DIR$ENTRY.FILENAME) ;
         DIR$ENTRY.EXTENSION(0) = TMP$CHAR;
         RETURN MATCH;
      ENDIF
   END NAME$PARTS$MATCH;

   DIR$ENTRY$PTR = .DIR$BUF;
   SCANP = NAME$PART$PTR;
   LEN$2 = LESSER$OF(6,LENGTH$OF(.LET$OR$DIG$CH));
   NUM$EXTENSION$FOUND = FALSE;
   LARGEST$EXTENSION = 0;
   /*	Grand directory search loop. */
   DO WHILE  DIR$ENTRY$PTR < END$OF$DIRECTORY;
      IF NOT READING$REMOTE  THEN
        DO;
          IF DIR$ENTRY.PRESENCE = 7FH  THEN
            GO TO NO$MORE$DIR;
          IF DIR$ENTRY.PRESENCE = 0FFH  THEN
            GO TO LOOP1;
        END;
        IF (DIR$ENTRY.EXTENSION(0) < '0') OR
           (DIR$ENTRY.EXTENSION(0) > '9') THEN GOTO LOOP1;
           IF  NAME$PARTS$MATCH  THENN
              IF NUMERIC$EXTENSION(.DIR$ENTRY.EXTENSION) THENN
                 DCL EXTENSION$NUM ADDRESS;
                 NUM$EXTENSION$FOUND = TRUE;
                 EXTENSION$NUM = VALUE(.DIR$ENTRY.EXTENSION);
                 IF EXTENSION$NUM >= LARGEST$EXTENSION THENN
                    EXT$PTR = .DIR$ENTRY.EXTENSION;
                    LARGEST$EXTENSION = EXTENSION$NUM;
                 ENDIF
              ENDIF
           ENDIF
      loop1:
      DIR$ENTRY$PTR = DIR$ENTRY$PTR + 16;
   ENDDO
   no$more$dir:
   IF      NUM$EXTENSION$FOUND       THENN
      RETURN (EXT$PTR);
   ELLSE
      RETURN NO$NUM$EXTENSION;
   ENDIF
END GREATEST$EXT;

$EJECT

/********************************************************
         O U T P U T     P R O C E D U R E S
********************************************************/

OUTPUT$LIST: PROC;
  DCL TMP$FILL$INDEX  ADDRESS,
      TMP$NAME$INDEX  ADDRESS;

  PRINT$GREATEST$NUMERIC$EXT: PROC ;
     DCL ( EXT, TMP$P, LEN) ADDRESS;
     EXT = GREATEST$EXT(.NAME$LIST(TMP$NAME$INDEX).NAME);
     SCANP = .NAME$LIST(TMP$NAME$INDEX).NAME;
     LEN = LESSER$OF(LENGTH$OF(.LET$OR$DIG$CH),6);
     IF EXT = 0 THENN
        CALL FMOVE(6,.BLANK$STR,.NO$EXT$MSG);
        CALL FMOVE(LEN,SCANP,.NO$EXT$MSG);
        CALL PRINT(.NO$EXT$MSG);
     ELLSE
        CALL FMOVE(6,.BLANK$STR,.EXT$MSG(30));
        CALL FMOVE(LEN,SCANP,.EXT$MSG(30 + 6 - LEN));
        CALL FMOVE(3,EXT,.EXT$MSG(37));
        CALL PRINT(.EXT$MSG);
     ENDIF
  END PRINT$GREATEST$NUMERIC$EXT;

  CALL READ$IN$DIRECTORY;
  TMP$NAME$INDEX = 0;
  DO WHILE TMP$NAME$INDEX <= NAME$INDEX;
     CALL PRINT$GREATEST$NUMERIC$EXT;
     TMP$NAME$INDEX = TMP$NAME$INDEX + 1;
  ENDDO
END OUTPUT$LIST;

$EJECT

/******************************************************
     C O M M A N D    L I N E  P R O C E S S I N G
                 P R O C E D U R E S
******************************************************/

PROCESS$COMMAND$LINE: PROC;
   GET$TEMPLATE$FILENAME: PROC;
     DCL STAT$MSG (*) BYTE DATA('process$command$line',0);
     CALL READC(.READBUF,128);
     CALL CHK$STATUS(.STAT$MSG);
     SCANP$TMP,SCANP = DEBLANK(.READBUF);
     IF         SCANMATCH(.('?',0))         THENN
$IF XVERSION
        DCL VERNO (*) BYTE DATA('latest X104',0);
$ELSE
        DCL VERNO (*) BYTE DATA('latest V1.1',0);
$ENDIF
        CALL PRINT$CR$EXIT(.VERNO);
     ENDIF
     SCANP = DEBLANK(SCANP);
     IF DIG$CH THENN
        DIR$TO$SEARCH = SCANBYTE;
        SCANP = DEBLANK(SCANP+1);
     ELLSE
        CALL PRINT$CR$EXIT(.('missing drive #',0));
     ENDIF
  END GET$TEMPLATE$FILENAME;

   MAKE$LIST: PROC;
      DCL FLAG BYTE;

         ADD$FILENAME: PROC BYTE;

         ADD$NAME: PROC (N$INDEX);
            DCL (N$INDEX,LEN$NAME$PART)  ADDRESS;
            IF (LEN$NAME$PART :=LENGTH$OF(.LET$OR$DIG$CH)) > 6  THENN
               CALL PRINT$CR(.('name part too long: ',0));
               SCANP = SCANP + 7;
               SCANBYTE = NULL;
               CALL PRINT$CR$EXIT(SCANP-7);
            ELLSE
               CALL FMOVE(6,.NULL$STRING,.NAMELIST(N$INDEX).NAME);
               CALL FMOVE(LEN$NAME$PART,SCANP,.NAME$LIST(N$INDEX).NAME);
               /* set type field in the event that it will be used */
               SCANP = SCANP + LEN$NAME$PART;
               IF        BLANK$CH OR TERM$CH             THENN
                  NAMELIST(N$INDEX).TYPE = NAME$ONLY$TYPE;
               ELSIF      DOT$CH                 THENN
                  SCAN$P = SCANP + 1;
                  IF    LET$OR$DIG$CH     THENN
                     NAMELIST(N$INDEX).TYPE = NAME$DOT$EXT$TYPE;
                  ELLSE
                     NAMELIST(N$INDEX).TYPE = NAME$DOT$TYPE;
                  ENDIF
               ELLSE
                  CALL PRINT$CR$EXIT(.('a blank or dot must follow name part',0));
               ENDIF
            ENDIF
         END ADD$NAME;

         SCANP = DEBLANK(SCANP);
         IF TERM$CH                              THENN
            RETURN DONE;
         ELSIF SCANMATCH(.('&',0))     THENN
            CALL ENFORCE$NO$TOKENS;
            CALL PRINT(.('**',0));
            CALL READC(.READBUF,128);
            SCANP = DEBLANK(.READBUF);
            RETURN NEW$LINE;
         ELSIF FILE$CH                 THENN
            CALL ADD$NAME(NAME$INDEX);
            IF (NAME$INDEX := NAME$INDEX + 1) = MAXINDEX THEN
              CALL PRINT$CR$EXIT(.('maximum 200 filenames exceeded',0));
            RETURN NAME$ADDED;
         ELLSE                                          /* syntax chk opt */
            DCL TEMP$PTR ADDRESS;
            TEMP$PTR = SCANP;
            DO WHILE NOT(BLANK$CH) AND NOT(TERM$CH);
               SCANP = SCANP + 1;
            ENDDO
            SCAN$BYTE = NULL;
            CALL PRINT(TEMP$PTR);
            CALL PRINT$CR$EXIT(.(' not a filename',0));
         ENDIF
      END ADDFILENAME;

      FLAG = NOT DONE;
      DO WHILE FLAG <> DONE;
         FLAG = ADD$FILENAME;
      ENDDO
      IF NAME$INDEX = 0 THENN
         CALL PRINT$CR$EXIT(.('no filenames on command line',0));
      ELLSE
         NAME$INDEX = NAME$INDEX - 1;
      ENDIF
   END MAKE$LIST;

   CALL GET$TEMPLATE$FILENAME;
   CALL MAKE$LIST;
   END PROCESS$COMMAND$LINE;

$EJECT
/*********************************************************
     F I R S T      E X E C U T A B L E      C O D E
*********************************************************/
REPORT = FALSE;
LEAD$CHAR = '0';
CALL PROCESS$COMMAND$LINE;
CALL OUTPUT$LIST;

CALL EXIT;

END;

src/loop.plm
LOOP$MOD: DO;

/************************************************************************/
/*																		*/
/*     'Copyright 1981,1983 Intel Corporation'.  All rights reserved.	*/
/*      No part of this program or publication may be reproduced,		*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

$IF XVERSION
DECLARE PROPRIETARY(*) BYTE DATA ('INTEL PROPRIETARY SOFTWARE');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=X103',0);
$ELSE
DECLARE COPYRIGHT (*) BYTE DATA  ('COPYRIGHT 1981,1983 INTEL ');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.1',0);
$ENDIF


DECLARE	LIT		LITERALLY	'LITERALLY',
		DCL		LIT	'DECLARE',
		TRUE	LIT	'0FFH',
		FALSE	LIT	'000H',
		PROC	LIT	'PROCEDURE',
		PROCEND	LIT	'END',
		THENDO	LIT	'THEN DO;',
		ELSEIF	LIT	'END; ELSE IF',
		ELSEDO	LIT	'END; ELSE DO;',
		IFEND	LIT	'END',
		WHILEND	LIT	'END',
		CR		LIT	'0DH',
		LF		LIT	'0AH';

EXIT:	PROC EXTERNAL;											PROCEND;
READ:	PROC (A,B,C,D,E) EXTERNAL;	DCL (A,B,C,D,E) ADDRESS;	PROCEND;
SEEK:	PROC (A,B,C,D,E) EXTERNAL;	DCL (A,B,C,D,E) ADDRESS;	PROCEND;

DCL (STATUS, ACTUAL) ADDRESS;

CALL READ (1, .MEMORY, 128, .ACTUAL, .STATUS); /* Skip command tail. */
ACTUAL = 0;
CALL SEEK (1, 2, .ACTUAL, .ACTUAL, .STATUS);
CALL EXIT; /* Don't need to check status. */

END LOOP$MOD;
src/lower.plm
/*
 * lower
 *      Program to convert a file to lower case ascii.
 *
 * Call:
 *
 *      -lower file1 file2
 *
 * Where:
 *      file1 is source file,
 *      file2 is file1 translated to lower case.
 *
 */

lower: DO;

/************************************************************************/
/*																		*/
/*     'Copyright 1981,1983 Intel Corporation'.  All rights reserved.	*/
/*      No part of this program or publication may be reproduced,		*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

$IF XVERSION
DECLARE PROPRIETARY(*) BYTE DATA ('INTEL PROPRIETARY SOFTWARE');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=X103',0);
$ELSE
DECLARE COPYRIGHT (*) BYTE DATA  ('COPYRIGHT 1981,1983 INTEL ');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.1',0);
$ENDIF

    


    /*
     * external procs.
     */

    csargs: PROCEDURE(argptrs,string,count) EXTERNAL;
        DECLARE (string,argptrs,count) ADDRESS;
    END csargs;

    fopen: PROCEDURE(buffer,name,status) EXTERNAL;
        DECLARE (name,buffer,status) ADDRESS;
    END fopen;

    fcreat: PROCEDURE(buffer,name,status) EXTERNAL;
        DECLARE (name,buffer,status) ADDRESS;
    END fcreat;

    fflush: PROCEDURE(buffer) EXTERNAL;
        DECLARE buffer ADDRESS;
    END fflush;

    getc: PROCEDURE(buffer) BYTE EXTERNAL;
        DECLARE buffer ADDRESS;
    END getc;

    putc: PROCEDURE(chr,buffer) EXTERNAL;
        DECLARE chr BYTE;
        DECLARE buffer ADDRESS;
    END putc;

    outstr: PROCEDURE(string) EXTERNAL;
        DECLARE string ADDRESS;
    END outstr;

    exit: PROCEDURE EXTERNAL;
    END exit;

    /*
     * local data.
     */

    DECLARE
        in$buf(140) BYTE,
        out$buf(140) BYTE,
        arg$chrs(50) BYTE,
        arg$ptr(5) ADDRESS,
        arg$cnt ADDRESS,
        c BYTE,
        status ADDRESS;

    DECLARE
        CR LITERALLY '0DH',
        LF LITERALLY '0AH',
        FOREVER LITERALLY 'WHILE 1';

    /*
     * main program. open files, do translation.
     */

    CALL csargs(.arg$ptr,.arg$chrs,.arg$cnt);

    IF arg$cnt <> 3 THEN DO;
        CALL outstr(.('Useage: lower file filelc.',CR,LF,0));
        CALL exit;
    END;

    CALL fopen(.in$buf,arg$ptr(1),.status);
    IF status <> 0 THEN DO;
        CALL outstr(.('Can''t open ',0));
        CALL outstr(arg$ptr(1));
        CALL outstr(.(CR,LF,0));
        CALL exit;
    END;

    CALL fcreat(.out$buf,arg$ptr(2),.status);
    IF status <> 0 THEN DO;
        CALL outstr(.('Can''t create ',0));
        CALL outstr(arg$ptr(2));
        CALL outstr(.(CR,LF,0));
        CALL exit;
    END;

    /*
     * main loop. get char, xlat to lower case if necessary, write.
     */

    DO FOREVER;

        IF (c := getc(.in$buf)) = 0 THEN DO;
            CALL fflush(.out$buf);
            CALL exit;
        END;

        IF (c >= 'A') AND (c <= 'Z') THEN
            c = c + ('a' - 'A');

        CALL putc(c,.out$buf);

    END;

END lower;
src/m3.asm
;     'Copyright 1981,1983 Intel Corporation'.  All rights reserved.
;      No part of this program or publication may be reproduced,
;      transmitted, transcribed, stored in a retrievel system, or
;      translated into any language or computer language, in any
;      form or by any means, electronic, mechanical, magnetic,
;      optical, chemical, manual or otherwise, without the prior
;      written permission of Intel Corporation, 3065 Bowers
;      Avenue, Santa Clara, California, 95051, Attn: Software
;      License Administration.
	STKLN 10
	CSEG
	PUBLIC CONVND
	EXTRN DIVIDE
CONVND: PUSH PSW
	PUSH H
	MOV H,D
	MOV L,E
	MVI M,' '
	INX H
	MVI M,' '
	INX H
	MVI M,' '
	INX H
	MVI M,' '
	INX H
	MVI M,'0'
	INX H
	MVI M,':'
	DCX H
LOOP:   MOV A,C
	ANA A
	JNZ CONV1
	MOV A,B
	ANA A
	JZ RETURN
CONV1:  LXI D,10
	CALL DIVIDE
	MOV A,C
	ADI 30H
	MOV M,A
	DCX H
	MOV B,D
	MOV C,E
	JMP LOOP
RETURN: POP H
	POP PSW
	RET
	
    END
src/merg80.plm
MERG80: DO;

/************************************************************************/
/*																		*/
/*     'Copyright 1981,1983 Intel Corporation'.  All rights reserved.	*/
/*      No part of this program or publication may be reproduced,		*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

$IF XVERSION
DECLARE PROPRIETARY(*) BYTE DATA ('INTEL PROPRIETARY SOFTWARE');

DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=X104',0);
$ELSE
DECLARE COPYRIGHT (*) BYTE DATA  ('COPYRIGHT 1981,1983 INTEL ');

DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.1',0);
$ENDIF

    


$NOLIST
BLNK$CH: PROCEDURE BYTE EXTERNAL;END;
DECLARE FILE$NAME$LIMIT BYTE EXTERNAL;
OUTBLANK: PROCEDURE EXTERNAL;END;
FMOVE: PROCEDURE (ZZ1,ZZ2,ZZ3) EXTERNAL; DECLARE (ZZ1,ZZ2,ZZ3)ADDRESS;END;
BUMP$SCAN$P: PROCEDURE EXTERNAL; END;
FORCUP: PROCEDURE BYTE EXTERNAL; END;
SCAN$WHILE$BLANKS: PROCEDURE EXTERNAL; END;
BLTSYM: PROCEDURE EXTERNAL; END;
SORT: PROCEDURE(ZZA,ZZB,ZZC)EXTERNAL; DECLARE(ZZA,ZZB,ZZC)ADDRESS; END;
SET$OB: PROCEDURE (A) EXTERNAL; DECLARE A ADDRESS; END;
FILL: PROCEDURE (A,B,C) EXTERNAL; DECLARE (A,B) ADDRESS, C BYTE; END;
OUT$CRLF: PROCEDURE EXTERNAL; END;
OUT$SCAN$STRING: PROCEDURE EXTERNAL; END;
LTNMCH: PROCEDURE BYTE EXTERNAL; END;
OUT$SCAN$BYTE: PROCEDURE EXTERNAL; END;
MIN: PROCEDURE (A,B) ADDRESS EXTERNAL; DECLARE (A,B) ADDRESS; END;
MAX: PROCEDURE (A,B) ADDRESS EXTERNAL; DECLARE (A,B) ADDRESS; END;
OUT$CHAR: PROCEDURE (CHAR) EXTERNAL; DECLARE CHAR BYTE; END;
TERM$CH: PROCEDURE BYTE EXTERNAL; END;
CONSOLE$IN: PROCEDURE EXTERNAL; END;
SBYTEU: PROCEDURE (DISTANCE) EXTERNAL; DECLARE DISTANCE ADDRESS; END;
WRITEU: PROCEDURE (SRC$PTR,COUNT) EXTERNAL;
  DECLARE (SRC$PTR,COUNT) ADDRESS; END;
READU: PROCEDURE (DEST$PTR,COUNT) EXTERNAL;
  DECLARE (DEST$PTR,COUNT) ADDRESS; END;
READI: PROCEDURE (DEST$PTR,COUNT) EXTERNAL;
  DECLARE (DEST$PTR,COUNT) ADDRESS; END;
OPENI: PROCEDURE (FILE$NAME$PTR) EXTERNAL; DECLARE FILE$NAME$PTR ADDRESS; END;
OPENU: PROCEDURE (FILE$NAME$PTR) EXTERNAL; DECLARE FILE$NAME$PTR ADDRESS; END;
DDIG$CH: PROCEDURE BYTE EXTERNAL; END;
MEMCK: PROCEDURE ADDRESS EXTERNAL; END;
EX: PROCEDURE EXTERNAL; END;
OHEX$W: PROCEDURE (VALUE) EXTERNAL; DECLARE VALUE ADDRESS; END;
OUT$WRITE: PROCEDURE (PTR,LENGTH) EXTERNAL;
  DECLARE PTR ADDRESS, LENGTH BYTE; END;
HEX$IN: PROCEDURE ADDRESS EXTERNAL; END;
SET$SC: PROCEDURE (PTR) EXTERNAL; DECLARE PTR ADDRESS; END;
ERROR$MESSAGE: PROCEDURE (PTR) EXTERNAL; DECLARE PTR ADDRESS; END;
PRINTCR: PROCEDURE (PTR) EXTERNAL; DECLARE PTR ADDRESS; END;
DEC$IN: PROCEDURE ADDRESS EXTERNAL; END;
OPEN$SCAN: PROCEDURE (PROC$ADDR) EXTERNAL; DECLARE PROC$ADDR ADDRESS; END;
MOVE$PARENS$FILE$NAME: PROCEDURE (DEST$PTR) EXTERNAL;
  DECLARE DEST$PTR ADDRESS; END;
SCAN$EXPECT: PROCEDURE (PTR) EXTERNAL; DECLARE PTR ADDRESS; END;
SFOUND: PROCEDURE BYTE EXTERNAL; END;
LEN$STR$NUL: PROCEDURE (PTR) ADDRESS EXTERNAL; DECLARE PTR ADDRESS; END;
$LIST

DECLARE STR LITERALLY '(.(';
DECLARE NUL LITERALLY ',0))';
DECLARE TRUE LITERALLY '0FFH';
DECLARE FALSE LITERALLY '0';

DECLARE OBUF$P ADDRESS EXTERNAL;
DECLARE SCAN$P ADDRESS EXTERNAL;
DECLARE SCAN$BYTE BASED SCAN$P BYTE;
DECLARE SCAN$ADDR BASED SCAN$P ADDRESS;
DECLARE FATAL BYTE EXTERNAL;
DECLARE ACTUAL ADDRESS EXTERNAL;
DECLARE TARLEN BYTE EXTERNAL;
DECLARE TARGET (45) BYTE PUBLIC;
DECLARE TARGADDR ADDRESS AT (.TARGET);
DECLARE TEMP ADDRESS;
DECLARE SYM$MAX ADDRESS;
DECLARE OUT$P ADDRESS;
DECLARE OUT$ADDR BASED OUT$P (1) ADDRESS;
DECLARE I BYTE;
DECLARE COL$MAX BYTE;
DECLARE COL$LENGTH BYTE;
DECLARE PTR$INDEX ADDRESS;
DECLARE SYM$COUNT ADDRESS;
DECLARE SYM$BASE ADDRESS;
DECLARE NAMES$TOP ADDRESS;
DECLARE LINES$TOP ADDRESS;
DECLARE CAPACITY$BYTES ADDRESS;
DECLARE SEPARATOR BYTE INITIAL (0CH);
DECLARE SORTING BYTE INITIAL (0FFH);
DECLARE GIVE$UP ADDRESS EXTERNAL;
DECLARE GIVE$UP$BYTE BASED GIVE$UP (3) BYTE;
DECLARE OLD$SYMTAB$SEEN BYTE;
DECLARE LOW$INDEX ADDRESS;
DECLARE INDEX ADDRESS;
DECLARE LIN$BASE ADDRESS;
DECLARE LIN BASED LIN$BASE (1) ADDRESS;
DECLARE QHSYMQ (*) BYTE DATA ('H SYM  ');
DECLARE QMODQ (*) BYTE DATA ('      MOD  ');
DECLARE QHLINQ (*) BYTE DATA ('H LIN  ');
DECLARE MOD$NAME (32) BYTE;
DECLARE OLD$INDEX ADDRESS;
$EJECT

READ$NOT$FINISHED: PROCEDURE BYTE;
  RETURN (ACTUAL = CAPACITY$BYTES);
END;

FLUSH: PROCEDURE;
  IF ACTUAL > 32766 THEN
   DO;
    CALL SBYTEU(-32512);
    CALL SBYTEU(32512 - ACTUAL);
   END;
  ELSE CALL SBYTEU(-ACTUAL);
  CALL WRITEU(LINES$TOP,SCAN$P-LINES$TOP);
  IF OLD$SYMTAB$SEEN THEN ACTUAL = 0;
  ELSE CALL READU(LINES$TOP,CAPACITY$BYTES);
  SCAN$P = LINES$TOP;
  GIVE$UP = LINES$TOP + ACTUAL;
  GIVEUP$BYTE(3) = 0;
  TARLEN = 2;
  TARGADDR = 0C00H;
  IF SFOUND THEN
   DO;
    OLD$SYMTAB$SEEN = TRUE;
    SCAN$P = SCAN$P - 2;
    GIVEUP = SCAN$P;
    CAPACITY$BYTES = ACTUAL + 1;
    SCAN$P = LINES$TOP;
   END;
  TARLEN = 1;
  TARGET(0) = 0AH;
END;

NEXT$CHAR$BLANK: PROCEDURE BYTE;
  CALL SET$SC(SCAN$P+1);
  RETURN BLNK$CH;
END;

NO$MORE: PROCEDURE BYTE;
  DO WHILE READ$NOT$FINISHED;
    IF SFOUND THEN
      RETURN FALSE;
    CALL FLUSH;
  END;
  RETURN NOT SFOUND;
END;

NEXT$LINE$NUMBER$FOUND: PROCEDURE BYTE;
   DO WHILE NOT (DDIG$CH AND NEXT$CHAR$BLANK);
    SCAN$P = SCAN$P - 3;
    IF NO$MORE THEN RETURN FALSE;
     DO WHILE TERM$CH;
      IF NO$MORE THEN RETURN FALSE;
     END;
    SCAN$P = SCAN$P + 3;
   END;
  SCAN$P = SCAN$P - 3;
  IF (SCAN$P > GIVE$UP - 256) AND READ$NOT$FINISHED THEN CALL FLUSH;
  OBUF$P = SCAN$P + 6;
  RETURN TRUE;
END;

OUT$LIN: PROCEDURE (VALUE);
  DECLARE VALUE ADDRESS;
  IF VALUE < LOW$INDEX THEN GO TO DASHES;
  IF VALUE > INDEX THEN GO TO DASHES;
  IF LIN(VALUE) = 0 THEN GO TO DASHES;
  CALL OHEXW(LIN(VALUE));
  RETURN;
 DASHES:
  CALL OUT$WRITE(.('----'),4);
END;

$EJECT
GET$LINE$NUMBER: PROCEDURE;
  SCAN$P = SCAN$P - 16;
  LIN(INDEX) = HEXIN;
  SCAN$P = SCAN$P + 12;
END;

READ: PROCEDURE (PTR);
  DECLARE PTR ADDRESS;
  CALL READI(PTR,(CAPACITY$BYTES:=(MEMCK-PTR)));
  SCAN$P = .MEMORY;
  GIVEUP = PTR + ACTUAL;
END;

CHECK$GIVE$UP: PROCEDURE;
  CALL FMOVE(GIVEUP-SCAN$P,SCAN$P,.MEMORY);
  CALL READ(GIVEUP - SCAN$P + .MEMORY);
  CALL SET$SC(.MEMORY);
  TARLEN = 11;
  IF SFOUND THEN GIVE$UP = SCAN$P;
END;

PUT$SYM$ADDR: PROCEDURE;
  CALL SET$SC(SCAN$P-11);
  TEMP = HEXIN;
  CALL OUT$CHAR(LOW (TEMP));
  CALL OUT$CHAR(HIGH (TEMP));
END;

COLLECT$SYMBOL$NAMES: PROCEDURE;
  SYM$MAX = 0;
  SYM$COUNT = 0;
  CALL FMOVE(7,.QHSYMQ,.TARGET);
  TARLEN = 7;
  OUT$P = MEMCK;
  OBUF$P = .MEMORY;
   DO WHILE SFOUND;
    OUT$P = OUT$P - 2;
    SYM$COUNT = SYM$COUNT + 1;
    OUT$ADDR(0) = OBUF$P;
    CALL PUT$SYM$ADDR;
    SYM$BASE = OBUF$P;
     DO WHILE LTNMCH;
      CALL OUT$SCAN$BYTE;
     END;
    SYM$MAX = MAX(OBUF$P-SYM$BASE,SYM$MAX);
    CALL OUT$CHAR(0);
   END;
  NAMES$TOP = OBUF$P;
END;

COLLECT$LINE$NUMBERS: PROCEDURE;
  CALL FMOVE(7,.QHLINQ,.TARGET);
  TARLEN = 7;
  IF SFOUND THEN
   DO;
    INDEX = (LOW$INDEX := DECIN);
    LIN$BASE = NAMES$TOP - (2*LOW$INDEX);
    CALL GET$LINE$NUMBER;
     DO WHILE SFOUND;
      OLD$INDEX = INDEX;
      INDEX = DECIN;
       DO WHILE OLD$INDEX < INDEX - 1;
        OLD$INDEX = OLD$INDEX + 1;
        LIN(OLD$INDEX) = 0;
       END;
      CALL GET$LINE$NUMBER;
     END;
    LINES$TOP = .LIN(INDEX+1);
   END;
  ELSE LOW$INDEX = 0FFFFH;
END;

PROCESS$LOCATE$FILE: PROCEDURE;
  CALL SET$SC(.MEMORY);
  CALL READ(.MEMORY);
  CALL FMOVE(11,.QMODQ,.TARGET);
  TARLEN = LEN$STR$NUL(.MOD$NAME);
  CALL FMOVE(TARLEN,.MOD$NAME,.TARGET+11);
  TARLEN = TARLEN + 11;
   DO WHILE NOT SFOUND;
    IF READ$NOT$FINISHED THEN
     DO;
      CALL FMOVE(TARLEN,GIVEUP-TARLEN,.MEMORY);
      CALL READ(.MEMORY+TARLEN);
     END;
    ELSE
     DO;
      CALL ERROR$MESSAGE STR 'MOD NAME NOT FOUND' NUL;
      CALL EX;
     END;
   END;
  CALL CHECK$GIVEUP;
  CALL COLLECT$SYMBOL$NAMES;
  CALL COLLECT$LINE$NUMBERS;
END;

OUT$SYM$NAME: PROCEDURE;
  CALL SET$OB(OBUF$P);
  SCAN$P = OUT$ADDR(PTR$INDEX);
  CALL OHEXW(SCAN$ADDR);
  SCAN$P = SCAN$P + 2;
  CALL OUT$BLANK;
  CALL OUT$SCAN$STRING;
END;

OUTPUT$SYMBOLS: PROCEDURE;
  CALL FILL(15000,NAMES$TOP,' ');
  SYM$MAX = SYM$MAX + 8;
  COL$MAX = 128 / SYM$MAX;
  COL$LENGTH = MAX (60, SYM$COUNT/COL$MAX + 1);
  COL$LENGTH = MIN (COL$LENGTH,SYM$COUNT);
  OBUF$P = NAMES$TOP;
  CALL OUT$CHAR(0);
  CALL OUT$CHAR(SEPARATOR);
  I = COL$LENGTH;
   DO WHILE I > 0;
    PTR$INDEX = SYM$COUNT + (I := I - 1);
    OBUF$P = OBUF$P + 4;
     DO WHILE PTR$INDEX >= COL$LENGTH;
      PTR$INDEX = PTR$INDEX - COL$LENGTH;
      CALL OUT$SYM$NAME;
      OBUF$P = OBUF$P + SYM$MAX;
     END;
    CALL OUT$CRLF;
   END;
  CALL WRITEU(NAMES$TOP,OBUF$P - NAMES$TOP);
END;

$EJECT

FATAL = TRUE;
CALL CONSOLE$IN;
CALL OPEN$SCAN(.OPENI);
FILE$NAME$LIMIT = 31;
CALL MOVE$PARENS$FILE$NAME(.MOD$NAME);
CALL SCAN$EXPECT STR 'INTO' NUL;
CALL PROCESS$LOCATE$FILE;
CALL OPEN$SCAN(.OPENU);
 DO WHILE NOT TERM$CH;
  IF FORCUP = 'N' THEN SORTING = FALSE;
  IF FORCUP = 'L' THEN SEPARATOR = 0AH;
  CALL BUMP$SCAN$P;
 END;
CAPACITY$BYTES = OUT$P - LINES$TOP - 4;
OLD$SYMTAB$SEEN = FALSE;
SCAN$P = LINES$TOP;
ACTUAL = 0;
CALL FLUSH;
SCAN$P = SCAN$P + 3;
TARLEN = 1;
TARGET(0) = 0AH;
 DO WHILE NEXT$LINE$NUMBER$FOUND;
  CALL OUTLIN(DECIN);
  CALL OUT$BLANK;
  SCAN$P = SCAN$P + 4;
 END;
SCAN$P = GIVE$UP;
CALL FLUSH;
IF SORTING THEN CALL SORT(OUT$P,SYM$COUNT,.BLTSYM);
CALL OUTPUT$SYMBOLS;
CALL EX;

END MERG80;
src/merg86.plm
MERG86: DO;

/************************************************************************/
/*																		*/
/*     'Copyright 1981,1983 Intel Corporation'.  All rights reserved.	*/
/*      No part of this program or publication may be reproduced,		*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

$IF XVERSION
DECLARE PROPRIETARY(*) BYTE DATA ('INTEL PROPRIETARY SOFTWARE');

DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=X164',0);
$ELSE
DECLARE COPYRIGHT (*) BYTE DATA  ('COPYRIGHT 1981,1983 INTEL ');

DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.7',0);
$ENDIF


DECLARE CR                  LITERALLY '0DH';
DECLARE LF                  LITERALLY '0AH';
DECLARE FF                  LITERALLY '0CH';

$IF XVERSION
DECLARE SIGN$ON$MSG (*) BYTE            /* 01/21/81 */
 DATA (CR, LF, 'ISIS-II MERG86, X164 - LINK86 & LOC86/PLM86 MERGE PROGRAM',0);
$ELSE
DECLARE SIGN$ON$MSG (*) BYTE            /* 01/21/81 */
 DATA (CR, LF, 'ISIS-II MERG86, V1.7 - LINK86 & LOC86/PLM86 MERGE PROGRAM',0);
$ENDIF

$NOLIST
/* PEX */
DECLARE SCANP ADDRESS EXTERNAL;
DECLARE SCANADDR BASED SCANP ADDRESS;
DECLARE OBUFP ADDRESS EXTERNAL;
DECLARE TARLEN BYTE EXTERNAL;
DECLARE GIVEUP ADDRESS EXTERNAL;
BLNKCH :PROCEDURE BYTE EXTERNAL;END;
BUMPSCANP :PROCEDURE  EXTERNAL;END;
CONSOLEIN :PROCEDURE  EXTERNAL;END;
DDIGCH :PROCEDURE BYTE EXTERNAL;END;
DECIN :PROCEDURE ADDRESS EXTERNAL;END;
ERRORMESSAGE :PROCEDURE (ZZ1) EXTERNAL;DECLARE (ZZ1)ADDRESS;END;
FILL :PROCEDURE (ZZ1,ZZ2,ZZ3) EXTERNAL;DECLARE (ZZ1,ZZ2)ADDRESS,(ZZ3)BYTE;END;
FMOVE :PROCEDURE (ZZ1,ZZ2,ZZ3) EXTERNAL;DECLARE (ZZ1,ZZ2,ZZ3)ADDRESS;END;
BLTSYM: PROCEDURE EXTERNAL;END;
SORT :PROCEDURE (ZZ1,ZZ2,ZZ3) EXTERNAL;DECLARE (ZZ1,ZZ2,ZZ3)ADDRESS;END;
FORCUP :PROCEDURE BYTE EXTERNAL;END;
HEXIN :PROCEDURE ADDRESS EXTERNAL;END;
LENSTRNUL :PROCEDURE (ZZ1)BYTE EXTERNAL;DECLARE (ZZ1)ADDRESS;END;
LTNMCH :PROCEDURE BYTE EXTERNAL;END;
TOKNCH :PROCEDURE BYTE EXTERNAL; END;
MAX :PROCEDURE (ZZ1,ZZ2)ADDRESS EXTERNAL;DECLARE (ZZ1,ZZ2)ADDRESS;END;
MIN :PROCEDURE (ZZ1,ZZ2)ADDRESS EXTERNAL;DECLARE (ZZ1,ZZ2)ADDRESS;END;
OHEXB :PROCEDURE (ZZ1) EXTERNAL;DECLARE (ZZ1)BYTE;END;
OHEXW :PROCEDURE (ZZ1) EXTERNAL;DECLARE (ZZ1)ADDRESS;END;
OUTBLANK :PROCEDURE  EXTERNAL;END;
OUTCHAR :PROCEDURE (ZZ1) EXTERNAL;DECLARE (ZZ1)BYTE;END;
OUTCRLF :PROCEDURE  EXTERNAL;END;
OUTSCANBYTE :PROCEDURE  EXTERNAL;END;
OUTSCANSTRING :PROCEDURE  EXTERNAL;END;
OUTWRITE :PROCEDURE (ZZ1,ZZ2) EXTERNAL;DECLARE (ZZ1)ADDRESS,(ZZ2)BYTE;END;
SCANEXPECT :PROCEDURE (ZZ1) EXTERNAL;DECLARE (ZZ1)ADDRESS;END;
SCANMATCH :PROCEDURE (ZZ1)BYTE EXTERNAL;DECLARE (ZZ1)ADDRESS;END;
SETOB :PROCEDURE (ZZ1) EXTERNAL;DECLARE (ZZ1)ADDRESS;END;
SETSC :PROCEDURE (ZZ1) EXTERNAL;DECLARE (ZZ1)ADDRESS;END;
SFOUND :PROCEDURE BYTE EXTERNAL;END;
STRINGLENGTH :PROCEDURE (ZZ1,ZZ2)BYTE EXTERNAL;DECLARE (ZZ1,ZZ2)ADDRESS;END;
TERMCH :PROCEDURE BYTE EXTERNAL;END;
PRINTCR: PROCEDURE (ZZ1) EXTERNAL; DECLARE ZZ1 ADDRESS; END;
SCANWHILE: PROCEDURE (ZZ1) EXTERNAL; DECLARE ZZ1 ADDRESS; END;
SCANUNTIL: PROCEDURE (ZZ1) EXTERNAL; DECLARE ZZ1 ADDRESS; END;
DECLARE FATAL BYTE EXTERNAL;
DECLARE ACTUAL ADDRESS EXTERNAL;
EX :PROCEDURE  EXTERNAL;END;
MEMCK :PROCEDURE ADDRESS EXTERNAL;END;
OPENI :PROCEDURE (ZZ1) EXTERNAL;DECLARE (ZZ1)ADDRESS;END;
OPENU :PROCEDURE (ZZ1) EXTERNAL;DECLARE (ZZ1)ADDRESS;END;
READI :PROCEDURE (ZZ1,ZZ2) EXTERNAL;DECLARE (ZZ1,ZZ2)ADDRESS;END;
READU :PROCEDURE (ZZ1,ZZ2) EXTERNAL;DECLARE (ZZ1,ZZ2)ADDRESS;END;
SBYTEU :PROCEDURE (ZZ1) EXTERNAL;DECLARE (ZZ1)ADDRESS;END;
WRITEU :PROCEDURE (ZZ1,ZZ2) EXTERNAL;DECLARE (ZZ1,ZZ2)ADDRESS;END;
/* deleted x161
DECLARE FILENAMELIMIT BYTE EXTERNAL;
MOVEPARENSFILENAME :PROCEDURE (ZZ1) EXTERNAL;DECLARE (ZZ1)ADDRESS;END;
*/
SCAN$WHILE$BLANKS: PROCEDURE EXTERNAL;END; /* added x161 */

OPENSCAN :PROCEDURE (ZZ1) EXTERNAL;DECLARE (ZZ1)ADDRESS;END;
DECLARE FALSE LITERALLY'0';
DECLARE NUL LITERALLY',0))';
DECLARE STR LITERALLY'(.(';
DECLARE TRUE LITERALLY'255';
DECLARE SCANBYTE BASED SCANP BYTE;
OUTPRINT :PROCEDURE (ZZ1) EXTERNAL;DECLARE (ZZ1)ADDRESS;END;
/* ENDPEX */
$LIST

DECLARE FILE$NAME$LIMIT BYTE INITIAL (15); /* added x161 */
DECLARE TARGET (45) BYTE PUBLIC;
DECLARE TARGADDR ADDRESS AT (.TARGET);
DECLARE TEMP ADDRESS;
DECLARE SYM$MAX ADDRESS;
DECLARE ASSEMBLY$LANGUAGE BYTE INITIAL (0);
DECLARE OUT$P ADDRESS;
DECLARE OUTBYTE BASED OBUF$P BYTE;
DECLARE OUTWORD BASED OBUF$P ADDRESS;
DECLARE OUT$ADDR BASED OUT$P (1) ADDRESS;
DECLARE I BYTE;
DECLARE COL$MAX BYTE;
DECLARE COL$LENGTH BYTE;
DECLARE PTR$INDEX ADDRESS;
DECLARE SYM$COUNT ADDRESS;
DECLARE SYM$BASE ADDRESS;
DECLARE NAMES$TOP ADDRESS;
DECLARE LINES$TOP ADDRESS;
DECLARE LINES$TOP$BYTE BASED LINES$TOP (1) BYTE;
DECLARE CAPACITY$BYTES ADDRESS;
DECLARE SEPARATOR BYTE INITIAL (0CH);
DECLARE SORTING BYTE INITIAL (0FFH);
DECLARE GIVE$UP$BYTE BASED GIVE$UP (3) BYTE;
DECLARE OLD$SYMTAB$SEEN BYTE;
DECLARE LOW$INDEX ADDRESS;
DECLARE INDEX ADDRESS;
DECLARE LIN$BASE ADDRESS;
DECLARE LIN BASED LIN$BASE (1) ADDRESS;
DECLARE SYM$LINE (*) BYTE DATA ('H SYM  ');
DECLARE BAS$LINE (*) BYTE DATA ('H BAS  ');
DECLARE LIN$LINE (*) BYTE DATA ('H LIN  ');
DECLARE STACK$BASE (*) BYTE DATA ('STACK  ');
DECLARE START$OF$RECORD ADDRESS;
DECLARE ARROW (5) BYTE INITIAL ('==>  ');  /* goes right before MOD$NAME */
DECLARE MOD$NAME (32) BYTE INITIAL (0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
DECLARE MOD$NAME$LENGTH BYTE;
DECLARE CLOSE$ARROW (5) BYTE DATA ('  <==');
DECLARE OLD$INDEX ADDRESS;

/* NEW DECLARATIONS FOR VERSION X150, 01/15/81 */

DECLARE WIDTH$OF$TYPE$COL   LITERALLY '3';

DECLARE LINES$IN$HEADER  BYTE INITIAL (3);
DECLARE OFFSET$COL       BYTE INITIAL (8);
DECLARE TYPE$COL         BYTE INITIAL (15);
DECLARE SYMBOL$COL       BYTE INITIAL (20);
DECLARE LINE$COL         LITERALLY 'SYMBOL$COL';

$EJECT

/* move$file$name,move$parens$file$name from fnames.lib  added x161
   file$ch changed to tokn$ch for modname
*/
MOVE$FILE$NAME: PROCEDURE (DEST$PTR);
  DECLARE DEST$PTR ADDRESS;
  DECLARE DEST$BYTE BASED DEST$PTR BYTE;
  DECLARE COUNT BYTE;
  COUNT = FILE$NAME$LIMIT + 1;
  CALL SCAN$WHILE$BLANKS;
   DO WHILE tokn$ch AND ((COUNT:=COUNT-1) > 0);
    DEST$BYTE = FORCUP;
    CALL BUMP$SCAN$P;
    DEST$PTR = DEST$PTR + 1;
   END;
  IF COUNT = 0 THEN
   DO;
    CALL ERROR$MESSAGE STR'FILE NAME TOO LONG'NUL;
    CALL SCAN$WHILE(.tokn$ch);
   END;
  CALL SCAN$WHILE$BLANKS;
  DEST$BYTE = 0;
END;

MOVE$PARENS$FILE$NAME: PROCEDURE (DEST$PTR);
  DECLARE DEST$PTR ADDRESS;
  CALL SCAN$WHILE$BLANKS;
  CALL SCAN$EXPECT STR'('NUL;
  CALL MOVE$FILE$NAME (DEST$PTR);
  CALL SCAN$EXPECT STR')'NUL;
  CALL SCAN$WHILE$BLANKS;
END;

READ$NOT$FINISHED: PROCEDURE BYTE;
  RETURN (ACTUAL = CAPACITY$BYTES);
END;

FLUSH: PROCEDURE;
  IF ACTUAL > 32766 THEN
   DO;
    CALL SBYTEU(-32512);
    CALL SBYTEU(32512 - ACTUAL);
   END;
  ELSE CALL SBYTEU(-ACTUAL);
  CALL WRITEU(LINES$TOP,SCAN$P-LINES$TOP);
  IF OLD$SYMTAB$SEEN THEN ACTUAL = 0;
  ELSE CALL READU(LINES$TOP,CAPACITY$BYTES);
  SCAN$P = LINES$TOP;
  GIVE$UP = LINES$TOP + ACTUAL;
  GIVEUP$BYTE(3) = 0;
  TARLEN = 2;
  TARGADDR = 0C00H;
  IF SFOUND THEN
   DO;
    OLD$SYMTAB$SEEN = TRUE;
    SCAN$P = SCAN$P - 2;
    GIVEUP = SCAN$P;
    CAPACITY$BYTES = ACTUAL + 1;
    SCAN$P = LINES$TOP;
   END;
  TARLEN = 1;
  TARGET(0) = 0AH;
END;

NEXT$CHAR$BLANK: PROCEDURE BYTE;
  CALL SET$SC(SCAN$P+1);
  RETURN BLNK$CH;
END;

NO$MORE: PROCEDURE BYTE;
  DO WHILE READ$NOT$FINISHED;
    IF SFOUND THEN
      RETURN FALSE;
    CALL FLUSH;
  END;
  RETURN NOT SFOUND;
END;

NEXT$LINE$NUMBER$FOUND: PROCEDURE BYTE;
   DO WHILE NOT (DDIG$CH AND NEXT$CHAR$BLANK);
    SCAN$P = SCAN$P - 3;
    IF NO$MORE THEN RETURN FALSE;
     DO WHILE TERM$CH;
      IF NO$MORE THEN RETURN FALSE;
     END;
    SCAN$P = SCAN$P + 3;
   END;
  SCAN$P = SCAN$P - 3;
  IF (SCAN$P > GIVE$UP - 256) AND READ$NOT$FINISHED THEN CALL FLUSH;
  OBUF$P = SCAN$P + 6;
  RETURN TRUE;
END;

OUT$LIN: PROCEDURE (VALUE);
  DECLARE VALUE ADDRESS;
  IF VALUE < LOW$INDEX THEN GO TO DASHES;
  IF VALUE > INDEX THEN GO TO DASHES;
  IF LIN(VALUE) = 0 THEN GO TO DASHES;
  CALL OHEXW(LIN(VALUE));
  RETURN;
 DASHES:
  CALL OUT$WRITE(.('----'),4);
END;

GET$LINE$OFFSET: PROCEDURE;
  SCAN$P = START$OF$RECORD + OFFSET$COL;  /* POINT TO OFFSET COLUMN */
  LIN(INDEX) = HEXIN;
  START$OF$RECORD, SCAN$P = SCAN$P + 15;  /* MOVE TO NEXT RECORD */
END;

READ: PROCEDURE (PTR);
  DECLARE PTR ADDRESS;
  CALL READI(PTR,(CAPACITY$BYTES:=(MEMCK-PTR)));
  SCAN$P = .MEMORY;
  GIVEUP = PTR + ACTUAL;
END;

CHECK$GIVE$UP: PROCEDURE;
  CALL FMOVE(GIVEUP-SCAN$P,SCAN$P,.MEMORY);
  CALL READ(GIVEUP - SCAN$P + .MEMORY);
  SCAN$P = .MEMORY;
  CALL SCAN$WHILE(.TERMCH);
  START$OF$RECORD = SCAN$P;
END;

$EJECT

PUT$SYM$ADDR: PROCEDURE;
  SCAN$P = START$OF$RECORD;
  IF SCAN$BYTE = 'G' THEN
    DO;  /* BASE IS A GROUP */
      TEMP = DECIN;
      OUTBYTE = 0;
      OBUF$P = OBUF$P + 1;
      CALL OUT$CHAR (LOW(TEMP));
      CALL OUT$CHAR (HIGH(TEMP));
    END;
  ELSE IF SCAN$BYTE = 'S' THEN
    DO;
      SCAN$P = SCAN$P + 1;
      IF SCAN$BYTE = '(' THEN
        DO;  /* BASE IS A SEGMENT */
          TEMP = DECIN;
          OUTBYTE = 1;
          OBUF$P = OBUF$P + 1;
          CALL OUT$CHAR (LOW(TEMP));
          CALL OUT$CHAR (HIGH(TEMP));
        END;
      ELSE
        DO;  /* BASE IS STACK */
          OUTBYTE = 2;
          OBUF$P = OBUF$P + 1;
          OUT$WORD = 0;
          OBUF$P = OBUF$P + 2;
          SCAN$P = SCAN$P + 4; /* SKIP PASSED 'STACK' */
        END;
    END;
  ELSE
    DO;  /* BASE IS A FRAME NUMBER */
      OUTBYTE = 3;
      OBUF$P = OBUF$P + 1;
      TEMP = HEXIN;                   /* GET BASE ADDRESS AND OUTPUT IT */
      CALL OUT$CHAR(LOW (TEMP));
      CALL OUT$CHAR(HIGH (TEMP));
    END;
  TEMP = HEXIN;                   /* GET OFFSET ADDRESS AND OUTPUT IT */
  CALL OUT$CHAR(LOW (TEMP));
  CALL OUT$CHAR(HIGH (TEMP));
END;

$EJECT

CHECK$FOR$WARNING: PROCEDURE BYTE;

DECLARE I BYTE;

  IF SCAN$MATCH(.('WARNING:')) THEN
    DO I = 1 TO 4;
      CALL SCAN$UNTIL(.TERMCH);
      SCAN$P = SCAN$P + 2;
      RETURN TRUE;
    END;
  RETURN FALSE;

END CHECK$FOR$WARNING;

$EJECT

STILL$SYMBOLS: PROCEDURE BYTE;

CALL SET$SC(START$OF$RECORD);
SCAN$P = SCAN$P + TYPE$COL;            /* POINT TO TYPE OF RECORD */
IF (SCAN$MATCH(.('SYM',0))) OR (SCAN$MATCH(.('BAS',0))) THEN RETURN TRUE;
ELSE
  DO;
    SCAN$P = START$OF$RECORD;
    IF CHECK$FOR$WARNING THEN
      DO;
        START$OF$RECORD = SCAN$P;
        SCAN$P = SCAN$P + TYPE$COL;
        IF (SCAN$MATCH(.('SYM',0))) OR (SCAN$MATCH(.('BAS',0))) THEN
          RETURN TRUE;
        ELSE RETURN FALSE;
      END;
    ELSE RETURN FALSE;
  END;
RETURN FALSE;

END STILL$SYMBOLS;

COLLECT$SYMBOL$NAMES: PROCEDURE;
  SYM$MAX = 0;
  SYM$COUNT = 0;
  OUT$P = MEMCK;
  OBUF$P = .MEMORY;
   DO WHILE STILL$SYMBOLS;
    OUT$P = OUT$P - 2;
    SYM$COUNT = SYM$COUNT + 1;
    OUT$ADDR(0) = OBUF$P + 1; /* STORE POINTER TO NAME RECORD */
    CALL PUT$SYM$ADDR;
    SCAN$P = START$OF$RECORD + SYMBOL$COL; /* POINT TO SYMBOL NAME */
    SYM$BASE = OBUF$P;
     DO WHILE TOKNCH;
      CALL OUT$SCAN$BYTE;
     END;
    START$OF$RECORD, SCAN$P = SCAN$P + 2;            /* SKIP OVER CRLF */
    SYM$MAX = MAX(OBUF$P-SYM$BASE,SYM$MAX);
    CALL OUT$CHAR(0);
   END;
  NAMES$TOP = OBUF$P;
END;

$EJECT

STILL$LINES: PROCEDURE BYTE;

CALL SET$SC(START$OF$RECORD);
SCAN$P = SCAN$P + TYPE$COL;
IF SCAN$MATCH(.('LIN',0)) THEN RETURN TRUE;
ELSE
  DO;
    SCAN$P = START$OF$RECORD;
    IF CHECK$FOR$WARNING THEN
      DO;
        START$OF$RECORD = SCAN$P;
        SCAN$P = SCAN$P + TYPE$COL;
        IF SCAN$MATCH(.('LIN',0)) THEN RETURN TRUE;
        ELSE RETURN FALSE;
      END;
    ELSE RETURN FALSE;
  END;
RETURN FALSE;

END STILL$LINES;

COLLECT$LINE$NUMBERS: PROCEDURE;

  IF STILL$LINES THEN
   DO;
    SCAN$P = START$OF$RECORD + LINE$COL;  /* POINT TO LINE NUMBER */
    INDEX = (LOW$INDEX := DECIN);         /* INDEX = FIRST LINE NUMBER */
    LIN$BASE = NAMES$TOP - (2*LOW$INDEX); /* LINBASE SET SO INDEX AFTER NAMESTOP */
    CALL GET$LINE$OFFSET;
     DO WHILE STILL$LINES;
      SCAN$P = START$OF$RECORD + LINE$COL; /* POINT TO LINE NUMBER */
      OLD$INDEX = INDEX;
      INDEX = DECIN;
       DO WHILE OLD$INDEX < INDEX - 1;
        OLD$INDEX = OLD$INDEX + 1;
        LIN(OLD$INDEX) = 0;
       END;
      CALL GET$LINE$OFFSET;
     END;
    LINES$TOP = .LIN(INDEX+2);
    LINES$TOP$BYTE(0FFFFH) = 0AH;
   END;
  ELSE /* NO LINE RECORDS FOUND */
   DO;
    ASSEMBLY$LANGUAGE = TRUE;
    LOW$INDEX = 0FFFFH;
    LINES$TOP = NAMES$TOP;
   END;
END;

$EJECT

PROCESS$LOCATE$FILE: PROCEDURE;
  DECLARE I BYTE;

  CALL SET$SC(.MEMORY);
  CALL READ(.MEMORY);                 /* READ IN LOCATE LISTING INTO MEMORY */
  IF SCAN$MATCH (.(FF, 'ISIS-II', 0)) THEN /* FILE OUTPUT BY CROSS LOC86 */
   DO;
    CALL FMOVE(MOD$NAME$LENGTH, .MOD$NAME, .TARGET);
    TARLEN = MOD$NAME$LENGTH + 1;
    CALL FMOVE(3, .(':  '),.TARGET(MOD$NAME$LENGTH));
    LINES$IN$HEADER = 1;
    OFFSET$COL = 7;
    TYPE$COL = 14;
    SYMBOL$COL = 19;
   END;
  ELSE /* FILE OUTPUT BY RESIDENT LINK86 OR LOC86 */
   DO;
    TARLEN = MOD$NAME$LENGTH + 4;
    CALL FMOVE(2, .('= '), .TARGET);
    CALL FMOVE(MOD$NAME$LENGTH, .MOD$NAME, .TARGET(2));
    CALL FMOVE(2, .(CR,LF), .TARGET(MOD$NAME$LENGTH+2));
   END;
   DO WHILE NOT SFOUND;
    IF READ$NOT$FINISHED THEN
     DO;
      CALL FMOVE(TARLEN,GIVEUP-TARLEN,.MEMORY);
      CALL READ(.MEMORY+TARLEN);
     END;
    ELSE
     DO;
      CALL ERROR$MESSAGE STR 'MOD NAME NOT FOUND' NUL;
      CALL EX;
     END;
   END;
  DO I = 1 TO LINES$IN$HEADER;  /* POINT TO FIRST RECORD */
    CALL SCAN$UNTIL(.TERMCH);
    SCAN$P = SCAN$P + 2;
  END;
  START$OF$RECORD = SCAN$P;
  CALL CHECK$GIVEUP;
  CALL COLLECT$SYMBOL$NAMES;
  CALL COLLECT$LINE$NUMBERS;
END;

$EJECT

OUT$SYM$NAME: PROCEDURE;
  DECLARE BASE$TYPE BYTE;

  CALL SET$OB(OBUF$P);
  SCAN$P = OUT$ADDR(PTR$INDEX) - 1;
  BASE$TYPE = SCAN$BYTE AND 0000$0011B;
  SCAN$P = SCAN$P + 1;
  DO CASE BASE$TYPE;  /* OUTPUT BASE */

    /* CASE 0: GROUP INDEX */
    DO;
      CALL OUT$PRINT (.('G=',0));
      CALL OHEXB(SCAN$BYTE);
      CALL OUT$BLANK;
    END;

    /* CASE 1: SEGMENT INDEX */
    DO;
      CALL OUT$PRINT (.('S=',0));
      CALL OHEXB(SCAN$BYTE);
      CALL OUT$BLANK;
    END;

    /* CASE 2: STACK SYMBOL */
    DO;
      CALL OUT$PRINT(.('STAK ',0));
    END;

    /* CASE 3: ABSOLUTE BASE */
    DO;
      CALL OHEXW(SCAN$ADDR);            /* OUTPUT BASE ADDRESS */
      CALL OUT$BLANK;
    END;
  END; /* DO CASE */
  SCAN$P = SCAN$P + 2;              /* SKIP BASE ADDRESS */
  CALL OHEXW(SCAN$ADDR);            /* OUTPUT OFFSET ADDRESS */
  SCAN$P = SCAN$P +2;               /* SKIP OFFSET ADDRESS */
  CALL OUT$BLANK;
  CALL OUT$SCAN$STRING;
END;

OUTPUT$SYMBOLS: PROCEDURE;
  CALL FILL(15000,NAMES$TOP,' ');
  SYM$MAX = SYM$MAX + 14;
  COL$MAX = 128 / SYM$MAX;
  COL$LENGTH = MAX (60, SYM$COUNT/COL$MAX + 1);
  COL$LENGTH = MIN (COL$LENGTH,SYM$COUNT);
  OBUF$P = NAMES$TOP;
  CALL OUT$CHAR(0);
  CALL OUT$CHAR(SEPARATOR);
  CALL OUT$PRINT(.ARROW);
  CALL OUT$WRITE(.CLOSE$ARROW,4);
  CALL OUT$CRLF;
  I = COL$LENGTH;
   DO WHILE I > 0;
    PTR$INDEX = SYM$COUNT + (I := I - 1);
    OBUF$P = OBUF$P + 4;
     DO WHILE PTR$INDEX >= COL$LENGTH;
      PTR$INDEX = PTR$INDEX - COL$LENGTH;
      CALL OUT$SYM$NAME;
      OBUF$P = OBUF$P + SYM$MAX;
     END;
    CALL OUT$CRLF;
   END;
  CALL OUT$CRLF;
  CALL WRITEU(NAMES$TOP,OBUF$P - NAMES$TOP);
END;

$EJECT

SCAN$BACK: PROCEDURE (CHAR);
  DECLARE CHAR BYTE;
   DO WHILE SCAN$BYTE <> CHAR;
    SCAN$P = SCAN$P - 1;
   END;
END;

READ$MOD$NAME: PROCEDURE;
  IF ASSEMBLY$LANGUAGE THEN RETURN;
  TARLEN = 3;
  CALL FMOVE(3,.('DO;'),.TARGET);
  IF NOT SFOUND THEN
   DO;
    TARGADDR = 'od';
    IF NOT SFOUND THEN RETURN;
   END;
  CALL SCAN$BACK(':');
  CALL SCAN$BACK(0AH);
  SCAN$P = SCAN$P + 12;
  CALL SET$OB(.MOD$NAME);
   DO WHILE SCAN$BYTE <> ':';
    IF TOKNCH THEN CALL OUT$SCAN$BYTE;
    ELSE SCAN$P = SCAN$P + 1;
   END;
  CALL OUT$CHAR(0);
END;

$EJECT

/* MAIN LINE CODE */

FATAL = TRUE;
CALL CONSOLE$IN;
CALL PRINT$CR(.SIGN$ON$MSG);
CALL OPEN$SCAN(.OPENI);                  /* OPEN LOCATE LISTING FILE */
FILE$NAME$LIMIT = 31;
CALL MOVE$PARENS$FILE$NAME(.MOD$NAME);   /* GET MODNAME FOR (MODNAME) */
MOD$NAME$LENGTH = LEN$STR$NUL(.MOD$NAME);
I = SCAN$MATCH STR 'IN' NUL;
CALL SCAN$EXPECT STR 'TO' NUL;           /* SCAN FOR 'INTO' IN COMMAND LINE */
CALL PROCESS$LOCATE$FILE;
CALL OPEN$SCAN(.OPENU);                  /* OPEN PLM80 LIST FILE */
 DO WHILE NOT TERM$CH;                   /* SCAN FOR ANY OPTIONS */
  IF FORCUP = 'N' THEN SORTING = FALSE;
  IF FORCUP = 'L' THEN SEPARATOR = 0AH;
  CALL BUMP$SCAN$P;
 END;
CAPACITY$BYTES = OUT$P - LINES$TOP - 4;
OLD$SYMTAB$SEEN = FALSE;
SCAN$P = LINES$TOP;
ACTUAL = 0;
CALL FLUSH;
CALL READ$MOD$NAME;
TARLEN = 1;
TARGET(0) = 0AH;
SCAN$P = SCAN$P + 3;
 DO WHILE NEXT$LINE$NUMBER$FOUND;
  CALL OUTLIN(DECIN);
  CALL OUT$BLANK;
  SCAN$P = SCAN$P + 6;
 END;
SCAN$P = GIVE$UP;
CALL FLUSH;
SCAN$P = GIVE$UP;  /* do again for big symbol table listings */
CALL FLUSH;
IF SORTING THEN CALL SORT(OUT$P,SYM$COUNT,.BLTSYM);
CALL OUTPUT$SYMBOLS;
CALL EX;

END;
src/mfiler.plm
$TITLE('==>  M F I L E R  <==  MRKOBJ')

FILERR: DO;

/************************************************************************/
/*																		*/
/*     'Copyright 1981,1983 Intel Corporation'.  All rights reserved.	*/
/*      No part of this program or publication may be reproduced,		*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/


/*******  EXTERNALS  *******/

/* FNAMES.LIB */

out$file$name: PROCEDURE (ptr) EXTERNAL; DECLARE ptr ADDRESS; END;

/*  UTIL.LIB  */

DECLARE obuf$p ADDRESS EXTERNAL;
DECLARE scan$p ADDRESS EXTERNAL;
error$message: PROCEDURE (ptr) EXTERNAL; DECLARE ptr ADDRESS; END;
out$blank: PROCEDURE EXTERNAL; END;
out$char: PROCEDURE (char) EXTERNAL; DECLARE char BYTE; END;
out$print: PROCEDURE (ptr) EXTERNAL; DECLARE ptr ADDRESS; END;

/*******  END OF EXTERNALS  *******/



/* file$error$msg is just like file$error$message in fnames.lib
   file$error$message has a bug in it: it doesn't put a null at
   the end of the string it builds for the call to error$message.
   so you tend to get garbage characters printed at the end of the
   string.
*/
file$error$msg: PROCEDURE (msg$ptr, file$name$ptr) PUBLIC;
  DECLARE (msg$ptr, file$name$ptr) ADDRESS;

  /* use free memory for building string,
     since we're going to exit anyways   */

  obuf$p = .memory;
  CALL out$file$name (file$name$ptr);
  CALL out$blank;
  CALL out$print (msg$ptr);
  CALL out$char (0);
  CALL error$message (.memory);
END file$error$msg;


/*  movem just calls the builtin MOVE procedure
    it is used because a call to MOVE turns off the optimize flag
*/
movem: PROCEDURE (count) PUBLIC;
  DECLARE count ADDRESS;

  /* movem always called with source = scan$p & destination = .memory */

  CALL move (count, scan$p, .memory);
END movem;

END;
src/minvok.plm
$TITLE('==>  M I N V O K  <==  MRKOBJ')

INVOK: DO;

/************************************************************************/
/*																		*/
/*     'Copyright 1981,1983 Intel Corporation'.  All rights reserved.	*/
/*      No part of this program or publication may be reproduced,		*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/


/*******  EXTERNALS *******/

/* FNAMES.LIB */

open$scan: PROCEDURE (proc$addr) EXTERNAL; DECLARE proc$addr ADDRESS; END;

/*  UTIL.LIB  */

DECLARE scan$p ADDRESS EXTERNAL;
console$in: PROCEDURE EXTERNAL; END;
error$message: PROCEDURE (ptr) EXTERNAL; DECLARE ptr ADDRESS; END;
file$ch: PROCEDURE BYTE EXTERNAL; END;
scan$match: PROCEDURE (ptr) BYTE EXTERNAL; DECLARE ptr ADDRESS; END;
scan$while: PROCEDURE (proc$addr) EXTERNAL; DECLARE proc$addr ADDRESS; END;
scan$while$blanks: PROCEDURE EXTERNAL; END;

/*  SYS.LIB   */

DECLARE report BYTE EXTERNAL;
DECLARE fatal  BYTE EXTERNAL;
isis$cl: PROCEDURE (proc$code,block$ptr) EXTERNAL;
  DECLARE proc$code BYTE, block$ptr ADDRESS; END;
open$u: PROCEDURE (file$name$ptr) EXTERNAL;
  DECLARE file$name$ptr ADDRESS; END;

/* MFILER.P80 */

file$error$msg: PROCEDURE (msg$ptr, file$name$ptr) EXTERNAL;
  DECLARE (msg$ptr, file$name$ptr) ADDRESS; END;

/*******  END OF EXTERNALS  *******/

DECLARE spath$code LITERALLY '14',
        TRUE       LITERALLY '0FFH',
        FALSE      LITERALLY '0';

DECLARE spath$file$info (12) BYTE,
        spath$status         ADDRESS,
        spath$block STRUCTURE (
         file$name$ptr ADDRESS,
         file$info$ptr ADDRESS,
         status$ptr    ADDRESS) INITIAL (0, .spath$file$info, .spath$status),
        temp                  BYTE;

DECLARE source$file$name$ptr ADDRESS PUBLIC AT (.spath$block.file$name$ptr);
DECLARE object$file$name$ptr ADDRESS PUBLIC;
DECLARE nopurge BYTE PUBLIC;


process$invocation$line: PROCEDURE PUBLIC;

  fatal,          /* all ISIS errors are fatal */
  report = TRUE;  /* automatic error reporting */

  CALL console$in;  /* read rest of line, set scan$p at the beginning */
  CALL scan$while$blanks;

  /* now should be pointing at the object file name */

  object$file$name$ptr = scan$p;
  CALL scan$while (.file$ch);  /* past object file name, will open it later */
  CALL scan$while$blanks;

  IF NOT scan$match (.('WITH',0)) THEN
    CALL error$message (.('SCAN ERROR, "WITH" EXPECTED',0));
  CALL scan$while$blanks;

  /* should now be pointing at source file name
     use SPATH to validate file name            */

  spath$block.file$name$ptr = scan$p;
  CALL isis$cl (spath$code, .spath$block);
  IF spath$status <> 0 THEN
    CALL file$error$msg (.('IS A BAD SOURCE FILE NAME',0),
                         source$file$name$ptr);

  /* now test for np (no purge) option */
	
  CALL scan$while (.file$ch);  /* past source file name */
  CALL scan$while$blanks;
  nopurge = scan$match(.('NP',0)) OR scan$match(.('NOPURGE',0));

  /* ignore rest of line, if any */
  /* invocation line OK, open object file for update */

  scan$p = object$file$name$ptr;
  CALL open$scan (.open$u);

END process$invocation$line;

END;
src/mrkobj.plm
$TITLE('==>  M R K O B J  <==  MRKOBJ')

MRKOBJ: DO;

/************************************************************************/
/*																		*/
/*     'Copyright 1981,1983 Intel Corporation'.  All rights reserved.	*/
/*      No part of this program or publication may be reproduced,		*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

$IF XVERSION
DECLARE PROPRIETARY(*) BYTE DATA ('INTEL PROPRIETARY SOFTWARE');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=X103',0);
$ELSE
DECLARE COPYRIGHT (*) BYTE DATA  ('COPYRIGHT 1981,1983 INTEL ');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.1',0);
$ENDIF



/*******  EXTERNALS  *******/

/*  SYS.LIB  */

DECLARE actual ADDRESS EXTERNAL;
ex: PROCEDURE EXTERNAL; END;
readu: PROCEDURE (dst,count) EXTERNAL; DECLARE (dst,count) ADDRESS; END;
sbyteu: PROCEDURE (distance) EXTERNAL; DECLARE distance ADDRESS; END;
writeu: PROCEDURE (src,count) EXTERNAL; DECLARE (src,count) ADDRESS; END;

/* UTIL.LIB  */

DECLARE scan$p ADDRESS EXTERNAL;
DECLARE obuf$p ADDRESS EXTERNAL;
error$message: PROCEDURE (ptr) EXTERNAL; DECLARE ptr ADDRESS; END;
file$ch: PROCEDURE BYTE EXTERNAL; END;
out$scan$byte: PROCEDURE EXTERNAL; END;

/* MINVOK.P80 */

process$invocation$line: PROCEDURE EXTERNAL; END;
DECLARE source$file$name$ptr ADDRESS EXTERNAL;
DECLARE object$file$name$ptr ADDRESS EXTERNAL;
DECLARE nopurge BYTE EXTERNAL;

/* MFILER.P80 */

file$error$msg: PROCEDURE (msg$ptr, file$name$ptr) EXTERNAL;
  DECLARE (msg$ptr, file$name$ptr) ADDRESS; END;
movem: PROCEDURE (count) EXTERNAL; DECLARE count ADDRESS; END;

/*******  END OF EXTERNALS  *******/

DECLARE scan$byte BASED scan$p BYTE,
        scan$word BASED scan$p ADDRESS,
        obuf$byte BASED obuf$p BYTE;

DECLARE end$of$filled$buffer ADDRESS,
        mod$end$rec$type     BYTE,
        mod$end$record$ptr   ADDRESS,
        record$length        ADDRESS,
        bytes$to$rewrite     ADDRESS,
        crec$begin           ADDRESS,
        crec$length$ptr      ADDRESS,
        crec$length BASED crec$length$ptr ADDRESS,
        check$sum            BYTE INITIAL (0),
        first$buffer$byte    BYTE AT (.memory) INITIAL (0);

DECLARE segid$8080$record STRUCTURE (
         type     BYTE,
         r$length ADDRESS,
         segid    BYTE,
         offset   ADDRESS,
         line$no  ADDRESS,
         checksum BYTE ) INITIAL (008H,6,0,0,0,0F2H);

DECLARE crec$8080 (31) BYTE INITIAL
       (10H,0,0,0,'SOURCE_FILE=              ',0),
        crec$8086 (32) BYTE INITIAL
  (88H,0,0,0FFH,0,'SOURCE_FILE=              ',0);

DECLARE crec$8080$name$length BYTE AT (.crec$8080(3));


DECLARE library$msg (*) BYTE INITIAL ('IS AN 808X LIBRARY',0),
        library$msg$type BYTE AT (.library$msg(9));
DECLARE not$obj$msg (*) BYTE INITIAL ('IS NOT AN OBJECT MODULE',0);

its$a$library: PROCEDURE (type);
  DECLARE type BYTE;

  library$msg$type = type;
  CALL file$error$msg (.library$msg, object$file$name$ptr);
  CALL ex;
END its$a$library;


its$not$an$object$module: PROCEDURE;

  CALL file$error$msg (.not$obj$msg, object$file$name$ptr);
  CALL ex;
END its$not$an$object$module;



scan$whole$file: PROCEDURE;
  DECLARE new$scan$p ADDRESS;
  /* the whole file is in the buffer,
     just scan until modend record found */

  DO WHILE scan$byte <> mod$end$rec$type;
    scan$p = scan$p + 1;
    record$length = scan$word;
    /* check for possibility of missing modend record! */
    new$scan$p = scan$p + record$length + 2;
    IF (new$scan$p >= end$of$filled$buffer)  /* but still less than 64K */
     OR (new$scan$p < scan$p) THEN  /* wrapped around 64K */
      CALL error$message (.('MISSING MODEND RECORD?!',0));
    scan$p = new$scan$p;
  END;
END scan$whole$file;


scan$and$buffer$file: PROCEDURE;
  DECLARE three$bytes$left$ptr ADDRESS,
          bytes$to$move        ADDRESS,
          bytes$left$in$buffer ADDRESS,
          too$much$file        ADDRESS;

  /* can't fit whole object file into buffer,
     must handle scanning to end of buffer, etc. */

  three$bytes$left$ptr = end$of$filled$buffer - 3;
  DO WHILE scan$byte <> mod$end$rec$type;
    IF scan$p >= three$bytes$left$ptr THEN  /* length field may not be here */
      DO;
        IF scan$p >= end$of$filled$buffer THEN  /* went too far, abort */
          DO;
            CALL error$message (.('UNABLE TO SCAN OBJECT FILE',0));
            CALL ex;
          END;
        /* OK here, move unscanned bytes to beginning and read again */
        bytes$to$move = end$of$filled$buffer - scan$p;
        CALL movem (bytes$to$move);
        CALL readu (.memory + bytes$to$move, 7000H);
        scan$p = .memory;
        end$of$filled$buffer = .memory + bytes$to$move + actual;
        IF actual < 7000H THEN  /* all the rest of the file is in the buffer */
          DO;
            CALL scan$whole$file;  /* do it the easy way */
            RETURN;
          END;
        three$bytes$left$ptr = end$of$filled$buffer - 3;
      END;
    /* now OK to look at the record length */
    scan$p = scan$p + 1;
    record$length = scan$word;
    scan$p = scan$p + 2;  /* bump past record field */
    /* record$length bytes may not have been read yet */
    bytes$left$in$buffer = end$of$filled$buffer - scan$p;
    DO WHILE bytes$left$in$buffer <= record$length;
      CALL readu (.memory, 7000H);
      scan$p = .memory;
      end$of$filled$buffer = .memory + actual;
      record$length = record$length - bytes$left$in$buffer;
      IF actual < 7000H THEN
        DO;
          scan$p = scan$p + record$length;
          CALL scan$whole$file;
          RETURN;
        END;
      bytes$left$in$buffer = actual;
      three$bytes$left$ptr = end$of$filled$buffer - 3;
    END;
    /* whatever's left of this record is in the buffer now */
    scan$p = scan$p + record$length;
    /* now pointing at next record type byte */
  END;  /* WHILE scan$byte <> mod$end$rec$type */
  /* now we've found the modend record, but there's still more to read */
  bytes$to$move = end$of$filled$buffer - scan$p;
  CALL movem (bytes$to$move);
  /* this is the last read, if it doesn't all fit, give up */
  too$much$file = 7000H - bytes$to$move + 1;
  CALL readu (.memory + bytes$to$move, too$much$file);
  IF actual = too$much$file THEN
    CALL error$message (.('CANNOT MARK OBJECT MODULE SEQUENCE',0));
  scan$p = .memory;
  end$of$filled$buffer = .memory + bytes$to$move + actual;
END scan$and$buffer$file;


/***************    MAINLINE CODE    ***************/

  CALL process$invocation$line;
  /* now object file has been opened for update */
  /* read the first byte to check for valid file */

  CALL readu (.memory, 1);
  IF first$buffer$byte = 002H THEN  /* 8080 module */
    mod$end$rec$type = 004H;
  ELSE IF first$buffer$byte = 080H THEN  /* 8086 translator module */
    mod$end$rec$type = 08AH;
  ELSE IF first$buffer$byte = 082H THEN  /* 8086 linker module */
    mod$end$rec$type = 08AH;
  ELSE IF first$buffer$byte = 06EH THEN  /* 8086 locater module */
    mod$end$rec$type = 08AH;
  ELSE IF first$buffer$byte = 02CH THEN  /* 8080 library */
    CALL its$a$library('0');
  ELSE IF first$buffer$byte = 0A4H THEN  /* 8086 library */
    CALL its$a$library('6');
  ELSE CALL its$not$an$object$module;

  /* OK to mark this object file, read it in */
  CALL readu (.memory + 1, 7000H);  /* 28K read */
  scan$p = .memory;
  end$of$filled$buffer = .memory + actual + 1;  /* points after last byte */
  IF actual < 7000H THEN  /* the whole file fit into the buffer */
    CALL scan$whole$file;
  ELSE  /* there's still more to read */
    CALL scan$and$buffer$file;

  /* now pointing at modend record */
  bytes$to$rewrite = end$of$filled$buffer - scan$p;
  mod$end$record$ptr = scan$p;
  
  /* seek backwards */
  CALL sbyteu (-bytes$to$rewrite);

  /* build comment record */
  IF nopurge THEN /* make 8086 comment record unpurgeable */
    crec$8086(4)=080H;
  IF mod$end$rec$type = 004H THEN  /* 8080 */
    DO;
      crec$length$ptr = (crec$begin := .crec$8080) + 1;
      obuf$p = .crec$8080(16);      /* source file name area */
    END;
  ELSE  /* 8086 */
    DO;
      crec$length$ptr = (crec$begin := .crec$8086) + 1;
      obuf$p = .crec$8086(17);
    END;
  scan$p = source$file$name$ptr;
  DO WHILE file$ch;
    CALL out$scan$byte;  /* put source file name into comment record */
  END;
  crec$length = obuf$p - crec$length$ptr - 1;  /* set record length */
  IF mod$end$rec$type = 004H THEN  /* set name length byte in 8080 record */
    crec$8080$name$length = crec$length - 2;
  /* now calculate checksum */
  scan$p = crec$begin;
  DO WHILE scan$p < obuf$p;
    check$sum = check$sum + scan$byte;
    scan$p = scan$p + 1;
  END;
  obuf$byte = 256 - check$sum;

  /* write the comment record and the rest of the object file */
  CALL writeu (crec$begin, crec$length + 3);
  IF mod$end$rec$type = 004H THEN  /* write dummy segid record for 8080 */
    CALL writeu (.segid$8080$record, 9);
  CALL writeu (mod$end$record$ptr, bytes$to$rewrite);

  CALL ex;

END;
src/note.plm
NOTE$MOD: DO;

/************************************************************************/
/*																		*/
/*     'Copyright 1981,1983 Intel Corporation'.  All rights reserved.	*/
/*      No part of this program or publication may be reproduced,		*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

$IF XVERSION
DECLARE PROPRIETARY(*) BYTE DATA ('INTEL PROPRIETARY SOFTWARE');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=X103',0);
$ELSE
DECLARE COPYRIGHT (*) BYTE DATA  ('COPYRIGHT 1981,1983 INTEL ');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.1',0);
$ENDIF


DECLARE	LIT		LITERALLY	'LITERALLY',
		DCL		LIT	'DECLARE',
		TRUE	LIT	'0FFH',
		FALSE	LIT	'000H',
		PROC	LIT	'PROCEDURE',
		PROCEND	LIT	'END',
		THENDO	LIT	'THEN DO;',
		ELSEIF	LIT	'END; ELSE IF',
		ELSEDO	LIT	'END; ELSE DO;',
		IFEND	LIT	'END',
		WHILEND	LIT	'END',
		CR		LIT	'0DH',
		LF		LIT	'0AH';


EXIT:	PROC EXTERNAL;											PROCEND;
READ:	PROC (A,B,C,D,E) EXTERNAL;	DCL (A,B,C,D,E) ADDRESS;	PROCEND;
WRITE:	PROC (A,B,C,D) EXTERNAL;	DCL (A,B,C,D) ADDRESS;		PROCEND;
SPATH:	PROC (A,B,C) EXTERNAL;		DCL (A,B,C) ADDRESS;		PROCEND;
WHOCON:	PROC (A,B) EXTERNAL;		DCL (A,B) ADDRESS;			PROCEND;
IOCHK:	PROC BYTE EXTERNAL;										PROCEND;
CO:		PROC (A) EXTERNAL;			DCL (A) BYTE;				PROCEND;

DCL (STATUS, ACTUAL) ADDRESS;
DCL (CMND, CMND$PTR) ADDRESS, (CMND$CH BASED CMND$PTR) (1) BYTE;
DCL (FILE) (15) BYTE;
DCL (PN) STRUCTURE
	(DEV BYTE, NAME (6) BYTE, EXT (3) BYTE, DEV$TYPE BYTE, DRIVE$TYPE BYTE);
DCL (COLD$START$CO) BYTE;

CALL READ (1, .MEMORY, 128, .ACTUAL, .STATUS); /* Get command tail. */
CMND = .MEMORY + ACTUAL;
CMND$PTR = .MEMORY;
DO WHILE CMND$PTR < CMND;
	IF CMND$CH (0) = '&' THENDO
		CMND$CH (0) = CR;
		CMND$CH (1) = LF;
		CALL WRITE (0, .('**'), 2, .STATUS);
		CALL READ (1, CMND$PTR + 2, 128, .ACTUAL, .STATUS);
		CMND = CMND$PTR + ACTUAL + 2;
	IFEND;
	CMND$PTR = CMND$PTR + 1;
WHILEND;

CALL WHOCON (0, .FILE); /* Find out what the :CO: file is. */
CALL SPATH (.FILE, .PN, .STATUS);
COLD$START$CO = IOCHK AND 3;
IF (PN.DEV = 7) AND (COLD$START$CO = 0) THENDO /* :CO: = :TO: */
ELSEIF (PN.DEV = 9) AND (COLD$START$CO = 1) THENDO /* :CO: = :VO: */
ELSEDO
	CMND$PTR = .MEMORY;
	DO WHILE CMND$PTR < CMND;
		CALL CO (CMND$CH (0));
		CMND$PTR = CMND$PTR + 1;
	WHILEND;
IFEND;
CALL EXIT;

END NOTE$MOD;
src/out.plm
OUT: DO;

/************************************************************************/
/*																		*/
/*     'Copyright 1981,1983 Intel Corporation'.  All rights reserved.	*/
/*      No part of this program or publication may be reproduced,		*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

      

/* THIS MODULE IS RESPONSIBLE FOR BUFFERING OUTPUT */

WRITE: PROCEDURE (AFT,BUF,COU,STA) EXTERNAL;
  DECLARE (AFT,BUF,COU,STA) ADDRESS;
END WRITE;

CHECK$STATUS: PROCEDURE EXTERNAL;
END CHECK$STATUS;

/* LOCAL DECLARATIONS */

DECLARE
  CR LITERALLY '0DH',    /* ASCII */
  LF LITERALLY '0AH',    /* ASCII */

  OUT$AFTN ADDRESS EXTERNAL,    /* AFTN OF LIST FILE */
  ACTUAL ADDRESS EXTERNAL,    /* RETURNED BY ISIS */
  STATUS ADDRESS EXTERNAL,    /* RETURNED BY ISIS */
  BUFFER(2048) BYTE AT(.MEMORY), /* OUTPUT BUFFER */
  CURSOR ADDRESS INITIAL(0); /* POINTER INTO BUFFER */

DUMP: PROCEDURE PUBLIC;
  IF CURSOR>0
  THEN DO;
    CALL WRITE(OUT$AFTN,.BUFFER,CURSOR,.STATUS);
    CALL CHECK$STATUS;
    CURSOR = 0;
  END;
END DUMP;

DISPLAY: PROCEDURE (LEN,ADDR) PUBLIC;

  DECLARE
    LEN BYTE,    /* LENGTH OF TEXT TO PRINT */
    ADDR ADDRESS, /* ADDRESS OF INCOMMING OUTPUT */
    CHAR BASED ADDR BYTE;

  DO WHILE LEN>0;
    IF CHAR<20H OR CHAR>7EH
    THEN IF (CHAR = 0DH)  /* CARRIAGE RETURN */ OR
            (CHAR = 0AH) /* LINE FEED */
         THEN BUFFER(CURSOR) = CHAR;
         ELSE IF CHAR = 09H /* TAB */
              THEN BUFFER(CURSOR) = ' ';
              ELSE BUFFER(CURSOR) = '?';
    ELSE BUFFER(CURSOR) = CHAR;
    CURSOR = CURSOR + 1;
    ADDR = ADDR + 1;
    LEN = LEN - 1;
    IF CURSOR = 2048 THEN CALL DUMP;
  END;

END DISPLAY;

BLANKS: PROCEDURE (LEN) PUBLIC;

  DECLARE
    LEN BYTE;    /* LENGTH OF BLANKS TO PRINT */

  DO WHILE LEN>0;
    BUFFER(CURSOR) = ' ';
    CURSOR = CURSOR + 1;
    LEN = LEN - 1;
    IF CURSOR = 2048 THEN CALL DUMP;
  END;

END BLANKS;

NEW$LINE: PROCEDURE PUBLIC;

  /* DISPLAY CRLF */

  CALL DISPLAY(2,.(CR,LF));

END NEW$LINE;

END OUT;

src/pack.plm
Pack:   DO;

/************************************************************************/
/*																		*/
/*     'Copyright 1981,1983 Intel Corporation'.  All rights reserved.	*/
/*      No part of this program or publication may be reproduced,		*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

$IF XVERSION
DECLARE PROPRIETARY(*) BYTE DATA ('INTEL PROPRIETARY SOFTWARE');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=X103',0);
$ELSE
DECLARE COPYRIGHT (*) BYTE DATA  ('COPYRIGHT 1981,1983 INTEL ');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.1',0);
$ENDIF

    


/*    This program is designed to accept ascii files and compress
      the blanks to reduce the storage costs on disks

      Blanks are compressed by converting strings of consecutive
      blanks into a single byte which has the high bit on.  This
      necessarily dictates that the system in use does not use
      the parity bit.  Strings of blanks greater than 128 are
      manipulated as multiple compression bytes.

*/

DECLARE dcl LITERALLY 'DECLARE';
DECLARE as LITERALLY 'LITERALLY';

dcl boolean as 'BYTE';
dcl end$of$file as 'actual=0';
dcl depart as '0FFH';
dcl true as '0FFH';
dcl false as '0';
dcl character as 'BYTE';
dcl pointer as 'ADDRESS';
dcl int1 as 'BYTE';
dcl int2 as 'ADDRESS';
dcl nil as '0';

dcl thenn as 'THEN DO;';
dcl elseif as 'END; ELSE IF';
dcl elsee as 'END; ELSE DO;';
dcl endif as 'END;';
dcl whilee as 'DO WHILE';
dcl endwhile as 'END;';
dcl for as 'DO';
dcl endfor as 'END;';
dcl enddo as 'END;';

dcl compress$1 as '0FFH';
dcl cr as '0DH';
dcl lf as '0AH';

/* system EXTERNALs */

open: PROCEDURE (aft,file,access,mode,status) EXTERNAL;
  DECLARE (aft,file,access,mode,status) ADDRESS; END;
close: PROCEDURE (aft,status) EXTERNAL; DECLARE (aft,status) ADDRESS; END;
read: PROCEDURE (aft,buffer,count,actual,status) EXTERNAL;
  DECLARE (aft,buffer,count,actual,status) ADDRESS; END;
write: PROCEDURE (aft,buffer,count,status) EXTERNAL;
  DECLARE (aft,buffer,count,status) ADDRESS; END;
delete: PROCEDURE (file,status) EXTERNAL; DECLARE (file,status) ADDRESS; END;
exit: PROCEDURE EXTERNAL; END;
spath: PROCEDURE(file, buffer, status) EXTERNAL;
  DECLARE (file, buffer, status) ADDRESS; END;
LOAD: PROCEDURE(FILE,BIAS,SWITCH,ENTRY,STATUS) EXTERNAL;
  DCL (FILE,BIAS,SWITCH,ENTRY,STATUS) ADDRESS; END;
GETD: PROCEDURE(DRIVE,CON,COUNT,ACTUAL$COUNT,BUFFER,STATUS) EXTERNAL;
  DCL (DRIVE,CON,COUNT,ACTUAL$COUNT,BUFFER,STATUS) ADDRESS; END;


seq: PROCEDURE (s1,s2,len) boolean EXTERNAL;
  DECLARE s1 ADDRESS; DECLARE s2 ADDRESS; DECLARE len BYTE; END;
force$upper: PROCEDURE (buffer$ptr) EXTERNAL; DECLARE buffer$ptr ADDRESS; END;
file$error: PROCEDURE (status, filename$ptr, callexit) EXTERNAL;
  DECLARE (status, filename$ptr) ADDRESS; DECLARE callexit boolean; END;
meq: PROCEDURE (search$arg, dir$entry) BYTE EXTERNAL;
  DECLARE (search$arg, dir$entry) ADDRESS; END;
wpath: PROCEDURE(pathname$ptr, pn, wc$used) BYTE EXTERNAL;
  DECLARE (pathname$ptr, pn, wc$used) ADDRESS; END;
unpath: PROCEDURE(int, ext) EXTERNAL; DECLARE (int, ext) ADDRESS; END;

packer: PROCEDURE boolean external; end;

$IF XVERSION
dcl version(4) character data('X103');
$ELSE
dcl version(4) character data('V1.1');
$ENDIF
dcl (actual,status) int2;
dcl out$aftn int2 PUBLIC;
dcl in$aftn int2 PUBLIC;
dcl command$line(122) character;
dcl command$pointer pointer;
dcl command$char based command$pointer character;
dcl delete$source boolean;
dcl default$output boolean;
dcl default$extension(3) character initial('PCK');
dcl input$file$name(16) character PUBLIC;
dcl output$file$name(16) character PUBLIC;
dcl input$name pointer PUBLIC;
dcl output$name pointer PUBLIC;
dcl in$name pointer;
dcl out$name pointer;
dcl no$error$occured boolean;

dcl directory$name(16) character initial(':F0:ISIS.DIR ');
dcl dir$aftn int2;
dcl path$name(16) character;
dcl out$path$name(16) character;
dcl max$directory$length int2;
dcl file$found boolean;
dcl wildcard$used boolean;
dcl directory$entry int2;
dcl source$disk int1;
dcl buf16(16) character;
dcl found boolean;
dcl no$such$file as '13';
dcl star$dot$PCK(16) character initial(0,'******PCK      ');

DCL reading$remote BYTE;
DCL ov0$name(16) BYTE INITIAL(':F0:ISIS.OV0 ');
DCL wasted ADDRESS;
DCL getd$drive ADDRESS;
DCL getd$conn ADDRESS;

deblank: PROCEDURE( char$ref ) pointer;
   /* scan for next non-blank */
   dcl char$ref pointer;
   dcl char BASED char$ref character;

   whilee char = ' ';
      char$ref = char$ref + 1;
   endwhile
   RETURN char$ref;
end deblank;

scan$blank: PROCEDURE( char$ref ) pointer;
   /* scan for a blank character */
   dcl char$ref pointer;
   dcl char BASED char$ref character;

   whilee char <> ' ' and char <> cr;
      char$ref = char$ref + 1;
   endwhile
   RETURN char$ref;
end scan$blank;

command$tail$error: PROCEDURE;
  CALL write(0,.command$line,command$pointer-.command$line,.status);
  CALL write(0,.('#'),1,.status);
  CALL write(0,command$pointer,actual-(command$pointer-.command$line),.status);
  CALL write(0,.('command tail error',cr,lf),20,.status);
  CALL exit;
END command$tail$error;

more$input$files: PROCEDURE boolean;
  DCL searching BYTE;
  DCL getd$actual ADDRESS;

   /****************************************************************************
    *
    * This routine sets up the global input$file$name with the next file
    * which matches the wildcard pathname and returns true.  If no
    * more matching file names are found, false is returned.
    *
    ****************************************************************************/

   searching = true;
   DO WHILE searching;
     IF reading$remote THEN
       DO;
         CALL getd(getd$drive,.getd$conn,1,.getd$actual,.buf16,.status);
         CALL file$error(status,.('GETD '),true);
         IF getd$actual = 0 THEN
           RETURN false;
         buf16(0) = 0;  /* for MEQ call */
       END;
     ELSE
       DO;
         CALL read(diraftn,.buf16,16,.actual,.status);
         CALL file$error(status, .directory$name, true);
         IF buf16(0) = 7FH or actual = 0 THEN
           RETURN false;
       END;
     searching = NOT meq(.pathname, .buf16);
   END;
   found = true;
   buf16(0) = source$disk;
   CALL move(15,.('                '),.input$filename);
   CALL unpath(.buf16, .input$file$name);
   RETURN true;
end more$input$files;

generate$default$output$filename: PROCEDURE;

   /****************************************************************************
    *
    * This procedure generates the default output$filename by changing
    * the input$filename extension to .PCK if no output filename was
    * specified.  If a name was specified (with wildcard) then the
    * appropriate replacements are made.
    *
    ****************************************************************************/

   dcl i int1;
   dcl internal$name(16) character;

   CALL move(15, .('               '), .output$filename);
   CALL move(15, .out$path$name, .internal$name);
   for i = 1 to 14;
      if out$path$name(i) = '*' or out$path$name(i) = '?' thenn
         internal$name(i) = buf16(i);
      endif
   endfor
   CALL unpath(.internal$name, .output$filename);
end generate$default$output$filename;

/*
     initialize values and open files
*/
   CALL write(0,.('ISIS-II  BLANK COMPRESSOR, '),27,.status);
   CALL write(0,.version,4,.status);
   CALL write(0,.(cr,lf),2,.status);

   CALL read(1,.command$line,LENGTH(command$line),.actual,.status);
   CALL force$upper(.command$line);
   command$pointer = deblank(.command$line);
   in$name = command$pointer;
   wildcard$used = true;
   status = wpath(in$name,.path$name,.wild$card$used);
   CALL file$error(status, in$name, true);

   output$name = .output$file$name;
   CALL move (15, .('               '), .output$filename);
   command$pointer = deblank(scan$blank(command$pointer));
   out$name = nil;
   if seq(command$pointer,.('TO '),3) thenn
      out$name, command$pointer=deblank(scan$blank(command$pointer));
      command$pointer = deblank(scan$blank(command$pointer));
      CALL move(command$pointer - out$name, out$name, .output$filename);
   endif
   default$output = true;
   if out$name <> nil thenn
      wildcard$used = true;
      status = wpath(out$name, .out$path$name, .wildcard$used);
      CALL file$error(status, out$name, true);
      if not wildcard$used thenn
         default$output = false;
      endif
   elsee
      /* generate template for :F#:*.PCK for output */
      CALL move(15, .star$dot$PCK, .out$path$name);
      out$path$name(0) = pathname(0);
   endif

   delete$source = true;
   if seq(command$pointer, .('DELETE'),6) thenn
      delete$source = true;
      command$pointer = deblank(scan$blank(command$pointer));
   elseif seq(command$pointer, .('NODELETE'),8) thenn
      delete$source = false;
      command$pointer = deblank(scan$blank(command$pointer));
   endif
   if command$char <> cr then call command$tail$error;

   /* setup wild card search */
   directory$name(2) = (source$disk := path$name(0)) + '0';
   IF path$name(0) >= 25 THEN
     directory$name(2) = directory$name(2) - 19;
   path$name(0) = 0;
   CALL spath(.directory$name, .buf16, .status);
   CALL file$error(status, .directory$name, true);
   IF buf16(10) = 3  AND  buf16(11) > 4  THEN
     DO;
       IF .MEMORY > 0E800H  THEN
         DO;
           CALL write(0,.('insufficient memory',CR,LF),21,.status);
           CALL exit;
         END;
       ELSE
         DO;
           CALL LOAD(.ov0$name,0,0,.wasted,.STATUS);
           CALL file$error(status,.ov0$name,true);
           /* set up getd call */
           getd$drive = directory$name(2) - '0';
           getd$conn = 0;
           reading$remote = true;
         END;
     END;
   ELSE
     DO;
       CALL open(.diraftn, .directory$name, 1, 0, .status);
       CALL file$error(status, .directory$name, true);
       reading$remote = false;
     END;
   found = false;

   if not default$output thenn
      CALL open(.outaftn,output$name,2,0,.status);
      CALL file$error(status,output$name,true);
   endif

   input$name = .input$filename;
   whilee more$input$files;
      no$error$occured = true;
      CALL open(.inaftn,input$name,1,0,.status);
      CALL file$error(status,input$name,false);
      if status <> 0 thenn
         no$error$occured = false;
      endif
      if default$output and no$error$occured thenn
         CALL generate$default$output$filename;
         CALL open(.outaftn,output$name,2,0,.status);
         CALL file$error(status,output$name,false);
         if status <> 0 thenn
            no$error$occured = false;
            CALL close(inaftn, .status);
            CALL file$error(status, input$name, false);
         endif
      endif
      if no$error$occured thenn
         CALL write(0,.('  '),2,.status);
         CALL write(0,input$name,15,.status);
         CALL write(0,.(' TO '),4,.status);
         CALL write(0,output$name,15,.status);
         no$error$occured = not packer;
         if no$error$occured thenn
            CALL write(0,.(' PACKED '),8,.status);
         elsee
            CALL write(0,.(' ERROR  '),8,.status);
         endif

         if default$output thenn
            CALL close(outaftn,.status);
            CALL file$error(status,output$name,false);
         endif

         CALL close(inaftn, .status);
         CALL file$error(status, input$name, false);

         if delete$source and no$error$occured thenn
            CALL delete(input$name, .status);
            CALL file$error(status, input$name, false);
            CALL write(0,.(' DELETED'),8,.status);
         endif
         CALL write(0,.(cr,lf),2,.status);

      endif
   endwhile
   IF NOT reading$remote THEN
     DO;
       CALL close(dir$aftn, .status);
       CALL file$error(status, .directory$name, true);
     END;
   if not found thenn
      CALL file$error(no$such$file, in$name, true);
   endif
   CALL exit;
end Pack;
src/packer.plm
Packer:   DO;


/************************************************************************/
/*																		*/
/*     'Copyright 1981,1983 Intel Corporation'.  All rights reserved.	*/
/*      No part of this program or publication may be reproduced,		*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

      
/*    These routines are designed to accept ascii files and compress
      the blanks to reduce the storage costs on disks

      Blanks are compressed by converting strings of consecutive
      blanks into a single byte which has the high bit on.  This
      necessarily dictates that the system in use does not use
      the parity bit.  Strings of blanks greater than 128 are
      manipulated as multiple compression bytes.

      The logical value returned is true if an error occured

*/

DECLARE dcl LITERALLY 'DECLARE';
DECLARE as LITERALLY 'LITERALLY';

dcl boolean as 'BYTE';
dcl end$of$file as 'actual=0';
dcl depart as '0FFH';
dcl true as '0FFH';
dcl false as '0';
dcl character as 'BYTE';
dcl pointer as 'ADDRESS';
dcl int1 as 'BYTE';
dcl int2 as 'ADDRESS';
dcl nil as '0';

dcl thenn as 'THEN DO;';
dcl elseif as 'END; ELSE IF';
dcl elsee as 'END; ELSE DO;';
dcl endif as 'END;';
dcl whilee as 'DO WHILE';
dcl endwhile as 'END;';
dcl enddo as 'END;';
dcl for as 'DO';
dcl endfor as 'END;';

dcl compress$1 as '0FFH';
dcl buffer$size as '16384'; /* =8*2048 */
dcl limit as 'buffer$size-1';
dcl cr as '0DH';
dcl lf as '0AH';

/* system EXTERNALs */
read: PROCEDURE (aft,buffer,count,actual,status) EXTERNAL;
  DECLARE (aft,buffer,count,actual,status) address; END;
write: PROCEDURE (aft,buffer,count,status) EXTERNAL;
  DECLARE (aft,buffer,count,status) address; END;

file$error: PROCEDURE (status, filename$ptr, callexit) EXTERNAL;
  DECLARE (status, filename$ptr) address; DECLARE callexit boolean; END;

dcl output$buffer(buffer$size) character;
dcl input$buffer(buffer$size) character;
dcl output$pointer pointer;
dcl output$character based output$pointer character;
dcl input$pointer pointer;
dcl input$character based input$pointer character;
dcl (actual,status) int2;
dcl compress boolean;
dcl compression$byte int1;
dcl i int2;
dcl input$name pointer EXTERNAL;
dcl output$name pointer EXTERNAL;
dcl out$aftn int2 EXTERNAL;
dcl in$aftn int2 EXTERNAL;

output: PROCEDURE(put$char) boolean;

/*
      This procedure accepts a character and fills a buffer.
      When the buffer is full, it is then written to the
      output file.
*/

   dcl put$char character;

   output$character = put$char;
   output$pointer = output$pointer + 1;
   if output$pointer > .output$buffer + limit thenn
      CALL write(outaftn,.output$buffer,buffer$size,.status);
      CALL file$error(status,output$name,false);
      if status <> 0 thenn
         RETURN false;
      endif
      output$pointer = .output$buffer;
   endif
   RETURN true;
END output;

flush: PROCEDURE;

/*
      This routine flushes the output buffer at the end of the file
*/

   if output$pointer = .output$buffer thenn
      RETURN;
   elsee
      CALL write(outaftn,.output$buffer,output$pointer-.output$buffer,
         .status);
      CALL file$error(status,output$name,false);
   endif
END flush;

packer: PROCEDURE boolean PUBLIC;

/*
   This procedure is responsible for compressing the blanks and
   transfering the contents of the input file
*/

   output$pointer = .output$buffer;
   input$pointer = .input$buffer;
   compress = false;

/*
        begin processing
*/

   CALL read(inaftn,.input$buffer,buffer$size,.actual,.status);
   CALL file$error(status,input$name,false);
   if status <> 0 thenn
      RETURN true;
   endif

   whilee not end$of$file;

      for i = 0 TO actual-1;

         if input$character=' ' thenn
            if not compress thenn
               compress=true;
               compression$byte=compress$1;
            elsee
               compression$byte=compression$byte-1;
               if compression$byte=80h thenn
                   /* 128 blanks */
                  if not output(080h) thenn
                     RETURN true;
                  endif
                  compression$byte=compress$1;
               endif
            endif
         elsee
            if compress thenn
               if not output(compression$byte) thenn
                  RETURN true;
               endif
               compress=false;
            endif
            if not output(input$character) thenn
               RETURN true;
            endif
         endif
         input$pointer=input$pointer+1;
      endfor

      CALL read(inaftn,.input$buffer,buffer$size,.actual,.status);
      CALL file$error(status,input$name,false);
      if status <> 0 thenn
         RETURN true;
      endif
      input$pointer=.input$buffer;
   endwhile

   CALL flush;
   RETURN false;
end packer;

end Packer;
src/passif.plm
$ TITLE ('==> PASSIF -- MAINMOD -- MAIN MODULE <==')

PASSIF:
DO;

/************************************************************************/
/*																		*/
/*     'Copyright 1981,1983 Intel Corporation'.  All rights reserved.	*/
/*      No part of this program or publication may be reproduced,		*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

$IF XVERSION
DECLARE PROPRIETARY(*) BYTE DATA ('INTEL PROPRIETARY SOFTWARE');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=X111',0);
$ELSE
DECLARE COPYRIGHT (*) BYTE DATA  ('COPYRIGHT 1981,1983 INTEL ');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.2',0);
$ENDIF


$ NOLIST

/* ISIS.INC */

CO:	PROCEDURE (CHAR$CO) EXTERNAL; DECLARE CHAR$CO BYTE;	END;
EXIT: PROCEDURE EXTERNAL; END;
WHOCON:	PROCEDURE (AFTN,BUFFER) EXTERNAL; DECLARE (AFTN,BUFFER) ADDRESS; END;

/* END ISIS.INC */

/*         LIT.INC          */

DECLARE					AS LITERALLY 'LITERALLY',
	AMPERSAND			AS '''&''',
	BELL				AS '07H',
	BLANK				AS '020H',
	BOOLEAN				AS 'BYTE',
	CHK					AS 'CALL CHECK$STATUS',
	CLEAR$CHAR			AS '01CH',
	CO$ECHO$FILE		AS '0F00H',
	COLON				AS ''':''',
	COMMA				AS '02CH',
	CONSOLE$INPUT		AS '1',
	CONSOLE$OUTPUT		AS '0',
	CONTROL$Z			AS '01AH',
	CR					AS '0DH',
	DOT					AS '''.''',
	END$DO				AS 'END',
	END$DO$CASE			AS 'END',
	END$DO$WHILE		AS 'END',
	END$IF				AS '   ',
	END$ITERATED$DO		AS 'END',
	END$LOOP			AS ' ',
	EOF$CHAR			AS 'CONTROL$Z',
	ESC					AS '01BH',
	FALSE				AS '0H',
	FF					AS '0CH',
	FOREVER				AS 'WHILE 1',
	FORMAT$ATTRIBUTE	AS '3',
	HASH$MARK			AS '''#''',
	INIT$STG			AS '(*) BYTE INITIAL',
	LEAD$IN$CHAR		AS '07EH',
	LF					AS '0AH',
	NO$LINE$EDIT		AS '0',
	NULL				AS '0FFFFH',
	OPEN$FOR$READ		AS '1',
	OPEN$FOR$WRITE		AS '2',
	OPEN$FOR$UPDATE		AS '3',
	PUB$STRING			AS '(*) BYTE PUBLIC DATA',
	RESET				AS '0',
	RETURN$MARKER$POS	AS '0',
	SEEK$2$EOF			AS '4',
	SEEK$BACKWARD$BY$N	AS '1',
	SEEK$FORWARD$BY$N	AS '3',
	SEEK$2$N			AS '2',
	SEMICOLON			AS ''';''',
	SET					AS '1',
	STRING				AS '(*) BYTE DATA',
	TAB					AS '09H',
	TRANSFER$CONTROL	AS '1',
	TRUE				AS '0FFH',
	UNDERBAR			AS '''_''',
	USER$CI				AS '0',
	WRITE$PROTECT$ATTRIBUTE 		AS '2',
	ZERO$BIAS			AS '0';

/*        ENDLIT.INC        */

$ LIST

DECLARE
    ACTUAL ADDRESS PUBLIC,
    AFTN ADDRESS PUBLIC,

    BLOCK$NO ADDRESS INITIAL (0),
    BYTE$NO ADDRESS  INITIAL (0),

    CI$BUF (130) BYTE,
    CHAR$PTR ADDRESS INITIAL (.CI$BUF),
    CHAR BASED CHAR$PTR BYTE,

    STATUS ADDRESS PUBLIC INITIAL (0) ;

	DECLARE
		FILE$INFORMATION STRUCTURE
           (DEVICE$NUMBER				BYTE,
            FILE$NAME 			(6)		BYTE,
            EXTENSION			(3)		BYTE,
            DEVICE$TYPE					BYTE,
            DRIVE$TYPE			(11)	BYTE);

$ NOLIST

/************************************************************/
/*															*/
/*              LITERALLY'S UNIQUE TO PASSIF                */
/*															*/
/************************************************************/

DECLARE
    MINIMUM$ACCEPTABLE$BANNER$LENGTH 	AS 		'73',
    MAXIMUM$TOKEN$LENGTH				AS		'70',
    BI									AS		'CALL BOMB$IF(STATUS)',

	FIRST$FIELD							AS		'0',
    SECOND$FIELD						AS		'28',
    THIRD$FIELD							AS		'54',

    RIGHT$PARENTHESIS 					AS		''')''',
    LEFT$PARENTHESIS 					AS		'''(''',
    RI									AS		'CALL REPORT$IF',
    UNRECOGNIZED$SWITCH$ERR 			AS		'201',
    QUESTION$MARK						AS		'''?''';


/*	CLI.INC  */

INTERPRET$COMMAND$LINE:	PROCEDURE EXTERNAL;	END;

/*	END CLI.INC  */

/*	ERRMSG.INC  */

DECLARE
	BAD$SYNTAX$MSG 				(29) BYTE EXTERNAL,
	BOMB$IF$MSG$1    			(12) BYTE EXTERNAL,
	BOMB$IF$MSG$2				(40) BYTE EXTERNAL,
    DURING$ASSERTION$CHECK$MSG	(50) BYTE EXTERNAL,
    PASSIF$INVOKED$BY$MSG       (19) BYTE EXTERNAL,
    ZERO$LENGTH$FILE$MSG 		(40) BYTE EXTERNAL;

/*	END ERRMSG.INC  */

/*	FUNC.INC  */

FILE$EXISTS: PROCEDURE EXTERNAL; END;
FILE$ABSENT: PROCEDURE EXTERNAL; END;
FILES$MATCH: PROCEDURE EXTERNAL; END;
STRING$FOUND: PROCEDURE EXTERNAL; END;
STRING$ABSENT: PROCEDURE EXTERNAL; END;

/*	END FUNC.INC  */

$ LIST

$ EJECT

/************************************************************/
/*															*/
/*                        NOTES                             */
/*															*/
/************************************************************/

/*

1.	Limitation of 250 characters in command tail.

2.  Calls to the "report assertion" procedures do not return (i.e., an exit
    call is therein encountered), since reporting the success or failure of an
    assertion is the ultimate goal to which a procedure can aspire.

3.	Some "initialized global variables" are declared just above the procedures
    in which they are used, not in the area "assigned" to them.  This is done
    in situations where the variables would have been declared locally, within
    said procedure, except that the plm80 language allows initialization only
    of identifiers declared at module level.

4.	CONVENTION ON BUFFER POINTERS -- The pointer to the bottom of a buffer
	points to the first byte used.  The pointer to the top of a buffer
	points to the last byte used.  This is a symmetrical situation, pleasing
	to the psyche of Western man.

5.  Passif's reaction to the Isis Errors it may encounter depends on where the
    error is detected, because some such errors may legitmately encountered
    during normal processing of assertion checking, but some may occur during
    Passif's own processing.  The legimate errors must be reported in the
    report file, but when Passif detects an error during its processing, it
    must exit.

	Passif can Isis report errors encountered in processing assertions, in
	its report file.  It has to bomb only when Isis errors are encountered
	in the process of updating the report file.

6.	If Passif needs a workfile, the workfile will be on the same disk as
	the report file, and will have name "passif.tmp".  This device will not
	be write-protected since the report file is there.

7.	Initializing, and/or re-initializing the report file is one of the
	trickier sections of Passif.

8.	The procedure exit$routine is used so that the updated banner can be
	printed out as the last Passif function before it exits.

9.	If any of the numbers in the report file reach 64k, then they stay at
	64k.

10.	I/O for the various searches and compares is buffered, but the i/o for
	"error entries" is not.

*/

$ EJECT

/************************************************************/
/*															*/
/*     UNINITIALIZED        GLOBAL           VARIABLES      */
/*															*/
/************************************************************/

DECLARE DELIMITER BYTE PUBLIC;
DECLARE TOK$BUF (80) BYTE PUBLIC;
DECLARE COMMAND$TAIL$BUF (250) BYTE PUBLIC;

DECLARE FIRST$BLOCK$BUF (128) BYTE PUBLIC;
DECLARE REPORT$FILE$AFTN ADDRESS PUBLIC;
DECLARE REPORT$FILE$ACTUAL ADDRESS PUBLIC;

DECLARE TMP$FILE$AFTN ADDRESS PUBLIC;
$ EJECT

/************************************************************/
/*															*/
/*       INITIALIZED        GLOBAL           VARIABLES      */
/*															*/
/************************************************************/

DECLARE FIRST$TIME$THROUGH BOOLEAN PUBLIC INITIAL (TRUE);

DECLARE FIRST$OUTPUT$MSG$PTR ADDRESS PUBLIC INITIAL (NULL);
DECLARE SECOND$OUTPUT$MSG$PTR ADDRESS PUBLIC INITIAL (NULL);

DECLARE PRINT$HASH$MARK BOOLEAN PUBLIC INITIAL (FALSE);

DECLARE ILLEGAL$COMMAND$LINE$CHAR$ERR BOOLEAN PUBLIC INITIAL (FALSE);

DECLARE TMP$FILE$NAME PUB$STRING (':F0:PASSIF.TMP ');

DECLARE REPORT$FILE STRING
	('REPORT_FILE=:F1:REPORT.LOG ');
/*    012345678901234567890123456        */
/*    0         1         2              */


/************************************************************/
/*															*/
/*        IRREVOCABLY INITIALIZED GLOBAL VARIABLES          */
/*															*/
/************************************************************/

DECLARE REPORT$FILE$STRING$BEGINNING ADDRESS PUBLIC DATA (.REPORT$FILE(12));

DECLARE INITIALIZED$BANNER PUB$STRING
                                       (

'00000 TESTS EXECUTED        00000 TESTS PASSED        00000 TESTS FAILED'

                                    ,CR,LF);


/************************************************************/
/*															*/
/*           KEYWORD              TABLE                     */
/*															*/
/************************************************************/

DECLARE KEY$WORDS (10) STRUCTURE
   (LENGTH							BYTE,
    KEY$WORD	(13)				BYTE,
	PROC$PTR						ADDRESS) PUBLIC DATA

/*               1234567890123                         */
    (11,		'FILE_EXISTS  '		,.FILE$EXISTS,
     11,		'FILE_ABSENT  '		,.FILE$ABSENT,
     11,		'FILES_MATCH  '		,.FILES$MATCH,

/*               1234567890123                         */
     12,		'STRING_FOUND '		,.STRING$FOUND,

/*               1234567890123                         */
     13,		'STRING_ABSENT'		,.STRING$ABSENT,

     02,		'FE           '		,.FILE$EXISTS,
     02,		'FA           '		,.FILE$ABSENT,
     02,		'FM           '		,.FILES$MATCH,
     02,		'SF           '		,.STRING$FOUND,
     02,		'SA           '		,.STRING$ABSENT);


/************************************************************/
/*															*/
/*                  EXTERNAL PROCEDURES                     */
/*															*/
/************************************************************/

FMOVE: PROCEDURE (COUNT,SOURCE$PTR,DEST$PTR) EXTERNAL;
	DECLARE (COUNT,SOURCE$PTR,DEST$PTR) ADDRESS; END;


/************************************************************/
/*															*/
/*           LOCAL              PROCEDURES                  */
/*															*/
/************************************************************/

MOVE:
	PROCEDURE (COUNT,SOURCE$PTR,DEST$PTR) PUBLIC;
	DECLARE (COUNT,SOURCE$PTR,DEST$PTR) ADDRESS;
    IF COUNT<>0 THEN
    	CALL FMOVE(COUNT,SOURCE$PTR,DEST$PTR);
    ENDIF
	END
MOVE;

RE$POSITION$CURSOR:
	PROCEDURE PUBLIC;
	CALL CO(CR);
	END
RE$POSITION$CURSOR;

CO$IS$VO:
	PROCEDURE BOOLEAN PUBLIC;
	DECLARE WHO$CON$BUF (15) BYTE;
	CALL WHO$CON(CONSOLE$OUTPUT,.WHO$CON$BUF);
	IF
		WHO$CON$BUF(0) = ':' AND
		WHO$CON$BUF(1) = 'V' AND
		WHO$CON$BUF(2) = 'O' AND
		WHO$CON$BUF(3) = ':'		THEN

		RETURN TRUE;
	ELSE
		RETURN FALSE;
	ENDIF
	END
CO$IS$VO;

PRINT$NEW$BANNER:
	PROCEDURE;
	DECLARE P BYTE;
	/*	We don't write all the way to the end of "initialized banner"
		so as to avoid printing the carriage return and line feed. */
    DO P = 0 TO LAST(INITIALIZED$BANNER)-2;
		CALL CO(FIRST$BLOCK$BUF(P));
	END$ITERATED$DO;

	IF CO$IS$VO THEN
		DO;
			CALL CO(CR);
			CALL CO(LF);
		ENDDO;
	ENDIF
    END
PRINT$NEW$BANNER;

EXIT$ROUTINE:
	PROCEDURE PUBLIC;
	CALL PRINT$NEW$BANNER;
	CALL EXIT;
	END
EXIT$ROUTINE;


/************************************************************/
/*															*/
/*				MAIN		LINE		CODE				*/
/*															*/
/************************************************************/

CALL RE$POSITION$CURSOR;
CALL INTERPRET$COMMAND$LINE;
CALL EXIT$ROUTINE;

END;
src/relab.plm
$ TITLE ('RELAB -- DISK RELABELLING TOOL')

RELAB$MOD:
DO;

/************************************************************************/
/*																		*/
/*     'Copyright 1981,1983 Intel Corporation'.  All rights reserved.	*/
/*      No part of this program or publication may be reproduced,		*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

$IF XVERSION
DECLARE PROPRIETARY(*) BYTE DATA ('INTEL PROPRIETARY SOFTWARE');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=X103',0);
$ELSE
DECLARE COPYRIGHT (*) BYTE DATA  ('COPYRIGHT 1981,1983 INTEL ');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.1',0);
$ENDIF

    

ATTRIB:
	PROCEDURE(FILE$NAME$PTR,WHICH$ATTRIBUTE,SET$OR$RESET,STATUS$PTR) EXTERNAL;
	DECLARE(FILE$NAME$PTR,WHICH$ATTRIBUTE,SET$OR$RESET,STATUS$PTR)ADDRESS; END;
CLOSE: PROCEDURE(AFTN,STATUS) EXTERNAL; DECLARE(AFTN,STATUS) ADDRESS; END;
ERROR: PROCEDURE(ERROR$NUMBER) EXTERNAL; DECLARE ERROR$NUMBER ADDRESS; END;
EXIT: PROCEDURE EXTERNAL; END;
OPEN: PROCEDURE(AFTN,FILENAME,ACCESS$MODE,LINE$EDIT$AFTN,ERROR) EXTERNAL;
	DECLARE(AFTN,FILENAME,ACCESS$MODE,LINE$EDIT$AFTN,ERROR) ADDRESS; END;
READ: PROCEDURE(AFTN,BUFFER,COUNT,ACTUAL,STATUS) EXTERNAL;
	DECLARE(AFTN,BUFFER,COUNT,ACTUAL,STATUS) ADDRESS; END;
SPATH: PROCEDURE(FILE,BUFFER,STATUS) EXTERNAL;
	DECLARE(FILE,BUFFER,STATUS) ADDRESS; END;
WRITE: PROCEDURE(AFTN,BUFFER,COUNT,STATUS) EXTERNAL;
	DECLARE(AFTN,BUFFER,COUNT,STATUS) ADDRESS; END;


DECLARE	AS	LITERALLY	'LITERALLY',
		BLANK		AS	'020H',
		CR			AS	'0DH',
		ESCAPE		AS	'01BH',
		LF			AS	'0AH',
		TAB			AS	'09H';

DECLARE
    ACTUAL ADDRESS,
    AFTN ADDRESS,
    STATUS ADDRESS,

	FILE$INFO STRUCTURE (
		DEVICE$NUMBER	BYTE,
		FILE$NAME(6)	BYTE,
		EXTENSION(3)	BYTE,
		DEVICE$TYPE		BYTE,
		DRIVE$TYPE(11)	BYTE);

DECLARE ISIS$LAB(*) BYTE INITIAL(':F0:ISIS.LAB ');

DECLARE CHAR$PTR ADDRESS INITIAL (.CI$BUF),
		CHAR BASED CHAR$PTR BYTE;

DECLARE CI$BUF (128) BYTE;

DECLARE BANNER(*) BYTE INITIAL
$IF XVERSION
		('ISIS-II DISK RELABELLING UTILITY, X103',cr,lf);
$ELSE
		('ISIS-II DISK RELABELLING UTILITY, V1.1',cr,lf);
$ENDIF
DECLARE DOC(*) BYTE INITIAL
		('syntax is RELAB <isis$disk$filename> | ? | EOL',CR,LF);

DECLARE	CHK	AS	'CALL CHECK$STATUS';


CHECK$STATUS: PROCEDURE;
	IF STATUS <> 0 THEN
		DO;
			CALL ERROR(STATUS);
			CALL EXIT;
		END;
END;


CALL WRITE(0,.BANNER,SIZE(BANNER),.STATUS); CHK;
CALL READ(1,.CI$BUF,SIZE(CI$BUF),.ACTUAL,.STATUS); CHK;
DO WHILE CHAR=TAB OR CHAR=BLANK;
	CHAR$PTR = CHAR$PTR + 1;
END;
	/*	If question mark... */
IF CHAR='?' THEN
	DO;
		CALL WRITE(0,.DOC,SIZE(DOC),.STATUS); CHK;
		CALL EXIT;
   	END;
    /*	If null command tail...*/
IF CHAR=CR OR CHAR=LF OR CHAR=ESCAPE THEN
	CALL EXIT;

CALL SPATH(CHAR$PTR,.FILE$INFO,.STATUS); CHK;
IF (FILE$INFO.DEVICE$NUMBER > 5 AND FILE$INFO.DEVICE$NUMBER < 25) OR
	(FILE$INFO.DEVICE$NUMBER > 28) THEN
	DO;
		CALL ERROR(17);
		CALL EXIT;
	END;
IF FILE$INFO.DEVICE$NUMBER >=25 THEN
	FILE$INFO.DEVICE$NUMBER = FILE$INFO.DEVICE$NUMBER - 19;
ISIS$LAB(2) = FILE$INFO.DEVICE$NUMBER + '0';

	/*	remove software write-protection. */
CALL ATTRIB(.ISIS$LAB,2,0,.STATUS); CHK; /* reset write protect */
CALL ATTRIB(.ISIS$LAB,3,0,.STATUS); CHK; /* reset format */

	/*	alter isis.lab */
CALL OPEN(.AFTN,.ISIS$LAB,3,0,.STATUS); CHK;  /* update */
CALL WRITE(AFTN,.FILE$INFO.FILE$NAME,9,.STATUS); CHK;
CALL CLOSE(AFTN,.STATUS); CHK;

    /*	restore "format" attribute. */
CALL ATTRIB(.ISIS$LAB,3,1,.STATUS); CHK;  /* set format */

CALL EXIT;

END;
src/report.plm
$ TITLE ('==> PASSIF -- REPORTMOD -- REPORT SUCCESS OR FAILURE <==')

REPORT$MOD:
DO;

/************************************************************************/
/*																		*/
/*     'Copyright 1981,1983 Intel Corporation'.  All rights reserved.	*/
/*      No part of this program or publication may be reproduced,		*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

$ NOLIST

/*         LIT.INC          */

DECLARE					AS LITERALLY 'LITERALLY',
	AMPERSAND			AS '''&''',
	BELL				AS '07H',
	BLANK				AS '020H',
	BOOLEAN				AS 'BYTE',
	CHK					AS 'CALL CHECK$STATUS',
	CLEAR$CHAR			AS '01CH',
	CO$ECHO$FILE		AS '0F00H',
	COLON				AS ''':''',
	COMMA				AS '02CH',
	CONSOLE$INPUT		AS '1',
	CONSOLE$OUTPUT		AS '0',
	CONTROL$Z			AS '01AH',
	CR					AS '0DH',
	DOT					AS '''.''',
	END$DO				AS 'END',
	END$DO$CASE			AS 'END',
	END$DO$WHILE		AS 'END',
	END$IF				AS '   ',
	END$ITERATED$DO		AS 'END',
	END$LOOP			AS ' ',
	EOF$CHAR			AS 'CONTROL$Z',
	ESC					AS '01BH',
	FALSE				AS '0H',
	FF					AS '0CH',
	FOREVER				AS 'WHILE 1',
	FORMAT$ATTRIBUTE	AS '3',
	HASH$MARK			AS '''#''',
	INIT$STG			AS '(*) BYTE INITIAL',
	LEAD$IN$CHAR		AS '07EH',
	LF					AS '0AH',
	NO$LINE$EDIT		AS '0',
	NULL				AS '0FFFFH',
	OPEN$FOR$READ		AS '1',
	OPEN$FOR$WRITE		AS '2',
	OPEN$FOR$UPDATE		AS '3',
	PUB$STRING			AS '(*) BYTE PUBLIC DATA',
	RESET				AS '0',
	RETURN$MARKER$POS	AS '0',
	SEEK$2$EOF			AS '4',
	SEEK$BACKWARD$BY$N	AS '1',
	SEEK$FORWARD$BY$N	AS '3',
	SEEK$2$N			AS '2',
	SEMICOLON			AS ''';''',
	SET					AS '1',
	STRING				AS '(*) BYTE DATA',
	TAB					AS '09H',
	TRANSFER$CONTROL	AS '1',
	TRUE				AS '0FFH',
	UNDERBAR			AS '''_''',
	USER$CI				AS '0',
	WRITE$PROTECT$ATTRIBUTE 		AS '2',
	ZERO$BIAS			AS '0';

/*        ENDLIT.INC        */

/* ISIS.INC */

CLOSE: PROCEDURE (AFTN,STATUS) EXTERNAL; DECLARE (AFTN,STATUS) ADDRESS;	END;
CO:	PROCEDURE (CHAR$CO) EXTERNAL; DECLARE CHAR$CO BYTE;	END;
DELETE:	PROCEDURE (FILE$NAME$PTR,STATUS) EXTERNAL;
	DECLARE (FILE$NAME$PTR,STATUS) ADDRESS;	END;
EXIT: PROCEDURE EXTERNAL; END;
OPEN: PROCEDURE(AFTN,FILENAME,ACCESS$MODE,LINE$EDIT$AFTN,ERROR) EXTERNAL;
	DECLARE (AFTN,FILENAME,ACCESS$MODE,LINE$EDIT$AFTN,ERROR) ADDRESS; END;
READ: PROCEDURE (AFTN,BUFFER,COUNT,ACTUAL,STATUS) EXTERNAL;
	DECLARE (AFTN,BUFFER,COUNT,ACTUAL,STATUS) ADDRESS; END;
RENAME: PROCEDURE (OLD$NAME,NEW$NAME,STATUS$R) EXTERNAL;
	DECLARE (OLD$NAME,NEW$NAME,STATUS$R) ADDRESS; END;
SEEK: PROCEDURE (AFTN,MODE,BLOCKNO,BYTENO,STATUS) EXTERNAL;
	DECLARE (AFTN,MODE,BLOCKNO,BYTENO,STATUS) ADDRESS; END;
SPATH: PROCEDURE (FILE,BUFFER,STATUS) EXTERNAL;
	DECLARE (FILE,BUFFER,STATUS) ADDRESS; END;
WHOCON:	PROCEDURE (AFTN,BUFFER) EXTERNAL; DECLARE (AFTN,BUFFER) ADDRESS; END;
WRITE: PROCEDURE (AFTN,BUFFER,COUNT,STATUS) EXTERNAL;
	DECLARE (AFTN,BUFFER,COUNT,STATUS) ADDRESS;	END;

/* END ISIS.INC */

/************************************************************/
/*															*/
/*              LITERALLY'S UNIQUE TO PASSIF                */
/*															*/
/************************************************************/

DECLARE
    MINIMUM$ACCEPTABLE$BANNER$LENGTH 	AS 		'73',
    MAXIMUM$TOKEN$LENGTH				AS		'70',
    BI									AS		'CALL BOMB$IF(STATUS)',

	FIRST$FIELD							AS		'0',
    SECOND$FIELD						AS		'28',
    THIRD$FIELD							AS		'54',

    RIGHT$PARENTHESIS 					AS		''')''',
    LEFT$PARENTHESIS 					AS		'''(''',
    RI									AS		'CALL REPORT$IF',
    UNRECOGNIZED$SWITCH$ERR 			AS		'201',
    QUESTION$MARK						AS		'''?''';


/*	MAIN.INC  */

DECLARE
    ACTUAL ADDRESS EXTERNAL,
    AFTN ADDRESS EXTERNAL,
    COMMAND$TAIL$BUF (250) BYTE EXTERNAL,
    DELIMITER BYTE EXTERNAL,
    FIRST$BLOCK$BUF (128) BYTE EXTERNAL,
    FIRST$OUTPUT$MSG$PTR ADDRESS EXTERNAL,
    FIRST$TIME$THROUGH BOOLEAN EXTERNAL,
    INITIALIZED$BANNER (74) BYTE EXTERNAL,
    PRINT$HASH$MARK BOOLEAN EXTERNAL,
    REPORT$FILE$ACTUAL ADDRESS EXTERNAL,
    REPORT$FILE$AFTN ADDRESS EXTERNAL,
    REPORT$FILE$STRING$BEGINNING ADDRESS EXTERNAL,
    SECOND$OUTPUT$MSG$PTR ADDRESS EXTERNAL,
    STATUS ADDRESS EXTERNAL,
    TMP$FILE$AFTN ADDRESS EXTERNAL,
    TMP$FILE$NAME (15) BYTE EXTERNAL,
    TOK$BUF (80) BYTE EXTERNAL;

DECLARE
    KEY$WORDS (10) STRUCTURE
    (LENGTH							BYTE,
    KEY$WORD	(13)				BYTE,
    PROC$PTR						ADDRESS) EXTERNAL;

CO$IS$VO: PROCEDURE BOOLEAN EXTERNAL; END;
EXIT$ROUTINE: PROCEDURE EXTERNAL; END;
RE$POSITION$CURSOR:	PROCEDURE EXTERNAL;	END;
MOVE: PROCEDURE (COUNT,SOURCE$PTR,DEST$PTR) EXTERNAL;
	DECLARE (COUNT,SOURCE$PTR,DEST$PTR) ADDRESS; END;

/*	END MAIN.INC  */

/*	ERRMSG.INC  */

DECLARE
	BAD$SYNTAX$MSG 				(29)	BYTE	EXTERNAL,
	BOMB$IF$MSG$1    			(12)	BYTE	EXTERNAL,
	BOMB$IF$MSG$2				(40)	BYTE	EXTERNAL,
    DURING$ASSERTION$CHECK$MSG	(50)	BYTE	EXTERNAL,
    PASSIF$INVOKED$BY$MSG       (19)    BYTE    EXTERNAL,
    ZERO$LENGTH$FILE$MSG 		(40)	BYTE	EXTERNAL;

/*	END ERRMSG.INC  */

/*	CLI.INC  */

DECLARE BUF$COUNT BYTE EXTERNAL;

/*	END CLI.INC  */

$ LIST

$ EJECT

/************************************************************/
/*															*/
/*                        NOTES                             */
/*															*/
/************************************************************/

/*

1.	Two types of string passing conventions are used:

	a.	the UDI convention, and
	b.	the "terminated by a binary 0" kind

2.	The procedures which report assertion failures with additional
	information work by preparing UDI-style message strings, setting
    pointers to them, then calling the vanilla "report$assertion$failure".
    In the course of its operation, report$assertion$failure will insert
    these prepared messages into the "failed assertion entry" if they're
    not null.

*/

$ EJECT

/************************************************************/
/*															*/
/*              LITERALLY'S FOR THIS MODULE                 */
/*															*/
/************************************************************/

DECLARE
	MAX$ENTRY$LINE$LENGTH 				AS				'71';


/************************************************************/
/*															*/
/*                     MODULE GLOBALS                       */
/*															*/
/************************************************************/

DECLARE HYPENS$STG STRING
                   ('--------------------------------------',
                    '--------------------------------------',
                                 CR,LF,CR,LF);

DECLARE
    TEST$STG STRING
        ('test '),

    FAILED$STG STRING
        (' failed'),

    CI$STG STRING
        ('            :CI:=');

/************************************************************/
/*															*/
/*         INITIALIZED "MODULE GLOBAL" VARIABLES            */
/*															*/
/************************************************************/

DECLARE ZERO$VAL ADDRESS DATA (0);
DECLARE FOUR$SPACES STRING ('    ');

/************************************************************/
/*															*/
/*               THE "REPORTING" PROCEDURES                 */
/*															*/
/************************************************************/

MSG$LENGTH:
	PROCEDURE (OLD$STYLE$MSG$PTR) BYTE PUBLIC;

	/*	This procedure is for assessing the length of
		an "old" style string;  that is, one terminated
		by a binary zero. */

    DECLARE OLD$STYLE$MSG$PTR ADDRESS,
    		OLD$STYLE$MSG BASED OLD$STYLE$MSG$PTR (1000) BYTE;
	DECLARE V BYTE;

	V = 0;
    DO WHILE (OLD$STYLE$MSG(V)<>0) AND V<255;
    	V = V + 1;
    END$DO$WHILE;
    RETURN V;
	END
MSG$LENGTH;

NUM$OUT:
	PROCEDURE (ERR$NUM,BUF$PTR);
	DECLARE (ERR$NUM,BUF$PTR) ADDRESS;
	DECLARE BUF BASED BUF$PTR (6) BYTE;
    DECLARE TMP$BUF (5) BYTE;
    DECLARE U BYTE;

	/*	This version of numout requires a pointer to a six-byte buffer
		as a parameter.  Numout places the "width" of the number in the
		first byte of the buffer, and the ascii expansion of the number
		in the next 1 to 5 bytes. */

	BUF(0) = 1;
	U = 4;

	loop$begin:
		TMP$BUF(U) = (ERR$NUM MOD 10) + '0';
        ERR$NUM = ERR$NUM / 10;
        IF ERR$NUM<>0 THEN
            DO;
            	U = U - 1;
                BUF(0) = BUF(0) + 1;
      			GOTO loop$begin;
        	ENDDO;
        ENDIF
	end$loop

	CALL MOVE(/*count*/			BUF(0),
			  /*source*/		.TMP$BUF(5-BUF(0)),
			  /*destination*/	.BUF(1));
	END
NUM$OUT;

HEXADECIMAL$DIGIT:
	PROCEDURE (A$CHAR) BOOLEAN;
	DECLARE A$CHAR BYTE;
	RETURN
		(A$CHAR>='0' AND A$CHAR<='9')
					OR
		(A$CHAR>='A' AND A$CHAR<='F');
	END
HEXADECIMAL$DIGIT;

$ EJECT

/************************************************************/
/*															*/
/*                       BOMB$IF                            */
/*															*/
/************************************************************/

BOMB$IF:
	PROCEDURE (STATUS) PUBLIC;

    /*	This procedure is called if an Isis error is encountered in the
    	course of processing the error reporting file.

        Such an error can not rationally be reported in the error
        report file, since it was the process of updating said file
        which caused the problem; therefore, under such
        circumstances, Passif prints the "bomb$if" error message to
        the console output, and to the cold boot console, and exits.
        */

    DECLARE STATUS ADDRESS;
	DECLARE T BYTE;
	DECLARE TMP$STATUS ADDRESS;
	DECLARE NUM$OUT$BUF (6) BYTE;
	DECLARE NUM$LEN BYTE;

	IF STATUS<>0 THEN
		DO;
          CALL NUM$OUT(STATUS,.NUM$OUT$BUF);

          IF NOT CO$IS$VO THEN
           DO;
            /*	First print the message to the cold boot console. */
            CALL RE$POSITION$CURSOR;

            /*	Print out part one of the message. */
            DO T=0 TO MSG$LENGTH(.BOMB$IF$MSG$1);
                CALL CO(BOMB$IF$MSG$1(T));
            END$ITERATED$DO;

            /*	Print out the error number. */
            NUM$LEN = NUM$OUT$BUF(0);
            DO T=1 TO NUM$LEN;
                CALL CO(NUM$OUT$BUF(T));
            END$ITERATED$DO;

            /*	Print out part two of the message. */
            DO T=0 TO MSG$LENGTH(.BOMB$IF$MSG$2);
                CALL CO(BOMB$IF$MSG$2(T));
            END$ITERATED$DO;

            CALL co(CR);
            CALL co(LF);
           END;

            /*	Now print the message to the console output.  */
            CALL WRITE(CONSOLE$OUTPUT,.BOMB$IF$MSG$1,
                    MSG$LENGTH(.BOMB$IF$MSG$1),.TMP$STATUS);

        	CALL WRITE(CONSOLE$OUTPUT,.NUM$OUT$BUF(1),NUM$OUT$BUF(0),
                                 .TMP$STATUS);

            CALL WRITE(CONSOLE$OUTPUT,.BOMB$IF$MSG$2,
                    MSG$LENGTH(.BOMB$IF$MSG$2),.TMP$STATUS);

            CALL WRITE(CONSOLE$OUTPUT,.(CR,LF),2,.TMP$STATUS);
        	CALL EXIT;
    	ENDDO;
    ENDIF
    END
BOMB$IF;

EOL:
    PROCEDURE;
    CALL WRITE(REPORT$FILE$AFTN,.(CR,LF),2,.STATUS);
    BI;
    END
EOL;

INDENT:
    PROCEDURE;
    /*	Indent 4 spaces. */
    CALL WRITE(REPORT$FILE$AFTN,.FOUR$SPACES,SIZE(FOUR$SPACES),.STATUS); BI;
    END
INDENT;

$ EJECT

/************************************************************/
/*															*/
/*                WRITE$OUT$COMMAND$TAIL                    */
/*															*/
/************************************************************/

WRITE$OUT$COMMAND$TAIL:
	PROCEDURE;

	DECLARE UN$WRITTEN$BYTES BYTE;
	DECLARE COUNT$FOR$THIS$LINE BYTE;
	DECLARE BUF$PTR ADDRESS,
			BUF BASED BUF$PTR (100) BYTE;

    UNWRITTEN$BYTES = BUF$COUNT;
    BUF$PTR = .COMMAND$TAIL$BUF;

    loop$begin:
        IF UN$WRITTEN$BYTES > MAX$ENTRY$LINE$LENGTH THEN
    		COUNT$FOR$THIS$LINE = MAX$ENTRY$LINE$LENGTH;
        ELSE
        	COUNT$FOR$THIS$LINE = UN$WRITTEN$BYTES;
    	ENDIF

    	UN$WRITTEN$BYTES = UN$WRITTEN$BYTES - COUNT$FOR$THIS$LINE;

        CALL INDENT;
        CALL WRITE(REPORT$FILE$AFTN,BUF$PTR,COUNT$FOR$THIS$LINE,.STATUS); BI;

        IF UN$WRITTEN$BYTES > 0 THEN
        	DO;
                BUF$PTR = BUF$PTR + COUNT$FOR$THIS$LINE;
    			CALL EOL;
    			GOTO loop$begin;
            ENDDO;
    	ENDIF
    end$loop

	IF PRINT$HASH$MARK THEN
        CALL WRITE(REPORT$FILE$AFTN,.(HASH$MARK),1,.STATUS); BI;
    ENDIF

    END
WRITE$OUT$COMMAND$TAIL;

FIVE$ASCII$HEXADECIMAL$DIGITS:
	PROCEDURE (DIG$PTR) BOOLEAN;
	DECLARE DIG$PTR ADDRESS,
			DIG BASED DIG$PTR (5) BYTE;
    DECLARE M BYTE;

    DO M = 0 TO 4;
		IF NOT HEXADECIMAL$DIGIT(DIG(M)) THEN
			RETURN FALSE;
        ENDIF
    END$ITERATED$DO;
    RETURN TRUE;
	END
FIVE$ASCII$HEXADECIMAL$DIGITS;

BANNER$IS$LEGIT:
	PROCEDURE BOOLEAN;
	IF REPORT$FILE$ACTUAL >= SIZE(INITIALIZED$BANNER) THEN
		DO;
            RETURN
            FIVE$ASCII$HEXADECIMAL$DIGITS(.FIRST$BLOCK$BUF(FIRST$FIELD))  AND
            FIVE$ASCII$HEXADECIMAL$DIGITS(.FIRST$BLOCK$BUF(SECOND$FIELD)) AND
            FIVE$ASCII$HEXADECIMAL$DIGITS(.FIRST$BLOCK$BUF(THIRD$FIELD));
        ENDDO;
	ELSE
		RETURN FALSE;
	ENDIF
    END
BANNER$IS$LEGIT;

/*  The following is a typical banner.
0         1         2         3         4         5         6         7
0123456789012345678901234567890123456789012345678901234567890123456789012345

13517 TESTS EXECUTED         13499 TESTS PASSED         00018 TESTS FAILED
*/



seek$report$file$to$beginning: PROCEDURE;
  CALL SEEK(REPORT$FILE$AFTN,SEEK$2$N,.ZERO$VAL,.ZERO$VAL,.STATUS); BI;
END;

open$report$file$for$update: PROCEDURE;
  CALL OPEN(.REPORT$FILE$AFTN,REPORT$FILE$STRING$BEGINNING,
                      OPEN$FOR$UPDATE,NO$LINE$EDIT,.STATUS); BI;
END;
$ EJECT

/************************************************************/
/*															*/
/*                READ$IN$AND$QA$REPORT$FILE                */
/*															*/
/************************************************************/

READ$IN$AND$QA$REPORT$FILE:
	PROCEDURE;

    RE$INITIALIZE$REPORT$FILE:
        PROCEDURE;

        DECLARE STATIC$BUF (128) BYTE;

		DECLARE FILE$INFORMATION STRUCTURE
           (DEVICE$NUMBER						BYTE,
            FILE$NAME				(6)			BYTE,
            EXTENSION				(3)			BYTE,
            DEVICE$TYPE							BYTE,
            DRIVE$TYPE							BYTE);

        /*	First, ascertain correct device for temporary file,
            and open it. */
        CALL SPATH(REPORT$FILE$STRING$BEGINNING,.FILE$INFORMATION,.STATUS); BI;
        IF file$information.device$number > 5 THEN  /* added 2/21/83  J.P. */
          file$information.device$number = file$information.device$number - 19;
        TMP$FILE$NAME(2) = FILE$INFORMATION.DEVICE$NUMBER + '0';

        /*	The temporary file must be opened in update mode, since it may
        	become the report file;  and it is crucial for the report file
        	to be readable from, and writeable to. */

        CALL OPEN(.TMP$FILE$AFTN,.TMP$FILE$NAME,OPEN$FOR$UPDATE,NO$LINE$EDIT,
                                   .STATUS); BI;

        /*	Write out an initialized banner. */
        CALL WRITE(TMP$FILE$AFTN,.INITIALIZED$BANNER,
                       					SIZE(INITIALIZED$BANNER),.STATUS);

        /*	Now, write out the rest of the file, first seeking
            back to the beginning of the report file. */
        CALL SEEK$REPORT$FILE$TO$BEGINNING;

        begin$copying$loop:
        	CALL READ(REPORT$FILE$AFTN,.STATIC$BUF,SIZE(STATIC$BUF),
                               .ACTUAL,.STATUS); BI;
            CALL WRITE(TMP$FILE$AFTN,.STATIC$BUF,ACTUAL,.STATUS); BI;
            IF ACTUAL = SIZE(STATIC$BUF) THEN
            	GOTO begin$copying$loop;
            ENDIF
        end$loop

		/*	Close report file, rename the temporary file, reassign
            the report$file$aftn, and seek back to the beginning.  We
            have to seek back to the beginning, because that's what
            the calling procedure expects.

            The result of all this is that, in terms of disk storage
            locations, what was the temporary file will be the report
            file, but both the ascii filename and the
            report$file$aftn will be correct.  */

        CALL CLOSE(REPORT$FILE$AFTN,.STATUS); BI;
		CALL DELETE(REPORT$FILE$STRING$BEGINNING,.STATUS); BI;
        CALL close(tmp$file$aftn,.status); bi;
        CALL RENAME(.TMP$FILE$NAME,REPORT$FILE$STRING$BEGINNING,.STATUS); BI;
        CALL OPEN$REPORT$FILE$FOR$UPDATE;
        CALL SEEK$REPORT$FILE$TO$BEGINNING;
		END
    RE$INITIALIZE$REPORT$FILE;

$ EJECT

    /************************************************************/
    /*															*/
    /*      FIRST EXECUTABLE IN READ$IN$AND$QA$REPORT$FILE      */
    /*															*/
    /************************************************************/

	CALL OPEN$REPORT$FILE$FOR$UPDATE;

    loop$begin:
        CALL READ(REPORT$FILE$AFTN,.FIRST$BLOCK$BUF(0),SIZE(FIRST$BLOCK$BUF),
                        .REPORT$FILE$ACTUAL,.STATUS); BI;

        IF NOT BANNER$IS$LEGIT THEN
            DO;
                CALL RE$INITIALIZE$REPORT$FILE;
                GOTO loop$begin;
            ENDDO;
        ENDIF
    end$loop

    END
READ$IN$AND$QA$REPORT$FILE;


INCREMENT$ASCII:
	PROCEDURE (FIELD$PTR);
	DECLARE FIELD$PTR ADDRESS,
			FIELD  BASED FIELD$PTR (5) BYTE,
			N BYTE;

    N = 4;
    loop$begin:
    IF FIELD(N)='9' THEN
    	DO;
			FIELD(N) = '0';
            IF N<>0 THEN
				DO;
					N = N - 1;
                	GOTO loop$begin;
                ENDDO;
    	ENDDO;
    ELSE
        FIELD(N) = FIELD(N) + 1;
    ENDIF
	END
INCREMENT$ASCII;

WRITE$OUT$FIRST$BLOCK$BUF:
	PROCEDURE;
	CALL SEEK$REPORT$FILE$TO$BEGINNING;
	CALL WRITE(REPORT$FILE$AFTN,.FIRST$BLOCK$BUF,REPORT$FILE$ACTUAL,.STATUS); BI;
	END
WRITE$OUT$FIRST$BLOCK$BUF;

REPORT$ASSERTION$SUCCESS:
	PROCEDURE PUBLIC;
	CALL READ$IN$AND$QA$REPORT$FILE;
    CALL INCREMENT$ASCII(.FIRST$BLOCK$BUF(FIRST$FIELD));
    CALL INCREMENT$ASCII(.FIRST$BLOCK$BUF(SECOND$FIELD));
    CALL WRITE$OUT$FIRST$BLOCK$BUF;
    CALL EXIT$ROUTINE;
	END
REPORT$ASSERTION$SUCCESS;

$ EJECT

/************************************************************/
/*															*/
/*               REPORT$ASSERTION$FAILURE                   */
/*															*/
/************************************************************/

REPORT$ASSERTION$FAILURE:
	PROCEDURE PUBLIC;

    DECLARE DOESNT$MATTER ADDRESS;
	DECLARE CI$BUF (20) BYTE;
    DECLARE Q BYTE;
	DECLARE W BYTE;

    /************************************************************/
    /*															*/
    /*      PROCEDURES LOCAL TO REPORT$ASSERTION$FAILURE        */
    /*															*/
    /************************************************************/

    INSERT$MSG:
    	PROCEDURE (MSG$PTR);
    	DECLARE MSG$PTR ADDRESS;

        /*	The strings passed to this procedure are of the "other" type,
        	meaning that the first byte of the string is part of the
        	string, and the string is terminated by a binary 0.  This
        	procedure assumes that the strings passed to it will fit on
        	a single line.  */
        IF MSG$PTR <> NULL THEN
            DO;
                CALL EOL;
                CALL INDENT;
                CALL WRITE(REPORT$FILE$AFTN,
                   MSG$PTR,MSG$LENGTH(MSG$PTR),.STATUS); BI;
			ENDDO;
		ENDIF
    	END
    INSERT$MSG;

    WRITE$CI$FILE:
    	PROCEDURE;
        /*	Write out :ci: file designation. */
        /*	Calculate how many bytes to write by finding the blank which
            terminates the filename string.  */
        CALL WHO$CON(CONSOLE$INPUT,.CI$BUF);
        Q = 0;
        DO WHILE CI$BUF(Q) <> BLANK;
            Q = Q + 1;
        ENDDOWHILE;
        CALL WRITE(REPORT$FILE$AFTN,.CI$BUF,Q,.STATUS); BI;
        END
    WRITE$CI$FILE;

    WRITE$OUT$TEST$FAILURE$NUMBER:
        PROCEDURE (AN$AFTN);

        DECLARE AN$AFTN ADDRESS;

        /*	Write out the "test" string.  */
        CALL WRITE(AN$AFTN,.TEST$STG,SIZE(TEST$STG),.STATUS); BI;

        /*	Write out the ordinal number of the test which failed. */
        CALL WRITE(AN$AFTN,.FIRST$BLOCK$BUF(0),5,.STATUS); BI;

        /*	Write out the "failed" string.  */
        CALL WRITE(AN$AFTN,.FAILED$STG,SIZE(FAILED$STG),.STATUS); BI;

        END
    WRITE$OUT$TEST$FAILURE$NUMBER;

    WRITE$FAILURE$NUMBER$IN$CO$FILE:
    	PROCEDURE;

		DECLARE
			FIRST$MESSAGE STRING
				(CR,LF,CR,LF,'                            ====> '),

        	SECOND$MESSAGE STRING
        		(' <====',CR,LF,CR,LF);

		CALL WRITE
            (CONSOLE$OUTPUT,.FIRST$MESSAGE,SIZE(FIRST$MESSAGE),.STATUS); BI;

        CALL WRITE$OUT$TEST$FAILURE$NUMBER (CONSOLE$OUTPUT);

		CALL WRITE
            (CONSOLE$OUTPUT,.SECOND$MESSAGE,SIZE(SECOND$MESSAGE),.STATUS); BI;

    	END
    WRITE$FAILURE$NUMBER$IN$CO$FILE;

$ EJECT

    /************************************************************/
    /*															*/
    /*  FIRST EXECUTABLE IN PROCEDURE REPORT$ASSERTION$FAILURE  */
    /*															*/
    /************************************************************/

    CALL READ$IN$AND$QA$REPORT$FILE;
    CALL INCREMENT$ASCII(.FIRST$BLOCK$BUF(FIRST$FIELD));
    CALL INCREMENT$ASCII(.FIRST$BLOCK$BUF(THIRD$FIELD));
    CALL WRITE$OUT$FIRST$BLOCK$BUF;

    /*	Now, seek to the end of the file. */
    CALL SEEK
      (REPORT$FILE$AFTN,SEEK$2$EOF,.DOESNT$MATTER,.DOESNT$MATTER,.STATUS); BI;

    /*	Write out the long row of hyphens which separates the "failed
    	assertion entry reports.  */
    CALL WRITE(REPORT$FILE$AFTN,.HYPENS$STG,SIZE(HYPENS$STG),.STATUS); BI;

	CALL WRITE$OUT$TEST$FAILURE$NUMBER (REPORT$FILE$AFTN);

    CALL WRITE(REPORT$FILE$AFTN,.CI$STG,SIZE(CI$STG),.STATUS); BI;

	IF NOT CO$IS$VO THEN
		CALL WRITE$FAILURE$NUMBER$IN$CO$FILE;
    ENDIF

    CALL WRITE$CI$FILE;
    CALL EOL;

	/*	Write out the first message, if any. */
	CALL INSERT$MSG(FIRST$OUTPUT$MSG$PTR);
	CALL EOL;

	CALL WRITE$OUT$COMMAND$TAIL;

    /*	Write out the second message, if any. */
	CALL INSERT$MSG(SECOND$OUTPUT$MSG$PTR);

    /*	Add blank lines at bottom of "assertion failure report entry". */
	DO W=1 TO 2;
		CALL EOL;
    END$ITERATED$DO;

    CALL EXIT$ROUTINE;

    END
REPORT$ASSERTION$FAILURE;

$ EJECT

REPORT$SYNTAX$ERROR:
	PROCEDURE PUBLIC;
	FIRST$OUTPUT$MSG$PTR = .BAD$SYNTAX$MSG;
    PRINT$HASH$MARK = TRUE;
    CALL REPORT$ASSERTION$FAILURE;
    END
REPORT$SYNTAX$ERROR;

REPORT$ASSERTION$FAILURE$W$MSG:
	PROCEDURE (OLD$STYLE$MSG$PTR) PUBLIC;
    DECLARE OLD$STYLE$MSG$PTR ADDRESS;

	SECOND$OUTPUT$MSG$PTR = OLD$STYLE$MSG$PTR;
    CALL REPORT$ASSERTION$FAILURE;
    END
REPORT$ASSERTION$FAILURE$W$MSG;

$ EJECT

/************************************************************/
/*															*/
/*           REPORT$ASSERTION$FAILURE$W$ISIS$ERR            */
/*															*/
/************************************************************/

REPORT$ASSERTION$FAILURE$W$ISIS$ERR:
	PROCEDURE (STATUS) PUBLIC;

	/*	This procedure accepts as input, and delivers as output,
		"delimited" strings.  Input, as specified above, does
		not mean the parameter with which this procedure was called,
		but some global strings which are concatenated to produce
        a larger string which becomes an error message. */

    DECLARE STATUS ADDRESS;
    DECLARE MSG$BUF (256) BYTE;
	DECLARE FIRST$FREE$BYTE ADDRESS;
    DECLARE ASCII$NUM$BUF (6) BYTE;

    /************************************************************/
    /*															*/
    /* PROCEDURES LOCAL TO REPORT$ASSERTION$FAILURE$W$ISIS$ERR  */
    /*															*/
    /************************************************************/

    LOAD$MSG$BUF:
    	PROCEDURE (SOURCE$PTR,COUNT);
    	DECLARE (SOURCE$PTR,COUNT) ADDRESS;
        CALL MOVE(/*count*/		COUNT,
                  /*source*/	SOURCE$PTR,
                  /*dest*/		.MSG$BUF(FIRST$FREE$BYTE));
    	FIRST$FREE$BYTE = FIRST$FREE$BYTE + COUNT;
    	END
    LOAD$MSG$BUF;

    /************************************************************/
    /*															*/
    /* FIRST EXECUTABLE IN REPORT$ASSERTION$FAILURE$W$ISIS$ERR  */
    /*															*/
    /************************************************************/

    FIRST$FREE$BYTE = 0;
    CALL LOAD$MSG$BUF(.BOMB$IF$MSG$1,MSG$LENGTH(.BOMB$IF$MSG$1));
    CALL NUM$OUT(STATUS,.ASCII$NUM$BUF);
    CALL LOAD$MSG$BUF(.ASCII$NUM$BUF(1),ASCII$NUM$BUF(0));
    CALL LOAD$MSG$BUF(.DURING$ASSERTION$CHECK$MSG,
                   MSG$LENGTH(.DURING$ASSERTION$CHECK$MSG));

    /*	Delimit the output string. */
    CALL LOAD$MSG$BUF(.ZERO$VAL,SIZE(ZERO$VAL));

    FIRST$OUTPUT$MSG$PTR  = .PASSIF$INVOKED$BY$MSG;
    SECOND$OUTPUT$MSG$PTR = .MSG$BUF;
	PRINT$HASH$MARK = TRUE;

    CALL REPORT$ASSERTION$FAILURE;
    END
REPORT$ASSERTION$FAILURE$W$ISIS$ERR;

REPORT$ISIS$ERROR:
	PROCEDURE (STATUS) PUBLIC;
	DECLARE STATUS ADDRESS;
	IF STATUS<>0 THEN
		CALL REPORT$ASSERTION$FAILURE$W$ISIS$ERR(STATUS);
	ENDIF
	END
REPORT$ISIS$ERROR;

END
REPORT$MOD;
src/rescan.plm
RESCAN:  DO;

/************************************************************************/
/*																		*/
/*     'Copyright 1981,1983 Intel Corporation'.  All rights reserved.	*/
/*      No part of this program or publication may be reproduced,		*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

$IF XVERSION
DECLARE PROPRIETARY(*) BYTE DATA ('INTEL PROPRIETARY SOFTWARE');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=X103',0);
$ELSE
DECLARE COPYRIGHT (*) BYTE DATA  ('COPYRIGHT 1981,1983 INTEL ');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.1',0);
$ENDIF


/*******************************************************************************
 *
 * This program is designed to allow the restarting of a submit file
 * at any line within the .CS file.
 *
 * the action performed by this program is to copy the .CS file, line-by-line,
 * to CO ( not :CO: ) and query the keyboard CI ( not :CI: ) for a
 * response.  If the response is an escape ( ESC ) then the submit file
 * is restarted at the currently displayed line.  If the response is
 * a control C character (control$C) command is given to the cold start
 * console and the program exited.  If the response is any other character,
 * the next line of the file will be printed ( except for tilda ).
 * Due to the way ISIS handles the console device, reaching the end of the
 * file will cause an ISIS error 29 with a subsequent reboot.
 *
 *******************************************************************************/

/* commonly used literallys */

   declare decl literally 'declare';
   declare as literally 'literally';

   decl pointer as 'address';
   decl boolean as 'byte';
   decl character as 'byte';
   decl int1 as 'byte';
   decl int2 as 'address';

   decl true as '0FFH';
   decl false as '0';
   decl nil as '0';

   decl FOREVER as 'while true';
   decl ESC as '1BH';
   decl control$C as '03H';
   decl TILDA as '7FH';
   decl CONSOLE$MASK as '03H';

/* system externals */

READ: procedure( AFTN, BUFFER, LEN, ACTUAL, STATUS ) external;
   decl (AFTN,BUFFER,LEN,ACTUAL,STATUS) address;
end;

WRITE: procedure( AFTN, BUFFER , COUNT , STATUS ) external;
   decl (AFTN,BUFFER,COUNT,STATUS) address;
end;
   
CI: procedure character external;
end;

CO: procedure( CHAR ) external;
   decl CHAR character;
end;

IOCHK: procedure byte external;
end;

RESCAN: procedure( AFTN, STATUS ) external;
   decl (AFTN,STATUS) address;
end;

CONSOL: procedure( INFILE, OUTFILE, STATUS ) external;
   decl (INFILE,OUTFILE,STATUS) address;
end;

ERROR: procedure(ERRNUM) external;
   decl ERRNUM address;
end;

EXIT: procedure external;
end;

SEEK:
    PROCEDURE (AFT,MODE,BLOCKNUM,BYTENUM,STATUS) EXTERNAL;
    DECLARE (AFT,MODE,BLOCKNUM,BYTENUM,STATUS) ADDRESS;
    END
SEEK;

FERR: procedure(STATUS);
   decl STATUS int2;
   /* exit if error (status <> 0) */
   if STATUS <> 0 then do;
      call ERROR(STATUS);
      call EXIT;
   end;
end FERR;

/* global declarations */

   decl LINE(128) character; /* input and display line */

   decl I int1;
   decl CHAR character;
   decl (STATUS,ACTUAL) address;
   decl ZERO$BLOCKS address data (0);

/* main line code */

/* read command line for input file name */
call READ( 1, .LINE, 128, .ACTUAL, .STATUS );
call FERR(STATUS); /* tests for non-zero status;

/* scan for first non-blank character in line */
I = 0;
do while LINE(I) = ' ' and I < 127;
   I = I + 1;
end;

/* use the input file as the current console device */
call CONSOL( .LINE(I), .(':CO: '), .STATUS);
call FERR(STATUS);

/* main control loop */

do FOREVER;

   /* reads console file and writes to screen */
   call WRITE(0, .('#'), 1 , .STATUS );
   call FERR(STATUS);
   call READ( 1, .LINE, 128, .ACTUAL, .STATUS );
   call FERR(STATUS);

   /* query the keyboard */
IGNORE:
   CHAR = CI and 7FH;
   if CHAR = TILDA then go to IGNORE; /* ignore tilda characters */

   /* test for action */

   if CHAR = ESC then do;
      /* start file from this point */
      /* position to beginning of line */
      call SEEK(1				/* seek on console input */	,
      			1				/* seek backward mode	 */	,
                .zero$blocks								,
                .actual										,
                .STATUS 									);
      call EXIT;
   end;

   else if CHAR = control$C then do;
      /* return to cold start console */
      I = IOCHK; /* get current device flags */
      if ( I and CONSOLE$MASK ) <> 0 then do; /* console is :VI: */
         call CONSOL( .(':VI: '), .(':CO: '), .STATUS );
         call FERR(STATUS);
         call EXIT;
      end;
      else do; /* console is :TI: */
         call CONSOL( .(':TI: '), .(':CO: '), .STATUS );
         call FERR(STATUS);
         call EXIT;
      end;
   end;
end;

end RESCAN;
src/return.plm
RETURN$MOD: DO;

/************************************************************************/
/*																		*/
/*     'Copyright 1981,1983 Intel Corporation'.  All rights reserved.	*/
/*      No part of this program or publication may be reproduced,		*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

$IF XVERSION
DECLARE PROPRIETARY(*) BYTE DATA ('INTEL PROPRIETARY SOFTWARE');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=X104',0);
$ELSE
DECLARE COPYRIGHT (*) BYTE DATA  ('COPYRIGHT 1981,1983 INTEL ');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.1',0);
$ENDIF


DECLARE	LIT		LITERALLY	'LITERALLY',
		DCL		LIT	'DECLARE',
		TRUE	LIT	'0FFH',
		FALSE	LIT	'000H',
		PROC	LIT	'PROCEDURE',
		PROCEND	LIT	'END',
		THENDO	LIT	'THEN DO;',
		ELSEIF	LIT	'END; ELSE IF',
		ELSEDO	LIT	'END; ELSE DO;',
		IFEND	LIT	'END',
		WHILEND	LIT	'END',
		CR		LIT	'0DH',
		LF		LIT	'0AH';

EXIT:	PROC EXTERNAL;											PROCEND;
READ:	PROC (A,B,C,D,E) EXTERNAL;	DCL (A,B,C,D,E) ADDRESS;	PROCEND;
WRITE:	PROC (A,B,C,D) EXTERNAL;	DCL (A,B,C,D) ADDRESS;		PROCEND;
SEEK:	PROC (A,B,C,D,E) EXTERNAL;	DCL (A,B,C,D,E) ADDRESS;	PROCEND;
DEBLANK:PROC (A) ADDRESS EXTERNAL;	DCL (A) ADDRESS;			PROCEND;
SEQ:	PROC (A,B,C) BYTE EXTERNAL;	DCL (A,B,C) ADDRESS;		PROCEND;
FORCE$UPPER:	PROC(A) EXTERNAL;	DCL (A) ADDRESS;			PROCEND;

DCL (STATUS, ACTUAL) ADDRESS;
DCL (CUR$BLOCKNO, CUR$BYTENO, EOF$BLOCKNO, EOF$BYTENO) ADDRESS;
DCL (LAST$BLOCKNO, LAST$BYTENO, BLOCKNO, BYTENO) ADDRESS;
DCL (SECOND$LAST$BLOCKNO, SECOND$LAST$BYTENO) ADDRESS;
DCL CMND$PTR ADDRESS;

CALL READ (1, .MEMORY, 128, .ACTUAL, .STATUS); /* Skip command tail. */
CALL SEEK (1, 0, .CUR$BLOCKNO, .CUR$BYTENO, .STATUS); /* Current point. */
IF STATUS <> 0 THENDO /* Can't seek, probably not in submit. */
	CALL EXIT;
IFEND;
CALL SEEK (1, 4, .EOF$BLOCKNO, .EOF$BYTENO, .STATUS); /* Seek to EOF. */
CALL SEEK (1, 0, .EOF$BLOCKNO, .EOF$BYTENO, .STATUS);
CALL SEEK (1, 2, .CUR$BLOCKNO, .CUR$BYTENO, .STATUS); /* Back up. */
SECOND$LAST$BLOCKNO, LAST$BLOCKNO = CUR$BLOCKNO;
SECOND$LAST$BYTENO, LAST$BYTENO = CUR$BYTENO;
DO WHILE TRUE;
	CALL WRITE (0, .('#'), 1, .STATUS);
	CALL READ (1, .MEMORY, 128, .ACTUAL, .STATUS);
	IF (STATUS <> 0) OR (ACTUAL = 0) THENDO
		CALL EXIT;
	IFEND;
	CALL SEEK (1, 0, .BLOCKNO, .BYTENO, .STATUS);
	IF (BLOCKNO = EOF$BLOCKNO) AND (BYTENO = EOF$BYTENO - 1) THENDO
		CALL SEEK (1, 2, .LAST$BLOCKNO, .LAST$BYTENO, .STATUS);
		/* see if this is an "END JOB" line */
		CALL READ (1, .MEMORY, 128, .ACTUAL, .STATUS);
		IF (STATUS <> 0) OR (ACTUAL = 0) THENDO
			CALL EXIT;
		IFEND;
		MEMORY (ACTUAL - 1) = CR;
		CALL FORCE$UPPER (.MEMORY);
		CMND$PTR = DEBLANK (.MEMORY);
		IF SEQ (CMND$PTR, .('END JOB'), 7) THENDO
			LAST$BLOCKNO = SECOND$LAST$BLOCKNO;
			LAST$BYTENO = SECOND$LAST$BYTENO;
		IFEND;
		CALL SEEK (1, 2, .LAST$BLOCKNO, .LAST$BYTENO, .STATUS);
		CALL EXIT;
	IFEND;
	SECOND$LAST$BLOCKNO = LAST$BLOCKNO;
	SECOND$LAST$BYTENO = LAST$BYTENO;
	LAST$BLOCKNO = BLOCKNO;
	LAST$BYTENO = BYTENO;
WHILEND;

END RETURN$MOD;
src/sort.plm
SORT: DO;

/************************************************************************/
/*																		*/
/*     'Copyright 1981,1983 Intel Corporation'.  All rights reserved.	*/
/*      No part of this program or publication may be reproduced,		*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

$IF XVERSION
DECLARE PROPRIETARY(*) BYTE DATA ('INTEL PROPRIETARY SOFTWARE');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=X103',0);
$ELSE
DECLARE COPYRIGHT (*) BYTE DATA  ('COPYRIGHT 1981,1983 INTEL ');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.1',0);
$ENDIF


DECLARE
	(MEM$SIZE,ITEM$SIZE) ADDRESS,
	ITEM$PTR ADDRESS, ITEM BASED ITEM$PTR (1) ADDRESS,
	FIELD(10) STRUCTURE(FIRST ADDRESS,LAST ADDRESS),
	(NR,NF,NI,AFTN1,AFTN2,STATUS,I) ADDRESS,
	BPTR ADDRESS, BUF BASED BPTR BYTE;

DECLARE
	TRUE LITERALLY '0FFH',
	FALSE LITERALLY '0',
	HT LITERALLY '08H',
	CR LITERALLY '0DH',
	LF LITERALLY '0AH',
	CI$AFTN LITERALLY '1',
	CO$AFTN LITERALLY '0';

ERROR: PROCEDURE(A) EXTERNAL; DECLARE(A) ADDRESS; END;
EXIT: PROCEDURE EXTERNAL; END;
READ: PROCEDURE(A,B,C,D,E) EXTERNAL; DECLARE(A,B,C,D,E) ADDRESS; END;
WRITE: PROCEDURE(A,B,C,D) EXTERNAL; DECLARE(A,B,C,D) ADDRESS; END;
CLOSE: PROCEDURE(A,B) EXTERNAL; DECLARE(A,B) ADDRESS; END;
OPEN: PROCEDURE(A,B,C,D,E) EXTERNAL; DECLARE(A,B,C,D,E) ADDRESS; END;
SEEK: PROCEDURE(A,B,C,D,E) EXTERNAL; DECLARE(A,B,C,D,E) ADDRESS; END;
MEMCK: PROCEDURE ADDRESS EXTERNAL; END;


FIND$EOL: PROCEDURE(PTR) ADDRESS;
	DECLARE PTR ADDRESS, CH BASED PTR BYTE;
	DO WHILE (CH<>LF) AND PTR+1<NR;
		PTR=PTR+1;
	END;
	RETURN PTR+1;
END FIND$EOL;


STAT: PROCEDURE(STATUS);
	DECLARE STATUS ADDRESS;
	IF STATUS<>0 THEN DO;
		CALL ERROR(STATUS);
		CALL WRITE(CO$AFTN,.('Command syntax is:',CR,LF),20,.STATUS);
		CALL WRITE(CO$AFTN,.('SORT file1 [TO file2] [col1[,col2]] ...',CR,LF),
			41,.STATUS);
		CALL EXIT;
	END;
END STAT;


SHELL$SORT: PROCEDURE;
	/* FROM KNUTH VOL 3, TRANSFORMED FOR ZERO-BASED ARRAYS */
	DECLARE
		HA(9) ADDRESS DATA (0,1,4,13,40,121,364,1093,3280),
		H ADDRESS,
		(S,T) BYTE,
		(I,J,K) ADDRESS;

	GREATER$THAN$OR$EQUAL: PROCEDURE(S1P,S2P) BYTE;
		DECLARE (S1P,S2P) ADDRESS,
			S1 BASED S1P(1) BYTE,
			S2 BASED S2P(1) BYTE,
			(I,J) ADDRESS,
			(T1,T2) BYTE;
		DO J=0 TO NF;
			DO I=FIELD(J).FIRST TO FIELD(J).LAST;
				IF (T1:=S1(I))<(T2:=S2(I)) THEN RETURN FALSE;
				IF T1>T2 THEN RETURN TRUE;
				IF T1=LF AND FIELD(J).LAST=0FFFFH THEN I=0FFFFH;
			END;
		END;
		RETURN TRUE;
	END GREATER$THAN$OR$EQUAL;

	/* CALCULATE T */
	T=0; S=1;
	DO WHILE T=0;
		IF HA(S+2)>NI THEN T=S;
		S=S+1;
	END;
	/* LOOP ON S */
	S=T;
	DO WHILE S>0;
		H=HA(S);
		J=H;
		DO WHILE J<=NI;
			I=J; K=ITEM(J);
			DO WHILE I>=H;
				I=I-H;
				IF GREATER$THAN$OR$EQUAL(K,ITEM(I)) THEN DO;
					ITEM(I+H)=K;
					GO TO L1; /* SORRY ABOUT THAT */
				END;
				ITEM(I+H)=ITEM(I);
			END;
			ITEM(I)=K;
		L1:	J=J+1;
		END;
		S=S-1;
	END;
END SHELL$SORT;


DEBLANK: PROCEDURE(PTR) ADDRESS;
	DECLARE PTR ADDRESS, CH BASED PTR BYTE;
	DO WHILE CH=' ' OR CH=HT;
		PTR=PTR+1;
	END;
	RETURN PTR;
END DEBLANK;


DELIMIT: PROCEDURE(PTR) ADDRESS;
	DECLARE PTR ADDRESS, CH BASED PTR BYTE;
	DO WHILE (CH>='A' AND CH<='Z') OR (CH>='a' AND CH<='z') OR
			(CH>='0' AND CH<='9') OR CH='.' OR CH=':';
		PTR=PTR+1;
	END;
	RETURN PTR;
END DELIMIT;


READ$FIELD: PROCEDURE ADDRESS;
	DECLARE I ADDRESS;
	IF BUF<'0' OR BUF>'9' THEN CALL STAT(201);
	I=0;
	DO WHILE BUF>='0' AND BUF<='9';
		I=I*10+(BUF-'0');
		BPTR=BPTR+1;
	END;
	IF I=0 THEN CALL STAT(201);
	BPTR=DEBLANK(BPTR);
	RETURN I;
END READ$FIELD;


/* SORT FILE1 TO FILE2 [FIELD[,FIELD] ...] */
$IF XVERSION
	CALL WRITE(CO$AFTN,.('ISIS-II SORT, X103',CR,LF),20,.STATUS);
$ELSE
	CALL WRITE(CO$AFTN,.('ISIS-II SORT, V1.1',CR,LF),20,.STATUS);
$ENDIF
	MEM$SIZE=MEMCK-.MEMORY;
	CALL READ(CI$AFTN,.MEMORY,128,.I,.STATUS);
	AFTN1,AFTN2,BPTR=DEBLANK(.MEMORY);
	BPTR=DEBLANK(DELIMIT(BPTR));
	IF BUF='T' OR BUF='t' THEN DO;
		BPTR=BPTR+1;
		IF BUF='O' OR BUF='o' THEN DO;
			AFTN2=DEBLANK(BPTR+2);
			BPTR=DEBLANK(DELIMIT(AFTN2));
		END;
		ELSE CALL STAT(233);
	END;
/*	THIS SECTION OF CODE READS THE FIELDS BY WHICH THE USER WANTS HIS 
	TEXT SORTED.  ON THE COMMAND LINE, THE USER CAN ENTER A CARRIAGE 
	RETURN, ONE NUMBER, OR TWO NUMBERS SEPARATED BY A COMMA.  LET THE 
	CHARACTER @ BE A BLANK OR A CARRIAGE RETURN, 'END' MEANS THAT 
	NO MORE FIELDS ARE EXPECTED, AND 'CONT' MEANS THAT MORE FIELDS 
	MAY OCCUR UNLESS THERE ARE ALREADY TEN FIELDS.  THEN THE FOLLOWING 
	RESPONSES ARE POSSIBLE AND WILL PRODUCE THE RESULTS SHOWN:  (NOTE 
	THAT THE FIRST COLUMN OF A LINE IS NUMBER 1, AND A NUMBER ZERO IS
	INVALID.)

				FIELD- @		END.  IF NO FIELDS HAVE BEEN DEFINED, THEN
								DEFINE ONE FIELD WITH THE DEFAULT VALUES
								1 AND EOL.
				FIELD- N@		CONT, WITH THE SORT FIELD STARTING AT COLUMN 
								N AND GOING TO THE END OF LINE.
				FIELD- N,M@		CONT, WITH THE SORT FIELD STARTING AT COLUMN 
								N AND GOING TO COLUMN M.  EOL'S ARE IGNORED.

	NOTE THAT TO USE A SINGLE COLUMN AS THE SORT FIELD, THE COLUMN NUMBER
	MUST BE ENTERED TWICE.  E.G.  FIELD- 3,3@   WILL USE ONLY COLUMN
	THREE FOR THIS SORT FIELD.  THE PRECEDENCE OF THE SORT FIELDS IS THE
	SAME AS THEIR ORDER OF ENTRY.
*/
	NF=0; FIELD(0).FIRST=0; FIELD(0).LAST=0FFFFH;
	DO WHILE NF<=LAST(FIELD) AND BUF<>CR;
		FIELD(NF).FIRST=READ$FIELD-1;
		IF BUF=',' THEN DO;
			BPTR=DEBLANK(BPTR+1);
			FIELD(NF).LAST=READ$FIELD-1;
			IF FIELD(NF).LAST<FIELD(NF).FIRST THEN CALL STAT(201);
		END;
		ELSE FIELD(NF).LAST=0FFFFH;
		IF BUF<>CR THEN NF=NF+1;
	END;
	IF AFTN1=AFTN2 THEN DO; /* SORTING TO SAME FILE */
		CALL OPEN(.AFTN2,AFTN1,3,0,.STATUS); /* UPDATE MODE */
		AFTN1=AFTN2;
	END;
	ELSE DO;
		CALL OPEN(.AFTN1,AFTN1,1,0,.STATUS);
		CALL STAT(STATUS);
		CALL OPEN(.AFTN2,AFTN2,2,0,.STATUS);
	END;
	CALL STAT(STATUS);
	CALL READ(AFTN1,.MEMORY,MEM$SIZE,.I,.STATUS);
	CALL STAT(STATUS);
	IF I>0 THEN DO; /* WE HAVE SOMETHING TO SORT */
		IF I=MEM$SIZE THEN CALL STAT(210);
		NR,ITEM$PTR=.MEMORY(I);
		ITEM$SIZE=(MEMCK-ITEM$PTR)/2;
		NI=0; ITEM(0)=.MEMORY;
		DO WHILE ITEM(NI)<NR;
			NI=NI+1;
			IF NI>ITEM$SIZE THEN CALL STAT(210);
			ITEM(NI)=FIND$EOL(ITEM(NI-1));
		END;
		NI=NI-1;
		CALL SHELL$SORT;
		IF AFTN1=AFTN2 THEN DO; /* SORTING TO SAME FILE */
			CALL SEEK(AFTN2,2,.(0,0),.(0,0),.STATUS); /* REWIND FILE */
			CALL STAT(STATUS);
		END;
		DO I=0 TO NI;
			CALL WRITE(AFTN2,ITEM(I),FIND$EOL(ITEM(I))-ITEM(I),.STATUS);
			CALL STAT(STATUS);
		END;
	END;
	CALL CLOSE(AFTN1,.STATUS);
	CALL STAT(STATUS);
	IF AFTN1<>AFTN2 THEN DO;
		CALL CLOSE(AFTN2,.STATUS);
		CALL STAT(STATUS);
	END;
	CALL EXIT;
END SORT;
src/sort2.asm
$MACROFILE NOGEN

;     'Copyright 1981,1983 Intel Corporation'.  All rights reserved.
;      No part of this program or publication may be reproduced,
;      transmitted, transcribed, stored in a retrievel system, or
;      translated into any language or computer language, in any
;      form or by any means, electronic, mechanical, magnetic,
;      optical, chemical, manual or otherwise, without the prior
;      written permission of Intel Corporation, 3065 Bowers
;      Avenue, Santa Clara, California, 95051, Attn: Software
;      License Administration.

; SORT: PROCEDURE (PTR,COUNT,PROC$ADDR) EXTERNAL;
;   DECLARE (PTR,COUNT,PROC$ADDR) ADDRESS;
; END;
;
; SORT ACCEPTS AN ARRAY OF POINTERS AND SORTS THE POINTERS.
;   "COUNT" IS THE NUMBER OF POINTERS.
;   "PTR" IS THE LOCATION OF THE POINTERS
;   "PROC$ADDR" IS THE ADDRESS OF THE FOLLOWING PROCEDURE:
;
; GREATER$THAN: PROCEDURE (PTR1,PTR2);
;   DECLARE (PTR1,PTR2) ADDRESS;
;   ...
; END;
;
; "GREATER$THAN" ACCEPTS AS INPUT TWO POINTERS INTO THE ARRAY
;   OF POINTERS.  IT RETURNS TRUE IFF THE RECORD ASSOCIATED
;   WITH PTR1 IS GREATER THAN THE RECORD ASSOCIATED WITH PTR2.
;
; SORT SORTS THE POINTERS SO THAT THE ASSOCIATED RECORDS ARE IN
;   INCREASING ORDER.
$EJECT
        NAME SORT
        CSEG
        PUBLIC SORT

        MIDPOINT MACRO  ;; LOCATE POINTER IN THE MIDDLE OF THE ARRAY
        MOV A,L
        ADD E
        MOV C,A
        MOV A,H
        ADC D           ;; AC NOW EQUALS (HL+DE) -- NOW DIVIDE BY 2
        RAR
        MOV B,A
        MOV A,C
        RAR             ;; BA NOW EQUALS (HL+DE)/2 -- NOW INSURE THAT IT
                        ;;   HAS THE SAME PARITY AS ALL THE OTHER POINTERS
        XRA L
        ANI 0FEH
        XRA L
        MOV C,A         ;; BC IS THE ANSWER.
        ENDM

        CENTER MACRO    ;;SET HA TO (HL+BC)/2
        DAD B
        MOV A,H
        RAR
        MOV H,A
        MOV A,L
        RAR
        ENDM

        JFALSE MACRO PARAM    ;; JUMP IF BCGTDE WAS FALSE I.E. IF BC <= DE
        JNC PARAM
        ENDM

        SKIP1 MACRO        ;; SKIP NEXT 1 INSTRUCTION BYTE  -- WIPES OUT A
        DB (MVI A,0)
        ENDM

        SKIP2 MACRO        ;; SKIP NEXT 2 INSTRUCTION BYTES  -- WIPES OUT HL
        DB (LXI H,0)
        ENDM

        IFCROSS MACRO ADR  ;; JUMP TO ADR IF BC AND DE HAVE CROSSED.
        MOV A,E
        SUB C
        MOV A,D
        SBB B
        JC ADR
        ENDM
$EJECT
SORT:                 ; BC=COUNT   DE=PROC$ADDR   HL=???   S1=RET   S2=PTR
        XCHG
        SHLD PADDR    ; BC=COUNT   DE=???   HL=PROC$ADDR
        POP H
        XTHL          ; BC=COUNT   DE=???   HL=PTR
        MOV D,H
        MOV E,L       ; BC=COUNT   DE=START$PTR   HL=START$PTR
        DAD B
        DAD B
        DCX H
        DCX H
        XCHG          ; BC=COUNT   DE=END$PTR   HL=START$PTR

HDSORT:                ; INTERIOR SORT ROUTINE WHICH IS CALLED RECURSIVELY.
                      ; SORTS POINTERS AT HL THRU DE.     A,B,C IGNORED.

        MOV A,E
        SUB L
        MOV C,A
        MOV A,D
        SBB H
        RC            ; RETURN IF END$PTR < START$PTR
        ORA C
        RZ            ;   ...OR IF END$PTR = START$PTR
$EJECT
; THE TOPMOST POINTER IS GOING TO BE SWITCHED INTO ITS FINAL POSITION ON
; THE NEXT PAGE.  ON THIS PAGE, WE INCREASE THE PROBABILITY THAT THAT
; FINAL POSITION IS NEAR THE MIDDLE.  THIS SPEEDS THINGS UP.  WE DO SO
; BY LOOKING AT THE BOTTOM, MID, AND TOP POINTERS, AND SWITCHING THE
; SECOND HIGHEST OF THE THREE TO THE TOP POSITION.

                      ; POINTER ARRAY LOOKS LIKE THIS:
                      ; HL . . .    . . . DE
        PUSH H        ; S1 . . .    . . . DE
        MIDPOINT      ; S1 . . . BC . . . DE
        CALL BCGTDE
        CC SWITCH     ; GUARANTEES MID < TOP
        POP H         ; HL . . . BC . . . DE
        PUSH B        ; HL . . . S1 . . . DE
        MOV B,H
        MOV C,L       ; BC . . . S1 . . . DE
        CALL BCGTDE   ; BOTTOM > TOP?
        POP H         ; BC . . . HL . . . DE
        JC ALLSET     ; IF SO THEN TOP IS ALREADY GOOD
        XCHG          ; BC . . . DE . . . HL
        PUSH H        ; BC . . . DE . . . S1
        CALL BCGTDE
        CNC SWITCH    ; GUARANTEES TOP > BOTTOM > MID
        POP D         ; BC . . .    . . . DE
        CALL SWITCH   ; NOW BOTTOM > TOP > MID   SO TOP IS GOOD.
ALLSET:
        PUSH B
        PUSH D        ; S2=BC . . . . . . S1=DE
$EJECT
; IN THIS STAGE, SWITCHES OF POINTERS ARE MADE UNTIL THERE IS A
; SINGLE POINTER IN ITS FINAL POSITION, WITH ALL LESSER POINTERS
; TO THE LEFT AND ALL GREATER POINTERS TO THE RIGHT.

CMPF:
        CALL BCGTDE
        JFALSE CRUZF
        CALL SWITCH
CRUZB:
        DCX D
        DCX D
        IFCROSS RCURS2
CMPB:
        CALL BCGTDE
        JFALSE CRUZB
        CALL SWITCH
CRUZF:
        INX B
        INX B
        IFCROSS RCURS1

        JMP CMPF
$EJECT
; NOW WE CAN SPLIT THE SORT INTO TWO HALF SORTS AND DO THE HALF SORTS
; BY RECURSION.
; AN ADJUSTMENT OF BC OR DE MUST FIRST BE MADE, DEPENDING ON THE ENTRY POINT.

RCURS1:                  ; S2 . . . . . DE BC . . . . . S1
                         ;             GOOD
        DCX D
        DCX D
        SKIP2
RCURS2:                  ; S2 . . . . . DE BC . . . . . S1
                         ;                GOOD
        INX B
        INX B

; NOW COMPUTE WHICH HALF IS SMALLER AND DO IT FIRST.

RCURS:                   ; S2 . . . . . DE GOOD BC . . . . . S1
        MOV H,B
        MOV L,C
        POP B            ; S1 . . . . . DE      HL . . . . . BC
        XTHL             ; HL . . . . . DE      S1 . . . . . BC
        PUSH H           ; S1 . . . . . DE      S2 . . . . . BC
        CENTER
        SUB E
        MOV A,H
        SBB D
        POP H            ; HL . . . . . DE      S1 . . . . . BC
        JNC LEFT
RIGHT:
        XTHL             ; S1 . . . . . . DE   HL . . . BC
        PUSH D           ; S2 . . . . . . S1   HL . . . BC
        MOV D,B
        MOV E,C          ; S2 . . . . . . S1   HL . . . DE
        SKIP1
LEFT:
        PUSH B           ; HL . . . DE   S2 . . . . . . S1

        CALL HDSORT       ; SORT THE FIRST HALF
        POP D
        POP H            ; POP OFF THE POINTERS TO THE OTHER HALF
        JMP HDSORT        ; SORT THE OTHER HALF
$EJECT

SWITCH:           ; SWITCH WORD POINTED AT BY BC WITH WORD POINTED AT BY DE
                  ; SAVE B,C,D,E

        MOV H,B
        MOV L,C
        LDAX D
        MOV C,M
        MOV M,A
        XCHG
        MOV M,C
        INX H
        INX D
        LDAX D
        MOV C,M
        MOV M,A
        XCHG
        MOV M,C
        DCX D
        DCX H
        MOV C,L
        RET

        DSEG
BCGTDE:                  ; CALL EXTERNALLY-PASSED "BC GREATER THAN DE"
                         ; ROUTINE SO AS TO PRESERVE B,C,D,E AND RETURN
                         ; THE ANSWER IN THE CARRY FLAG (CARRY=TRUE)

        PUSH B
        PUSH D
        DB (CALL 0)
PADDR:
        DW 0
        RAR
        POP D
        POP B
        RET

        STKLN 100

$EJECT
        END
src/stopif.plm
$ TITLE('=====>>>  STOPIF   <<<=====')

STOPIF: DO;

/************************************************************************/
/*																		*/
/*     'Copyright 1981,1983 Intel Corporation'.  All rights reserved.	*/
/*      No part of this program or publication may be reproduced,		*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

$IF XVERSION
DECLARE PROPRIETARY(*) BYTE DATA ('INTEL PROPRIETARY SOFTWARE');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=X107',0);
$ELSE
DECLARE COPYRIGHT (*) BYTE DATA  ('COPYRIGHT 1981,1983 INTEL ');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.1',0);
$ENDIF

    
      
/* THIS IMPROVED VERSION OF STOPIF IS DESIGNED TO RUN WITH THE ASSEMBLERS AS
WELL AS PL/M.  ADDITIONALLY, THE PRESENCE OF A PAGE BREAK SHOULD NOT FOUL UP
STOPIF. */
/* MODIFICATION:  20 Sept 1982 by M. L. - scans back upto 1024
                  characters for ERROR line; this lookback amount is 
                  a compile time constant (simply set MAX$BUFFER$SIZE).

   MODIFICATION:  23 Sept 1982 by M. L. - 1) generalized error or 
                  warning message searching task in order to support
                  all of the existing compilers' and assemblers' listings.
                  2) implement IGNORE WARNING switch.
*/
                  

/* LITERALLY DEFINITIONS */

  DECLARE
    TRUE LITERALLY '0FFH',
    FALSE LITERALLY '0',
    WORD LITERALLY 'ADDRESS',
    POINTER LITERALLY 'ADDRESS',
    CR LITERALLY '0DH',
    LF LITERALLY '0AH',
    TAB LITERALLY '09H',
    FF LITERALLY '0CH',
    BELL LITERALLY '07H',
    BOOLEAN LITERALLY 'BYTE',
    esc literally '1bH',

    error$or$warning$found literally '1',
    no$error$or$warning literally '2',
    non$list$file literally '3',
    space literally '20H',
    max$buffer$size literally '1024',
    max$num$blocks literally '(max$buffer$size/128)';


/* EXTERNAL PROCEDURES FROM ISIS */

OPEN: PROCEDURE(AFTN$P,FILENAME$P,ACCESS,MODE,STATUS$P) EXTERNAL;
  DECLARE (AFTN$P,FILENAME$P,STATUS$P) POINTER, (ACCESS,MODE) WORD; END;
READ: PROCEDURE(AFTN,BUF$P,COUNT,ACTUAL$P,STATUS$P) EXTERNAL;
  DECLARE (AFTN,COUNT) WORD, (BUF$P,ACTUAL$P,STATUS$P) POINTER; END;
WRITE: PROCEDURE(AFTN,BUF$P,COUNT,STATUS$P) EXTERNAL;
  DECLARE (AFTN,COUNT) WORD, (BUF$P,STATUS$P) POINTER; END;
SEEK: PROCEDURE(AFTN,MODE,BLOCKNO$P,BYTENO$P,STATUS$P) EXTERNAL;
  DECLARE (AFTN,MODE) WORD, (BLOCKNO$P,BYTENO$P,STATUS$P) POINTER; END;
ERROR: PROCEDURE (NUMBER) EXTERNAL; DECLARE NUMBER WORD; END;
EXIT: PROCEDURE EXTERNAL; END;
WHOCON: PROCEDURE(AFTN,FILE$NAME$P) EXTERNAL;
  DECLARE AFTN WORD, FILENAME$P POINTER; END;
CONSOL: PROCEDURE(INFILE$P,OUTFILE$P,STATUS$P) EXTERNAL;
  DECLARE (INFILE$P,OUTFILE$P,STATUS$P) POINTER; END;

/* GLOBAL VARIABLES */

DECLARE
  STATUS WORD, /* FOR CALLS TO ISIS */
  COMMAND$SIZE WORD,
  ACTUAL WORD,
  AFTN WORD,
  (BLOCK$NUMBER, BYTE$NUMBER) WORD,
  BUFFER(MAX$BUFFER$SIZE) BYTE, /* THE LAST 1024 BYTES OF THE LISTING */
  TIMER BYTE, /* FOR TIMING THE BELL */
  COMMAND$TAIL(122) BYTE,
  NON$LIST$MSG (*) BYTE DATA('NOT A LISTING ==> ',0),
  EMSG (*) BYTE DATA ('PROGRAM ERROR IN ',0),
  WMSG (*) BYTE DATA ('PROGRAM WARNING IN ',0),
  ignore$warning  boolean initial (false),
  file$name$length byte,
  find$error byte,
  find$warning byte,
  in$file$ptr address,
  command$ptr address,
  command$ch based command$ptr byte;
  


/* LOCAL PROCEDURES */


CHECK$STATUS: PROCEDURE;

  IF STATUS <> 0
  THEN DO;
    CALL ERROR(STATUS);
    CALL CONSOL(.(':VI: '),.(':VO: '),.STATUS);
    IF STATUS <> 0
    THEN CALL ERROR(STATUS);
    CALL EXIT;
  END;

END CHECK$STATUS;



DISPLAY: PROCEDURE(LEN,BUF) PUBLIC; /* WRITE OUT A BUFFER TO THE CONSOL */

  DECLARE
    LEN WORD, /* THE NUMBER OF CHARACTER TO WRITE OUT */
    BUF ADDRESS; /* THE ADDRESS OF THE BUFFER */

  IF LEN > 0
  THEN DO;

    CALL WRITE(0,BUF,LEN,.STATUS);
    CALL CHECK$STATUS;

  END;

END DISPLAY;



PRINT: PROCEDURE(BUF) PUBLIC;
         /* WRITE OUT A BUFFER TERMINATED BY NULL TO :CO: */

  DECLARE
    BUF ADDRESS, /* ADDRESS OF BUFFER */
    PTR ADDRESS, /* POINTER INTO BUFFER */
    CHAR BASED PTR BYTE; /* CHARACTER IN BUFFER */

  /* SEARCH FOR NULL */
  PTR = BUF;
  DO WHILE CHAR <> 0;
    PTR = PTR + 1;
  END;

  /* print out buffer */
  CALL DISPLAY(PTR - BUF,BUF);

END PRINT;



FAIL: PROCEDURE(MSG$P);

  DECLARE MSG$P POINTER,
          OUT$FILE$NAME(15) BYTE;

  CALL PRINT(MSG$P);
  CALL DISPLAY(file$name$length, in$file$ptr);
  call print(.(cr,lf,0));
  CALL WHOCON(0,.OUT$FILE$NAME);
  CALL CONSOL(.(':VI: '),.(':VO: '),.STATUS);
  CALL CHECK$STATUS;
  IF OUT$FILE$NAME(1) <> 'V' /* VIDEO OUTPUT */
  THEN DO;
    CALL PRINT(MSG$P);
    CALL DISPLAY(file$name$length, in$file$ptr);
  END;
  CALL PRINT(.(CR,LF,0));
  DO TIMER = 1 TO 80;
    CALL DISPLAY(1,.(BELL));
    CALL TIME(250);
  END;
  CALL EXIT;

END FAIL;



capitalize: procedure (buff$ptr, len);

  declare buff$ptr pointer,
          len word,
          buff based buff$ptr (1) byte,
          i word;

  i = 0;
  do while i < len;
    if buff(i) >= 'a' and buff(i) <= 'z' then
      buff(i) = buff(i) - 20H;
    i = i + 1;
  end;

end capitalize;



READ$BUF: PROCEDURE;

  if block$number < max$num$blocks then
    block$number, byte$number = 0;
  else
    block$number = block$number - max$num$blocks;

  call seek(aftn, 2, .block$number, .byte$number, .status);
  call check$status;
  
  CALL READ(AFTN, .BUFFER, max$buffer$size, .ACTUAL, .STATUS);
  CALL CHECK$STATUS;

  call capitalize(.buffer, actual);

END READ$BUF;



cmp: procedure (str$ptr$1, str$ptr$2, count) boolean; 

  /* compare strings */

  declare (str$ptr$1, str$ptr$2) pointer,
          str$1 based str$ptr$1 (1) byte,
          str$2 based str$ptr$2 (1) byte,
          (count, j) byte;

  j = 0;
  do while j < count  ;
    if str$1(j) <> str$2(j) then
      return false;
    else
      j = j + 1;
  end;
  return true;
  
end cmp;



digit: procedure (ch) boolean;

  declare ch byte;

  if (ch >= '0') and (ch <= '9') then 
    return true;
  else
    return false;

end digit;



search: procedure (search$str$ptr) byte;

  /* returns:
     error$or$warning$found -  If search$str is found and there is a non-zero 
                         number preceding it.
     no$error$or$warning -  If search$str is found and either '0' or 
                         'NO' preceds it.
     non$list$file -  If search$str is not found  */
     

  declare search$str$ptr pointer,  /* points to (5,'ERROR')   */
                                   /*        or (7,'WARNING') */
  
          search$str based search$str$ptr (1) byte, 
          i word;

  if actual = 0 then
    return non$list$file;
  if actual <= search$str(0) then
    i = actual - 1;
  else
    i = actual - search$str(0) - 1;
    
  do while i > 0;
    if cmp(.buffer(i), .search$str(1), search$str(0))  then
      do;
        /* back up and search for '0' or 'NO' */

        do while i > 0;
          i = i - 1;
          if digit(buffer(i)) then
            do;
              do while digit(buffer(i)) and i > 0;
                i = i - 1;
              end;

              if i = 0 then
                /* not enough room in buffer to backup,
                   so pretend string is never found */
                return non$list$file;
              else
                if buffer(i+1) > '0'  then 
                  return error$or$warning$found;
                else
                  return no$error$or$warning;
            end;
          else
            if cmp(.buffer(i), .('NO'), 2)  then
              return no$error$or$warning;
        end;

         /* Even though the target string is found, number of errors  
            or word 'NO' is not found. It will be considered as a 
            non-listing file.  */
        return non$list$file;

      end;  /* string not found */
    i = i - 1;
  end;
  return non$list$file;

end search;



deblanks:  procedure (buff$ptr) address;

  declare buff$ptr address,
          buff based buff$ptr byte;

  do while buff = space;
    buff$ptr = buff$ptr + 1;
  end;
  return buff$ptr;
  
end deblanks;



scan$blanks:  procedure (buff$ptr) address;

  declare buff$ptr address,
          buff based buff$ptr byte;

  do while (buff <> space) and (buff <> cr) and (buff <> esc);
    buff$ptr = buff$ptr + 1;
  end;
  return buff$ptr;
  
end scan$blanks;



/**************  MAIN BEGIN ******************/

/* READ COMMAND TAIL */
CALL READ(1,.COMMAND$TAIL,128,.COMMAND$SIZE,.STATUS);
CALL CHECK$STATUS;

call capitalize(.command$tail, command$size);
in$file$ptr = deblanks(.command$tail);
command$ptr = scan$blanks(in$file$ptr);
file$name$length = command$ptr - in$file$ptr;

call open(.aftn, in$file$ptr, 1, 0, .status);
if status = 13 then 
  call fail(.('NO SUCH FILE ==> ', 0));
else
  if status = 4 or status = 5 or status = 23 or status = 28 then
    call fail(.('ILLEGAL FILENAME SPECIFICATION ==> ', 0));
  else
    call check$status;

command$ptr = deblanks(command$ptr);
if command$ch <> cr then
  do;
    if cmp(command$ptr, .('IW'), 2) or
       cmp(command$ptr, .('IGNOREWARNING'), 13)  then
       ignore$warning = true;
    else
       ignore$warning = false;
  end;
  
  
    
CALL SEEK(AFTN,4,.BLOCK$NUMBER,.BYTE$NUMBER,.STATUS);
CALL CHECK$STATUS;

CALL SEEK(AFTN,0,.BLOCK$NUMBER,.BYTE$NUMBER,.STATUS);

call read$buf;
BUFFER(actual) = CR;

find$error = search(.(5,'ERROR'));

if find$error = error$or$warning$found  then
  call fail(.emsg);
else
  if find$error = no$error$or$warning  then
    do;
      if ignore$warning then
        call exit;
      else
        find$warning = search(.(7,'WARNING'));
        if find$warning = error$or$warning$found  then
          call fail(.wmsg);
        else
          call exit;
    end;
  else
    call fail(.non$list$msg);
        

END STOPIF;
src/tail.plm
TAIL:DO;


/************************************************************************/
/*																		*/
/*     'Copyright 1981,1983 Intel Corporation'.  All rights reserved.	*/
/*      No part of this program or publication may be reproduced,		*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/


/* THIS MODULE SCANS THE COMMAND TAIL AND OPENS ALL THREE FILES */

DECLARE
  TRUE LITERALLY '0FFH',
  FALSE LITERALLY'0',
  CR LITERALLY'0DH', /* CARRIAGE RETURN */
  LF LITERALLY'0AH', /* LINE FEED */

  LINE(128) BYTE, /* COMMAND LINE */
  DIGITS(6) BYTE, /* USED FOR PRINTING SYNCPARM */
  PTR ADDRESS, /* CURSOR POSITION IN SCANNING COMMAND LINE */
  CHAR BASED PTR BYTE, /* CHARACTER IN COMMAND LINE */
  LEXLEN BYTE, /* LENGTH OF CURRENT LEXEME */
  LEXPTR ADDRESS, /* POINTER AT CURRENT LEXEME */
  LEXCHAR BASED LEXPTR BYTE, /* CHARACTER IN LEXEME */
  FILE$NAME$0(15) BYTE EXTERNAL,
  FILE$NAME$1(15) BYTE EXTERNAL,
  OUT$FILE$NAME(15) BYTE INITIAL('               '),
  AFTN0 ADDRESS EXTERNAL, /* AFTN FOR FILE1 */
  AFTN1 ADDRESS EXTERNAL, /* AFTN FOR FILE2 */
  OUT$AFTN ADDRESS EXTERNAL, /* AFTN FOR OUTPUT FILE */
  SYNCPARM BYTE EXTERNAL,
  ACTUAL ADDRESS PUBLIC, /* NUMBER OF CHARACTERS READ IN */
  STATUS ADDRESS PUBLIC;

OPEN: PROCEDURE(AFTN,FILE,ACCESS,MODE,STATUS) EXTERNAL;
  DECLARE(AFTN,FILE,ACCESS,MODE,STATUS) ADDRESS;
END OPEN;

ERROR: PROCEDURE(NUMBER) EXTERNAL;
  DECLARE NUMBER ADDRESS;
END ERROR;

READ: PROCEDURE(AFTN,BUF,COUNT,ACTUAL,STATUS) EXTERNAL;
  DECLARE(AFTN,BUF,COUNT,ACTUAL,STATUS) ADDRESS;
END READ;

WRITE: PROCEDURE(AFTN,BUF,COUNT,STATUS) EXTERNAL;
  DECLARE(AFTN,BUF,COUNT,STATUS) ADDRESS;
END WRITE;

EXIT: PROCEDURE EXTERNAL;
END EXIT;

DISPLAY: PROCEDURE (LEN,BUFFER) EXTERNAL;
  DECLARE
    LEN BYTE,
    BUFFER ADDRESS;
END DISPLAY;

NEW$LINE: PROCEDURE EXTERNAL;
END NEW$LINE;

DUMP: PROCEDURE EXTERNAL;
END DUMP;

CONVND: PROCEDURE(NUMBER,DIGITS) EXTERNAL;
  DECLARE (NUMBER,DIGITS) ADDRESS;
END CONVND;

CHECK$STATUS: PROCEDURE PUBLIC;

  /* CHECK STATUS AND IF NONZERO DON'T RETURN */

  IF STATUS<>0 THEN
    DO;
      CALL ERROR(STATUS);
      CALL EXIT;
    END;

END CHECK$STATUS;

SYN$ERR: PROCEDURE;

  /* REPORT FATAL SYNTAX ERROR. */

  CALL WRITE(0,.('COMMAND FORMAT: <FILE1> TO <FILE2>&',CR,LF,
            '[ PRINT( <FILE> ) ]  [ SYNC ( <NUMBER> ) ]',CR,LF),81,.STATUS);
  CALL CHECKSTATUS;
  CALL EXIT;

END SYN$ERR;

SCAN: PROCEDURE;

/* PROCEDURE TO RETURN THE NEXT LEXEME IN THE COMMAND TAIL */

  /* SKIP BLANKS AND COMMAS */
  DO WHILE (CHAR = ' ') OR (CHAR = '&');
    IF CHAR = '&' /* REPROMPT AND READ IN NEW LINE */
    THEN DO;
      CALL WRITE(0,.('**'),2,.STATUS);
      CALL CHECK$STATUS;
      CALL READ(1,.LINE,128,.ACTUAL,.STATUS);
      CALL CHECK$STATUS;
      PTR = .LINE;
    END;
    ELSE PTR = PTR + 1;
  END;
  LEXPTR = PTR;
  IF (CHAR = '(') OR (CHAR = ')') OR (CHAR = CR)
  THEN DO;
    LEXLEN = 1;
    PTR = PTR + 1;
    RETURN;
    END;
  LEXLEN = 0;
  /* ISOLATE COMMAND WORD */
  DO WHILE (CHAR <> ' ') AND (CHAR <> '(') AND (CHAR <> ')')
       AND (CHAR <> '&') AND (CHAR <> CR);
    IF CHAR > 60H /* LOWER CASE */
    THEN CHAR = CHAR - 20H; /* RAISE CASE */
    PTR = PTR + 1;
    LEXLEN = LEXLEN + 1;
  END;

END SCAN;

EQUAL: PROCEDURE(LEN1,PTR1,LEN2,PTR2) BYTE;

/* PROCEDURE TO TEST IF TWO STRINGS ARE EQUAL */

  DECLARE
    LEN1 BYTE, /* LENGTH OF STRING 1 */
    LEN2 BYTE, /* LENGTH OF STRING 2 */
    PTR1 ADDRESS, /* ADDRESS OF STRING 1 */
    PTR2 ADDRESS, /* ADDRESS OF STRING 2 */
    CHAR1 BASED PTR1 BYTE, /* CHARACTER IN STRING 1 */
    CHAR2 BASED PTR2 BYTE, /* CHARACTER IN STRING 2 */
    I BYTE; /* LOOP INDEX */
  IF LEN1 <> LEN2 THEN RETURN FALSE;

  DO I = 1 TO LEN1;
    IF CHAR1 <> CHAR2 THEN RETURN FALSE;
    PTR1 = PTR1 + 1;
    PTR2 = PTR2 + 1;
  END;

  RETURN TRUE;

END EQUAL;

COMMAND: PROCEDURE PUBLIC;

/* PROCEDURE TO READ THE COMMAND LINE AND OPEN FILES */

   DECLARE I BYTE; /* LOOP INDEX */

   CALL READ(1,.LINE,128,.ACTUAL,.STATUS);
   CALL CHECK$STATUS;
   PTR = .LINE;
   CALL SCAN;
   CALL MOVE(LEXLEN,LEXPTR,.FILE$NAME$0);
   CALL SCAN;
   IF NOT EQUAL(2,.('TO'),LEXLEN,LEXPTR) THEN CALL SYN$ERR;
   CALL SCAN;
   CALL MOVE(LEXLEN,LEXPTR,.FILE$NAME$1);
   CALL SCAN;
   IF EQUAL(5,.('PRINT'),LEXLEN,LEXPTR)
   THEN DO;
     CALL SCAN;
     IF NOT EQUAL(1,.('('),LEXLEN,LEXPTR) THEN CALL SYN$ERR;
     CALL SCAN;
     CALL MOVE(LEXLEN,LEXPTR,.OUT$FILE$NAME);
     CALL SCAN;
     IF NOT EQUAL(1,.(')'),LEXLEN,LEXPTR) THEN CALL SYN$ERR;
     CALL SCAN;
   END;
   ELSE CALL MOVE(4,.(':CO:'),.OUT$FILE$NAME);
   IF EQUAL(4,.('SYNC'),LEXLEN,LEXPTR)
   THEN DO;
     CALL SCAN;
     IF NOT EQUAL(1,.('('),LEXLEN,LEXPTR) THEN CALL SYN$ERR;
     CALL SCAN;
     SYNCPARM = 0;
     DO I = 1 TO LEXLEN;
       IF (LEXCHAR < 30H) OR (LEXCHAR > 39H) THEN CALL SYN$ERR;
       SYNCPARM = SYNCPARM*10 + LEXCHAR - 30H;
       LEXPTR = LEXPTR + 1;
     END;
     CALL SCAN;
     IF NOT EQUAL(1,.(')'),LEXLEN,LEXPTR) THEN CALL SYN$ERR;
     CALL SCAN;
   END;
   ELSE SYNCPARM = 3;
   IF NOT EQUAL(1,.(CR),LEXLEN,LEXPTR) THEN CALL SYN$ERR;
$IF XVERSION
   CALL WRITE(0,.('ISIS-II SOURCE COMPARE X103',CR,LF,LF),30,.STATUS);
$ELSE
   CALL WRITE(0,.('ISIS-II SOURCE COMPARE V1.1',CR,LF,LF),30,.STATUS);
$ENDIF
   CALL CHECKSTATUS;

CALL OPEN(.AFTN1,.FILE$NAME$1,1,0,.STATUS);    /* OPEN SECOND IN FILE */
CALL CHECK$STATUS;
CALL OPEN(.AFTN0,.FILE$NAME$0,1,0,.STATUS);    /* OPEN FIRST IN FILE */
CALL CHECK$STATUS;
CALL OPEN(.OUT$AFTN,.OUT$FILE$NAME,2,0,.STATUS);    /* OPEN NEW OUT FILE */
CALL CHECK$STATUS;
IF NOT EQUAL(15,.OUT$FILE$NAME,15,.(':CO:           '))
THEN DO;
$IF XVERSION
  CALL DISPLAY(31,.(CR,LF,'ISIS-II SOURCE COMPARE X103',CR,LF));
$ELSE
  CALL DISPLAY(31,.(CR,LF,'ISIS-II SOURCE COMPARE V1.1',CR,LF));
$ENDIF
  CALL DISPLAY(6,.('PRINT('));
  CALL DISPLAY(15,.OUT$FILE$NAME);
  CALL DISPLAY(10,.(')    SYNC('));
  CALL CONVND(SYNCPARM,.DIGITS);
  CALL DISPLAY(3,2+.DIGITS);
  CALL DISPLAY(3,.(')',CR,LF));
  CALL DISPLAY(8,.('FILE 1: '));
  CALL DISPLAY(15,.FILE$NAME$0);
  CALL NEW$LINE;
  CALL DISPLAY(8,.('FILE 2: '));
  CALL DISPLAY(15,.FILE$NAME$1);
  CALL NEWLINE;
  CALL NEWLINE;
  CALL DUMP;
END;
END COMMAND;

END TAIL;
src/tokens.plm
$ TITLE ('==> PASSIF -- TOKENSMOD -- UDI STYLE TOKENIZER <==')

TOKENS$MOD:
DO;

/************************************************************************/
/*																		*/
/*     'Copyright 1981,1983 Intel Corporation'.  All rights reserved.	*/
/*      No part of this program or publication may be reproduced,		*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

$ NOLIST

/*         LIT.INC          */

DECLARE					AS LITERALLY 'LITERALLY',
	AMPERSAND			AS '''&''',
	BELL				AS '07H',
	BLANK				AS '020H',
	BOOLEAN				AS 'BYTE',
	CHK					AS 'CALL CHECK$STATUS',
	CLEAR$CHAR			AS '01CH',
	CO$ECHO$FILE		AS '0F00H',
	COLON				AS ''':''',
	COMMA				AS '02CH',
	CONSOLE$INPUT		AS '1',
	CONSOLE$OUTPUT		AS '0',
	CONTROL$Z			AS '01AH',
	CR					AS '0DH',
	DOT					AS '''.''',
	END$DO				AS 'END',
	END$DO$CASE			AS 'END',
	END$DO$WHILE		AS 'END',
	END$IF				AS '   ',
	END$ITERATED$DO		AS 'END',
	END$LOOP			AS ' ',
	EOF$CHAR			AS 'CONTROL$Z',
	ESC					AS '01BH',
	FALSE				AS '0H',
	FF					AS '0CH',
	FOREVER				AS 'WHILE 1',
	FORMAT$ATTRIBUTE	AS '3',
	HASH$MARK			AS '''#''',
	INIT$STG			AS '(*) BYTE INITIAL',
	LEAD$IN$CHAR		AS '07EH',
	LF					AS '0AH',
	NO$LINE$EDIT		AS '0',
	NULL				AS '0FFFFH',
	OPEN$FOR$READ		AS '1',
	OPEN$FOR$WRITE		AS '2',
	OPEN$FOR$UPDATE		AS '3',
	PUB$STRING			AS '(*) BYTE PUBLIC DATA',
	RESET				AS '0',
	RETURN$MARKER$POS	AS '0',
	SEEK$2$EOF			AS '4',
	SEEK$BACKWARD$BY$N	AS '1',
	SEEK$FORWARD$BY$N	AS '3',
	SEEK$2$N			AS '2',
	SEMICOLON			AS ''';''',
	SET					AS '1',
	STRING				AS '(*) BYTE DATA',
	TAB					AS '09H',
	TRANSFER$CONTROL	AS '1',
	TRUE				AS '0FFH',
	UNDERBAR			AS '''_''',
	USER$CI				AS '0',
	WRITE$PROTECT$ATTRIBUTE 		AS '2',
	ZERO$BIAS			AS '0';

/*        ENDLIT.INC        */


/* ISIS.INC */

READ: PROCEDURE (AFTN,BUFFER,COUNT,ACTUAL,STATUS) EXTERNAL;
	DECLARE (AFTN,BUFFER,COUNT,ACTUAL,STATUS) ADDRESS; END;
RESCAN: PROCEDURE (AFTN,STATUS) EXTERNAL;
	DECLARE (AFTN,STATUS) ADDRESS; END;
WRITE: PROCEDURE (AFTN,BUFFER,COUNT,STATUS) EXTERNAL;
	DECLARE (AFTN,BUFFER,COUNT,STATUS) ADDRESS;	END;

/* END ISIS.INC */

/************************************************************/
/*															*/
/*              LITERALLY'S UNIQUE TO PASSIF                */
/*															*/
/************************************************************/

DECLARE
    MINIMUM$ACCEPTABLE$BANNER$LENGTH 	AS 		'73',
    MAXIMUM$TOKEN$LENGTH				AS		'70',
    BI									AS		'CALL BOMB$IF(STATUS)',

	FIRST$FIELD							AS		'0',
    SECOND$FIELD						AS		'28',
    THIRD$FIELD							AS		'54',

    RIGHT$PARENTHESIS 					AS		''')''',
    LEFT$PARENTHESIS 					AS		'''(''',
    RI									AS		'CALL REPORT$IF',
    UNRECOGNIZED$SWITCH$ERR 			AS		'201',
    QUESTION$MARK						AS		'''?''';


/*	MAIN.INC  */

DECLARE
    ACTUAL ADDRESS EXTERNAL,
    AFTN ADDRESS EXTERNAL,
    COMMAND$TAIL$BUF (250) BYTE EXTERNAL,
    DELIMITER BYTE EXTERNAL,
    FIRST$BLOCK$BUF (128) BYTE EXTERNAL,
    FIRST$OUTPUT$MSG$PTR ADDRESS EXTERNAL,
    FIRST$TIME$THROUGH BOOLEAN EXTERNAL,
    INITIALIZED$BANNER (74) BYTE EXTERNAL,
    PRINT$HASH$MARK BOOLEAN EXTERNAL,
    REPORT$FILE$ACTUAL ADDRESS EXTERNAL,
    REPORT$FILE$AFTN ADDRESS EXTERNAL,
    REPORT$FILE$STRING$BEGINNING ADDRESS EXTERNAL,
    SECOND$OUTPUT$MSG$PTR ADDRESS EXTERNAL,
    STATUS ADDRESS EXTERNAL,
    TMP$FILE$AFTN ADDRESS EXTERNAL,
    TMP$FILE$NAME (15) BYTE EXTERNAL,
    TOK$BUF (80) BYTE EXTERNAL;

DECLARE
    KEY$WORDS (10) STRUCTURE
    (LENGTH							BYTE,
    KEY$WORD	(13)				BYTE,
    PROC$PTR						ADDRESS) EXTERNAL;


/*	END MAIN.INC  */

/*	ERRMSG.INC  */

DECLARE
	BAD$SYNTAX$MSG 				(29)	BYTE	EXTERNAL,
	BOMB$IF$MSG$1    			(12)	BYTE	EXTERNAL,
	BOMB$IF$MSG$2				(40)	BYTE	EXTERNAL,
    DURING$ASSERTION$CHECK$MSG	(50)	BYTE	EXTERNAL,
    PASSIF$INVOKED$BY$MSG       (19)    BYTE    EXTERNAL,
    ZERO$LENGTH$FILE$MSG 		(40)	BYTE	EXTERNAL;

/*	END ERRMSG.INC  */

/*	CLI.INC  */

DECLARE BUF$COUNT BYTE EXTERNAL;
UDI$STRING$MATCH: PROCEDURE (STG$1$PTR,STG$2$PTR) BOOLEAN EXTERNAL;
    DECLARE (STG$1$PTR,STG$2$PTR) ADDRESS; END;

/*	END CLI.INC  */

/*	REPORT.INC  */

BOMB$IF: PROCEDURE (STATUS) EXTERNAL; DECLARE STATUS ADDRESS; END;

/*	END REPORT.INC  */

$ LIST

$ EJECT

/************************************************************/
/*															*/
/*                    GENERAL    NOTES                      */
/*															*/
/************************************************************/

/*

1.	The variable "actual" has been locally redefined in this module.

2.	The procedure used to check isis status in this module is "bomb if"
	because Passif cannot make a reasonable failed assertion entry
	if it can't even read the command tail.

3.	The variable string$mode affects the functioning of the next$char
	procedure.  If string$mode is false, then next$char will handle
	ampersands, and strip out comments;  otherwise, their characters
	will be passed along.

4.	If the token "DEBUG" appears as the first token in the command
	line, it is stripped out here.

*/

/************************************************************/
/*															*/
/*                    DESIGN     NOTES                      */
/*															*/
/************************************************************

	This tokenizer has a very hierarchical design

	The procedure next$char quality assures characters for both
the "token stuffing" procedures, and for the delimiter processing
procedures.

	The procedure "bad$char" makes sure that a character is printable
before passing it on.

    Since next$char is a procedure which advances the buffer pointer before it
performs it checking, said checking would not ordinarily performed on the
first character in the buffer, except that the first character looked at will
be a dummy blank.

                             END OF DESIGN NOTES
*/

$ EJECT

/************************************************************/
/*															*/
/*                    GLOBAL VARIABLES                      */
/*															*/
/************************************************************/

DECLARE
    BIGGER$BUF (131) BYTE DATA (BLANK),
    LOCAL$BUF (130) BYTE AT (.BIGGER$BUF(1)),
	BUF$PTR ADDRESS,
	CHAR BASED BUF$PTR BYTE;

DECLARE FIRST$TOKEN$REQUESTED BOOLEAN INITIAL (TRUE);
DECLARE STRING$MODE BOOLEAN INITIAL (FALSE);

DECLARE PROMPT STRING ('**');

DECLARE DEBUG$STG STRING (5,'DEBUG');

/************************************************************/
/*															*/
/*                     LITERALLY'S                          */
/*															*/
/************************************************************/

DECLARE MAXIMUM$PHYSICAL$LINE$LENGTH	AS	'122';
DECLARE INVALID$COMMAND$SYNTAX			AS	'203';
DECLARE UP$ARROW						AS	'''^''';
DECLARE NO$ERROR$DETECTED				AS	'0';
DECLARE TILDE							AS	'07EH';
DECLARE RUB$OUT							AS	'07FH';
DECLARE QUOTE							AS	'''"''';

$ EJECT

/************************************************************/
/*															*/
/*                    PUBLIC PROCEDURES                     */
/*															*/
/************************************************************/

FORCUP:
    PROCEDURE (CHAR$PTR) PUBLIC;
    DECLARE CHAR$PTR ADDRESS,
            CHAR BASED CHAR$PTR BYTE;
    IF CHAR>='a' AND CHAR<='z' THEN
        CHAR = CHAR - 20H;
    ENDIF
    END
FORCUP;

GET$ARGUMENT:
	PROCEDURE (USER$BUF$PTR,STATUS$PTR) BYTE PUBLIC;
	DECLARE USER$BUF$PTR ADDRESS;
	DECLARE STATUS$PTR ADDRESS,
			STAT BASED STATUS$PTR BYTE;

	DECLARE USER$BUF BASED USER$BUF$PTR (100) BYTE;
	DECLARE TOKEN$LENGTH BASED USER$BUF$PTR BYTE;

    DECLARE ACTUAL ADDRESS;
	DECLARE RETURNEE BYTE;

	/*	We use a different variable for status information, in this
		procedure, than elsewhere, since this procedure is allowed to
		set the other status variable. */
    DECLARE LOCAL$STATUS ADDRESS;

$ EJECT

    /************************************************************/
    /*															*/
    /*             PROCEDURES LOCAL TO GET$ARGUMENT             */
    /*															*/
    /************************************************************/

    STUFF$CHAR:
    	PROCEDURE;
		USER$BUF(TOKEN$LENGTH+1) = CHAR;
    	TOKEN$LENGTH = TOKEN$LENGTH + 1;
        END
    STUFF$CHAR;

    REFRESH$CI$BUF:
        PROCEDURE;
        CALL READ
          (CONSOLE$INPUT,.LOCAL$BUF,SIZE(LOCAL$BUF),.ACTUAL,.LOCAL$STATUS);
        CALL BOMB$IF(LOCAL$STATUS);
        BUF$PTR = .BIGGER$BUF(0);
        END
    REFRESH$CI$BUF;

    OVER$ALL$INITIALIZATION:
    	PROCEDURE;
        /*	Get$argument starts at the very beginning of the command line
            to be compatible with the UDI convention. */
        CALL RESCAN(CONSOLE$INPUT,.STATUS); BI;
        CALL REFRESH$CI$BUF;
        END
    OVER$ALL$INITIALIZATION;

    INITIALIZE$FOR$THIS$TOKEN:
    	PROCEDURE;
        /*	Initialize the data fields returned to the user, in case
            get$argument has to return "unexpectedly". */
        TOKEN$LENGTH = 0;
        RETURNEE = HASH$MARK;
        STAT = NO$ERROR$DETECTED;
        END
    INITIALIZE$FOR$THIS$TOKEN;

	BLANK$OR$TAB:
		PROCEDURE (A$CHAR) BOOLEAN;
		DECLARE A$CHAR BYTE;

		IF A$CHAR=BLANK OR A$CHAR=TAB THEN
			RETURN TRUE;
    	ELSE
    		RETURN FALSE;
    	ENDIF
    	END
    BLANK$OR$TAB;

    NEXT$CHAR:
    	PROCEDURE;

        /*	This procedure detects some error conditions. The possible
        	error conditions detectable in string mode are

        	1.	carriage return encountered
        	2.	physical line too long

        	The possible error conditions in token mode are

        	1.	line too long
        	2.	illegal character (e.g., escape)

			If an error is detected, then the errant character is
			overwritten by a carriage return, and status is set to
			isis error 203, which is defined as "invalid command syntax".

            After encountering an illegal character, or error condition, the
            user should be able to get the remaining tokens on the line.
            The rest of this code expects that buf$ptr will be
            pointing to the start of the next token.  This function is
            correctly handled for the case of carriage return, whether
            or not an error state exists, by the set$delimiter procedure.

            Next$char will change all lowercase characters to uppercase,
            unless string$mode is true.  */

$ EJECT

        /************************************************************/
        /*															*/
        /*             PROCEDURES LOCAL TO NEXT$CHAR                */
        /*															*/
        /************************************************************/

        NEXT$CHAR$ERROR$CONDITION:
        	PROCEDURE;
            CHAR = HASH$MARK;
            STAT = INVALID$COMMAND$SYNTAX;
            END
        NEXT$CHAR$ERROR$CONDITION;

		BAD$CHAR:
			PROCEDURE BOOLEAN;

			RETURN (CHAR>=0 AND CHAR<=19H AND (NOT (CHAR=CR OR CHAR=TAB)))
							OR
            		CHAR = UP$ARROW
            				OR
            		CHAR > 07FH;
			END
        BAD$CHAR;

$ EJECT

        /************************************************************/
        /*															*/
        /*             FIRST EXECUTABLE IN NEXT$CHAR                */
        /*															*/
        /************************************************************/

        BUF$PTR = BUF$PTR + 1;

		/*	Check all possible error condtions, as specified in the
			comment above. */

		/*	First check for line too long. This error condition applies
			in both string mode and token mode. */

    check$current$character:
        IF BUF$PTR > .LOCAL$BUF(MAXIMUM$PHYSICAL$LINE$LENGTH) THEN
            /*	This is the "line too long" condition. */
        	CALL NEXT$CHAR$ERROR$CONDITION;
        ELSE IF STRING$MODE THEN
            DO;
               /*	Now, check for carriage-return encountered in string
                    mode. */
                IF CHAR = CR THEN
                    DO;
                    	STAT = INVALID$COMMAND$SYNTAX;
                    ENDDO;
                ENDIF
            ENDDO;
        ELSE
        	DO;
        		/*	Check for the illegal character error condition. */
        		IF BAD$CHAR THEN
        			CALL NEXT$CHAR$ERROR$CONDITION;
        		ELSE
        			DO;
						/*	Now, we can finally check for the non-error
							conditions which require special handling:
							ampersands, and comments. */
                        IF CHAR=AMPERSAND THEN
                        	DO;
                        		CALL WRITE(CONSOLE$OUTPUT,
                                           .PROMPT
                                           ,SIZE(PROMPT),
                                           .LOCAL$STATUS);
                        		CALL REFRESH$CI$BUF;
                                CALL BOMB$IF(LOCAL$STATUS);
                                GOTO check$current$character;
                            ENDDO;
                        ELSE IF CHAR=SEMICOLON THEN
                        	DO;
								/*	the line is terminated by the
									detection of this comment. */
                                CHAR = CR;
                        	ENDDO;
                        ENDIF
        			ENDDO;
                ENDIF
            ENDDO;
        ENDIF

		IF NOT STRING$MODE THEN
			CALL FORCUP(BUF$PTR);
        ENDIF

        END
    NEXT$CHAR;

	SKIP$CHAFF:
		PROCEDURE;
		DO WHILE BLANK$OR$TAB(CHAR);
			CALL NEXT$CHAR;
        END$DO$WHILE;
    	END
    SKIP$CHAFF;

$ EJECT

    /************************************************************/
    /*															*/
    /*                     TOKEN$DELIMITER                      */
    /*															*/
    /************************************************************/

    TOKEN$DELIMITER:
    	PROCEDURE (A$CHAR) BOOLEAN;
		DECLARE A$CHAR BYTE;

        EXPRESSION$1:
            PROCEDURE BOOLEAN;

            RETURN
                (A$CHAR>=0 AND A$CHAR<=20H)  OR
                (A$CHAR = ',')				OR
                (A$CHAR = ')')				OR
                (A$CHAR = '(')				OR
                (A$CHAR = '=')				OR
                (A$CHAR = '#')				OR
                (A$CHAR = '!')				OR
                (A$CHAR = '$')				OR
                (A$CHAR = '%')				OR
                (A$CHAR = '''')				OR
                (A$CHAR = '\');
            END
        EXPRESSION$1;

        EXPRESSION$2:
        	PROCEDURE BOOLEAN;

            RETURN
                (A$CHAR = TILDE)			OR
                (A$CHAR = '+')				OR
                (A$CHAR = '-')				OR
                (A$CHAR = '&')				OR
                (A$CHAR = '|')				OR
                (A$CHAR = ']')				OR
                (A$CHAR = '[')				OR
                (A$CHAR = '>')				OR
                (A$CHAR = '<')				OR
                (A$CHAR = ';')				OR
                (A$CHAR = RUBOUT);
    		END
        EXPRESSION$2;

        RETURN EXPRESSION$1 OR EXPRESSION$2;

        END
    TOKEN$DELIMITER;

$ EJECT

    SET$DELIMITER:
    	PROCEDURE;

		/*	This procedure expects char to be pointing to the first
			character following the token.  This procedure processes
			the strings of consecutive delimiters, as specified by
			UDI;  i.e., strings of blanks and tabs followed a fresh
			token become a single blank, but strings of blanks and
			tabs followed by one of the other delimiters are
			thrown away.

			If the "true" or "final" (after the chaff has been skipped)
            delimiter is anything besides a carriage return, then
            set$delimiter will advance buf$ptr to the next token.  */

        CALL SKIP$CHAFF;
        IF TOKEN$DELIMITER(CHAR) THEN
        	DO;
        		RETURNEE = CHAR;
        		IF NOT CHAR=CR THEN
        			CALL NEXT$CHAR;
            	ENDIF
            ENDDO;
        ELSE
        	RETURNEE = BLANK;
        ENDIF
        END
    SET$DELIMITER;

$ EJECT

    /************************************************************/
    /*															*/
    /*                  HANDLE$QUOTED$STRING                    */
    /*															*/
    /************************************************************/

    HANDLE$QUOTED$STRING:
        PROCEDURE;

        loop$begin:
        CALL NEXT$CHAR;
        IF CHAR = CR THEN
        	DO;
        		/*	Carriage-return will terminate a string.
        			Prepare to return. */
                CALL STUFF$CHAR;
        		RETURN;
            ENDDO;
        ELSE IF CHAR=QUOTE THEN
        	DO;
                /*	Check for double quotes.  If there are double
                	quotes then pass on a single quote.  If the
                	quote is only a single quote, then do not pass it
                	on, but terminate the string. */
    			CALL NEXT$CHAR;
				IF CHAR=QUOTE THEN
					/*	Pass on a single quote to stand for the double
						quotes. */
                    DO;
                    	CALL STUFF$CHAR;
                        GOTO loop$begin;
                	ENDDO;
                ELSE
                	/*	The previous quote has terminated the string. */
                    RETURN;
                ENDIF
            ENDDO;
        ELSE
        	DO;
				/*	The current character can have no interest to those
					procedures interested in terminating the string. */
                CALL STUFF$CHAR;
        		GOTO loop$begin;
            ENDDO;
        ENDIF
        END
    HANDLE$QUOTED$STRING;

$ EJECT

    /************************************************************/
    /*															*/
    /*                       STUFF$TOKEN                        */
    /*															*/
    /************************************************************/

    STUFF$TOKEN:
		PROCEDURE;

		/* This procedure expects the current character to be pointing
			to a token. */

        IF CHAR=QUOTE THEN
			DO;
				STRING$MODE = TRUE;
                CALL HANDLE$QUOTED$STRING;
        		STRING$MODE = FALSE;
            ENDDO;
        ELSE
            DO WHILE NOT TOKEN$DELIMITER(CHAR);
                CALL STUFF$CHAR;
                CALL NEXT$CHAR;
            END$DO$WHILE;
		END$IF
        END
    STUFF$TOKEN;

    TOKEN$TOO$LONG:
    	PROCEDURE BYTE;
		RETURN TOKEN$LENGTH > MAXIMUM$TOKEN$LENGTH;
    	END
    TOKEN$TOO$LONG;

	CORRECT$TOKEN$LENGTH:
		PROCEDURE;
		DECLARE CORRECTION$FACTOR BYTE;
		CORRECTION$FACTOR = TOKEN$LENGTH - MAXIMUM$TOKEN$LENGTH;
		BUF$PTR = BUF$PTR - CORRECTION$FACTOR;
		TOKEN$LENGTH = TOKEN$LENGTH - CORRECTION$FACTOR;
        END
    CORRECT$TOKEN$LENGTH;

$ EJECT

    /************************************************************/
    /*															*/
    /*      FIRST EXECUTABLE CODE IN PROCEDURE GET$ARGUMENT     */
    /*															*/
    /************************************************************/

	IF FIRST$TOKEN$REQUESTED THEN
		CALL OVER$ALL$INITIALIZATION;
    ENDIF

	CALL INITIALIZE$FOR$THIS$TOKEN;

	begin$loop:
    CALL SKIP$CHAFF;
    CALL STUFF$TOKEN;

    IF FIRST$TOKEN$REQUESTED THEN
        DO;
        	FIRST$TOKEN$REQUESTED = FALSE;
            IF UDI$STRING$MATCH(.DEBUG$STG(0),.USER$BUF(0)) THEN
                DO;
                    TOKEN$LENGTH = 0;
                    GOTO begin$loop;
                ENDDO;
            ENDIF
        ENDDO;
    ENDIF

    IF TOKEN$TOO$LONG THEN
    	DO;
			CALL CORRECT$TOKEN$LENGTH;
            STAT = INVALID$COMMAND$SYNTAX;
            RETURN BLANK;
    	ENDDO;
    ENDIF

    CALL SET$DELIMITER;
    RETURN RETURNEE;

    END
GET$ARGUMENT;

END
TOKENS$MOD;
src/unpack.plm
Unpack:   DO;

/************************************************************************/
/*																		*/
/*     'Copyright 1981,1983 Intel Corporation'.  All rights reserved.	*/
/*      No part of this program or publication may be reproduced,		*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

$IF XVERSION
DECLARE PROPRIETARY(*) BYTE DATA ('INTEL PROPRIETARY SOFTWARE');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=X103',0);
$ELSE
DECLARE COPYRIGHT (*) BYTE DATA  ('COPYRIGHT 1981,1983 INTEL ');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.1',0);
$ENDIF

    


/*    This program is designed to accept packed files and decompress
      the blanks back to their original forms

      Blanks are decompressed by converting bytes with the high bit
      on into a string of blanks whose length is the lower
      seven bits of the byte.  All other characters are passed
      through without alteration.

*/

DECLARE dcl LITERALLY 'DECLARE';
DECLARE as LITERALLY 'LITERALLY';

dcl boolean as 'BYTE';
dcl end$of$file as 'actual=0';
dcl depart as '0FFH';
dcl true as '0FFH';
dcl false as '0';
dcl character as 'BYTE';
dcl pointer as 'ADDRESS';
dcl int1 as 'BYTE';
dcl int2 as 'ADDRESS';
dcl nil as '0';

dcl thenn as 'THEN DO;';
dcl elseif as 'END; ELSE IF';
dcl elsee as 'END; ELSE DO;';
dcl endif as 'END;';
dcl whilee as 'DO WHILE';
dcl endwhile as 'END;';
dcl for as 'DO';
dcl endfor as 'END;';
dcl enddo as 'END;';

dcl compress$1 as '0FFH';
dcl cr as '0DH';
dcl lf as '0AH';

/* system EXTERNALs */

open: PROCEDURE (aft,file,access,mode,status) EXTERNAL;
  DECLARE (aft,file,access,mode,status) ADDRESS; END;
close: PROCEDURE (aft,status) EXTERNAL; DECLARE (aft,status) ADDRESS; END;
read: PROCEDURE (aft,buffer,count,actual,status) EXTERNAL;
  DECLARE (aft,buffer,count,actual,status) ADDRESS; END;
write: PROCEDURE (aft,buffer,count,status) EXTERNAL;
  DECLARE (aft,buffer,count,status) ADDRESS; END;
delete: PROCEDURE (file,status) EXTERNAL; DECLARE (file,status) ADDRESS; END;
exit: PROCEDURE EXTERNAL; END;
spath: PROCEDURE(file, buffer, status) EXTERNAL;
  DECLARE (file, buffer, status) ADDRESS; END;
LOAD: PROCEDURE(FILE,BIAS,SWITCH,ENTRY,STATUS) EXTERNAL;
  DCL (FILE,BIAS,SWITCH,ENTRY,STATUS) ADDRESS; END;
GETD: PROCEDURE(DRIVE,CON,COUNT,ACTUAL$COUNT,BUFFER,STATUS) EXTERNAL;
  DCL (DRIVE,CON,COUNT,ACTUAL$COUNT,BUFFER,STATUS) ADDRESS; END;


seq: PROCEDURE (s1,s2,len) boolean EXTERNAL;
  DECLARE s1 ADDRESS; DECLARE s2 ADDRESS; DECLARE len BYTE; END;
force$upper: PROCEDURE (buffer$ptr) EXTERNAL; DECLARE buffer$ptr ADDRESS; END;
file$error: PROCEDURE (status, filename$ptr, callexit) EXTERNAL;
  DECLARE (status, filename$ptr) ADDRESS; DECLARE callexit boolean; END;
meq: PROCEDURE (search$arg, dir$entry) BYTE EXTERNAL;
  DECLARE (search$arg, dir$entry) ADDRESS; END;
wpath: PROCEDURE(pathname$ptr, pn, wc$used) BYTE EXTERNAL;
  DECLARE (pathname$ptr, pn, wc$used) ADDRESS; END;
unpath: PROCEDURE(int, ext) EXTERNAL; DECLARE (int, ext) ADDRESS; END;

unpacker: PROCEDURE boolean external; end;

$IF XVERSION
dcl version(4) character data('X103');
$ELSE
dcl version(4) character data('V1.1');
$ENDIF
dcl (actual,status) int2;
dcl out$aftn int2 PUBLIC;
dcl in$aftn int2 PUBLIC;
dcl command$line(122) character;
dcl command$pointer pointer;
dcl command$char based command$pointer character;
dcl delete$source boolean;
dcl default$output boolean;
dcl default$extension(3) character initial('PCK');
dcl input$file$name(16) character PUBLIC;
dcl output$file$name(16) character PUBLIC;
dcl input$name pointer PUBLIC;
dcl output$name pointer PUBLIC;
dcl in$name pointer;
dcl out$name pointer;
dcl no$error$occured boolean;

dcl directory$name(16) character initial(':F0:ISIS.DIR ');
dcl dir$aftn int2;
dcl path$name(16) character;
dcl out$path$name(16) character;
dcl max$directory$length int2;
dcl file$found boolean;
dcl wildcard$used boolean;
dcl directory$entry int2;
dcl source$disk int1;
dcl buf16(16) character;
dcl found boolean;
dcl no$such$file as '13';
dcl star$dot$LST(16) character initial(0,'******LST      ');

DCL reading$remote BYTE;
DCL ov0$name(16) BYTE INITIAL(':F0:ISIS.OV0 ');
DCL wasted ADDRESS;
DCL getd$drive ADDRESS;
DCL getd$conn ADDRESS;
DCL spooling BYTE;
DCL spool$name(4) BYTE INITIAL(':SP:');
DCL unrecognized$device as '5';

deblank: PROCEDURE( char$ref ) pointer;
   /* scan for next non-blank */
   dcl char$ref pointer;
   dcl char BASED char$ref character;

   whilee char = ' ';
      char$ref = char$ref + 1;
   endwhile
   RETURN char$ref;
end deblank;

scan$blank: PROCEDURE( char$ref ) pointer;
   /* scan for a blank character */
   dcl char$ref pointer;
   dcl char BASED char$ref character;

   whilee char <> ' ' and char <> cr;
      char$ref = char$ref + 1;
   endwhile
   RETURN char$ref;
end scan$blank;

command$tail$error: PROCEDURE;
  CALL write(0,.command$line,command$pointer-.command$line,.status);
  CALL write(0,.('#'),1,.status);
  CALL write(0,command$pointer,actual-(command$pointer-.command$line),.status);
  CALL write(0,.('command tail error',cr,lf),20,.status);
  CALL exit;
END command$tail$error;

more$input$files: PROCEDURE boolean;
  DCL searching BYTE;
  DCL getd$actual ADDRESS;

   /****************************************************************************
    *
    * This routine sets up the global input$file$name with the next file
    * which matches the wildcard pathname and returns true.  If no
    * more matching file names are found, false is returned.
    *
    ****************************************************************************/

   searching = true;
   DO WHILE searching;
     IF reading$remote THEN
       DO;
         CALL getd(getd$drive,.getd$conn,1,.getd$actual,.buf16,.status);
         CALL file$error(status,.('GETD '),true);
         IF getd$actual = 0 THEN
           RETURN false;
         buf16(0) = 0;  /* for MEQ call */
       END;
     ELSE
       DO;
         CALL read(diraftn,.buf16,16,.actual,.status);
         CALL file$error(status, .directory$name, true);
         IF buf16(0) = 7FH or actual = 0 THEN
           RETURN false;
       END;
     searching = NOT meq(.pathname, .buf16);
   END;
   found = true;
   buf16(0) = source$disk;
   CALL move(15,.('                '),.input$filename);
   CALL unpath(.buf16, .input$file$name);
   RETURN true;
end more$input$files;

generate$default$output$filename: PROCEDURE;

   /****************************************************************************
    *
    * This procedure generates the default output$filename by changing
    * the input$filename extension to .PCK if no output filename was
    * specified.  If a name was specified (with wildcard) then the
    * appropriate replacements are made.
    *
    ****************************************************************************/

   dcl i int1;
   dcl internal$name(16) character;

   CALL move(15, .('               '), .output$filename);
   CALL move(15, .out$path$name, .internal$name);
   for i = 1 to 14;
      if out$path$name(i) = '*' or out$path$name(i) = '?' thenn
         internal$name(i) = buf16(i);
      endif
   endfor
   CALL unpath(.internal$name, .output$filename);
   IF spooling THEN  /* force :SP: as device */
     CALL MOVE(4,.spool$name,.output$filename);
end generate$default$output$filename;

/*
     initialize values and open files
*/
   CALL write(0,.('ISIS-II  BLANK DECOMPRESSOR, '),29,.status);
   CALL write(0,.version,4,.status);
   CALL write(0,.(cr,lf),2,.status);

   CALL read(1,.command$line,LENGTH(command$line),.actual,.status);
   CALL force$upper(.command$line);
   command$pointer = deblank(.command$line);
   in$name = command$pointer;
   wildcard$used = true;
   status = wpath(in$name,.path$name,.wild$card$used);
   CALL file$error(status, in$name, true);

   output$name = .output$file$name;
   CALL move (15, .('               '), .output$filename);
   command$pointer = deblank(scan$blank(command$pointer));
   out$name = nil;
   if seq(command$pointer,.('TO '),3) thenn
      out$name, command$pointer=deblank(scan$blank(command$pointer));
      command$pointer = deblank(scan$blank(command$pointer));
      CALL move(command$pointer - out$name, out$name, .output$filename);
      spooling = seq(.output$filename,.spool$name,4);
   endif
   default$output = true;
   if out$name <> nil thenn
      wildcard$used = true;
      IF spooling THEN  /* wpath doesn't know :SP: */
        CALL MOVE(4,.ov0$name,out$name);
      status = wpath(out$name, .out$path$name, .wildcard$used);
      IF spooling THEN  /* restore :SP: for error report */
        CALL MOVE(4,.spool$name,out$name);
      CALL file$error(status, out$name, true);
      if not wildcard$used thenn
         default$output = false;
      endif
   elsee
      /* generate template for :F#:*.LST for output */
      CALL move(15, .star$dot$LST, .out$path$name);
      out$path$name(0) = pathname(0);
   endif

   delete$source = true;
   if seq(command$pointer, .('DELETE'),6) thenn
      delete$source = true;
      command$pointer = deblank(scan$blank(command$pointer));
   elseif seq(command$pointer, .('NODELETE'),8) thenn
      delete$source = false;
      command$pointer = deblank(scan$blank(command$pointer));
   endif
   if command$char <> cr then call command$tail$error;

   /* setup wild card search */
   directory$name(2) = (source$disk := path$name(0)) + '0';
   IF path$name(0) >= 25 THEN
     directory$name(2) = directory$name(2) - 19;
   path$name(0) = 0;
   CALL spath(.directory$name, .buf16, .status);
   CALL file$error(status, .directory$name, true);
   IF buf16(10) = 3  AND  buf16(11) > 4  THEN
     DO;
       IF .MEMORY > 0E800H  THEN
         DO;
           CALL write(0,.('insufficient memory',CR,LF),21,.status);
           CALL exit;
         END;
       ELSE
         DO;
           CALL LOAD(.ov0$name,0,0,.wasted,.STATUS);
           CALL file$error(status,.ov0$name,true);
           /* set up getd call */
           getd$drive = directory$name(2) - '0';
           getd$conn = 0;
           reading$remote = true;
         END;
     END;
   ELSE
     DO;
       CALL open(.diraftn, .directory$name, 1, 0, .status);
       CALL file$error(status, .directory$name, true);
       reading$remote = false;
     END;
   found = false;

   if not default$output thenn
      CALL open(.outaftn,output$name,2,0,.status);
      CALL file$error(status,output$name,true);
   endif

   input$name = .input$filename;
   whilee more$input$files;
      no$error$occured = true;
      CALL open(.inaftn,input$name,1,0,.status);
      CALL file$error(status,input$name,false);
      if status <> 0 thenn
         no$error$occured = false;
      endif
      if default$output and no$error$occured thenn
         CALL generate$default$output$filename;
         CALL open(.outaftn,output$name,2,0,.status);
         CALL file$error(status,output$name,false);
         if status <> 0 thenn
            no$error$occured = false;
            CALL close(inaftn, .status);
            CALL file$error(status, input$name, false);
         endif
      endif
      if no$error$occured thenn
         CALL write(0,.('  '),2,.status);
         CALL write(0,input$name,15,.status);
         CALL write(0,.(' TO '),4,.status);
         CALL write(0,output$name,15,.status);
         no$error$occured = not unpacker;
         if no$error$occured thenn
            CALL write(0,.(' UNPACKED '),10,.status);
         elsee
            CALL write(0,.(' ERROR    '),10,.status);
         endif

         if default$output thenn
            CALL close(outaftn,.status);
            CALL file$error(status,output$name,false);
         endif

         CALL close(inaftn, .status);
         CALL file$error(status, input$name, false);

         if delete$source and no$error$occured thenn
            CALL delete(input$name, .status);
            CALL file$error(status, input$name, false);
            CALL write(0,.(' DELETED'),8,.status);
         endif
         CALL write(0,.(cr,lf),2,.status);

      endif
   endwhile
   IF NOT reading$remote THEN
     DO;
       CALL close(dir$aftn, .status);
       CALL file$error(status, .directory$name, true);
     END;
   if not found thenn
      CALL file$error(no$such$file, in$name, true);
   endif
   CALL exit;
end Unpack;
src/unpakr.plm
Unpacker:   DO;


/************************************************************************/
/*																		*/
/*     'Copyright 1981,1983 Intel Corporation'.  All rights reserved.	*/
/*      No part of this program or publication may be reproduced,		*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

      
/*
      This routine is the logical opposite of the program pack
      this routine accepts as input a file containing the
      compression bytes produced by pack, reexpands them
      and outputs the result.

      The compression bytes are bytes which have the sign bit
      on which implies that parity must not be used by the
      system.  This byte is the negation of the number of
      blanks which have been compressed.

*/

DECLARE dcl LITERALLY 'DECLARE';
DECLARE as LITERALLY 'LITERALLY';

dcl true as '0FFH';
dcl false as '0';
dcl boolean as 'BYTE';
dcl int1 as 'BYTE';
dcl int2 as 'ADDRESS';
dcl pointer as 'ADDRESS';
dcl character as 'BYTE';
dcl nil as '0';

dcl thenn as 'THEN DO;';
dcl elseif as 'END; ELSE IF';
dcl elsee as 'END; ELSE DO;';
dcl endif as 'END;';
dcl for as 'DO';
dcl endfor as 'END;';
dcl whilee as 'DO WHILE';
dcl endwhile as 'END;';

dcl until literally 'while not';
dcl end$of$file literally 'actual=0';
dcl buffer$size literally '16384'; /* =8*2048 */
dcl limit literally 'buffer$size-1';
dcl compress$1 literally '81h';

read: PROCEDURE (aft,buffer,count,actual,status) EXTERNAL;
  DECLARE (aft,buffer,count,actual,status) ADDRESS; END;
write: PROCEDURE (aft,buffer,count,status) EXTERNAL;
  DECLARE (aft,buffer,count,status) ADDRESS; END;

file$error: PROCEDURE(status,ptr,callexit) EXTERNAL;
  DECLARE (status,ptr) ADDRESS; DECLARE callexit BOOLEAN; end;

dcl output$buffer(buffer$size) byte;
dcl input$buffer(buffer$size) byte;
dcl output$pointer address;
dcl output$character based output$pointer byte;
dcl input$pointer address;
dcl input$character based input$pointer byte;
dcl status address;
dcl actual address;
dcl outaftn address EXTERNAL;
dcl inaftn address EXTERNAL;
dcl (input$name, output$name) address EXTERNAL;
dcl compress boolean;
dcl compression$byte byte;
dcl (i,j) address;

output: PROCEDURE(put$char) boolean;

/*
      this procedure accepts a character and fills a buffer
      when the buffer is full, it is then written to the
      output file.
*/

   dcl put$char character;

   output$character=put$char;
   output$pointer=output$pointer+1;
   if output$pointer > .output$buffer+limit thenn
      call write(outaftn,.output$buffer,buffer$size,.status);
      call file$error(status,output$name,false);
      if status <> 0 thenn
         RETURN false;
      endif
      output$pointer=.output$buffer;
   endif
   RETURN true;
END output;

flush: PROCEDURE;
/*
      this routine flushes the output buffer at the end of the program
*/

   if output$pointer = .output$buffer thenn
      RETURN;
   endif
   call write(outaftn,.output$buffer,output$pointer-.output$buffer,
      .status);
   call file$error(status,output$name,false);
END flush;

unpacker: PROCEDURE boolean PUBLIC;

/*
     initialize values
*/

   output$pointer=.output$buffer;
   input$pointer=.input$buffer;
   compress=false;

/*
        begin processing
*/

   call read(inaftn,.input$buffer,buffer$size,.actual,.status);
   call file$error(status,input$name,false);
   if status <> 0 thenn
      RETURN true;
   endif

   whilee not end$of$file;

      for i = 0 to actual-1;

         if input$character > 127 thenn
            /* expand blanks */
            for j = 1 to -input$character;
               if not output(' ') thenn
                  RETURN true;
               endif
            endfor
         elsee
            if not output(input$character) thenn
               RETURN true;
            endif
         endif

         input$pointer=input$pointer+1;
      endfor

      call read(inaftn,.input$buffer,buffer$size,.actual,.status);
      call file$error(status,input$name,false);
      if status <> 0 thenn
         RETURN true;
      endif
      input$pointer=.input$buffer;
   endfor

   call flush;
   RETURN false;

END unpacker;

END Unpacker;
src/upper.plm
UPPER: DO;

/************************************************************************/
/*																		*/
/*     'Copyright 1981,1983 Intel Corporation'.  All rights reserved.	*/
/*      No part of this program or publication may be reproduced,		*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

$IF XVERSION
DECLARE PROPRIETARY(*) BYTE DATA ('INTEL PROPRIETARY SOFTWARE');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=X103',0);
$ELSE
DECLARE COPYRIGHT (*) BYTE DATA  ('COPYRIGHT 1981,1983 INTEL ');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.1',0);
$ENDIF

    


$NOLIST
/* PEX */
DECLARE SCANP ADDRESS EXTERNAL;
DECLARE SCANBYTE BASED SCANP BYTE;
FORCUP :PROCEDURE BYTE EXTERNAL;END;
MIN :PROCEDURE (ZZ1,ZZ2)ADDRESS EXTERNAL;DECLARE (ZZ1,ZZ2)ADDRESS;END;
DECLARE FATAL BYTE EXTERNAL;
DECLARE ACTUAL ADDRESS EXTERNAL;
EX :PROCEDURE  EXTERNAL;END;
MEMCK :PROCEDURE ADDRESS EXTERNAL;END;
OPENU :PROCEDURE (ZZ1) EXTERNAL;DECLARE (ZZ1)ADDRESS;END;
READC :PROCEDURE (ZZ1,ZZ2) EXTERNAL;DECLARE (ZZ1,ZZ2)ADDRESS;END;
READU :PROCEDURE (ZZ1,ZZ2) EXTERNAL;DECLARE (ZZ1,ZZ2)ADDRESS;END;
SBYTEU :PROCEDURE (ZZ1) EXTERNAL;DECLARE (ZZ1)ADDRESS;END;
WRITEU :PROCEDURE (ZZ1,ZZ2) EXTERNAL;DECLARE (ZZ1,ZZ2)ADDRESS;END;
DECLARE FOREVER LITERALLY'WHILE 1';
DECLARE TRUE LITERALLY'255';
/* ENDPEX */
$LIST

DECLARE CAPACITY ADDRESS;
CAPACITY = MIN(32512,MEMCK-.MEMORY);
FATAL = TRUE;
CALL READC(.MEMORY,100);
CALL OPENU(.MEMORY);
DO FOREVER;
 CALL READU(.MEMORY,CAPACITY);
 IF ACTUAL = 0 THEN CALL EX;
 SCAN$P = .MEMORY;
  DO WHILE SCAN$P < .MEMORY + ACTUAL;
   SCAN$BYTE = FORCUP;
   SCAN$P = SCAN$P + 1;
  END;
 CALL SBYTEU(-ACTUAL);
 CALL WRITEU(.MEMORY,ACTUAL);
END;

END UPPER;
src/wait.plm
WAIT$MOD: DO;

/************************************************************************/
/*																		*/
/*     'Copyright 1981,1983 Intel Corporation'.  All rights reserved.	*/
/*      No part of this program or publication may be reproduced,		*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

$IF XVERSION
DECLARE PROPRIETARY(*) BYTE DATA ('INTEL PROPRIETARY SOFTWARE');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=X103',0);
$ELSE
DECLARE COPYRIGHT (*) BYTE DATA  ('COPYRIGHT 1981,1983 INTEL ');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.1',0);
$ENDIF


DECLARE	LIT		LITERALLY	'LITERALLY',
		DCL		LIT	'DECLARE',
		TRUE	LIT	'0FFH',
		FALSE	LIT	'000H',
		PROC	LIT	'PROCEDURE',
		PROCEND	LIT	'END',
		THENDO	LIT	'THEN DO;',
		ELSEIF	LIT	'END; ELSE IF',
		ELSEDO	LIT	'END; ELSE DO;',
		IFEND	LIT	'END',
		WHILEND	LIT	'END',
		CR		LIT	'0DH',
		LF		LIT	'0AH';


EXIT:	PROC EXTERNAL;											PROCEND;
RESCAN:	PROC (A,B) EXTERNAL;		DCL (A,B) ADDRESS;			PROCEND;
READ:	PROC (A,B,C,D,E) EXTERNAL;	DCL (A,B,C,D,E) ADDRESS;	PROCEND;
WRITE:	PROC (A,B,C,D) EXTERNAL;	DCL (A,B,C,D) ADDRESS;		PROCEND;
SPATH:	PROC (A,B,C) EXTERNAL;		DCL (A,B,C) ADDRESS;		PROCEND;
CONSOL:	PROC (A,B,C) EXTERNAL;		DCL (A,B,C) ADDRESS;		PROCEND;
WHOCON:	PROC (A,B) EXTERNAL;		DCL (A,B) ADDRESS;			PROCEND;
IOCHK:	PROC BYTE EXTERNAL;										PROCEND;
CSTS:	PROC BYTE EXTERNAL;										PROCEND;
CI:		PROC BYTE EXTERNAL;										PROCEND;
CO:		PROC (A) EXTERNAL;			DCL (A) BYTE;				PROCEND;

DCL (STATUS, ACTUAL) ADDRESS;
DCL (CMND, CMND$PTR) ADDRESS, (CMND$CH BASED CMND$PTR) (1) BYTE;
DCL (FILE1, FILE2) (15) BYTE;
DCL (PN) STRUCTURE
	(DEV BYTE, NAME (6) BYTE, EXT (3) BYTE, DEV$TYPE BYTE, DRIVE$TYPE BYTE);
DCL (COLD$START$CO) BYTE;
DCL (CH) BYTE;


CALL RESCAN (1, .STATUS);
CALL READ (1, .MEMORY, 128, .ACTUAL, .STATUS); /* Get command tail. */
CMND = .MEMORY + ACTUAL;
CMND$PTR = .MEMORY;
DO WHILE CMND$PTR < CMND;
	IF CMND$CH (0) = '&' THENDO
		CMND$CH (0) = CR;
		CMND$CH (1) = LF;
		CALL WRITE (0, .('**'), 2, .STATUS);
		CALL READ (1, CMND$PTR + 2, 128, .ACTUAL, .STATUS);
		CMND = CMND$PTR + ACTUAL + 2;
	IFEND;
	CMND$PTR = CMND$PTR + 1;
WHILEND;

CALL WHOCON (0, .FILE1); /* Find out what the :CO: file is. */
CALL SPATH (.FILE1, .PN, .STATUS);
COLD$START$CO = IOCHK AND 3;
IF (PN.DEV = 7) AND (COLD$START$CO = 0) THENDO /* :CO: = :TO: */
ELSEIF (PN.DEV = 9) AND (COLD$START$CO = 1) THENDO /* :CO: = :VO: */
ELSEDO
	CMND$PTR = .MEMORY;
	DO WHILE CMND$PTR < CMND;
		CALL CO (CMND$CH (0));
		CMND$PTR = CMND$PTR + 1;
	WHILEND;
IFEND;

/* Wait for CR or Control-C. */
DO WHILE TRUE;
	CH = 198; /* Used as a temp to count the seconds here. */
	DO WHILE NOT CSTS; /* No keys hit yet, just wait. */
		CALL TIME (250);
		CH = CH + 1;
		IF CH = 199 THENDO /* Ring bell once every 5 second or so. */
			CH = 0;
			CALL CO (7);
		IFEND;
	WHILEND;
	CH = CI AND 7FH;
	IF CH = CR THENDO /* Got a CR, exit and continue. */
		CALL EXIT;
	ELSEIF CH = 03H THENDO /* Got an Control-C, abort the rest. */
		IF COLD$START$CO = 0 THENDO /* Cold start CONSOL is tty. */
			CALL MOVE (5, .(':TI: '), .FILE1);
			CALL MOVE (5, .(':TO: '), .FILE2);
			CALL CONSOL (.FILE1, .FILE2, .STATUS);
		ELSEIF COLD$START$CO = 1 THENDO /* Cold start CONSOL is crt. */
			CALL MOVE (5, .(':VI: '), .FILE1);
			CALL MOVE (5, .(':VO: '), .FILE2);
			CALL CONSOL (.FILE1, .FILE2, .STATUS);
		IFEND;
		CALL EXIT;
	IFEND;
WHILEND;

END WAIT$MOD;
src/which.plm
$ TITLE ('WHICH -- VERSION_NUMBER_SEARCHER')

WHICH$MOD:
DO;

/************************************************************************/
/*																		*/
/*     'Copyright 1981,1983 Intel Corporation'.  All rights reserved.	*/
/*      No part of this program or publication may be reproduced,		*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

$IF XVERSION
DECLARE PROPRIETARY(*) BYTE DATA ('INTEL PROPRIETARY SOFTWARE');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=X103',0);
$ELSE
DECLARE COPYRIGHT (*) BYTE DATA  ('COPYRIGHT 1981,1983 INTEL ');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.1',0);
$ENDIF


/**************************************************************/
/*                 EXTERNAL  PROCEDURES                       */
/**************************************************************/

CLOSE: PROCEDURE (AFTN,STATUS) EXTERNAL; DECLARE (AFTN,STATUS) ADDRESS; END;
CO: PROCEDURE (CHAR$CO) EXTERNAL; DECLARE CHAR$CO BYTE; END;
ERROR: PROCEDURE  (ERROR$NUMBER) EXTERNAL; DECLARE ERROR$NUMBER ADDRESS; END;
EXIT: PROCEDURE EXTERNAL; END;
OPEN: PROCEDURE(AFTN,FILENAME,ACCESS$MODE,LINE$EDIT$AFTN,ERROR) EXTERNAL;
  DECLARE (AFTN,FILENAME,ACCESS$MODE,LINE$EDIT$AFTN,ERROR) ADDRESS; END;
READ: PROCEDURE (AFTN,BUFFER,COUNT,ACTUAL,STATUS) EXTERNAL;
  DECLARE (AFTN,BUFFER,COUNT,ACTUAL,STATUS) ADDRESS; END;
WRITE: PROCEDURE (AFTN,BUFFER,COUNT,STATUS) EXTERNAL;
  DECLARE (AFTN,BUFFER,COUNT,STATUS) ADDRESS; END;

/*************************************************************/
/*               LITERALLY  DECLARATION                      */
/*************************************************************/

DECLARE      LIT LITERALLY 'LITERALLY',
    BELL               LIT '07H',
    BLANK              LIT '020H',
    BOOLEAN            LIT 'BYTE',
    CHK                LIT 'CALL CHECK$STATUS(STATUS)',
    CONSOLE$INPUT      LIT '1',
    CONSOLE$OUTPUT     LIT '0',
    CR                 LIT '0DH',
    CRLF               LIT '0DH,0AH',
    FALSE              LIT '0H',
    LF                 LIT '0AH',
    NO$LINE$EDIT       LIT '0',
    OPEN$FOR$READ      LIT '1',
    OPEN$FOR$WRITE     LIT '2',
    READ$BUFFER$LENGTH LIT '2048',
    SENTINEL$0         LIT '0',
    SENTINEL$1         LIT '1',
    SPACE              LIT '020H',
    TAB                LIT '09H',
    TRUE               LIT '0FFH';

$EJECT

/************************************************************/
/*                GLOBAL  VARIABLE  DECLARATION             */
/************************************************************/

DECLARE STRING$TO$SEARCH (*) BYTE INITIAL
        ('program_version_number=');

DECLARE FOUND$MSG (*) BYTE INITIAL
        ('    program version number is ');

DECLARE NOT$FOUND$MSG (*) BYTE INITIAL
        ('    file does not contain a program version number', CR,LF);

DECLARE FILE$NAME (15) BYTE INITIAL (':F0:           ');
DECLARE BUFFER(READ$BUFFER$LENGTH)     BYTE;
DECLARE SUCCESSFUL$FIND  BYTE;
DECLARE END$OF$FILE      BYTE;
DECLARE STATUS ADDRESS;
DECLARE ACTUAL ADDRESS;
DECLARE AFTN$IN ADDRESS;
DECLARE I   BYTE;
DECLARE (LEN, LEN1)  ADDRESS;
DECLARE STRING$INDEX  BYTE;
DECLARE BUFFER$INDEX ADDRESS;
DECLARE BUFFER$PTR  ADDRESS;
DECLARE VERSION$MSG$LENGTH ADDRESS;
DECLARE PROGRAM$MSG$PRINTED BOOLEAN;

/********************************************************/
/*              UTILITY   PROCEDURES                    */
/********************************************************/

SKIP$BLANKS$N$TABS:  PROCEDURE (CHAR$PTR) ADDRESS  ;
  DECLARE CHAR$PTR ADDRESS;
  DECLARE CHAR BASED CHAR$PTR BYTE;

  DO WHILE (CHAR = BLANK)  OR  (CHAR = TAB);
    CHAR$PTR = CHAR$PTR + 1;
  END;

  RETURN CHAR$PTR;
END SKIP$BLANKS$N$TABS;

CHECK$STATUS:  PROCEDURE (ISIS$STATUS);
  DECLARE ISIS$STATUS ADDRESS;

  IF ISIS$STATUS <> 0  THEN
  DO;
    CALL ERROR(ISIS$STATUS);
    CALL EXIT;
  END;
END CHECK$STATUS;

STOP$EVERYTHING:  PROCEDURE(MSG$PTR);
  DECLARE MSG$PTR ADDRESS,
    MSG BASED MSG$PTR (256) BYTE;
  DECLARE MSG$LENGTH ADDRESS;

  MSG$LENGTH = 0;

  DO WHILE (MSG(MSG$LENGTH) <> 0)  AND  (MSG$LENGTH < 255);
    MSG$LENGTH = MSG$LENGTH + 1;
  END;

  CALL WRITE(CONSOLE$OUTPUT, MSG$PTR, MSG$LENGTH, .STATUS);
   CHK;
  CALL CO(BELL);
  CALL EXIT;
END STOP$EVERYTHING;

CAPITALIZE:  PROCEDURE(PTR, LEN);
  DECLARE  PTR ADDRESS,
    CHAR BASED PTR BYTE;
  DECLARE  LEN  BYTE;
  DECLARE  I  BYTE;

  DO  I = 1 TO LEN;
    IF CHAR >= 'a'  AND  CHAR <= 'z'  THEN
      CHAR = CHAR - SPACE;
    PTR = PTR + 1;
  END;
END CAPITALIZE;

ASCII$DIGIT:  PROCEDURE (CHAR) BOOLEAN;
  DECLARE  CHAR  BYTE;
  IF CHAR >= '0'  AND CHAR <= '9'  THEN
    RETURN TRUE;
  ELSE
    RETURN FALSE;
END ASCII$DIGIT;

FILE$NAME$LENGTH:  PROCEDURE(PTR)  BYTE;
  DECLARE PTR ADDRESS;
  DECLARE CHAR BASED PTR  BYTE;
  DECLARE TMP$PTR ADDRESS;

  TMP$PTR = PTR;
    DO WHILE   ( CHAR >= 'A'  AND  CHAR <= 'Z' )
            OR ( ASCII$DIGIT(CHAR) )
            OR  CHAR = '.'
            OR  CHAR = ':'      ;
      PTR = PTR + 1;
    END;
  TMP$PTR = PTR - TMP$PTR;
  IF TMP$PTR > 14  THEN
  DO;
    CALL ERROR(4);  /*  illegal filename specification  */
    CALL EXIT;
  END;
  RETURN  TMP$PTR;
END FILE$NAME$LENGTH;

STRING$FOUND:  PROCEDURE (BUFFER$PTR, LEN0)  BOOLEAN;
  DECLARE BUFFER$PTR ADDRESS;
  DECLARE LEN0   ADDRESS;
  DECLARE BUFFER$CHAR BASED BUFFER$PTR(256) BYTE;

  BUFFER$INDEX = 0;
  DO WHILE  BUFFER$INDEX < LEN0  AND  STRING$INDEX < LEN1;
    IF BUFFER$CHAR(BUFFER$INDEX) = STRING$TO$SEARCH(STRING$INDEX)  THEN
      STRING$INDEX = STRING$INDEX + 1;
    ELSE
      STRING$INDEX = 0;
    BUFFER$INDEX = BUFFER$INDEX + 1;
  END;

  IF STRING$INDEX >= LEN1  THEN
    RETURN TRUE;
  ELSE
    RETURN FALSE;
END STRING$FOUND;

CHECK$VERSION$NUMBER:  PROCEDURE(CHAR$PTR) ;
  DECLARE CHAR$PTR  ADDRESS,
    CHAR BASED CHAR$PTR BYTE;
  DECLARE (VERSION$TYPE$V, VERSION$TYPE$X)  BYTE;

  VERSION$TYPE$V, VERSION$TYPE$X = FALSE;
  IF CHAR = 'V'  THEN
    VERSION$TYPE$V = TRUE;
  ELSE
    IF CHAR = 'X'  THEN
      VERSION$TYPE$X = TRUE;

  IF VERSION$TYPE$V  OR  VERSION$TYPE$X  THEN
  DO;
    VERSION$MSG$LENGTH = 4;
    PROGRAM$MSG$PRINTED = TRUE;
    CHAR$PTR = CHAR$PTR + 1;
    IF ASCII$DIGIT(CHAR)  THEN
    DO;
      CHAR$PTR = CHAR$PTR + 1;
      IF (CHAR = '.'  AND  VERSION$TYPE$V)  OR
         (ASCII$DIGIT(CHAR)  AND  VERSION$TYPE$X)  THEN
      DO;
        CHAR$PTR = CHAR$PTR + 1;
        IF  ASCII$DIGIT(CHAR)  THEN
          RETURN;
      END;
    END;
  END;

  IF CHAR = SENTINEL$1 THEN DO;  /* LOOK FOR  1...0  COMBINATION  */
    CHAR$PTR = CHAR$PTR + 1;  /* ADVANCE BEYOND THE SENTINEL  */
    BUFFER$PTR = BUFFER$PTR + 1;  /* DON'T PRINT THE SENTINEL  */
    PROGRAM$MSG$PRINTED = FALSE;
    VERSION$MSG$LENGTH = 0;
    DO WHILE CHAR <> SENTINEL$0;  /*  DETERMINE THE MESSAGE LENGTH  */
      VERSION$MSG$LENGTH = VERSION$MSG$LENGTH + 1;
      CHAR$PTR = CHAR$PTR + 1;
    END;
    RETURN;
  END;

  SUCCESSFUL$FIND = FALSE;
  STRING$INDEX = 0;
END CHECK$VERSION$NUMBER;

/*******************************************************/
/*   MAIN  PROCEDURES    */
/*******************************************************/

PARSE$COMMAND$TAIL:  PROCEDURE;

  DECLARE COMMAND$TAIL(140) BYTE;
  DECLARE CHAR$PTR ADDRESS,
    CHAR BASED CHAR$PTR BYTE;

  CALL READ(CONSOLE$INPUT, .COMMAND$TAIL, LENGTH(COMMAND$TAIL), .ACTUAL,
   .STATUS);  CHK;

  COMMAND$TAIL(ACTUAL - 1) = CR;
  CALL CAPITALIZE(.COMMAND$TAIL, ACTUAL);
  CHAR$PTR = SKIP$BLANKS$N$TABS(.COMMAND$TAIL);

  LEN = FILE$NAME$LENGTH(CHAR$PTR);
  IF CHAR = ':'  THEN
    DO I = 0  TO  LEN;
      FILE$NAME(I) = CHAR;
      CHAR$PTR = CHAR$PTR + 1;
    END;
  ELSE
    DO I = 4  TO  LEN + 4;
      FILE$NAME(I) = CHAR;
      CHAR$PTR = CHAR$PTR + 1;
    END;

  CHAR$PTR = SKIP$BLANKS$N$TABS(CHAR$PTR );
  IF CHAR <> CR  THEN
    CALL STOP$EVERYTHING(.('Syntax is "WHICH  <file name>" ',CR, LF, 0));

END PARSE$COMMAND$TAIL;

SEARCH$FOR$STRING:  PROCEDURE;

  CALL OPEN(.AFTN$IN, .FILE$NAME, OPEN$FOR$READ, NO$LINE$EDIT, .STATUS);
   CHK;

  LEN1 = LENGTH(STRING$TO$SEARCH);
  SUCCESSFUL$FIND, END$OF$FILE = FALSE;
  STRING$INDEX = 0;

  DO WHILE  NOT  END$OF$FILE;
    CALL READ(AFTN$IN, .BUFFER, READ$BUFFER$LENGTH, .ACTUAL, .STATUS);
    CHK;
    IF ACTUAL < READ$BUFFER$LENGTH  THEN
      END$OF$FILE = TRUE;

    BUFFER$PTR = .BUFFER;

    DO WHILE NOT SUCCESSFUL$FIND  AND  BUFFER$PTR < .BUFFER(ACTUAL);
      SUCCESSFUL$FIND = STRING$FOUND(BUFFER$PTR, .BUFFER(ACTUAL) - BUFFER$PTR);
      BUFFER$PTR = BUFFER$PTR + BUFFER$INDEX;
      IF SUCCESSFUL$FIND  THEN
        DO;
          CALL CHECK$VERSION$NUMBER(BUFFER$PTR);
          IF SUCCESSFUL$FIND  THEN
            END$OF$FILE = TRUE;
        END;
    END;
  END;
END SEARCH$FOR$STRING;

PRINT$RESULT:  PROCEDURE;

  IF  SUCCESSFUL$FIND  THEN
    DO;
      IF PROGRAM$MSG$PRINTED THEN
      DO;
        CALL WRITE(CONSOLE$OUTPUT, .FOUND$MSG, LENGTH(FOUND$MSG), .STATUS);
        CHK;
      END;
      CALL WRITE(CONSOLE$OUTPUT, BUFFER$PTR, VERSION$MSG$LENGTH, .STATUS); CHK;
      CALL WRITE(CONSOLE$OUTPUT, .(CRLF), 2, .STATUS);  CHK;
    END;
  ELSE
    DO;
      CALL WRITE(CONSOLE$OUTPUT, .NOT$FOUND$MSG, LENGTH(NOT$FOUND$MSG),
                       .STATUS);  CHK;
    END;

  CALL CLOSE(AFTN$IN, .STATUS);  CHK;
END PRINT$RESULT;

$EJECT

/*********************************************************/
/*  MAIN  EXECUTABLE  CODE    */
/*********************************************************/

CALL PARSE$COMMAND$TAIL;
CALL SEARCH$FOR$STRING;
CALL PRINT$RESULT;
CALL EXIT;

END
WHICH$MOD;
src/xlate2.plm
XLATE2$MOD:
DO;

/************************************************************************/
/*																		*/
/*     'Copyright 1981,1983 Intel Corporation'.  All rights reserved.	*/
/*      No part of this program or publication may be reproduced,		*/
/*      transmitted, transcribed, stored in a retrievel system, or		*/
/*      translated into any language or computer language, in any		*/
/*      form or by any means, electronic, mechanical, magnetic,			*/
/*      optical, chemical, manual or otherwise, without the prior		*/
/*      written permission of Intel Corporation, 3065 Bowers			*/
/*      Avenue, Santa Clara, California, 95051, Attn: Software			*/
/*      License Administration.											*/
/*																		*/
/************************************************************************/

$IF XVERSION
DECLARE PROPRIETARY(*) BYTE DATA ('INTEL PROPRIETARY SOFTWARE');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=X103',0);
$ELSE
DECLARE COPYRIGHT (*) BYTE DATA  ('COPYRIGHT 1981,1983 INTEL ');
DECLARE PROGRAM$VERSION$NUMBER$STRING (*) BYTE DATA
    ('program_version_number=V1.1',0);
$ENDIF


DECLARE LIT     LITERALLY 'LITERALLY',
  DCL     LIT  'DECLARE',
  TRUE    LIT  '0FFH',
  FALSE   LIT  '000H',
  PROC    LIT  'PROCEDURE',
  ENDPROC LIT  'END;',
  THENN   LIT  'THEN DO;',
  ELLSE   LIT  'END; ELSE DO;',
  ELSIF   LIT  'END; ELSE IF',
  ENDIF   LIT  'END;',
  ENDDO   LIT  'END;',
  CR      LIT  '0DH',
  LF      LIT  '0AH',
  NULL    LIT  '0',
  CHK     LIT  'CALL CHECK$ISIS$STATUS(STATUS)',
  TOEND   LIT  '7FFFH',
  TOBEG   LIT  '08000H';

DCL comtrace            LIT '/*';   /* for debugging procedure trace */

DCL PCNT$0$TYPE         LIT '0',
    PCNT$0$DOT$TYPE     LIT '1',
    PCNT$0$DOT$EXT$TYPE LIT '2',
    NUMB$0$TYPE         LIT '3';

DCL NAME$DOT$TYPE       LIT  '0',
    NAME$DOT$EXT$TYPE   LIT  '1',
    NAME$ONLY$TYPE      LIT  '2';

DCL UNKNOWN$TYPE        LIT  '10';

DCL NAME$ADDED          LIT  '1',
    NEW$LINE            LIT  '3',
    DONE                LIT  '0';

DCL NO$NUM$EXTENSION    LIT '0FFFFH';

$EJECT
EXIT: PROC EXTERNAL; END;
RESCAN: PROC (AFT,ST) EXTERNAL; DCL (AFT,ST) ADDRESS; END;
CO: PROC (CHR) EXTERNAL; DCL CHR BYTE; END;
READC: PROC (PTR,LEN) EXTERNAL; DCL (PTR,LEN) ADDRESS; END;
READI: PROC (PTR,LEN) EXTERNAL; DCL (PTR,LEN) ADDRESS; END;
READ1: PROC (PTR,LEN) EXTERNAL; DCL (PTR,LEN) ADDRESS; END;
OPENO: PROC (PTR) EXTERNAL; DCL PTR ADDRESS; END;
OPENI: PROC (PTR) EXTERNAL; DCL PTR ADDRESS; END;
OPEN1: PROC (PTR,MO) EXTERNAL; DCL PTR ADDRESS,MO BYTE; END;
CLOSEO: PROC EXTERNAL; END;
CLOSEI: PROC EXTERNAL; END;
CLOSE1: PROC EXTERNAL; END;
CONS: PROC (P1,P2) EXTERNAL; DCL (P1,P2) ADDRESS; END;
SEEK: PROC (A,M,B,C,S) EXTERNAL; DCL (A,M,B,C,S) ADDRESS; END;
SCANMATCH: PROC(P) BYTE EXTERNAL; DCL P ADDRESS; END;
SCAN$WHILE: PROC(P) EXTERNAL; DCL P ADDRESS; END;
SCAN$UNTIL: PROC(P) EXTERNAL; DCL P ADDRESS; END;
TERM$CH: PROC BYTE EXTERNAL; END;
OUT$CHAR: PROC (CHAR) EXTERNAL; DCL CHAR BYTE; END;
OUT$PRINT: PROC (PTR) EXTERNAL; DCL PTR ADDRESS; END;
OUT$DEC$R: PROC (VAL,W)  EXTERNAL; DCL  VAL ADDRESS, W BYTE; END;
DEC$IN: PROC ADDRESS EXTERNAL; END;
DEL: PROC(PTR) EXTERNAL; DCL PTR ADDRESS; END;
FMOVE: PROC (C,S,D) EXTERNAL; DCL (C,S,D) ADDRESS; END;
WHOCI: PROC (PTR) EXTERNAL; DCL PTR ADDRESS; END;
WHOCO: PROC (PTR) EXTERNAL; DCL PTR ADDRESS; END;
WRITEO: PROC(P,L) EXTERNAL; DCL (P,L) ADDRESS; END;
WRITEC: PROC(P,L) EXTERNAL; DCL (P,L) ADDRESS; END;
ERROR: PROC(ERROR$NO) EXTERNAL; DCL ERROR$NO ADDRESS; END;
MEM$CK: PROC ADDRESS EXTERNAL; END;
SPATH: PROC(FILE,BUFFER,STATUS) EXTERNAL;
       DCL (FILE,BUFFER,STATUS) ADDRESS; END;
LOAD: PROC(FILE,BIAS,SWITCH,ENTRY,STATUS) EXTERNAL;
      DCL (FILE,BIAS,SWITCH,ENTRY,STATUS) ADDRESS; END;
GETD: PROC(DRIVE,CON,COUNT,ACTUAL$COUNT,BUFFER,STATUS) EXTERNAL;
      DCL (DRIVE,CON,COUNT,ACTUAL$COUNT,BUFFER,STATUS) ADDRESS; END;
WRITE:PROC(AFTN,BUFFER,COUNT,STATUS) EXTERNAL;
      DCL (AFTN,BUFFER,COUNT,STATUS) ADDRESS; END;

DCL (STATUS,REPORT,ERRED,FATAL,ACTUAL) ADDRESS EXTERNAL;
DCL (SCANP,OBUFP,GIVEUP) ADDRESS EXTERNAL,
    (SCANENDED,TARLEN,JOKER) BYTE EXTERNAL;
DCL LEADCHAR BYTE EXTERNAL;

$EJECT
DCL SCANBYTE BASED SCANP BYTE,
    SCANP$TMP ADDRESS;
DCL BLOKNO ADDRESS, BYTENO ADDRESS;

/*********************************************
    G L O B A L   S T R U C T U R E S
*********************************************/
DCL NAMEINDEX ADDRESS;
DCL MAXINDEX  LIT '200';
DCL NAME$LIST (MAXINDEX) STRUCTURE (
      DRIVE (4) BYTE,
      NAME  (6) BYTE,
      EXT   (3) BYTE,
      TYPE BYTE);

DCL FILL$INDEX BYTE;
DCL MAX$FILLS LIT '30';
DCL FILL$ARRAY (MAX$FILLS) STRUCTURE (
      FILL$PTR ADDRESS,
      TYPE BYTE,
      EXT (4) BYTE,
      DRIVE (4) BYTE);

/*********************************************
       G L O B A L   V A R I A B L E S
*********************************************/

DCL FRONT$EXT       LIT '512',
    READ$LEN        LIT '1024';
DCL TEMPLATE (1536) BYTE;
DCL PAD             BYTE;  /* this is a pad for template, do not disturb */
DCL INVOK$NAME (16) BYTE;

DCL (FROM$PTR, FILL$PTR) ADDRESS;
DCL ENDOFLIST       BYTE;

DCL DEBUG$FLAG      BYTE INITIAL (FALSE);
DCL HALT$FLAG       BYTE INITIAL (FALSE);
DCL SCRUNCH$FLAG    BYTE INITIAL (FALSE);

DCL TARGET (10)     BYTE PUBLIC ;
DCL READBUF (129)   BYTE;
DCL MSG$BUF (128)   BYTE;
DCL BLANK$STR (16)  BYTE DATA('                ');
DCL NULLSTRING(16)  BYTE DATA(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
DCL DR$STR(4)       BYTE DATA(':F#:');

DCL LENGTH$TO$WRITE$FROM$TEMPLATE ADDRESS;
DCL MONITOR ADDRESS DATA(0);
DCL CONNECTION ADDRESS INITIAL(0);
DCL MEM$TOP ADDRESS;
DCL END$OF$DIRECTORY ADDRESS;
DCL READING$REMOTE BYTE;

/*********************************************
    D I R E C T O R Y    G L O B A L S
*********************************************/
DCL DIR$TO$SEARCH BYTE;
DCL DIRECTORY$NAME (*) BYTE INITIAL(':F :ISIS.DIR ');
DCL DIR$BUF  (16384) BYTE;
DCL DIR$ENTRY$PTR ADDRESS,
    DIR$ENTRY BASED DIR$ENTRY$PTR STRUCTURE (
      PRESENCE BYTE,
      FILENAME (6) BYTE,
      EXTENSION (3) BYTE,
      ATTRIBUTES BYTE,
      EOF$COUNT BYTE,
      NUM$DATA$BLKS ADDRESS,
      HEADER$BLK$PTR ADDRESS);

$EJECT
/*********************************************
    C O M M O N      P R O C E D U R E S
*********************************************/
PRINT: PROC (PTR);
  DCL (TMP$PTR,PTR) ADDRESS,CHR BASED PTR BYTE;
  TMP$PTR = PTR;
  DO WHILE CHR <> NULL;
     PTR = PTR + 1;
  ENDDO
  CALL WRITEC(TMP$PTR,PTR-TMP$PTR);
END PRINT;

PRINT$CR: PROC (PTR);
  DCL PTR ADDRESS;
  CALL PRINT(PTR);
  CALL PRINT(.(CR,LF,0));
END PRINT$CR;

PRINT$CR$EXIT: PROC (PTR);
  DCL PTR ADDRESS;
  CALL PRINT$CR(PTR);
  CALL EXIT;
END;

CHK$STATUS: PROC (PTR);
  DCL PTR ADDRESS;
  DCL STATUS$OUT ADDRESS;
  IF STATUS <> 0 THENN
     STATUS$OUT = STATUS;
     CALL PRINT(.('bad status (= ',0));
     OBUFP = .MSG$BUF;
     CALL OUT$DEC$R(STATUS$OUT,5);
     CALL OUTPRINT(.(') ',0));
     CALL OUTCHAR(NULL);
     CALL PRINT(.MSG$BUF);
     CALL PRINT$CR$EXIT(PTR);
  ENDIF
END CHK$STATUS;

CHECK$ISIS$STATUS: PROC(ISIS$STATUS);
   DCL ISIS$STATUS  ADDRESS;
   IF ISIS$STATUS <> 0  THEN
     DO;
       CALL ERROR(ISIS$STATUS);
       CALL EXIT;
     END;
END CHECK$ISIS$STATUS;

comtrace BEG$PR$DEBUG: PROC ( PTR,VAL,PROC$PTR);
           DCL (PTR,PROC$PTR) ADDRESS, VAL BYTE;
           IF DEBUG$FLAG THENN
              DO WHILE VAL > 0;
                 CALL PRINT(.('.',0));
                 VAL = VAL - 1;
              ENDDO
              CALL PRINT(.('entering ',0));
              CALL PRINT$CR(PTR);
              CALL PROC$PTR;
           ENDIF
         END BEG$PR$DEBUG;

comtrace END$PR$DEBUG: PROC( PTR,VAL,PROC$PTR);
            DCL (PTR,PROC$PTR) ADDRESS, VAL BYTE;
           IF DEBUG$FLAG THENN
              DO WHILE VAL > 0;
                 CALL PRINT(.('.',0));
                 VAL = VAL - 1;
              ENDDO
              CALL PRINT(.('leaving  ',0));
              CALL PRINT$CR(PTR);
              CALL PROC$PTR;
           ENDIF
         END END$PR$DEBUG;                            /* opt */

DEBLANK: PROC (PTR) ADDRESS;
 DCL PTR ADDRESS,CHR BASED PTR BYTE;
 DO WHILE CHR = ' ';
  PTR = PTR + 1;
 ENDDO
 RETURN PTR;
END DEBLANK;

LESSER$OF: PROC (VAL1,VAL2) ADDRESS;
  DCL (VAL1,VAL2) ADDRESS;
  IF VAL1 > VAL2 THENN
     RETURN VAL2;
  ELLSE
     RETURN VAL1;
  ENDIF
END LESSER$OF;

LET$CH$WP: PROC (CHAR) BYTE;
  DCL CHAR BYTE;
   RETURN
   ( (CHAR >= 'a' AND CHAR <= 'z') OR
     (CHAR >= 'A' AND CHAR <= 'Z')  );
END LET$CH$WP;

DIG$CH$WP: PROC (CHAR) BYTE;
  DCL CHAR BYTE;
  RETURN ((CHAR >= '0' AND CHAR <= '9'));
END DIG$CH$WP;

LET$OR$DIG$CH$WP: PROC (CHAR) BYTE;
  DCL CHAR BYTE;
  RETURN (LET$CH$WP(CHAR) OR DIG$CH$WP(CHAR));
END LET$OR$DIG$CH$WP;

DOT$CH$WP: PROC (CHAR) BYTE;
  DCL CHAR BYTE;
  RETURN (CHAR = '.');
END DOT$CH$WP;

COLON$CH$WP: PROC (CHAR) BYTE;
   DCL CHAR BYTE;
   RETURN (CHAR = ':');
END COLON$CH$WP;

FILE$CH$WP: PROC (CHAR) BYTE;
   DCL CHAR BYTE;
   RETURN( LET$OR$DIG$CH$WP(CHAR) OR DOT$CH$WP(CHAR) OR COLON$CH$WP(CHAR));
END FILE$CH$WP;

BLANK$CH$WP: PROC (CHAR) BYTE;
   DCL CHAR BYTE;
   RETURN (CHAR = ' ');
END BLANK$CH$WP;

LENGTH$OF: PROC (PROC$PTR) ADDRESS;
  DCL (PROC$PTR,TMP$PTR,LEN) ADDRESS;
  TMP$PTR = SCANP;
  CALL SCANWHILE(PROC$PTR);
  LEN = SCANP - TMP$PTR;
  SCANP = TMP$PTR;
  RETURN LEN;
END LENGTH$OF;

NULL$PROC: PROC;
  SCANP = SCANP;
END NULL$PROC;

ENFORCE$LESS$OR$EQUAL: PROC (VAL,LIM$VAL,PROC$PTR);
   DCL(VAL,LIM$VAL,PROC$PTR) ADDRESS;
   IF VAL > LIM$VAL THEN CALL PROC$PTR;
END ENFORCE$LESS$OR$EQUAL;

ENFORCE$GREATER$OR$EQUAL: PROC (VAL,LIM$VAL,PROC$PTR);
   DCL(VAL,LIM$VAL,PROC$PTR) ADDRESS;
   IF VAL < LIM$VAL THEN CALL PROC$PTR;
END ENFORCE$GREATER$OR$EQUAL;

ENFORCE$WITHIN$BOUNDS: PROC (VAL,HI$LIM,LO$LIM,PROC$PTR);
   DCL(VAL,HI$LIM,LO$LIM,PROC$PTR) ADDRESS;
   CALL ENFORCE$LESS$OR$EQUAL(VAL,HI$LIM,PROC$PTR);
   CALL ENFORCE$GREATER$OR$EQUAL(VAL,LO$LIM,PROC$PTR);
END ENFORCE$WITHIN$BOUNDS;

LET$CH: PROC BYTE;
  RETURN(LET$CH$WP(SCANBYTE));
END LET$CH;

LP: PROC BYTE;
  RETURN(SCANBYTE='(');
END LP;

COMMA: PROC BYTE;
  RETURN(SCANBYTE=',');
END COMMA;

DIG$CH: PROC BYTE;
  RETURN(DIG$CH$WP(SCANBYTE));
END DIG$CH;

LET$OR$DIG$CH: PROC BYTE;
  RETURN (LET$OR$DIG$CH$WP(SCANBYTE));
END LET$OR$DIG$CH;

DOT$CH: PROC BYTE;
  RETURN(DOT$CH$WP(SCANBYTE));
END DOT$CH;

COLON$CH: PROC BYTE;
  RETURN(COLON$CH$WP(SCANBYTE));
END COLON$CH;

FILE$CH: PROC BYTE;
   RETURN(LET$OR$DIG$CH$WP(SCANBYTE)
   OR DOT$CH$WP(SCANBYTE)OR COLON$CH$WP(SCANBYTE) );
END FILE$CH;

BLANK$CH: PROC BYTE;
   RETURN(BLANK$CH$WP(SCANBYTE));
END BLANK$CH;

NULL$CH: PROC BYTE;
   RETURN (SCANBYTE = NULL);
END NULL$CH;

ENFORCE$NO$TOKENS: PROC;
  DO WHILE NOT TERM$CH ;
     IF NOT  BLANK$CH  THENN
       CALL PRINT$CR$EXIT(.('only blanks allowed after &',0));
     ENDIF
     SCANP = SCANP + 1;
  ENDDO
END ENFORCE$NO$TOKENS;

RESTORE: PROC;
  /* this procedure interprets the restore command in the xlate2.cs file */
  /* restores the previous :ci: file and deletes the xlate2.cs file      */
  DCL NAME$CI (16) BYTE;
  DCL CI$PTR ADDRESS;
  LP: PROC BYTE;
      RETURN (SCANBYTE='(');
  END LP;
  COMMA: PROC BYTE;
      RETURN (SCANBYTE=',');
  END COMMA;
  comtrace DCL PROC$NAME (*) BYTE DATA('restore',0);               /* opt */
  comtrace CALL BEG$PR$DEBUG(.PROC$NAME,1,.NULL$PROC);             /* opt */
  CALL FMOVE(15,.BLANK$STR,.NAME$CI);                     /* current :ci: */
  CALL WHOCI(.NAME$CI);    /* current :ci: name saved, file to be deleted */
  CALL CONS(CI$PTR:=DEBLANK(SCANP),.(':CO: '));    /* new :ci:, same :co: */
  SCANP = CI$PTR + 1;
  IF SCANBYTE = 'F' THENN                /* old :ci: = :f?:... --> delete */
     DCL MSG(*) BYTE DATA('xlate2 error: restore seek',0);
     CALL DEL(.NAME$CI);                 /* and console over to old pos   */
     CALL CHK$STATUS(.('cannot delete .cs file',0));
     CALL SCANUNTIL(.LP);
     BLOKNO = DEC$IN;
     CALL SCANUNTIL(.COMMA);
     BYTENO = DEC$IN;
     CALL SEEK(1,2,.BLOKNO,.BYTENO,.STATUS);
     CALL CHK$STATUS(.MSG);
  ENDIF
  CALL EXIT;                           /* f i n i s h e d  ! ! ! */
  comtrace CALL END$PR$DEBUG(.PROC$NAME,1,.NULL$PROC); /* opt */
END RESTORE;

$EJECT

/***************************************************
           I N I T I A L I Z A T I O N
***************************************************/

FIRST$INIT: PROC;
   DCL TMP$PTR ADDRESS;
   comtrace DCL PROC$NAME (*) BYTE DATA('first$init',0); /* opt */
   comtrace CALL BEG$PR$DEBUG(.PROC$NAME,1,.NULL$PROC); /* opt */
   REPORT = FALSE;              /* set sys.lib status checking to false */
   CALL FMOVE(16,.BLANK$STR,.INVOK$NAME);
   NAME$INDEX = 0;
   FILL$INDEX = 0;
   READBUF(128) = CR;
   comtrace CALL END$PR$DEBUG(.PROC$NAME,1,.NULL$PROC); /* opt */
END FIRST$INIT;

$EJECT

/****************************************************
       T E M P L A T E   P R O C E S S I N G
               P R O C E D U R E S
****************************************************/
/****************************************************
   these procedures
   1) read in the template file
   2) expand the template file at the substitution
      characters
   3) fills an array of pointers into
      the expanded template.
   4) fill an array describing the type of sub.
      parameter, preceding drive # , etc.
*****************************************************/

BUILD$TEMPLATE: PROC ;
   DCL (BEG$SUB$PTR,END$SUB$PTR) ADDRESS;

   SUBSTITUTION$FOUND: PROC (F$INDEX,B$PTR$PTR,E$PTR$PTR,LIMIT) BYTE;
     DCL (F$INDEX, B$PTR$PTR, E$PTR$PTR, LIMIT, TMP$PTR) ADDRESS;

     SET$FILL$DRIVE: PROC (F$INDEX,B$PTR$PTR);
       DCL (F$INDEX,B$PTR$PTR) ADDRESS, B$PTR BASED B$PTR$PTR ADDRESS;
       DCL TMP$PTR ADDRESS;
       comtrace DCL PROC$NAME (*) BYTE DATA('set$fill$drive',0);
                   PR$DEBUG: PROC;
                   CALL PRINT(.('fill index : ',0));
                   OBUFP = .MSG$BUF;
                   CALL OUT$DEC$R(F$INDEX,5);
                   CALL OUT$CHAR(NULL);
                   CALL PRINT$CR(.MSG$BUF);
                END PR$DEBUG;
                CALL BEG$PR$DEBUG(.PROC$NAME,3,.PR$DEBUG);       /* opt */

       TMP$PTR = SCANP;
       SCANP = SCANP - 2;
       IF          COLON$CH          THENN
          SCANP = SCANP - 3;
          B$PTR = SCANP;
          CALL FMOVE(4,SCANP,.FILL$ARRAY(F$INDEX).DRIVE);
          SCANP = SCANP + 2;
          IF   SCANBYTE = '?'   THENN
             CALL FMOVE(1,.DIR$TO$SEARCH,.FILL$ARRAY(F$INDEX).DRIVE(2));
          ENDIF
       ELLSE
          CALL FMOVE(4,.NULL$STRING,.FILL$ARRAY(F$INDEX).DRIVE);
          B$PTR = SCANP + 1;
       ENDIF
       SCANP = TMP$PTR;
       comtrace CALL END$PR$DEBUG(.PROC$NAME,3,.NULL$PROC); /* opt */
     END SET$FILL$DRIVE;

     SET$FILL$EXT: PROC (F$INDEX,E$PTR$PTR);
        DCL (F$INDEX,E$PTR$PTR) ADDRESS,
             E$PTR BASED E$PTR$PTR ADDRESS;
        comtrace DCL PROC$NAME (*) BYTE DATA('set$fill$ext',0); /* opt */
        comtrace CALL BEG$PR$DEBUG(.PROC$NAME,3,.NULL$PROC);    /* opt */
        SCANP = SCANP - 1;
        IF           SCANBYTE = '#'               THENN
           E$PTR,SCANP = SCANP + 2;
           FILL$ARRAY(F$INDEX).TYPE = NUMB$0$TYPE;
        ELSIF        SCANBYTE = '%'               THENN
           SCANP = SCANP + 2;
           IF         BLANK$CH            THENN
              E$PTR = SCANP;
              FILL$ARRAY(F$INDEX).TYPE = PCNT$0$TYPE;
           ELSIF       DOT$CH             THENN
              SCANP = SCANP + 1;
              IF NOT (LET$OR$DIG$CH) THENN
                 E$PTR = SCANP;
                 FILL$ARRAY(F$INDEX).TYPE = PCNT$0$DOT$TYPE;
              ELLSE
                    DCL LEN$EXT ADDRESS;
                    FILL$ARRAY(F$INDEX).TYPE = PCNT$0$DOT$EXT$TYPE;
                    LEN$EXT = LENGTH$OF(.LET$OR$DIG$CH);
                    IF LEN$EXT > 3 THENN
                       CALL PRINT$CR$EXIT(.('ext part too long',0));
                    ELLSE
                       CALL FMOVE(3,.BLANK$STR ,.FILL$ARRAY(F$INDEX).EXT);
                       CALL FMOVE(LEN$EXT,SCANP,.FILL$ARRAY(F$INDEX).EXT);
                       E$PTR,SCANP = SCANP + LEN$EXT;
                    ENDIF
              ENDIF
           ELLSE
              FILL$ARRAY(F$INDEX).TYPE = UNKNOWN$TYPE;
              E$PTR = SCANP;
           ENDIF
        ELLSE
           CALL PRINT$CR$EXIT(.('xlate2 error: set$fill$index',0));
        ENDIF
        E$PTR = LESSER$OF(E$PTR,.TEMPLATE+FRONT$EXT+ACTUAL);
        comtrace CALL END$PR$DEBUG(.PROC$NAME,3,.NULL$PROC);       /* opt */
     END SET$FILL$EXT;

     comtrace DCL PROC$NAME (*) BYTE DATA('substitution$found',0); /* opt */
     comtrace CALL BEG$PR$DEBUG(.PROC$NAME,2,.NULL$PROC);          /* opt */
     DO WHILE TRUE;
        DO WHILE SCANBYTE <> '%' AND SCANBYTE <> '#' ;
           SCANP = SCANP + 1;
        ENDDO
        SCANP = SCANP + 1;
        IF           SCANBYTE = '0' AND SCANP <= LIMIT          THENN
           DCL TMP$PTR ADDRESS;
           TMP$PTR = SCANP;
           CALL SET$FILL$DRIVE(F$INDEX,B$PTR$PTR);
           CALL SET$FILL$EXT(F$INDEX,E$PTR$PTR);
           SCANP = TMP$PTR;
           comtrace CALL END$PR$DEBUG(.PROC$NAME,2,.NULL$PROC);    /* opt */
           RETURN TRUE;
        ELSIF                 SCANP > LIMIT                     THENN
           comtrace CALL END$PR$DEBUG(.PROC$NAME,2,.NULL$PROC);    /* opt */
           RETURN FALSE;
        ENDIF
     ENDDO
   END SUBSTITUTION$FOUND;

   comtrace DCL PROC$NAME (*) BYTE DATA('build$template',0);       /* opt */
   comtrace CALL BEG$PR$DEBUG(.PROC$NAME,1,.NULL$PROC);            /* opt */
   CALL READI(.TEMPLATE+FRONT$EXT, READ$LEN);
   CALL CHK$STATUS(.('cannot read template file',0));
   TEMPLATE(FRONT$EXT + ACTUAL) = NULL;
   IF ACTUAL = 1024 THENN                  /* syntax chk opt */
      CALL PRINT$CR$EXIT(.('template file too large',0));
   ENDIF
   FROM$PTR,SCANP = .TEMPLATE+FRONT$EXT;
   FILL$PTR = .TEMPLATE;
   DO WHILE SUBSTITUTION$FOUND(FILL$INDEX,.BEG$SUB$PTR,.END$SUB$PTR,
                               .TEMPLATE(FRONT$EXT+ACTUAL-1));
      CALL FMOVE(BEG$SUB$PTR-FROM$PTR,FROM$PTR,FILL$PTR);
      FILL$PTR = FILL$PTR + BEG$SUB$PTR-FROM$PTR;
      FILL$ARRAY(FILL$INDEX).FILL$PTR = FILL$PTR;
      FILL$PTR = FILL$PTR + 16;
      FROM$PTR,SCANP = END$SUB$PTR;
      IF (FILL$INDEX := FILL$INDEX + 1) > MAX$FILLS THENN
         CALL PRINT$CR$EXIT(.('maximum substitutions exceeded',0));
      ENDIF
   ENDDO
   IF FILL$INDEX = 0 THENN
      CALL PRINT$CR$EXIT(
         .('no substitution signs in the template',0));
   ELLSE
      FILL$INDEX = FILL$INDEX - 1;
   ENDIF
   IF FROM$PTR  >  .TEMPLATE+ACTUAL+FRONT$EXT THENN
      CALL PRINT$CR$EXIT(.('xlate2 error: build$template',0));
   ENDIF
   CALL FMOVE(.TEMPLATE+FRONT$EXT+ACTUAL-FROM$PTR, FROM$PTR, FILL$PTR);
   /* this is a kludge, we want to add the -1 in the fmove but
      dont because we might end up with a 64k move, so we only
      adjust the fill$ptr accordingly.
   */
   FILL$PTR = FILL$PTR + .TEMPLATE+FRONT$EXT+ACTUAL - FROM$PTR;
   LENGTH$TO$WRITE$FROM$TEMPLATE = FILL$PTR - .TEMPLATE;
   CALL FMOVE(1,.(0),(FILL$PTR+1));
   comtrace CALL END$PR$DEBUG(.PROC$NAME,1,.NULL$PROC);     /* opt */
END BUILD$TEMPLATE;

$ EJECT

/**************************************************
  D I R E C T O R Y   M A N I P U L A T I N G
                P R O C E D U R E S
***************************************************/

READ$DIRECTORY:  PROC (NAKED$DEVICE$NUMBER) ;
   DCL NAKED$DEVICE$NUMBER BYTE;
   DCL BUFFER(12) BYTE;
   DCL COUNT ADDRESS;
   DCL FREE$SPACE ADDRESS;
   DCL ACTUAL$ENTRY ADDRESS;
   DCL ENTRY ADDRESS;

   comtrace DCL PROC$NAME (*) BYTE DATA('read$directory',0);
   CALL BEG$PR$DEBUG(.PROC$NAME,1,.NULL$PROC);          /* opt */

   DIRECTORY$NAME(2) = NAKED$DEVICE$NUMBER;

   CALL SPATH(.DIRECTORY$NAME,.BUFFER,.STATUS); CHK;
   IF BUFFER(10) = 3  AND  BUFFER(11) > 4  THEN /* must use GETD */
       DO;
         MEM$TOP = MEM$CK - 13;
         IF MEM$TOP < 0E800H  THEN
           CALL CHK$STATUS(.('insufficient memory',0));
         ELSE
           DO;
              FREE$SPACE = 0E800H - .MEMORY;
              COUNT = FREE$SPACE/16;
              CALL LOAD(.(':F0:ISIS.OV0 '),0,0,.ENTRY,.STATUS); CHK;
              CALL GETD(NAKED$DEVICE$NUMBER-'0',.CONNECTION,COUNT,
                        .ACTUAL$ENTRY,.DIR$BUF,.STATUS); CHK;
              IF ACTUAL$ENTRY >= COUNT  THEN
                 CALL CHK$STATUS(.('remote directory too large',0));
              READING$REMOTE = TRUE;
              END$OF$DIRECTORY = .DIR$BUF + (ACTUAL$ENTRY * 16);
           END;
       END;
   ELSE
       DO;
          CALL OPEN1(.DIRECTORY$NAME,1);
          CALL CHK$STATUS(.('cannot open directory file',0));
          CALL READ1(.DIR$BUF,SIZE(DIR$BUF));
          CALL CHK$STATUS(.('cannot read directory file',0));
          /*	Dir$buf is larger than an ISIS V4.0 hard disk directory  */
          CALL CLOSE1;
          CALL CHK$STATUS(.('cannot close directory file',0));

          READING$REMOTE = FALSE;
          END$OF$DIRECTORY = .DIR$BUF + ACTUAL;
          comtrace CALL END$PR$DEBUG(.PROC$NAME,1,.NULL$PROC);        /* opt */
       END;
END READ$DIRECTORY;

GREATEST$EXT: PROC (NAME$PART$PTR) ADDRESS;
   DCL NAME$PART$PTR ADDRESS;
   DCL LARGEST$EXTENSION ADDRESS;
   DCL NUM$EXTENSION$FOUND BYTE;
   NUMERIC$EXTENSION: PROC (PTR) BYTE;
        /*	Given a pointer into memory, this procedure determines
                whether the byte pointed to, and the next two contiguous
                bytes, constitute a wholly numeric ascii sequence.
        */
        DCL PTR ADDRESS,
            CHAR BASED PTR (10) BYTE;
        DCL L BYTE;
        DO L=0 TO 2;
                IF NOT DIG$CH$WP(CHAR(L)) THENN
                        RETURN FALSE;
                ENDIF
        ENDDO
        RETURN TRUE;
   END NUMERIC$EXTENSION;

   VALUE: PROC (DIR$EXT$PTR) ADDRESS;
        DCL DIR$EXT$PTR ADDRESS;
        DCL CHAR BASED DIR$EXT$PTR (3) BYTE;
        DCL T BYTE;
        DCL RESULT ADDRESS;
        RESULT = 0;
        DO T = 0 TO 2;
                RESULT = (RESULT * 10) + CHAR(T) - '0';
        ENDDO
        RETURN RESULT;
   END VALUE;

   NAME$PARTS$MATCH: PROC (NAME$PTR$1,NAME$PTR$2) BYTE;
           DCL (NAME$PTR$1,NAME$PTR$2) ADDRESS,
               TMP ADDRESS, COMP$BUF (7) BYTE, MATCH BYTE,
               (LEN$1,LEN$2) ADDRESS;
      TMP = SCANP;
      SCANP = NAME$PTR$1;
      LEN$1 = LESSER$OF(6,LENGTH$OF(.LET$OR$DIG$CH));
      SCANP = NAME$PTR$2;
      LEN$2 = LESSER$OF(6,LENGTH$OF(.LET$OR$DIG$CH));
      SCANP = TMP;
      IF                LEN$1    <>    LEN$2                THENN
         RETURN FALSE;
      ELLSE
         CALL FMOVE(LEN$1,NAME$PTR$1,.COMP$BUF);
         CALL FMOVE(1,.(0),.COMP$BUF(LEN$1));
         TMP = SCANP;
         SCANP = NAME$PTR$2;
         MATCH = SCAN$MATCH(.COMP$BUF);
         SCANP = TMP;
         RETURN MATCH;
      ENDIF
   END NAME$PARTS$MATCH;

   comtrace DCL PROC$NAME (*) BYTE DATA('greatest$ext',0);      /* opt */
   comtrace CALL BEG$PR$DEBUG(.PROC$NAME,1,.NULL$PROC);         /* opt */
   DIR$ENTRY$PTR = .DIR$BUF;
   NUM$EXTENSION$FOUND = FALSE;
   LARGEST$EXTENSION = 0;
   /*	Grand directory search loop. */
   DO WHILE  DIR$ENTRY$PTR < END$OF$DIRECTORY;
      IF NOT READING$REMOTE  THEN
        DO;
          IF DIR$ENTRY.PRESENCE = 7FH  THEN
             GO TO NO$MORE$DIR;
          IF DIR$ENTRY.PRESENCE = 0FFH  THEN
             GO TO BUMP$PTR;
        END;
      IF NAME$PARTS$MATCH(.DIR$ENTRY.FILENAME,NAME$PART$PTR) AND
               (DIR$ENTRY.PRESENCE <> 0FFH)                           THENN
         IF NUMERIC$EXTENSION(.DIR$ENTRY.EXTENSION) THENN
            DCL EXTENSION$NUM ADDRESS;
            NUM$EXTENSION$FOUND = TRUE;
            EXTENSION$NUM = VALUE(.DIR$ENTRY.EXTENSION);
            IF EXTENSION$NUM > LARGEST$EXTENSION THENN
               LARGEST$EXTENSION = EXTENSION$NUM;
            ENDIF
         ENDIF
      ENDIF
      bump$ptr:
      DIR$ENTRY$PTR = DIR$ENTRY$PTR + 16;
   ENDDO
   no$more$dir:
   IF      NUM$EXTENSION$FOUND       THENN
      comtrace CALL END$PR$DEBUG(.PROC$NAME,1,.NULL$PROC);          /* opt */
      RETURN LARGEST$EXTENSION;
   ELLSE
      comtrace CALL END$PR$DEBUG(.PROC$NAME,1,.NULL$PROC);          /* opt */
      RETURN NO$NUM$EXTENSION;
   ENDIF
END GREATEST$EXT;

$EJECT

/********************************************************
         O U T P U T     P R O C E D U R E S
********************************************************/

FILL$NAME: PROC (N$INDEX, F$INDEX);
  DCL (N$INDEX,F$INDEX) ADDRESS, (N$TYPE,F$TYPE) BYTE;
  DCL TMP$BUF (16) BYTE, LENGTH$NAME$PART BYTE;
  DCL MSG (*) BYTE DATA('xlate2 error: fill$name',0);
  N$TYPE = NAME$LIST(N$INDEX).TYPE;
  F$TYPE = FILL$ARRAY(F$INDEX).TYPE;
  SCANP = .NAME$LIST(N$INDEX).NAME;
  OBUFP = .TMP$BUF;
  LENGTH$NAME$PART = LESSER$OF(6,LENGTH$OF(.LET$OR$DIG$CH));
  CALL FMOVE(16,.BLANK$STR,OBUFP);
  IF FILL$ARRAY(F$INDEX).DRIVE(2) = '?' THENN
     FILL$ARRAY(F$INDEX).DRIVE(2) = DIR$TO$SEARCH;
  ENDIF
  IF FILL$ARRAY(F$INDEX).DRIVE(0) <> NULL THENN
     CALL FMOVE(4,.FILL$ARRAY(F$INDEX).DRIVE,OBUFP);
  ENDIF;
  OBUFP = OBUFP + 4;
  CALL FMOVE(LENGTH$NAME$PART,.NAME$LIST(N$INDEX).NAME,OBUFP);
  OBUFP = OBUFP + LENGTH$NAME$PART;
  IF                 F$TYPE <= 3                   THENN
     DO CASE F$TYPE;
        /* PCNT$0$TYPE */
        DO;
          IF N$TYPE = NAME$DOT$EXT$TYPE THENN
             DCL LENGTH$EXT BYTE;
             CALL OUTCHAR('.');
             SCANP = .NAME$LIST(N$INDEX).EXT;
             LENGTH$EXT = LESSER$OF(3,LENGTH$OF(.LET$OR$DIG$CH));
             CALL FMOVE(LENGTH$EXT,.NAME$LIST(N$INDEX).EXT,OBUFP);
          ENDIF
        ENDDO
        /* PCNT$0$DOT$TYPE */
        DO;
        ENDDO
        /* PCNT$0$DOT$EXT$TYPE */
        DO;
          DCL LENGTH$EXT BYTE;
          SCANP = .FILL$ARRAY(F$INDEX).EXT;
          LENGTH$EXT = LESSER$OF(3,LENGTH$OF(.LET$OR$DIG$CH));
          CALL OUTCHAR('.');
          CALL FMOVE(LENGTH$EXT,.FILL$ARRAY(F$INDEX).EXT,OBUFP);
        ENDDO
        /* NUMB$0$TYPE */
        DO;
          IF N$TYPE <> NAME$DOT$TYPE THENN
             DCL NUMB$EXT ADDRESS;
             DCL NAMEPART (7) BYTE;
             CALL OUT$CHAR('.');
             NUMB$EXT = GREATEST$EXT(.NAME$LIST(N$INDEX).NAME);
             /*   For the first version a wholly numeric 3 digit
                extension is required */
             IF NUMB$EXT >= 1000 THENN
                CALL PRINT(.('filename : ',0));
                SCANP = .NAME$LIST(N$INDEX).NAME;
                CALL FMOVE(7,.NULL$STRING,.MSG$BUF);
                CALL FMOVE(LESSEROF(6,LENGTHOF(.LET$OR$DIG$CH)),SCANP,.MSGBUF);
                OBUFP = .MSG$BUF(6);
                CALL OUTCHAR(NULL);
                CALL PRINT(.MSGBUF);
                CALL PRINT$CR(.(' has no numeric extension',0));
             ENDIF
             LEADCHAR = '0';
             CALL OUT$DEC$R(NUMB$EXT,3);
             LEADCHAR = ' ';
          ENDIF
        ENDDO
     ENDDO
  ELSIF          F$TYPE <> UNKNOWN$TYPE             THENN
     CALL PRINT$CR(.MSG);
     CALL PRINT(.('xlate2 error: fill$name, type = ',0));
     OBUFP = .MSG$BUF;
     CALL OUTDECR(F$TYPE,3);
     CALL OUTCHAR(NULL);
     CALL PRINT(.MSG$BUF);
     CALL PRINT(.(' on the ',0));
     OBUFP = .MSG$BUF;
     CALL OUTDECR(F$INDEX+1,3);
     CALL PRINT(.MSG$BUF);
     CALL PRINT$CR$EXIT(.(' template substitution',0));
  ENDIF
  CALL FMOVE(16,.TMP$BUF,FILL$ARRAY(F$INDEX).FILL$PTR);
END FILL$NAME;

OUTPUT$LIST: PROC;
  DCL TMP$FILL$INDEX  ADDRESS,
      TMP$NAME$INDEX  ADDRESS;
  DCL FILE$NAME (16) BYTE DATA(':F0:XLATE2.CS  ',0);
  DCL FILE$TO$EXECUTE (16) BYTE;
  
  OPEN$CONSOLE$FILE: PROC;
    DCL TMP$PTR ADDRESS;
    TMP$PTR = SCANP;
    CALL FMOVE(16,.FILENAME,.MSG$BUF);
    SCANP = DEBLANK(.INVOK$NAME);
    IF COLON$CH THENN
       SCANP = SCANP + 2;
       IF DIG$CH THENN
          CALL FMOVE(1,SCANP,.MSG$BUF(2));
       ENDIF
    ENDIF
    CALL FMOVE(16,.MSG$BUF,.FILE$TO$EXECUTE);
    SCANP = TMP$PTR;
    CALL OPENO(.MSG$BUF);
    CALL CHK$STATUS(.('cannot open .cs file',0));
  END OPEN$CONSOLE$FILE;
  
  MAKE$RESTORE$COMMAND: PROC;
    OBUFP = .MSG$BUF;
    CALL SEEK(1,0,.BLOKNO,.BYTENO,.STATUS);
    IF STATUS <> 0 THENN
       BLOKNO,BYTENO = 0;
    ENDIF
    CALL FMOVE(15,.INVOK$NAME,OBUFP);
    OBUFP = OBUFP + 15;
    CALL OUTPRINT(.(' RESTORE ',0));
    CALL FMOVE(15,.BLANK$STR,OBUFP);
    CALL WHOCI(OBUFP);
    OBUFP = OBUFP + 15;
    CALL OUTCHAR('(');
    CALL OUT$DEC$R(BLOKNO,5);
    CALL OUTCHAR(',');
    CALL OUT$DEC$R(BYTENO,5);
    CALL OUTPRINT(.(')',CR,LF,0));
    CALL WRITEO(.MSG$BUF,OBUFP-.MSG$BUF);
  END MAKE$RESTORE$COMMAND;
  
  comtrace DCL PROC$NAME (*) BYTE DATA('output$list',0);          /* opt */
  comtrace CALL BEG$PR$DEBUG(.PROC$NAME,1,.NULL$PROC);            /* opt */
  CALL READ$DIRECTORY(DIR$TO$SEARCH);
  CALL OPEN$CONSOLE$FILE;
  TMP$NAME$INDEX = 0;
  DO WHILE TMP$NAME$INDEX <= NAME$INDEX;
     TMP$FILL$INDEX = 0;
     DO WHILE TMP$FILL$INDEX <= FILL$INDEX;
        CALL FILL$NAME(TMP$NAME$INDEX,TMP$FILL$INDEX);
        TMP$FILL$INDEX = TMP$FILL$INDEX + 1;
     ENDDO
     TMP$NAME$INDEX = TMP$NAME$INDEX + 1;
     CALL WRITEO(.TEMPLATE,LENGTH$TO$WRITE$FROM$TEMPLATE);
  ENDDO
  CALL WRITEO(.(CR,LF),2);
  CALL MAKE$RESTORE$COMMAND;
  CALL CLOSEO;
  IF NOT HALT$FLAG THENN
     CALL CONS(.FILE$TO$EXECUTE,.(':CO: '));
  ENDIF
  comtrace CALL END$PR$DEBUG(.PROC$NAME,1,.NULL$PROC);         /* opt */
END OUTPUT$LIST;

/*********************************************************
         D E B U G G I N G   P R O C E D U R E S
**********************************************************/

/*
PRINTLIST: PROC;
  DCL TMP$INDEX ADDRESS;
  TMP$INDEX = 0;
  DO WHILE TMP$INDEX <= NAMEINDEX;
     DO;
       DCL SPACE(7) BYTE;
       SPACE(6) = NULL;
       CALL FMOVE(6,.NAMELIST(TMP$INDEX).NAME,.SPACE);
       CALL PRINT$CR(.SPACE);
       IF NAMELIST(TMPINDEX).TYPE < 3 THENN
          DO CASE NAMELIST(TMPINDEX).TYPE;
             DO;
                CALL PRINT$CR(.('name$dot$type',0));
             ENDDO
             DO;
                CALL PRINT$CR(.('name$dot$ext$type',0));
             ENDDO
             DO;
                CALL PRINT$CR(.('name$only$type',0));
             ENDDO
          ENDDO
       ELSIF NAMELIST(TMPINDEX).TYPE = UNKNOWN$TYPE THENN
          CALL PRINT$CR(.('unknown$type',0));
       ELLSE
          CALL PRINT$CR(.('bad name type',0));
       ENDIF
       TMP$INDEX = TMP$INDEX + 1;
     ENDDO
  ENDDO 
  OBUFP = .MSG$BUF;
  CALL OUT$DEC$R(NAME$INDEX+1,5);
  CALL OUT$PRINT(.(' filenames read from list',0));
  CALL OUT$CHAR(NULL);
  CALL PRINT$CR(.MSG$BUF);
END PRINTLIST; 
*/

/*
BULL: PROC; 
  DCL TMP$INDEX BYTE;
  TMP$INDEX = 0; 
  OBUFP = .MSG$BUF;
  CALL OUT$DEC$R(FILL$INDEX+1,3);
  CALL OUT$PRINT(.(' substitutions',0));
  CALL OUT$CHAR(NULL);
  CALL PRINT$CR(.MSG$BUF);
  DO WHILE TMP$INDEX <= FILL$INDEX;
     IF FILL$ARRAY(TMP$INDEX).TYPE < 4 THENN
        DO CASE FILL$ARRAY(TMP$INDEX).TYPE;
          CALL PRINT$CR(.('   %0 type',0));
          CALL PRINT$CR(.('   %0. type',0));
          CALL PRINT$CR(.('   %0.ext type',0));
          CALL PRINT$CR(.('   #0 type',0));
        ENDDO
     ELSIF FILL$ARRAY(TMP$INDEX).TYPE = UNKNOWN$TYPE  THENN
        CALL PRINT$CR(.('   unknown type',0));
     ELLSE
       CALL PRINT$CR(.('bogus type',0));
     ENDIF
     TMP$INDEX = TMP$INDEX + 1;
  ENDDO
  CALL PRINT$CR(.(' expanded template:',0));
  CALL PRINT$CR(.TEMPLATE);
END BULL;
*/

$EJECT

/******************************************************
     C O M M A N D    L I N E  P R O C E S S I N G
                 P R O C E D U R E S
******************************************************/

PROCESS$COMMAND$LINE: PROC;
   GET$TEMPLATE$FILENAME: PROC;
     DCL STAT$MSG (*) BYTE DATA('process$command$line',0);
     comtrace DCL PROC$NAME (*) BYTE DATA('get$template$filename',0);/* opt */
     comtrace CALL BEG$PR$DEBUG(.PROC$NAME,2,.NULL$PROC);            /* opt */
     CALL RESCAN(1,.STATUS);  
     CALL CHK$STATUS(.STAT$MSG);
     CALL READC(.READBUF,128);  
     CALL CHK$STATUS(.STAT$MSG);
     SCANP = DEBLANK(.READBUF);
     DEBUG$FLAG = SCANMATCH(.('DEBUG',0));
     SCANP = DEBLANK(SCANP);
     SCANP$TMP = SCANP;
     CALL SCANWHILE(.FILE$CH);
     CALL FMOVE(SCANP-SCANP$TMP,SCANP$TMP,.INVOK$NAME);
     SCANP = DEBLANK(SCANP);
     HALT$FLAG = SCANMATCH(.('HALT!',0));
     SCANP = DEBLANK(SCANP);
     IF         SCANMATCH(.('?',0))         THENN 
$IF XVERSION
        DCL VERNO (*) BYTE DATA('xlate2 X103',0);
$ELSE
        DCL VERNO (*) BYTE DATA('xlate2 V1.1',0);
$ENDIF
        CALL PRINT$CR$EXIT(.VERNO);
     ELSIF      SCANMATCH(.('RESTORE',0))   THENN
        CALL RESTORE;
     ENDIF
     CALL OPENI(DEBLANK(SCANP));
     CALL CHK$STATUS(.('cannot open template file',0));
     CALL SCANWHILE(.FILE$CH);
     SCANP = DEBLANK(SCANP);
     IF DIG$CH THENN
        DIR$TO$SEARCH = SCANBYTE;
        SCANP = DEBLANK(SCANP+1);
     ELLSE
        CALL PRINT$CR$EXIT(.('missing drive #',0));
     ENDIF
     comtrace CALL END$PR$DEBUG(.PROC$NAME,2,.NULL$PROC);            /* opt */
   END GET$TEMPLATE$FILENAME;
   
   MAKE$LIST: PROC;
      DCL FLAG BYTE;
      
         ADD$FILENAME: PROC BYTE;
         
         ADD$DRIVE: PROC (N$INDEX);
            DCL N$INDEX ADDRESS;
            IF COLON$CH THENN
               CALL FMOVE(4,SCANP,.NAME$LIST(N$INDEX).DRIVE);
               SCANP = SCANP + 4;
            ELLSE
               CALL FMOVE(4,.DR$STR,.NAME$LIST(N$INDEX).DRIVE);
               CALL FMOVE(1,.DIR$TO$SEARCH,.NAME$LIST(N$INDEX).DRIVE(2));
            ENDIF
         END ADD$DRIVE;

         ADD$NAME: PROC (N$INDEX);
            DCL (N$INDEX,LEN$NAME$PART)  ADDRESS;
            IF (LEN$NAME$PART :=LENGTH$OF(.LET$OR$DIG$CH)) > 6  THENN
               CALL PRINT$CR(.('name too long: ',0));
               SCANP = SCANP + 7; 
               SCANBYTE = NULL;
               CALL PRINT$CR$EXIT(SCANP-7);
            ELLSE
               CALL FMOVE(6,.NULL$STRING,.NAMELIST(N$INDEX).NAME);
               CALL FMOVE(LEN$NAME$PART,SCANP,.NAME$LIST(N$INDEX).NAME);
               /* set type field in the event that it will be used */
               SCANP = SCANP + LEN$NAME$PART;
               IF        BLANK$CH OR TERM$CH             THENN
                  NAMELIST(N$INDEX).TYPE = NAME$ONLY$TYPE;
               ELSIF      DOT$CH                 THENN
                  SCAN$P = SCANP + 1;
                  IF    LET$OR$DIG$CH     THENN
                     NAMELIST(N$INDEX).TYPE = NAME$DOT$EXT$TYPE;
                  ELLSE
                     NAMELIST(N$INDEX).TYPE = NAME$DOT$TYPE;
                  ENDIF
               ELLSE
                  CALL PRINT$CR$EXIT(.('a blank or dot must follow name part',0));
               ENDIF
            ENDIF
         END ADD$NAME; 

         ADD$EXT: PROC (N$INDEX);
            DCL (N$INDEX,LEN$EXT) ADDRESS;
            IF                    LET$OR$DIG$CH                    THENN
               IF (LEN$EXT := LENGTH$OF(.LET$OR$DIG$CH)) > 3 THENN
                  CALL PRINT$CR$EXIT(.('ext > 3 chars',0));
               ELLSE
                  CALL FMOVE(3,.NULL$STRING,.NAME$LIST(N$INDEX).EXT);
                  CALL FMOVE(LEN$EXT,SCANP,.NAME$LIST(N$INDEX).EXT);
                  SCANP = SCANP + LEN$EXT;
               ENDIF
            ENDIF
         END ADD$EXT;

$EJECT
         comtrace DCL PROC$NAME (*) BYTE DATA('add$filename',0);    /* opt */
         comtrace CALL BEG$PR$DEBUG(.PROC$NAME,3,.NULL$PROC);       /* opt */ 
         SCANP = DEBLANK(SCANP);
         IF TERM$CH                              THENN
            comtrace CALL END$PR$DEBUG(.PROC$NAME,3,.NULL$PROC);    /* opt */
            RETURN DONE;
         ELSIF SCANMATCH(.('&',0))     THENN
            CALL ENFORCE$NO$TOKENS;
            CALL PRINT(.('**',0));
            CALL READC(.READBUF,128);
            SCANP = DEBLANK(.READBUF);
            comtrace CALL END$PR$DEBUG(.PROC$NAME,3,.NULL$PROC);    /* opt */
            RETURN NEW$LINE;
         ELSIF FILE$CH                 THENN 
            CALL ADD$DRIVE(NAME$INDEX);
            CALL ADD$NAME(NAME$INDEX);
            CALL ADD$EXT(NAME$INDEX);
            NAME$INDEX = NAME$INDEX + 1;
            comtrace CALL END$PR$DEBUG(.PROC$NAME,3,.NULL$PROC);    /* opt */
            RETURN NAME$ADDED;
         ELLSE                                          /* syntax chk opt */
            DCL TEMP$PTR ADDRESS;
            TEMP$PTR = SCANP;
            DO WHILE NOT(BLANK$CH) AND NOT(TERM$CH);
               SCANP = SCANP + 1;
            ENDDO
            SCAN$BYTE = NULL;
            CALL PRINT(TEMP$PTR);
            CALL PRINT$CR$EXIT(.(' not a filename',0));
         ENDIF 
         comtrace CALL END$PR$DEBUG(.PROC$NAME,3,.NULL$PROC);       /* opt */
      END ADDFILENAME;
        
      comtrace DCL PROC$NAME (*) BYTE DATA('make$list',0);          /* opt */ 
      comtrace CALL BEG$PR$DEBUG(.PROC$NAME,2,.NULL$PROC);          /* opt */
      FLAG = NOT DONE;
      DO WHILE FLAG <> DONE;
         FLAG = ADD$FILENAME;
      ENDDO 
      IF NAME$INDEX = 0 THENN
         CALL PRINT$CR$EXIT(.('0 filenames on command line',0));
      ELLSE
         NAME$INDEX = NAME$INDEX - 1;
      ENDIF
      comtrace CALL END$PR$DEBUG(.PROC$NAME,2,.NULL$PROC);          /* opt */
   END MAKE$LIST; 

   comtrace DCL PROC$NAME (*) BYTE DATA('process$command$line',0);  /* opt */
   comtrace CALL BEG$PR$DEBUG(.PROC$NAME,1,.NULL$PROC);             /* opt */
   CALL GET$TEMPLATE$FILENAME;
   CALL MAKE$LIST;
   comtrace CALL END$PR$DEBUG(.PROC$NAME,1,.NULL$PROC);             /* opt */
END PROCESS$COMMAND$LINE;

$EJECT

/*********************************************************
     F I R S T      E X E C U T A B L E      C O D E
*********************************************************/

CALL FIRST$INIT;
CALL PROCESS$COMMAND$LINE;
CALL BUILD$TEMPLATE;
CALL OUTPUT$LIST;
/* CALL PRINTLIST; CALL BULL; */       /* debug opt */
CALL EXIT;

END XLATE2$MOD;
sys/makefile
# common makefile info
ITOOLS ?=../../..
ifdef LIB
	TARGETDIR = ../$(LIB)/
endif
TARGETS=$(TARGETDIR)sys.lib
unexport ISIS_F1

include $(ITOOLS)/tools/isis.mk

REF = $(call ipath,toolbox,2.0)
PLM80 = 3.1

OBJS =	ver10.obj ci.obj co.obj csts.obj iochk.obj iodef.obj ioset.obj lo.obj\
	memck.obj po.obj ri.obj cons.obj sblok1.obj sblok2.obj sblok3.obj\
       	sblok9.obj sbloki.obj sbloku.obj sbyte1.obj sbyte2.obj sbyte3.obj\
	sbyte9.obj sbytei.obj sbyteu.obj attr.obj backci.obj del.obj load.obj\
	open1.obj open2.obj open3.obj open9.obj openi.obj openo.obj openu.obj\
	readc.obj renam.obj seek.obj whoci.obj whoco.obj isiscl.obj

all::
	$(MAKE) $(TARGETS)

$(TARGETDIR)sys.lib: $(OBJS)
	$(call lib,$@,$^)


sys/sys_all.src
?attr.asm
	name attr
	public	ATTR
	extrn	ZZXCHG, STATUS

	dseg
pathp:	dw	0
attrib:	dw	0
onoff:	dw	0
	dw	STATUS

	cseg
ATTR:	mvi	a,1
	ana	e
	sta	onoff
	xra	e
	rrc
	sta	attrib
	lxi	h,pathp + 1
	mov	m,b
	dcx	h
	mov	m,c
	mvi	a,0AH
	jmp	ZZXCHG

	end
?backci.asm
	name	BACKCI
	extrn	ISISCL, STATUS
	public	BACKCI
	
RESCAN	equ	11
	
	DSEG
RSARG:	dw	1	; rescan args - CI
	dw	STATUS	; status$p


	CSEG

BACKCI:	lxi	d,RSARG
	mvi	c,RESCAN
	jmp	ISISCL

	end
?ci.asm
	name	ci
	public	CI

CI	equ	0F803H
	end
?co.asm
	name	co
	public	CO

CO	equ	0F809H
	end
?cons.asm
	name	cons
	public	CONS
	extrn	ZZRENA

	cseg
CONS:	mvi	a,8
	jmp	ZZRENA
	end

?csts.asm
	name	csts
	public	CSTS

CSTS	equ	0F812H
	end
?del.asm
	name	DEL
	extrn	STATUS, ZZXCHG
	public	DEL

IDELET	EQU	2

	DSEG
pathp:	dw	0		; path$p
	dw	STATUS		; status$p
	
	CSEG

DEL:	lxi	h,pathp+1
	mov	m,b
	dcx	h
	mov	m,c
	mvi	a,IDELET
	jmp	ZZXCHG

	end
?iochk.asm
	name	iochk
	public	IOCHK

IOCHK	equ	0F815H
	end
?iodef.asm
	name	iodef
	public	IODEF

IODEF	equ	0F81EH
	end
?ioset.asm
	name	ioset
	public	IOSET

IOSET	equ	0F818H
	end

?isiscl.asm
	name ISISCL
	public STATUS, FATAL, ERRED, REPORT, ACTUAL, ZZCLOS
	public ZZREAD, ZZOPEN, EX, ERR, ISISCL, ZZXCHG, ZZLOD2
	public ZZWRIT, ISIS

	ASEG
ISIS	equ	40H

IOPEN	equ	0
ICLOSE	equ	1
IREAD	equ	3
IWRITE	equ	4
IEXIT	equ	9
IERROR	equ	12

	DSEG
ACTUAL:	dw	0
REPORT:	db	0FFH
ERRED:	db	0
FATAL:	db	0
STATUS:	dw	0
EXITV:	dw	STATUS


	CSEG
ZZWRIT:
	mvi	a,IWRITE
ZZLOD1:
	mov	m,d	; stuff the count
	dcx	h
	mov	m,e
	dcx	h

ZZLOD2: mov	m,b	; stuff the buff$p
	dcx	h
	mov	m,c
	dcx	h	; back up to conn arg
	dcx	h
ZZXCHG:			; hl -> isis arg ptr
	xchg
	mov	c,a	; isis cmd

ISISCL: call	ISIS
	lhld	STATUS
	mov	a,h
	ora	l
	rz
	mvi	a,0FFH	; flag we have an error
	sta	ERRED
	lda	REPORT	; continue if no reporting
	rar
	rnc

ERR:	mvi	c,IERROR
	lxi	d,STATUS
	call	ISIS
	lda	FATAL		; done if error is considered fatal
	rar
	rnc

EX:	mvi	c,IEXIT
	lxi	d,EXITV		; safe pointer
	call	ISIS
	rst	0		; reboot

ZZOPEN: sub	a		; IOPEN
	jmp	ZZLOD2

ZZREAD: mvi	a,IREAD
	jmp	ZZLOD1

ZZCLOS:	mvi	c,ICLOSE
	jmp	ISISCL


	end
?lo.asm
	name	lo
	public	LO

LO	equ	0F80FH
	end
?load.asm
	name	load
	public	LDEBUG, LOADGO, LOADOV, ENTRY
	extrn	ZZXCHG, STATUS

	dseg
pathp:	dw	0
offset:	dw	0
switch:	dw	0
entryp:	dw	ENTRY
statp:	dw	STATUS

ENTRY:	dw	0

	cseg
LDEBUG:	mvi	a,2
	jmp	ldcom

LOADGO:	mvi	a,1
	jmp	ldcom
LOADOV:	sub	a

ldcom:
	sta	switch
	lxi	h,pathp + 1
	mov	m,b
	dcx	h
	mov	m,c
	mvi	a,6
	jmp	ZZXCHG

	end
?memck.asm
	name	MEMCK
	public	MEMCK
	CSEG
MEMCK:	call	0F81BH
	mov	h,b
	mov	l,a
	ret

	end
?open1.asm
	name	OPEN1

	extrn	STATUS, ACTUAL, ZZOPEN, ZZCLOS, ZZREAD, ZZWRIT
	public	AFTN1, FNAME1, WRITE1, READ1, CLOSE1, ROPEN1, OPEN1

	DSEG
CONNP:	dw	AFTN1	; args for open
FNAME1:	dw	0	; path$p
ACCESS:	dw	0	; access
	dw	0	; echo
	dw	STATUS	; status$p

CONNC:	dw	0	; args for close
	dw	STATUS	; status$p

CONNR:	dw	1	; args for read
	dw	0	; buff$p
CNTR:	dw	0	; count
	dw	ACTUAL	; actual$p
	dw	STATUS	; status$p

AFTN1:	dw	0	; args for write
	dw	0	; buff$p
CNTW:	dw	0	; count
	dw	STATUS	; status$p


	CSEG

OPEN1:  lxi	h,ACCESS
	mov	m,e
	dcx	h
	call	ZZOPEN

ROPEN1: lhld	AFTN1	; update 
	shld	CONNR
	shld	CONNC
	ret

CLOSE1: lxi	d,CONNC
	jmp	ZZCLOS

READ1:  lxi	h,CNTR + 1
	jmp	ZZREAD

WRITE1: lxi	h,CNTW + 1
	jmp	ZZWRIT



	end
?open2.asm
	name	OPEN2

	extrn	STATUS, ACTUAL, ZZOPEN, ZZCLOS, ZZREAD, ZZWRIT
	public	AFTN2, FNAME2, WRITE2, READ2, CLOSE2, ROPEN2, OPEN2

	DSEG
CONNP:	dw	AFTN2	; args for open
FNAME2:	dw	0	; path$p
ACCESS:	dw	0	; access
	dw	0	; echo
	dw	STATUS	; status$p

CONNC:	dw	0	; args for close
	dw	STATUS	; status$p

CONNR:	dw	1	; args for read
	dw	0	; buff$p
CNTR:	dw	0	; count
	dw	ACTUAL	; actual$p
	dw	STATUS	; status$p

AFTN2:	dw	0	; args for write
	dw	0	; buff$p
CNTW:	dw	0	; count
	dw	STATUS	; status$p


	CSEG

OPEN2:  lxi	h,ACCESS
	mov	m,e
	dcx	h
	call	ZZOPEN

ROPEN2: lhld	AFTN2	; update 
	shld	CONNR
	shld	CONNC
	ret

CLOSE2: lxi	d,CONNC
	jmp	ZZCLOS

READ2:  lxi	h,CNTR + 1
	jmp	ZZREAD

WRITE2: lxi	h,CNTW + 1
	jmp	ZZWRIT

	end

?open3.asm
	name	OPEN3

	extrn	STATUS, ACTUAL, ZZOPEN, ZZCLOS, ZZREAD, ZZWRIT
	public	AFTN3, FNAME3, WRITE3, READ3, CLOSE3, ROPEN3, OPEN3

	DSEG
CONNP:	dw	AFTN3	; args for open
FNAME3:	dw	0	; path$p
ACCESS:	dw	0	; access
	dw	0	; echo
	dw	STATUS	; status$p

CONNC:	dw	0	; args for close
	dw	STATUS	; status$p

CONNR:	dw	1	; args for read
	dw	0	; buff$p
CNTR:	dw	0	; count
	dw	ACTUAL	; actual$p
	dw	STATUS	; status$p

AFTN3:	dw	0	; args for write
	dw	0	; buff$p
CNTW:	dw	0	; count
	dw	STATUS	; status$p


	CSEG

OPEN3:  lxi	h,ACCESS
	mov	m,e
	dcx	h
	call	ZZOPEN

ROPEN3: lhld	AFTN3	; update 
	shld	CONNR
	shld	CONNC
	ret

CLOSE3: lxi	d,CONNC
	jmp	ZZCLOS

READ3:  lxi	h,CNTR + 1
	jmp	ZZREAD

WRITE3: lxi	h,CNTW + 1
	jmp	ZZWRIT

	end
?open9.asm
	name	OPEN9

	extrn	STATUS, ACTUAL, ZZOPEN, ZZCLOS, ZZREAD, ZZWRIT
	public	AFTN9, FNAME9, WRITE9, READ9, CLOSE9, ROPEN9, OPEN9

	DSEG
CONNP:	dw	AFTN9	; args for open
FNAME9:	dw	0	; path$p
ACCESS:	dw	0	; access
	dw	0	; echo
	dw	STATUS	; status$p

CONNC:	dw	0	; args for close
	dw	STATUS	; status$p

CONNR:	dw	1	; args for read
	dw	0	; buff$p
CNTR:	dw	0	; count
	dw	ACTUAL	; actual$p
	dw	STATUS	; status$p

AFTN9:	dw	0	; args for write
	dw	0	; buff$p
CNTW:	dw	0	; count
	dw	STATUS	; status$p


	CSEG

OPEN9:  lxi	h,ACCESS
	mov	m,e
	dcx	h
	call	ZZOPEN

ROPEN9: lhld	AFTN9	; update 
	shld	CONNR
	shld	CONNC
	ret

CLOSE9: lxi	d,CONNC
	jmp	ZZCLOS

READ9:  lxi	h,CNTR + 1
	jmp	ZZREAD

WRITE9: lxi	h,CNTW + 1
	jmp	ZZWRIT



	end

?openi.asm
	name	OPENI
	extrn	STATUS, ACTUAL, ZZOPEN, ZZCLOS, ZZREAD
	public	AFTNI, FNAMEI, READI, CLOSEI, ROPENI, OPENI

	DSEG
CONNP:	dw	AFTNI	; args for open
FNAMEI:	dw	0
	dw	1	; access
	dw	0	; echo
	dw	STATUS	; status$p

CONNC:	dw	0	; args for close
	dw	STATUS

AFTNI:	dw	1	; args for read - conn - default CI
	dw	0	; buff$p
CNTR:	dw	0	; count
	dw	ACTUAL	; actual$p
	dw	STATUS	; status$p

	CSEG
OPENI:	lxi	h,FNAMEI + 1
	call	ZZOPEN

ROPENI:	lhld	AFTNI
	shld	CONNC
	ret

CLOSEI:	lxi	d,CONNC
	jmp	ZZCLOS

READI:	lxi	h, CNTR + 1
	jmp	ZZREAD

	end


?openo.asm
	name	OPENO
	extrn	STATUS, ACTUAL, ZZOPEN, ZZCLOS, ZZWRIT
	public	AFTNO, FNAMEO, WRITEO, CLOSEO, ROPENO, OPENO

	DSEG
CONNP:	dw	AFTNO	; args for open
FNAMEO:	dw	0
	dw	2	; access
	dw	0	; echo
	dw	STATUS	; status$p

CONNC:	dw	0	; args for close
	dw	STATUS

AFTNO:	dw	0	; args for write - conn - default CO
	dw	0	; buff$p
CNTW:	dw	0	; count
	dw	STATUS	; status$p

	CSEG

OPENO:	lxi	h,FNAMEO + 1
	call	ZZOPEN

ROPENO:	lhld	AFTNO
	shld	CONNC
	ret

CLOSEO:	lxi	d,CONNC
	jmp	ZZCLOS

WRITEO:	lxi	h,CNTW + 1
	jmp	ZZWRIT

	end
?openu.asm
	name	OPENU

	extrn	STATUS, ACTUAL, ZZOPEN, ZZCLOS, ZZREAD, ZZWRIT
	public	AFTNU, FNAMEU, WRITEU, READU, CLOSEU, ROPENU, OPENU

	DSEG
CONNP:	dw	AFTNU	; args for open
FNAMEU:	dw	0	; path$p
ACCESS:	dw	3	; access
	dw	0	; echo
	dw	STATUS	; status$p

CONNC:	dw	0	; args for close
	dw	STATUS	; status$p

CONNR:	dw	1	; args for read
	dw	0	; buff$p
CNTR:	dw	0	; count
	dw	ACTUAL	; actual$p
	dw	STATUS	; status$p

AFTNU:	dw	0	; args for write
	dw	0	; buff$p
CNTW:	dw	0	; count
	dw	STATUS	; status$p


	CSEG

OPENU:  lxi	h,ACCESS-1
	call	ZZOPEN

ROPENU: lhld	AFTNU	; update 
	shld	CONNR
	shld	CONNC
	ret

CLOSEU: lxi	d,CONNC
	jmp	ZZCLOS

READU:  lxi	h,CNTR + 1
	jmp	ZZREAD

WRITEU: lxi	h,CNTW + 1
	jmp	ZZWRIT

	end
?po.asm
	name	po
	public	PO

PO	equ	0F80CH
	end
?readc.asm
	name READC
	extrn	STATUS, ACTUAL, ZZREAD, ZZWRIT
	public	READC, WRITEC

	DSEG
	dw	1	; read args - CI
	dw	0	; buff$p
CNTR:	dw	0	; count
	dw	ACTUAL
	dw	STATUS

	dw	0	; write args - CO
	dw	0	; buff$p
CNTW:	dw	0	; count
	dw	STATUS

	CSEG
READC:	lxi	h,CNTR + 1
	jmp	ZZREAD

WRITEC:	lxi	h,CNTW + 1
	jmp	ZZWRIT

	end
?renam.asm
	name	renam
	public	RENAM, ZZRENA
	extrn	ZZXCHG, STATUS

	dseg
oldp:	dw	0
newp:	dw	0
statp:	dw	STATUS

	cseg
RENAM:	mvi	a,7

ZZRENA:	lxi	h,newp + 1	; de = new$p, bc = old$p
	mov	m,d
	dcx	h
	mov	m,e
	dcx	h
	mov	m,b
	dcx	h
	mov	m,c
	jmp	ZZXCHG

	end
?ri.asm
	name	ri
	public	RI

RI	equ	0F806H
	end
?sblok1.asm
	name	SBLOK1
	extrn	AFTN1
	extrn	ZZBLOK
	extrn	ISIS
	public	SBLOK1

	cseg
sblok1:	lxi	h,AFTN1
	jmp	ZZBLOK

	end

?sblok2.asm
	name	SBLOK2
	extrn	AFTN2
	extrn	ZZBLOK
	extrn	ISIS
	public	SBLOK2

	cseg
sblok2:	lxi	h,AFTN2
	jmp	ZZBLOK

	end


?sblok3.asm
	name	SBLOK3
	extrn	AFTN3
	extrn	ZZBLOK
	extrn	ISIS
	public	SBLOK3

	cseg
sblok3:	lxi	h,AFTN3
	jmp	ZZBLOK

	end


?sblok9.asm
	name	SBLOK9
	extrn	AFTN9
	extrn	ZZBLOK
	extrn	ISIS
	public	SBLOK9

	cseg
sblok9:	lxi	h,AFTN9
	jmp	ZZBLOK

	end


?sbloki.asm
	name	SBLOKI
	extrn	AFTNI
	extrn	ZZBLOK
	extrn	ISIS
	public	SBLOKI

	cseg
sblokI:	lxi	h,AFTNI
	jmp	ZZBLOK

	end


?sbloku.asm
	name	SBLOKU
	extrn	AFTNU
	extrn	ZZBLOK
	extrn	ISIS
	public	SBLOKU

	cseg
sblokU:	lxi	h,AFTNU
	jmp	ZZBLOK

	end


?sbyte1.asm
	name	SBYTE1
	extrn	AFTN1
	extrn	ZZBYTE
	extrn	ISIS
	public	SBYTE1

	cseg
sbyte1:	lxi	h,AFTN1
	jmp	ZZBYTE

	end
?sbyte2.asm
	name	SBYTE2
	extrn	AFTN2
	extrn	ZZBYTE
	extrn	ISIS
	public	SBYTE2

	cseg
sbyte2:	lxi	h,AFTN2
	jmp	ZZBYTE

	end

?sbyte3.asm
	name	SBYTE3
	extrn	AFTN3
	extrn	ZZBYTE
	extrn	ISIS
	public	SBYTE3

	cseg
sbyte3:	lxi	h,AFTN3
	jmp	ZZBYTE

	end

?sbyte9.asm
	name	SBYTE9
	extrn	AFTN9
	extrn	ZZBYTE
	extrn	ISIS
	public	SBYTE9

	cseg
sbyte9:	lxi	h,AFTN9
	jmp	ZZBYTE

	end

?sbytei.asm
	name	SBYTEI
	extrn	AFTNI
	extrn	ZZBYTE
	extrn	ISIS
	public	SBYTEI

	cseg
sbyteI:	lxi	h,AFTNI
	jmp	ZZBYTE

	end

?sbyteu.asm
	name	SBYTEU
	extrn	AFTNU
	extrn	ZZBYTE
	extrn	ISIS
	public	SBYTEU

	cseg
sbyteU:	lxi	h,AFTNU
	jmp	ZZBYTE

	end

?seek.asm
	name	seek
	public	ZZBLOK, SBLOK, ZZBYTE, SBYTE
	public	BLOKNO, BYTENO
	extrn	ZZXCHG
	extrn	STATUS

	dseg
conn:	dw	0
mode:	dw	0
blkp:	dw	BLOKNO
bytp:	dw	BYTENO
statp:	dw	STATUS

BLOKNO:	dw	0
BYTENO:	dw	0

; sblok: procedure(offset, conn) public; declare offset address, conn byte; end;
; sbyte: procedure(offset, conn) public; declare offset address, conn byte; end;

	cseg
conmod: mov	a,e		; set conn
	sta	conn
	call	getmod		; set mode
	sta	mode
	lxi	h,0		; useful 0
	ret

getmod: sub	a		; check for -ve offset
	add	b
	jm	seekbw
	ora	c
	rz			; return mode seek return for 0 offset
	call	chkmax
	mvi	a,3		; seek forward
	rnz
	inr	a		; seek eof
	ret

seekbw: cma			; not offset
	mov	b,a
	mov	a,c
	cma
	mov	c,a
	call	chkmax
	inx	b		; make offset full negate
	mvi	a,1		; seek backwards
	rnz			; not max
	inr	a		; seek abs -> rewind
	lxi	b,0		; offset = 0
	ret

chkmax: mvi	a,0FFH		; return 0 if max offset
	cmp	c
	rnz
	mvi	a,7FH
	cmp	b
	ret

ZZBLOK:	mov	e,m		; pickup conn from *hl

SBLOK:	call	conmod
	shld	BYTENO		; byte = 0
	dad	b
	shld	BLOKNO		; block = offset
seekcm:
	mvi	a,5
	lxi	h,conn
	jmp	ZZXCHG

ZZBYTE:	mov	e,m		; pickup conn from *hl

SBYTE:	call	conmod
	shld	BLOKNO		; block = 0
	dad	b
	shld	BYTENO		; byte = offset
	jmp	seekcm

	end
?ver10.plm
VERSIONNUMBER1P0: DO;
end;

?whoci.asm
	name	whoci
	public	WHOCI
	extrn	ZZLOD2, STATUS

	dseg
ciconn:	dw	1
buffp:	dw	0
statp:	dw	STATUS

	cseg
WHOCI:	mvi	a,0DH
	lxi	h,buffp + 1
	jmp	ZZLOD2
	end
?whoco.asm
	name	whoco
	public WHOCO
	extrn	ZZLOD2, STATUS

	dseg
coconn:	dw	0
buffp:	dw	0
statp:	dw	STATUS

	cseg
WHOCO:	mvi	a,0DH
	lxi	h,buffp + 1
	jmp	ZZLOD2

	end
unixio/makefile
ITOOLS ?= ../../..
ifdef LIB
	TARGETDIR = ../$(LIB)/
endif
TARGETS=$(TARGETDIR)unixio.lib
unexport ISIS_F1

include $(ITOOLS)/tools/isis.mk

REF = $(call ipath,toolbox,1.0)
PLM80 = 3.0
PLMFLAGS = code

OBJS = getcp.obj fopenp.obj getchr.obj putcp.obj fflush.obj putchr.obj\
       fcreat.obj csargs.obj strcmp.obj outstr.obj fclose.obj

all::
	$(MAKE) $(TARGETS)

$(TARGETDIR)unixio.lib: $(OBJS)
	$(call lib,$@,$^)

unixio/unixio_all.src
?csargs.plm
CSARGS: DO;
DECLARE TAB LITERALLY '9',
	CR  LITERALLY '0DH',
	ESC LITERALLY '1BH';


rescan: procedure (conn, status$p) external;
    declare (conn, status$p) address;
end rescan;

getchar: procedure byte external; end;

csargs: PROCEDURE(argptrs$p,string$p,count$p) public;
        DECLARE (string$p,argptrs$p,count$p) ADDRESS;
	DECLARE status address, c byte;
	DECLARE argptr based argptrs$p address,
		string  based string$p  byte,
		count   based count$p   address;
	
	call rescan(1, .status);
	count = 0;	
	c = ' ';
	do while 1;
		do while c = ' ' or c = TAB or c = ',';
			c = getchar;
		end;
		if c = CR or c = ESC then
			return;
		argptr = string$p;
		argptrs$p = argptrs$p + 2;
		count = count + 1;
		do while c <> ' ' and c <> TAB and c <> ','
		  and c <> CR and c <> ESC;
			string = c;
			string$p = string$p + 1;
			c = getchar;
		end;
		string = 0;
		string$p = string$p + 1;
	end;
end;
end;

?fclose.plm
FCLOSE: DO;

close: procedure (conn, status$p) external;
    declare (conn, status$p) address;
end close;

fclose: procedure(fp) public;
	declare (fp, status) address;
	declare fd based fp address;

	call close(fd, .status);
end;
end;

?fcreat.plm
FCREATP: DO;
open: procedure (conn$p, path$p, access, echo, status$p) external;
    declare (conn$p, path$p, access, echo, status$p) address;
end open;

fcreat: procedure(fp, fname, status$p) public;
	declare (fp, fname, status$p) address;
	declare file based fp structure(fd address, cnt address, actual address, buf(1) byte);

	call open(.file.fd, fname, 2, 0, status$p);
	file.cnt = 0;
	file.actual = 80h;
end;
end;

?fflush.plm
FFLUSHP: DO;

write: procedure (conn, buff$p, count, status$p) external;
    declare (conn, buff$p, count, status$p) address;
end write;

fflush: procedure(fp) public;
	declare (fp, status) address;
	declare file based fp structure(fd address, cnt address, w4 address, buf(1) byte);

	call write(file.fd, .file.buf, file.cnt, .status);
	file.cnt = 0;
end;
end;

?fopenp.plm
FOPENP: DO;
/* b1=01, b2=30, CODE(3EH) byte, DATA(6H) byte, STACK(8H) byte, MEMORY(0H) byte,*/
open: procedure (conn$p, path$p, access, echo, status$p) external;
    declare (conn$p, path$p, access, echo, status$p) address;
end open;

fopen: PROCEDURE(fp, path$p, status$p) public;
	DECLARE fp address,
		path$p address,
		status$p address;
	DECLARE file based fp
		STRUCTURE(conn address, count address, actual address, buff(1) byte);
	call open(.file.conn, path$p, 1, 0, status$p);
	file.count, file.actual = 0;
end;
end;

?getchr.plm
GETCHARP: DO;

getc: procedure(fp) byte external; declare fp address; end;

declare stdin structure(conn address, count address, actual address, buff(128) byte)
	initial (1, 0, 0);

getchar: procedure byte public;
	return getc(.stdin);
end;
end;
?getcp.plm
GETCP: DO;

read: procedure (conn, buff$p, count, actual$p, status$p) external;
    declare (conn, buff$p, count, actual$p, status$p) address;
end read;

getc: PROCEDURE(fp) byte public;
	declare fp address;
	declare status address, c byte;
	declare file based fp structure(conn address, count address, actual address, buff(1) byte);

	if file.count >= file.actual then
	do;
		call read(file.conn, .file.buff, 128, .file.actual, .status);
		if file.actual = 0 then
			return 0;
		file.count = 0;
	end;
	c = file.buff(file.count);
	file.count = file.count + 1;
	return c;
end;
end;
?outstr.plm
OUTSTR: DO;

putchar: procedure(ch) external; declare ch byte; end;

outstr: procedure(str) public;
	declare str address, ch based str byte;

	do while ch <> 0;
		call putchar(ch);
		str = str + 1;
	end;
end;
end;

?putchr.plm
PUTCHARP: DO;
write: procedure (conn, buff$p, count, status$p) external;
    declare (conn, buff$p, count, status$p) address;
end write;

putchar: procedure(ch) public;
	declare ch byte, status address;
	call write(0, .ch, 1, .status);
end;
end;
?putcp.plm
PUTCP: DO;
write: procedure (conn, buff$p, count, status$p) external;
    declare (conn, buff$p, count, status$p) address;
end write;

putc: procedure(ch, fp) public;
	declare fp address, ch byte;
	declare status address;
	declare file based fp structure(fd address, cnt address, actual address, buf(1) byte);

	if file.cnt >= file.actual then
	do;
		call Write(file.fd, .file.buf, file.actual, .status);
		file.cnt = 0;
	end;
	
	file.buf(file.cnt) = ch;
	file.cnt = file.cnt + 1;
end;
end;

?strcmp.plm
STRCOMP: DO;

strcomp: procedure(s, t) byte public;
	declare (s, t) address;
	declare sch based s byte,
		tch based t byte;

	do while sch = tch;
		if sch = 0 then
			return 0;
		s = s + 1;
		t = t + 1;
	end;
	if sch > tch then
		return 1;
	return 0ffh;
end;
end;
util/makefile
# common makefile info
ITOOLS ?=../../..
unexport ISIS_F1
ifdef LIB
	TARGETDIR = ../$(LIB)/
endif
TARGETS=$(TARGETDIR)util.lib

include $(ITOOLS)/tools/isis.mk

REF = $(call ipath,toolbox,2.0)
PLM80 = 3.1

OBJS = 	ver10.obj bit.obj bmove.obj comp1.obj comp2.obj comp3.obj comp4.obj\
	comp5.obj comp6.obj cons1.obj cons2.obj cons3.obj cons4.obj fill.obj\
	fmove.obj out1.obj out2.obj out3.obj out4.obj out6.obj out7.obj\
	out8.obj out9.obj out10.obj out11.obj rscan.obj scan.obj scan1.obj\
	scan2.obj scan3.obj scan5.obj scan6.obj scan7.obj scan9.obj scanp.obj\
	sfound.obj

all::
	$(MAKE) $(TARGETS)

$(TARGETDIR)util.lib: $(OBJS)
	$(call lib,$@,$^)

util/util_all.src
?bit.asm
	name BIT
	public	BIT

; DECLARE BITMASK(*) BYTE DATA(80H, 40H, 20H, 10H, 8, 4, 2, 1);
; BIT: PROCEDURE(BITN, PBITS ) BYTE PUBLIC;
;      DECLARE N BYTE, PBITS ADDRESS;
;      DECLARE BITS BASED PBITS (1) BYTE;
;      IF N > BITS(0) THEN RETURN 0;
;      RETURN (BITS(1 + SHR(N, 3)) AND BITMASK(N AND 7)) <> 0;
; END;
	CSEG
BIT:	ldax	d
	cmp	c
	mvi	a,0
	rc
	inx	d
	xchg
	mov	d,a
	mov	a,c
	ani	0F8H
	rrc
	rrc
	rrc
	mov	e,a
	dad	d
	mov	a,c
	ani	7
	mov	e,a
	mov	a,m
	lxi	h,MASKS
	dad	d
	ana	m
	rz
	mvi	a,0FFH
	ret

MASKS:	db	80H, 40H, 20H, 10H, 8, 4, 2, 1

	end;
?bmove.asm
	name	BMOVE
	extrn	ZFMOVE
	public	BMOVE, MOVE2, MOVE3, MOVE4, MOVE5, MOVE6, MOVE7, MOVE8
	public	MOVE9, MOVE10, MOVE11, MOVE12, MOVE13, MOVE14, MOVE15
	public	MOVE16, MOVE17, MOVE18, MOVE19, MOVE20, MOVE21, MOVE22
	public	MOVE23, MOVE24

	cseg page
MOVE24:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE23:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE22:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE21:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE20:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE19:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE18:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE17:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE16:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE15:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE14:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE13:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE12:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE11:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE10:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE9:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE8:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE7:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE6:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE5:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE4:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE3:	ldax	b
	stax	d
	inx	b
	inx	d
MOVE2:	ldax	b
	stax	d
	inx	b
	inx	d
	ldax	b
	stax	d
	ret
	nop
	ret

BMOVE:	pop	h
	xthl
	mvi	a,24
	sub	l
	jc	L6F
	add	a
	add	a
	mov	l,a
	mvi	h,HIGH move24
	pchl
L6F:
	mvi	h,0
	jmp	ZFMOVE

	end;
?comp1.asm
	name	COMP1
	public	MAX
	CSEG

; max(n, m) address

MAX:	xchg
	mov	a,c
	sub	l
	mov	a,b
	sbb	h
	rc		; m > n to return the original m
	mov	h,b
	mov	l,c
	ret		; return the n

	end
?comp2.asm
	name	COMP2
	public	MIN
	CSEG

; min(n, m) address

MIN:	xchg
	mov	a,c
	sub	l
	mov	a,b
	sbb	h
	rnc		; m < n so return m
	mov	h,b
	mov	l,c
	ret		; return n

	end
?comp3.asm
	name	COMP3
	public	DECSIZ

; DECSIZE(N) BYTE - returns number of digits in N
	cseg

DECSIZ:	mov	h,b
	mov	l,c
	mvi	a,1
	lxi	d,-10
	dad	d
	rnc
	inr	a
	lxi	d,-90
	dad	d
	rnc
	inr	a
	lxi	d,-900
	dad	d
	rnc
	inr	a
	lxi	d,-9000
	dad	d
	rnc
	inr	a
	ret

	end
?comp4.plm
COMP4: DO;

SETSC: PROCEDURE(SCANP) EXTERNAL; DECLARE SCANP ADDRESS; END;
SCANWHILE: PROCEDURE(FUNC) EXTERNAL; DECLARE FUNC ADDRESS; END;
ANYCH: PROCEDURE BYTE EXTERNAL; END;
DECLARE SCANP ADDRESS EXTERNAL;

LENSTRNUL: PROCEDURE(STR) BYTE PUBLIC;
	DECLARE STR ADDRESS;
	CALL SETSC(STR);
	CALL SCANWHILE(.ANYCH);
	RETURN SCANP - STR;
END;
END;

?comp5.plm
COMP5: DO;

declare scanP address external;
ScanWhile: procedure(func) external; declare func address; end;
SetSc: procedure(scanp) external; declare scanp address; end;

StringLength: procedure(ptr, func) byte public;
	declare (ptr, func) address;

	call SetSc(ptr);
	call ScanWhile(func);
	return scanP - ptr;
end;
end;
?comp6.asm
	name COMP6
	public	ONBIT

	CSEG
ONBIT:	stc
	mov	a,c
	mvi	c,0FFH

L4:	inr	c
	rar
	jnc	L4
	mov	a,c
	ret

	end

?cons1.plm
CONS1: DO;
DECLARE ACTUAL ADDRESS EXTERNAL,
	SCANP ADDRESS EXTERNAL,
	SCANBUF BASED SCANP (1) BYTE;

READC: PROCEDURE(buf, len) EXTERNAL; DECLARE (buf, len) ADDRESS; END;

CONSOLEIN: PROCEDURE PUBLIC;
	DECLARE buf(123) BYTE;
	CALL READC((SCANP := .buf), last(buf));
	SCANBUF(ACTUAL) = 0;
END;

END;	

?cons2.plm
CONS2: DO;

WRITEC: PROCEDURE(buf, len) EXTERNAL; DECLARE (buf, len) ADDRESS; END;


PUTCHAR: PROCEDURE(CH) PUBLIC;
	DECLARE CH BYTE;
	CALL WRITEC(.CH, 1);
END;

PUTCRLF: PROCEDURE PUBLIC;
	call PUTCHAR(0DH);
	call PUTCHAR(0AH);
END;

PRINT: PROCEDURE(STR) PUBLIC;
	DECLARE STR ADDRESS,
		CH BASED STR BYTE;

	DO WHILE CH <> 0;
		CALL PUTCHAR(CH);
		STR = STR + 1;
	END;
END;

PRINTCR: PROCEDURE(STR) PUBLIC;
	DECLARE STR ADDRESS;
	CALL PRINT(STR);
	CALL PUTCRLF;
END;

PUTBLANK: PROCEDURE PUBLIC;
	CALL PUTCHAR(' ');
END;

END;
?cons3.plm
CONS3: DO;
DECLARE OBUFP ADDRESS EXTERNAL;
SETOB: PROCEDURE(PTR) EXTERNAL; DECLARE PTR ADDRESS; END;
OUTDEC: PROCEDURE(N) EXTERNAL; DECLARE N ADDRESS; END;
OHEXB: PROCEDURE(N) EXTERNAL; DECLARE N ADDRESS; END;
OHEXW: PROCEDURE(N) EXTERNAL; DECLARE N ADDRESS; END;
SETPF: PROCEDURE/*(FUNC)*/ EXTERNAL; END;
PF: PROCEDURE(N) EXTERNAL; DECLARE N ADDRESS; END;
WRITEC: PROCEDURE(buf, len) EXTERNAL; DECLARE (buf, len) ADDRESS; END;

DECLARE BUF(6) BYTE;

WRITENUM: PROCEDURE(FUNC, N);
	DECLARE (FUNC, N) ADDRESS;
	call	SETPF;
	call	SETOB(.BUF);
	call	PF(N);
	CALL	WRITEC(.BUF, OBUFP - .BUF);
END;

DEC: PROCEDURE(N) PUBLIC;
	DECLARE N ADDRESS;
	CALL WRITENUM(.OUTDEC, N);
END;

HEXB: PROCEDURE(N) PUBLIC;
	DECLARE N BYTE;
	CALL WRITENUM(.OHEXB, N);
END;

HEXW: PROCEDURE(N) PUBLIC;
	DECLARE N ADDRESS;
	CALL WRITENUM(.OHEXW, N);
END;

END;
?cons4.plm
CONS4: DO;
DECLARE STATUS ADDRESS EXTERNAL,
	REPORT BYTE EXTERNAL,
	FATAL BYTE EXTERNAL;

PUTCRLF: PROCEDURE EXTERNAL; END;
EX: PROCEDURE EXTERNAL; END;
PRINT: PROCEDURE(STR) EXTERNAL; DECLARE STR ADDRESS; END;


STARS: PROCEDURE;
	CALL PRINT(.(' *** ', 0));
END;

ERRORMESSAGE: PROCEDURE(MSG) PUBLIC;
	DECLARE MSG ADDRESS;
	STATUS = MSG;
	IF NOT REPORT THEN RETURN;

	CALL STARS;
	CALL PRINT(MSG);
	CALL STARS;
	CALL PUTCRLF;
	IF FATAL THEN CALL EX;
END;

END;
?fill.asm
	name FILL
	public FILL

	CSEG

; FILL: PROCEDURE(CNT, DST, VAL) PROCEDURE;
;	DECLARE (CNT, DST) ADDRESS, VAL BYTE;
; END;

FILL:   pop	h	; CNT to HL
	xthl
	mov	a,e	; VAL in A reg
	inr	l	; adjust for quick loop check
	inr	h
	jmp	L2

L1:	stax	b
	inx	b

L2:	dcr	l
	jnz	L1
	dcr	h
	jnz	L1
	ret

	END;
?fmove.asm
	name	FMOVE
	public	FMOVE, ZFMOVE

; fmove(cnt, src, dst)
	cseg

FMOVE:	pop	h	; hl = cnt arg
	xthl
ZFMOVE:
	push	b	; src
	mov	b,h	; xchg hl,bc
	mov	c,l
	pop	h
	dcx	b
	mov	a,e	; dst - src
	sub	l
	mov	a,d
	jz	L1	; possibly same
	sbb	h
	jmp	L2
L1:
	sbb	h
	rz		; nothing to do
L2:
	push	h
	lxi	h,L5
	jc	L3	; src > dst so copy forward
	pop	h
	dad	b	; adjust to copy backwards
	push	h
	xchg
	dad	b
	xchg
	lxi	h,L7
L3:
	inx	b
	mov	a,b	; rrc b,3
	rrc		; the hack below effectively does shl(bc, 3)
	rrc
	rrc
	mov	b,a
	mvi	a,7	; mask of part count
	ana	c
	push	psw
	xra	c	; invert the mask
	rrc		; rrc c,3
	rrc
	rrc
	xra	b	; merge with the rrc b,3 above
	ani	1FH	; mask of the lower bit that are to go in b
	xra	b	; this will leave low 5 bits of c + top 3 bits from b
	mov	c,a	
	mvi	a,1FH
	ana	b	; get the lower bits of b back
	mov	b,a	; end of hack
	inr	b	; adjust for simple loop test
	inr	c
	pop	psw	; get the residule
	rlc		; * 4
	rlc
	push	b	; subtract from the address of the bottom of the loop
	cma
	mov	c,a
	mvi	b,0FFH
	inx	b
	dad	b
	pop	b
	xthl		; effectively jumps to the correct loop code
	ret
L4:	mov	a, m
	stax	d
	inx	h
	inx	d
	mov	a, m
	stax	d
	inx	h
	inx	d
	mov	a, m
	stax	d
	inx	h
	inx	d
	mov	a, m
	stax	d
	inx	h
	inx	d
	mov	a, m
	stax	d
	inx	h
	inx	d
	mov	a, m
	stax	d
	inx	h
	inx	d
	mov	a, m
	stax	d
	inx	h
	inx	d
	mov	a, m
	stax	d
	inx	h
	inx	d

L5:	dcr	c
	jnz	L4
	dcr	b
	jnz	L4
	ret

L6:	mov	a, m
	stax	d
	dcx	h
	dcx	d
	mov	a, m
	stax	d
	dcx	h
	dcx	d
	mov	a, m
	stax	d
	dcx	h
	dcx	d
	mov	a, m
	stax	d
	dcx	h
	dcx	d
	mov	a, m
	stax	d
	dcx	h
	dcx	d
	mov	a, m
	stax	d
	dcx	h
	dcx	d
	mov	a, m
	stax	d
	dcx	h
	dcx	d
	mov	a, m
	stax	d
	dcx	h
	dcx	d

L7:	dcr	c
	jnz	L6
	dcr	b
	jnz	L6
	ret

	END


?out1.asm
	name OUT1
	public	OHEXB, OHEXW, OHEXPB, OHEXPW
	extrn	OBUFP

	CSEG
OHEXPB:	ldax	b
	mov	c,a
	jmp	OHEXB
OHEXPW:	mov	h,b
	mov	l,c
	mov	c,m
	inx	h
	mov	b,m
OHEXW:	mov	a,c
	mov	c,b
	mov	b,a
	call	OHEXB
	mov	c,b
OHEXB:	lhld	OBUFP
	mov	a,c
	rlc
	rlc
	rlc
	rlc
	call	OHEXN
	mov	a,c
OHEXN:
	ani	0FH
	adi	30H
	cpi	3AH
	jc	L001E
	adi	7
L001E:
	mov	m,a
	inx	h
	shld	OBUFP
	ret

	end
?out10.plm
OUT10: DO;
OutScanByte: procedure external; end;

OutScanBytes: procedure(n) public;
	declare n byte;

	do while n > 0;
		call OutScanByte;
		n = n - 1;
	end;
end;
end;

?out11.asm
	name OUT11
	public OBUFP, ZZOPRI, ZZOWRI, ZZOADD, ZZOCRL, ZZOCHR, ZZOBLK

	cseg

ZZOBLK:	mvi	c,' '		; save a space
ZZOCHR:	lhld	OBUFP		; save character
	mov	m,c
	inx	h
	shld	OBUFP
	ret
ZZOCRL:	lxi	b,0A0DH		; save crlf
ZZOADD:	lhld	OBUFP		; save byte pair
	mov	m,c
	inx	h
	mov	m,b
	inx	h
	shld	OBUFP
	ret
ZZOWRI:	sub	a		; copy from *bc -> *OBUFP for e chars
	add	e
	rz
	lhld	OBUFP
L1F:
	ldax	b
	mov	m,a
	inx	h
	inx	b
	dcr	e
	jnz	L1F
L27:
	shld	OBUFP
	ret
ZZOPRI:	lhld	OBUFP		; copy from *bc -> *OBUFP until *bc == 0
L2E:
	ldax	b
	ana	a
	jz	L27
	mov	m,a
	inx	h
	inx	b
	jmp	L2E

	dseg
OBUFP:	dw	0
	end
?out2.plm
OUT2: DO;
/* b1=01, b2=31, CODE(12H) byte, DATA(0H) byte, STACK(0H) byte, MEMORY(0H) byte,*/
declare jmp literally '0c3h';

declare (zzochr, zzocrl, zzoblk, zzowri, zzopri, zzoadd) label external;

declare outchar byte public data(jmp), outcharAddr address data(.zzochr);
declare outcrlf  byte public data(jmp), outcrlfAddr address data(.zzocrl);
declare outblank byte public data(jmp), outblankAddr address data(.zzoblk);
declare outwrite byte public data(jmp), outwriteAddr address data(.zzowri);
declare outprint byte public data(jmp), outprintAddr address data(.zzopri);
declare outaddr  byte public data(jmp), outaddrAddr address data(.zzoadd);

end;
?out3.plm
OUT3: DO;

OUTDECR: PROCEDURE(A, B) EXTERNAL; DECLARE A ADDRESS, B BYTE; END;

OUTDEC: PROCEDURE(A) PUBLIC;
	DECLARE A ADDRESS;
	call OUTDECR(A, 0);
END;

END;
?out4.asm
	name	OUT4
	extrn	OBUFP
	public  SETOB
	stkln	14


	CSEG
SETOB:	pop	d		; return address
	lhld	OBUFP
	push	h		; old OBUFP	
	lxi	h,ROBUFP	; push return address for call to restore OBUFP
	push	h
	mov	h,b		; OBUFP = bc
	mov	l,c
	shld	OBUFP
	push	d		; restore return address
	ret

ROBUFP:	xchg
	pop	h
	shld	OBUFP
	xchg
	ret

	end
?out6.plm
OUT6: DO;

OUTCHARS: PROCEDURE(CNT, CH) EXTERNAL; DECLARE (CNT, CH) BYTE; END;
DECSIZ: PROCEDURE(N) BYTE EXTERNAL; DECLARE N ADDRESS; END;
DECLARE OBUFP ADDRESS EXTERNAL;

DECLARE LEADCHAR BYTE PUBLIC INITIAL(' ');

OUTDECR: PROCEDURE(N, WIDTH) PUBLIC;
	DECLARE N ADDRESS, WIDTH BYTE;
	DECLARE CHP ADDRESS, NDIGIT BYTE,
		CH BASED CHP BYTE;

	if (NDIGIT := DECSIZ(N)) < WIDTH THEN
		CALL OUTCHARS(WIDTH - NDIGIT, LEADCHAR);
	
	CHP = OBUFP + NDIGIT;
	DO WHILE CHP > OBUFP;
		CHP = CHP - 1;
		CH = '0' + N mod 10;
		N = N / 10;
	END;	
	OBUFP = OBUFP + NDIGIT;
END;
END;

?out7.plm
OUT7: DO;

OUTCHAR: PROCEDURE(CH) EXTERNAL; DECLARE CH BYTE; END;


OUTCHARS: PROCEDURE(CNT, CH) PUBLIC;
	DECLARE (CNT, CH) BYTE;

	DO WHILE CNT > 0;
		CALL OUTCHAR(CH);
		CNT = CNT - 1;
	END;
END;
END;

?out8.plm
OUT8: DO;

BUMPSCANP: PROCEDURE EXTERNAL; END;
OUTCHAR: PROCEDURE(CH) EXTERNAL; DECLARE CH BYTE; END;
DECLARE SCANP ADDRESS EXTERNAL,
	SCANCH BASED SCANP BYTE;

OUTSCANBYTE: PROCEDURE PUBLIC;
	call OUTCHAR(SCANCH);
	call BUMPSCANP;
end;
end;
?out9.plm
OUT9: DO;

OUTSCANBYTE: PROCEDURE EXTERNAL; END;
SETSCANENDED: PROCEDURE EXTERNAL; END;
DECLARE SCANP ADDRESS EXTERNAL,
	SCANENDED BYTE EXTERNAL;
SETSC: PROCEDURE(SCANP) EXTERNAL; DECLARE SCANP ADDRESS; END;

OUTSCANSTRING: PROCEDURE PUBLIC;
	call SETSC(SCANP);
	call SETSCANENDED;
	do while not SCANENDED;
		call OUTSCANBYTE;
	end;
end;
end;
?rscan.asm
	name RSCAN
	extrn	SCANP
	public	RSCANB, RSCANA
	cseg

RSCANB:	lhld	SCANP	; return *(byte *)SCANP++
	mov	a,m
	inx	h
	shld	SCANP
	ret

RSCANA:	lhld	SCANP	; return *(address *)SCANP++
	mov	e,m
	inx	h
	mov	d,m
	inx	h
	shld	SCANP
	xchg
	ret

	end
?scan.asm
	name	scan
	public	QDIGCH, DDIGCH, BDIGCH, ANYCH, FORCUP, HDIGCH
	public	LETRCH, LTNMCH, TOKNCH, FILECH
	public	CRLFCH, TERMCH, BLNKCH, ASCBIN
	extrn	SCANP

	CSEG
NXTCH:	lhld	SCANP
	mov	a,m
	mov	b,a
	ret

QDIGCH:	call	NXTCH
	ori	1
	cpi	'9'
	jz	retz
DDIGCH:	call	NXTCH
	cpi	'0'
	jc	RETZ
	cpi	'9' + 1
	sbb	a
	ret
BDIGCH:	call	NXTCH
	ori	1
	cpi	'1'
	jnz	retz

ANYCH:	stc
	sbb	a
	ret

FORCUP:	call	NXTCH
	cpi	'a'
	rc
	cpi	'z' + 1
	rnc
	sui	20H
	ret

HDIGCH:	call	DDIGCH
	rc
	call	FORCUP
	cpi	'A'
	jc	RETZ
	cpi	'F' + 1
	jc	ANYCH

RETZ:	sub	a
	ret

LETRCH:	call	FORCUP
	cpi	'A'
	jc	RETZ
	cpi	'Z' + 1
	jc	ANYCH
	sub	a
	ret

LTNMCH:	call	LETRCH
	rc
	call	DDIGCH
	rc
	sub	a
	ret

TOKNCH:	call	LTNMCH
	rc
	mov	a,b
	cpi	'?'
	jz	ANYCH
	cpi	'@'
	jz	ANYCH
	cpi	'_'
	jz	ANYCH
	sub	a
	ret

FILECH:	call	LTNMCH
	rc
	mov	a,b
	cpi	':'
	jz	ANYCH
	cpi	'.'
	jz	ANYCH
	sub	a
	ret

CRLFCH:	call	NXTCH
	cpi	0DH	; CR
	jz	ANYCH
	cpi	0AH	; LF
	jz	ANYCH
	sub	a
	ret

TERMCH:	call	CRLFCH
	rc
	mov	a,b
	cpi	1BH	; esc
	jz	ANYCH
	sub	a
	ret

BLNKCH:	call	NXTCH
	cpi	9	; TAB
	jz	ANYCH
	cpi	' '
	jz	ANYCH
	sub	a
	ret

ASCBIN:	call	NXTCH
	sui	'0'
	cpi	10
	rc
	sui	7
	ani	5FH
	ret

	end

?scan1.plm
SCAN1: DO;

DECLARE SCAN$P ADDRESS EXTERNAL;
DECLARE CH BASED SCAN$P BYTE;

DECLARE SCAN$ENDED BYTE PUBLIC;
DECLARE ZZSCEN BYTE PUBLIC AT (.SCAN$ENDED);

FORCUP: PROCEDURE BYTE EXTERNAL; END FORCUP;

SETPF: PROCEDURE/*(FUNC)*/ EXTERNAL;
/*	DECLARE FUNC ADDRESS;*/
/* must be called immediately as first non declare statement
   as it relies on reg BC still holding in the passed in FUNC
*/
END SETPF;

PF: PROCEDURE BYTE EXTERNAL;
END PF;

SET$SCAN$ENDED: PROCEDURE PUBLIC;
	SCAN$ENDED = CH = 0;
END SET$SCAN$ENDED;

BUMP$SCANP: PROCEDURE PUBLIC;
	CALL SET$SCAN$ENDED;
	SCAN$P = SCAN$P + (SCAN$ENDED + 1);
	CALL SET$SCAN$ENDED;
END BUMP$SCANP;

SCAN$UNTIL: PROCEDURE(FUNC) PUBLIC;
	DECLARE FUNC ADDRESS;
	CALL SETPF/*(FUNC)*/;
	
	DO WHILE not PF;
		CALL BUMP$SCANP;
		if SCAN$ENDED then
			RETURN;
	END;
END SCAN$UNTIL;
	
	
SCAN$WHILE: PROCEDURE(FUNC) PUBLIC;
	DECLARE FUNC ADDRESS;
	CALL SETPF/*(FUNC)*/;
	
	DO WHILE PF;
		CALL BUMP$SCANP;
		if SCAN$ENDED then
			RETURN;
	END;
END SCAN$WHILE;

SCAN$MATCH: PROCEDURE(PTR) BYTE PUBLIC;
	DECLARE PTR ADDRESS;
	DECLARE C BASED PTR BYTE;
	DECLARE D7 ADDRESS;

	call	SET$SCAN$ENDED;
	D7 = SCAN$P;

	DO WHILE FORCUP = C AND NOT SCAN$ENDED;
		PTR = PTR + 1;
		CALL BUMP$SCANP;
		if C = 0 then
			return 0FFH;
	END;
	SCAN$P = D7;
	CALL Set$SCAN$ENDED;
	return 0;
END SCAN$MATCH;	

END;
?scan2.asm
	name SCAN2
	public SETPF, PF, PF1, PF2
	CSEG
SETPF:
	mov	h,b
	mov	l,c
	shld	PF+1
	ret

	DSEG

PF:
PF1:
PF2:	JMP	0
	END

?scan3.plm
SCAN3: DO;

SCAN$UNTIL: PROCEDURE(FUNC) EXTERNAL; DECLARE FUNC ADDRESS; END;
SCAN$WHILE$BLANKS: PROCEDURE EXTERNAL; END;
HDIGCH: PROCEDURE BYTE EXTERNAL; END;
DDIGCH: PROCEDURE BYTE EXTERNAL; END;
ASCBIN: PROCEDURE BYTE EXTERNAL; END;
BUMP$SCANP: PROCEDURE EXTERNAL; END;

DECLARE ACC ADDRESS;

HEXIN: PROCEDURE ADDRESS PUBLIC;

	ACC = 0;
	call SCAN$UNTIL(.HDIGCH);
	do while HDIGCH;
		ACC = ACC * 16 + ASCBIN;
		call	BUMP$SCANP;
	end;
	call	SCAN$WHILE$BLANKS;
	return ACC;
END;


DECIN: PROCEDURE ADDRESS PUBLIC;

	ACC = 0;
	call SCAN$UNTIL(.DDIGCH);
	do while DDIGCH;
		ACC = ACC * 10 + ASCBIN;
		call	BUMP$SCANP;
	end;
	call	SCAN$WHILE$BLANKS;
	return ACC;
END;

END;

?scan5.plm
SCAN5: DO;
BLNKCH: PROCEDURE BYTE EXTERNAL; END;
SCANWHILE: PROCEDURE(FUNC) EXTERNAL;
	DECLARE FUNC ADDRESS;
END;

SCANWHILEBLANKS: PROCEDURE PUBLIC;
	CALL SCANWHILE(.BLNKCH);
END;


END;
?scan6.plm
SCAN6: DO;

SCANMATCH: PROCEDURE(PTR) BYTE EXTERNAL; DECLARE PTR ADDRESS; END;
SETOB: PROCEDURE(PTR) EXTERNAL; DECLARE PTR ADDRESS; END;
OUTPRINT: PROCEDURE(STR) EXTERNAL; DECLARE STR ADDRESS; END;
OUTWRITE: PROCEDURE(FILE, STR) EXTERNAL; DECLARE (FILE, STR) ADDRESS; END;
ERRORMESSAGE: PROCEDURE(STR) EXTERNAL; DECLARE STR ADDRESS; END;

DECLARE MSG(*) BYTE INITIAL('SCAN ERROR: EXPECTED "',
/* 22 */		    '                               ');

SCANEXPECT: PROCEDURE(PTR) PUBLIC;
	DECLARE PTR ADDRESS;

	if SCANMATCH(PTR) THEN
		RETURN;
	CALL SETOB(.MSG(22));
	CALL OUTPRINT(PTR);
	CALL OUTWRITE(.('"', 0), 2);
	CALL ERRORMESSAGE(.MSG);	
END;

END;
?scan7.asm
	name	SCAN7
	extrn	SCANP, ZZSCEN
	public	SETSC
	stkln	14

	cseg
SETSC:	pop	d		; return address
	lhld	SCANP		; original SCANP
	push	h
	lxi	h,RSETSC	; push address of restore routine
	push	h
	mov	h,b		; SCANP = bc
	mov	l,c
	shld	SCANP
	push	d		; restore return address
	ret

RSETSC:	xchg
	pop	h
	shld	SCANP		; restore original SCANP
	mov	b,a
	sub	a
	sub	m
	cmc
	sbb	a
	sta	ZZSCEN
	mov	a,b
	xchg
	ret

	end

?scan9.plm
SCAN9: DO;

DECLARE	SCANP ADDRESS EXTERNAL,
	SCANENDED BYTE EXTERNAL;

SETSC: PROCEDURE(SCANP) EXTERNAL; DECLARE SCANP ADDRESS; END;
FORCUP: PROCEDURE BYTE EXTERNAL; END;
BUMPSCANP: PROCEDURE EXTERNAL; END;

FORCUPSTRING: PROCEDURE PUBLIC;
	DECLARE SCANCH BASED SCANP BYTE;

	call SETSC(SCANP);
	do while not SCANENDED;
		SCANCH = FORCUP;
		call BUMPSCANP;
	end;
end;

end;	

?scanp.asm
	name SCANP
	public SCANP
	dseg
SCANP:	dw	0
	end;

?sfound.asm
	name SFOUND
	public SFOUND, TARLEN, JOKER, GIVEUP
	extrn SCANP, TARGET

	DSEG
TARLEN:	db	0
JOKER:	db	'?'
GIVEUP:	dw	0

	CSEG
SFOUND: lhld	GIVEUP
	xchg
	lhld	TARLEN
	mov	b,h		; b = joker
	mov	c,l		; c = tarlen
	lhld	SCANP
	mov	a,e
	sub	l
	mov	e,a
	mov	a,d
	sbb	h
	mov	d,a
	ora	e
	rz			; nothing to check
	inr	d		; adjust for simple loop checks
	inr	e
trial:
	lda	TARGET
	call	first		; returns if first char found
	push	b		; save joker and tarlen
	push	d		; save counters
	push	h		; save where we are matching
	lxi	d,TARGET
match:
	dcr	c		; matched one more
	inx	d
	jz	found		; all done?
	ldax	d
	cmp	m
	inx	h
	jz	match		; still matching
	cmp	b
	jz	match		; or is wild card
	pop	h		; no match so restore and retry
	pop	d
	pop	b
	jmp	trial
found:
	mvi	a,0FFH		; found
	shld	SCANP		; save location after this string
	pop	b		; junk the stack saves
	pop	b
	pop	b
	ret
match1:
	cmp	m		; start match found
	inx	h
	rz			; return just the one level
first:
	dcr	e
	jnz	match1
	dcr	d
	jnz	match1
	pop	psw		; junk first return address
	sub	a		; return 0 to original caller
	ret

	END	
?ver10.plm
VERSIONNUMBER1P0: DO;
end;

