editor.plm
editor: do;
    /* useful literals */
    declare LIT LITERALLY 'literally';
    declare BELL LIT '7',
            BS  LIT '8',
            TAB LIT '9',
            LF  LIT '0AH',
            VT  LIT '0BH',
            FF  LIT '0CH',
            CR  LIT '0DH',
            ESC LIT '1BH';

    declare CTRLC   LIT '3',
            CTRLQ   LIT '11h',
            CTRLR   LIT '12h',
            CTRLS   LIT '13h',
            CTRLX   LIT '18h',
            CTRLZ   LIT '1Ah',
            RUBOUT  LIT '7FH';

    declarE ISALPHA LIT '0',
            ISNUMBER   LIT '1',
            ISOTHER lIT '2';

    declare TRUE    LIT '0FFH',
            FALSE   LIT '0',
            BOOL    LIT 'BYTE';      
    declare jmps(2) structure(jmp byte, target address) data(
        0c3h, .main-3, 0c3h, 0);    /* To patch 0 with .REENTER */
    declare copyRight(*) byte data('(C) 1973,1974,1975,1976,1977 INTEL CORP');
    declare vecStart0 address data(0F800h);
    declare signOn(*) byte data(CR, LF, 'ROM TEXT EDITOR, V1.1', CR, LF);
    declare aIllegal(*) byte data(22h, ' ILLEGAL IN THIS CONTEXT', CR, LF);
    declare aNotFound(*) byte data(CR, LF, 'CANNOT FIND ', 22h);
    declare crlf(2) byte data(CR, LF);
    declare aStartPunch(*) byte data(CR, LF, 'START PUNCH, TYPE CHAR', CR, LF);
    declare aIterFault(*) byte data(CR, LF, 'ITERATION STACK FAULT');
    declare aBreak(*) byte data(CR, LF, '*BREAK*', CR, LF);
    declare aUnused(*)  byte data(' - UNUSED BYTES', CR, LF);
    declare bA8C1 byte data(0);

    declare (ILLEGAL, BREAK) label public;

    /* data located at 2000h */
    declare (w2000, w2002, w2004) address,
            (textPtr, endPtr) address,
            (w200A, w200C, cmdCnt, w2010, w2012) address,
            memSize address,
            (char, chType, backwards, curCol) byte;
    declare (iterSp, b201B, b201C, findLen, B201E) byte,
            needLeader byte, b2020 byte,
            findBuf(17) byte,
            (iterStackPtr, iterStackCnt)(8) address;

    ci: procedure byte external;
    end ci;

    co: procedure (char) external;
        declare (char) byte;
    end co;

    ri: procedure byte external;
    end ri;

    po: procedure (char) external;
        declare (char) byte;
    end po;

    lo: procedure (char) external;
        declare (char) byte;
    end lo;

    csts: procedure byte external;
    end csts;

    memck: procedure address external;
    end memck;

    numout: procedure(value, base, lc, bufadr, width) external;
        declare (value, bufadr) address, (base, lc, width) byte; 
    end;

    ChIn$CI: procedure byte;
        return CI and 7fh;
    end;

    ChkCtrlC: procedure;
        if CSTS then
        if ChIn$CI = CTRLC then
            goto BREAK;
    end;

    Write$PO: procedure(curPos, endPos);
        declare (curPos, endPos) address;
        /* 
           this code compiles differently on all available compilers
           cf the rom code, specifically the code in the rom after
           the call to PO is
           lxi h,needLeader
           mvi m,0
           inx h
           inr m
           jnz ..

           even though needLeader and b2020 are adjacent in memory
           according to the declaration, the compiler generates
           lxi h,needLeader
           mvi m,0
           lxi h,b2020
           inr m
           jnz ...

           the hack here is to comment out the line of code
           and to insert a dummy enables to pad to align
        */

        if needLeader then
            do b2020 = 1 to 120;
                call PO(0);
                /*needLeader = 0;*/
                enable;
                enable;
                enable;
            end;
        do while curPos <= endPos;
            call ChkCtrlC;
            call PO(MEMORY(curPos));
            curPos = curPos + 1;
        end;
    end; 

    Putch$CO: procedure(ch);
        declare ch byte;
        CALL CO(ch);
        if CSTS then do;
            ch = ChIn$CI;
            if ch = CTRLS then
                do while (ch := ChIn$CI) <> CTRLQ;
                    if ch = 3 then
                        goto BREAK;
                end;
        end;
    end;

    DisplayCh: procedure(ch);
        declare (ch, spaces, i) byte;

        spaces = ch = TAB and (7 - (curCol and 7));
        if ch = TAB then
            ch = ' ';
        do i = 0 to spaces;
            if ch = CR then
                curCol = 0;
            if ch = FF then
                ch = '!';
            if ch = ESC or ch = 7dh then
                ch = '$';
            if ch >= ' ' then
                curCol = curCol + 1;
            call Putch$CO(ch);
        end;
    end;

    DisplayText: procedure(str$p,  len);
        declare (str$p, len, i) address;
        declare str based str$p (1) byte;

        do i = 0 to len;
            call ChkCtrlC;
            call DisplayCh(str(i));
        end;
    end;

    ChIn$RO: procedure byte;
        call ChkCtrlC;
        char = RI;
        if CARRY then
            char = CTRLZ;
        return char and 7fh;
    end;

    moveup: procedure;
        declare dstidx address;

        if iter$sp <> 0 then
            return;
        dstidx = memsize - 1;

        do while w2012 >= w2004;
            memory(dstidx) = memory(w2012);
            dstidx = dstidx - 1;
            w2012 = w2012 - 1;
        end;
        w2004 = dstidx + 1;
        w2012 = memsize - 1;
    end;

    MoveDown: procedure;
        endPtr = textPtr;
        do while w200A <= w200C;
            MEMORY(endPtr) = MEMORY(w200A);
            w200A = w200A + 1;
            endPtr = endPtr + 1;
        end;
        MEMORY(endPtr := endPtr - 1) = 0ffh;;
        call MoveUp;
    end;

    GetText: procedure;
        declare (inCh,  prevInCh) byte,
                idx address;

        do while 1;
            b201B = FALSE;
            w2004 = memSize;
            w2012 = memSize - 1;
            prevInCh = 0;
            iterSp = 0;
            call DisplayCh('*');
            inch = ChIn$CI;

            do while inCh <> CTRLC;
                do while inCh = RUBOUT;
                    if w2004 <> memSize then do;
                        if (inCh := MEMORY(w2004)) = ESC THEN
                            inCh = '$';
                        call DisplayCh(inCh);
                        w2004 = w2004 + 1;
                        inCh = ChIn$CI;
                        prevInCh = 0;
                    end;
                    else do;
                        inCh = CTRLC;
                        call DisplayCh(BELL);
                    end;
                end;
                if inCh = CTRLX then do;
                    call DisplayCh('#');
                    call DisplayText(.crlf, 1);
                    do while w2004 <> memSize and MEMORY(w2004) <> LF;
                        w2004 = w2004 + 1;
                    end;
                    inCh = ChIn$CI;
                end;
                else if inCh = CTRLR then do;
                    call DisplayText(.crlf, 1);
                    idx = w2004;
                    do while idx < memSize and LF <> MEMORY(idx);
                        idx = idx + 1;
                    end;
                    do while idx <> w2004;
                        call DisplayCh(MEMORY(idx := idx - 1));
                    end;
                    inCh = ChIn$CI;
                end;
                else if endPtr >= w2004 - 10 then do;
                    inCh = ChIn$CI;
                    call DisplayCh(BELL);
                end;
                else do;
                    if inCh = CR then do;
                        MEMORY(w2004 := w2004 - 1) = CR;
                        call DisplayCh(CR);
                        inCh = LF;
                    end;
                    if inCh <> CTRLC then do;
                        if inCh =  7dh then
                            inCh = ESC;
                        if inCh = ESC then
                            call DisplayCh('$');
                        else
                            call DisplayCh(inCh);
                        MEMORY(w2004 := w2004 - 1) = inCH;
                        if inCh = ESC and prevInCh = ESC then do;
                            call DisplayText(.crlf, 1);
                            return;
                        end;
                        prevInCh = inCh;
                        inCh = ChIn$CI;
                    end;
                end;
            end;
            call DisplayText(.crlf, 1);
        end;    /* while 1 */
    end;

    GetCmdCh: procedure byte;
        declare ch byte;

        if w2004 > w2012 then
            call GetText;
        if csts then
            if ChIn$CI = CTRLC then do;
                if b201E then
                    call MoveDown;
                goto BREAK;
            end;
        chtype = ISOTHER;
        ch = MEMORY(w2012); 
        if ch >= 'A' and ch <= 'Z' or ch >= 'a' and ch <= 'z' then
            chtype = ISALPHA;
        if (ch >= '0' and ch <= '9') or ch = '+' or ch = '-' then
            chtype = ISNUMBER;
        w2012 = w2012 - 1;
        return ch;
     end;

    GetCmdNum: procedure address;
        declare val address;
        if char < '0' then do;
            backwards = char = '-';
            char = GetCmdCh;
        end; 

        val =  0;
        do while chtype = ISNUMBER;
            if char < '0' then
                goto ILLEGAL;
            /* val = val * 10 + char - '0' */
            val = shl(shl(val, 2) + val, 1) + char - '0';
            char = GetCmdCh;
        end;
        if val = 0 and backwards then
            return 1;
        return val;
    end;


    FindRel: procedure address;
        declare start address, (i, ch) byte;

        start = 0;
        do while MEMORY(textPtr + start) <> 0ffh;
            i = 0;
            do while (ch := MEMORY(textPtr + start + i)) = findbuf(i);
                if findbuf(i := i + 1) = esc then
                    return start;
            end;
            if ch = 0ffh then
                return 0ffffh;
            start = start + 1;
        end;
        return 0ffffh;
    end;

    SeekLine: procedure address;
        declare startLine address, ch byte;

        startLine = textPtr;
        if cmdCnt = 0 or backwards then do;
            if textPtr = 1 then
                return 1;
            if textPtr = endPtr then
                startLine = startLine - 1;
            cmdCnt = cmdCnt + 1;
            do while cmdCnt <> 0 and textPtr <> 1;
                if (ch := MEMORY(startLine)) = 0ffh then
                    return startLine + 1;
                if ch = LF then
                    cmdCnt = cmdCnt - 1;
                startLine = startLine - 1;
            end;
            return startLine + 2;   /* after the marker */
        end;
        else
            do while cmdCnt <> 0;
                if (ch := memory(startLine)) = 0ffh then
                    return startLine;
                if ch = LF then
                    cmdCnt = cmdCnt - 1;
                startLine = startLine + 1;
            end;
        return startLine;
    end;


    FindLoc: procedure address;
        declare relOffset address;
 
        findLen = 0;
        do while (findbuf(findLen) := getcmdch) <> ESC;
            if findLen < 16 then
                findLen = findLen + 1;
        end;
        if (relOffset := FindRel) = 0ffffh then do;
            call DisplayText(.aNotFound, 14);
            if findLen <> 0 then
                call DisplayText(.findbuf, findLen - 1);
            call PutCh$CO(22h);
            call DisplayText(.crlf, 1);
            goto break;
        end;
        else
            return relOffset + textPtr;
    end;


    ShowUnused: procedure;
        declare b2072(6) byte, b2078 byte,
                b2079 byte, b207A(6) byte;
        declare unused address, junk address;

        unused = memSize - endPtr;
        call NumOut(unused, 10, bA8C1, .b207A, 6);
        b2079 = 5;
        b2078 = 5;
        /* copy the digits over inserting a comma if >= 1000 */
        do while b2078 <> 0ffh;
            b2072(b2078) = b207A(b2079);
            b2079 = b2079 - 1;
            b2078 = b2078 - 1;
            if b207A(b2079) <> 0 and b2079 = 2 then do;
                b2072(b2078) = ',';
                b2078 = b2078 - 1;
            end;
        end;
        call DisplayText(.b2072, 5);
        call DisplayText(.aUnused, 16);
    end;

main:
    call DisplayText(.signOn, 24);
    memSize = MEMCK - .MEMORY;
    MEMORY(0) = 0ffh;
    MEMORY(1) = 0ffh;
    w2000 = .MEMORY(1);
    textPtr, endPtr = 1;
    b201B = 0;
    needLeader = TRUE;
    call GetText;

CMDLOOP:
    do while 1;
        b201E = 0;
        w200A = textPtr;
        w200C = endPtr;
        backwards = 0;
        cmdCnt = 1;
        char = GetCmdCh;
        if chType = ISNUMBER then
            cmdCnt = getCmdNum;
        if char = '<' then do;
            if backwards then
                goto ILLEGAL;
            if (iterSp := iterSp + 1) > 8 then do;
                call DisplayText(.aIterFault, 22);
                goto BREAK;
            end;
            iterStackPtr(iterSp) = w2012;
            if (iterStackCnt(iterSp) := cmdCnt) = 0 then
                goto ILLEGAL;
            goto CMDLOOP;
        end;
        if char = '>' and iterSp <> 0 then do;
            if (iterStackCnt(iterSp) := iterStackCnt(iterSp) - 1) <> 0 then
                w2012 = iterStackPtr(iterSp);
            else
               iterSp = iterSp - 1;
            goto CMDLOOP;
        end; 
        if chType = ISALPHA then do;
            if char > 'Z' then
                char = char and 0dfh;
            do case char - 'A';
               do;                  /* 'A' APPEND */
                    b201C = TRUE;
                    cmdCnt = 0;
                    do while b201C;
                        if endPtr >= w2004 - 240 OR b201B THEN
                            b201C = 0;
                        else if (char := ChIn$RO) <> ctrlz then do; 
                            if char <> 0 and char <> 7fh then do;
                                if char = FF then
                                    b201C = 0;
                                MEMORY(endPtr) = char;
                                endPtr = endPtr + 1;
                                if char = LF then
                                    if (cmdCnt := cmdCnt + 1) = 50 then
                                        b201C = 0;
                            end;
                        end;
                        else do;
                            b201B = 0FFH;
                            b201C = 0;
                        end;
                    end;
                    MEMORY(endPtr) = 0ffh;
                end;
                textPtr = 1;        /* 'B' TEXT POINTER TO BEGINNING */
                do;                 /* 'C' TEXT POINTER CHARACTER */
                    if backwards then do;
                        if textPtr - 1 < cmdCnt then
                            textPtr = 1;
                        else
                            textPtr = textPtr - cmdCnt;
                    end;
                    else if (w2010 := textPtr + cmdCnt) > endPtr then
                        textPtr = endPtr;
                    else
                        textPtr = w2010;
                end;
                do;                 /* 'D' DELETE */
                    if backwards then do;
                        if textPtr - 1 < cmdCnt then
                            textPtr = 1;
                        else
                            textPtr = textPtr - cmdCnt;
                    end;
                    else if (w2010 := textPtr + cmdCnt) > endPtr then
                        w200A = endPtr;
                    else
                        w200A = w2010;
                    call MoveDown;
                end;
                do;                 /* 'E' EXIT */
                    call DisplayText(.aStartPunch, 25);
                    char = CI;
                    char = 0;
                    call Write$PO(1, endPtr - 1);
                    if b201B then
                        call PO(CTRLZ);
                    else
                        do while char <> CTRLZ;
                            char = ChIn$RO;
                            call PO(char);
                        end;
                    do char = 1 to 120;
                        call PO(0);
                    end;
                    w200A = STACKPTR;
                    w2002 = endPtr - 1;
                    call vecStart0;
        REENTER:
                    STACKPTR = w200A;
                end;
                textPtr = FindLoc + findLen;/* 'F' FIND */
                do; goto ILLEGAL; end;      /* 'G' */
                do; goto ILLEGAL; end;      /* 'H' */
    CASE$I:     do;                         /* 'I' INSERT */
                    b201E = TRUE;
                    do while (char := GetCmdCh) <> ESC;
                        if textPtr = w200A then do; 
                            call MoveUp;
                            if w2004 - 11 < w200C then
                                goto BREAK;
                            w2010 = w200C;
                            w200C, w200A = w2004 - 10;
                            do while w2010 >= textptr;
                                MEMORY(w200A) = MEMORY(w2010);
                                w2010 = w2010 - 1;
                                w200A = w200A - 1;
                            end;
                            w200A = w200A + 1;
                        end;
                        MEMORY(textPtr) = char;
                        textPtr = textPtr + 1; 
                    END; 
                    b201E = 0;
                    call MoveDown;
                end;
                do; goto ILLEGAL; end;      /* 'J' */
                do;                         /* 'K' KILL */
                    if (w200A := SeekLine) < textPtr then do;
                        w2010 = textptr;
                        textptr = w200A;
                        w200A = w2010;
                    end;
                    call MoveDown;
                end;
                textPtr = SeekLine;         /* 'L' TEXT POINTER LINE*/
                call ShowUnused;            /* 'M' MEMORY */
                do;                         /* 'N' PUNCH NULLS */
                    call DisplayText(.aStartPunch, 25);
                    b2020 = CI;
                    do b2020 = 1 to 120;
                        call PO(0);
                    end;
                    b2020 = CI;
                end;
                do; goto ILLEGAL; end;      /* 'O' */
                do; goto ILLEGAL; end;      /* 'P' */
                do;                         /* 'Q' QUIT */
                    w200A = STACKPTR;
                    w2002 = endPtr - 1;
                    call vecStart0;
                END;
                do; goto ILLEGAL; end;      /* 'R' */
                do;                         /* 'S' SUBSTITUTE */
                    w200A = (textPtr := FindLoc) + findLen;
                    goto CASE$I;
                end;
                do;                         /* 'T' TYPE */
                    if (w2010 := SeekLine) <> textPtr then
                        if textPtr < w2010 then
                        call DisplayText(.MEMORY + textptr, w2010 - textptr - 1);
                    else
                        call DisplayText(.MEMORY + w2010, textptr - w2010 - 1);
                end;
                do; goto ILLEGAL; end;      /* 'U' */
                do; goto ILLEGAL; end;      /* 'V' */
                do;                         /* 'W' WRITE */
                    call DisplayText(.aStartPunch, 25);
                    b2020 = CI;
                    backwards = 0;
                    textptr = 1;
                    w200A = SeekLine;
                    call Write$PO(1, w200A - 1);
                    b2020 = CI;
                    call MoveDown;
                end;
                do; goto ILLEGAL; end;      /* 'X' */
                do; goto ILLEGAL; end;      /* 'Y' */
                textPtr = endPtr;           /* 'Z' TEXT POINTER END */
            end;    /* of case */
        end;
        else
            goto ILLEGAL;
    end;


ILLEGAL:
    if char > ' ' then do;
        call DisplayText(.crlf, 1);
        call Putch$CO(22h);
        call DisplayCh(char);
        call DisplayText(.aIllegal, 26);
        call GetText;
    end;
    goto CMDLOOP;


BREAK:
    call DisplayText(.aBreak, 10);
    call GetText;
    goto CMDLOOP;


end;
eof;
dblank.plm
deblank: do;

    DEBLANK: PROCEDURE(PTR) ADDRESS public;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE (C = ' ');
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;
end;
dlimit.plm
delimit: do;
    DELIMIT: PROCEDURE(PTR) ADDRESS public;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE (C = ':' OR C = '.' OR
                 ('0' <= C AND C <= '9') OR
                 ('A' <= C AND C <= 'Z'));
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;
end;
fupper.plm
forceUpper: do;
declare CR LITERALLY '0dh';
uppercase: procedure(char) byte external; declare char byte; end;

    ForceUpper: procedure(bufferPtr) public;
        declare bufferPtr address, ch based bufferPtr byte;

        do while ch <> CR;
            ch = uppercase(ch);
            bufferPtr = bufferPtr + 1;
        end;
    end;
end;
numout.plm
numout: do;
    NUMOUT: PROCEDURE(VALUE, BASE, LC, BUFADR, WIDTH) public;
        DECLARE (VALUE, BUFADR) ADDRESS, (BASE, LC, WIDTH) BYTE; 
        DECLARE DIGITS(*) byte data('0123456789ABCDEF');
        DECLARE I BYTE;
        DECLARE BUF BASED BUFADR (1) BYTE;

        DO I = 1 TO WIDTH;
            BUF(WIDTH - I) = DIGITS(VALUE MOD BASE);
            VALUE = VALUE / BASE;   
        END;

        I = 0;
        DO WHILE BUF(I) = '0' AND I < WIDTH - 1;
            BUF(I) = LC;
            I = I + 1;
        END;
    END;
end;
seq.plm
seq: do;

    SEQ: PROCEDURE(S1, S2, CNT) BYTE;
        DECLARE (S1,S2) ADDRESS, CNT BYTE;
        DECLARE S1A BASED S1(1) BYTE;
        DECLARE S2A BASED S2(1) BYTE;
        DECLARE I BYTE;
        CNT = CNT - 1;
        DO I = 0 TO CNT;
            IF S1A(I) <> S2A(I) THEN
                RETURN 0;
        END;
        RETURN 0FFH;
    END;
end;
ucase.plm
uppercase: do;
    uppercase: procedure(char) byte public;
        declare char byte;
        if char < 'a' then
            return char;
        if char > 'z' then
            return char;
        return char and 0dfh;
    end;
end;
