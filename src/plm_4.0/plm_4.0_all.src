shared/plm.pex
@offCurCh   'oCurCh'
@offLastCh  'oLstCh'

/* isis command codes */
IOPEN	'0'
ICLOSE	'1'
IDELETE	'2'
IREAD	'3'
IWRITE	'4'
ISEEK	'5'
ILOAD	'6'
IRENAME	'7'
ICONSOL	'8'
IEXIT	'9'
IATTRIB	'10'
IRESCAN	'11'
IERROR	'12'
IWHOCON	'13'
ISPATH	'14'

LIT             'literally'
POINTER         'ADDRESS'
WORD            'ADDRESS'
bool            'byte'
local           ' '
TRUE            '0FFH'
FALSE           '0'
FILE$NAME$LEN   '15'

TAB             '9'
CR              '0DH'
LF              '0AH'
QUOTE           '27H'
ISISEOF         '81H'

/* flags */
F$PUBLIC	'0'
F$EXTERNAL	'1'
F$BASED	'2'
F$INITIAL	'3'
F$REENTRANT	'4'
F$DATA	'5'
F$INTERRUPT	'6'
F$AT	'7'
F$ARRAY	'8'
F$STARDIM	'9'
F$PARAMETER	'10'
F$MEMBER	'11'
F$LABEL	'12'
F$AUTOMATIC	'13'
F$PACKED	'14'
F$ABSOLUTE	'15'
F$MEMORY	'16'
F$DECLARED	'17'
F$DEFINED	'18'
F$MODGOTO	'19'

/* token info types */
LIT$T	'0'
LABEL$T	'1'
BYTE$T	'2'
ADDRESS$T	'3'
STRUCT$T	'4'
PROC$T	'5'
BUILTIN$T	'6'
MACRO$T	'7'
UNK$T	'8'
TEMP$T	'9'

/* Lex tokens */
L$LINEINFO	'0'
L$SYNTAXERROR	'1'
L$TOKENERROR	'2'
L$LIST	'3'
L$NOLIST	'4'
L$CODE	'5'
L$NOCODE	'6'
L$EJECT	'7'
L$INCLUDE	'8'
L$STMTCNT	'9'
L$LABELDEF	'10'
L$LOCALLABEL	'11'
L$JMP	'12'
L$JMPFALSE	'13'
L$PROCEDURE	'14'
L$SCOPE	'15'
L$END	'16'
L$DO	'17'
L$DOLOOP	'18'
L$WHILE	'19'
L$CASE	'20'
L$CASELABEL	'21'
L$IF	'22'
L$STATEMENT	'23'
L$CALL	'24'
L$RETURN	'25'
L$GO	'26'
L$GOTO	'27'
L$SEMICOLON	'28'
L$ENABLE	'29'
L$DISABLE	'30'
L$HALT	'31'
L$EOF	'32'
L$AT	'33'
L$INITIAL	'34'
L$DATA	'35'
L$VARIABLE	'36'
L$NUMBER	'37'
L$STRING	'38'
L$PLUSSIGN	'39'
L$MINUSSIGN	'40'
L$PLUS	'41'
L$MINUS	'42'
L$STAR	'43'
L$SLASH	'44'
L$MOD	'45'
L$COLONEQUALS	'46'
L$AND	'47'
L$OR	'48'
L$XOR	'49'
L$NOT	'50'
L$LT	'51'	
L$LE	'52'
L$EQ	'53'
L$NE	'54'
L$GE	'55'
L$GT	'56'
L$COMMA	'57'
L$LPAREN	'58'
L$RPAREN	'59'
L$PERIOD	'60'
L$TO	'61'
L$BY	'62'
L$INVALID	'63'
L$MODULE	'64'
L$XREFINFO	'65'
L$XREF	'66'
L$EXTERNAL	'67'
L$ERROR	'68'

/* character classes */
CC$BINDIGIT	'0'
CC$OCTDIGIT	'1'
CC$DECDIGIT	'2'
CC$HEXCHAR	'3'
CC$ALPHA	'4'
CC$PLUS		'5'
CC$MINUS	'6'
CC$STAR		'7'
CC$SLASH	'8'
CC$LPAREN	'9'
CC$RPAREN	'10'
CC$COMMA	'11'
CC$COLON	'12'
CC$SEMICOLON	'13'
CC$QUOTE	'14'
CC$PERIOD	'15'
CC$EQUALS	'16'
CC$LESS		'17'
CC$GREATER	'18'
CC$WSPACE	'19'
CC$DOLLAR	'20'
CC$INVALID	'21'
CC$NONPRINT	'22'
CC$NEWLINE	'23'

/* intermediate tokens */
T$VARIABLE	'0'
T$NUMBER	'1'
T$STRING	'2'
T$PLUSSIGN	'3'
T$MINUSSIGN	'4'
T$STAR	'5'
T$SLASH	'6'
T$MOD	'7'
T$PLUS	'8'
T$MINUS	'9'
T$AND	'10'
T$OR	'11'
T$XOR	'12'
T$NOT	'13'
T$LT	'15'
T$LE	'16'
T$EQ	'17'
T$NE	'18'
T$GE	'19'
T$GT	'20'
T$COLON$EQUALS	'21'
T$COLON	'22'
T$SEMICOLON	'23'
T$PERIOD	'24'
T$LPAREN	'25'
T$RPAREN	'26'
T$COMMA	'27'
T$CALL	'28'
T$DECLARE	'29'
T$DISABLE	'30'
T$DO	'31'
T$ENABLE	'32'
T$END	'33'
T$GO	'34'
T$GOTO	'35'
T$HALT	'36'
T$IF	'37'
T$PROCEDURE	'38'
T$RETURN	'39'
T$ADDRESS	'40'
T$AT	'41'
T$BASED	'42'
T$BYTE	'43'
T$DATA	'44'
T$EXTERNAL	'45'
T$INITIAL	'46'
T$INTERRUPT	'47'
T$LABEL	'48'
T$LITERALLY	'49'
T$PUBLIC	'50'
T$REENTRANT	'51'
T$STRUCTURE	'52'
T$BY	'53'
T$CASE	'54'
T$ELSE	'55'
T$EOF	'56'
T$THEN	'57'
T$TO	'58'
T$WHILE	'59'

/* T2 codes */
T2$LT	'0'
T2$LE	'1'
T2$NE	'2'
T2$EQ	'3'
T2$GE	'4'
T2$GT	'5'
T2$ROL	'6'
T2$ROR	'7'
T2$SCL	'8'
T2$SCR	'9'
T2$SHL	'10'
T2$SHR	'11'
T2$JMPFALSE	'12'
/*	T2$13 LIT '13', */
/*	T2$14 LIT '14', */
/*	T2$15 LIT '15', */
/*	T2$16 LIT '16', */
/*	T2$17 LIT '17', */
T2$DOUBLE	'18'
T2$ADDB	'19'
T2$MINUSSIGN	'20'
T2$STAR	'21'
T2$SLASH	'22'
T2$MOD	'23'
T2$AND	'24'
T2$OR	'25'
T2$XOR	'26'
T2$BASED	'27'
T2$BYTEINDEX	'28'
T2$WORDINDEX	'29'
T2$MEMBER	'30'
T2$UNARYMINUS	'31'
T2$NOT	'32'
T2$LOW	'33'
T2$HIGH	'34'
T2$ADDRESSOF	'35'
T2$PLUS	'36'
T2$MINUS	'37'
/*	T2$38 LIT '38', */
/*	T2$39 LIT '39', */
/*	T2$40 LIT '40', */
/*	T2$41 LIT '41', */
/*	T2$42 LIT '42', */
/*	T2$43 LIT '43', */
T2$44	'44'
/*	T2$45 LIT '45', */
/*	T2$46 LIT '46', */
/*	T2$47 LIT '47', */
/*	T2$48 LIT '48', */
/*	T2$49 LIT '49', */
/*	T2$50 LIT '50', */
T2$51	'51'
/*	T2$52 LIT '52', */
/*	T2$53 LIT '53', */
/*	T2$54 LIT '54', */
/*	T2$55 LIT '55', */
T2$56	'56'
T2$TIME	'57'
T2$STKBARG	'58'
T2$STKWARG	'59'
T2$DEC	'60'
T2$STORE	'61'
T2$OUTPUT	'62'
T2$63	'63'
T2$STKARG	'64'
T2$65	'65'
/*	T2$66 LIT '66', */
/*	T2$67 LIT '67', */
/*	T2$68 LIT '68', */
T2$MOVE	'69'
/*	T2$70 LIT '70', */
T2$RETURNBYTE	'71'
T2$RETURNWORD	'72'
T2$RETURN	'73'
/*	T2$74 LIT '74', */
/*	T2$75 LIT '75', */
/*	T2$76 LIT '76', */
/*	T2$77 LIT '77', */
/*	T2$78 LIT '78', */
/*	T2$79 LIT '79', */
/*	T2$80 LIT '80', */
/*	T2$81 LIT '81', */
/*	T2$82 LIT '82', */
/*	T2$83 LIT '83', */
/*	T2$84 LIT '84', */
/*	T2$85 LIT '85', */
/*	T2$86 LIT '86', */
/*	T2$87 LIT '87', */
/*	T2$88 LIT '88', */
/*	T2$89 LIT '89', */
/*	T2$90 LIT '90', */
/*	T2$91 LIT '91', */
/*	T2$92 LIT '92', */
/*	T2$93 LIT '93', */
/*	T2$94 LIT '94', */
/*	T2$95 LIT '95', */
/*	T2$96 LIT '96', */
/*	T2$97 LIT '97', */
/*	T2$98 LIT '98', */
/*	T2$99 LIT '99', */
/*	T2$100 LIT '100', */
/*	T2$101 LIT '101', */
/*	T2$102 LIT '102', */
/*	T2$103 LIT '103', */
/*	T2$104 LIT '104', */
/*	T2$105 LIT '105', */
/*	T2$106 LIT '106', */
/*	T2$107 LIT '107', */
/*	T2$108 LIT '108', */
/*	T2$109 LIT '109', */
/*	T2$110 LIT '110', */
/*	T2$111 LIT '111', */
/*	T2$112 LIT '112', */
/*	T2$113 LIT '113', */
/*	T2$114 LIT '114', */
/*	T2$115 LIT '115', */
/*	T2$116 LIT '116', */
/*	T2$117 LIT '117', */
/*	T2$118 LIT '118', */
/*	T2$119 LIT '119', */
/*	T2$120 LIT '120', */
/*	T2$121 LIT '121', */
/*	T2$122 LIT '122', */
/*	T2$123 LIT '123', */
/*	T2$124 LIT '124', */
/*	T2$125 LIT '125', */
/*	T2$126 LIT '126', */
/*	T2$127 LIT '127', */
/*	T2$128 LIT '128', */
/*	T2$129 LIT '129', */
T2$ADDW	'130'
T2$BEGMOVE	'131'
T2$CALL	'132'
T2$CALLVAR	'133'
/*	T2$134 LIT '134', */
T2$PROCEDURE	'135'
T2$LOCALLABEL	'136'
T2$CASELABEL	'137'
T2$LABELDEF	'138'
T2$INPUT	'139'
T2$GO$TO	'140'
T2$JMP	'141'
T2$JNC	'142'
T2$JNZ	'143'
T2$SIGN	'144'
T2$ZERO	'145'
T2$PARITY	'146'
T2$CARRY	'147'
T2$DISABLE	'148'
T2$ENABLE	'149'
T2$HALT	'150'
T2$STMTCNT	'151'
T2$LINEINFO	'152'
T2$MODULE	'153'
T2$SyntaxERROR	'154'
T2$TokenERROR	'155'
T2$EOF	'156'
T2$LIST	'157'
T2$NOLIST	'158'
T2$CODE	'159'
T2$NOCODE	'160'
T2$EJECT	'161'
T2$INCLUDE	'162'
T2$ERROR	'163'
/*	T2$164 LIT '164', */
/*	T2$165 LIT '165', */
/*	T2$166 LIT '166', */
/*	T2$167 LIT '167', */
/*	T2$168 LIT '168', */
/*	T2$169 LIT '169', */
/*	T2$170 LIT '170', */
/*	T2$171 LIT '171', */
T2$VARIABLE	'172'
T2$NUMBER	'173'
T2$BIGNUMBER	'174'
/*	T2$175 LIT '175', */
/*	T2$176 LIT '176', */
/*	T2$177 LIT '177', */
/*	T2$178 LIT '178', */
/*	T2$179 LIT '179', */
/*	T2$180 LIT '180', */
T2$STACKPTR	'181'
T2$SEMICOLON	'182'
T2$OPTBACKREF	'183'
T2$CASE	'184'
T2$ENDCASE	'185'
T2$ENDPROC	'186'
T2$LENGTH	'187'
T2$LAST	'188'
T2$SIZE	'189'
T2$BEGCALL	'190'
/*	T2$191 LIT '191', */
/*	T2$192 LIT '192', */
/*	T2$193 LIT '193', */
/*	T2$194 LIT '194', */
/*	T2$195 LIT '195', */
/*	T2$196 LIT '196', */
/*	T2$197 LIT '197', */
/*	T2$198 LIT '198', */
/*	T2$199 LIT '199', */
/*	T2$200 LIT '200', */
/*	T2$201 LIT '201', */
/*	T2$202 LIT '202', */
/*	T2$203 LIT '203', */
/*	T2$204 LIT '204', */
/*	T2$205 LIT '205', */
/*	T2$206 LIT '206', */
/*	T2$207 LIT '207', */
/*	T2$208 LIT '208', */
/*	T2$209 LIT '209', */
/*	T2$210 LIT '210', */
/*	T2$211 LIT '211', */
/*	T2$212 LIT '212', */
/*	T2$213 LIT '213', */
/*	T2$214 LIT '214', */
/*	T2$215 LIT '215', */
/*	T2$216 LIT '216', */
/*	T2$217 LIT '217', */
/*	T2$218 LIT '218', */
/*	T2$219 LIT '219', */
/*	T2$220 LIT '220', */
/*	T2$221 LIT '221', */
/*	T2$222 LIT '222', */
/*	T2$223 LIT '223', */
/*	T2$224 LIT '224', */
/*	T2$225 LIT '225', */
/*	T2$226 LIT '226', */
/*	T2$227 LIT '227', */
/*	T2$228 LIT '228', */
/*	T2$229 LIT '229', */
/*	T2$230 LIT '230', */
/*	T2$231 LIT '231', */
/*	T2$232 LIT '232', */
/*	T2$233 LIT '233', */
/*	T2$234 LIT '234', */
/*	T2$235 LIT '235', */
/*	T2$236 LIT '236', */
/*	T2$237 LIT '237', */
/*	T2$238 LIT '238', */
/*	T2$239 LIT '239', */
/*	T2$240 LIT '240', */
/*	T2$241 LIT '241', */
/*	T2$242 LIT '242', */
/*	T2$243 LIT '243', */
/*	T2$244 LIT '244', */
/*	T2$245 LIT '245', */
/*	T2$246 LIT '246', */
/*	T2$247 LIT '247', */
/*	T2$248 LIT '248', */
/*	T2$249 LIT '249', */
/*	T2$250 LIT '250', */
/*	T2$251 LIT '251', */
/*	T2$252 LIT '252', */
/*	T2$253 LIT '253', */
T2$254	'254'

/* ICodes */
I$STRING	'0'
I$VARIABLE	'1'
I$NUMBER	'2'
I$PLUSSIGN	'3'
I$MINUSSIGN	'4'
I$PLUS	'5'
I$MINUS	'6'
I$STAR	'7'
I$SLASH	'8'
I$MOD	'9'
I$AND	'10'
I$OR	'11'
I$XOR	'12'
I$NOT	'13'
I$LT	'14'
I$LE	'15'
I$EQ	'16'
I$NE	'17'
I$GE	'18'
I$GT	'19'
I$ADDRESSOF	'20'
I$UNARYMINUS	'21'
I$STACKPTR	'22'
I$INPUT	'23'
I$OUTPUT	'24'
I$CALL	'25'
I$CALLVAR	'26'
I$BYTEINDEX	'27'
I$WORDINDEX	'28'
I$COLONEQUALS	'29'
I$MEMBER	'30'
I$BASED	'31'
I$CARRY	'32'
I$DEC	'33'
I$DOUBLE	'34'
I$HIGH	'35'
I$LAST	'36'
I$LENGTH	'37'
I$LOW	'38'
I$MOVE	'39'
I$PARITY	'40'
I$ROL	'41'
I$ROR	'42'
I$SCL	'43'
I$SCR	'44'
I$SHL	'45'
I$SHR	'46'
I$SIGN	'47'
I$SIZE	'48'
I$TIME	'49'
I$ZERO	'50'

/* AT Icodes */
ATI$AHDR	'0'
ATI$DHDR	'1'
ATI$2	'2'
ATI$STRING	'3'
ATI$DATA	'4'
ATI$END	'5'
ATI$EOF	'6'

/* CF codes */
CF$3	'3'
CF$POP	'4'
CF$XTHL	'5'
CF$6	'6'
CF$7	'7'
CF$XCHG	'14'
CF$MOVRPM	'16'
CF$MOVLRM	'18'
CF$MOVMRPR	'19'
CF$MOVMLR	'20'
CF$DW	'21'
CF$SPHL	'22'
CF$PUSH	'23'
CF$INX	'24'
CF$DCX	'25'
CF$DCXH	'26'
CF$RET	'27'
CF$SHLD	'59'
CF$STA	'60'
CF$MOVMRP	'62'
CF$67	'67'
CF$68	'68'
CF$DELAY	'97'
CF$MOVE$HL	'103'
CF$MOVLRHR	'110'
CF$MOVHRLR	'113'
CF$MOVHRM	'114'
CF$MOVMHR	'115'
CF$INXSP	'116'
CF$DCXSP	'117'
CF$JMPTRUE	'118'
CF$134	'134'
CF$EI	'149'
CF$171	'171'
CF$174	'174'



/* Error codes */
ERR1	'1' /* INVALID PL/M-80 CHARACTER */
ERR2	'2' /* UNPRINTABLE ASCII CHARACTER */
ERR3	'3' /* IDENTIFIER, STRING, OR NUMBER TOO LONG, TRUNCATED */
ERR4	'4' /* ILLEGAL NUMERIC CONSTANT TYPE */
ERR5	'5' /* INVALID CHARACTER IN NUMERIC CONSTANT */
ERR6	'6' /* ILLEGAL MACRO REFERENCE, RECURSIVE EXPANSION */
ERR7	'7' /* LIMIT EXCEEDED: MACROS NESTED TOO DEEPLY */
ERR8	'8' /* INVALID CONTROL FORMAT */
ERR9	'9' /* INVALID CONTROL */
ERR10	'10' /* ILLEGAL USE OF PRIMARY CONTROL AFTER NON-CONTROL LINE */
ERR11	'11' /* MISSING CONTROL PARAMETER */
ERR12	'12' /* INVALID CONTROL PARAMETER */
ERR13	'13' /* LIMIT EXCEEDED: INCLUDE NESTING */
ERR14	'14' /* INVALID CONTROL FORMAT, INCLUDE NOT LAST CONTROL */
ERR15	'15' /* MISSING INCLUDE CONTROL PARAMETER */
ERR16	'16' /* ILLEGAL PRINT CONTROL */
ERR17	'17' /* INVALID PATH-NAME */
ERR18	'18' /* INVALID MULTIPLE LABELS AS MODULE NAMES */
ERR19	'19' /* INVALID LABEL IN MODULE WITHOUT MAIN PROGRAM */
ERR20	'20' /* MISMATCHED IDENTIFIER AT END OF BLOCK */
ERR21	'21' /* MISSING PROCEDURE NAME */
ERR22	'22' /* INVALID MULTIPLE LABELS AS PROCEDURE NAMES */
ERR23	'23' /* INVALID LABELLED END IN EXTERNAL PROCEDURE */
ERR24	'24' /* INVALID STATEMENT IN EXTERNAL PROCEDURE */
ERR25	'25' /* UNDECLARED PARAMETER */
ERR26	'26' /* INVALID DECLARATION, STATEMENT OUT OF PLACE */
ERR27	'27' /* LIMIT EXCEEDED: NUMBER OF DO BLOCKS */
ERR28	'28' /* MISSING 'THEN' */
ERR29	'29' /* ILLEGAL STATEMENT */
ERR30	'30' /* LIMIT EXCEEDED: NUMBER OF LABELS ON STATEMENT */
ERR31	'31' /* LIMIT EXCEEDED: PROGRAM TOO COMPLEX */
ERR32	'32' /* INVALID SYNTAX, TEXT IGNORED UNTIL ';' */
ERR33	'33' /* DUPLICATE LABEL DECLARATION */
ERR34	'34' /* DUPLICATE PROCEDURE DECLARATION */
ERR35	'35' /* LIMIT EXCEEDED: NUMBER OF PROCEDURES */
ERR36	'36' /* MISSING PARAMETER */
ERR37	'37' /* MISSING ') ' AT END OF PARAMETER LIST */
ERR38	'38' /* DUPLICATE PARAMETER NAME */
ERR39	'39' /* INVALID ATTRIBUTE OR INITIALIZATION, NOT AT MODULE LEVEL */
ERR40	'40' /* DUPLICATE ATTRIBUTE */
ERR41	'41' /* CONFLICTING ATTRIBUTE */
ERR42	'42' /* INVALID INTERRUPT VALUE */
ERR43	'43' /* MISSING INTERRUPT VALUE */
ERR44	'44' /* ILLEGAL ATTRIBUTE, 'INTERRUPT' WITH PARAMETERS */
ERR45	'45' /* ILLEGAL ATTRIBUTE, 'INTERRUPT' WITH TYPED PROCEDURE */
ERR46	'46' /* ILLEGAL USE OF LABEL */
ERR47	'47' /* MISSING ') ' AT END OF FACTORED DECLARATION */
ERR48	'48' /* ILLEGAL DECLARATION STATEMENT SYNTAX */
ERR49	'49' /* LIMIT EXCEEDED: NUMBER OF ITEMS IN FACTORED DECLARE */
ERR50	'50' /* INVALID ATTRIBUTES FOR BASE */
ERR51	'51' /* INVALID BASE, SUBSCRIPTING ILLEGAL */
ERR52	'52' /* INVALID BASE, MEMBER OF BASED STRUCTURE OR ARRAY OF STRUCTURES */
ERR53	'53' /* INVALID STRUCTURE MEMBER IN BASE */
ERR54	'54' /* UNDECLARED BASE */
ERR55	'55' /* UNDECLARED STRUCTURE MEMBER IN BASE */
ERR56	'56' /* INVALID MACRO TEXT, NOT A STRING CONSTANT */
ERR57	'57' /* INVALID DIMENSION, ZERO ILLEGAL */
ERR58	'58' /* INVALID STAR DIMENSION IN FACTORED DECLARATION */
ERR59	'59' /* ILLEGAL DIMENSION ATTRIBUTE */
ERR60	'60' /* MISSING ') ' AT END OF DIMENSION */
ERR61	'61' /* MISSING TYPE */
ERR62	'62' /* INVALID STAR DIMENSION WITH 'STRUCTURE' OR 'EXTERNAL' */
ERR63	'63' /* INVALID DIMENSION WITH THIS ATTRIBUTE */
ERR64	'64' /* MISSING STRUCTURE MEMBERS */
ERR65	'65' /* MISSING ') ' AT END OF STRUCTURE MEMBER LIST */
ERR66	'66' /* INVALID STRUCTURE MEMBER, NOT AN IDENTIFIER */
ERR67	'67' /* DUPLICATE STRUCTURE MEMBER NAME */
ERR68	'68' /* LIMIT EXCEEDED: NUMBER OF STRUCTURE MEMBERS */
ERR69	'69' /* INVALID STAR DIMENSION WITH STRUCTURE MEMBER */
ERR70	'70' /* INVALID MEMBER TYPE, 'STRUCTURE' ILLEGAL */
ERR71	'71' /* INVALID MEMBER TYPE, 'LABEL' ILLEGAL */
ERR72	'72' /* MISSING TYPE FOR STRUCTURE MEMBER */
ERR73	'73' /* INVALID ATTRIBUTE OR INITIALIZATION, NOT AT MODULE LEVEL */
ERR74	'74' /* INVALID STAR DIMENSION, NOT WITH 'DATA' OR 'INITIAL' */
ERR75	'75' /* MISSING ARGUMENT OF 'AT' , 'DATA' , OR 'INITIAL' */
ERR76	'76' /* CONFLICTING ATTRIBUTE WITH PARAMETER */
ERR77	'77' /* INVALID PARAMETER DECLARATION, BASE ILLEGAL */
ERR78	'78' /* DUPLICATE DECLARATION */
ERR79	'79' /* ILLEGAL PARAMETER TYPE, NOT BYTE OR ADDRESS */
ERR80	'80' /* INVALID DECLARATION, LABEL MAY NOT BE BASED */
ERR81	'81' /* CONFLICTING ATTRIBUTE WITH 'BASE' */
ERR82	'82' /* INVALID SYNTAX, MISMATCHED '(' */
ERR83	'83' /* LIMIT EXCEEDED: DYNAMIC STORAGE */
ERR84	'84' /* LIMIT EXCEEDED: BLOCK NESTING */
ERR85	'85' /* LONG STRING ASSUMED CLOSED AT NEXT SEMICOLON OR QUOTE */
ERR86	'86' /* LIMIT EXCEEDED: SOURCE LINE LENGTH */
ERR87	'87' /* MISSING 'END' , END-OF-FILE ENCOUNTERED */
ERR88	'88' /* INVALID PROCEDURE NESTING, ILLEGAL IN REENTRANT PROCEDURE */
ERR89	'89' /* MISSING 'DO' FOR MODULE */
ERR90	'90' /* MISSING NAME FOR MODULE */
ERR91	'91' /* ILLEGAL PAGELENGTH CONTROL VALUE */
ERR92	'92' /* ILLEGAL PAGEWIDTH CONTROL VALUE */
ERR93	'93' /* MISSING 'DO' FOR 'END' , 'END' IGNORED */
ERR94	'94' /* ILLEGAL CONSTANT, VALUE > 65535 */
ERR95	'95' /* ILLEGAL RESPECIFICATION OF PRIMARY CONTROL IGNORED */
ERR96	'96' /* COMPILER ERROR: SCOPE STACK UNDERFLOW */
ERR97	'97' /* COMPILER ERROR: PARSE STACK UNDERFLOW */
ERR98	'98' /* INCLUDE FILE IS NOT A DISKETTE FILE */
ERR99	'99' /* ?? unused */
ERR100	'100' /* INVALID STRING CONSTANT IN EXPRESSION */
ERR101	'101' /* INVALID ITEM FOLLOWS DOT OPERATOR */
ERR102	'102' /* MISSING PRIMARY OPERAND */
ERR103	'103' /* MISSING ') ' AT END OF SUBEXPRESSION */
ERR104	'104' /* ILLEGAL PROCEDURE INVOCATION WITH DOT OPERATOR */
ERR105	'105' /* UNDECLARED IDENTIFIER */
ERR106	'106' /* INVALID INPUT/OUTPUT PORT NUMBER */
ERR107	'107' /* ILLEGAL INPUT/OUTPUT PORT NUMBER, NOT NUMERIC CONSTANT */
ERR108	'108' /* MISSING ') ' AFTER INPUT/OUTPUT PORT NUMBER */
ERR109	'109' /* MISSING INPUT/OUTPUT PORT NUMBER */
ERR110	'110' /* INVALID LEFT OPERAND OF QUALIFICATION, NOT A STRUCTURE */
ERR111	'111' /* INVALID RIGHT OPERAND OF QUALIFICATION, NOT IDENTIFIER */
ERR112	'112' /* UNDECLARED STRUCTURE MEMBER */
ERR113	'113' /* MISSING ') ' AT END OF ARGUMENT LIST */
ERR114	'114' /* INVALID SUBSCRIPT, MULTIPLE SUBSCRIPTS ILLEGAL */
ERR115	'115' /* MISSING ') ' AT END OF SUBSCRIPT */
ERR116	'116' /* MISSING '=' IN ASSIGNMENT STATEMENT */
ERR117	'117' /* MISSING PROCEDURE NAME IN CALL STATEMENT */
ERR118	'118' /* INVALID INDIRECT CALL, IDENTIFIER NOT AN ADDRESS SCALAR */
ERR119	'119' /* LIMIT EXCEEDED: PROGRAM TOO COMPLEX */
ERR120	'120' /* LIMIT EXCEEDED: EXPRESSION TOO COMPLEX */
ERR121	'121' /* LIMIT EXCEEDED: EXPRESSION TOO COMPLEX */
ERR122	'122' /* LIMIT EXCEEDED: PROGRAM TOO COMPLEX */
ERR123	'123' /* INVALID DOT OPERAND, BUILT-IN PROCEDURE ILLEGAL */
ERR124	'124' /* MISSING ARGUMENTS FOR BUILT-IN PROCEDURE */
ERR125	'125' /* ILLEGAL ARGUMENT FOR BUILT-IN PROCEDURE */
ERR126	'126' /* MISSING ') ' AFTER BUILT-IN PROCEDURE ARGUMENT LIST */
ERR127	'127' /* INVALID SUBSCRIPT ON NON-ARRAY */
ERR128	'128' /* INVALID LEFT-HAND OPERAND OF ASSIGNMENT */
ERR129	'129' /* ILLEGAL 'CALL' WITH TYPED PROCEDURE */
ERR130	'130' /* ILLEGAL REFERENCE TO OUTPUT FUNCTION */
ERR131	'131' /* ILLEGAL REFERENCE TO UNTYPED PROCEDURE */
ERR132	'132' /* ILLEGAL USE OF LABEL */
ERR133	'133' /* ILLEGAL REFERENCE TO UNSUBSCRIPTED ARRAY */
ERR134	'134' /* ILLEGAL REFERENCE TO UNSUBSCRIPTED MEMBER ARRAY */
ERR135	'135' /* ILLEGAL REFERENCE TO AN UNQUALIFIED STRUCTURE */
ERR136	'136' /* INVALID RETURN FOR UNTYPED PROCEDURE, VALUE ILLEGAL */
ERR137	'137' /* MISSING VALUE IN RETURN FOR TYPED PROCEDURE */
ERR138	'138' /* MISSING INDEX VARIABLE */
ERR139	'139' /* INVALID INDEX VARIABLE TYPE, NOT BYTE OR ADDRESS */
ERR140	'140' /* MISSING '=' FOLLOWING INDEX VARIABLE */
ERR141	'141' /* MISSING 'TO' CLAUSE */
ERR142	'142' /* MISSING IDENTIFIER FOLLOWING GOTO */
ERR143	'143' /* INVALID REFERENCE FOLLOWING GOTO, NOT A LABEL */
ERR144	'144' /* INVALID GOTO LABEL, NOT AT LOCAL OR MODULE LEVEL */
ERR145	'145' /* MISSING 'TO' FOLLOWING 'GO' */
ERR146	'146' /* MISSING ') ' AFTER 'AT' RESTRICTED EXPRESSION */
ERR147	'147' /* MISSING IDENTIFIER FOLLOWING DOT OPERATOR */
ERR148	'148' /* INVALID QUALIFICATION IN RESTRICTED REFERENCE */
ERR149	'149' /* INVALID SUBSCRIPTING IN RESTRICTED REFERENCE */
ERR150	'150' /* MISSING ') ' AT END OF RESTRICTED SUBSCRIPT */
ERR151	'151' /* INVALID OPERAND IN RESTRICTED EXPRESSION */
ERR152	'152' /* MISSING ') ' AFTER CONSTANT LIST */
ERR153	'153' /* INVALID NUMBER OF ARGUMENTS IN CALL, TOO MANY */
ERR154	'154' /* INVALID NUMBER OF ARGUMENTS IN CALL, TOO FEW */
ERR155	'155' /* INVALID RETURN IN MAIN PROGRAM */
ERR156	'156' /* MISSING RETURN STATEMENT IN TYPED PROCEDURE */
ERR157	'157' /* INVALID ARGUMENT, ARRAY REQUIRED FOR LENGTH OR LAST */
ERR158	'158' /* INVALID DOT OPERAND, LABEL ILLEGAL */
ERR159	'159' /* COMPILER ERROR: PARSE STACK UNDERFLOW */
ERR160	'160' /* COMPILER ERROR: OPERAND STACK UNDERFLOW */
ERR161	'161' /* COMPILER ERROR: ILLEGAL OPERAND STACK EXCHANGE */
ERR162	'162' /* COMPILER ERROR: OPERATOR STACK UNDERFLOW */
ERR163	'163' /* COMPILER ERROR: GENERATION FAILURE */
ERR164	'164' /* COMPILER ERROR: SCOPE STACK OVERFLOW */
ERR165	'165' /* COMPILER ERROR: SCOPE STACK UNDERFLOW */
ERR166	'166' /* COMPILER ERROR: CONTROL STACK OVERFLOW */
ERR167	'167' /* COMPILER ERROR: CONTROL STACK UNDERFLOW */
ERR168	'168' /* COMPILER ERROR: BRANCH MISSING IN 'IF' STATEMENT */
ERR169	'169' /* ILLEGAL FORWARD CALL */
ERR170	'170' /* ILLEGAL RECURSIVE CALL */
ERR171	'171' /* INVALID USE OF DELIMITER OR RESERVED WORD IN EXPRESSION */
ERR172	'172' /* INVALID LABEL: UNDEFINED */
ERR173	'173' /* INVALID LEFT SIDE OF ASSIGNMENT: VARIABLE DECLARED WITH DATA ATTRIBUTE */
ERR174	'174' /* INVALID NULL PROCEDURE */
ERR175	'175' /* unused */
ERR176	'176' /* INVALID INTVECTOR INTERVAL VALUE */
ERR177	'177' /* INVALID INTVECTOR LOCATION VALUE */
ERR178	'178' /* INVALID 'AT' RESTRICTED REFERENCE, EXTERNAL ATTRIBUTE CONFLICTS WITH PUBLIC ATTRIBUTE */
ERR179	'179' /* OUTER 'IF' MAY NOT HAVE AN 'ELSE' PART */
ERR180	'180' /* MISSING OR INVALID CONDITIONAL COMPILATION PARAMETER */
ERR181	'181' /* MISSING OR INVALID CONDITIONAL COMPILATION CONSTANT */
ERR182	'182' /* MISPLACED ELSE OR ELSEIF OPTION */
ERR183	'183' /* MISPLACED ENDIF OPTION */
ERR184	'184' /* CONDITIONAL COMPILATION PARAMETER NAME TOO LONG */
ERR185	'185' /* MISSING OPERATOR IN CONDITIONAL COMPILATION EXPRESSION */
ERR186	'186' /* INVALID CONDITIONAL COMPILATION CONSTANT, TOO LARGE */
ERR187	'187' /* LIMIT EXCEEDED: NUMBER OF SAVE LEVELS > 5 */
ERR188	'188' /* MISPLACED RESTORE OPTION */
ERR189	'189' /* NULL STRING NOT ALLOWED */
ERR200	'200' /* LIMIT EXCEEDED: STATEMENT SIZE */
ERR201	'201' /* INVALID DO CASE BLOCK, AT LEAST ONE CASE REQUIRED */
ERR202	'202' /* LIMIT EXCEEDED: NUMBER OF ACTIVE CASES */
ERR203	'203' /* LIMIT EXCEEDED: NESTING OF TYPED PROCEDURE CALLS */
ERR204	'204' /* LIMIT EXCEEDED: NUMBER OF ACTIVE PROCEDURES AND DO CASE GROUPS */
ERR205	'205' /* ILLEGAL NESTING OF BLOCKS, ENDS NOT BALANCED */
ERR206	'206' /* LIMIT EXCEEDED: CODE SEGMENT SIZE */
ERR207	'207' /* LIMIT EXCEEDED: SEGMENT SIZE */
ERR208	'208' /* LIMIT EXCEEDED: STRUCTURE SIZE */
ERR209	'209' /* ILLEGAL INITIALIZATION OF MORE SPACE THAN DECLARED */
ERR210	'210' /* ILLEGAL INITIALIZATION OF A BYTE TO A VALUE > 255 */
ERR211	'211' /* INVALID IDENTIFIER IN 'AT' RESTRICTED REFERENCE */
ERR212	'212' /* INVALID RESTRICTED REFERENCE IN 'AT' , BASE ILLEGAL */
ERR213	'213' /* UNDEFINED RESTRICTED REFERENCE IN 'AT' */
ERR214	'214' /* COMPILER ERROR: OPERAND CANNOT BE TRANSFORMED */
ERR215	'215' /* COMPILER ERROR: EOF Read IN FINAL ASSEMBLY */
ERR216	'216' /* COMPILER ERROR: BAD LABEL ADDRESS */
ERR217	'217' /* ILLEGAL INITIALIZATION OF AN EXTERNAL VARIABLE */
ERR218	'218' /* ILLEGAL SUCCESSIVE USES OF RELATIONAL OPERATORS */
ERR219	'219' /* LIMIT EXCEEDED: NUMBER OF EXTERNALS > 255 */

/* standard structures */
FILE$P1         'AFTN ADDRESS, sNam(6) BYTE, fNam(16) BYTE'
FILE$P2         'BUF$P ADDRESS, BSIZE ADDRESS, ACTUAL ADDRESS, CUROFF ADDRESS'
FILE$T          'STRUCTURE(FILE$P1, FILE$P2)'
SYM$ST	'STRUCTURE(link ADDRESS, info$p ADDRESS, name(1) BYTE)'
INFO$P1	'len BYTE, type BYTE, sym ADDRESS, scope ADDRESS, ilink ADDRESS, flag(3) BYTE'
INFO$P2	'extId BYTE, dim ADDRESS, baseoff ADDRESS, parent ADDRESS'
INFO$P3	'dtype BYTE, intno BYTE, pcnt BYTE, procId BYTE'
INFO$ST	'STRUCTURE(INFO$P1, INFO$P2, INFO$P3)'
LIT$ST	'STRUCTURE(len BYTE, type BYTE, sym ADDRESS, scope ADDRESS, ilink ADDRESS, litAddr ADDRESS)'
LOC$ST	'STRUCTURE(blk ADDRESS, byt ADDRESS)'
CMD$ST	'STRUCTURE(link ADDRESS, pstr(1) BYTE)'
MAC$ST	'STRUCTURE(inChr$p ADDRESS, info$p ADDRESS)'
LINFO$ST 'STRUCTURE(type BYTE, lineCnt ADDRESS, stmtCnt ADDRESS, blkCnt ADDRESS)'
TX1ITEM$ST	'structure(type byte, dataw(129) address)'
ERR$T   'STRUCTURE(num word, info word, stmt word)'

VAL2$SIZE        '1'
VAL6$SIZE        '1'
VAL8$SIZE        '1'
VAL10$SIZE       '1'
VAL12$SIZE       '1'
VAL14$SIZE       '1'
VAL16$SIZE       '1'
VAL18$SIZE       '1'
VAL20$SIZE       '1'
VAL22$SIZE       '1'
VAL24$SIZE       '1'
VAL26$SIZE       '1'
VAL28$SIZE       '1'

REC2$ST          'structure(type byte, len address, val(VAL2$SIZE) byte)'
REC4$ST          'structure(type byte, len address, subtype byte, seg byte, addr address, crc byte)'
REC6$ST          'structure(type byte, len address, seg byte, addr address, val(VAL6$SIZE) byte)'
REC8$ST          'structure(type byte, len address, val(VAL8$SIZE) byte)'
REC12$ST         'structure(type byte, len address, val(VAL12$SIZE) byte)'
REC16$ST         'structure(type byte, len address, val(VAL16$SIZE) byte)'
REC18$ST         'structure(type byte, len address, val(VAL18$SIZE) byte)'
REC20$ST         'structure(type byte, len address, val(VAL20$SIZE) byte)'
REC22$ST         'structure(type byte, len address, val(VAL22$SIZE) byte)'
REC24$ST         'structure(type byte, len address, val(VAL24$SIZE) byte)'


/* plm main */

/* $file(main.plm) */
$file(main.plm,plm0a.plm,plm1a.plm,plm4b.plm,plm6b.plm)
FatalError      P(B err)

$file(plmA.plm)
cmdText$p       A
SignOnAndGetSourceName        P

$file(plmb.plm)
InitKeywordsAndBuiltins        P

$file(plmc.plm)
verno           BS

$file(plmd.plm)
SetMarginAndTabW P(B b1,B b2)
SetPageNo       P(A v)
SetTitle        P(A str,B len)

$file(plmd.plm,lstsp4.plm,lstsp5.plm,lstsp6.plm)
SetMarkerInfo   P(B arg1b,B arg2b,B arg3b)

$file(plmd.plm,plm0h.plm)
SetDate         P(A str,B len)
SetPageLen      P(A len)
SetPageWidth    P(A width)

$file(plmE.plm)
builtins        BS
ioBuffer        BS
keywords        BS


/* plm overlay 0 */
$file(main0.plm)
resetPt         L

$file(plm0A.plm)
cClass          BS
curBlkCnt       A
curDoBlkCnt     B
curMacroInfo$p  A
curProcData     A
curProcId       B
curStmtCnt      A
doBlkCnt        A
ifDepth         A
inbuf           BS
inChr$p         A
isNonCtrlLine   B
labelBrkSymbol  A
labelBrkToken   B
lastch          B
lblBrkTxiCode   B
lineBuf         BS
lineInfoToWrite B
macroDepth      A
macroPtrs       AS
markedSymbol$p  A
skippingCOND    B
state           B
stateIdX        A
stateStack      AS
stmtLabelCnt    A
stmtLabels      AS
stmtStartCode   B
tok2oprMap      BS
tokenStr        BS
tokenType       B
tokenVal        A
yyAgain         B
CreateTxi1File  P
PopBlock           P
PushBlock       P(A idAndLevel)
RewindTx1        P
SyntaxError     P(B err)
TokenError      P(B err,A sym$p)
TokenErrorAt    P(B err)
WrBuf           P(A buf,A len)
WrByte          P(B v)
WriteLineInfo   P
WriteTx1        P(A buf,A len)
WrInfoOffset        P(A addr)
WrOprAndValue   P
WrWord          P(A v)
WrXrefDef       P
WrXrefUse       P

$file(plm0A.plm,main1.plm)
curProcInfo$p   A
linfo           "LINFO$ST"

$file(plm0A.plm,pdata4.plm,pdata6.plm)
offCurCh          A
offLastCh          A

$file(plm0A.plm,plm3a.plm,pdata4.plm)
tx1Buf          BS

$file(plm0b.plm)
AcceptRP      P
BadCmdTail      P(B err)
DoCondCompile   P(A pch)
Do$Control      P(A pch)
NxtCh           P
SkipToRPARorEOL P
SkipWhite       P
UnknownCtrl     P

$file	(plm0c.asm)
gnxtch		P
ingetc		P
trunc		B
rSrcLn		P

$file(plm0d.plm)
GetLin          P

$file(plm0e.plm)
ParseDcl        P
ParseExpresion  P(B endTok)
ParseProcDcl    P
SetYyAgain      P
Yylex           P
YylexMatch      P(B token)"bool"
YylexNotMatch   P(B token)"bool"

$file(plm0f.plm)
curState        A
endSeen         B
Sub$6F00        P

$file(plm0g.plm)
CreateLit       P(A pstr)A

/* $file(plm0h.plm) */

/* plm overlay 1 */
$file(main1.plm)
b88B3           B
b91C0           B
cleanup         L
curStmtNum      A
markedStSP      A
regetTx1Item    B
T2CntForStmt    A
tx1Aux1         B
tx1Aux2         B
tx1Item         "TX1ITEM$ST"
tx1RdBuf        BS
tx2Buf          BS
varArrayIndex   A
varInfoOffset   A
varNestedArrayIndex A
varVal          A
xrfBuf          BS

$file(main1.plm,plm3a.plm)
atBuf           BS

$file(plm1a.plm)
b402F           BS
b40B7           BS
b413F           BS
b4172           BS
builtinsMap     BS
ex1Stack        BS
ex2Stack        BS
ex3Stack        AS
exSP            A
operatorSP      A
operatorStack   AS
parseSP         A
parseStack      AS
st1Stack        BS
st2Stack        BS
st3Stack        AS
stSP            A
MapLToT2        P
OptWrXrf        P
RdTx1Item       P
SetRegetTx1Item P
Sub$42EF        P(A arg1w)A
WrTx2Error      P(B arg1b)
WrTx2ExtError   P(B arg1b)
WrTx2File       P(A buf,B cnt)
WrTx2Item       P(B arg1b)A
WrTx2Item1Arg   P(B arg1b,A arg2w)A
WrTx2Item2Arg   P(B arg1b,A arg2w,A arg3w)A
WrTx2Item3Arg   P(B arg1b,A arg2w,A arg3w,A arg4w)A

$file(plm1b.pl3)
ExpectRparen    P(B arg1b)
GetTx1Item      P
MatchTx2AuxFlag P(B arg1b)B
MatchTx2Item    P(B arg1b)B
NotMatchTx2Item P(B arg1b)B
ResyncRparen    P
Sub$4599        P
Sub$45E0        P
Sub$4631        P
Sub$467D        P
WrAtFile        P(A buf,A cnt)
WrAtFileByte    P(B arg1b)
WrAtFileWord    P(A arg1w)

$file(plm1c.plm)
AcceptOpAndArgs P
ExprMakeNode    P(B arg1b,B arg2b)
ExprPop         P
ExprPush2       P(B arg1b,A arg2w)
GetCallArgCnt   PB
GetRestrictedExpr P
MkIndexNode     P
MoveExpr2Stmt   P
ParseDataItems  P(A arg1w)A
ParsePortNum    P(B arg1b)
PopOperatorStack P
PopParseStack   P
PushOperator    P(B arg1b)
PushParseByte   P(B arg1b)
PushParseWord   P(A arg1w)
ResetStacks     P
Sub$4CFD        P(A arg1w)
Sub$4D2C        P
Sub$4D38        P
Sub$4DCF        P(B arg1b)
Sub$50D5        P
Sub$512E        P(A arg1w)B
Sub$521B        P

$file(plm1d.plm)
ExprParse       P
ExprParse0      P
ExprParse1      P
ExprParse10     P
ExprParse11     P
ExprParse12     P
ExprParse13     P
ExprParse14     P
ExprParse15     P
ExprParse16     P
ExprParse17     P
ExprParse18     P
ExprParse19     P
ExprParse2      P
ExprParse20     P
ExprParse3      P
ExprParse4      P
ExprParse5      P
ExprParse6      P
ExprParse7      P
ExprParse8      P
ExprParse9      P

$file(plm1e.plm)
StmtParse       P(A arg1w)A
Sub$5945        PB
Sub$59D4        PB
Sub$5AD8        P
Sub$6523        P

$file(plm1f.plm)
Sub$6EE0        P

/* plm overlay 2 */
$file(main2.plm)
bC045           BS
bC04E           BS
bC0A8           BS
bC0B1           B
bC0B2           B
bC0B3           BS
bC0B5           BS
bC0B7           BS
bC0B9           BS
bC0BB           BS
bC0BD           BS
bC0BF           BS
bC0C1           BS
bC0C3           BS
bC140           BS
bC1BD           B
bC1BF           B
bC1D2           B
bC1D9           B
bC1DB           B
bC1E6           B
bC209           BS
blkCurInfo      AS
blkOverCnt      B
blkSP           B
boC057          BS
boC060          BS
boC069          BS
boC072          BS
boC07B          BS
boC1CC          B
boC1CD          B
boC1D8          B
boC20F          B
buf$C1E7        BS
cfrag1          B
curExtProcId    B
curOp           B
eofSeen         B
extProcId       BS
finalise        L
padC1D3         B
pc              A
procCallDepth   B
procChainId     B
procChainNext   BS
tx2Aux1b        BS
tx2Aux2b        BS
tx2Auxw         AS
tx2op1          AS
tx2op2          AS
tx2op3          AS
tx2opc          BS
tx2qEnd         B
tx2qp           B
wAF54           AS
wB488           AS
wB4B0           AS
wB4D8           AS
wB528           AS
wB53C           AS
wC084           AS
wC096           AS
wC1C3           A
wC1C5           A
wC1C7           A
wC1CF           A
wC1D6           A
wC1DC           AS

$file(plm2a.plm)
b3FCD           BS
b4029           BS
b4128           BS
b413B           BS
b418C           BS
b425D           BS
b4273           BS
b42F9           BS
b43F8           BS
b44F7           BS
b46EB           BS
b499B           BS
b4A21           BS
b4C15           BS
b4C2D           BS
b4C45           BS
b4CB4           BS
b4D23           BS
b4FA3           BS
b5012           BS
b5048           BS
b50AD           BS
b5112           BS
b5124           BS
b51E3           BS
b5202           BS
b5221           BS
b5286           BS
b528D           BS
b52B5           BS
b52DD           BS
unused          BS
w48DF           AS
w493D           AS
w502A           AS
EmitTopItem     P
EncodeFragData  P(B arg1b)
EnterBlk        PB
ExitBlk         PB
FillTx2Q        P
GetTx2Item      P
PutTx1Byte      P(B arg1b)
PutTx1Word      P(A arg1w)
Sub$5679        P(B arg1b)B
Sub$56A0        P(B arg1b,B arg2b)
Sub$5748        P(B arg1b)B
Sub$575E        P(A arg1w)A
Sub$5795        P(A arg1w)
Sub$58F5        P(B arg1b)
Sub$597E        P
Sub$5B96        P(B arg1b,B arg2b)
Sub$5C1D        P(B arg1b)
Sub$5C97        P(B arg1b)
Sub$5D27        P(B arg1b)
Sub$5D6B        P(B arg1b)
Sub$5E66        P(B arg1b)
Sub$5EE8        P
Sub$5F4B        P(A arg1w,A arg2w,B arg3b,B arg4b)
Sub$5FBF        P(B arg1b,A arg2w$p,A arg3w$p)
Sub$611A        P
Sub$61A9        P(B arg1b)
Sub$61E0        P(B arg1b)
Sub$636A        P(B arg1b)
Sub$63AC        P(B arg1b)
Sub$6416        P(B arg1b)
Sub$652B        P
Sub$67A9        P
Tx2SyntaxError  P(B arg1b)
WrFragData      P

$file(plm2b.pl3)
Sub$689E        P

$file(plm2c.plm)
Sub$6BD6        P

$file(plm2d.plm)
Sub$717B        P
Sub$7550        P

$file(plm2e.plm)
Sub$7A85        P
Sub$7DA9        P
Sub$84ED        P

$file(plm2f.plm)
Sub$87CB        P
Sub$9457        P

$file(plm2g.pl3)
FindParamInfo   P(B arg1b)
Inxh            P
MovDem          P
OpB             P(B arg1b)
OpD             P(B arg1b)
Sub$9514        P
Sub$9560        P
Sub$9624        P(A arg1w)
Sub$9646        P(A arg1w)
Sub$9706        P
Sub$975F        P
Sub$978E        P
Sub$981C        P
Sub$994D        P

$file(plm2h.plm)
Sub$9BB0        P
Sub$9D06        P
Sub$9DD7        P
Sub$9EF8        P
Sub$9F14        P
Sub$9F2F        P
Sub$9F9F        P
Sub$A072        P(B arg1b)
Sub$A0C4        P
Sub$A10A        P
Sub$A153        P

/* plm overlay 3 */
/* $file(main3.plm) no externals */

$file(plm3a.plm)
b42A8           BS
b42D6           BS
b4813           BS
b7199           B
nmsBuf          BS
rec12           "REC12$ST"
rec16$1         "REC16$ST"
rec16$2         "REC16$ST"
rec16$3         "REC16$ST"
rec16$4         "REC16$ST"
rec18           "REC18$ST"
rec2            "REC2$ST"
rec6            "REC6$ST"
w7197           A
Sub$4889        P
Sub$48BA        P(A arg1w,B arg2b,B arg3b,A arg4b$p)
Sub$4908        P(A arg1w$p,A arg2w,B arg3b)
Sub$4938        PA
Sub$4984        PA
Sub$49BC        P(A arg1w,A arg2w,A arg3w)
Sub$49F9        P

$file(plm3a.plm,pdata4.plm)
objBuf          BS
rec20           "REC20$ST"
rec22           "REC22$ST"
rec24$1         "REC24$ST"
rec24$2         "REC24$ST"
rec24$3         "REC24$ST"

$file(plm3b.plm,wrec.plm)
RecAddByte      P(A rec$p,B arg2b,B arg3b)
RecAddWord      P(A arg1w,B arg2b,A arg3w)
WriteRec        P(A rec$p,B arg2b)

/* $file(lstsp4.plm) */
$file(lstsp4.plm,lstsp6.plm)
SetStartAndTabW P(B arg1b,B arg2b)

$file(lstsp4.plm,lstsp5.plm,lstsp6.plm)
FlushLstBuf     P
NewLineLst      P
NewPageNextChLst P
SetSkipLst      P(B arg1b)
TabLst          P(B arg1b)
XnumLst         P(A num,B width,B radix)
Xputstr2cLst    P(A str,B endch)
XwrnstrLst      P(A str,B cnt)

/* plm overlay 4 */
/* $file(main4.plm) */
$file(main4.plm,main6.plm)
errCont         L

/* $file(page.plm) */
$file(page.plm,page1.plm)
NewPgl          P

$file(page.plm,page2.plm)
NlLead          P

$file(pdata4.plm)
b9692           B
b969C           B
b969D           B
b96B0           B
b96B1           BS
b96D6           B
baseAddr        A
bo812B          B
cfCode          B
commentStr      BS
curExtId        B
dstRec          B
endHelperId     B
helperId        B
helperModId     B
helperStr       BS
line            BS
lineLen         B
locLabStr       BS
lstLine         BS
opByteCnt       B
opBytes         BS
rec4            "REC4$ST"
rec6$4          "REC6$ST"
rec8            "REC8$ST"
stmtNo          A
sValAry         AS
w812F           A
w969E           A
w96D7           A
wValAry         AS

$file(pdata4.plm,main5.plm,pdata6.plm)
lstBuf          BS

$file(pdata4.plm,pdata6.plm)
errData         "ERR$T"
codeOn          B
lineNo          A
listing         B
listOff         B
lstLineLen      B
srcbuf          BS
linePrefixChecked          "bool"
linePrefixListed          "bool"
depth           A

$file(plm4a.plm)
b4304           BS
b4602           BS
b473D           BS
b475E           BS
b4774           BS
b478A           BS
b47A0           BS
b4A03           BS
b4A78           BS
opcodes         BS
regIdx          BS
regNo           BS
stack$origin    BS
stkRegIdx       BS
stkRegNo        BS
w47C1           AS
w4919           AS
w506F           AS
Sub$54BA        P

$file(plm4b.plm)
AddWrdDisp      P(A str$p,A arg2w)
EmitLabel       P
EmitStatementNo P
FlushRecs       P
ListCodeBytes        P

$file(plm4b.plm,plm6b.plm)
EmitError       P
GetSourceLine   P
LinePrefix        P

$file(plm4c.plm)
Sub$5FE7        P(A arg1w,B arg2b)
Sub$668B        P

/* $file(wrec.plm) */

/* $file(lstsp5.plm) */

$file(main5.plm)
b3F0B           B
b66D8           B
dictionary$p    A
dictSize        A
dictTop$p       A
maxSymLen       B
w66D2           A
w66D4           A
xrefItem$p      A
dictionary      AS..dictionary$p
xrefItem        AS..xrefItem$p


/* $file(page1.plm) */

/* $file(page2.plm) */

$file(plm5a.plm)

/* $file(lstsp6.plm) */

/* $file(main6.plm) */

/* $file(page.plm) */

$file(pdata6.plm)
b7AD9           B
b7ADA           B
b7AE4           B
w7AE5           A

$file(plm6a.plm)
Sub$42E7        P


/* files in common dir */
/* friendly names for the controls */
PRINT	 'CONTROLS(0)'
XREF	 'CONTROLS(1)'
SYMBOLS	 'CONTROLS(2)'
DEBUG	 'CONTROLS(3)'
PAGING	 'CONTROLS(4)'
OBJECT	 'CONTROLS(5)'
OPTIMIZE 'CONTROLS(6)'
IXREF	 'CONTROLS(7)'

cursym          "SYM$ST"..curSymbol$p
info            "INFO$ST"..curInfo$p
litinfo         "LIT$ST"..curInfo$p
cmd             "CMD$ST"..cmdLine$p
inChr           B..inChr$p
curScope        A..curProcData


$file(adninf.plm)
AdvNxtInfo      P

$file(Alloc.plm)
Alloc           P(A size1,A size2)

$file(allocs.plm)
AllocSymbol     P(A spc)A

$file(Backup.plm)
Backup          P(A loc$p,A cnt)

$file(Chain.plm)
Chain           P(A fNam)

$file(ciflag.plm)
ClrInfoFlag     P(B flag)

$file(Close.plm)
Close           P(A conn,A status$p)

$file(CloseF.plm)
CloseF          P(A file$p)

$file(clrflg.plm)
ClrFlag         P(A base,B flag)

$file(cpyflg.plm)
CpyFlags        P(A base)

$file(cpytil.plm)
CpyTill         P(A src$p,A dst$p,A cnt,B endch)

$file(CreatF.plm)
CreatF          P(A fp,A buf,A bsize,B mode)

$file(creati.plm)
AllocInfo       P(A infosize)A
CreateInfo      P(A val,B type)

$file(data.plm)
atFile          "FILE$T"
b3CF2           B
wrapMarkerCol           B
wrapMarker           B
wrapTextCol           B
skpCnt           B
blk1Used        A
blk2Used        A
blkSize1        A
blkSize2        A
blockDepth      A
botInfo         A
botMem          A
botSymbol       A
cmdLine$p       A
col             B
conFile         "FILE$T"
CONTROLS        BS
csegSize        A
curInfo$p       A
curSymbol$p     A
DATE            BS
debugFlag       B
debugSwitches   BS
dsegSize        A
fatalErrorCode  B
hasErrors       B
hashChains$p    A
haveModule      B
helpers$p       A
intVecLoc       A
intVecNum       B
invokeName      BS
ISIS            A
ixiFile         "FILE$T"
ixiFileName     BS
IXREFSet        B
lbuf$p          A
lBufSz          A
lChCnt          A
LEFTMARGIN      A
lfOpen          B
linesRead       A
linlft          B
localLabelCnt   A
localLabels$p   A
lstFil          "FILE$T"
lstFileName     BS
margin          B
nmsFile         "FILE$T"
objBlk          A
objByte         A
OBJECTSet       B
objFile         "FILE$T"
objFileName     BS
offNxtCmdChM1   A
ov0             BS
ov6             BS
overlay1        BS
overlay2        BS
overlay3        BS
overlay4        BS
overlay5        BS
overlay6        BS
pad3C43         B
pad$3C4E        BS
PAGELEN         B
pageNo          A
plm80Compiler   BS
PRINTSet        B
procChains      AS
procCnt         A
procInfo        AS
programErrCnt   A
PWIDTH          B
REBOOTVECTOR    A
srcFil          "FILE$T"
srcFileIdx      A
srcFileTable    AS
srcStemLen      B
srcStemName     BS
standAlone      B
startCmdLine$p  A
tblBitFlags     BS
tblOffsets      BS
TITLE           BS
TITLELEN        B
topInfo         A
topMem          A
topSymbol       A
tWidth          B
tx1File         "FILE$T"
tx2File         "FILE$T"
unexpectedEOF   B
version         BS
w381E           A
w3822           A
w382A           A
w3C34           A
w3C44           A
xrfFile         "FILE$T"

$file(Delete.plm)
Delete          P(A path$p,A status$p)

$file(DeletF.plm)
DeletF          P(A file$p)

$file(endcom.plm)
EndCompile      P

$file(error.plm)
Error           P(A Error$num)

$file(exit.plm)
Exit            P

$file(Fatal.plm)
Fatal           P(A str,B len)

$file(FatlIO.plm)
FatlIO          P(A file$p,A errnum)

$file(Fflush.plm)
Fflush          P(A fp)

$file(fi.plm)
FindInfo        P

$file(fill.asm)
fill            P(A cnt,A dst,B val)
fillx           P(A cnt,A dst,A val)

$file(findmi.plm)
FindMemberInfo  P

$file(fiscop.plm)
FindScopedInfo  P(A scp)

$file(fread.asm)
fread           P(A file,A buf,A cnt)

$file(fwrite.asm)
fwrite          P(A file,A buf,A cnt)

$file(gibin.plm)
GetBuiltinId    PB

$file(gibseo.plm)
GetBaseOffset   PA

$file(gibsev.plm)
GetBaseVal      PA

$file(gicond.plm)
GetCondFlag     PB

$file(gidim.plm)
GetDimension    PA

$file(gidim2.plm)
GetDimension2   PA

$file(gidtyp.plm)
GetDataType     PB

$file(gieid.plm)
GetExternId     PB

$file(giintn.plm)
GetIntrNo       PB

$file(gilen.plm)
GetLen          PB

$file(gilit.plm)
GetLitaddr      PA

$file(gilnko.plm)
GetLinkOffset   PA

$file(gilnkv.plm)
GetLinkVal      PA

$file(giparo.plm)
GetParentOffset PA

$file(giparv.plm)
GetParentVal    PA

$file(gipcnt.plm)
GetParamCnt     PB

$file(gipid.plm)
GetProcId       PB

$file(giscop.plm)
GetScope        PA

$file(gisym.plm)
GetSymbol       PA

$file(gitype.plm)
GetType         PB

$file(InitF.plm)
InitF           P(A file$p,A sNam,A fNam)

$file(itoa.plm)
Num2Asc         P(A num,B width,B radix,A buf$p)B

$file(Load.plm)
Load            P(A path$p,A Load$offset,A switch,A entry$p,A status$p)

$file(Lookup.plm)
Lookup          P(A pstr)

$file(lstinf.plm)
LstModuleInfo   P

$file(lstlin.plm)
LstLineNo       P

$file(memchk.asm)
memchk          PA

$file(movmem.asm)
movmem          P(A cnt,A src,A dst)

$file(Open.plm)
Open            P(A conn$p,A path$p,A access,A echo,A status$p)

$file(OpenF.plm)
OpenF           P(A file$p,B access)

$file(prints.plm)
PrintStr        P(A str,B len)

$file(putlst.asm)
putLst          P(B ch)

$file(Read.plm)
Read            P(A conn,A buff$p,A count,A actual$p,A status$p)

$file(Readf.plm)
Readf           P(A file$p,A buf$p,A len,A actual$p)

$file(Rename.plm)
Rename          P(A old$p,A new$p,A status$p)

$file(Rescan.plm)
Rescan          P(A conn,A status$p)

$file(Rewind.plm)
Rewind          P(A file$p)

$file(Seek.plm)
Seek            P(A conn,A mode,A block$p,A byte$p,A status$p)

$file(SeekF.plm)
SeekF           P(A file$p,A loc$p)

$file(SekEnd.plm)
SekEnd          P(A file$p)

$file(setflg.plm)
SetFlag         P(A base,B flag)

$file(sibin.plm)
SetBuiltinId    P(B id)

$file(sibseo.plm)
SetBaseOffset   P(A base$p)

$file(sibsev.plm)
SetBaseVal      P(A val)

$file(sicond.plm)
SetCondFlag     P(B flag)

$file(sidim.plm)
SetDimension    P(A dim)

$file(sidtyp.plm)
SetDataType     P(B dtype)

$file(sieid.plm)
SetExternId     P(B id)

$file(siflag.plm)
SetInfoFlag     P(B flag)

$file(siintn.plm)
SetIntrNo       P(B intNo)

$file(silen.plm)
SetLen          P(B len)

$file(silit.plm)
SetLitaddr      P(A litaddr)

$file(silnko.plm)
SetLinkOffset   P(A link)

$file(silnkv.plm)
SetLinkVal      P(A val)

$file(siparo.plm)
SetParentOffset P(A parent)

$file(sipcnt.plm)
SetParamCnt     P(B cnt)

$file(sipid.plm)
SetProcId       P(B id)

$file(siscop.plm)
SetScope        P(A scope)

$file(sisym.plm)
SetSymbol       P(A symbol)

$file(sitype.plm)
SetType         P(B type)

$file(strcmp.plm)
Strncmp         P(A s1$p,A s2$p,B cnt)B

$file(TellF.plm)
TellF           P(A file$p,A loc$p)

$file(tiflag.plm)
TestInfoFlag    P(B flag)B

$file(tstflg.plm)
TestFlag        P(A base,B flag)B

$file(wr2lst.plm)
Wr2cLst         P(A arg1w)

$file(wrclst.asm)
wrcLst          P(B ch)

$file(Write.plm)
Write           P(A conn,A buff$p,A count,A status$p)

$file(WriteF.plm)
WriteF          P(A fp,A buf,A count)

$file(wrslst.plm)
WrnstrLst       P(A str$p,A cnt)

$file(zerflg.plm)
ClrFlags        P(A base)
shared/adninf.plm
adninf: DO;
$include(:f3:adninf.ipx)

AdvNxtInfo: PROCEDURE PUBLIC;
	do while 1;
		curInfo$p = curInfo$p + GetLen;
		if curInfo$p >= topInfo then
		do;
			curInfo$p = 0;
			return;
		end;
		else if GetType <> 9 then
			return;
	end;
end;


END;

shared/alloc.plm
Alloc: DO;
$include(:f3:Alloc.ipx)

Alloc: PROCEDURE(size1, size2) PUBLIC;
	DECLARE (size1, size2) ADDRESS;

	blk1Used = blk1Used + size1;
	blk2Used = blk2Used + size2;
	if blk1Used >= blksize1 or blk2Used >= blksize2 then
		call FatalError(ERR83);
end Alloc;
end;
shared/allocs.plm
allocs: DO;
$include(:f3:allocs.ipx)

AllocSymbol: PROCEDURE(spc) ADDRESS PUBLIC;
	DECLARE spc ADDRESS;
	DECLARE tmp ADDRESS;

	if (tmp := botSymbol - spc) < topInfo then
		call FatalError(ERR83);
	return (botSymbol := tmp);
end AllocSymbol;

end;
shared/backup.plm
Backup: DO;
$include(:f3:Backup.ipx)

Backup: PROCEDURE(loc$p, cnt) public; /* Backup the block/byte pos by cnt bytes */
	DECLARE (loc$p, cnt) ADDRESS;
	DECLARE loc BASED loc$p LOC$ST;
	DECLARE (blk, byt) ADDRESS;

	blk = cnt / 128;
	byt = cnt mod 128;
	loc.blk = loc.blk - blk;
	if byt > loc.byt then
	do;
		loc.blk = loc.blk - 1;
		loc.byt = loc.byt + 128 - byt;
	end;
	else
		loc.byt = loc.byt - byt;
end;


END;
shared/chain.plm
Chain: DO;

$include(:f3:Chain.ipx)

Chain:	PROCEDURE(fNam) public;
	DECLARE fNam ADDRESS;
	DECLARE loadFile FILE$T;
	DECLARE (status, entry, switch) ADDRESS;

	if debugFlag then
		switch = 2;
	else
		switch = 1;
	call Load(fNam, 0, switch, .entry, .status);
	if status <> 0 then
	do;
		call InitF(.loadFile, .('LOAD '), fNam);
		call FatlIO(.loadFile, status);
	end;
end Chain;
end;
shared/ciflag.plm
ciflag: DO;

$include(:f3:ciflag.ipx)

ClrInfoFlag: PROCEDURE(flag) PUBLIC;
	DECLARE flag BYTE;
	call ClrFlag(.info.flag, flag);
end;



END;

shared/close.plm
Close: DO;
$include(:f3:Close.ipx)

Close: PROCEDURE(conn, status$p) public;
	declare (conn, status$p) address;
	CALL ISIS(ICLOSE, .conn);
end Close;

end;
shared/closef.plm
CloseF: DO;
$include(:f3:CloseF.ipx)

CloseF: PROCEDURE(file$p) public;
	DECLARE file$p ADDRESS;
	DECLARE file BASED file$p FILE$T;
	DECLARE status ADDRESS;

	call Close(file.aftn, .status);
	if status <> 0 then
		call FatlIO(file$p, status);
end;


END;
shared/clrflg.plm
ClrFlag: DO;

$include(:f3:clrflg.ipx)

ClrFlag: PROCEDURE(base, flag) PUBLIC;
	DECLARE base ADDRESS, flag BYTE;
	DECLARE b BASED base(1) BYTE;
	DECLARE off BYTE, mask BYTE;

	off = tblOffsets(flag);
	mask = not tblBitFlags(flag);
	b(off) = b(off) and mask;
end;

END;
shared/cpyflg.plm
cpyflg: do;

$include(:f3:cpyflg.ipx)

CpyFlags: PROCEDURE(base) PUBLIC;
	DECLARE base ADDRESS;
	DECLARE b BASED base(3) BYTE;
	DECLARE i BYTE;

	do i = 0 to 2;
		info.flag(i) = b(i);
	end;
end;



end;

shared/cpytil.plm
CpyTill: DO;

CpyTill: PROCEDURE(src$p, dst$p, cnt, endch) PUBLIC;
	DECLARE src$p ADDRESS, dst$p ADDRESS, cnt ADDRESS, endch BYTE;
	DECLARE src BASED src$p BYTE, dst BASED dst$p BYTE;

	do while cnt <> 0;
		if src = endch then
			return;
		dst = src;
		src$p = src$p + 1;
		dst$p = dst$p + 1;
		cnt = cnt - 1;
	end;
end CpyTill;
END;
shared/creatf.plm
CreatF: DO;
$include(:f3:CreatF.ipx)

/* CreatF(file$p, buf$p, size$w, mode$b)
   set files buffer and buffer size
   Read into buffer if mode$b =    1
*/

CreatF: PROCEDURE(fp, buf, bsize, mode) public;
	DECLARE (fp, buf, bsize) ADDRESS, mode BYTE;
	DECLARE file BASED fp FILE$T;

	file.buf$p = buf;
	file.bsize = bsize;
	if mode = 1 then
		call Readf(fp, buf, bsize, .file.actual);
	file.curoff = 0;
end;

END;
shared/creati.plm
creati: DO;
$include(:f3:creati.ipx)

DECLARE infoLengths(*) BYTE DATA(10, 12, 18, 18, 18, 22, 11, 10, 8, 9);


AllocInfo: PROCEDURE(infosize) ADDRESS PUBLIC;
	DECLARE infosize ADDRESS;
	DECLARE (q, p) ADDRESS;

	call Alloc(infosize, infosize);
	p = topInfo + 1;
	if botSymbol < (q := topInfo + infosize) then
		call FatalError(ERR83);
	call fill(infosize, p, 0);
	topInfo = q;
	return p;
end AllocInfo;


CreateInfo: PROCEDURE(val, type) PUBLIC;
	DECLARE val ADDRESS, type BYTE;
	DECLARE len BYTE;

	len = infoLengths(type);
	curInfo$p = AllocInfo(len);
	if curSymbol$p <> 0 then
	do;
		call SetLinkOffset(cursym.info$p);
		cursym.info$p = curInfo$p;
	end;
	call SetType(type);
	call SetLen(len);
	call SetScope(val);
	call SetSymbol(curSymbol$p);
end CreateInfo;


end;
shared/data.plm
PLMDATA: DO;
$include(:f3:data.ipx)

DECLARE
	topMem	ADDRESS PUBLIC,
	botMem	ADDRESS PUBLIC,
	botInfo	ADDRESS PUBLIC,
	topInfo	ADDRESS PUBLIC,
	topSymbol ADDRESS PUBLIC,
	botSymbol ADDRESS PUBLIC,
	curSymbol$p ADDRESS PUBLIC,
	curInfo$p ADDRESS PUBLIC,
	offNxtCmdChM1 ADDRESS PUBLIC,
	LEFTMARGIN ADDRESS PUBLIC,
	localLabelCnt ADDRESS PUBLIC,
	srcFileIdx ADDRESS PUBLIC,
	hashChains$p ADDRESS PUBLIC,
	blockDepth ADDRESS PUBLIC,
	(localLabels$p, w381E, helpers$p, w3822, linesRead) ADDRESS PUBLIC,
	programErrCnt ADDRESS PUBLIC,
	procCnt ADDRESS PUBLIC,
	w382A ADDRESS PUBLIC INITIAL(0),
	dsegSize ADDRESS PUBLIC INITIAL(0),
	csegSize ADDRESS PUBLIC INITIAL(0),
	objBlk ADDRESS PUBLIC,
	objByte ADDRESS PUBLIC,
	srcFileTable(60) address PUBLIC,
	srcFil FILE$T PUBLIC INITIAL(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0),
	lstFil FILE$T PUBLIC INITIAL(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0),
	objFile FILE$T PUBLIC INITIAL(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0),
	conFile FILE$T PUBLIC INITIAL(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0),
	tx1File FILE$T PUBLIC INITIAL(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0),
	tx2File FILE$T PUBLIC INITIAL(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0),
	atFile FILE$T PUBLIC INITIAL(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0),
	nmsFile FILE$T PUBLIC INITIAL(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0),
	xrfFile FILE$T PUBLIC INITIAL(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0),
	ixiFile FILE$T PUBLIC INITIAL(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0),
	procChains(35) ADDRESS PUBLIC,
	procInfo(255) ADDRESS PUBLIC,
	blk1Used ADDRESS PUBLIC INITIAL(400),
	blk2Used ADDRESS PUBLIC INITIAL(400),
	w3C34 ADDRESS PUBLIC INITIAL(9F00H),
	blkSize1 ADDRESS PUBLIC INITIAL(0C400H),
	blkSize2 ADDRESS PUBLIC INITIAL(0A400H),
	srcStemLen BYTE PUBLIC,
	standAlone BYTE PUBLIC INITIAL(0FFH),
	IXREFSet BYTE PUBLIC INITIAL(0FFH),
	PRINTSet BYTE PUBLIC INITIAL(0FFH),
	OBJECTSet BYTE PUBLIC INITIAL(0FFH),
	debugFlag BYTE PUBLIC INITIAL(0),
	unexpectedEOF BYTE PUBLIC INITIAL(0),
	haveModule BYTE PUBLIC INITIAL(0),
	fatalErrorCode BYTE PUBLIC INITIAL(0),
	pad3C43 BYTE PUBLIC INITIAL(1),
	w3C44 ADDRESS PUBLIC INITIAL(0A000H),
	CONTROLS(8) BYTE PUBLIC,
	pad$3C4E(2) BYTE PUBLIC,
	srcStemName(10) BYTE PUBLIC,
	debugSwitches(26) BYTE PUBLIC INITIAL(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),
	cmdLine$p ADDRESS PUBLIC,
	startCmdLine$p ADDRESS PUBLIC,
	overlay1(FILE$NAME$LEN) BYTE PUBLIC INITIAL(':F0:PLM80 .OV1 '),
	overlay2(FILE$NAME$LEN) BYTE PUBLIC INITIAL(':F0:PLM80 .OV2 '),
	overlay3(FILE$NAME$LEN) BYTE PUBLIC INITIAL(':F0:PLM80 .OV3 '),
	overlay4(FILE$NAME$LEN) BYTE PUBLIC INITIAL(':F0:PLM80 .OV4 '),
	overlay5(FILE$NAME$LEN) BYTE PUBLIC INITIAL(':F0:PLM80 .OV5 '),
	ixiFileName(FILE$NAME$LEN) BYTE PUBLIC,
	lstFileName(FILE$NAME$LEN) BYTE PUBLIC,
	objFileName(FILE$NAME$LEN) BYTE PUBLIC,
	pageNo ADDRESS PUBLIC INITIAL(0),
	b3CF2 BYTE PUBLIC, 
	lbuf$p ADDRESS PUBLIC INITIAL(.b3CF2),	
	lChCnt ADDRESS PUBLIC INITIAL(0),
	lBufSz ADDRESS PUBLIC INITIAL(0),
	lfOpen BYTE PUBLIC INITIAL(0),
	linlft BYTE PUBLIC INITIAL(0),
	(wrapMarkerCol, wrapMarker, wrapTextCol) BYTE PUBLIC INITIAL(0,0,0),
	col BYTE PUBLIC INITIAL(0),
	skpCnt BYTE PUBLIC INITIAL(0),
	tWidth BYTE PUBLIC INITIAL(0),
	TITLELEN BYTE PUBLIC INITIAL(1),
	PAGELEN BYTE PUBLIC INITIAL(60),
	PWIDTH BYTE PUBLIC INITIAL(120),
	margin BYTE PUBLIC INITIAL(0FFH),
	DATE(9) BYTE PUBLIC,
	plm80Compiler(*) BYTE PUBLIC INITIAL('PL/M-80 COMPILER    '),
	TITLE(60) BYTE PUBLIC INITIAL(' '),
	ISIS ADDRESS PUBLIC INITIAL(40H),
	REBOOTVECTOR ADDRESS PUBLIC INITIAL(0);

DECLARE tblOffsets(*) BYTE PUBLIC INITIAL(0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			        1, 1, 1, 1, 1, 1, 1, 1, 2, 2);
DECLARE tblBitFlags(*) BYTE PUBLIC INITIAL(80h, 40h, 20h, 10h, 10h, 8, 8, 4, 2, 1,
				 80h, 40h, 20h, 10h, 8, 4, 2, 1, 80h, 40h);

DECLARE	intVecNum BYTE PUBLIC INITIAL(8),
	intVecLoc ADDRESS PUBLIC INITIAL(0),
	hasErrors BYTE PUBLIC INITIAL(0),
	overlay6(*) BYTE PUBLIC INITIAL(':F0:PLM80 '),
	ov6(*) BYTE PUBLIC INITIAL('.OV6 '),
	version(*) BYTE PUBLIC INITIAL('X000'),
	pad3DA1 BYTE,
	invokeName(*) BYTE PUBLIC INITIAL(':F0:PLM80 '),
	ov0(*) BYTE PUBLIC INITIAL('.OV0 ');

end;
shared/delete.plm
Delete: DO;
$include(:f3:Delete.ipx)

Delete: procedure (path$p, status$p) public;
    declare (path$p, status$p) address;
    call ISIS(IDELETE, .path$p);
end Delete;

end;
shared/deletf.plm
DeletF: DO;
$include(:f3:DeletF.ipx)

DeletF: PROCEDURE(file$p) PUBLIC;
	DECLARE file$P ADDRESS, file BASED file$p FILE$T;
	DECLARE status ADDRESS;

	call Delete(.file.fNam, .status);
end;

end;
shared/endcom.plm
endcom: do;
$include(:f3:endcom.ipx)


declare endMsg(*) byte data('PL/M-80 COMPILATION COMPLETE.  '),
	errMsg(*) byte data('XXXXX PROGRAM ERROR'),
	crlf2(*) byte data(cr, lf, cr, lf);

EndCompile: procedure public;
	declare junk byte;
	junk = Num2Asc(programErrCnt, 5, 10, .errMsg);
	call PrintStr(.endMsg, length(endMsg));
	call PrintStr(.errMsg, length(errMsg));
	if programErrCnt <> 1 then
		call PrintStr(.('S'), 1);
	call PrintStr(.crlf2, 4);
end;	

end;
shared/error.plm
Error: DO;
$include(:f3:Error.ipx)

Error: procedure (Error$num) public;
    declare (Error$num) address;
    call ISIS(IERROR, .Error$num);
end Error;
end;
shared/exit.plm
Exit: DO;
$include(:f3:Exit.ipx)

Exit: procedure public;
    declare tmp address;
    tmp = .tmp;
    call ISIS(IEXIT, .tmp);
end Exit;
end;
shared/fatal.plm
Fatal: DO;
$include(:f3:Fatal.ipx)

Fatal: PROCEDURE(str, len) PUBLIC;
	DECLARE str ADDRESS, len BYTE;
	call PrintStr(.(CR, LF, LF,'PL/M-80 FATAL ERROR --', CR, LF, LF), 28);
	call PrintStr(str, len);
	call PrintStr(.(CR, LF, LF,'COMPILATION TERMINATED', CR, LF, LF), 28);
	if debugFlag then
		call REBOOTVECTOR;
	else
		call Exit;
end Fatal;

end;
shared/fatlio.plm
FatlIO: DO;
$include(:f3:FatlIO.ipx)

DECLARE
	errHeader(*) BYTE DATA(CR, LF, LF, 'PL/M-80 I/O ERROR --', CR, LF, '  FILE: '),
	aName(*) BYTE DATA(CR, LF, '  NAME: '),
	aError(*) BYTE DATA(CR, LF, '  ERROR: '),
	aTerminate(*) BYTE DATA(CR, LF, 'COMPILATION TERMINATED', CR, LF, LF),
	errStrTable(*) BYTE DATA(
	4, 'ILLEGAL FILENAME SPECIFICATION', 0,
	5, 'ILLEGAL OR UNRECOGNIZED DEVICE SPECIFICATION IN FILENAME', 0,
	0Ch, 'ATTEMPT TO OPEN AN ALREADY OPEN FILE', 0,
	0Dh, 'NO SUCH FILE', 0,
	0Eh, 'FILE IS WRITE PROTECTED', 0,
	13h, 'FILE IS NOT ON A DISKETTE', 0,
	16h, 'DEVICE TYPE NOT COMPATIBLE WITH INTENDED FILE USE', 0,
	17h, 'FILENAME REQUIRED ON DISKETTE FILE', 0,
	1Ch, 'NULL FILE EXTENSION', 0,
	0FEh, 'ATTEMPT TO READ PAST EOF', 0,
   	0);


FatlIO: PROCEDURE(file$p, errnum) PUBLIC;
	DECLARE (file$p, errnum) ADDRESS;
	DECLARE file BASED file$p FILE$T;
	DECLARE buf(5) BYTE, len BYTE;
	DECLARE off ADDRESS, slen ADDRESS;

	FindErrStr: PROCEDURE;
		DECLARE (j, i) ADDRESS;

		i = 0;
		do while errStrTable(i) <> 0;	
			j = i;
			do while errStrTable(i) <> 0;
				i = i + 1;
			end;
			if errstrTable(j) = errnum then
			do;
				off = j + 1;
				slen = i - off;
				return;
			end;
			i = i + 1;
		end;
		slen = 0;
	end FindErrStr;


	call PrintStr(.errHeader, length(errHeader));
	call PrintStr(.file.sNam, 6);
	call PrintStr(.aName, length(aName));	
	call PrintStr(.file.fnam, 15);
	call PrintStr(.aError, length(aError));
	len = Num2Asc(errnum, 0, 10, .buf);
	call PrintStr(.buf, len);
	call FindErrStr;
	if slen <> 0 then
	do;
		call PrintStr(.('--'), 2);
		call PrintStr(.errStrTable(off), slen);
	end;
	call PrintStr(.aTerminate, length(aTerminate));
	if debugFlag then
		call REBOOTVECTOR;
	else
		call Exit;
end FatlIO;

END;
shared/fflush.plm
Fflush: DO;
$include(:f3:Fflush.ipx)


Fflush: PROCEDURE(fp) public;
	DECLARE fp ADDRESS;
	DECLARE file BASED fp FILE$T;

	if file.curoff <> 0 then
	do;
		call WriteF(fp, file.buf$p, file.curoff);
		file.curoff = 0;
	end;
end;

END;
shared/fi.plm
fi: DO;
$include(:f3:fi.ipx)

FindInfo: PROCEDURE PUBLIC;
	DECLARE i ADDRESS;

	if cursym.info$p= 0 then
	do;
		curInfo$p = 0;
		return;
	end;
	i = blockDepth;
	do while i <> 0;
		call FindScopedInfo(procChains(i));
		if curInfo$p <> 0 then
			return;
		i = i - 1;
	end;
end;


END;
shared/findmi.plm
findmi: DO;
$include(:f3:findmi.ipx)

FindMemberInfo: PROCEDURE public;
	DECLARE tmp ADDRESS;

	tmp = curInfo$p;
	curInfo$p = cursym.info$p;
	do while curInfo$p <> 0;
		if TestInfoFlag(F$MEMBER) then
			if tmp = GetParentOffset then
				return;
		curInfo$p = GetLinkOffset;
	end;
end;
end;
shared/fiscop.plm
fiscop: DO;
$include(:f3:fiscop.ipx)

FindScopedInfo: PROCEDURE(scp) PUBLIC;
	DECLARE scp ADDRESS;
	DECLARE (p, q, next) ADDRESS, infoType BYTE;

	curInfo$p = cursym.info$p;
	p = 0;
	do while curInfo$p <> 0;
		if scp = GetScope then
		do;
			infoType = GetType;
			if infoType = LIT$T or infoType = MACRO$T then
				;
			else if TestInfoFlag(F$MEMBER) then
				goto nxt;
			if p <> 0 then	/* not at start of Chain */
			do;
				next = GetLinkOffset;	/* move to head of Chain */
				q = curInfo$p;		/* save current */
				curInfo$p = p;		/* pick up previous */
				call SetLinkOffset(next);	/* set its link */
				curInfo$p = q;		/* restore current */
				call SetLinkOffset(cursym.info$p);	/* set its link to current head */
				cursym.info$p = curInfo$p;	/* set head to found info */
			end;
			return;
		end;
	nxt:	p = curInfo$p;
		curInfo$p = GetLinkOffset;
	end;
end;



END;
shared/gibin.plm
gibin: do;
$include(:f3:gibin.ipx)

GetBuiltinId: PROCEDURE byte PUBLIC;

	return info.flag(0);
end;

end;
shared/gibseo.plm
gibseo: DO;
$include(:f3:gibseo.ipx)

GetBaseOffset: procedure address public;
	if info.baseoff = 0 then
		return 0;
	else
		return info.baseoff + botInfo;
end;



END;

shared/gibsev.plm
gibsev: DO;
$include(:f3:gibsev.ipx)

GetBaseVal: procedure address public;
	return info.baseoff;
end;


END;
shared/gicond.plm
gicond: do;
$include(:f3:gicond.ipx)

GetCondFlag: PROCEDURE BYTE PUBLIC;
	return info.flag(0);
end;



end;
shared/gidim.plm
gidim: DO;
$include(:f3:gidim.ipx)


GetDimension: procedure address public;
	return info.dim;
end;



END;

shared/gidim2.plm
gidim2: DO;
$include(:f3:gidim2.ipx)

GetDimension2: procedure address public;
	return info.dim;
end;



END;

shared/gidtyp.plm
gidtyp: DO;
$include(:f3:gidtyp.ipx)

GetDataType: procedure byte public;
	if info.type = PROC$T then
		return info.dtype;
	else
		return info.flag(2);
end;



END;

shared/gieid.plm
gieid: DO;
$include(:f3:gieid.ipx)

GetExternId: PROCEDURE BYTE PUBLIC;
	return info.extId;	
end;



END;

shared/giintn.plm
giintn: DO;
$include(:f3:giintn.ipx)

GetIntrNo: procedure byte public;
	return info.intno;
end;



END;

shared/gilen.plm
gilen: do;
$include(:f3:gilen.ipx)

GetLen: procedure byte public;
	return info.len;
end;

end;
shared/gilit.plm
gilit: DO;
$include(:f3:gilit.ipx)

GetLitaddr: PROCEDURE address PUBLIC;
	return litinfo.litAddr;
end;

end;
shared/gilnko.plm
gilnko: DO;
$include(:f3:gilnko.ipx)

GetLinkOffset: PROCEDURE ADDRESS PUBLIC;
	if info.ilink = 0 then
		return 0;
	else
		return botInfo + info.ilink;
end;


END;

shared/gilnkv.plm
gilnkv: DO;
$include(:f3:gilnkv.ipx)

GetLinkVal: PROCEDURE ADDRESS PUBLIC;
	return info.ilink;
end;


END;

shared/giparo.plm
giparo: DO;
$Include(:f3:giparo.ipx)

GetParentOffset: procedure address public;
	if info.type = STRUCT$T then
		return info.parent;
	if info.parent = 0 then
		return 0;
	else
		return info.parent + botInfo;
end;



END;

shared/giparv.plm
giparv: DO;
$include(:f3:giparv.ipx)

GetParentVal: procedure address public;
	return info.parent;
end;



END;

shared/gipcnt.plm
gipcnt: DO;
$include(:f3:gipcnt.ipx)

GetParamCnt: PROCEDURE BYTE PUBLIC;

	if info.type = PROC$T then
		return info.pcnt;
	else
		return info.flag(1);
end;




END;
shared/gipid.plm
gipid: DO;
$include(:f3:gipid.ipx)

GetProcId: procedure byte public;
	return info.procId;
end;

end;
shared/giscop.plm
giscope: DO;
$include(:f3:giscop.ipx)

GetScope: PROCEDURE address PUBLIC;
	return info.scope;
end;


END;

shared/gisym.plm
gisym: DO;
$include(:f3:gisym.ipx)

GetSymbol: PROCEDURE ADDRESS PUBLIC;
	if info.sym = 0 then
		return 0;
	else
		return topSymbol - info.sym;
end;


END;

shared/gitype.plm
gitype: DO;
$include(:f3:gitype.ipx)

GetType: PROCEDURE BYTE PUBLIC;
	return info.type;
end;


END;

shared/initf.plm
InitF: DO;
$include(:f3:InitF.ipx)

InitF: PROCEDURE(file$p, sNam, fNam) PUBLIC;
	DECLARE (file$p, sNam, fNam) ADDRESS;
	DECLARE file BASED file$p FILE$T;
	file.aftn = 0;
	call fill(22, .file.sNam, ' ');
	call CpyTill(sNam, .file.sNam, 6, ' ');
	call CpyTill(fNam, .file.fNam, 15, ' ');
end InitF;


END;
shared/itoa.plm
Num2Asc: DO;
$include(:f3:itoa.ipx)

DECLARE hexdigits(*) BYTE DATA('0123456789ABCDEF');
DECLARE numsuffix(*) BYTE DATA('BXXXXXQXDXXXXXH');

Num2Asc: PROCEDURE(num, width, radix, buf$p) BYTE PUBLIC;
	DECLARE num ADDRESS, width BYTE, radix BYTE, buf$p ADDRESS;
	DECLARE buf(18) BYTE;
	DECLARE padch BYTE, fmt BYTE, j BYTE, lwidth BYTE,
	tmp BYTE, firstch BYTE, i BYTE;

	padch = ' ';
	if width > 7FH then
	do;
		padch = '0';
		width = -width;
	end;
	if width = 0 then
		lwidth = 16;
	else if width > 16 then
		lwidth = 16;
	else
		lwidth = width;
	fmt = 0;
	if radix > 7FH then
	do;
		fmt = 0FFH;
		radix = -radix;
	end;
	if radix > 16 then
		radix = 16;
	tmp = 16;
	firstch = tmp - lwidth + 1;
	call fill(lwidth, .buf(firstch), padch);
	i = lwidth;
	j = 16;
	do while i <> 0;
		buf(j) = hexdigits(num mod radix);
		if (num := num / radix) = 0 then
			i = 0;
		else
		do;
			i = i - 1;
			j = j - 1;
		end;
	end;
	if width = 0 then
	do;
		if fmt then
			if buf(j) > '9' then
			do;
				j = j - 1;
				buf(j) = '0';
			end;
		lwidth = 17 - (firstCh := j);
	end;
	if fmt then
	do;
		lwidth = lwidth + 1;
		buf(17) = numsuffix(radix - 2);
	end;
	call movmem(lwidth, .buf(firstCh), buf$p);
	return lwidth;
end Num2Asc;
end;
shared/lstsup.cmn
/* common source for lstsp[456].plm */

FlushLstBuf: procedure public;
	if lChCnt <> 0 then
	do;
		if not lfOpen then
		do;
			call OpenF(.lstFil, 2);
			lfOpen = true;
		end;
		call WriteF(.lstFil, lbuf$p, lChCnt);
		lChCnt = 0;
	end;
end;

NewLineLst: procedure public;
	if col = 0 then
		if linlft = 0 then
			call NewPgl;
	call Wr2cLst(0d0ah);
	linlft = linlft - 1;
	col = 0;
end;


TabLst: procedure(arg1b) public;
	declare arg1b byte;
	if arg1b > 7fh then
	do;
		arg1b = -arg1b;
		if col >= arg1b then
			call NewLineLst;
		arg1b = arg1b - col - 1;
	end;
	do while arg1b <> 0;
		call putLst(' ');
		arg1b = arg1b - 1;
	end;
end;


NewPageNextChLst: procedure public;
	linlft = 0;
end;

SetMarkerInfo: procedure(arg1b, arg2b, arg3b) public;
	declare (arg1b, arg2b, arg3b) byte;
	wrapMarkerCol = arg1b;
	wrapMarker = arg2b;
	wrapTextCol = arg3b;
end;

$if OVL<>5
SetStartAndTabW: procedure(arg1b, arg2b) public;
	declare (arg1b, arg2b) byte;
	margin = arg1b - 1;
	tWidth = arg2b;
end;
$endif

SetSkipLst: procedure(arg1b) public;
	declare arg1b byte;
	skpCnt = arg1b;
end;


Xputstr2cLst: procedure(str, endch) public;
	declare str address, endch byte,
		ch based str byte;
	do while ch <> endch;
		call putLst(ch);
		str = str + 1;
	end;
end;

XwrnstrLst: procedure(str, cnt) public;
	declare str address, cnt byte,
		ch based str byte;
	do while cnt <> 0;
		call putLst(ch);
		str=  str + 1;
		cnt = cnt - 1;
	end;
end;


XnumLst: procedure(num, width, radix) public;
	declare num address, (width, radix) byte;
	declare i byte, buf(7) byte;

	i = Num2Asc(num, width, radix, .buf);
	call XwrnstrLst(.buf, i);
end;
shared/load.plm
Load: DO;
$include(:f3:Load.ipx)

Load: procedure (path$p, Load$offset, switch, entry$p, status$p) public;
    declare (path$p, Load$offset, switch, entry$p, status$p) address;
    CALL ISIS(ILOAD, .path$p);
end Load;

end;
shared/lookup.plm
Lookup: DO;
$include(:f3:Lookup.ipx)

Lookup: PROCEDURE(pstr) PUBLIC;
	DECLARE pstr ADDRESS;
	DECLARE (p, r, q, hval) ADDRESS;
	DECLARE cmp BYTE;
	DECLARE hashchains BASED hashChains$p(64) ADDRESS;
	DECLARE len BASED pstr BYTE;

	Hash:	PROCEDURE ADDRESS;
		DECLARE p ADDRESS, len BYTE, Hash BYTE;
		DECLARE cha BASED pstr(1) BYTE;
		DECLARE ch BASED p BYTE;

		p = pstr;
		Hash = 0;
		len = cha(0);
		do while len <> 0;
			Hash = ROL(Hash, 1) + ch;
			p = p + 1;
			len = len - 1;
		end;
		return Hash and 3FH;
	end Hash;

	hval = Hash;
	curSymbol$p = hashChains(hval);
	p = 0;
	do while curSymbol$p <> 0;
		if cursym.name(0) = len then
		do;
			cmp = Strncmp(.cursym.name(1), pstr + 1, len);
			if cmp = 0 then
			do;
				if p <> 0 then
				do;
					q = cursym.link;
					r = curSymbol$p;
					curSymbol$p = p;
					cursym.link = q;
					curSymbol$p = r;
					cursym.link = hashChains(hval);
					hashChains(hval) = curSymbol$p;
				end;
				return;
			end;
		end;
		p = curSymbol$p;
		curSymbol$p = cursym.link;
	end;
	call Alloc(0, len + 1);
	curSymbol$p = AllocSymbol(5 + len);
	call movmem(len + 1, pstr, .cursym.name);
	cursym.info$p = 0;
	cursym.link = hashChains(hval);
	hashChains(hval) = curSymbol$p;
end Lookup;
END;
shared/lstinf.plm
lstInfo: DO;
$include(:f3:lstinf.ipx)

LstModuleInfo: procedure public;
	declare (p, q, r) address;
	p = 0;
	do q = 1 to procCnt;
		curInfo$p = botInfo + procInfo(q);
		r = GetBaseVal;
		if r > p then
			p = r;
	end;
	call SetSkipLst(3);
	call Xputstr2cLst(.('MODULE INFORMATION:', 0), 0);
	call NewLineLst;
	call SetSkipLst(1);
	call TabLst(5);
	call Xputstr2cLst(.('CODE AREA SIZE     = ', 0), 0);
	call XnumLst(csegSize, 0FCh, 0F0h);
	call TabLst(2);
	call XnumLst(csegSize, 5, 0F6h);
	call NewLineLst;
	call TabLst(5);
	call Xputstr2cLst(.('VARIABLE AREA SIZE = ', 0), 0);
	call XnumLst(dsegSize, 0FCh, 0F0h);
	call TabLst(2);
	call XnumLst(dsegSize, 5, 0F6h);
	call NewLineLst;
	call TabLst(5);
	call Xputstr2cLst(.('MAXIMUM STACK SIZE = ', 0), 0);
	call XnumLst(p, 0FCh, 0F0h);
	call TabLst(2);
	call XnumLst(p, 5, 0F6h);
	call NewLineLst;
	call TabLst(5);
	call XnumLst(linesRead, 0, 0Ah);
	call Xputstr2cLst(.(' LINES READ', 0), 0);
	call NewLineLst;
	call TabLst(5);
	call XnumLst(programErrCnt, 0, 0Ah);
	call Xputstr2cLst(.(' PROGRAM ERROR', 0), 0);
	if programErrCnt <> 1 then
		call Xputstr2cLst(.('S', 0), 0);

	call NewLineLst;
	call SetSkipLst(1);
	call Xputstr2cLst(.('END OF PL/M-80 COMPILATION', 0), 0);
	call NewLineLst;
	call FlushLstBuf;
	call CloseF(.lstFil);
	lfOpen = false;
end;
end;
shared/lstlin.plm
lstlin: DO;
$include(:f3:lstlin.ipx)

declare tmp(*) byte initial('     1');
declare	lastNo address initial(1);

LstLineNo: procedure public;
	declare	q address, i byte,
		ch based q byte;

	if lineNo > lastNo + 20 then
	do;
		lastNo = Num2Asc(lineNo, 6, 10, .tmp);
		lastNo = lineNo;
	end;
	else
	do while lastNo < lineNo;
		q = .tmp(5);
		i = true;
		do while i;
			if ch = '9' then
				ch = '0';
			else
			do;
				if ch = ' ' then
					ch = '1';
				else
					ch = ch + 1;
				i = false;
			end;
			q = q - 1;
		end;
		lastNo = lastNo + 1;
	end;
	call XwrnstrLst(.tmp(2), 4);
end;

end;
shared/open.plm
Open: DO;
$include(:f3:Open.ipx)

Open: procedure (conn$p, path$p, access, echo, status$p) public;
    declare (conn$p, path$p, access, echo, status$p) address;
    CALL ISIS(IOPEN, .conn$p);
end Open;

end;
shared/openf.plm
OpenF: DO;
$include(:f3:OpenF.ipx)

OpenF: PROCEDURE(file$p, access) PUBLIC;
	DECLARE file$p ADDRESS, access BYTE;
	DECLARE file BASED file$p FILE$T;
	DECLARE status ADDRESS;

	call Open(.file.aftn, .file.fNam, access, 0, .status);
	if status <> 0 then
		call FatlIO(file$p, status);
end OpenF;


END;
shared/prints.plm
PrintStr: DO;

$include(:f3:prints.ipx)


PrintStr: PROCEDURE(str, len) PUBLIC;
	DECLARE str ADDRESS, len BYTE;
	DECLARE status ADDRESS;

	call Write(0, str, len, .status);
end PrintStr;


END;
shared/read.plm
Read: DO;
$include(:f3:Read.ipx)

Read: procedure (conn, buff$p, count, actual$p, status$p) public;
    declare (conn, buff$p, count, actual$p, status$p) address;
    call ISIS(IREAD, .conn);
end Read;

end;
shared/readf.plm
Readf: DO;
$include(:f3:Readf.ipx)

Readf: PROCEDURE(file$p, buf$p, len, actual$p) PUBLIC;
	DECLARE (file$p, buf$p, len, actual$p) ADDRESS;
	DECLARE file BASED file$p FILE$T;
	DECLARE status ADDRESS;

    	call Read(file.aftn, buf$p, len, actual$p, .status);
	if status <> 0 then
		call FatlIO(file$p, status);
end;


END;
shared/rename.plm
Rename: DO;
$include(:f3:Rename.ipx)

Rename: procedure (old$p, new$p, status$p) public;
    declare (old$p, new$p, status$p) address;
    CALL ISIS(IRENAME, .old$p);
end Rename;

end;
shared/rescan.plm
Rescan: DO;
$include(:f3:Rescan.ipx)

Rescan: procedure (conn, status$p) public;
    declare (conn, status$p) address;
    call ISIS(IRESCAN, .conn);
end Rescan;

end;
shared/rewind.plm
Rewind: DO;
$include(:f3:Rewind.ipx)

Rewind: PROCEDURE(file$p) public;
	DECLARE file$p ADDRESS;
	DECLARE file BASED file$p FILE$T;
	DECLARE loc STRUCTURE(blk ADDRESS, byt ADDRESS);

	loc.blk, loc.byt = 0;
	call SeekF(file$p, .loc);
end;
end;
shared/seek.plm
Seek: DO;
$include(:f3:Seek.ipx)

Seek: procedure (conn, mode, block$p, byte$p, status$p) public;
    declare (conn, mode, block$p, byte$p, status$p) address;
    CALL ISIS(ISEEK, .conn);
end Seek;

end;
shared/seekf.plm
SeekF: DO;
$include(:f3:SeekF.ipx)

SeekF: PROCEDURE(file$p, loc$p) public;
	DECLARE (file$p, loc$p) ADDRESS;
	DECLARE file BASED file$p FILE$T;
	DECLARE loc BASED loc$p STRUCTURE(blk ADDRESS, byt ADDRESS);
	DECLARE status ADDRESS;

	call Seek(file.aftn, 2, .loc.blk, .loc.byt, .status);
	if status <> 0 then
		call FatlIO(file$p, status);
end;



END;
shared/sekend.plm
SekEnd: DO;
$include(:f3:SekEnd.ipx)

SekEnd: procedure(file$p) public;
	declare file$p address;
	declare file based file$p FILE$T;
	declare (status, tmp) address;

	call Seek(file.aftn, 4, .tmp, .tmp, .status);
	if status <> 0 then
		call FatlIO(file$p, status);
end;
end;
shared/setflg.plm
SetFlag: DO;
$include(:f3:setflg.ipx)

SetFlag: PROCEDURE(base, flag) PUBLIC;
	DECLARE base ADDRESS, flag BYTE;
	DECLARE b BASED base(1) BYTE;
	DECLARE off BYTE, bit BYTE;

	off = tblOffsets(flag);
	bit = tblBitFlags(flag);
	b(off) = b(off) or bit;
end;

END;
shared/sibin.plm
sibin: do;
$include(:f3:sibin.ipx)

SetBuiltinId: PROCEDURE(id) PUBLIC;
	DECLARE id BYTE;

	info.flag(0) = id;
end;

end;
shared/sibseo.plm
sibseo: DO;
$include(:f3:sibseo.ipx)

SetBaseOffset: procedure(base$p) public;
	DECLARE base$p ADDRESS;

	if base$p = 0 then
		info.baseoff = 0;
	else
		info.baseoff = base$p - botInfo;
end;



END;

shared/sibsev.plm
sibsev: DO;
$include(:f3:sibsev.ipx)

SetBaseVal: procedure(val) public;
	declare val address;
	info.baseoff = val;
end;


END;
shared/sicond.plm
sicond: do;
$include(:f3:sicond.ipx)

SetCondFlag: PROCEDURE(flag) PUBLIC;
	DECLARE flag BYTE;

	info.flag(0) = flag;
end;

end;
shared/sidim.plm
sidim: DO;
$include(:f3:sidim.ipx)

SetDimension: procedure(dim) public;
	declare dim address;
	info.dim = dim;
end;



END;

shared/sidtyp.plm
sidtyp: DO;
$include(:f3:sidtyp.ipx)

SetDataType: procedure(dtype) public;
	declare dtype byte;
	if info.type = PROC$T then
		info.dtype = dtype;
	else
		info.flag(2) = dtype;
end;



END;

shared/sieid.plm
sieid: DO;
$include(:f3:sieid.ipx)

SetExternId: PROCEDURE(id) PUBLIC;
	declare id byte;
	info.extId = id;;	
end;



END;

shared/siflag.plm
siflag: DO;
$include(:f3:siflag.ipx)

SetInfoFlag: PROCEDURE(flag) PUBLIC;
	DECLARE flag BYTE;
	call SetFlag(.info.flag, flag);
end;



END;

shared/siintn.plm
siintn: DO;
$include(:f3:siintn.ipx)

SetIntrNo: procedure(intNo) public;
	declare intNo byte;
	info.intno = intNo;
end;



END;

shared/silen.plm
silen: do;
$include(:f3:silen.ipx)

SetLen: procedure(len) public;
	declare len byte;
	info.len = len;
end;

end;
shared/silit.plm
silit: DO;
$include(:f3:silit.ipx)

SetLitaddr: PROCEDURE(litaddr) PUBLIC;
	DECLARE litaddr ADDRESS;
	litinfo.litAddr = litaddr;
end;

end;
shared/silnko.plm
silnko: DO;
$include(:f3:silnko.ipx)

SetLinkOffset: PROCEDURE(link) PUBLIC;
	DECLARE link ADDRESS;
	if link = 0 then
		info.ilink = 0;
	else
		info.ilink = link - botInfo;
end;


END;

shared/silnkv.plm
silnkv: DO;
$include(:f3:silnkv.ipx)

SetLinkVal: PROCEDURE(val) PUBLIC;
	declare val address;
	info.ilink = val;
end;


END;

shared/siparo.plm
siparo: DO;
$include(:f3:siparo.ipx)

SetParentOffset: procedure(parent) public;
	declare parent address;
	if info.type = STRUCT$T then
	do;
		info.parent = parent;
		return;
	end;
	if parent = 0 then
		info.parent = 0;
	else
		info.parent = parent - botInfo;
end;



END;

shared/sipcnt.plm
sipcnt: DO;
$include(:f3:sipcnt.ipx)

SetParamCnt: PROCEDURE(cnt) PUBLIC;
	declare cnt byte;

	if info.type = PROC$T then
		info.pcnt = cnt;
	else
		info.flag(1) = cnt;
end;

END;
shared/sipid.plm
sipid: DO;
$include(:f3:sipid.ipx)

SetProcId: procedure(id) public;
	declare id byte;
	info.procId = id;
end;

end;
shared/siscop.plm
siscope: DO;
$include(:f3:siscop.ipx)

SetScope: procedure(scope) public;
	declare scope address;
	info.scope = scope;
end;


END;

shared/sisym.plm
sisym: DO;
$include(:f3:sisym.ipx)

SetSymbol: PROCEDURE(symbol) PUBLIC;
	DECLARE symbol ADDRESS;
	if  symbol = 0 then
		info.sym = 0;
	else
		info.sym = topSymbol - symbol;
end;


END;

shared/sitype.plm
sitype: DO;
$include(:f3:sitype.ipx)

SetType: PROCEDURE(type) PUBLIC;
	declare type byte;
	info.type = type;
end;


END;

shared/strcmp.plm
strcmp: DO;

Strncmp: PROCEDURE(s1$p, s2$p, cnt) BYTE PUBLIC;
	DECLARE s1$p ADDRESS, s2$p ADDRESS, cnt BYTE;
	DECLARE s1 BASED s1$p BYTE, s2 BASED s2$p BYTE;
	do while cnt <> 0;
		if s1 < s2 then
			return 1;
		if s1 > s2 then
			return 2;
		cnt = cnt - 1;
		s1$p = s1$p + 1;
		s2$p = s2$p + 1;
	end;
	return 0;
end Strncmp;


END;
shared/tellf.plm
TellF: DO;
$include(:f3:TellF.ipx)

TellF: PROCEDURE(file$p, loc$p) public;
	DECLARE (file$p, loc$p) ADDRESS;
	DECLARE file BASED file$p FILE$T;
	DECLARE loc BASED loc$p STRUCTURE(blk ADDRESS, byt ADDRESS);
	DECLARE status ADDRESS;

	call Seek(file.aftn, 0, .loc.blk, .loc.byt, .status);
	if status <> 0 then
		call FatlIO(file$p, status);
end;


END;
shared/tiflag.plm
tiflag: DO;

$include(:f3:tiflag.ipx)

TestInfoFlag: PROCEDURE(flag) BYTE PUBLIC;
	DECLARE flag BYTE;
	return TestFlag(.info.flag, flag);
end;



END;

shared/tstflg.plm
TestFlag: DO;
$include(:f3:tstflg.ipx)

TestFlag: PROCEDURE(base, flag) BYTE PUBLIC;
	DECLARE base ADDRESS, flag BYTE;
	DECLARE b BASED base(1) BYTE;
	DECLARE off BYTE, bit BYTE;

	off = tblOffsets(flag);
	bit = tblBitFlags(flag);
	if (b(off) and bit) <> 0 then
		return TRUE;
	else
		return FALSE;
end TestFlag;

END;
shared/wr2lst.plm
Wr2cLst: DO;

$include(:f3:wr2lst.ipx)

Wr2cLst: procedure(arg1w) public;
	declare arg1w address;
	declare pbp address;
	declare bp based pbp(2) byte;
	pbp = .arg1w;
	call wrcLst(bp(1));
	call wrcLst(bp(0));
end;
end;
shared/write.plm
Write: DO;

$include(:F3:Write.ipx)

Write: procedure (conn, buff$p, count, status$p) public;
    declare (conn, buff$p, count, status$p) address;
    call ISIS(IWRITE, .conn);
end Write;

end;
shared/writef.plm
WriteF: DO;

$include(:f3:WriteF.ipx)

WriteF: PROCEDURE(fp, buf, count) PUBLIC;
 DECLARE (fp, buf, count) ADDRESS;
 DECLARE status ADDRESS;
 DECLARE file BASED fp FILE$T;

 call Write(file.aftn, buf, count, .status);
 if status <> 0 then
  call FatlIO(fp, status);
end;


END;
shared/wrslst.plm
WrnstrLst: DO;

$include(:f3:wrslst.ipx)

WrnstrLst: procedure(str$p, cnt) public;
	declare str$p address, cnt address;
	declare ch based str$p byte;

	do while cnt <> 0;
		call wrcLst(ch);
		str$p = str$p + 1;
		cnt = cnt - 1;
	end;
end;
end;









shared/zerflg.plm
zerflg: do;

ClrFlags: PROCEDURE(base) PUBLIC;
	DECLARE base ADDRESS;
	DECLARE b BASED base(3) BYTE;
	DECLARE i BYTE;

	do i = 0 to 2;
		b(i) = 0;
	end;
end;



end;

src/lstsp4.plm
$SET(OVL=4)
lstsup: DO;
$include(:f2:lstsp4.ipx)
$include(:f3:lstsup.cmn)
end;
src/lstsp5.plm
$SET(OVL=5)
lstsup: DO;
$include(:f2:lstsp5.ipx)
$include(:f3:lstsup.cmn)
end;
src/lstsp6.plm
$SET(OVL=6)
lstsup: DO;
$include(:f2:lstsp6.ipx)
$include(:f3:lstsup.cmn)

end;
src/main.plm
PLM: DO;
$include(:f2:main.ipx)
DECLARE
	copyRight(*) BYTE DATA('(C) 1976, 1977, 1982 INTEL CORP');

DECLARE state$main BYTE;

	FatalError: PROCEDURE(code) PUBLIC;
		DECLARE code BYTE;
		if code = ERR83 then
			call Fatal(.('DYNAMIC STORAGE OVERFLOW'), 24);
		call Fatal(.('UNKNOWN FATAL ERROR'), 19);
		call Exit;
	end FatalError;

	state$main = 10;
	call SignOnAndGetSourceName;
	state$main = 15;
	call InitKeywordsAndBuiltins;
	call Chain(.invokeName);
end;

src/main0.plm
plm0:
DO;
$include(:f2:main0.ipx)

DECLARE copyright(*) BYTE DATA('(C) 1976, 1977, 1982 INTEL CORP');
DECLARE resetPt LABEL PUBLIC;

Sub$3EDF: PROCEDURE local;
	if unexpectedEOF then
		call SyntaxError(ERR87);	/* MISSING 'END' , END-OF-FILE ENCOUNTERED */
	call WriteLineInfo;
	call WrByte(L$EOF);
	call RewindTx1;
	call TellF(.srcFil, .srcFileTable(srcFileIdx + 8));
	call Backup(.srcFileTable(srcFileIdx + 8), offLastCh - offCurCh);
	call CloseF(.srcFil);
end Sub$3EDF;


Sub$3F23: PROCEDURE local;
	call InitF(.srcFil, .('SOURCE'), .srcFileTable(srcFileIdx));
	call OpenF(.srcFil, 1);
	call SeekF(.srcFil, .srcFileTable(srcFileIdx + 8));
	offCurCh = offLastCh;
	if offNxtCmdChM1 <> 0 then
		do while cmdLine$p <> 0;
			call Do$Control(offNxtCmdChM1 + cmdLine$p);
			offNxtCmdChM1 = 2;
			cmdLine$p = cmd.link;
		end;
	offNxtCmdChM1 = 0;
	curProcData = .curDoBlkCnt;
	inChr$p = .(LF) - 1;
	blockDepth = 1;
	procChains(1) = 0;
	call gnxtch;
end Sub$3F23;

Sub$3FAD: PROCEDURE local;
	call Sub$3F23;
	call Sub$6F00;
end Sub$3FAD;



start:
		state = 20;	/* 9B46 */
		call Sub$3FAD;
resetPt:	call Sub$3EDF;
		call Chain(.overlay1);

END;
src/main1.plm
main1: DO;
$include(:f2:main1.ipx)

DECLARE copyright(*) BYTE DATA('(C) 1976, 1977, 1982 INTEL CORP');
DECLARE cleanup LABEL public;

declare markedStSP address public,
	T2CntForStmt address public,
	curProcInfo$p address public initial(0),
	curStmtNum address public,
	(varInfoOffset, varArrayIndex, varNestedArrayIndex, varVal) address public,
	regetTx1Item byte public initial(FALSE),
	b88B3 byte public initial(FALSE),
	linfo$ LINFO$ST public,
	tx1Item TX1ITEM$ST public,
	tx1Aux2 byte public,
	tx1Aux1 byte public,
	tx1RdBuf(512) byte public,
	tx2Buf(512) byte public,
	xrfBuf(512) byte public,
	atBuf(512) byte public,
	b91C0 byte public;


	Sub$3F19: PROCEDURE;
		call CreatF(.tx1File, .tx1RdBuf, 512, 1);
		call OpenF(.tx2File, 3);
		call CreatF(.tx2File, .tx2Buf, 512, 2);
		if XREF or IXREF or SYMBOLS then
		do;
			call OpenF(.xrfFile, 2);
			call CreatF(.xrfFile, .xrfBuf, 512, 2);
		end;
		call OpenF(.atFile, 3);
		call CreatF(.atFile, .atBuf, 16, 2);
		blockDepth = 1;
		procChains(1) = 0;
	end;

	Sub$3F8B: PROCEDURE;
		if b88B3 then 
			call WrTx2File(.linfo, 7);
		call CloseF(.tx1File);
		call DeletF(.tx1File);
		call OpenF(.tx1File, 3);
		if XREF or IXREF or SYMBOLS then
		do;
			call fwrite(.xrfFile, .(0), 1);
			call Fflush(.xrfFile);
			call CloseF(.xrfFile);
		end;
		call WrAtFileByte(ATI$END);
		call WrAtFileByte(ATI$EOF);
		call Fflush(.atFile);
		call Rewind(.atFile);
	end;


	call Sub$3F19;	/* create files and preload tx1 */
	call Sub$6523;
loop:	
	call Sub$3F8B;
	call Sub$6EE0;
	if hasErrors then 
		call Chain(.overlay6);
	else
		call Chain(.overlay2);

cleanup:
	call WrTx2ExtError(b91C0);
	do while tx1Item.type <> L$EOF;
		if tx1Item.type = L$STMTCNT then
		do;
			T2CntForStmt = 0;
			call MapLToT2;
			curStmtNum = tx1Item.dataw(0);
		end;
		call GetTx1Item;
	end;
	goto loop;
END;
src/main2.plm
main2: DO;
$include(:f2:main2.ipx)

declare wAF54(*) address public initial(
	11Bh, 14Bh, 12Bh, 12Bh, 11Bh, 14Bh, 60h, 60h,
	62h, 62h, 5Bh, 62h, 0Bh, 1E4h, 1E7h, 1E8h,
	1EEh, 1F1h, 8Dh, 0CFh, 10Bh, 0Eh, 12h, 14h,
	0EBh, 0EBh, 0EBh, 0A9h, 9Ah, 96h, 0A1h, 69h,
	68h, 70h, 76h, 90h, 0EBh, 10Bh, 15Bh, 18Bh,
	1BBh, 19Bh, 17Bh, 16Bh, 58h, 19h, 20h, 27h,
	19h, 20h, 27h, 16h, 17h, 18h, 16h, 17h,
	18h, 0Ah, 38h, 3Eh, 67h, 2Ah, 6, 0Ch,
	1DEh, 80h, 43h, 45h, 47h, 1DBh, 49h, 0C9h,
	0CDh, 0CEh, 0B7h, 0BAh, 0BDh, 41h, 42h, 44h,
	46h, 48h, 4Ah, 4Bh, 4Ch, 41h, 42h, 44h,
	46h, 48h, 4Ah, 4Bh, 4Ch, 7Ch, 42h, 44h,
	46h, 48h, 48h, 46h, 44h, 42h, 7Ch, 42h,
	44h, 46h, 48h, 48h, 46h, 44h, 42h, 4Fh,
	42h, 44h, 46h, 48h, 4Ah, 4Dh, 4Eh, 57h,
	50h, 51h, 52h, 53h, 54h, 55h, 56h, 0C0h,
	0C3h, 0C6h, 0CFh, 1DCh, 0, 0	/* wB05C & wB05E assumed at end */
);

declare	tx2Buf(512) byte,
	tx1Buf(512) byte,
	blkCurInfo(20) address public,
	wB488(20) address public,
	wB4B0(20) address public,
	wB4D8(20) address public,
	extProcId(20) byte public,
	procChainNext(20) byte public,
	wB528(10) address public,
	wB53C(10) address public,
	tx2opc(255) byte public initial(T2$SEMICOLON, T2$LOCALLABEL, T2$SEMICOLON, T2$SEMICOLON),
	tx2Aux1b(255) byte public initial(12, 9),
	tx2Aux2b(255) byte public,
	tx2op1(255) address public,
	tx2op2(255) address public,
	tx2op3(255) address public initial(0, 0, 0, 0),
	tx2Auxw(255) address public initial(0, 1),
	bC045(9) byte public,
	bC04E(9) byte public,
	boC057(9) byte public,
	boC060(9) byte public,
	boC069(9) byte public,
	boC072(9) byte public,
	boC07B(9) byte public,
	wC084(9) address public,
	wC096(9) address public,
	bC0A8(9) byte public,
	bC0B1 byte public,
	bC0B2 byte public,
	bC0B3(2) byte public,
	bC0B5(2) byte public,
	bC0B7(2) byte public,
	bC0B9(2) byte public,
	bC0BB(2) byte public,
	bC0BD(2) byte public,
	bC0BF(2) byte public,
	bC0C1(2) byte public,
	bC0C3(125) byte public,
	bC140(125) byte public,
	bC1BD byte public initial (0),
	tx2qp byte public,
	bC1BF byte public initial(4),
	tx2qEnd byte public initial(4),
	pc address public initial(0),
	wC1C3 address public initial(0),
	wC1C5 address public initial(0),
	wC1C7 address public initial(0),
	blkSP byte public initial(0),
	blkOverCnt byte public initial(0),
	procCallDepth byte public initial(0),
	boC1CC byte public initial(0),
	boC1CD byte public,
	eofSeen byte public initial(0),
	wC1CF address public initial(0),
	curOp byte public,
	bC1D2 byte public,
	padC1D3 byte public,
	curExtProcId byte public initial(1),
	procChainId byte public initial(0),
	wC1D6 address public,
	boC1D8 byte public initial(0),
	bC1D9 byte public,
	cfrag1 byte public,
	bC1DB byte public,
	wC1DC(5) address public,
	bC1E6 byte public,
	buf$C1E7(34) byte public,
	bC209(*) byte public initial(4, 5, 3, 2, 0, 1),
	boC20F byte public initial(0);




DECLARE copyRight(*) BYTE DATA('(C) 1976, 1977, 1982 INTEL CORP');

	DECLARE finalise LABEL PUBLIC;

	Sub$3F27: PROCEDURE;
		DECLARE emsg(*) BYTE DATA('COMPILER ERROR: INSUFFICIENT MEMORY FOR CODE GENERATION');
		botMem = .MEMORY + 256;
		if w3822 < botMem then
			call Fatal(.emsg, length(emsg));
		call CreatF(.tx1File, .tx1Buf, 512, 2);
		call CreatF(.tx2File, .tx2Buf, 512, 1);
		call FILLX(10, .wC1DC, 0);
		blkCurInfo(0) = procInfo(1) + botInfo;
		programErrCnt = 0;
	end Sub$3F27;


	Sub$3F7D: PROCEDURE;
		curInfo$p = procInfo(1) + botInfo;
		call SetDimension(pc);
		call SetBaseVal(wC1C5);
		call Fflush(.tx1File);
	end Sub$3F7D;

	call Sub$3F27;
	do while 1;
		call FillTx2Q;
		call Sub$67A9;
		if tx2opc(4) = T2$EOF then
			goto finalise;
		call Sub$689E;
		call Sub$6BD6;
		call Sub$A153;
	end;

	finalise:
		call Sub$3F7D;
		call Chain(.overlay3);
END;
src/main3.plm
main3: DO;
$include(:f2:main3.ipx)
declare copyright(*) byte data('(C) 1976, 1977, 1982 INTEL CORP');

    Sub$3F3C: procedure;
	b7199 = PRINT or OBJECT;
	if OBJECTSet then
	do;
	    call DeletF(.objFile);
	    OBJECTSet = FALSE;
	end;
	if not lfOpen and PRINTSet then
	do;
	    call DeletF(.lstFil);
	    PRINTSet = FALSE;
	end;
	call CloseF(.tx2File);
	call DeletF(.tx2File);
	call CreatF(.tx1File, .tx1Buf, 1280, 2);
	if b7199 or IXREF then
	    call CreatF(.nmsFile, .nmsBuf, 1280, 1);
	call CreatF(.atFile, .atBuf, 1280, 1);
	if OBJECT then
	do;
	    call OpenF(.objFile, 3);
	    call CreatF(.objFile, .objBuf, 1280, 2);
	    call SekEnd(.objFile);
	end;
	w7197 = csegSize;
    end;




    Sub$3FE2: procedure;
	declare p address;
	do p = 1 to procCnt;
	    curInfo$p = procInfo(p) + botInfo;
	    if not TestInfoFlag(F$EXTERNAL) then
	    do;
		call SetLinkVal(w7197);
		w7197 = w7197 + GetDimension2;
	    end;
	end;
    end;



    Sub$402F: procedure;
	declare (p, q) address;
	curInfo$p = botInfo + 2;
	do while curInfo$p <> 0;
	    if GetType = LABEL$T then
	    do;
		if not TestInfoFlag(F$LABEL) then 
			call Sub$49BC(0ACh, curInfo$p - botInfo, 0);
		else if not TestInfoFlag(F$EXTERNAL) then
		do;
			p = GetLinkVal;
			q = curInfo$p;
			curInfo$p = procInfo(high(GetScope)) + botInfo;
			p = p + GetLinkVal;
			curInfo$p = q;
			call SetLinkVal(p);
		end;
	    end;
	    call AdvNxtInfo;
	end;
    end;




    Sub$40B6: procedure;
	declare p address;
	declare memb based w381E(1) byte,
	    localLabels based localLabels$p(1) address;

	do p = 1 to localLabelCnt;
	    curInfo$p = procInfo(memb(p)) + botInfo;
	    localLabels(p) = localLabels(p) + GetLinkVal;
	end;
    end;




    Sub$4105: procedure;
	declare (i, j, k, m) byte, p address;
	declare helpers based helpers$p(1) address;

	if not standAlone then
	    return;

	call fwrite(.tx1File, .(0A4h), 1);
	call fwrite(.tx1File, .procInfo(1), 2);
	curInfo$p = procInfo(1) + botInfo;
	p = w7197 - GetLinkVal;
	call fwrite(.tx1File, .p, 2);
	do i = 0 to 45;
	    k = b42D6(i);
	    j = k + b42A8(i);
	    m = 0;
	    do while k < j;
		if m then
		do;
			helpers(k) = w7197;
			w7197 = w7197 + b4813(k);
		end;
		else if helpers(k) <> 0 then
		do;
			m = 0FFh;
			helpers(k) = w7197;
			w7197 = w7197 + b4813(k);
		end;
		k = k + 1;
	    end;
	end;
    end;



    Sub$4201: procedure;
	declare i byte;

	curSymbol$p = (topSymbol := localLabels$p - 3) - 1;
	call fread(.nmsFile, .i, 1);
	do while i <> 0;
	    curSymbol$p = curSymbol$p - i - 1;
	    cursym.name(0) = i;
	    call fread(.nmsFile, .cursym.name(1), i);
	    call fread(.nmsFile, .i, 1);
	end;
	botSymbol = curSymbol$p + 4;
	botMem = botSymbol;
    end;


    Sub$426E: procedure;

	curInfo$p = botInfo + procInfo(1);
	curSymbol$p = GetSymbol;
	if curSymbol$p = 0 then
	    call RecAddByte(.rec2, 0, 0);
	else 
	    call Sub$48BA(.rec2, 0, cursym.name(0), .cursym.name(1));
	call RecAddByte(.rec2, 0, 1);
	call RecAddByte(.rec2, 0, shl(version(1), 4) or (version(3) and 0fh));
	call RecAddByte(.rec2, 0, 1);
	call RecAddWord(.rec2, 0, csegSize);
	call RecAddByte(.rec2, 0, 3);
	call RecAddByte(.rec2, 0, 2);
	call RecAddWord(.rec2, 0, dsegSize);
	call RecAddByte(.rec2, 0, 3);
	call RecAddByte(.rec2, 0, 3);
	call RecAddWord(.rec2, 0, Sub$4938);
	call RecAddByte(.rec2, 0, 3);
	call RecAddByte(.rec2, 0, 4);
	call RecAddWord(.rec2, 0, 0);
	call RecAddByte(.rec2, 0, 3);
	call WriteRec(.rec2, 0);
    end;


    Sub$436C: procedure;
	declare (p, q) address, (i, j) byte,
	    (r, s) address, (k, m) byte, t(6) byte;
	declare helpers based helpers$p(1) address;

	s = 0;
	curInfo$p = botInfo + 2;
	do while curInfo$p <> 0;
	    curSymbol$p = GetSymbol;
	    if LABEL$T <= GetType and GetType <= PROC$T and curSymbol$p <> 0 then
	    do; 
		if TestInfoFlag(F$EXTERNAL) and not TestInfoFlag(F$AT) then
		do; 
			if rec18.len + cursym.name(0) + 2 >= 299 then
				call WriteRec(.rec18.type, 0);
			s = s + 1;
			call Sub$48BA(.rec18.type, 0, cursym.name(0), .cursym.name(1));
			call RecAddByte(.rec18.type, 0, 0);
		end;
		else if not (TestInfoFlag(F$AUTOMATIC) or TestInfoFlag(F$BASED) or TestInfoFlag(F$MEMBER)) then
		do;
			if TestInfoFlag(F$DATA) or GetType = LABEL$T or GetType = PROC$T then
			do;
				p = .rec16$2;
				q = rec16$2.len;
				i = 1;
			end;
			else if TestInfoFlag(F$MEMORY) then
			do; 
				p = .rec16$4;
				q = rec16$4.len;
				i = 4;
			end;
			else if TestInfoFlag(F$ABSOLUTE) then
			do; 
				p = .rec16$1;
				q = rec16$1.len;
				i = 0;
			end;
			else
			do;
				p = .rec16$3;
				q = rec16$3.len;
				i = 2;
			end;

			if TestInfoFlag(F$PUBLIC) then
			do; 
				if q + cursym.name(0) + 4 >= 299 then
					call WriteRec(p, 1);
				call RecAddWord(p, 1, GetLinkVal);
				call Sub$48BA(p, 1, cursym.name(0), .cursym.name(1));
				call RecAddByte(p, 1, 0);
			end;
			if DEBUG then
			do;
				if curInfo$p = procInfo(1) + botInfo then
					j = true;
				else if not TestInfoFlag(F$PARAMETER) then
					j = TestInfoFlag(F$EXTERNAL);
				else
				do;
					r = curInfo$p;
					curInfo$p = procInfo(high(GetScope)) + botInfo;
					j = TestInfoFlag(F$EXTERNAL);
					curInfo$p = r;
				end;
				if not j then
				do;
					if i <> rec12.val(0) or rec12.len + cursym.name(0) + 4 >= 1019 then
						call WriteRec(.rec12, 1);
					rec12.val(0) = i;
					call RecAddWord(.rec12, 1, GetLinkVal);
					call Sub$48BA(.rec12, 1, cursym.name(0), .cursym.name(1));
					call RecAddByte(.rec12, 1, 0);
				end;
			end;
		end;
	    end;
	    call AdvNxtInfo;
	end; /* of while */

	t(0) = '@';
	t(1) = 'P';
	if not standAlone then
	do;
	    do k = 0 to 116;
		if helpers(k) <> 0 then
		do;
			helpers(k) = s;
			s = s + 1;
			if rec18.len + 8 >= 299 then
				call WriteRec(.rec18, 0);
			m = Num2Asc(k, 0fch, 10, .t(2));
			call Sub$48BA(.rec18, 0, 6, .t);
			call RecAddByte(.rec18, 0, 0);
		end;
	    end;
	end;
	call WriteRec(.rec18, 0);
	call WriteRec(.rec16$1, 1);
	call WriteRec(.rec16$2, 1);
	call WriteRec(.rec16$3, 1);
	call WriteRec(.rec16$4, 1);
	call WriteRec(.rec12, 1);
    end;



    Sub$46B7: procedure;
	declare p address;

	if intVecNum = 0 then
	    return;
	do p = 1 to procCnt;
	    curInfo$p = procInfo(p) + botInfo;
		if TestInfoFlag(F$INTERRUPT) then
		do; 
			rec6.addr = intVecLoc + intVecNum * GetIntrNo;
			call RecAddByte(.rec6, 3, 0C3h);
			call RecAddWord(.rec6, 3, GetLinkVal);
			call WriteRec(.rec6, 3);
			call RecAddWord(.rec24$1, 2, rec6.addr + 1);
			call WriteRec(.rec24$1, 2);
	    end;
	end;
    end;



    Sub$4746: procedure;
	if b7199 or IXREF then
	do;
	    call fwrite(.tx1File, .(9ch), 1);
	    call Fflush(.tx1File);
	    call Rewind(.tx1File);
	    call CloseF(.nmsFile);
	    call DeletF(.nmsFile);
	    call Fflush(.objFile);
	end;
	call CloseF(.atFile);
	call DeletF(.atFile);
    end;

    call Sub$3F3C;
    if b7199 or IXREF then
	call Sub$3FE2;
    call Sub$402F;
    if b7199 or IXREF then
    do;
	call Sub$40B6;
	call Sub$4105;
	csegSize = w7197;
	call Sub$4201;
    end;
    if OBJECT then
    do;
	call Sub$426E;
	call Sub$436C;
	call Sub$46B7;
    end;
    call Sub$49F9;
    call Sub$4746;
    if b7199 then
	call Chain(.overlay4);
    else
    do;
	call CloseF(.tx1File);
	call DeletF(.tx1File);
	if IXREF then
	    call Chain(.overlay5);
	else
	do;
		call EndCompile;
		call Exit;
	end;
    end;
end;
src/main4.plm
main4: DO;
$include(:f2:main4.ipx)

declare copyright(*) byte data('(C) 1976, 1977, 1982 INTEL CORP'),
	objEOF(*) byte data(0eh, 1, 0, 0f1h),
	errCont label public;



	Sub$3FC8: procedure;
		declare cmd BASED cmdLine$p STRUCTURE(link ADDRESS, pstr(1) BYTE);
		if PRINT then
		do;
			call NewPageNextChLst;
			call Xputstr2cLst(.('ISIS-II PL/M-80 ',0), 0);
			call XwrnstrLst(.version, 4);
			call Xputstr2cLst(.(' COMPILATION OF MODULE ',0), 0);
			curInfo$p = botInfo + procInfo(1);
			curSymbol$p = GetSymbol;
			if curSymbol$p <> 0 then
				call XwrnstrLst(.cursym.name(1), cursym.name(0));
			call NewLineLst;
			if OBJECT then
			do; 
				call Xputstr2cLst(.('OBJECT MODULE PLACED IN ',0), 0);
				call Xputstr2cLst(.objFile.fNam, ' ');
			end;
			else
				call Xputstr2cLst(.('NO OBJECT MODULE REQUESTED',0), 0);

			call NewLineLst;
			if w382A = 1 then
			do;
				call Xputstr2cLst(.('COMPILER INVOKED BY:  ',0), 0);
				cmdLine$p = startCmdLine$p;
				do while cmdLine$p <> 0;
					call TabLst(-23);
					call Xputstr2cLst(.cmd.pstr(1), cr);
					cmdLine$p = cmd.link;
				end;
				call NewLineLst;
			end;
		end;
	end;

	Sub$408B: procedure;
		if PRINT then
		do; 
			lBuf$p = .lstbuf;
			lBufSz = 639;
		end;

		call Sub$3FC8;
		if .MEMORY + 256 > botMem then
			call Fatal(.('COMPILER ERROR: INSUFFICIENT MEMORY FOR FINAL ASSEMBLY'), 54);
		stmtNo = 0;
		if PRINT then
		do;
			srcFileIdx = 0;
			call InitF(.srcFil, .('SOURCE'), .srcFileTable(srcFileIdx));
			call OpenF(.srcFil, 1);
		end;

		call CreatF(.tx1File, .tx1buf, 640, 1);
		call CreatF(.objFile, .objbuf, 640, 2);
		curInfo$p = procInfo(1) + botInfo;
		baseAddr, rec6$4.addr = GetLinkVal;
		call SetSkipLst(3);
		call SetMarkerInfo(11, '-', 15);
		if fatalErrorCode > 0 then
		do;
            errData.stmt, errData.info = 0;
			errData.num = fatalErrorCode;
			call EmitError;
			call SetSkipLst(2);
		end;
		listing = PRINT;
		listOff = false;
		codeOn = false;
		programErrCnt, linesRead = 0;
	end;



	Sub$4162: procedure;
		declare helpers based helpers$p(1) address;

		if not standAlone then
			return;
		do helperModId = 0 to 45;
			helperId = b42D6(helperModId);
			endHelperId = helperId + b42A8(helperModId);
			do while helperId < endHelperId;
				if helpers(helperId) <> 0 then
				do;
					baseAddr = helpers(helperId);
					b969C = b4304(helperModId);
					b969D = b4273(b969C);
					call Sub$5FE7(w4919(helperId), b4A03(helperId));
					goto break;
				end;
				helperId = helperId + 1;
			end;
		break:
		end;
	end Sub$4162;

	Sub$4208: procedure;
		if haveModule then
		do; 
			rec4.subtype = 1;
			curInfo$p = procInfo(1) + botInfo;
			rec4.addr = GetLinkVal;
		end;
		else
		do;
			rec4.subtype = 0;
			rec4.addr = 0;
		end;
		call WriteRec(.rec4.type, 0);
	end;


	Sub$423C: procedure;
		linesRead = w812F;
		call Sub$4208;
		call CloseF(.tx1File);
		if OBJECT then
		do;
			call fwrite(.objFile, .objEOF, 4);
			call Fflush(.objFile);
			call CloseF(.objFile);
		end;

		if PRINT then
		do;
			call TellF(.srcFil, .srcFileTable(srcFileIdx + 8));
			call Backup(.srcFileTable(srcFileIdx + 8), offLastCh - offCurCh);
			call CloseF(.srcFil);
			call FlushLstBuf;
		end;

		call DeletF(.tx1File);
	end Sub$423C;


	call Sub$408B;

	do while bo812B;
		call Sub$54BA;
	end;
	call Sub$4162;
	call FlushRecs;
	call LinePrefix;
errCont:
	call Sub$423C;
	if IXREF then
		call Chain(.overlay5);
	if PRINT then
	do;
		if XREF or SYMBOLS then
			call Chain(.overlay5);
		else
			call LstModuleInfo;
	end;
	call EndCompile;
	call Exit;
end;
src/main5.plm
plm5: DO;
$include(:f2:main5.ipx)

declare	lstBuf(1280) byte public,
	maxSymLen byte public,
	dictSize address public,
	w66D2 address public,
	w66D4 address public,
	xrefItem$p address public,
	xrefItem based xrefItem$p(1) address,
	b66D8 byte public initial(0),
	dictionary$p address public,
	dictionary based dictionary$p(1) address,
	dictTop$p address public;

$list

declare copyright(*) byte data('(C) 1976, 1977, 1982 INTEL CORP'),
	dots(*) byte data('. . . . . . . . . . . . . . . . . . . . '),
	dashes(*) byte data('------------------------------------'),
	b3F0B byte public data(0FFh);	/* ixi module header */


	Sub$4121: procedure(str);
		declare str address;
		call NewLineLst;
		call Xputstr2cLst(.('*** WARNING -- ', 0), 0);
		call Xputstr2cLst(str, 0);
		call NewLineLst;
	end;

	LoadDictionary: procedure;
		declare dictItem based dictTop$p address;
		declare symLen based curSymbol$p byte;

		dictionary$p, dictTop$p = botMem;
		dictSize, maxSymLen = 0;
		curInfo$p = botInfo + 2;

		do while 1;
			if GetType < MACRO$T and GetSymbol <> 0 then
			do;
				dictTop$p = dictTop$p + 2;
				if dictTop$p >= botSymbol then
				do;
					call Sub$4121(.('INSUFFICIENT MEMORY FOR FULL DICTIONARY LISTING', 0));
					return;
				end;
				dictSize = dictSize + 1;
				dictItem = curInfo$p;
				call SetScope(0);		/* used for xref Chain */
				curSymbol$p = GetSymbol;
				if symLen > maxSymLen then
					maxSymLen = symLen;
			end;
			call AdvNxtInfo;
			if curInfo$p = 0 then
				return;
		end;
	end;

	CmpSym: procedure(dictItem1, dictItem2) byte;
		declare (dictItem1, dictItem2) address;
		declare (sym1, sym2, sym1str, sym2str) address, (i, j) byte;
		declare len1 based sym1 byte, len2 based sym2 byte;
		declare ch1 based sym1str byte, ch2 based sym2str byte;

		curInfo$p = dictItem1;
		sym1 = GetSymbol;
		sym1str = sym1 + 1;
		curInfo$p = dictItem2;
		sym2 = GetSymbol;
		sym2str = sym2 + 1;
		if len1 < len2 then
		do;
			i = len1;
			j = 0;
		end;
		else if len1 > len2 then
		do;
			i = len2;
			j = 2;
		end;
		else
		do;
			i = len1;
			j = 1;
		end;

		do while i <> 0;
			if ch1 < ch2 then
				return 0;
			if ch1 > ch2 then
				return 2;
			sym1str = sym1str + 1;
			sym2str = sym2str + 1;
			i = i - 1;
		end;
		return j;
	end;


	SortDictionary: procedure;
		declare (p, q, r, s, t, u, v, w, x, y, z) address;

		if dictSize = 1 then
			return;
		r = dictSize / 2;
		s = r + 2;
		t = 1;
		p = 2;
		q = r;
		y = dictSize;
		u = q;
		w = dictionary(u);

		do while 1;
			v = u * 2;
			if v > y then
			do;
				dictionary(u) = w;
				if t = 2 then
				do;
					x = dictionary(1);
					dictionary(1) = dictionary(q);
					dictionary(q) = x;
					if p >= dictSize then
						goto done;
					else
					do;
						p = p + 1;
						q, y = z - p;
						u = 1;
					end;
				end;
				else if p >= r then
				do; 
					t = 2;
					z = dictSize + 2;
					p = 2;
					q, y = dictSize;
					u = 1;
				end;
				else
				do;
					p = p + 1;
					q = s - p;
					y = dictSize;
					u = q;
				end;
				w = dictionary(u);
			end;
			else
			do;
				if v <> y then
					if CmpSym(dictionary(v + 1), dictionary(v)) > 1 then
						v = v + 1;
				if CmpSym(dictionary(v), w) <= 1 then
				do;
					dictionary(u) = w;
					if t = 2 then
					do;
						x = dictionary(1);
						dictionary(1) = dictionary(q);
						dictionary(q) = x;
						if p >= dictSize then
							goto done;
						p = p + 1;
						q, y = z - p;
						u = 1;
					end;
					else if p >= r then
					do;
						t = 2;
						z = dictSize + 2;
						p = 2;
						q, y = dictSize;
						u = 1;
					end;
					else
					do;
						p = p + 1;
						q = s - p;
						y = dictSize;
						u = q;
					end;
					w = dictionary(u);
				end;
				else
				do;
					dictionary(u) = dictionary(v);
					u = v;
				end;
			end;
		end;
	done:
	end;


	PrepXref: procedure;

		LoadXref: procedure;
			declare xrfbuf(128) byte,
				b6783 byte,
				pa(2) address,
				xrefItem based xrefItem$p(1) address;

			call OpenF(.xrfFile, 1);
			call CreatF(.xrfFile, .xrfbuf, 128, 1);
			do while 1;
				call fread(.xrfFile, .b6783, 1);
				if b6783 = 0 then
					goto break;
				call fread(.xrfFile, .pa, 4);
				if b6783 = 42h or XREF then
				do;
					curInfo$p = pa(0) + botInfo;
					xrefItem$p = w66D4 + 1;
					w66D4 = w66D4 + 4;
					if w66D4 > botSymbol then
					do;
						call Sub$4121(.('INSUFFICIENT MEMORY FOR FULL XREF PROCESSING', 0));
						goto break;
					end;
					xrefItem(0) = GetScope;
					call SetScope(xrefItem$p);
					if b6783 = 42h then
						xrefItem(1) = -pa(1);	/* make defn line -ve */
					else
						xrefItem(1) = pa(1);
				end;
			end;
		break:
			call CloseF(.xrfFile);
		end;


		XrefDef2Head: procedure;
			declare (p, q, r) address;

			do p = 1 to dictSize;
				curInfo$p = dictionary(p);
				xrefItem$p = GetScope;
				if xrefItem$p <> 0 then
				do; 
					q = 0;
					call SetScope(0);
					do while xrefItem$p <> 0; 
						r = xrefItem(0);
						if (xrefItem(1) and 8000h) <> 0 then
							q = xrefItem$p;	/* definition */
						else
						do;
							xrefItem(0) = GetScope;
							call SetScope(xrefItem$p);
						end;
						xrefItem$p = r;
					end;

					if q <> 0 then		/* insert definition at head */
					do;
						xrefItem$p = q;
						xrefItem(0) = GetScope;
						call SetScope(xrefItem$p);
					end;
				end;
			end;
		end;


		w66D2 = dictTop$p + 2;
		if w66D2 >= botSymbol then
		do;
			call Sub$4121(.('INSUFFICIENT MEMORY FOR ANY XREF PROCESSING', 0));
			return;
		end;
		w66D4 = w66D2 - 1;
		call LoadXref;
		call XrefDef2Head;
	end;


	PrintRefs: procedure;
		declare (defnCol, addrCol, sizeCol, nameCol, attribCol, refContCol) byte,
			p address, pad byte;

		Sub$480A: procedure;
			declare p address;

			if not XREF then
			do; 
				call NewLineLst;
				return;
			end;

			xrefItem$p = GetScope;
			if xrefItem$p = 0 then
			do;
				call NewLineLst;
				return;
			end;
			call XwrnstrLst(.(': '), 2);
			p = 0;

			do while xrefItem$p <> 0;
				if p <> xrefItem(1) then
				do;
					if PWIDTH < col + 5 then
					do;
						call NewLineLst;
						call TabLst(-refContCol);
					end;
					call TabLst(1);
					call XnumLst(xrefItem(1), 0, 10);
					p = xrefItem(1);
				end;
				xrefItem$p = xrefItem(0);
			end;
			if col <> 0 then
				call NewLineLst;
		end;



		Sub$48A7: procedure;
			declare pstr based curSymbol$p structure(len byte, str(1) byte);

			curSymbol$p = GetSymbol;
			call TabLst(-nameCol);
			call XwrnstrLst(.pstr.str, pstr.len);
			call XwrnstrLst(.dots(pstr.len), attribCol - col - 2);
			call TabLst(1);
		end;

		Sub$48E2: procedure(arg1w, arg2w);
			declare (arg1w, arg2w) address;
			call TabLst(-addrCol);
			call XnumLst(arg1w, 0FCh, 0F0h);
			if arg2w <> 0 then
			do;
				call TabLst(-sizeCol);
				call XnumLst(arg2w, 5, 10);
			end;
		end;


		Sub$4921: procedure;
			xrefItem$p = GetScope;
			if GetType = BUILTIN$T then
				return;
			if xrefItem$p <> 0 and (xrefItem(1) and 8000h) <> 0 then
			do;
				call TabLst(-defnCol);
				call XnumLst(-xrefItem(1), 5, 10); /* defn stored as -ve */
				call SetScope(xrefItem(0));
			end;
			else if not TestInfoFlag(F$LABEL) then
			do;
				call TabLst(-defnCol);
				call XwrnstrLst(.dashes, 5);
			end;
		end;

		Sub$499C: procedure;
			call Xputstr2cLst(.(' EXTERNAL(', 0), 0);
			call XnumLst(GetExternId, 0, 10);
			call XwrnstrLst(.(')'), 1);
		end;


		Sub$49BB: procedure;
			declare (p, q, r) address;
			declare pstr based curSymbol$p structure(len byte, str(1) byte);

			p = curInfo$p;
			call Xputstr2cLst(.(' BASED(', 0), 0);
			curInfo$p = GetBaseOffset;
			if TestInfoFlag(F$MEMBER) then
			do;
				r = GetSymbol;
				curInfo$p = GetParentOffset;
				q = GetSymbol;
			end;
			else
			do;
				q = GetSymbol;
				r = 0;
			end;

			curSymbol$p = q;
			call XwrnstrLst(.pstr.str, pstr.len);
			if r <> 0 then
			do;
				call XwrnstrLst(.('.'), 1);
				curSymbol$p = r;
				call XwrnstrLst(.pstr.str, pstr.len);
			end;
			call XwrnstrLst(.(')'), 1);
			curInfo$p = p;
		end;


		Sub$4A42: procedure;
			declare p address;
			declare pstr based curSymbol$p structure(len byte, str(1) byte);

			p = curInfo$p;
			curInfo$p = GetParentOffset;
			call Xputstr2cLst(.(' MEMBER(', 0), 0);
			curSymbol$p = GetSymbol;
			call XwrnstrLst(.pstr.str, pstr.len);
			call XwrnstrLst(.(')'), 1);
			curInfo$p = p;
		end;

		Sub$4A78: procedure(str);
			declare str address;
			call Sub$4921;
			call Sub$48A7;
			call Xputstr2cLst(str, 0);
			call Sub$480A;
		end;


		Sub$4A92: procedure;
			declare p address;

			call Sub$4921;
			call Sub$48E2(GetLinkVal, GetDimension2);
			call Sub$48A7;
			call Xputstr2cLst(.('PROCEDURE', 0), 0);
			if GetDataType <> 0 then
			do;
				if GetDataType = 2 then
					p = .(' BYTE', 0);
				else
					p = .(' ADDRESS', 0);
				call Xputstr2cLst(p, 0);
			end;
			if TestInfoFlag(F$PUBLIC) then
				call Xputstr2cLst(.(' PUBLIC', 0), 0);

			if TestInfoFlag(F$EXTERNAL) then
				call Sub$499C;

			if TestInfoFlag(F$REENTRANT) then
				call Xputstr2cLst(.(' REENTRANT', 0),0);

			if TestInfoFlag(F$INTERRUPT) then
			do;
				call Xputstr2cLst(.(' INTERRUPT(', 0), 0);
				call XnumLst(GetIntrNo, 0, 10);
				call XwrnstrLst(.(')'), 1);
			end;
			if not TestInfoFlag(F$EXTERNAL) then
			do; 
				call Xputstr2cLst(.(' STACK=', 0), 0);
				call XnumLst(GetBaseVal, 0fch, 0f0h);
			end;
			call Sub$480A;
		end;

		Sub$4B4A: procedure(str);
			declare str address;
			declare p address, i byte;

			call Sub$4921;
			i = GetType;
			if i = BYTE$T then
				p = 1;
			else if i = ADDRESS$T then
				p = 2;
			else if i = LABEL$T then
				p = 0;
			else
				p = GetParentOffset;

			if TestInfoFlag(F$ARRAY) then
				p = p * GetDimension;
			call Sub$48E2(GetLinkVal, p);
			call Sub$48A7;
			call Xputstr2cLst(str, 0);
			if TestInfoFlag(2) then
				call Sub$49BB;
			if TestInfoFlag(F$ARRAY) then
			do;
				call Xputstr2cLst(.(' ARRAY(', 0), 0);
				call XnumLst(GetDimension, 0, 10);
				call XwrnstrLst(.(')'), 1);
			end;
			if TestInfoFlag(F$PUBLIC) then
				call Xputstr2cLst(.(' PUBLIC', 0),0);

			if TestInfoFlag(F$EXTERNAL) then
				call Sub$499C;

			if TestInfoFlag(F$AT) then
				call Xputstr2cLst(.(' AT', 0), 0);
			if TestInfoFlag(F$DATA) then
				call Xputstr2cLst(.(' DATA', 0), 0);
			if TestInfoFlag(F$INITIAL) then
				call Xputstr2cLst(.(' INITIAL', 0), 0);

			if TestInfoFlag(F$MEMBER) then
				call Sub$4A42;

			if TestInfoFlag(F$PARAMETER) then
				call Xputstr2cLst(.(' PARAMETER', 0), 0);

			if TestInfoFlag(F$AUTOMATIC) then
				call Xputstr2cLst(.(' AUTOMATIC', 0), 0);

			if TestInfoFlag(F$ABSOLUTE) then
				call Xputstr2cLst(.(' ABSOLUTE', 0),0);

			call Sub$480A;
		end;

		Sub$4C84: procedure;
			declare pstr based curSymbol$p structure(len byte, str(1) byte);
			
			curSymbol$p = GetSymbol;
			if b66D8 <> pstr.str(0) then
			do;
				call NewLineLst;
				b66D8 = pstr.str(0);
			end;
			if GetType < MACRO$T then
				do case GetType;
					call Sub$4A78(.('LITERALLY', 0));
					call Sub$4B4A(.('LABEL', 0));
					call Sub$4B4A(.('BYTE', 0));
					call Sub$4B4A(.('ADDRESS', 0));
					call Sub$4B4A(.('STRUCTURE', 0));
					call Sub$4A92;
					call Sub$4A78(.('BUILTIN', 0));
				end;
		end Sub$4C84;

/* PrintRefs */
		defnCol = 3;
		addrCol = defnCol + 6;
		sizeCol = addrCol + 6;
		nameCol = sizeCol + 7;
		attribCol = nameCol + maxSymLen + 2;
		refContCol = attribCol + 1;
		call SetMarkerInfo(attribCol, '-', 3);
		call NewPageNextChLst;
		if XREF then
		do;
			call Xputstr2cLst(.('CROSS-REFERENCE LISTING', 0), 0);
			call NewLineLst;
			call XwrnstrLst(.dashes, 23);
			call NewLineLst;
		end;
		else
		do;
			call Xputstr2cLst(.('SYMBOL LISTING', 0), 0);
			call NewLineLst;
			call XwrnstrLst(.dashes, 14);
			call NewLineLst;
		end;
		call SetSkipLst(2);
		call TabLst(-defnCol);
		call Xputstr2cLst(.(' DEFN', 0), 0);
		call TabLst(-addrCol);
		call Xputstr2cLst(.(' ADDR', 0), 0);
		call TabLst(-sizeCol);
		call Xputstr2cLst(.(' SIZE', 0), 0);
		call TabLst(-nameCol);
		call Xputstr2cLst(.('NAME, ATTRIBUTES, AND REFERENCES', 0), 0);
		call NewLineLst;
		call TabLst(-defnCol);
		call XwrnstrLst(.dashes, 5);
		call TabLst(-addrCol);
		call XwrnstrLst(.dashes, 5);
		call TabLst(-sizeCol);
		call XwrnstrLst(.dashes, 5);
		call TabLst(-nameCol);
		call XwrnstrLst(.dashes, 32);
		call NewLineLst;
		call NewLineLst;

		do p = 1 to dictSize;
			curInfo$p = dictionary(p);
			if GetType = BUILTIN$T then
			do;
				if GetScope <> 0 then
					call Sub$4C84;
			end;
			else
				call Sub$4C84;
		end;
	end PrintRefs;






	CreateIxrefFile: procedure;
		declare (p, q, r) address,
			(i, j) byte, ixibuf(128) byte, k byte;
		declare pstr based curSymbol$p structure(len byte, str(1) byte);

		Sub$4EAA: procedure(buf, cnt);
			declare buf address, cnt address;
			call fwrite(.ixiFile, buf, cnt);
		end;


		call OpenF(.ixiFile, 2);
		call CreatF(.ixiFile, .ixibuf, 128, 2);
		curInfo$p = botInfo + procInfo(1);
		curSymbol$p = GetSymbol;
		if curSymbol$p <> 0 then			/* Write the module info */
		do;
			call Sub$4EAA(.b3F0B, 1);
			k = 22 + pstr.len;
			call Sub$4EAA(.k, 1);
			call Sub$4EAA(.pstr.len, 1);		/* module name len */
			call Sub$4EAA(.pstr.str, pstr.len);	/* module name */
		end;
		if low(srcFileTable(0)) = ':' then
			j = 2;
		else
			j = 0;
		call Sub$4EAA(.srcFileTable(j), 10);		/* filename minus any :fx: */
		call Sub$4EAA(.('---------'), 9);

		do p = 1 to dictSize;
			curInfo$p = dictionary(p);
			i = GetType;
			if LABEL$T <= i and i <= PROC$T and 
			   (TestInfoFlag(F$PUBLIC) or (TestInfoFlag(F$EXTERNAL) and not TestInfoFlag(F$AT))) then
			do;
				if TestInfoFlag(F$PUBLIC) then
					call Sub$4EAA(.(0), 1);
				else
					call Sub$4EAA(.(1), 1);

				curSymbol$p = GetSymbol;
				k = 6 + pstr.len;
				call Sub$4EAA(.k, 1);
				call Sub$4EAA(.pstr.len, 1);
				call Sub$4EAA(.pstr.str, pstr.len);
				call Sub$4EAA(.i, 1);
				if GetType = PROC$T then
				do;
					r = GetDataType;
					call Sub$4EAA(.r, 2);
				end;
				else
				do;
					if TestInfoFlag(F$ARRAY) then
						q = GetDimension;
					else
						q = 0;
					call Sub$4EAA(.q, 2);
				end;
			end;
		end;
		call Fflush(.ixiFile);
		call CloseF(.ixiFile);
	end;



	Sub$4EC5: procedure;
		call LoadDictionary;
		call SortDictionary;
		call PrepXref;
		if (XREF or SYMBOLS) and PRINT then
			call PrintRefs;
		if IXREF then
			call CreateIxrefFile;
	end;

	botMem = .MEMORY + 100h;
	topSymbol = topSymbol + 4;
	if PRINT then
	do;
		lBuf$p = .lstBuf;
		lBufSz = 1279;
	end;
	call Sub$4EC5;
	if PRINT then
		call LstModuleInfo;
	call DeletF(.xrfFile);
	call EndCompile;
	call Exit;
end;

src/main6.plm
plm6: DO;
$include(:f2:main6.ipx)

declare copyright(*) byte data('(C) 1976, 1977, 1982 INTEL CORP');
declare errCont label public;

	Sub$3F96: procedure;
		declare cmd BASED cmdLine$p STRUCTURE(link ADDRESS, pstr(1) BYTE);
		if PRINT then
		do;
			call NewPageNextChLst;
			call Xputstr2cLst(.('ISIS-II PL/M-80 ', 0), 0);
			call XwrnstrLst(.version, 4);
			call Xputstr2cLst(.(' COMPILATION OF MODULE ', 0), 0);
			curInfo$p = botInfo + procInfo(1);
			curSymbol$p = GetSymbol;
			if curSymbol$p <> 0 then
				call XwrnstrLst(.cursym.name(1), cursym.name(0));
			call NewLineLst;
			if OBJECT then
				call Xputstr2cLst(.('NO OBJECT MODULE GENERATED', 0), 0);
			else
				call Xputstr2cLst(.('NO OBJECT MODULE REQUESTED', 0), 0);
			call NewLineLst;
			call Xputstr2cLst(.('COMPILER INVOKED BY:  ', 0), 0);
			cmdLine$p = startCmdLine$p;
			do while cmdLine$p <> 0;
				call TabLst(-23);
				call Xputstr2cLst(.cmd.pstr(1), cr);
				cmdLine$p = cmd.link;
			end;
			call NewLineLst;
			call SetSkipLst(3);
		end;
	end;



	Sub$404A: procedure;
		declare tx2Buf(2048) byte,
			nmsBuf(2048) byte,
			lstBuf(2048) byte;

		if PRINT then
		do;
			lbuf$p = .lstBuf;
			lBufSz = 2047;
		end;
		b7AD9 = PRINT or OBJECT;
		if OBJECT then
			call DeletF(.objFile);
		if not lfOpen and PRINTSet then
		do;
			call DeletF(.lstFil);
			PRINTSet = false;
		end;
		call CloseF(.tx1File);
		call DeletF(.tx1File);
		call CreatF(.tx2File, .tx2Buf, 800h, 1);
		if b7AD9 or IXREF then
			call CreatF(.nmsFile, .nmsBuf, 800h, 1);
		stmtNo = 0;
		if PRINT then
		do;
			srcFileIdx = 0;
			call InitF(.srcFil, .('SOURCE'), .srcFileTable(srcFileIdx)); /* note word array used */
			call OpenF(.srcFil, 1);
		end;
		curInfo$p = procInfo(1) + botInfo;
		call SetSkipLst(3);
		call SetMarkerInfo(11, '-', 15);
		if fatalErrorCode > 0 then
		do;
			errData.stmt, errData.info = 0;
			errData.num = fatalErrorCode;
			call EmitError;
			call SetSkipLst(2);
		end;
		listing = PRINT;
		listOff = false;
		codeOn = false;
		programErrCnt, linesRead, csegSize = 0;
	end;

	Sub$4149: procedure;
		topSymbol = localLabels$p - 3;
		curSymbol$p = topSymbol - 1;
		call fread(.nmsFile, .b7ADA, 1);
		do while b7ADA <> 0;
			curSymbol$p = curSymbol$p - b7ADA - 1;
			cursym.name(0) = b7ADA;
			call fread(.nmsFile, .cursym.name(1), b7ADA);
			call fread(.nmsFile, .b7ADA, 1);
		end;
		botSymbol = curSymbol$p + 4;
		botMem = botSymbol;
	end;


	Sub$41B6: procedure;
		call CloseF(.atFile);
		call DeletF(.atFile);
		call CloseF(.tx2File);
		call DeletF(.tx2File);
		if b7AD9 or IXREF then
		do;
			call CloseF(.nmsFile);
			call DeletF(.nmsFile);
		end;
		linesRead = w7AE5;
		if PRINT then
		do;
			call TellF(.srcFil, .srcFileTable(srcFileIdx + 8));
			call Backup(.srcFileTable(srcFileIdx + 8), offLastCh - offCurCh);
			call CloseF(.srcFil);
			call FlushLstBuf;
		end;
	end;

/* 3F3B */
	call Sub$404A;
	if b7AD9 or IXREF then
		call Sub$4149;
	call Sub$3F96;
	do while b7AE4;
		call Sub$42E7;
	end;

	call LinePrefix;

errCont:
	call Sub$41B6;
	if PRINT or IXREF then
	do;
		if XREF or  SYMBOLS or IXREF then
			call Chain(.overlay5);
		else
			call LstModuleInfo;
	end;
	call EndCompile;
	call Exit;
end;
/* split file */
src/page.plm
page: DO;
$include(:f2:page.ipx)

NewPgl: procedure public;
	declare (i, j, k, m) byte,
		pnum(3) byte;

	if not PAGING then
		return;
	call wrcLst(0ch);
	linlft = PAGELEN;
	pageNo = pageNo + 1;
	i = Num2Asc(pageNo, 3, 10, .pnum);
	j = PWIDTH - 41;
	if j < TITLELEN then
		m = j;
	else
		m = TITLELEN;
	call WrnstrLst(.Plm80Compiler, 20);
	call WrnstrLst(.TITLE, m);
	k = j - m + 2;
	do while k <> 0;
		call wrcLst(' ');
		k = k - 1;
	end;
	call WrnstrLst(.DATE, 9);
	call WrnstrLst(.('  PAGE '), 7);
	call WrnstrLst(.pnum, 3);
	call WrnstrLst(.(cr, lf, lf, lf), 4);
	skpCnt = 0;
end;


NlLead: procedure public;
	call Wr2cLst(0d0ah);
	col = 0;
	linlft = linlft - 1;
	if linlft = 0 then
		call NewPgl;
	do while col < wrapMarkerCol;
		call wrcLst(' ');
		col = col + 1;
	end;
	if wrapMarker <> 0 then
	do;
		call wrcLst(wrapMarker);
		col = col + 1;
	end;
	do while col < wrapTextCol;
		call wrcLst(' ');
		col = col + 1;
	end;
end;
end;
src/page1.plm
page: DO;
$include(:f2:page1.ipx)

NewPgl: procedure public;
	declare (i, j, k, m) byte,
		pnum(3) byte;

	if not PAGING then
		return;
	call wrcLst(0ch);
	linlft = PAGELEN;
	pageNo = pageNo + 1;
	i = Num2Asc(pageNo, 3, 10, .pnum);
	j = PWIDTH - 41;
	if j < TITLELEN then
		m = j;
	else
		m = TITLELEN;
	call WrnstrLst(.Plm80Compiler, 20);
	call WrnstrLst(.TITLE, m);
	k = j - m + 2;
	do while k <> 0;
		call wrcLst(' ');
		k = k - 1;
	end;
	call WrnstrLst(.DATE, 9);
	call WrnstrLst(.('  PAGE '), 7);
	call WrnstrLst(.pnum, 3);
	call WrnstrLst(.(cr, lf, lf, lf), 4);
	skpCnt = 0;
end;

end;
src/page2.plm
page: DO;
$include(:f2:page2.ipx)

NlLead: procedure public;
	call Wr2cLst(0d0ah);
	col = 0;
	linlft = linlft - 1;
	if linlft = 0 then
		call NewPgl;
	do while col < wrapMarkerCol;
		call wrcLst(' ');
		col = col + 1;
	end;
	if wrapMarker <> 0 then
	do;
		call wrcLst(wrapMarker);
		col = col + 1;
	end;
	do while col < wrapTextCol;
		call wrcLst(' ');
		col = col + 1;
	end;
end;
end;
src/pdata4.plm
pdata: DO;
/* as this defines the record sizes so override the VALx$SIZE literals */

declare	VAL6$SIZE	literally	'1018',
	VAL8$SIZE	literally	'1021',
	VAL18$SIZE	literally	'300',
	VAL20$SIZE	literally	'1019',
	VAL22$SIZE	literally	'1019',
	VAL24$SIZE	literally	'101';
$include(:f2:pdata4.ipx)

declare (helperModId, endHelperId) byte public,
	listing byte public,
	listOff byte public,
	codeOn byte public,
	locLabStr(32) byte public,		/* used to hold symbol name */
    errData ERR$T public,
	bo812B  byte public initial(true),
	baseAddr address public,
	cfCode byte public,
	w812F address public,
	lineNo address public,
	depth address public,
	stmtNo address public,
	offLastCh address public initial(0),
	offCurCh address public initial(0),
	linePrefixChecked bool public initial(true),
	linePrefixListed bool public initial(true),
	lstLineLen byte public,
	lstLine(130) byte public,
	rec6$4 REC6$ST public initial(6, 0, 1),
	rec22 REC22$ST public initial(22h, 0, 3),
	rec24$1 REC24$ST public initial(24h, 0, 2, 3),
	/* to allow common user defined types add in the extra val buf */
	/* 1019 - VAL24$SIZE => 918 */
	rec24$1$extra(918) byte,
	rec24$2 REC24$ST public initial(24h, 0, 3, 3),
	rec24$3 REC24$ST public initial(24h, 0, 4, 3),
	rec20 REC20$ST public initial(20h, 0, 3),
	rec8 REC8$ST public initial(8, 0, 1),
	rec4 REC4$ST  public initial(4, 4),
	rec4seg byte at(.rec4.seg) initial(1),
	b9692 byte public,
	helperId byte public,
	helperStr(1) byte public,
	ihelperStr(*) byte initial('@P    :'),
	b969C byte public,
	b969D byte public,
	w969E address public,
	wValAry(4) address public,
	sValAry(4) address public,
	b96B0 byte public,
	b96B1(37) byte public,
	b96D6 byte public,
	w96D7 address public,
	curExtId byte public,
	commentStr(1) byte public,
	commentStri(40) byte initial('; '),
	lineLen byte public,
	line(80) byte public,
	opByteCnt byte public,
	opBytes(3) byte public,
	dstRec byte public,
	srcbuf(640) byte public,
	tx1buf(640) byte public,
	objbuf(640) byte public,
	lstbuf(640) byte public;
END;
src/pdata6.plm
pdata: do;
$include(:f2:pdata6.ipx)

declare b7AD9 byte public,
	b7ADA byte public,
	listing byte public,
	listOff byte public,
	codeOn byte public,
    errData ERR$T public,
	b7AE4 byte public initial(true),
	w7AE5 address public,
	lineNo address public,
	depth address public,
	stmtNo address public,
	offLastCh address public initial(0),
	offCurCh address public initial(0),
	linePrefixChecked bool public initial(true),
	linePrefixListed bool public initial(true),
	lstLineLen byte public,
	lstbuf(130) byte public,
	srcbuf(2048) byte public;


end;
src/plm0a.plm
plm0a:
DO;
$include(:f2:plm0a.ipx)

DECLARE	cClass(*) BYTE PUBLIC DATA(
	CC$NONPRINT, CC$NONPRINT, CC$NONPRINT, CC$NONPRINT,
	CC$NONPRINT, CC$NONPRINT, CC$NONPRINT, CC$NONPRINT,
	CC$NONPRINT, CC$WSPACE, CC$NEWLINE, CC$NONPRINT,
	CC$NONPRINT, CC$WSPACE, CC$NONPRINT, CC$NONPRINT,
	CC$NONPRINT, CC$NONPRINT, CC$NONPRINT, CC$NONPRINT,
	CC$NONPRINT, CC$NONPRINT, CC$NONPRINT, CC$NONPRINT,
	CC$NONPRINT, CC$NONPRINT, CC$NONPRINT, CC$NONPRINT,
	CC$NONPRINT, CC$NONPRINT, CC$NONPRINT, CC$NONPRINT,
	CC$WSPACE, CC$INVALID, CC$INVALID, CC$INVALID,
	CC$DOLLAR, CC$INVALID, CC$INVALID, CC$QUOTE,
	CC$LPAREN,  CC$RPAREN,  CC$STAR,  CC$PLUS,
	CC$COMMA,  CC$MINUS, CC$PERIOD,  CC$SLASH,
	CC$BINDIGIT, CC$BINDIGIT, CC$OCTDIGIT, CC$OCTDIGIT,
	CC$OCTDIGIT, CC$OCTDIGIT, CC$OCTDIGIT, CC$OCTDIGIT,
	CC$DECDIGIT, CC$DECDIGIT, CC$COLON, CC$SEMICOLON,
	CC$LESS, CC$EQUALS, CC$GREATER, CC$INVALID,
	CC$INVALID, CC$HEXCHAR, CC$HEXCHAR, CC$HEXCHAR,
	CC$HEXCHAR, CC$HEXCHAR, CC$HEXCHAR, CC$ALPHA,
	CC$ALPHA, CC$ALPHA, CC$ALPHA, CC$ALPHA,
	CC$ALPHA, CC$ALPHA, CC$ALPHA, CC$ALPHA,
	CC$ALPHA, CC$ALPHA, CC$ALPHA, CC$ALPHA,
	CC$ALPHA, CC$ALPHA, CC$ALPHA, CC$ALPHA,
	CC$ALPHA, CC$ALPHA, CC$ALPHA, CC$INVALID,
	CC$INVALID, CC$INVALID, CC$INVALID, CC$INVALID,
	CC$INVALID, CC$HEXCHAR, CC$HEXCHAR, CC$HEXCHAR,
	CC$HEXCHAR, CC$HEXCHAR, CC$HEXCHAR, CC$ALPHA,
	CC$ALPHA, CC$ALPHA, CC$ALPHA, CC$ALPHA,
	CC$ALPHA, CC$ALPHA, CC$ALPHA, CC$ALPHA,
	CC$ALPHA, CC$ALPHA, CC$ALPHA, CC$ALPHA,
	CC$ALPHA, CC$ALPHA, CC$ALPHA, CC$ALPHA,
	CC$ALPHA, CC$ALPHA, CC$ALPHA, CC$INVALID,
	CC$INVALID, CC$INVALID, CC$INVALID, CC$NONPRINT
	);

DECLARE tok2oprMap(*) BYTE PUBLIC DATA(
	L$VARIABLE, L$NUMBER, L$STRING, L$PLUSSIGN,
	L$MINUSSIGN, L$STAR, L$SLASH, L$MOD,
	L$PLUS, L$MINUS, L$AND, L$OR,
	L$XOR, L$NOT, 0, L$LT,
	L$LE, L$EQ, L$NE, L$GE,
	L$GT, L$COLONEQUALS, L$INVALID, L$INVALID,
	L$PERIOD, L$LPAREN, L$RPAREN, L$COMMA,
	L$CALL, L$INVALID, L$DISABLE, L$INVALID,
	L$ENABLE, L$END, L$GO, L$GOTO,
	L$HALT, L$IF, L$PROCEDURE, L$RETURN,
	L$INVALID, L$INVALID, L$INVALID, L$INVALID,
	L$INVALID, L$INVALID, L$INVALID, L$INVALID,
	L$INVALID, L$INVALID, L$INVALID, L$INVALID,
	L$INVALID, L$BY, L$INVALID, L$INVALID,
	L$INVALID, L$INVALID, L$TO, L$INVALID);


/* public variables */
DECLARE	macroPtrs(12) ADDRESS /* six inChr$p, info$p pairs */ PUBLIC,
	macroDepth ADDRESS PUBLIC INITIAL(0),
	tokenVal ADDRESS PUBLIC,
	inChr$p ADDRESS PUBLIC,
	stateStack(100) ADDRESS PUBLIC,
	stateIdX ADDRESS PUBLIC,
	stmtLabels(10) ADDRESS PUBLIC,
	stmtLabelCnt ADDRESS PUBLIC,
	curProcInfo$p ADDRESS PUBLIC,
	pad8FA1 ADDRESS,
	offCurCh ADDRESS PUBLIC INITIAL(0),
	offLastCh ADDRESS PUBLIC INITIAL(0),
	curStmtCnt ADDRESS PUBLIC INITIAL(0),
	curBlkCnt ADDRESS PUBLIC INITIAL(0),
	curMacroInfo$p ADDRESS PUBLIC INITIAL(0),
	markedSymbol$p ADDRESS PUBLIC INITIAL(0),
	lineBuf(128) BYTE PUBLIC,
	inbuf(1280) BYTE PUBLIC,
	tokenType BYTE PUBLIC,
	tokenStr(256) BYTE PUBLIC INITIAL(0),
	lastch BYTE PUBLIC,
	stmtStartCode BYTE PUBLIC,
	labelBrkToken BYTE PUBLIC,
	lblBrkTxiCode BYTE PUBLIC,
	doBlkCnt ADDRESS PUBLIC INITIAL(0),
	tx1Buf(1280) BYTE PUBLIC,
	labelBrkSymbol ADDRESS PUBLIC,
	lineInfoToWrite BYTE PUBLIC INITIAL(FALSE),
	isNonCtrlLine BYTE PUBLIC INITIAL(FALSE),
	yyAgain BYTE PUBLIC INITIAL(FALSE),
	linfo LINFO$ST PUBLIC INITIAL(0, 0),
	(curDoBlkCnt, curProcId) BYTE PUBLIC INITIAL(0, 0),
	curProcData ADDRESS PUBLIC,
	state BYTE PUBLIC,
	skippingCOND BYTE PUBLIC INITIAL(FALSE),
	ifDepth ADDRESS PUBLIC INITIAL(0);
	

CreateTxi1File:	PROCEDURE PUBLIC;
	DECLARE tmp ADDRESS;

	tmp = tx1File.curoff;
	call OpenF(.tx1File, 3);
	call CreatF(.tx1File, .tx1Buf, 1280, 2);
	tx1File.curoff = tmp;
end CreateTxi1File;

WriteTx1: PROCEDURE(buf, len) PUBLIC;
	DECLARE (buf, len) ADDRESS;

	if tx1File.aftn = 0 then
		if tx1File.curoff > 1024 then
			call CreateTxi1File;
		else
		do;
			call movmem(len, buf, .tx1Buf(tx1File.curoff));
			tx1File.curoff = tx1File.curoff + len;
			return;
		end;
	call fwrite(.tx1File, buf, len);
end WriteTx1;

RewindTx1: PROCEDURE PUBLIC;
	if tx1File.aftn = 0 then
		call CreateTxi1File;
	call Fflush(.tx1File);
	call Rewind(.tx1File);
end RewindTx1;


WriteLineInfo: PROCEDURE PUBLIC;
	if lineInfoToWrite then
	do;
		call WriteTx1(.linfo, 7);
		lineInfoToWrite = FALSE;
	end;
end WriteLineInfo;


WrBuf: PROCEDURE(buf, len) PUBLIC;
	DECLARE (buf, len) ADDRESS;

	call WriteLineInfo;
	call WriteTx1(buf, len);
end WrBuf;

WrByte: PROCEDURE(v) PUBLIC;
	DECLARE v BYTE;

	call WrBuf(.v, 1);
end WrByte;



WrWord: PROCEDURE(v) PUBLIC;
	DECLARE v ADDRESS;

	call WrBuf(.v, 2);
end WrWord;


WrInfoOffset: PROCEDURE(addr) PUBLIC;
	DECLARE addr ADDRESS;

	call WrWord(addr - botInfo);
end WrInfoOffset; 

SyntaxError: PROCEDURE(err) PUBLIC;
	DECLARE err BYTE;
	hasErrors = TRUE;
	call WrByte(L$SyntaxError);
	call WrWord(err);
end SyntaxError;


TokenErrorAt: PROCEDURE(err) PUBLIC;
	DECLARE err BYTE;

	hasErrors = TRUE;
	call WrByte(L$TokenError);
	call WrWord(err);
	call WrWord(markedSymbol$p);
end TokenErrorAt;


TokenError: PROCEDURE(err, sym$p) PUBLIC;
	DECLARE err BYTE, sym$p ADDRESS;

	hasErrors = TRUE;
	call WrByte(L$TokenError);
	call WrWord(err);
	call WrWord(sym$p);
end TokenError;


FatalError: PROCEDURE(err) PUBLIC;
	DECLARE err BYTE;

	hasErrors = TRUE;
	if state <> 20 then
	do;
		if err = ERR83 then	/* LIMIT EXCEEDED: DYNAMIC STORAGE */
			call Fatal(.('DYNAMIC STORAGE OVERFLOW'), 24);
		call Fatal(.('UNKNOWN FATAL ERROR'), 19);
	end;
	call TokenErrorAt(err);
	fatalErrorCode = err;
	goto resetPt;
end FatalError;

PushBlock: PROCEDURE(idAndLevel) PUBLIC;
	DECLARE idAndLevel ADDRESS;

	if blockDepth = 34 then
		call FatalError(ERR84);	/* LIMIT EXCEEDED: BLOCK NESTING */
	else
	do;
		procChains(blockDepth := blockDepth + 1) = idAndlevel;
		curBlkCnt = curBlkCnt + 1;
	end;
end PushBlock;

PopBlock:	PROCEDURE PUBLIC;
	DECLARE procDW BASED curProcData ADDRESS;
	if blockDepth = 0 then
		call FatalError(ERR96);	/* COMPILER Error: SCOPE STACK UNDERFLOW */
	else
	do;
		curBlkCnt = curBlkCnt - 1;
		procDW = procChains(blockDepth := blockDepth - 1);
	end;
end PopBlock;



WrOprAndValue:	PROCEDURE PUBLIC;
	if tok2oprMap(tokenType) = L$INVALID then
	do;
		call TokenErrorAt(ERR171);	/* INVALID USE OF DELIMITER OR RESERVED WORD IN EXPRESSION */
		return;
	end;
	call WrByte(tok2oprMap(tokenType));
	if tokenType = T$VARIABLE then
		call WrWord(curSymbol$p);
	else if tokenType = T$NUMBER then
		call WrWord(tokenVal);
	else if tokenType = T$STRING then
	do;
		call WrWord(tokenstr(0));
		call WrBuf(.tokenStr(1), tokenstr(0));
	end;
end WrOprAndValue;


WrXrefUse: PROCEDURE PUBLIC;
	if XREF then
	do;
		call WrByte(L$XREFINFO);
		call WrInfoOffset(curInfo$p);
	end;
end;


WrXrefDef: PROCEDURE PUBLIC;
	if XREF or IXREF or SYMBOLS then
	do;
		call WrByte(L$XREF);
		call WrInfoOffset(curInfo$p);
	end;
end;

END;
src/plm0b.plm
plm0b:
DO;
$include(:f2:plm0b.ipx)

DECLARE opttable(*) BYTE DATA(
	5,'PRINT', 0, 0, 0FFh, 7, 0,
	7,'NOPRINT', 0, 0, 0FFh, 8, 0,
	4,'LIST', 3, 1, 0, 0, 0,
	6,'NOLIST', 4, 1, 0, 0, 0,
	4,'CODE', 5, 1, 0, 0, 0,
	6,'NOCODE', 6, 1, 0, 0, 0,
	4,'XREF', 0, 0, 1, 1, 1,
	6,'NOXREF', 0, 0, 1, 0, 1,
	7,'SYMBOLS', 0, 0, 2, 1, 2,
	9,'NOSYMBOLS', 0, 0, 2, 0, 2,
	5,'DEBUG', 0, 0, 3, 1, 3,
	7,'NODEBUG', 0, 0, 3, 0, 3,
	6,'PAGING', 0, 0, 4, 1, 4,
	8,'NOPAGING', 0, 0, 4, 0, 4,
	10,'PAGELENGTH', 0, 0, 0FFh, 0, 5,
	9,'PAGEWIDTH', 0, 0, 0FFh, 1, 6,
	4,'DATE', 0, 0, 0FFh, 2, 7,
	5,'TITLE', 0, 0, 0FFh, 3, 8,
	5,'EJECT', 7, 1, 0, 0, 0,
	10,'LEFTMARGIN', 0, 1, 0FFh, 4, 0,
	6,'OBJECT', 0, 0, 0FFh, 5, 9,
	8,'NOOBJECT', 0, 0, 0FFh, 9, 9,
	8,'OPTIMIZE', 0, 0, 6, 1, 0Ah,
	10,'NOOPTIMIZE', 0, 0, 6, 0, 0Ah,
	7,'INCLUDE', 0, 1, 0FFh, 6, 0,
	9,'WORKFILES', 0, 0, 0FFh, 0Ah, 0Bh,
	9,'INTVECTOR', 0, 0, 0FFh, 0Bh, 0Ch,
	11,'NOINTVECTOR', 0, 0, 0FFh, 0Ch, 0Ch,
	5,'IXREF', 0, 0, 0FFh, 0Dh, 0Dh,
	7,'NOIXREF', 0, 0, 0FFh, 0Eh, 0Dh,
	4,'SAVE', 0, 1, 0FFh, 0Fh, 0,
	7,'RESTORE', 0, 1, 0FFh, 10h, 0,
	3,'SET', 0, 1, 0FFh, 11h, 0,
	5,'RESET', 0, 1, 0FFh, 12h, 0,
	2,'IF', 0, 1, 0FFh, 13h, 0,
	6,'ELSEIF', 0, 1, 0FFh, 14h, 0,
	4,'ELSE', 0, 1, 0FFh, 14h, 0,
	5,'ENDIF', 0, 1, 0FFh, 15h, 0,
	4,'COND', 0, 1, 0FFh, 16h, 0,
	6,'NOCOND', 0, 1, 0FFh, 17h, 0,
	0);

DECLARE ebadTail(*) BYTE DATA('ILLEGAL COMMAND TAIL SYNTAX OR VALUE');
DECLARE ebadcontrol(*) BYTE DATA('UNRECOGNIZED CONTROL IN COMMAND TAIL');
DECLARE errNotDisk(*) BYTE DATA('INCLUDE FILE IS NOT A DISKETTE FILE'),
	errWorkFiles(*) BYTE DATA('MISPLACED CONTROL: WORKFILES ALREADY OPEN');



DECLARE	primaryCtrlSeen(14) BYTE INITIAL(0,0,0,0,0,0,0,0,0,0,0,0,0,0),
	saveStack(5) STRUCTURE(code BYTE, list BYTE, cond BYTE, leftmargin ADDRESS),
	saveDepth BYTE INITIAL(0),
	CODE BYTE INITIAL(FALSE),
	LIST BYTE INITIAL(TRUE),
	COND BYTE INITIAL(TRUE),
	curCh$p ADDRESS,
	chrClass BYTE,
	tknLen BYTE,
	optStrVal$p ADDRESS,
	optNumValue ADDRESS,
	optFileName(16) BYTE,
	ixiGiven BYTE,
	objGiven BYTE,
	lstGiven BYTE,
	inIFpart BYTE,
	skippingCONDDepth ADDRESS,
	tknFlags$p ADDRESS,	
	tknFlags BASED tknFlags$p STRUCTURE(tokenId BYTE, primary BYTE,
			controlId BYTE, controlVal BYTE, primaryId BYTE);
	
DECLARE curCh BASED curCh$p BYTE;

NxtCh: PROCEDURE PUBLIC;
	if chrClass = CC$NEWLINE then
		return;
	curCh$p = curCh$p + 1;
	if curCh = CR or (offNxtCmdChM1 <> 0 and curCh = '&') then
		chrClass = CC$NEWLINE;
	else if (chrClass := cClass(curCh)) = CC$NONPRINT then
		curCh = ' ';
	if curCh >= 'a' then
		curCh = curCh and 5fh;
end NxtCh;
	

BadCmdTail: PROCEDURE(err) PUBLIC;
	DECLARE err BYTE;

	if offNxtCmdChM1 <> 0 then
		call Fatal(.ebadTail, length(ebadTail));
	else
		call SyntaxError(err);
end;


UnknownCtrl: PROCEDURE PUBLIC;

	if offNxtCmdChM1 <> 0 then
		call Fatal(.ebadcontrol, length(ebadcontrol));
	else
		call SyntaxError(ERR9);	/* INVALID CONTROL */
end;


SkipWhite: PROCEDURE PUBLIC;
	do while curCh = ' ';
		call NxtCh;
	end;
end;


SkipToRPARorEOL: PROCEDURE PUBLIC;
	do while curCh <> CR and curCh <> ')';
		call NxtCh;
	end;
	if curCh = ')' then
		call NxtCh;
end;	

AcceptRP: PROCEDURE PUBLIC;
	call SkipWhite;
	if curCh <> ')' then
	do;
		call BadCmdTail(ERR12);	/* INVALID CONTROL PARAMETER */
		call SkipToRPARorEOL;
	end;
	else
		call NxtCh;
end;

AcceptOptStrVal: PROCEDURE local;
	DECLARE nesting BYTE;
	nesting = 0;
	call SkipWhite;
	if curCh <> '(' then
		tknLen = 0;
	else
	do;
		call NxtCh;
		optStrVal$p = curCh$p;
		loop:
			if chrClass = CC$NEWLINE or curCh = '''' then
				goto done;
			if curCh = '(' then
				nesting = nesting + 1;
			else if curCh = ')' then
			do;
				if nesting = 0 then
					goto done;
				nesting = nesting - 1;
			end;
			call NxtCh;
			goto loop;
		done:
		tknLen = curCh$p - optStrVal$p;
		call AcceptRP;
	end;			

end AcceptOptStrVal;

AcceptFileName:	PROCEDURE local;
	call SkipWhite;
	if curCh <> '(' then
		tknLen = 0;
	else
	do;
		call NxtCh;
		call SkipWhite;
		optStrVal$p = curCh$p;
		do while curCh <> ' ' and curCh <> ')' and chrClass <> CC$NEWLINE;
			call NxtCh;
		end;
		tknLen = curCh$p - optStrVal$p;
		if tknLen > 14 then
		do;
			call BadCmdTail(ERR17);	/* INVALID PATH-NAME */
			tknLen = 0;
		end;
		else
		do;
			call FILL(16, .optFileName, ' ');
			call movmem(tknLen, optStrVal$p, .optFileName);
			optStrVal$p = .optFileName;
			tknLen = tknLen + 1;
		end;
		call AcceptRP;
	end;
end;


Asc2Num: PROCEDURE(firstch$p, lastch$p, radix) ADDRESS local;
	DECLARE (firstch$p, lastch$p) ADDRESS, radix BYTE;
	DECLARE num ADDRESS, digit BYTE, trial ADDRESS;
	DECLARE firstch BASED firstch$p BYTE;
	
    if lastch$p < firstch$p or radix = 0 then
		return 0ffffh;
	
    num = 0;
    do while firstch$p <= lastch$p;
	if cClass(firstch) <= CC$DECDIGIT then
		digit = firstch - '0';
	else if cClass(firstch) < CC$ALPHA then
		digit = firstch - '7';
	else
		return 0ffffh;
	if digit >= radix then
		return 0ffffh;
	if (trial := num * radix + digit) < digit or (num * radix + digit - digit) / radix <> num then
		return 0ffffh;
	num = trial;
	firstch$p = firstch$p + 1;
    end;
    return num;
end;

ChkRadix: PROCEDURE(p$lastch) BYTE local;
	DECLARE p$lastch ADDRESS;
	DECLARE lastch BASED p$lastch ADDRESS;
	DECLARE p ADDRESS;
	DECLARE ch BASED p BYTE;

	p = lastch;
	if cClass(ch) <= CC$DECDIGIT then
		return 10;
	lastch = lastch - 1;
	if ch = 'B' then
		return 2;
	if ch = 'Q' or ch = 'O' then
		return 8;
	if ch = 'H' then
		return 16;
	if ch = 'D' then
		return 10;
	else
		return 0;
end;

ParseNum: PROCEDURE ADDRESS local;
	DECLARE (firstch, lastch) ADDRESS;
	DECLARE radix BYTE;

	call NxtCh;
	call SkipWhite;
	firstch = curCh$p;
	do while chrClass <= CC$ALPHA;
		call NxtCh;
	end;	
	lastch = curCh$p - 1;
	call SkipWhite;
	radix = ChkRadix(.lastch);
	return Asc2Num(firstch, lastch, radix);
end;

GetOptNumVal: PROCEDURE local;
	call SkipWhite;
	optNumValue = 0;
	if curCh <> '(' then
		call BadCmdTail(Err11);
	else
	do;
		optNumValue = ParseNum;
		call AcceptRP;
	end;
end;


GetToken: PROCEDURE local;
	optStrVal$p = curCh$p;
	do while curCh <> ' ' and curCh <> '(' and chrClass <> CC$NEWLINE;
		call NxtCh;
	end;
	tknLen = curCh$p - optStrVal$p;
end;



ParseWord: PROCEDURE(maxlen) local;
	DECLARE maxlen BYTE;
    	DECLARE pstr(33) BYTE;
	
	optStrVal$p = .pstr(1);
	tknLen = 0;
	call SkipWhite;
	if chrClass = CC$HEXCHAR or chrClass = CC$ALPHA then
		do while chrClass <= CC$ALPHA or chrClass = CC$DOLLAR;
			if chrClass <> CC$DOLLAR and tknLen <= maxlen then
			do;
				pstr(tknLen + 1) = curCh;
				tknLen = tknLen + 1;
			end;
			call NxtCh;
		end;
	if tknLen > maxlen then
		pstr(0) = maxlen;
	else
		pstr(0) = tknLen;
end;


GetVal:	PROCEDURE local;
	DECLARE tmp ADDRESS;
	tmp = curCh$p - 1;
	call ParseWord(31);
	if tknLen = 0 then
	do;
		curInfo$p = 0FFFFh;
		curCh$p = tmp;
		chrClass = 0;
		call NxtCh;
		return;
	end;
	if tknlen > 31 then
	do;
		tknlen = tknlen - 1;
		call BadCmdTail(ERR184);	/* CONDITIONAL COMPILATION PARAMETER NAME TOO LONG */
	end;
	call Lookup(optStrVal$p - 1);
	if HIGH(cursym.info$p) = 0FFH then	/* special */
	do;
		curInfo$p = 0FFFFh;
		curCh$p = tmp;
		chrClass = 0;
		call NxtCh;
		return;
	end;

	call FindScopedInfo(1);
end;


GetLogical: PROCEDURE BYTE local;
	call ParseWord(3);
	if tknLen = 0 and chrClass = CC$NEWLINE then
		return 0;
	if tknLen = 2 then
	do;
		if Strncmp(optStrVal$p, .('OR'), 2) = 0 then
			return 1;
	end;
	else if tknLen = 3 then
		if Strncmp(optStrVal$p, .('AND'), 3) = 0 then
			return 2;
		else if Strncmp(optStrVal$p, .('XOR'), 3) = 0 then
			return 3;
	
	call BadCmdTail(ERR185);	/* MISSING OPERATOR IN CONDITIONAL COMPILATION EXPRESSION */
	call SkipToRPARorEOL;
	return 4;
end;


GetTest: PROCEDURE BYTE local;
	DECLARE test BYTE;

	test = 0;
	call SkipWhite;
	if curCh = '<' then
	do;
		call NxtCh;
		if curCh = '>' then
		do;
			call NxtCh;
			return 6;
		end;
		test = 2;
	end;
	else if curCh = '>' then
	do;
		call NxtCh;
		test = 4;
	end;
	if curCh = '=' then
	do;
		call NxtCh;
		test = test + 1;
	end;
	return test;
end;

ChkNot: PROCEDURE bool local;
	DECLARE notStatus BYTE, tmp ADDRESS;

	notStatus = FALSE;

	do while (1);
		tmp = curCh$p - 1;
		call ParseWord(3);
		if tknLen <> 3 or Strncmp(optStrVal$p, .('NOT'), 3) <> 0 then
		do;
			curCh$p = tmp;
			return notStatus;
		end;
		notStatus = not notStatus;
	end;
end;

GetIfVal: PROCEDURE ADDRESS local;
	DECLARE val ADDRESS;

	chrClass = 0;
	call NxtCh;
	call SkipWhite;
	if chrClass < CC$HEXCHAR then
	do;
		curCh$p = curCh$p - 1;
		val = ParseNum;
		if val > 255 then
			call BadCmdTail(ERR186);	/* INVALID CONDITIONAL COMPILATION CONSTANT, TOO LARGE */
		return low(val);
	end;
	else
	do;
		call GetVal;
		if curInfo$p = 0ffffh then
		do;
			call BadCmdTail(ERR180);	/* MISSING OR INVALID CONDITIONAL COMPILATION PARAMETER */
			call SkipToRPARorEOL;
			return 256;
		end;
		else if curInfo$p = 0 then
		do;
			return 0;
		end;
		else
			return GetCondFlag;
	end;
end;

ParseIfCond: PROCEDURE bool local;
	DECLARE (andFactor, orFactor, xorFactor) BYTE;
	DECLARE (val1, val2) ADDRESS;
	DECLARE (relOp, not1, not2) BYTE;

	andFactor = TRUE;
	orFactor = FALSE;
	xorFactor = FALSE;
	
	do while (1);
		not1 = ChkNot;
		val1 = GetIfVal;
		if val1 > 255 then
			return TRUE;
		
		relOp = GetTest;
		if relOp > 0 then
		do;
			not2 = ChkNot;
			val2 = GetIfVal;
			if val2 > 255 then
				return TRUE;
			val2 = not2 xor val2;
			do case relOp - 1;
			val1 = val1 = val2;
			val1 = val1 < val2;
			val1 = val1 <= val2;
			val1 = val1 > val2;
			val1 = val1 >= val2;
			val1 = val1 <> val2;
			end;
		end;
		val1 = (not1 xor val1) and andFactor;
		andFactor = TRUE;
		do case GetLogical;
		return (val1 or orFactor) xor xorFactor;
		do;
			orFactor = (val1 or orFactor) xor xorFactor; 
			xorFactor = FALSE;
		end;
		andFactor = val1;
		do;
			xorFactor = (val1 or orFactor) xor xorFactor;
			orFactor = FALSE;
		end;
		return TRUE;
		end;
	end;
end;


OptPageLen: PROCEDURE local;
	call GetOptNumVal;
	if optNumValue < 4 or optNumValue = 0FFFFH then
		call BadCmdTail(ERR91);	/* ILLEGAL PAGELENGTH CONTROL VALUE */
	else
		call SetPageLen(optNumValue - 3);
end;

OptPageWidth: PROCEDURE local;
	call GetOptNumVal;
	if optNumValue < 60 or optNumValue = 0FFFFH then
		call BadCmdTail(ERR92);	/* ILLEGAL PAGEWIDTH CONTROL VALUE */
	else if optNumValue > 132 then
		call BadCmdTail(ERR92);	/* ILLEGAL PAGEWIDTH CONTROL VALUE */
	else
		call SetPageWidth(optNumValue);
end;

OptDate: PROCEDURE local;
	call AcceptOptStrVal;
	call SetDate(optStrVal$p, tknLen);
end;

OptTitle: PROCEDURE local;

	LocalSetTitle: PROCEDURE BYTE;
		DECLARE len BYTE;
		call NxtCh;
		if curCh <> '''' then
			return 0;
		len = 0;
		do while 1;
			call NxtCh;
			if curCh = CR then
				goto done;
			if curCh = '''' then
			do;
				call NxtCh;
				if curCh <> '''' then
					goto done;
			end;
			if len <= 59 then
			do;
				TITLE(len) = curCh;
				len = len + 1;
			end;
		end;
	done:	if len <> 0 then
			TITLELEN = len;
		else
		do;
			TITLELEN = 1;
			TITLE(0) = ' ';
		end;
		if curch <> ')' then
			return 0;
		else
		do;
			call NxtCh;
			return TRUE;
		end;
	end;

	call SkipWhite;
	if curCh <> '(' then
	do;
		call BadCmdTail(ERR11);	/* MISSING CONTROL PARAMETER */
		return;
	end;
	if not LocalSetTitle then
	do;
		call BadCmdTail(ERR12);	/* INVALID CONTROL PARAMETER */
		call SkipToRPARorEOL;
	end;
end;


OptLeftMargin:	PROCEDURE local;
	call GetOptNumVal;
	if optNumValue = 0 then
	do;
		call BadCmdTail(ERR12);	/* INVALID CONTROL PARAMETER */
		optNumValue = 1;
	end;
	else if optNumValue = 0FFFFh then
	do;
		call BadCmdTail(ERR12);	/* INVALID CONTROL PARAMETER */
		return;
	end;
	LEFTMARGIN = optNumValue;
end;

OptIXRef: PROCEDURE local;
	call AcceptFileName;
	if tknLen <> 0 then
		call InitF(.ixiFile, .('IXREF '), optStrVal$p);
	else
		call InitF(.ixiFile, .('IXREF '), .ixiFileName);
	IXREFSet = TRUE;
	IXREF = TRUE;
	call OpenF(.ixiFile, 2);
	ixiGiven = TRUE;
end;

OptObject: PROCEDURE local;
	call AcceptFileName;
	if tknLen <> 0 then
		call InitF(.objFile, .('OBJECT'), optStrVal$p);
	else
		call InitF(.objFile, .('OBJECT'), .objFileName);
	objBlk, objByte = 0;
	OBJECT = TRUE;
	OBJECTSet = TRUE;
	call OpenF(.objFile, 2);
	objGiven = TRUE;
end;

OptInclude: PROCEDURE local;
	call AcceptFileName;
	if tknLen = 0 then
	do;
		call BadCmdTail(ERR15);	/* MISSING INCLUDE CONTROL PARAMETER */
		return;
	end;
	if optFileName(0) = ':' then
	do;
		if optFileName(1) <> 'F' then
			if offNxtCmdChM1 <> 0 then
				call Fatal(.errNotDisk, length(errNotDisk));
			else
				call FatalError(ERR98);	/* INCLUDE FILE IS NOT A DISKETTE FILE */
	end;
	if srcFileIdx >= 50 then
		call SyntaxError(ERR13);	/* LIMIT EXCEEDED: INCLUDE NESTING */
	else
	do;
		call TellF(.srcFil, .srcFileTable(srcFileIdx + 8));
		call Backup(.srcFileTable(srcFileIdx + 8), offLastCh - offCurCh);
		srcFileIdx = srcFileIdx + 10;
		call movmem(tknLen, optStrVal$p, .srcFileTable(srcFileIdx));
		call CloseF(.srcFil);
		call InitF(.srcFil, .('SOURCE'), optStrVal$p);
		call OpenF(.srcFil, 1);
		offCurCh = offLastCh;
		call WrByte(L$INCLUDE);
		call WrBuf(optStrVal$p + 12, 6);
		call WrByte(L$INCLUDE);
		call WrBuf(optStrVal$p + 6, 6);
		call WrByte(L$INCLUDE);
		call WrBuf(optStrVal$p, 6);
	end;
	call SkipWhite;
	if curCh <> CR then
		call BadCmdTail(ERR14);	/* INVALID CONTROL FORMAT, INCLUDE NOT LAST CONTROL */
end;


OptPrint: PROCEDURE local;
	call AcceptFileName;
	if lfOpen then
		call BadCmdTail(ERR16);	/* ILLEGAL PRINT CONTROL */
	else
	do;
		if tknLen <> 0 then
			call InitF(.lstFil, .('LIST '), optStrVal$p);
		else
			call InitF(.lstFil, .('PRINT '), .lstFileName);
		PRINTSet = TRUE;
	end;
	PRINT = TRUE;
	call OpenF(.lstFil, 2);
	lstGiven = TRUE;
end;


OptIntVector: PROCEDURE local;
	DECLARE vecNum BYTE, vecLoc ADDRESS;

	call SkipWhite;
	if curCh <> '(' then
		call BadCmdTail(ERR11);	/* MISSING CONTROL PARAMETER */
	else
	do;
		vecNum = ParseNum;
		if vecNum <> 4 and vecNum <> 8 then
		do;
			call BadCmdTail(ERR176);	/* INVALID INTVECTOR INTERVAL VALUE */
			call SkipToRPARorEOL;
		end;
		else if curCh <> ',' then
		do;
			call BadCmdTail(ERR177);	/* INVALID INTVECTOR LOCATION VALUE */
			call SkipToRPARorEOL;
		end;
		else
		do;
			vecLoc = ParseNum;
			if vecLoc > 0FFE0H or vecLoc mod (vecNum * 8) <> 0 or curCh <> ')' then
			do;
				call BadCmdTail(ERR177);	/* INVALID INTVECTOR LOCATION VALUE */
				call SkipToRPARorEOL;
			end;
			else
			do;
				call NxtCh;
				intVecNum = vecNum;
				intVecLoc = vecLoc;
			end;
		end;
	end;
end;

AcceptDrive: PROCEDURE(fname, follow) bool local;
	DECLARE fname ADDRESS, follow BYTE;
	DECLARE isOK bool;
	DECLARE fnch BASED fname BYTE;

	AcceptRangeChrs: PROCEDURE(lch, hch);
		DECLARE (lch, hch) BYTE;
		if isOK then
			if curch < lch or hch < curch then
			do;
				call BadCmdTail(ERR12);	/* INVALID CONTROL PARAMETER */
				call SkipToRPARorEOL;
				isOK = FALSE;
			end;
			else
			do;
				fnch = curch;
				fname = fname + 1;
				call NxtCh;
			end;
	end;
	
	isOK = TRUE;
	call SkipWhite;
    	call AcceptRangeChrs(':', ':');
    	call AcceptRangeChrs('F', 'F');
    	call AcceptRangeChrs('0', '9');
    	call AcceptRangeChrs(':', ':');
    	call SkipWhite;
	call AcceptRangeChrs(follow, follow);
	return isOK;
end;


OptWorkFiles: PROCEDURE local;
	DECLARE wrkFiles1(5) BYTE, wrkFiles2(5) BYTE;

	call SkipWhite;
	if curCh <> '(' then
		call BadCmdTail(ERR11);	/* MISSING CONTROL PARAMETER */
	else
	do;
		call NxtCh;
		if not AcceptDrive(.wrkFiles1, ',') then
			return;
		if not AcceptDrive(.wrkFiles2, ')') then
			return;
		if tx1File.aftn <> 0 then
			call Fatal(.errWorkFiles, length(errWorkFiles));
		call movmem(4, .wrkFiles1, .atFile.fnam);
		call movmem(4, .wrkFiles1, .nmsFile.fnam);
		call movmem(4, .wrkFiles1, .tx1File.fnam);
		call movmem(4, .wrkFiles1, .xrfFile.fnam);
		call movmem(4, .wrkFiles2, .tx2File.fnam);
	end;
end;

OptSave: PROCEDURE local;
	if saveDepth >= 5 then
		call BadCmdTail(ERR187);	/* LIMIT EXCEEDED: NUMBER OF SAVE LEVELS > 5 */
	else
	do;
		saveStack(saveDepth).code = CODE;
		saveStack(saveDepth).list = LIST;
		saveStack(saveDepth).cond = COND;
		saveStack(saveDepth).leftmargin = LEFTMARGIN;
		saveDepth = saveDepth + 1;
	end;
end;

OptRestore: PROCEDURE local;
	if saveDepth = 0 then
		call BadCmdTail(ERR188);	/* MISPLACED RESTORE OPTION */
	else
	do;
		saveDepth = saveDepth - 1;
		CODE = saveStack(saveDepth).code;
		LIST = saveStack(saveDepth).list;
		COND = saveStack(saveDepth).cond;
		LEFTMARGIN = saveStack(saveDepth).leftmargin;
		if CODE then
			call WrByte(L$CODE);
		else
			call WrByte(L$NOCODE);
		if LIST then
			call WrByte(L$LIST);
		else
			call WrByte(L$NOLIST);
	end;
end;


OptSetReset: PROCEDURE(isSet) local;
	DECLARE isSet BYTE;
	DECLARE val ADDRESS;

	call SkipWhite;	
	if curCh <> '(' then
		call BadCmdTail(ERR11);	/* MISSING CONTROL PARAMETER */
	else 
		do while (1);
			call NxtCh;
			call GetVal;
			if curInfo$p = 0ffffh then
			do;
				call BadCmdTail(ERR180);	/* MISSING OR INVALID CONDITIONAL COMPILATION PARAMETER */
				call SkipToRPARorEOL;
				return;
			end;
			if curInfo$p = 0 then
				call CreateInfo(1, TEMP$T);
			call SkipWhite;
			if curCh = '=' and isSet then
			do;
				val = ParseNum;
				if val > 255 then
				do;
					call BadCmdTail(ERR181);	/* MISSING OR INVALID CONDITIONAL COMPILATION CONSTANT */
					call SkipToRPARorEOL;
					return;
				end;
				call SetCondFlag(val);
			end;
			else
				call SetCondFlag(isSet);
			if curCh <> ',' then
			do;
				call AcceptRP;
				return;
			end;
		end;
end;

OptIf: PROCEDURE local;

	ifDepth = ifDepth + 1;
	if not ParseIfCond then
	do;
		skippingCOND = TRUE;
		inIFpart = TRUE;
		skippingCONDDepth = ifDepth;
		if not COND then
			if LIST then
				call WrByte(L$NOLIST);
	end;
end;

OptElseElseIf: PROCEDURE local;
	if ifDepth = 0 then
		call BadCmdTail(ERR182);	/* MISPLACED ELSE OR ELSEIF OPTION */
	else
	do;
		skippingCOND = TRUE;
		inIFpart = FALSE;
		skippingCONDDepth = ifDepth;
		if not COND then
			if LIST then
				call WrByte(L$NOLIST);
	end;
	do while curCh <> CR;
		call NxtCh;
	end;
end;


OptEndIf: PROCEDURE local;
	if ifDepth = 0 then
		call BadCmdTail(ERR183);	/* MISPLACED ENDIF OPTION */
	else
		ifDepth = ifDepth - 1;
end;


Sub$550C: PROCEDURE local;

	do case tknFlags.controlVal;
	call OptPageLen;
	call OptPageWidth;
	call OptDate;
	call OptTitle;
	call OptLeftMargin;
	call OptObject;
	call OptInclude;
	call OptPrint;
	do;
		PRINT = FALSE; PRINTSet = FALSE;
	end;
	do;
		OBJECT = FALSE; OBJECTSet = FALSE;
	end;
	call OptWorkFiles;
	call OptIntVector;
	intVecNum = 0;
	call OptIXRef;
	do;
		IXREF = FALSE; IXREFSet = FALSE;
	end;
	call OptSave;
	call OptRestore;
	call OptSetReset(TRUE);
	call OptSetReset(FALSE);
	call OptIf;
	call OptElseElseIf;
	call OptEndIf;
	COND = TRUE;
	COND = FALSE;
	end;
end;

FindOption: PROCEDURE local;
	DECLARE (off, clen) ADDRESS;
	off = 0;
	clen = optTable(0);	

	do while clen <> 0;
		if clen = tknLen then
			if Strncmp(optStrVal$p, .optTable(off) + 1, clen) = 0 then
			do;
				tknFlags$p = .optTable(off) + clen + 1;
				return;
			end;
		clen = optTable(off := off + clen + 6);
	end;
	tknFlags$p = 0;
end;


SkipControlParam: PROCEDURE local;
	call SkipWhite;
	if curCh = '(' then
	do;
		call NxtCh;
		call SkipToRPARorEOL;
	end;
end;



DoControls: PROCEDURE local;
	call GetToken;
	if tknLen = 0 then
	do;
		call BadCmdTail(ERR8);	/* INVALID CONTROL FORMAT */
		call SkipControlParam;
	end;
	else
	do;
		call FindOption;
		if tknFlags$p = 0 then
		do;
			call UnknownCtrl;
			call SkipControlParam;
		end;
		else
		do;
			if tknFlags.primary = 0 then
				if isNonCtrlLine then
				do;
					call SyntaxError(ERR10);	/* ILLEGAL USE OF PRIMARY CONTROL AFTER NON-CONTROL LINE */
					call SkipControlParam;
					return;
				end;
				else if primaryCtrlSeen(tknFlags.PrimaryId) then
				do;
					call BadCmdTail(ERR95);	/* ILLEGAL RESPECIFICATION OF PRIMARY CONTROL IGNORED */
					call SkipControlParam;
					return;
				end;
				else
					primaryCtrlSeen(tknFlags.PrimaryId) = TRUE;

			if tknFlags.controlId <> 0FFH then
				if tknFlags.tokenId = 0 then
					CONTROLS(tknFlags.controlId) = tknFlags.controlVal;
				else 
				do;
					call WrByte(tknFlags.tokenId);
					if tknFlags.tokenId = 5 then
						CODE = TRUE;
					else if tknFlags.tokenId = 6 then
						CODE = FALSE;
					else if tknFlags.tokenId = 3 then
						LIST = TRUE;
					else if tknFlags.tokenId = 4 then
						LIST = FALSE;
				end;
			else
				call Sub$550C;
		end;
	end;
end;

Do$Control: PROCEDURE(pch) public;
	DECLARE pch ADDRESS;

	curCh$p = pch;
	chrClass = 0;
	ixiGiven, objGiven, lstGiven = 0;
	call NxtCh;

	do while (1);
		call SkipWhite;
		if chrClass = CC$NEWLINE then
		do;
			if ixiGiven then
				call CloseF(.ixiFile);
			if objGiven then
				call CloseF(.objFile);
			if lstGiven then
				call CloseF(.lstFil);
			return;
		end;
		call DoControls;
	end;
end;


DoCondCompile: PROCEDURE(pch) public;
	DECLARE pch ADDRESS;

	curCh$p = pch;
	if curCh = '$'then
	do;
		chrClass = 0;
		call NxtCh;
		call SkipWhite;
		call GetToken;
		if tknLen = 2 and Strncmp(optStrVal$p, .('IF'), 2) = 0 then
			ifDepth = ifDepth + 1;
		else if tknLen = 5 and Strncmp(optStrVal$p, .('ENDIF'), 5) = 0 then
		do;
			if (ifDepth := ifDepth - 1) < skippingCONDDepth then
				skippingCOND = FALSE;
		end;
		else if skippingCONDDepth = ifDepth and inIFpart then
			if tknLen = 4 and Strncmp(optStrVal$p, .('ELSE'), 4) = 0 then
				skippingCOND = FALSE;
			else if tknLen = 6 and Strncmp(optStrVal$p, .('ELSEIF'), 6) = 0 then
				skippingCOND = not ParseIfCond;
		if not skippingCOND then
			if not COND then
				if LIST then
					call WrByte(L$LIST);
	end;
end;


end;

src/plm0d.plm
plm0d:
DO;
$include(:f2:plm0d.ipx)

GetLin: PROCEDURE public;
	DECLARE tmp ADDRESS;

	GetSrcLine: PROCEDURE;
		call WriteLineInfo;
		inChr$p = .lineBuf;
		call ingetc;
		if inchr = 81H then	/* EOF */
			return;
		trunc = FALSE;
		call rsrcln;
		inchr = CR;
		inChr$p = inChr$p + 1;
		inChr = LF;
		inChr$p = .lineBuf;
		linfo.lineCnt = linfo.lineCnt + 1;
		linfo.stmtCnt, linfo.blkCnt = 0;
		lineInfoToWrite = TRUE;
	end;


	GetCodeLine: PROCEDURE;
		DECLARE startOfLine ADDRESS;

		do while (1);
			call GetSrcLine;
			if inchr <> ISISEOF then
			do;
				startOfLine = inChr$p + LEFTMARGIN - 1;
				do while inChr$p < startOfLine;
					if inchr = CR then
						return;
					inChr$p = inChr$p + 1;
				end;
				if skippingCOND then
					call DoCondCompile(inChr$p);
				else if inchr = '$' then
				do;
					call WrByte(L$STMTCNT);
					call WrWord(0);
					if trunc then
					do;
						call SyntaxError(ERR86);	/* LIMIT EXCEEDED: SOURCE LINE LENGTH */
						trunc = FALSE;
					end;
					call Do$Control(inChr$p);
				end;
				else
				do;
					isNonCtrlLine = TRUE;
					return;
				end;
			end;
			else if srcFileIdx = 0 then
			do;
				if ifDepth <> 0 then
					call SyntaxError(ERR188);	/* MISPLACED RESTORE OPTION */
				inChr$p = .('/*',27h,'/**/EOF   ');
				return;
			end;
			else
			do;
				call CloseF(.srcFil);
				srcFileIdx = srcFileIdx - 10;
				call InitF(.srcFil, .('SOURCE'), .srcFileTable(srcFileIdx));
				call OpenF(.srcFil, 1);
				call SeekF(.srcFil, .srcFileTable(srcFileIdx + 8));
				offCurCh = offLastCh;
			end;
		end;
	end;




	if macroDepth <> 0 then
	do;
		tmp = curInfo$p;
		curInfo$p = curMacroInfo$p;
		call SetType(0);
		curMacroInfo$p = macroPtrs(macroDepth + 1);
		inChr$p = macroPtrs(macroDepth);
		macroDepth = macroDepth - 2;
		curInfo$p = tmp;
	end;
	else
		call GetCodeLine;
end;


END;
src/plm0e.plm
plm0e: DO;
$include(:f2:plm0e.ipx)

DECLARE ENDorSEMICOLON(2) BYTE DATA(T$END, T$SEMICOLON);
DECLARE tokenTypeTable(*) BYTE DATA(
	T$NUMBER, T$NUMBER, T$NUMBER, T$VARIABLE,
	T$VARIABLE, T$PLUSSIGN, T$MINUSSIGN, T$STAR,
	T$SLASH, T$LPAREN, T$RPAREN, T$COMMA,
	T$COLON, T$SEMICOLON, T$STRING, T$PERIOD,
	T$EQ, T$LT, T$GT, T$VARIABLE,
	T$VARIABLE, T$VARIABLE, T$VARIABLE, T$VARIABLE);

DECLARE typeProcIdx(*) BYTE DATA(
	1, 1, 1, 2, 2, 3, 3, 3,
	4, 3, 3, 3, 5, 3, 6, 3,
	3, 7, 8, 0, 9, 9, 10, 0);

DECLARE binValidate(4) BYTE DATA(0, 1, 1, 1),
	octValidate(4) BYTE DATA(0, 0, 1, 1),
	decValidate(4) BYTE DATA(0, 0, 0, 1),
	hexValidate(4) BYTE DATA(0, 0, 0, 2);


DECLARE endToggle BYTE INITIAL(0);

Yylex: PROCEDURE public;
    DECLARE saveClass BYTE,
    pad ADDRESS, curOff ADDRESS;


	Toupper: PROCEDURE(c) BYTE;
	    DECLARE c BYTE;

	    if 'a' <= c and c <= 'z' then
		c = c and 5FH;
	    return c;
	end;



	Token2Num: PROCEDURE;
		DECLARE (tokenLen, ch) BYTE;

		Str2num: PROCEDURE(radix, validate$p);
			DECLARE radix byte, validate$p ADDRESS;
			DECLARE validate BASED validate$p(4) BYTE;
			DECLARE trial ADDRESS, valId BYTE,
				errored BYTE, curoff BYTE, ct BYTE;

		    
			tokenVal, trial, errored = 0;
			do curoff = 1 to tokenLen;
				if (ct := cClass(ch := tokenStr(curoff))) > CC$HEXCHAR then
				    valId = 1;
				else
				    valId = validate(ct);
				do case valId;
					ch = ch - '0';
					do;
						if not errored then
						do;
							call TokenErrorAt(ERR5);	/* INVALID CHARACTER IN NUMERIC CONSTANT */
							errored = TRUE;
						end;
						ch = 0;
					end;
					ch = ch - 'A' + 10;
				end;

				if (trial := tokenVal * radix + ch) < tokenVal then
				do;
				    call TokenErrorAt(ERR94);	/* ILLEGAL CONSTANT, VALUE > 65535 */
				    return;
				end;
				tokenVal = trial;
			end;
		end;


		if cClass(ch := tokenStr(tokenlen := tokenStr(0))) <= CC$DECDIGIT then
			call Str2num(10, .decValidate);
		else 
		do;
			tokenlen = tokenLen - 1;
			if ch = 'H' then
				call Str2num(16, .hexValidate);
			else if ch = 'Q' or ch = 'O' then
				call Str2num(8, .octValidate);
			else if ch = 'B' then
				call Str2num(2, .binValidate);
			else if ch = 'D' then
				call Str2num(10, .decValidate);
			else
			do;
				call TokenErrorAt(ERR4);	/* ILLEGAL NUMERIC CONSTANT TYPE */
				tokenVal = 0;
			end;
		end;
	end Token2Num;

	NestMacro: PROCEDURE;
		DECLARE tmp ADDRESS;

		tmp = GetLitaddr + 2;	
		call WrXrefUse;
		if macroDepth = 10 then
			call TokenErrorAt(ERR7);	/* LIMIT EXCEEDED: MACROS NESTED TOO DEEPLY */
		else
		do;
			call SetType(7);
			macroPtrs(macroDepth := macroDepth + 2) = inChr$p;
			macroPtrs(macroDepth + 1) = curMacroInfo$p;
			inChr$p = tmp - 1;
			curMacroInfo$p = curInfo$p;
		end;
	end NestMacro;

	ChkMacro: PROCEDURE bool;

	    call Lookup(.tokenStr);
	    markedSymbol$p = curSymbol$p;
	    if high(cursym.info$p) = 0FFH then	/* simple key word */
		tokenType = low(cursym.info$p);
	    else
	    do; 
		call FindInfo;
		if curInfo$p <> 0 then
			if GetType = LIT$T then
			do;
				call NestMacro;
				return FALSE;
			end;
			else if GetType = MACRO$T then
			do;
				call TokenErrorAt(ERR6);	/* ILLEGAL MACRO REFERENCE, RECURSIVE EXPANSION */
				return FALSE;
			end;
	    end;
	    return TRUE;
	end;

	GetName: PROCEDURE(maxlen);
		DECLARE maxlen ADDRESS;
		DECLARE ct BYTE;

	    curOff = 1;
	   
	    ct = cClass(lastch); 
	    do while ct <= CC$ALPHA or lastch = '$';
		if lastch = '$' then
		    call gnxtch;
		else if curOff > maxlen then
		do;
		    call TokenErrorAt(ERR3);	/* IDENTIFIER, STRING, OR NUMBER TOO LONG, TRUNCATED */
		    do while ct <= CC$ALPHA or lastch = '$';
			call gnxtch;
			ct = cClass(lastch);
		    end;
		    curOff = maxlen + 1;
		end;
		else
		do;
		    tokenStr(curOff) = Toupper(lastch);
		    curOff = curOff + 1;
		    call gnxtch;
		end;
		ct = cClass(lastch);
	    end;
	    
	    tokenStr(0) = curOff - 1;
	end;


	ParseString: PROCEDURE;
		DECLARE tooLong BYTE;

		tooLong = FALSE;
		curOff = 1;
		
		do while 1;
			call gnxtch;
			do while lastch <> QUOTE;
				do while lastch = CR or lastch = LF;
					call gnxtch;
				end;
				if lastch <> QUOTE then
				do;
					if curOff <> 256 then
					do;
						tokenStr(curOff) = lastch;
						curOff = curOff + 1;
					end;
					else
					do;
						toolong = TRUE;
						if lastch = ';' then
						do;
							call TokenErrorAt(ERR85);	/* LONG STRING ASSUMED CLOSED AT NEXT SEMICOLON OR QUOTE */
							goto L5F4E;
						end;
					end;
					call gnxtch;
				end;
			end;
			call gnxtch;
			if lastch = QUOTE then
				if curOff <> 256 then
				do;
					tokenStr(curOff) = lastch;
					curOff = curOff + 1;
				end;
				else
					toolong = TRUE;
			else
				goto L5F4E;
		end;
	l5F4E:
	    tokenStr(0) = curOff - 1;
	    if tokenStr(0) = 0 then
			call TokenErrorAt(ERR189);	/* NULL STRING NOT ALLOWED */
	    if toolong then
			call TokenErrorAt(ERR3);	/* IDENTIFIER, STRING, OR NUMBER TOO LONG, TRUNCATED */
	end;


	LocYylex: PROCEDURE;
		DECLARE tmp ADDRESS, inComment BYTE;

		do while 1;
			saveClass = cClass(lastch);
			tokenType = tokenTypeTable(saveClass);
			do case typeProcIdx(saveClass);
			do;	/* white space */
				call gnxtch;
				saveClass = cClass(lastch);
				do while saveClass = CC$WSPACE;
					call gnxtch;
					saveClass = cClass(lastch);
				end;
			end;
			do;	/* digits */
				call GetName(31);
				call Token2Num;
				return;
			end;
			do;	/* letters */
				tmp = curInfo$p;
				call GetName(255);
				if ChkMacro then
					return;
				curInfo$p = tmp;
				call gnxtch;
			end;
			do;	/* -, +, *, (, ), ,, ;, = */
				call gnxtch;
				return;
			end;
			do;	/* slash */
				call gnxtch;
				inComment = TRUE;
				if lastch <> '*' then
					return;
				call gnxtch;
				do while inComment;
					do while lastch <> '*';
						call gnxtch;
					end;
					call gnxtch;
					if lastch = '/' then
					do;
						inComment = FALSE;
						call gnxtch;
					end;
				end;
			end;
			do;	/* : */
				call gnxtch;
				if lastch = '=' then
				do;
					tokenType = T$COLON$EQUALS;
					call gnxtch;
				end;
				return;
			end;
			do;	/* quote */
				call ParseString;
				return;
			end;
			do;	/* < */
				call gnxtch;
				if lastch = '>' then
				do;
					tokenType = T$NE;
					call gnxtch;
				end;
				else if lastch = '=' then
				do;
					tokenType = T$LE;
					call gnxtch;
				end;
				return;
			end;
			do;	/* > */
				call gnxtch;
				if lastch = '=' then
				do;
					tokenType = T$GE;
					call gnxtch;
				end;
				return;
			end;
			do;	/* $, !, ", #, %, &, ?, @, [, \, ], ^, $, `, {, |, end;, ~ */
				call TokenErrorAt(ERR1);	/* INVALID PL/M-80 CHARACTER */
				call gnxtch;
			end;
			do;	/* non white space control chars and DEL */
				call TokenErrorAt(ERR2);	/* UNPRINTABLE ASCII CHARACTER */
				call gnxtch;
			end;
			end;
		end;
	end LocYylex;

	if yyAgain then
		yyAgain = FALSE;
	else if unexpectedEOF then
		tokenType = ENDorSEMICOLON(endToggle := (endToggle + 1) and 1);
	else 
	do;
		call LocYylex;
		if tokenType = T$EOF then
		do;
		    unexpectedEOF = TRUE;
		    tokenType = T$END;
		end;
	end;
end;

SetYyAgain: PROCEDURE public;
	yyAgain = TRUE;
end;

/*
	look for matching token
*/
YylexMatch: PROCEDURE(token) bool public;
	DECLARE token BYTE;

    call Yylex;			/* get the token to check */
    if tokenType = token then
		return TRUE;
    else
    do;
	    call SetYyAgain;	/* not matching but push back */
	    return FALSE;
    end;
end;

YylexNotMatch: PROCEDURE(token) bool public;
	DECLARE token BYTE;
    return not YylexMatch(token);
end;

Sub$60F9: PROCEDURE;
	DECLARE i ADDRESS;

	i = 1;
	call WrOprAndValue;
	call Yylex;
    
	do while 1;
		if tokenType = T$LPAREN then
		    i = i + 1;
		else if tokenType = T$RPAREN then
		do;
		    if (i := i - 1) = 0 then
		    do;
			call WrOprAndValue;
			return;
		    end;
		end;
		else if tokenType = T$SEMICOLON or
				(tokenType >= T$CALL and tokenType <= T$RETURN)  then
		do;
			call TokenErrorAt(ERR82);	/* INVALID SYNTAX, MISMATCHED '(' */
			do while i <> 0;
				call WrByte(L$RPAREN);
				i = i - 1;
			end;
			call SetYyAgain;
			return;
		end;
		call WrOprAndValue;
		call Yylex;
	end;
end;


ParseExpresion: PROCEDURE(endTok) public;
	DECLARE endTok BYTE;
	call Yylex;
	do while tokenType <> endTok and tokenType <> T$SEMICOLON;
		if T$CALL <= tokenType and tokenType <= T$RETURN then
			goto L61CB;
		call WrOprAndValue;
		call Yylex;
	end;
L61CB:
	call SetYyAgain;
end;


/*
	Error recovery to ) or end of statement
	skip to ; or
		) unless inside nested ()
*/
Sub$61CF: PROCEDURE;
	DECLARE i ADDRESS;

	i = 0;
	do while (1);
		if tokenType = T$SEMICOLON then
			goto L6216;
		if tokenType = T$LPAREN then
			i = i + 1;
		else if tokenType = T$RPAREN then
			if i = 0 then
				goto L6216;
			else
				i = i - 1;
		call Yylex;	/* get next token */
	end;
L6216:
	call SetYyAgain;	/* push back token */
end;


/*
	Error recovery to next element in parameter list
	skip to ; or
		) or , unless inside nested ()
*/
Sub$621A: PROCEDURE;
	DECLARE i ADDRESS;
	i = 0;
	do while 1;
		if tokenType = T$SEMICOLON then
			goto L6278;
		if i = 0 then
			if tokenType = T$COMMA then
				goto L6278;
		if tokenType = T$LPAREN then
			i = i + 1;
		else if tokenType = T$RPAREN then
			if i = 0 then
				goto L6278;
			else
				i = i - 1;
		call Yylex;	/* get next token */
	end;
L6278:
	call SetYyAgain;	/* push back token */
end;



DECLARE declNames(33) ADDRESS,
	declBasedNames(33) ADDRESS,
	declNameCnt ADDRESS,
	declaringName ADDRESS,
	declaringBase ADDRESS,
	parentStructure ADDRESS,
	basedInfo ADDRESS,
	dclFlags(3) BYTE,
	dclType BYTE,
	lastLit ADDRESS,
	arrayDim ADDRESS,
	structMembers(33) ADDRESS,
	structMemDim(33) ADDRESS,
	structMemType(33) BYTE,
	structMCnt ADDRESS,
	byte$9D7B BYTE,
	flag BYTE;



ParseDcl: PROCEDURE public;

	DeclarationError: PROCEDURE(errcode);
		DECLARE errcode ADDRESS;

		call TokenError(errcode, declaringName);
	end;



	ChkModuleLevel: PROCEDURE;	/* 62C2 */

		if curscope <> 100H then
			call TokenErrorAt(ERR73);	/* INVALID ATTRIBUTE OR INITIALIZATION, NOT AT MODULE LEVEL */
	end;

	ChkNotArray: PROCEDURE;	/* 62D5 */

		if TestFlag(.dclFlags, F$ARRAY) then
		do;
			call TokenErrorAt(ERR63);	/* INVALID DIMENSION WITH THIS ATTRIBUTE */
			call ClrFlag(.dclFlags, F$ARRAY);
			call ClrFlag(.dclFlags, F$STARDIM);
			arrayDim = 0;
		end;
	end;


	ChkNotStarDim: PROCEDURE;

		if TestFlag(.dclFlags, F$STARDIM) then
		do;
			call TokenErrorAt(ERR62);	/* INVALID STAR DIMENSION WITH 'STRUCTURE' OR 'EXTERNAL' */
			call ClrFlag(.dclFlags, F$STARDIM);
			arrayDim = 1;
		end;
	end;

	CreateStructMemberInfo: PROCEDURE;

		DECLARE (i, memDim) ADDRESS, memType BYTE;

		if structMCnt = 0 then
			return;

		do i = 1 to structMCnt;
			curSymbol$p = structMembers(i);
			memType = structMemType(i);
			memDim = structMemDim(i);
			call CreateInfo(curscope, memType);
			call WrXrefDef;
			call SetInfoFlag(F$MEMBER);
			call SetInfoFlag(F$LABEL);
			if memDim <> 0 then
			do;
				call SetInfoFlag(F$ARRAY);
				call SetDimension(memDim);
			end;
			else
				call SetDimension(1);
			call SetParentOffset(parentStructure);
		end;
	end;

	Sub$63B7: PROCEDURE(v);
		DECLARE v ADDRESS;
		DECLARE (cFlags, i) BYTE;
	    
		curSymbol$p = declaringName;
		call FindScopedInfo(curscope);
		if curInfo$p <> 0 then
		do;
			call WrXrefUse;
			if TestInfoFlag(F$PARAMETER) and not TestInfoFlag(F$LABEL) then
			do;
				cFlags = 0;
				do i = 0 to 2;
					cFlags = cFlags or dclFlags(i);
				end;
				if cFlags <> 0 then
					call DeclarationError(ERR76);	/* CONFLICTING ATTRIBUTE WITH PARAMETER */
				if dclType <> 2 and dclType <> 3 then
					call DeclarationError(ERR79);	/* ILLEGAL PARAMETER TYPE, NOT BYTE OR ADDRESS */
				else
					call SetType(dclType);
				if declaringBase <> 0 then
				do;
					call DeclarationError(ERR77);	/* INVALID PARAMETER DECLARATION, BASE ILLEGAL */
					declaringBase = 0;
				end;
			end;
			else
			do;
			    call DeclarationError(ERR78);	/* INVALID PARAMETER DECLARATION, BASE ILLEGAL */
			    return;
			end;
		end;
		else
		do;
			call CreateInfo(curscope, dclType);
			call WrXrefDef;
			call CpyFlags(.dclFlags);
		end;
		parentStructure = curInfo$p;
		if dclType = 0 then
		do;
			if declaringBase <> 0 then
			    call DeclarationError(ERR81);	/* CONFLICTING ATTRIBUTE WITH 'BASE' */
			call SetLitaddr(lastLit);
			return;
		end;
		else if dclType = 1 then
		do;
			if declaringBase <> 0 then
			    call DeclarationError(ERR80);	/* INVALID DECLARATION, LABEL MAY NOT BE BASED */
			if TestInfoFlag(F$EXTERNAL) then
			    call SetInfoFlag(F$LABEL);
			return;
		end;
		else
		do;
			if declaringBase <> 0 then
			do;
				if TestInfoFlag(F$PUBLIC) or TestInfoFlag(F$EXTERNAL)
				    or TestInfoFlag(F$AT) or TestInfoFlag(F$INITIAL)
				    or TestInfoFlag(F$DATA) then
				do;
				    call DeclarationError(ERR81);	/* CONFLICTING ATTRIBUTE WITH 'BASE' */
				    declaringBase = 0;
				end;
				else
				    call SetInfoFlag(F$BASED);
			end;
			call SetDimension(arrayDim);
			call SetBaseOffset(declaringBase);
			curInfo$p = curProcInfo$p;
			if TestInfoFlag(F$REENTRANT) then
			do;
				curInfo$p = parentStructure;
				if not( TestInfoFlag(F$DATA) or TestInfoFlag(F$BASED)
				   or TestInfoFlag(F$AT)) then
				    call SetInfoFlag(F$AUTOMATIC);
			end;
			curInfo$p = parentStructure;
		end;
		if TestInfoFlag(F$PARAMETER) then
			byte$9D7B = byte$9D7B + 1;
		else if v - byte$9D7B <> 1 then
			call SetInfoFlag(F$PACKED);
		call SetInfoFlag(F$LABEL);
		if dclType = 4 then
			call CreateStructMemberInfo;
	end;

	Sub$65AF: PROCEDURE;
		DECLARE i ADDRESS;

		byte$9D7B = 0;
		do i = 1 to declNameCnt;
			declaringName = declNames(i);
			declaringBase = declBasedNames(i);
			call Sub$63B7(i);
		end;
	end;

	/*
		parse AT, DATA or INITIAL argument
	*/
	Sub$65FA: PROCEDURE(lexItem, locflag);
		DECLARE (lexitem, locflag) BYTE;

		if TestFlag(.dclFlags, F$EXTERNAL) then
			call TokenErrorAt(ERR41);	/* CONFLICTING ATTRIBUTE */
		if YylexMatch(T$LPAREN) then
		do;
			call WrByte(lexItem);
			if flag then
				call WrInfoOffset(topInfo + 1);
			else
				call WrInfoOffset(botinfo);
			call SetFlag(.dclFlags, locflag);
			call Sub$60F9;
		end;
		else
			call TokenErrorAt(ERR75);	/* MISSING ARGUMENT OF 'AT' , 'DATA' , OR 'INITIAL' */
	end;


	ParseDclInitial: PROCEDURE;

		if YylexMatch(T$INITIAL) then
		do;
			call ChkModuleLevel;
			call Sub$65FA(L$INITIAL, F$INITIAL);
		end;
		else if YylexMatch(T$DATA) then
			call Sub$65FA(L$DATA, F$DATA);
		else if TestFlag(.dclFlags, F$STARDIM) then
		do;
			call TokenErrorAt(ERR74);	/* INVALID STAR DIMENSION, NOT WITH 'DATA' OR 'INITIAL' */
			call ClrFlag(.dclFlags, F$STARDIM);
			arrayDim = 1;
		end;
	end;

	ParseDclAt: PROCEDURE;
		if YylexMatch(T$AT) then
			call Sub$65FA(L$AT, F$AT);
	end;

	ParseDclScope: PROCEDURE;
		if YylexMatch(T$PUBLIC) then
		do;
			call ChkModuleLevel;
			call SetFlag(.dclFlags, F$PUBLIC);
		end;
		else if YylexMatch(T$EXTERNAL) then
		do;
			call ChkNotStarDim;
			call ChkModuleLevel;
			call SetFlag(.dclFlags, F$EXTERNAL);
		end;
	end;

	ParseStructMType: PROCEDURE;
		DECLARE type ADDRESS;
		
		if YylexMatch(T$BYTE) then
			type = 2;
		else if YylexMatch(T$ADDRESS) then
			type = 3;
		else
		do;
			type = 2;
			if YylexMatch(T$STRUCTURE) then
			do;
				call TokenErrorAt(ERR70);	/* INVALID MEMBER TYPE, 'STRUCTURE' ILLEGAL */
				if YylexMatch(T$LPAREN) then
				do;
					call Sub$61CF;
					call Yylex;
				end;
			end;
			else if YylexMatch(T$LABEL) then
				call TokenErrorAt(ERR71);	/* INVALID MEMBER TYPE, 'LABEL' ILLEGAL */
			else
				call TokenErrorAt(ERR72);	/* MISSING TYPE FOR STRUCTURE MEMBER */
		end;
		structMemType(structMCnt) = type;
	end;

	ParseStructMDim: PROCEDURE;
		DECLARE dim ADDRESS;
		
		if YylexMatch(T$LPAREN) then
		do;
			if YylexMatch(T$NUMBER) then
				dim = tokenVal;
			else if YylexMatch(T$STAR) then
			do;
				dim = 1;
				call TokenErrorAt(ERR69);	/* INVALID STAR DIMENSION WITH STRUCTURE MEMBER */
			end;
			else
			do;
				dim = 1;
				call TokenErrorAt(ERR59);	/* ILLEGAL DIMENSION ATTRIBUTE */
			end;
			if dim = 0 then
			do;
				dim = 1;
				call TokenErrorAt(ERR57);	/* ILLEGAL DIMENSION ATTRIBUTE */
			end;
			if YylexNotMatch(T$RPAREN) then
			do;
				call TokenErrorAt(ERR60);	/* MISSING ') ' AT END OF DIMENSION */
				call Sub$61CF;
				call Yylex;
			end;
			structMemDim(structMCnt) = dim;
		end;
	end;


	LocParseStructMem: PROCEDURE;
		DECLARE mcnt BYTE;

		if YylexNotMatch(T$VARIABLE) then
			call TokenErrorAt(ERR66);	/* INVALID STRUCTURE MEMBER, NOT AN IDENTIFIER */
		else
		do;
			do mcnt = 1 to structMCnt;
				if curSymbol$p = structMembers(mcnt) then
					call TokenErrorAt(ERR67);	/* DUPLICATE STRUCTURE MEMBER NAME */
			end;
			if structMCnt = 32 then
				call TokenErrorAt(ERR68);	/* LIMIT EXCEEDED: NUMBER OF STRUCTURE MEMBERS */
			else
				structMCnt = structMCnt + 1;
			structMembers(structMCnt) = curSymbol$p;
			structMemType(structMCnt) = 0;
			structMemDim(structMCnt) = 0;
			call ParseStructMDim;
			call ParseStructMType;
	    end;
	end;

	ParseStructMem: PROCEDURE;
		structMCnt = 0;
		if YylexNotMatch(T$LPAREN) then
			call TokenErrorAt(ERR64);	/* MISSING STRUCTURE MEMBERS */
		else
		do;
			do while 1;
				call LocParseStructMem;
				if YylexNotMatch(T$COMMA) then
					goto Exit;
			end;
			Exit:
			if YylexNotMatch(T$RPAREN) then
			do;
				call TokenErrorAt(ERR65);	/* MISSING ') ' AT END OF STRUCTURE MEMBER LIST */
				call Sub$61CF;
				call Yylex;
			end;
		end;
	end;

	ParseDclDataType: PROCEDURE;
		if YylexMatch(T$BYTE) then
			dclType = 2;
		else if YylexMatch(T$ADDRESS) then
			dclType = 3;
		else if YylexMatch(T$STRUCTURE) then
		do;
			dclType = 4;
			call ChkNotStarDim;
			call ParseStructMem;
		end;
		else if YylexMatch(T$LABEL) then
		do;
			dclType = 1;
			call ChkNotArray;
		end;
		else
		do;
			call TokenErrorAt(ERR61);	/* MISSING TYPE */
			dclType = 2;
		end;
	end;

	ParseArraySize: PROCEDURE;
		if YylexMatch(T$LPAREN) then
		do;
			call SetFlag(.dclFlags, F$ARRAY);
			if YylexMatch(T$NUMBER) then
			do;
				if tokenVal = 0 then
				do;
					call TokenErrorAt(ERR57);	/* INVALID DIMENSION, ZERO ILLEGAL */
					arrayDim = 1;
				end;
				else
					arrayDim = tokenVal;
			end;
			else if YylexMatch(T$STAR) then
			do;
				if declNameCnt > 1 then
				do;
					call TokenErrorAt(ERR58);	/* INVALID STAR DIMENSION IN FACTORED DECLARATION */
					arrayDim = 1;
				end;
				else
					call SetFlag(.dclFlags, F$STARDIM);
			end;
			else
			do;
				call TokenErrorAt(ERR59);	/* ILLEGAL DIMENSION ATTRIBUTE */
				arrayDim = 1;
			end;
			if YylexNotMatch(T$RPAREN) then
			do;
				call TokenErrorAt(ERR60);	/* MISSING ') ' AT END OF DIMENSION */
				call Sub$61CF;
				call Yylex;
			end;
		end;
	end;

	ParseDeclType: PROCEDURE;
		call ParseArraySize;
		call ParseDclDataType;
		call ParseDclScope;
		call ParseDclAt;
		call ParseDclInitial;
	end;


	ParseLiterally: PROCEDURE;
		if YylexNotMatch(T$STRING) then
		do;
			call TokenErrorAt(ERR56);	/* INVALID MACRO TEXT, NOT A STRING CONSTANT */
			tokenStr(0) = 1;
			tokenStr(1) = ' ';
		end;
		lastLit = CreateLit(.tokenStr);
		dclType = 0;
	end;


	ParseLitOrType: PROCEDURE;

		arrayDim = 1;
		call ClrFlags(.dclFlags);
		dclType = 0;
		if YylexMatch(T$LITERALLY) then
			call ParseLiterally;
		else
			call ParseDeclType;
	end;

	GetBaseInfo: PROCEDURE;
	    DECLARE (base1Name, base2Name) ADDRESS;

		basedInfo = 0;
		if YylexNotMatch(T$VARIABLE) then
			call TokenErrorAt(ERR52);	/* INVALID BASE, MEMBER OF BASED STRUCTURE OR ARRAY OF STRUCTURES */
		else 
		do;
			base1Name = curSymbol$p;
			if YylexMatch(T$PERIOD) then
				if YylexMatch(T$VARIABLE) then
					base2Name = curSymbol$p;
				else 
				do;
					call TokenErrorAt(ERR53);	/* INVALID STRUCTURE MEMBER IN BASE */
					return;
				end;
			else
				base2Name = 0;
			curSymbol$p = base1Name;
			call FindInfo;
			if curInfo$p = 0 then
			do;
				call TokenErrorAt(ERR54);	/* UNDECLARED BASE */
				return;
			end;
			call WrXrefUse;
			if base2Name = 0 then
				basedInfo = curInfo$p;
			else 
			do;
				curSymbol$p = base2Name;
				call FindMemberInfo;
				if curInfo$p = 0 then
				do;
					call TokenErrorAt(ERR55);	/* UNDECLARED STRUCTURE MEMBER IN BASE */
					return;
				end;
				call WrXrefUse;
				basedInfo = curInfo$p;
			end;
		end;
	end GetBaseInfo;


	Sub$6A68: PROCEDURE;
		if YylexNotMatch(T$VARIABLE) then
			call TokenErrorAt(ERR48);	/* ILLEGAL DECLARATION STATEMENT SYNTAX */
		else
		do;
			if declNameCnt = 32 then
				call TokenErrorAt(ERR49);	/* LIMIT EXCEEDED: NUMBER OF ITEMS IN FACTORED DECLARE */
			else
				declNameCnt = declNameCnt + 1;

			declNames(declNameCnt) = curSymbol$p;
			declBasedNames(declNameCnt) = 0;
			if not flag then
			do;
				call FindScopedInfo(curscope);
				if curInfo$p = 0 then
					flag = TRUE;
			end;
			if YylexMatch(T$BASED) then
			do;
				call GetBaseInfo;
				if basedInfo <> 0 then
				do;
					curInfo$p = basedInfo;
					if TestInfoFlag(F$BASED) or TestInfoFlag(F$ARRAY) or GetType <> ADDRESS$T then
					do; 
						call TokenErrorAt(ERR50);	/* INVALID ATTRIBUTES FOR BASE */
						basedInfo = 0;
					end;
					else if TestInfoFlag(F$MEMBER) then
					do;
						curInfo$p = GetParentOffset;
						if TestInfoFlag(F$ARRAY) or TestInfoFlag(F$BASED) then
						do;
							call TokenErrorAt(ERR52);	/* INVALID BASE, MEMBER OF BASED STRUCTURE OR ARRAY OF STRUCTURES */
							basedInfo = 0;
						end;
					end;
					declBasedNames(declNameCnt) = basedInfo;
				end;
			end;
		end;
	end;


	GetDclNames: PROCEDURE;

		declNameCnt = 0;
		flag = FALSE;
		if YylexMatch(T$LPAREN) then
		do;
			do while 1;
				call Sub$6A68;
				if YylexNotMatch(T$COMMA) then
					goto Exit;
			end;
			Exit:
			if YylexNotMatch(T$RPAREN) then
			do;
				call TokenErrorAt(ERR47);	/* MISSING ') ' AT END OF FACTORED DECLARATION */
				call Sub$61CF;
				call Yylex;
			end;
		end;
		else
			call Sub$6A68;
	end;
	if stmtLabelCnt <> 0 then
		call SyntaxError(ERR46);	/* ILLEGAL USE OF LABEL */
	do while 1;
		call GetDclNames;
		if declNameCnt <> 0 then
		do;
			call ParseLitOrType;
			call Sub$65AF;
		end;
		if YylexNotMatch(T$COMMA) then
			return;
    	end;
end;

ParseProcDcl: PROCEDURE public;
	DECLARE hasParams BYTE, tmp ADDRESS;

	SetPublic: PROCEDURE;
		if GetScope <> 100h then
			call TokenErrorAt(ERR39);	/* INVALID ATTRIBUTE OR INITIALIZATION, NOT AT MODULE LEVEL */
		else if TestInfoFlag(F$PUBLIC) then
			call TokenErrorAt(ERR40);	/* DUPLICATE ATTRIBUTE */
		else if TestInfoFlag(F$EXTERNAL) then
			call TokenErrorAt(ERR41);	/* CONFLICTING ATTRIBUTE */
		else
			call SetInfoFlag(F$PUBLIC);
	end;


	SetExternal: PROCEDURE;

		if GetScope <> 100H then
			call TokenErrorAt(ERR39);	/* INVALID ATTRIBUTE OR INITIALIZATION, NOT AT MODULE LEVEL */
		else if TestInfoFlag(F$EXTERNAL) then
			call TokenErrorAt(ERR40);	/* DUPLICATE ATTRIBUTE */
		else if TestInfoFlag(F$REENTRANT) or TestInfoFlag(F$PUBLIC) then
			call TokenErrorAt(ERR41);	/* CONFLICTING ATTRIBUTE */
		else
			call SetInfoFlag(F$EXTERNAL);
	end;

	SetReentrant: PROCEDURE;

		if GetScope <> 100h then
			call TokenErrorAt(ERR39);	/* INVALID ATTRIBUTE OR INITIALIZATION, NOT AT MODULE LEVEL */
		else if TestInfoFlag(F$REENTRANT) then
			call TokenErrorAt(ERR40);	/* DUPLICATE ATTRIBUTE */
		else if TestInfoFlag(F$EXTERNAL) then
			call TokenErrorAt(ERR41);	/* CONFLICTING ATTRIBUTE */
		else
			call SetInfoFlag(F$REENTRANT);
	end;

	SetInterruptNo: PROCEDURE;

		if YylexMatch(T$NUMBER) then
		do;
			if tokenVal > 255 then
			do;
				call TokenErrorAt(ERR42);	/* INVALID INTERRUPT VALUE */
				tokenVal = 0;
			end;
		end;
		else 
		do;
			call TokenErrorAt(ERR43);	/* MISSING INTERRUPT VALUE */
			tokenVal = 0;
		end;
		if GetScope <> 100h then
			call TokenErrorAt(ERR39);	/* INVALID ATTRIBUTE OR INITIALIZATION, NOT AT MODULE LEVEL */
		else if TestInfoFlag(F$INTERRUPT) then
			call TokenErrorAt(ERR40);	/* DUPLICATE ATTRIBUTE */
		else if hasParams then
			call TokenErrorAt(ERR44);	/* ILLEGAL ATTRIBUTE, 'INTERRUPT' WITH PARAMETERS */
		else if GetDataType <> 0 then
			call TokenErrorAt(ERR45);	/* ILLEGAL ATTRIBUTE, 'INTERRUPT' WITH TYPED PROCEDURE */
		else if TestInfoFlag(F$EXTERNAL) then
			call TokenErrorAt(ERR41);	/* CONFLICTING ATTRIBUTE */
		else
		do;
			call SetInfoFlag(F$INTERRUPT);
			call SetIntrNo(tokenVal);
		end;
	end;


	ParseProcAttrib: PROCEDURE;

	    curInfo$p = curProcInfo$p;
		
	    do while 1;
			if YylexMatch(T$PUBLIC) then
				call SetPublic;
			else if YylexMatch(T$EXTERNAL) then
				call SetExternal;
			else if YylexMatch(T$REENTRANT) then
				call SetReentrant;
			else if YylexMatch(T$INTERRUPT) then
				call SetInterruptNo;
			else
				return;
	    end;
	end;

	ParseRetType: PROCEDURE;

	    curInfo$p = curProcInfo$p;
	    if YylexMatch(T$BYTE) then
			call SetDataType(2);
	    else if YylexMatch(T$ADDRESS) then
			call SetDataType(3);
	end;

	DECLARE paramCnt ADDRESS;

	Sub$6E4B: PROCEDURE;

	    call FindScopedInfo(curscope);
	    if curInfo$p <> 0 then
			call TokenErrorAt(ERR38);	/* DUPLICATE PARAMETER NAME */
	    call CreateInfo(curscope, BYTE$T);
	    call WrXrefDef;
	    call SetInfoFlag(F$PARAMETER);
	    paramCnt = paramCnt + 1;
	end;

	ParseParams: PROCEDURE;

		paramCnt = 0;
		if YylexMatch(T$LPAREN) then
		do;
			do while 1;
				hasParams = TRUE;
				if YylexMatch(T$VARIABLE) then
					call Sub$6E4B;
				else
				do;
					call TokenErrorAt(ERR36);	/* MISSING PARAMETER */
					call Sub$621A;
				end;
				if YylexNotMatch(T$COMMA) then
					goto Exit;
			end;
		Exit:	
			if YylexNotMatch(T$RPAREN) then
			do;
				call TokenErrorAt(ERR37);	/* MISSING ') ' AT END OF PARAMETER LIST */
				call Sub$61CF;
				call Yylex;
			end;
			curInfo$p = curProcInfo$p;
			call SetParamCnt(paramCnt);
		end;
		else
			hasParams = FALSE;
	end;


	tmp = curProcInfo$p;
	curSymbol$p = stmtLabels(1);
	call FindScopedInfo(curscope);
	if curInfo$p <> 0 then
		call SyntaxError(ERR34);	/* DUPLICATE PROCEDURE DECLARATION */
	call CreateInfo(curscope, PROC$T);
	call SetInfoFlag(F$LABEL);
	call WrXrefDef;
	if procCnt = 254 then
		call FatalError(ERR35);	/* LIMIT EXCEEDED: NUMBER OF PROCEDURES */
	procInfo(procCnt := procCnt + 1) = curInfo$p;
	curProcId = procCnt;
	curProcInfo$p = curInfo$p;
	curDoBlkCnt = 0;
	doBlkCnt = 0;
	call PushBlock(curscope);
	call ParseParams;
	call ParseRetType;
	call ParseProcAttrib;
	curInfo$p = curProcInfo$p;
	if not TestInfoFlag(F$EXTERNAL) then
	do;
		call WrByte(L$PROCEDURE);
		call WrInfoOffset(curInfo$p);
		call WrByte(L$SCOPE);
		call WrWord(curscope);
	end;
	else
	do;
		call WrByte(L$EXTERNAL);
		call WrInfoOffset(curInfo$p);
	end;
	call SetProcId(curProcId);
	if tmp <> 0 then
	do;
		curInfo$p = tmp;
		if TestInfoFlag(F$REENTRANT) then
			call SyntaxError(ERR88);	/* INVALID PROCEDURE NESTING, ILLEGAL IN REENTRANT PROCEDURE */
		curInfo$p = curProcInfo$p;
	end;
end;
END;
src/plm0f.plm
plm0f: DO;
$include(:f2:plm0f.ipx)

DECLARE brkTxiCodes(*) BYTE DATA(
	L$STATEMENT, L$SEMICOLON, L$CALL, L$LINEINFO,
	L$DISABLE, L$DO, L$ENABLE, L$END,
	L$GO, L$GOTO, L$HALT, L$IF,
	L$PROCEDURE, L$RETURN);


DECLARE curState ADDRESS PUBLIC, endSeen BYTE PUBLIC;

Sub$6F00: PROCEDURE public;

	SkipToSemiColon: PROCEDURE;
		do while tokenType <> T$SEMICOLON;
			call Yylex;
		end;
		
		yyAgain = FALSE;
	end;

	ExpectSemiColon: PROCEDURE;
		if YylexNotMatch(T$SEMICOLON) then
		do;
			call TokenErrorAt(ERR32);	/* INVALID SYNTAX, TEXT IGNORED UNTIL ';' */
			call SkipToSemiColon;
		end;
	end;

	ErrorSkip: PROCEDURE;
		call SkipToSemiColon;
		call SetYyAgain;
	end;

	PopStateWord: PROCEDURE(state$p);
		DECLARE state$p ADDRESS,
			state BASED state$p ADDRESS;

		if stateIdx = 0 then
			call FatalError(ERR97);		/* COMPILER Error: PARSE STACK UNDERFLOW */
		state = stateStack(stateIdx);
		stateIdx = stateIdx - 1;
	end;

	GenLocalLabel: PROCEDURE;
		call Alloc(3, 3);
		localLabelCnt = localLabelCnt + 1;
	end;

	/*
		collect labels (max 9)
		looks for Variable ':'
		sybmol references stored in stmtLabels array
		count is in stmtLabelCnt
	*/
	ParseStmtLabels: PROCEDURE;
		stmtLabelCnt = 0;
		
		do while (1);
			labelBrkToken = tokenType;
			labelBrkSymbol = curSymbol$p;
			if tokenType <> T$VARIABLE then
				return;
			
			if YylexMatch(T$COLON) then
			do;
				if stmtLabelCnt = 9 then
					call TokenErrorAt(ERR30);	/* LIMIT EXCEEDED: NUMBER OF LABELS ON STATEMENT */
						/* LIMIT EXCEEDED: NUMBER OF LABELS ON STATEMENT */
				else
					stmtLabelCnt = stmtLabelCnt + 1;
				stmtLabels(stmtLabelCnt) = curSymbol$p;
			end;
			else
				return;
			call Yylex;
		end;
	end;

	ParseStartStmt: PROCEDURE;
		DECLARE tmp BYTE;
		
		if endSeen then
		do;
			endSeen = FALSE;
			return;
		end;
		tmp = XREF;
		XREF = FALSE;
		call Yylex;
		XREF = tmp;
		curStmtCnt = curStmtCnt + 1;
		if linfo.stmtCnt = 0 then
		do;
			linfo.stmtCnt = curStmtCnt;
			linfo.blkCnt = curBlkCnt;
		end;
		call WrByte(L$STMTCNT);
		call WrWord(curStmtCnt);
		if trunc then
		do;
			call SyntaxError(ERR86);	/* LIMIT EXCEEDED: SOURCE LINE LENGTH */
			trunc = FALSE;
		end;
		call ParseStmtLabels;
		if labelBrkToken = T$SEMICOLON then
		do;
			stmtStartCode = 1;
			call SetYyAgain;
		end;
		else if labelBrkToken = T$VARIABLE then
			stmtStartCode = 0;
		else if labelBrkToken >= T$CALL and labelBrkToken <= T$RETURN then
			stmtStartCode = labelBrkToken - T$CALL + 2;
		else
		do;
			call TokenErrorAt(ERR29);	/* ILLEGAL STATEMENT */
			stmtStartCode = 1;
			call ErrorSkip;
		end;
		lblBrkTxiCode = brkTxiCodes(stmtStartCode);
	end;

	WrLabelDefs: PROCEDURE;
		DECLARE i ADDRESS, tmp ADDRESS;

		tmp = curSymbol$p;
		if stmtLabelCnt <> 0 then
		do;
			do i = 1 to stmtLabelCnt;
				curSymbol$p = stmtLabels(i);
				call FindScopedInfo(curscope);
				if curInfo$p <> 0 then		/* already seen at this scope */
				do;
					if TestInfoFlag(F$LABEL) then
						call TokenError(ERR33, curSymbol$p);	/* DUPLICATE LABEL DECLARATION */
							/* DUPLICATE LABEL DECLARATION */
					else
					do;
						call WrByte(L$LABELDEF);
						call WrInfoOffset(curInfo$p);
						call SetInfoFlag(F$LABEL);
					end;
					call WrXrefUse;
				end;
				else
				do;
					call CreateInfo(curscope, LABEL$T);
					call WrXrefDef;
					call WrByte(L$LABELDEF);
					call WrInfoOffset(curInfo$p);
					call SetInfoFlag(F$LABEL);
				end;
			end;
			if curscope = 100h then
				call WrByte(L$MODULE);
		end;
		curSymbol$p = tmp;
	end WrLabelDefs;

	Sub$723A: PROCEDURE BYTE;
		if YylexMatch(T$VARIABLE) then
		do;
			curInfo$p = procInfo(1);
			if GetSymbol <> curSymbol$p then
			    call TokenErrorAt(ERR20);	/* MISMATCHED IDENTIFIER AT END OF BLOCK */
		end;
		call ExpectSemiColon;
		if unexpectedEOF then
		do;
			call WrByte(L$END);
			return TRUE;
		end;
		else
		do;
			call Yylex;
			if unexpectedEOF then
			do;
				call WrByte(L$END);
				unexpectedEOF = FALSE;
				return TRUE;
			end;
			else
			do;
				call SyntaxError(ERR93);	/* MISSING 'DO' FOR 'END' , 'END' IGNORED */
				call SetYyAgain;
				return FALSE;
			end;
		end;
	end Sub$723A;

	Sub$7296: PROCEDURE;
		DECLARE (i, v) BYTE;
		
		call PopBlock;
		if YylexMatch(T$VARIABLE) then
		do;
			curInfo$p = curProcInfo$p;
			if GetSymbol <> curSymbol$p then
				call TokenErrorAt(ERR20);	/* MISMATCHED IDENTIFIER AT END OF BLOCK */
		end;
		curInfo$p = curProcInfo$p;
		v = GetParamCnt;
		do i = 1 to v;
			call AdvNxtInfo;
			if not TestInfoFlag(F$LABEL) then
				call TokenError(ERR25, GetSymbol);	/* UNDECLARED PARAMETER */
		end;
		call PopStateWord(.doBlkCnt);
		call PopStateWord(.curProcInfo$p);
		call ExpectSemiColon;
	end;

	PushStateWord: PROCEDURE(v);
		DECLARE v ADDRESS;
		if stateIdx <> 63h then
		do;
			stateStack(stateIdx := stateIdx + 1) = v;
		end;
		else
			call FatalError(ERR31);		/* LIMIT EXCEEDED: PROGRAM TOO COMPLEX */
	end;


	PushStateByte: PROCEDURE(state);
		DECLARE state BYTE;
		call PushStateWord(state);
	end;


	CreateModuleInfo: PROCEDURE(symptr);
		DECLARE symptr ADDRESS;

		curSymbol$p = symptr;
		call CreateInfo(0, PROC$T);
		call SetInfoFlag(F$LABEL);
		call WrXrefDef;
		curProcInfo$p = curInfo$p;
		call SetProcId(1);
		procCnt = 1;
		procInfo(1) = curInfo$p;
		curscope = 100H;			/* proc = 1,  do level = 0 */
		call WrByte(L$DO);
		call WrByte(L$SCOPE);
		call WrWord(curscope);
		call PushBlock(curscope);
	end;


	State0: PROCEDURE;
		call ParseStartStmt;
		call PushStateByte(1);
		if stmtStartCode <> (T$DO - T$CALL + 2) then
		do;
			call SyntaxError(ERR89);		/* MISSING 'DO' FOR MODULE */
			call Lookup(.(6, 'MODULE'));
			call CreateModuleInfo(curSymbol$p);
			call PushStateByte(19);
		end;
		else
		do;
			if stmtLabelCnt = 0 then
			do;
				call SyntaxError(ERR90);	/* MISSING NAME FOR MODULE */
				call Lookup(.(6, 'MODULE'));
				stmtLabelCnt = 1;
				stmtLabels(1) = curSymbol$p;
			end;
			else if stmtLabelCnt > 1 then
				call SyntaxError(ERR18);	/* INVALID MULTIPLE LABELS AS MODULE NAMES */
			call CreateModuleInfo(stmtLabels(1));
			call ExpectSemiColon;
			call PushStateByte(3);
		end;
	end State0;



	State1: PROCEDURE;
		if stmtStartCode <> (T$END - T$CALL + 2) then
		do;
			haveModule = TRUE;
			call WrByte(L$MODULE);
			call PushStateByte(2);
		end;
		else
		do;
			if stmtLabelCnt <> 0 then
				call TokenErrorAt(ERR19);	/* INVALID LABEL IN MODULE WITHOUT MAIN PROGRAM */
			if not Sub$723A then
			do;
				call PushStateByte(1);
				call PushStateByte(10);
			end;
		end;
	end State1;


	State2: PROCEDURE;
		if stmtStartCode <> (T$END - T$CALL + 2) then
		do;
			call PushStateByte(2);
			call PushStateByte(10);
			call PushStateByte(11);
		end;
		else
		do;
			call WrLabelDefs;
			if Sub$723A then
				call WrByte(L$HALT);
			else
			do;
				call PushStateByte(2);
				call PushStateByte(10);
			end;
		end;
	end State2;


	State3: PROCEDURE;
		call ParseStartStmt;
		call PushStateByte(19);
	end;


	State19: PROCEDURE;	/* check for DECLARE or PROCEDURE */
		if stmtStartCode = (T$DECLARE - T$CALL + 2) then
		do;
			call ParseDcl;
			call PushStateByte(3);
			call ExpectSemiColon;
		end;
		else if stmtStartCode = (T$PROCEDURE - T$CALL + 2) then
		do;
			call PushStateByte(3);
			call PushStateByte(4);
		end;
	end;

	State4: PROCEDURE;
		if stmtLabelCnt = 0 then
		do;
			call SyntaxError(ERR21);	/* MISSING PROCEDURE NAME */
			call PushStateByte(7);
		end;
		else
		do;
			if stmtLabelCnt <> 1 then
			do;
				call TokenErrorAt(ERR22);	/* INVALID MULTIPLE LABELS AS PROCEDURE NAMES */
				stmtLabelCnt = 1;
			end;
			call PushStateWord(curProcInfo$p);
			call PushStateWord(doBlkCnt);
			call ParseProcDcl;
			call ExpectSemiColon;
			curInfo$p = curProcInfo$p;
			if TestInfoFlag(F$EXTERNAL) then
				call PushStateByte(5);
			else
			do;
				call PushStateByte(6);
				call PushStateByte(21);
				call PushStateByte(3);
			end;
		end;
	end;


	State5: PROCEDURE;
		call ParseStartStmt;
		if stmtStartCode = (T$END - T$CALL + 2) then
		do;
			if stmtLabelCnt <> 0 then
			do;
				call TokenErrorAt(ERR23);	/* INVALID LABELLED END IN EXTERNAL PROCEDURE */
				stmtLabelCnt = 0;
			end;
			call Sub$7296;
		end;
		else
		do;
			call PushStateByte(5);
			if stmtStartCode = (T$DECLARE - T$CALL + 2) then
			do;
				call ParseDcl;
				call ExpectSemiColon;
			end;
			else
			do;
				call TokenErrorAt(ERR24);	/* INVALID STATEMENT IN EXTERNAL PROCEDURE */
				if stmtStartCode = (T$PROCEDURE - T$CALL + 2) or
				   stmtStartCode = (T$DO - T$CALL + 2) then
					call PushStateByte(7);
				else
					call SkipToSemiColon;
			end;
		end;
	end;


	State21: PROCEDURE;
		if stmtStartCode = (T$END - T$CALL + 2) then
			call TokenErrorAt(ERR174);	/* INVALID NULL PROCEDURE */
		else
			call PushStateByte(9);
	end;


	State6: PROCEDURE;
		call WrLabelDefs;
		call Sub$7296;
		call WrByte(L$END);
	end;


	/* states 7 & 8 skip to end of block, handling nested blocks */
	State7: PROCEDURE;
		call SkipToSemiColon;
		call PushStateByte(8);
	end;


	State8: PROCEDURE;
		call ParseStartStmt;
		if stmtStartCode = (T$PROCEDURE - T$CALL + 2) or 	/* nested block */
		   stmtStartCode = (T$DO - T$CALL + 2) then
		do;
			call PushStateByte(8);
			call PushStateByte(7);				/* proc nested block */
		end;
		else
		do;
			call SkipToSemiColon;				/* skip to end of statement */
			if stmtStartCode <> (T$END - T$CALL + 2) then	/* if not an END then go again */
				call PushStateByte(8);
		end;
	end;

	State9: PROCEDURE;
		if stmtStartCode <> (T$END - T$CALL + 2) then
		do;
			call PushStateByte(9);
			call PushStateByte(10);
			call PushStateByte(11);
		end;
	end;


	State10: PROCEDURE;
		call ParseStartStmt;
	end;

	State11: PROCEDURE;
		if stmtStartCode = (T$DECLARE - T$CALL + 2) or
			stmtStartCode = (T$PROCEDURE - T$CALL + 2) or
			stmtStartCode = (T$END - T$CALL + 2) then
		do;

			call TokenErrorAt(ERR26);	/* INVALID DECLARATION, STATEMENT OUT OF PLACE */
			call PushStateByte(20);
		end;
		else if stmtStartCode = (T$DO - T$CALL + 2) then
			call PushStateByte(12);
		else if stmtStartCode = (T$IF - T$CALL + 2) then
			call PushStateByte(16);
		else
		do;
			call WrLabelDefs;
			call WrByte(lblBrkTxiCode);
			if stmtStartCode <> 1 then		/* Semicolon */
			do;
				if stmtStartCode = 0 then 	/* Variable */
				do;
					call WrByte(L$VARIABLE);
					call WrWord(labelBrkSymbol);
				end;
				call ParseExpresion(T$SEMICOLON);
			end;
			call ExpectSemiColon;
			end;
	end;


	State20: PROCEDURE;
		if stmtStartCode = (T$DECLARE - T$CALL + 2) then
		do;
			call ParseDcl;
			call ExpectSemiColon;
			call PushStateByte(20);
			call PushStateByte(10);
		end;
		else if stmtStartCode = (T$PROCEDURE - T$CALL + 2) then
		do;
			call PushStateByte(20);
			call PushStateByte(10);
			call PushStateByte(4);
		end;
		else if stmtStartCode = (T$END - T$CALL + 2) then
			endSeen = TRUE;
		else
			call PushStateByte(11);
	end;


	State12: PROCEDURE;	/* process DO */
		call WrLabelDefs;
		if stmtLabelCnt <> 0 then
			call PushStateWord(stmtLabels(stmtLabelCnt));
		else
			call PushStateWord(0);
		if YylexMatch(T$VARIABLE) then
		do;
			call WrByte(L$DOLOOP);	/* start of do loop */
			call WrOprAndValue;
			call ParseExpresion(T$SEMICOLON);
			call PushStateByte(13);
			call PushStateByte(9);
			call PushStateByte(10);
		end;
		else if YylexMatch(T$WHILE) then
		do;
			call WrByte(L$WHILE);	/* start of while */
			call ParseExpresion(T$SEMICOLON);
			call PushStateByte(13);
			call PushStateByte(9);
			call PushStateByte(10);
		end;
		else if YylexMatch(T$CASE) then
		do;
			call WrByte(L$CASE);	/* start of case */
			call ParseExpresion(T$SEMICOLON);
			call GenLocalLabel;
			call PushStateWord(localLabelCnt);
			call PushStateByte(14);
		end;
		else
		do;
			call WrByte(L$DO);	/* simple do end block */
			call PushStateByte(13);
			call PushStateByte(9);
			call PushStateByte(3);
		end;
		call ExpectSemiColon;		/* we should now see a semicolon */
		if doBlkCnt >= 255 then
			call SyntaxError(ERR27);	/* LIMIT EXCEEDED: NUMBER OF DO BLOCKS */
		else
			doBlkCnt = doBlkCnt + 1;

		curDoBlkCnt = doBlkCnt;
		call PushBlock(curscope);
		call WrByte(L$SCOPE);
		call WrWord(curscope);
	end;



	State13: PROCEDURE;
		DECLARE labelPtr ADDRESS;

		call WrLabelDefs;
		call PopBlock;
		call PopStateWord(.labelPtr);
		if YylexMatch(T$VARIABLE) then
			if curSymbol$p <> labelPtr then
				call TokenErrorAt(ERR20);	/* MISMATCHED IDENTIFIER AT END OF BLOCK */
		call WrByte(L$END);
		call ExpectSemiColon;
	end;


	State14: PROCEDURE;	/* process CASE statements */
		DECLARE labelptr ADDRESS, stateWord ADDRESS;
		
		call ParseStartStmt;
		if stmtStartCode <> (T$END - T$CALL + 2) then
		do;
			call GenLocalLabel;
			call WrByte(L$CASELABEL);
			call WrWord(localLabelCnt);
			call PushStateByte(15);
			call PushStateByte(11);
		end;
		else
		do;
			call PopStateWord(.stateWord);	/* get the head jump */
			call WrLabelDefs;
			if stmtLabelCnt <> 0 then
			do;
				call WrByte(L$JMP);
				call WrWord(stateWord);
			end;
			call PopBlock;
			call PopStateWord(.labelptr);
			call WrByte(L$END);
			call WrByte(L$LOCALLABEL);
			call WrWord(stateWord);
			/* check end label if present */
			if YylexMatch(T$VARIABLE) then
				if curSymbol$p <> labelptr then
					call SyntaxError(ERR20);	/* MISMATCHED IDENTIFIER AT END OF BLOCK */
			call ExpectSemiColon;
		end;
	end;


	State15: PROCEDURE;
		DECLARE stateWord ADDRESS;
		
		call PopStateWord(.stateWord);
		call WrByte(L$JMP);
		call WrWord(stateWord);
		call PushStateWord(stateWord);
		call PushStateByte(14);
	end;


	State16: PROCEDURE;	/* process if condition then */
		call WrLabelDefs;
		call WrByte(L$IF);
		call ParseExpresion(T$THEN);
		if YylexNotMatch(T$THEN) then
		do;
			call TokenErrorAt(ERR28);	/* MISSING 'THEN' */
			call WrByte(L$JMPFALSE);
			call WrWord(0);
		end;
		else
		do;
			call GenLocalLabel;
			call PushStateWord(localLabelCnt);
			call WrByte(L$JMPFALSE);
			call WrWord(localLabelCnt);
			call PushStateByte(17);
			call PushStateByte(11);
			call PushStateByte(10);
		end;
	end;


	State17: PROCEDURE;	/* process optional ELSE */
		DECLARE stateWord ADDRESS, tmp BYTE;
		
		call PopStateWord(.stateWord);	/* labelref for if condition false */
		call Yylex;
		tmp = lineInfoToWrite;			/* supress line info for labeldefs etc */
		lineInfoToWrite = FALSE;
		if tokenType = T$ELSE then
		do;
			call GenLocalLabel;
			call WrByte(L$JMP);
			call WrWord(localLabelCnt);	/* jump round else labelref */
			call PushStateWord(localLabelCnt);	/* save labelref for end of else statement */
			call PushStateByte(18);
			call PushStateByte(11);
			call PushStateByte(10);
		end;
		else
			call SetYyAgain;

		call WrByte(L$LOCALLABEL);	/* emit label for if condition false */
		call WrWord(stateWord);
		lineInfoToWrite = tmp;
	end;



	State18: PROCEDURE;		/* end of else */
		DECLARE stateWord ADDRESS, tmp BYTE;

		tmp = lineInfoToWrite;				/* supress line info for labeldefs */
		
		lineInfoToWrite = FALSE;
		call PopStateWord(.stateWord);		/* labelref for end of else */
		call WrByte(L$LOCALLABEL);	/* emit label */
		call WrWord(stateWord);
		lineInfoToWrite = tmp;
	end;

	stateIdx = 0;
	endSeen = FALSE;
	call PushStateByte(0);
	do while stateIdx <> 0;
		curState = stateStack(stateIdx);
		stateIdx = stateIdx - 1;
		do case curState;
			call State0;
			call State1;
			call State2;
			call State3;
			call State4;
			call State5;
			call State6;
			call State7;
			call State8;
			call State9;
			call State10;
			call State11;
			call State12;
			call State13;
			call State14;
			call State15;
			call State16;
			call State17;
			call State18;
			call State19;
			call State20;
			call State21;
		end;
	end;
end;end;
src/plm0g.plm
plm0g: DO;
$include(:f2:plm0g.ipx)

CreateLit: PROCEDURE(pstr) ADDRESS PUBLIC;
	DECLARE pstr ADDRESS, str BASED pstr(1) BYTE;
	DECLARE (litLen, litSymbol) ADDRESS;
	DECLARE litStr BASED litSymbol(1) BYTE;

	litLen = str(0) + 1;
	litSymbol = AllocSymbol(litLen + 3);
	call movmem(litLen, pstr, litSymbol + 1);
	call movmem(2, .(' ', LF), litSymbol + litLen + 1);	/* add " \n" */
	litStr(0) = 255;		/* put max size \n will terminate */
	return litSymbol;
end;


end;


src/plm0h.plm
plm0h: DO;
$include(:f2:plm0h.ipx)

SetDate: PROCEDURE(str, len) PUBLIC;
	DECLARE str ADDRESS, len BYTE;
	if len > 9 then
		len = 9;
	call fill(9, .DATE, ' ');
	call movmem(len, str, .DATE);
end SetDate;

SetPageLen: PROCEDURE(len) PUBLIC;
	DECLARE len ADDRESS;
	PAGELEN = len;
end SetPageLen;

SetPageWidth: PROCEDURE(width) PUBLIC;
	DECLARE width ADDRESS;
	PWIDTH = width;
end SetPageWidth;


end;

src/plm1a.plm
plm1a: DO;
$include(:f2:plm1a.ipx)

/* index into precedence table */
DECLARE tx1Aux1Map(*) BYTE DATA(0, 0, 0, 0, 0, 0, 0, 0,
	      0, 0, 0, 0, 0, 0, 0, 0,
	      0, 0, 0, 0, 0, 0, 0, 0,
	      0, 0, 0, 0, 0, 0, 0, 0,
	      0, 0, 0, 0, 1, 2, 0, 3,
	      4, 5, 6, 7, 8, 9, 1Dh, 0Ah,
	      0Bh, 0Ch, 0Dh, 0Eh, 0Fh, 10h, 11h, 12h,
	      13h, 0, 0, 0, 0, 0, 0, 0,
	      0, 0, 0, 0);

DECLARE b402F(*) BYTE PUBLIC DATA(
    /* L$LINEINFO, L$SyntaxError, L$TokenError, L$LIST, L$NOLIST, L$CODE, L$NOCODE, L$EJECT, */
    T2$LINEINFO, T2$SyntaxError, T2$TokenError, T2$LIST, T2$NOLIST, T2$CODE, T2$NOCODE, T2$EJECT,
    /* L$INCLUDE, L$STMTCNT, L$LABELDEF, L$LOCALLABEL, L$JMP, L$JMPFALSE, L$PROCEDURE, L$SCOPE, */
    T2$INCLUDE, T2$STMTCNT, T2$LABELDEF, T2$LOCALLABEL, T2$JMP, T2$JMPFALSE, T2$PROCEDURE, 0,
    /* L$END, L$DO, L$DOLOOP, L$WHILE, L$CASE, L$CASELABEL, L$IF, L$STATEMENT, */
    0, 0, 0, 0, T2$CASE, T2$CASELABEL, 0, 0,
    /* L$CALL, L$RETURN, L$GO, L$GOTO, L$SEMICOLON, L$ENABLE, L$DISABLE, L$HALT, */
    0, T2$RETURN, T2$GO$TO, T2$GO$TO, T2$SEMICOLON, T2$ENABLE, T2$DISABLE, T2$HALT,
    /* L$EOF, L$AT, L$INITIAL, L$DATA, L$VARIABLE, L$NUMBER, L$STRING, L$PLUSSIGN, */
    0, 0, 0, 0,T2$VARIABLE, 0, 0, T2$ADDB,
    /* L$MINUSSIGN, L$PLUS, L$MINUS, L$STAR, L$SLASH, L$MOD, L$COLONEQUALS, L$AND, */
    T2$MINUSSIGN, T2$PLUS, T2$MINUS, T2$STAR, T2$SLASH, T2$MOD, T2$STORE, T2$AND,
    /* L$OR, L$XOR, L$NOT, L$LT, L$LE, L$EQ, L$NE, L$GE, */
    T2$OR, T2$XOR, T2$NOT, T2$LT, T2$LE, T2$EQ, T2$NE, T2$GE,
    /* L$GT, L$COMMA, L$LPAREN, L$RPAREN, L$PERIOD, L$TO, L$BY, L$UNUSED, */
    T2$GT, 0, 0, 0, 0, 0, 0, 0,
    /* L$MODULE, L$XREFINFO, L$XREF, L$EXTERNAL */
    T2$MODULE, 0, 0, 0);

/* 80h	- expression item */
/* 40h - binary operator */
/* 20h - pass through */
/* 10h - PROCEDURE, AT, DATA, INITIAL or EXTERNAL */

DECLARE tx1Aux2Map(*) BYTE DATA(
        20h, 20h, 20h, 20h, 20h, 20h, 20h, 20h,
        20h, 0, 0, 0, 0, 0, 10h, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 10h, 10h, 10h, 80h, 80h, 80h,0C0h,
        0C0h,0C0h,0C0h,0C0h,0C0h,0C0h, 80h,0C0h,
        0C0h,0C0h, 80h,0C0h,0C0h,0C0h,0C0h,0C0h,
        0C0h, 80h, 80h, 80h, 80h, 80h, 80h, 0,
        20h, 0, 0, 10h);

DECLARE b40B7(*) BYTE public DATA(
    /* L$LINEINFO, L$SyntaxError, L$TokenError, L$LIST, L$NOLIST, L$CODE, L$NOCODE, L$EJECT, */
    12h, 12h, 12h, 12h, 12h, 12h, 12h, 12h,
    /* L$INCLUDE, L$STMTCNT, L$LABELDEF, L$LOCALLABEL, L$JMP, L$JMPFALSE, L$PROCEDURE, L$SCOPE,  */
    12h, 0, 13h, 13h, 13h, 13h, 7, 1,
    /* L$END, L$DO, L$DOLOOP, L$WHILE, L$CASE, L$CASELABEL, L$IF, L$STATEMENT,  */
    2, 6, 4, 5, 8, 13h, 3, 9,
    /* L$CALL, L$RETURN, L$GO, L$GOTO, L$SEMICOLON, L$ENABLE, L$DISABLE, L$HALT,  */
    0Ah, 0Bh, 0Dh, 0Ch, 0Eh, 0Fh, 0Fh, 0Fh,
    /* L$EOF, L$AT, L$INITIAL, L$DATA, L$VARIABLE, L$NUMBER, L$STRING, L$PLUSSIGN,  */
    12h, 10h, 11h, 11h, 12h, 12h, 12h, 12h,
    /* L$MINUSSIGN, L$PLUS, L$MINUS, L$STAR, L$SLASH, L$MOD, L$COLONEQUALS, L$AND,  */
    12h, 12h, 12h, 12h, 12h, 12h, 12h, 12h,
    /* L$OR, L$XOR, L$NOT, L$LT, L$LE, L$EQ, L$NE, L$GE,  */
    12h, 12h, 12h, 12h, 12h, 12h, 12h, 12h,
    /* L$GT, L$COMMA, L$LPAREN, L$RPAREN, L$PERIOD, L$TO, L$BY, L$INVALID,  */
    12h, 12h, 12h, 12h, 12h, 12h, 12h, 12h,
    /* L$MODULE, L$XREFINFO, L$XREF, L$EXTERNAL */
    12h, 12h, 12h, 14h);


DECLARE tx1ItemLengths(*) BYTE DATA(
    6, 2, 4, 0, 0, 0, 0, 0,
    6, 2, 2, 2, 2, 2, 2, 2,
    0, 0, 0, 0, 0, 2, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 2, 2, 2, 2, 2,0FFh, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 2, 2, 2);


DECLARE b413F(*) BYTE public DATA(
    /* ?, I$VARIABLE, I$NUMBER, I$PLUSSIGN, I$MINUSSIGN, I$PLUS, I$MINUS, I$STAR */
    0 , T2$VARIABLE, T2$NUMBER, T2$ADDB, T2$MINUSSIGN, T2$PLUS, T2$MINUS, T2$STAR,
    /* I$SLASH, I$MOD, I$AND, I$OR, I$XOR, I$NOT, I$LT, I$LE */
    T2$SLASH, T2$MOD, T2$AND, T2$OR, T2$XOR, T2$NOT, T2$LT, T2$LE,
    /* I$EQ, I$NE, I$GE, I$GT, I$ADDRESSOF, I$UNARYMINUS, I$STACKPTR, I$INPUT */
    T2$EQ, T2$NE, T2$GE, T2$GT, T2$ADDRESSOF, T2$UNARYMINUS, T2$STACKPTR, T2$INPUT,
    /* I$OUTPUT, I$CALL, I$CALLVAR, I$BYTEINDEX, I$WORDINDEX, I$COLONEQUALS, I$MEMBER, I$BASED */
    T2$OUTPUT, T2$CALL, T2$CALLVAR, T2$BYTEINDEX, T2$WORDINDEX, T2$STORE, T2$MEMBER, T2$BASED,
    /* I$CARRY, I$DEC, I$DOUBLE, I$HIGH, I$LAST, I$LENGTH, I$LOW, I$MOVE, */
    T2$CARRY, T2$DEC, T2$DOUBLE, T2$HIGH, T2$LAST, T2$LENGTH, T2$LOW, T2$MOVE,
    /* I$PARITY, I$ROL, I$ROR, I$SCL, I$SCR, I$SHL, I$SHR, I$SIGN, */
    T2$PARITY, T2$ROL, T2$ROR, T2$SCL, T2$SCR, T2$SHL, T2$SHR, T2$SIGN,
    /* I$SIZE, I$TIME, I$ZERO, */
    T2$SIZE, T2$TIME, T2$ZERO);

DECLARE b4172(*) BYTE public DATA(
/* I$STRING, I$VARIABLE, I$NUMBER, I$PLUSSIGN, I$MINUSSIGN, I$PLUS, I$MINUS, I$STAR */
	10, 0, 0, 60, 60, 60, 60, 70,
/* I$SLASH, I$MOD, I$AND, I$OR, I$XOR, I$NOT, I$LT, I$LE */
        70, 70, 30, 20, 20, 40, 50, 50,
/* I$EQ, I$NE, I$GE, I$GT,$ADDRESSOF,I$UNARYMINUS, I$STACKPTR, I$INPUT */
        50, 50, 50, 50, 0, 80, 0, 0,
/* I$OUTPUT, I$CALL, I$CALLVAR, I$BYTEINDEX, I$WORDINDEX, I$COLONEQUALS, I$MEMBER, I$BASED */
        0, 0, 0, 0, 0, 0, 0, 0,
/* I$CARRY, I$DEC, I$DOUBLE, I$HIGH, I$LAST, I$LENGTH, I$LOW, I$MOVE  */
        0, 0, 0, 0, 0, 0, 0, 0,
/* I$PARITY, I$ROL, I$ROR, I$SCL, I$SCR, I$SHL, I$SHR, I$SIGN */
        0, 0, 0, 0, 0, 0, 0, 0,
/*  I$SIZE, I$TIME, I$ZERO */
        0, 0, 0);


DECLARE builtinsMap(*) BYTE public DATA(
     I$CARRY, I$DEC, I$DOUBLE, I$HIGH, I$INPUT, I$LAST, I$LENGTH, I$LOW,
     I$MOVE, I$OUTPUT, I$PARITY, I$ROL, I$ROR, I$SCL, I$SCR, I$SHL,
     I$SHR, I$SIGN, I$SIZE, I$STACKPTR, I$TIME, I$ZERO);




declare parseSP address public,
	parseStack(100) address public,
	operatorSP address public,
	operatorStack(50) address public,
	exSP address public,
	ex1Stack(100) byte public,
	ex2Stack(100) byte public,
	ex3Stack(100) address public,
	stSP address public,
	st1Stack(300) byte public,
	st2Stack(300) byte public,
	st3Stack(300) address public;


FatalError: PROCEDURE(err) public;
    DECLARE err BYTE;
    hasErrors = TRUE;
    b91C0, fatalErrorCode = err;
    goto cleanup;
end;


OptWrXrf: PROCEDURE public;
    DECLARE tmp STRUCTURE(type BYTE, info ADDRESS, stmt ADDRESS);

    if not XREF then
	return;
    tmp.type = T2$65;
    tmp.info = curInfo$p - botInfo;
    tmp.stmt = curStmtNum;
    call fwrite(.xrfFile, .tmp, 5);
end;

WrTx2File: PROCEDURE(buf, cnt) public;
    DECLARE buf ADDRESS, cnt BYTE;
    DECLARE type BASED buf BYTE;

    T2CntForStmt = T2CntForStmt + 1;
    if not hasErrors then 
	call fwrite(.tx2File, buf, cnt);
    else if T2$STMTCNT <= type and type <= T2$Error then
	call fwrite(.tx2File, buf, cnt);
end;

Sub$4251: PROCEDURE(type$p, cnt);
    DECLARE type$p ADDRESS, cnt BYTE;
    DECLARE type BASED type$p BYTE;

    if b88B3 then
	if type = T2$STMTCNT then
	do;
	    call WrTx2File(.linfo, 7);
	    b88B3 = 0;
	    if tx1Item.dataw(0) = 0 then
		return;
	end;
    call WrTx2File(type$p, cnt);
end;

WrTx2Item: PROCEDURE(arg1b) ADDRESS public;
    DECLARE arg1b BYTE;
    call Sub$4251(.arg1b, 1);
    return T2CntForStmt;
end;

WrTx2Item1Arg: PROCEDURE(arg1b, arg2w) ADDRESS public;
    DECLARE arg1b BYTE, arg2w ADDRESS;
    call Sub$4251(.arg1b, 3);
    return T2CntForStmt;
end;

WrTx2Item2Arg: PROCEDURE(arg1b, arg2w, arg3w) ADDRESS public;
    DECLARE arg1b BYTE, (arg2w, arg3w) ADDRESS;
    call Sub$4251(.arg1b, 5);
    return T2CntForStmt;
end;

WrTx2Item3Arg: PROCEDURE(arg1b, arg2w, arg3w, arg4w) ADDRESS public;
    DECLARE arg1b BYTE, (arg2w, arg3w, arg4w) ADDRESS;
    call Sub$4251(.arg1b, 7);
    return T2CntForStmt;
end;

Sub$42EF: PROCEDURE(arg1w) ADDRESS public;
    declare arg1w address;
    return (T2CntForStmt + 1 - arg1w);
end;

MapLToT2: PROCEDURE public;
    DECLARE i BYTE;
    i = tx1ItemLengths(tx1Item.type) + 1;
    tx1Item.type = b402F(tx1Item.type);
    call Sub$4251(.tx1Item.type, i);
end;

WrTx2Error: PROCEDURE(arg1b) public;
    DECLARE arg1b BYTE, junk ADDRESS;
    hasErrors = TRUE;
    junk = WrTx2Item1Arg(T2$SyntaxError, arg1b);
end;


WrTx2ExtError: PROCEDURE(arg1b) public;
    declare arg1b byte, junk address;
    hasErrors = TRUE;
    if curInfo$p <> 0 then 
	junk = WrTx2Item2Arg(T2$TokenError, arg1b, curInfo$p - botInfo);
    else
	junk = WrTx2Item1Arg(T2$SyntaxError, arg1b);
end;

SetRegetTx1Item: PROCEDURE public;
    regetTx1Item = TRUE;
end;

RdTx1Item: PROCEDURE public;
    DECLARE tx1ItemLen ADDRESS;
    call fread(.tx1File, .tx1Item, 1);
    tx1ItemLen = tx1ItemLengths(tx1Item.type);
    if tx1ItemLen <> 0 then
	if tx1ItemLen <> 255 then
	do;		/* i.e. not a string */
	    call fread(.tx1File, .tx1Item.dataw, tx1ItemLen);
	end;
	else
	do;
	    call fread(.tx1File, .tx1Item.dataw, 2);
	    tx1ItemLen = tx1Item.dataw(0);
	    call fread(.tx1File, .tx1Item.dataw(1), tx1Item.dataw(0));
	end;
    tx1Aux1 = tx1Aux1Map(tx1Item.type);
    tx1Aux2 = tx1Aux2Map(tx1Item.type);
end;
end;
src/plm1b.plm
plm1b: DO;
$include(:f2:plm1b.ipx)

GetTx1Item: PROCEDURE public;

    if regetTx1Item then
    do;
	regetTx1Item = FALSE;
	return;
    end;
    do while 1;
	call RdTx1Item;
	if tx1Item.type = L$TokenError then
	do;
	    if (curSymbol$p := tx1Item.dataw(1)) <> 0 then
	    do;
		if high(cursym.info$p) = 0ffh then
			cursym.info$p = 0;
		if (curInfo$p := cursym.info$p) = 0 then
			call CreateInfo(0, UNK$T);
		tx1Item.dataw(1) = curInfo$p - botInfo;
	    end;
	    call MapLToT2;
	end;
	else if (tx1Item.type = L$XREFINFO and XREF)
	      or (tx1Item.type = L$XREF and (IXREF or XREF or SYMBOLS)) then
	do;
	    tx1Item.dataw(1) = curStmtNum;
	    call fwrite(.xrfFile, .tx1Item, 5);
	end;
	else if tx1Item.type = L$LINEINFO then
	do;
	    if b88B3 then
		call WrTx2File(.linfo, 7);
	    call move(7, .tx1Item, .linfo);
	    linfo.type = T2$LINEINFO;
	    b88B3 = TRUE;
	end;
	else if (tx1Aux2 and 20h) <> 0 then
	    call MapLToT2;
	else if tx1Item.type = L$STMTCNT and tx1Item.dataw(0) = 0 then
	    call MapLToT2;
	else if tx1Item.type <> L$XREF and tx1Item.type <> L$XREFINFO then
	    goto done;
    end;
done:	if tx1Item.type = L$VARIABLE then
	curSymbol$p = tx1Item.dataw(0);
    if (tx1Aux2 and 10h) <> 0 then
	tx1Item.dataw(0) = tx1Item.dataw(0) + botInfo;
end;

MatchTx2Item: PROCEDURE(arg1b) BYTE public;
    declare arg1b byte;
    call GetTx1Item;
    if tx1Item.type = arg1b then
	return TRUE;
    else
    do;
	call SetRegetTx1Item;
	return FALSE;
    end;
end;

NotMatchTx2Item: PROCEDURE(arg1b) BYTE public;
    declare arg1b byte;
    return not MatchTx2Item(arg1b);
end;

MatchTx2AuxFlag: PROCEDURE(arg1b) BYTE public;
    declare arg1b byte;

    call GetTx1Item;
    if (tx1Aux2 and arg1b) <> 0 then
	return TRUE;
    else
    do;
	call SetRegetTx1Item;
	return FALSE;
    end;
end;


Sub$4599: PROCEDURE public;
    do while 1;
	call GetTx1Item;
	if (tx1Aux2 and 80h) = 0 then
	    goto done;
	else if tx1Item.type = L$RPAREN then
	    goto done;
    end;
done:
    call SetRegetTx1Item;
end;

ResyncRparen: PROCEDURE public;
    call Sub$4599;
    if MatchTx2Item(L$RPAREN) then
	;
end;

ExpectRparen: PROCEDURE(arg1b) public;
    declare arg1b byte;
    if NotMatchTx2Item(L$RPAREN) then
    do;
	call WrTx2ExtError(arg1b);
	call ResyncRparen;
    end;
end;

Sub$45E0: PROCEDURE public;
    call FindInfo;
    if curInfo$p = 0 or GetType = LIT$T then
	call CreateInfo(256, BYTE$T);
    call OptWrXrf;
    if GetType <> BUILTIN$T then
	if  not TestInfoFlag(F$LABEL) then
	    if not TestInfoFlag(F$DECLARED) then
	    do;
		call WrTx2ExtError(105);	/* UNDECLARED IDENTIFIER */
		call SetInfoFlag(F$DECLARED);
	    end;
end;

Sub$4631: PROCEDURE public;
    declare tmp address;

    tmp = curInfo$p;
    call FindMemberInfo;
    if curInfo$p = 0 then
    do;
	call CreateInfo(0, BYTE$T);
	call SetParentOffset(tmp);
	call SetInfoFlag(F$MEMBER);
    end;
    if not TestInfoFlag(F$LABEL) then
	if not TestInfoFlag(F$DECLARED) then
	do;
	    call WrTx2ExtError(112);	/* UNDECLARED STRUCTURE MEMBER */
	    call SetInfoFlag(F$DECLARED);
	end;
    call OptWrXrf;
end;

Sub$467D: PROCEDURE public;
    call Sub$45E0;
    if MatchTx2Item(L$PERIOD) then
	if GetType <> STRUCT$T then
	    call WrTx2ExtError(110);	/* INVALID LEFT OPERAND OF QUALIFICATION, NOT A STRUCTURE */
	else if NotMatchTx2Item(L$VARIABLE) then
	    call WrTx2ExtError(111);	/* INVALID RIGHT OPERAND OF QUALIFICATION, NOT IDENTIFIER */
	else
	    call Sub$4631;
end;

WrAtFile: PROCEDURE(buf, cnt) public;
    declare (buf, cnt) address;
    call fwrite(.atFile, buf, cnt);
end;

WrAtFileByte: PROCEDURE(arg1b) public;
    declare arg1b byte;
    call WrAtFile(.arg1b, 1);
end;

WrAtFileWord: PROCEDURE(arg1w) public;
    declare arg1w address;
    call WrAtFile(.arg1w, 2);
end;
end;
src/plm1c.plm
plm1c: DO;
$include(:f2:plm1c.ipx)

GetRestrictedExpr: PROCEDURE public;
	declare rValue address,
		use8bit byte;


	SimpleUExpr: PROCEDURE;
	    if MatchTx2Item(L$NUMBER) then
		rValue = tx1Item.dataw(0);
	    else
	    do;
		if MatchTx2Item(L$VARIABLE) then
		    call Sub$45E0;
		call WrTx2ExtError(151);	/* INVALID OPERAND IN RESTRICTED EXPRESSION */
		rValue = 0;
	    end;
	    use8bit = use8bit and (high(rValue) = 0);
	end;

	SimpleNExpr: PROCEDURE;
	    if MatchTx2Item(L$MINUSSIGN) then
	    do;
		call SimpleUExpr;
		if use8bit then 
		    rValue = - low(rValue);
		else
		    rValue = - rValue;
	    end;
	    else
		call SimpleUExpr;
	end;

	EvalSimpleExpr: PROCEDURE;
	    declare p address;
	    call SimpleNExpr;
	    p = rValue;
	    do while 1;
		if MatchTx2Item(L$PLUSSIGN) then
		do;
		    call SimpleNExpr;
		    if use8bit then
		    do;
			p = (p := p + rValue) and 0ffh;
			
		    end;
		    else 
			p =  p + rValue;
		end;
		else if MatchTx2Item(L$MINUSSIGN) then
		do;
		    call SimpleNExpr;
		    if use8bit then
			p = (p := p - rValue) and 0ffh;
		    else
			p =  p - rValue;
		end;
		else
		    goto done;
	    end;
	done:
	    rValue = p;
	end;


	GetRestrictedArrayIndex: PROCEDURE;
	    use8bit = TRUE;
	    if not(TestInfoFlag(F$ARRAY)) then
		call WrTx2ExtError(149);	/* INVALID SUBSCRIPTING IN RESTRICTED REFERENCE */
	    call EvalSimpleExpr;
	    call ExpectRparen(150);	/* MISSING ') ' AT END OF RESTRICTED SUBSCRIPT */
	end;

	GetRestrictedVar: PROCEDURE;
	    if NotMatchTx2Item(L$VARIABLE) then
	    do;
		call WrTx2Error(147);	/* MISSING IDENTIFIER FOLLOWING DOT OPERATOR */
		call Sub$4599;
		return;
	    end;
	    call Sub$45E0;
	    varInfoOffset = curInfo$p;
	    if GetType = BUILTIN$T then
	    do;
		call WrTx2Error(123);	/* INVALID DOT OPERAND, BUILT-IN PROCEDURE ILLEGAL */
		call Sub$4599;
		return;
	    end;
	    if MatchTx2Item(L$LPAREN) then
	    do;
		call GetRestrictedArrayIndex;
		varArrayIndex = rValue;
	    end;
	    if MatchTx2Item(L$PERIOD) then
	    do;
		curInfo$p = varInfoOffset;
		if GetType <> STRUCT$T then
		do;
		    call WrTx2ExtError(148);	/* INVALID QUALIFICATION IN RESTRICTED REFERENCE */
		    call Sub$4599;
		    return;
		end;
		if NotMatchTx2Item(L$VARIABLE) then
		do;
		    call WrTx2Error(147);	/* MISSING IDENTIFIER FOLLOWING DOT OPERATOR */
		    varInfoOffset = varInfoOffset - botInfo;
		    return;
		end;
		call Sub$4631;
		varInfoOffset = curInfo$p;
		if MatchTx2Item(L$LPAREN) then
		do;
		    call GetRestrictedArrayIndex;
		    varNestedArrayIndex = rValue;
		end;
	    end;
	    varInfoOffset = varInfoOffset - botInfo;
	end;

    varInfoOffset, varArrayIndex, varNestedArrayIndex, varVal = 0;
    if MatchTx2Item(L$PERIOD) then
    do;
	call GetRestrictedVar;
	if MatchTx2Item(L$PLUSSIGN) then
	    ;
	else if MatchTx2Item(L$MINUSSIGN) then
	    call SetRegetTx1Item;
	else
	    return;
	use8bit = FALSE;
	call EvalSimpleExpr;
	varVal = rValue;
    end;
    else if MatchTx2Item(L$RPAREN) then
	call SetRegetTx1Item;
    else
    do;
	use8bit = TRUE;
	call EvalSimpleExpr;
	varVal = rValue;
    end;
end;

ParseDataItems: PROCEDURE(arg1w) ADDRESS public;
    declare arg1w address;
    declare p address;

    p = 0;
    call WrAtFileByte(ATI$DHDR);
    call WrAtFileWord(arg1w - botInfo);
    call WrAtFileWord(curStmtNum);
    do while 1;
	if MatchTx2Item(L$STRING) then
	do;
	    call WrAtFileByte(ATI$STRING);
	    call WrAtFileWord(tx1Item.dataw(0));
	    call WrAtFile(.tx1Item.dataw(1), tx1Item.dataw(0));
	    curInfo$p = arg1w;
	    if GetType = ADDRESS$T then 
		p = p + (tx1Item.dataw(0) + 1) / 2;
	    else 
		p = p + tx1Item.dataw(0);
	end;
	else
	do;
	    call GetRestrictedExpr;
	    call WrAtFileByte(ATI$DATA);
	    call WrAtFile(.varInfoOffset, 8);
	    p = p + 1;
	end;
	if NotMatchTx2Item(L$COMMA) then
	    goto done;
	else if MatchTx2Item(L$RPAREN) then
	do;
	    call WrTx2Error(151);	/* INVALID OPERAND IN RESTRICTED EXPRESSION */
	    call SetRegetTx1Item;
	    goto done;
	end;
    end;
done:
    call WrAtFileByte(ATI$END);
    call ExpectRparen(152);	/* MISSING ') ' AFTER CONSTANT LIST */
    curInfo$p = arg1w;;
    return p;
end;

ResetStacks: PROCEDURE public;
    parseSP, exSP, operatorSP, stSP = 0;
end;

PushParseWord: PROCEDURE(arg1w) public;
    declare arg1w address;
    if parseSP = 63h then
	call FatalError(119);	/* LIMIT EXCEEDED: PROGRAM TOO COMPLEX */
    parseStack(parseSP := parseSP + 1) = arg1w;
end;


PopParseStack: PROCEDURE public;
    if parseSP = 0 then
	call FatalError(159);	/* COMPILER Error: PARSE STACK UNDERFLOW */
    parseSP = parseSP - 1;
end;


PushParseByte: PROCEDURE(arg1b) public;
    declare arg1b byte;
    call PushParseWord(arg1b);
end;

ExprPush3: PROCEDURE(arg1b, arg2b, arg3w);
    declare (arg1b, arg2b) byte, arg3w address;
    if exSP = 63h then
	call FatalError(121);	/* LIMIT EXCEEDED: EXPRESSION TOO COMPLEX */
    ex1Stack(exSP := exSP + 1) = arg1b;
    ex2Stack(exSP) = arg2b;
    ex3Stack(exSP) = arg3w;
end;

ExprPop: PROCEDURE public;
    if exSP = 0 then
	call FatalError(160);	/* COMPILER Error: OPERAND STACK UNDERFLOW */
    exSP = exSP - 1;
end;


SwapOperandStack: PROCEDURE;
    declare i address, (op1, op2) byte, op3 address;

    if exSP < 2 then
	call FatalError(161);	/* COMPILER Error: ILLEGAL OPERAND STACK EXCHANGE */
    i = exSP - 1;
    op1 = ex1Stack(exSP);
    op2 = ex2Stack(exSP);
    op3 = ex3Stack(exSP);
    ex1Stack(exSP) = ex1Stack(i);
    ex2Stack(exSP) = ex2Stack(i);
    ex3Stack(exSP) = ex3Stack(i);
    ex1Stack(i) = op1;
    ex2Stack(i) = op2;
    ex3Stack(i) = op3;
end;

ExprPush2: PROCEDURE(arg1b, arg2w) public;
    declare arg1b byte, arg2w address;
    call ExprPush3(arg1b, 0, arg2w);
end;

StmtPush3: PROCEDURE(arg1b, arg2b, arg3w);
    declare (arg1b, arg2b) byte, arg3w address;
    if stSP = 299 then
	call FatalError(122);	/* LIMIT EXCEEDED: PROGRAM TOO COMPLEX	 */
    st1Stack(stSP := stSP + 1) = arg1b;
    st2Stack(stSP) = arg2b;
    st3Stack(stSP) = arg3w;
end;

MoveExpr2Stmt: PROCEDURE public;
    call StmtPush3(ex1Stack(exSP), ex2Stack(exSP), ex3Stack(exSP));
    call ExprPop;
end;

PushOperator: PROCEDURE(arg1b) public;
    declare arg1b byte;
    if operatorSP = 31h then
	call FatalError(120);	/* LIMIT EXCEEDED: EXPRESSION TOO COMPLEX */
    operatorStack(operatorSP := operatorSP + 1) = arg1b;
end;


PopOperatorStack: PROCEDURE public;
    if operatorSP = 0 then
	call FatalError(162);	/* COMPILER Error: OPERATOR STACK UNDERFLOW */
    operatorSP = operatorSP - 1;
end;


ExprMakeNode: PROCEDURE(arg1b, arg2b) public;
    declare (arg1b, arg2b) byte;
    declare w address, (j, i) byte;

    w = stSP + 1;

    if exSP < arg2b then
	call FatalError(163);	/* COMPILER Error: GENERATION FAILURE  */
    j = exSP - arg2b + 1;
    i = arg2b;
    do while i <> 0;
	call StmtPush3(ex1Stack(j), ex2Stack(j), ex3Stack(j));
	i = i - 1;
	j = j + 1;
    end;

    exSP = exSP - arg2b;
    if arg2b = 0 then
	w = 0;
    call ExprPush3(arg1b, arg2b, w);
end;

AcceptOpAndArgs: PROCEDURE public;
    declare i byte;

    i = operatorStack(operatorSP);
    if i = I$NOT or i = I$UNARYMINUS then
	call ExprMakeNode(i, 1);
    else
	call ExprMakeNode(i, 2);
    call PopOperatorStack;
end;


Sub$4CC2: PROCEDURE;
    declare p address;
    if TestInfoFlag(F$MEMBER) then
    do;
	p = curInfo$p;
	curInfo$p = GetParentOffset;
	call ExprPush2(I$VARIABLE, curInfo$p);
	call ExprPush2(I$VARIABLE, p);
	call ExprMakeNode(I$MEMBER, 2);
    end;
    else
	call ExprPush2(I$VARIABLE, curInfo$p);
end;

Sub$4CFD: PROCEDURE(arg1w) public;
    declare arg1w address;

    curInfo$p = arg1w;
    if TestInfoFlag(F$BASED) then
    do;
	curInfo$p = GetBaseOffset;
	call Sub$4CC2;
	curInfo$p = arg1w;
	call SwapOperandStack;
	call ExprMakeNode(I$BASED, 2);
    end;
end;

Sub$4D2C: PROCEDURE public;
    call Sub$4CC2;
    call Sub$4CFD(curInfo$p);
end;


Sub$4D38: PROCEDURE public;
    if GetDataType = 0 then
	call WrTx2ExtError(131);	/* ILLEGAL REFERENCE TO UNTYPED PROCEDURE */
end;


GetCallArgCnt: PROCEDURE BYTE public;
    declare (i, j, k) byte;
    i = parseStack(parseSP);
    j = operatorStack(operatorSP);
    call PopParseStack;
    call PopOperatorStack;
    if i = j then
	return i;
    if i < j then
    do;
	call WrTx2ExtError(153);	/* INVALID NUMBER OF ARGUMENTS IN CALL, TOO MANY */
	k = j - i;
	do while k <> 0;
	    call ExprPop;
	    k = k - 1;
	end;
    end;
    else
    do;
	call WrTx2ExtError(154);	/* INVALID NUMBER OF ARGUMENTS IN CALL, TOO FEW */
	k = i - j;
	do while k <> 0;
	    call ExprPush2(I$NUMBER, 0);
	    k = k - 1;
	end;
    end;
    return i;
end;

Sub$4DCF: PROCEDURE(arg1b) public;
    declare arg1b byte;

    if NotMatchTx2Item(L$LPAREN) then
    do;
	call WrTx2ExtError(124);	/* MISSING ARGUMENTS FOR BUILT-IN PROCEDURE */
	call ExprPush2(I$NUMBER, 0);
    end;
    else
    do;	if NotMatchTx2Item(L$VARIABLE) then
	do;
	    call WrTx2Error(125);	/* ILLEGAL ARGUMENT FOR BUILT-IN PROCEDURE */
	    call ExprPush2(I$NUMBER, 0);
	end;
	else
	do;
	    call Sub$45E0;
	    if MatchTx2Item(L$LPAREN) then
	    do;
		if TestInfoFlag(F$ARRAY) then
		do;
			call ResyncRparen;
			if MatchTx2Item(L$RPAREN) then
			do;
				if arg1b = I$LENGTH or arg1b = I$LAST then
				do;
					call WrTx2ExtError(125); /*  ILLEGAL ARGUMENT FOR BUILT-IN PROCEDURE */
					call ExprPush2(I$NUMBER, 0);
				end;
				else 
					call ExprPush2(arg1b, curInfo$p);
				return;
			end;
		end;
		else 
			call WrTx2ExtError(127);	/* INVALID SUBSCRIPT ON NON-ARRAY */
	    end; 
	    if MatchTx2Item(L$PERIOD) then
	    do;
		if GetType <> STRUCT$T then
			call WrTx2ExtError(110); /* INVALID LEFT OPERAND OF QUALIFICATION, NOT A STRUCTURE */
		else if NotMatchTx2Item(L$VARIABLE) then
			call WrTx2ExtError(111); /* INVALID RIGHT OPERAND OF QUALIFICATION, NOT IDENTIFIER */
		else
			call Sub$4631;
	    end;
	    if MatchTx2Item(L$LPAREN) then
	    do;
		if TestInfoFlag(F$ARRAY) then
		do;
			call ResyncRparen;
			if arg1b = I$LENGTH or arg1b = I$LAST then
			do;
				call WrTx2ExtError(125);	/* ILLEGAL ARGUMENT FOR BUILT-IN PROCEDURE */
				call ExprPush2(I$NUMBER, 0);
			end;
			else 
				call ExprPush2(arg1b, curInfo$p);
		end;
		else
		do;
			call WrTx2ExtError(127);	/* INVALID SUBSCRIPT ON NON-ARRAY */
			call ExprPush2(I$NUMBER, 0);
		end;
	    end;
	    else if arg1b = I$LENGTH or arg1b = I$LAST then
	    do;
		if TestInfoFlag(F$ARRAY) then 
			call ExprPush2(arg1b, curInfo$p);
		else
		do;
			call WrTx2ExtError(157);
				/* INVALID ARGUMENT, ARRAY REQUIRED FOR LENGTH OR LAST */
			call ExprPush2(I$NUMBER, 0);
		end;
	    end;
	    else
	    do;
		call ExprPush2(arg1b, curInfo$p);
		call ExprPush2(I$LENGTH, curInfo$p);
		call ExprMakeNode(I$STAR, 2);
	    end;
	end;
	call ExpectRparen(126);	/* MISSING ') ' AFTER BUILT-IN PROCEDURE ARGUMENT LIST */
    end;
end;


MkIndexNode: PROCEDURE public;
    declare (p, q) address;
    declare i byte, r address;

    curInfo$p = ex3Stack(exSP-1);	/* get var */
    if ex1Stack(exSP) = I$PLUSSIGN then
    do;	/* see if index is of form expr + ?? */
	p = ex3Stack(exSP) + 1;
	if st1Stack(p) = I$NUMBER then
	do;	/* expr + number */
	    ex1Stack(exSP) = st1Stack(q := p - 1);	/* pull up expression */
	    ex2Stack(exSP) = st2Stack(q);
	    ex3Stack(exSP) = st3Stack(q);
	    call ExprPush2(I$NUMBER, st3Stack(p));	/* and get the number as an offset */
	end;
	else 
	    call ExprPush2(I$NUMBER, 0);		/* no simple 0 offset */
    end;
    else
	call ExprPush2(I$NUMBER, 0);			/* 0 offset */

    if GetType = ADDRESS$T then		/* simple word array */
	i = I$WORDINDEX;
    else
    do;
	i = I$BYTEINDEX;
	if GetType = STRUCT$T then
	do;	/* scale structure index */
	    r = exSP - 1;					/* the index expr (ex offset) */
	    call ExprPush3(ex1Stack(r), ex2Stack(r), ex3Stack(r));	/* calc dimension */
	    call ExprPush2(I$SIZE, curInfo$p);
	    call ExprMakeNode(I$STAR, 2);
	    ex1Stack(r) = ex1Stack(exSP);	/* replace index expr */
	    ex2Stack(r) = ex2Stack(exSP);
	    ex3Stack(r) = ex3Stack(exSP);
	    call ExprPop;						/* waste intermediate */
	end;
    end;
    call ExprMakeNode(i, 3);
end;


ParsePortNum: PROCEDURE(arg1b) public;
    declare arg1b byte;
    declare p address;

    p = 0;
    if MatchTx2Item(L$LPAREN) then
    do;
	if MatchTx2Item(L$NUMBER) then
	do;
	    if tx1Item.dataw(0) <= 255 then
		p = tx1Item.dataw(0);
	    else
		call WrTx2ExtError(106);	/* INVALID INPUT/OUTPUT PORT NUMBER */
	end;
	else
	    call WrTx2ExtError(107);/* ILLEGAL INPUT/OUTPUT PORT NUMBER, NOT NUMERIC CONSTANT */
	call ExpectRparen(108);	/* MISSING ') ' AFTER INPUT/OUTPUT PORT NUMBER */
    end;
    else
	call WrTx2ExtError(109);	/* MISSING INPUT/OUTPUT PORT NUMBER */

    call ExprPush2(arg1b, p);
end;


Sub$50D5: PROCEDURE public;
    declare p address, i byte;

    p = curInfo$p;
    if (curInfo$p := curProcInfo$p) = 0 then
	i = FALSE;
    else
	i = TestInfoFlag(F$REENTRANT);
    curInfo$p = p;
    if TestInfoFlag(F$REENTRANT) and i then
	return;
    if not TestInfoFlag(F$DECLARED) then 
	call WrTx2ExtError(169);		/* ILLEGAL FORWARD CALL */
    else if not TestInfoFlag(F$DEFINED) then
	call WrTx2ExtError(170);		/* ILLEGAL RECURSIVE CALL */
end;


Sub$512E: PROCEDURE(arg1w) BYTE public;
    declare arg1w address, c byte;
    if (c := ex1Stack(arg1w)) = I$OUTPUT or c = I$STACKPTR or c = I$BASED then
	return FALSE;
    if c = I$VARIABLE then 
	curInfo$p = ex3Stack(arg1w);
    else if c = I$BYTEINDEX or c = I$WORDINDEX then
	curInfo$p = st3Stack(ex3Stack(arg1w));
    else if c = I$MEMBER then
    do;
	if st1Stack(ex3Stack(arg1w)) = I$VARIABLE then
	    curInfo$p = st3Stack(ex3Stack(arg1w));
	else
	    curInfo$p = st3Stack(st3Stack(ex3Stack(arg1w)));
    end;
    else
	return TRUE;
    if TestInfoFlag(F$DATA) then
	call WrTx2ExtError(173);
    /*  INVALID LEFT SIDE OF ASSIGNMENT: VARIABLE DECLARED WITH DATA ATTRIBUTE */
    return FALSE;
end;

Sub$521B: PROCEDURE public;
    declare (q, p) address;

    p = curSymbol$p;
    curSymbol$p = 0;
    call CreateInfo(256, BYTE$T);
    call SetInfoFlag(F$DATA);
    curSymbol$p = p;
    call ExprPush2(I$VARIABLE, curInfo$p);
    call SetInfoFlag(F$ARRAY);
    call SetInfoFlag(F$STARDIM);
    q = ParseDataItems(curInfo$p);
    call SetDimension(q);
end;
end;
src/plm1d.plm
plm1d: DO;
$include(:f2:plm1d.ipx)

ExprParse0: PROCEDURE public;
    call PushOperator(0);
    if MatchTx2Item(L$VARIABLE) then
    do;
	call PushParseByte(1);
	call Sub$45E0;
	call PushParseByte(11);
    end;
    else
    do;
	call PushParseByte(3);
	call PushParseByte(4);
    end;
end;

ExprParse1: PROCEDURE public;
    if MatchTx2Item(L$COLONEQUALS) then
    do;
	if Sub$512E(exSP) then
	do;
	    call WrTx2ExtError(ERR128);	/* INVALID LEFT-HAND OPERAND OF ASSIGNMENT */
	    call ExprPop;
	end;
	else
	    call PushParseByte(2);
	call PushParseByte(3);
	call PushParseByte(4);
    end;
    else
    do;
	if ex1Stack(exSP) = I$OUTPUT then
	do;
	    call WrTx2Error(ERR130);	/*  ILLEGAL REFERENCE TO OUTPUT FUNCTION */
	    call ExprPop;
	    call ExprPush2(I$NUMBER, 0);
	end;
	call PushParseByte(3);
    end;
end;

ExprParse2: PROCEDURE public;
    call ExprMakeNode(I$COLONEQUALS, 2);
end;


ExprParse3: PROCEDURE public;
    if MatchTx2AuxFlag(64) then
    do;
	do while b4172(tx1Aux1) <= b4172(operatorStack(operatorSP));
	    if b4172(tx1Aux1) = 50 and b4172(operatorStack(operatorSP)) = 50 then
		call WrTx2ExtError(ERR218);	/* ILLEGAL SUCCESSIVE USES OF RELATIONAL OPERATORS */
	    call AcceptOpAndArgs;
	end;
	call PushOperator(tx1Aux1);
	call PushParseByte(3);
	call PushParseByte(4);
    end;
    else
    do;
	do while operatorStack(operatorSP) <> 0;
	    call AcceptOpAndArgs;
	end;
	call PopOperatorStack;
    end;
end;


ExprParse4: PROCEDURE public;
    if MatchTx2Item(L$MINUSSIGN) then
	call PushOperator(I$UNARYMINUS);
    else if MatchTx2Item(L$NOT) then
	call PushOperator(I$NOT);
    call PushParseByte(5);
end;

ExprParse5: PROCEDURE public;
    declare (p, q) address; 
    declare bpair based q(2) byte;

    if MatchTx2Item(L$VARIABLE) then
    do;
	call Sub$45E0;
	if GetType = BUILTIN$T and GetBuiltinId = 9 then
	do;	 /* 9 -> OUTPUT */
	    call WrTx2ExtError(ERR130);	/* ILLEGAL REFERENCE TO OUTPUT FUNCTION */
	    if MatchTx2Item(L$LPAREN) then
		call ResyncRparen;
	    call ExprPush2(I$NUMBER, 0);
	end;
	else 
	    call PushParseByte(11);
    end;
    else if MatchTx2Item(L$NUMBER) then
	call ExprPush2(I$NUMBER, tx1Item.dataw(0));
    else if MatchTx2Item(L$STRING) then
    do;
	if tx1Item.dataw(0) = 1 then
	    p = low(tx1Item.dataw(1));
	else if tx1Item.dataw(0) = 2 then
	do;
	    q = .p;
	    bpair(0) = high(tx1Item.dataw(1));
	    bpair(1) = low(tx1Item.dataw(1));
	end;
	else
	do;
	    call WrTx2ExtError(ERR100);	/* INVALID STRING CONSTANT IN EXPRESSION  */
	    p = 0;
	end;
	call ExprPush2(I$NUMBER, p);
    end;
    else if MatchTx2Item(L$LPAREN) then
    do;
	call PushParseByte(6);
	call PushParseByte(0);
    end;
    else if MatchTx2Item(L$PERIOD) then
    do;
	if MatchTx2Item(L$VARIABLE) then
	do;
	    call PushParseByte(7);
	    call PushParseByte(8);
	end;
	else if MatchTx2Item(L$LPAREN) then
	do;
	    call Sub$521B;
	    call PushParseByte(7);
	end;
	else
	do;
	    call WrTx2ExtError(ERR101);	/* INVALID ITEM FOLLOWS DOT OPERATOR */
	    call PushParseByte(5);
	end;
    end;
    else
    do;
	call WrTx2ExtError(ERR102);	/* MISSING PRIMARY OPERAND */
	call ExprPush2(I$NUMBER, 0);
    end;
end;


ExprParse6: PROCEDURE public;
    call ExpectRparen(ERR103);	/* MISSING ') ' AT END OF SUBEXPRESSION */
end;

ExprParse7: PROCEDURE public;
    call ExprMakeNode(I$ADDRESSOF, 1);
end;


ExprParse8: PROCEDURE public;
    call Sub$45E0;
    if GetType = BUILTIN$T then
    do;
	call PopParseStack;
	call WrTx2ExtError(ERR123);	/* INVALID DOT OPERAND, BUILT-IN PROCEDURE ILLEGAL */
	if MatchTx2Item(L$LPAREN) then
	    call ResyncRparen;
	call ExprPush2(I$NUMBER, 0);
    end;
    else
    do;
	call ExprPush2(I$VARIABLE, curInfo$p);
	if GetType = PROC$T then
	do;
	    if MatchTx2Item(L$LPAREN) then
	    do;
		call WrTx2ExtError(ERR104);	/* ILLEGAL PROCEDURE INVOCATION WITH DOT OPERATOR */
		call ResyncRparen;
	    end;
	end;
	else
	do;
	    if GetType = LABEL$T then
		call WrTx2ExtError(ERR158);	/* INVALID DOT OPERAND, LABEL ILLEGAL */
	    call PushParseByte(9);
	end;
    end;
end;

ExprParse9: PROCEDURE public;
    call PushParseWord(curInfo$p);
    call PushParseByte(0ah);
    if MatchTx2Item(L$LPAREN) then
    do;
	if not TestInfoFlag(F$ARRAY) then
	    call WrTx2ExtError(ERR127);	/* INVALID SUBSCRIPT ON NON-ARRAY */
	call PushParseByte(13h);
    end;
end;

ExprParse10: PROCEDURE public;
    declare p address;
    p = parseStack(parseSP);
    call PopParseStack;
    if MatchTx2Item(L$PERIOD) then
    do;
	curInfo$p = p;
	if GetType <> STRUCT$T then
	    call WrTx2ExtError(ERR110);	/* INVALID LEFT OPERAND OF QUALIFICATION, NOT A STRUCTURE */
	else if NotMatchTx2Item(L$VARIABLE) then
	    call WrTx2ExtError(ERR111);	/* INVALID RIGHT OPERAND OF QUALIFICATION, NOT IDENTIFIER */
	else
	do;
	    call Sub$4631;
	    call ExprPush2(I$VARIABLE, curInfo$p);
	    call PushParseWord(p);
	    call PushParseByte(14);
	    if MatchTx2Item(L$LPAREN) then
		call PushParseByte(19);
	end;
    end;
    else 
	call Sub$4CFD(p);
end;

ExprParse11: PROCEDURE public;
    declare p address;
    if GetType = BUILTIN$T then
    do;
	p = builtinsMap(GetBuiltinId);
	if p = I$INPUT or p = I$OUTPUT then
	    call ParsePortNum(p);
	else if p = I$LENGTH or p = I$LAST or p = I$SIZE then
	    call Sub$4DCF(p);
	else
	do;
	    call PushParseWord(p);
	    call PushParseWord(GetParamCnt);
	    call PushOperator(0);
	    call PushParseByte(17);
	    call Sub$4D38;
	    if MatchTx2Item(L$LPAREN) then
	    do;
		call PushParseByte(15);
		call PushParseByte(0);
	    end;
	end;
    end;
    else if GetType = PROC$T then
    do;
	call Sub$50D5;
	call ExprPush2(I$VARIABLE, curInfo$p);
	call Sub$4D38;
	call PushParseWord(GetParamCnt);
	call PushOperator(0);
	call PushParseByte(16);
	if MatchTx2Item(L$LPAREN) then
	do;
	    call PushParseByte(15);
	    call PushParseByte(0);
	end;
    end;
    else
	call PushParseByte(12);
end;

ExprParse12: PROCEDURE public;
    call ExprPush2(I$VARIABLE, curInfo$p);
    call PushParseWord(curInfo$p);
    if GetType = LABEL$T then
	call WrTx2ExtError(ERR132);	/* ILLEGAL USE OF LABEL */
    call PushParseByte(13);
    if TestInfoFlag(F$ARRAY) then
    do;
	if MatchTx2Item(L$LPAREN) then
	    call PushParseByte(19);
	else
	    call WrTx2ExtError(ERR133);	/* ILLEGAL REFERENCE TO UNSUBSCRIPTED ARRAY */
    end;
    else if MatchTx2Item(L$LPAREN) then
    do;
	call WrTx2ExtError(ERR127);	 /* INVALID SUBSCRIPT ON NON-ARRAY */
	call PushParseByte(19);
    end;
end;

ExprParse13: PROCEDURE public;
    declare p address;

    p, curInfo$p = parseStack(parseSP);
    call PopParseStack;
    if MatchTx2Item(L$PERIOD) then
    do;
	if GetType <> STRUCT$T then
	    call WrTx2ExtError(ERR110);	/* INVALID LEFT OPERAND OF QUALIFICATION, NOT A STRUCTURE */
	else if NotMatchTx2Item(L$VARIABLE) then
	    call WrTx2ExtError(ERR111);	/* INVALID RIGHT OPERAND OF QUALIFICATION, NOT IDENTIFIER */
	else
	do;
	    call Sub$4631;
	    call ExprPush2(I$VARIABLE, curInfo$p);
	    call PushParseWord(p);
	    call PushParseByte(14);
	    if TestInfoFlag(F$ARRAY) then
	    do;
		if MatchTx2Item(L$LPAREN) then
			call PushParseByte(19);
		else
			call WrTx2ExtError(ERR134);	/* ILLEGAL REFERENCE TO UNSUBSCRIPTED MEMBER ARRAY */
	    end;
	    else if MatchTx2Item(L$LPAREN) then
		call WrTx2ExtError(ERR127);	/* INVALID SUBSCRIPT ON NON-ARRAY */
	end;
    end;
    else
    do;
	if GetType = STRUCT$T then
	    call WrTx2ExtError(ERR135);	/* ILLEGAL REFERENCE TO AN UNQUALIFIED STRUCTURE */
	call Sub$4CFD(p);
    end;
end;

ExprParse14: PROCEDURE public;
    declare p address;
    p = parseStack(parseSP);
    call PopParseStack;
    call ExprMakeNode(I$MEMBER, 2);
    call Sub$4CFD(p);
end;


ExprParse15: PROCEDURE public;
    operatorStack(operatorSP) = operatorStack(operatorSP) + 1;
    if MatchTx2Item(L$COMMA) then
    do;
	call PushParseByte(0fh);
	call PushParseByte(0);
    end;
    else
	call ExpectRparen(ERR113);	/* MISSING ') ' AT END OF ARGUMENT LIST */
end;


ExprParse16: PROCEDURE public;
    call ExprMakeNode(I$CALL, GetCallArgCnt + 1);
end;


ExprParse17: PROCEDURE public;
    declare (i, j) byte;
    j = GetCallArgCnt;
    i = parseStack(parseSP);
    call PopParseStack;
    call ExprMakeNode(i, j);
end;


ExprParse18: PROCEDURE public;
    call ExprMakeNode(I$CALLVAR, operatorStack(operatorSP)+1);
    call PopOperatorStack;
end;


ExprParse19: PROCEDURE public;
    call PushParseByte(20);
    call PushParseByte(0);
end;


ExprParse20: PROCEDURE public;
    if MatchTx2Item(L$COMMA) then
    do;
	call WrTx2ExtError(ERR114);	/* INVALID SUBSCRIPT, MULTIPLE SUBSCRIPTS ILLEGAL */
	call Sub$4599;
    end;
    call ExpectRparen(ERR115);	/* MISSING ') ' AT END OF SUBSCRIPT */
    call MkIndexNode;
end;

ExprParse: PROCEDURE public;
    declare p address;
    do while parseSP <> 0;
	p = parseStack(parseSP);
	parseSP = parseSP - 1;
	do case p;
	    call ExprParse0;
	    call ExprParse1;
	    call ExprParse2;
	    call ExprParse3;
	    call ExprParse4;
	    call ExprParse5;
	    call ExprParse6;
	    call ExprParse7;
	    call ExprParse8;
	    call ExprParse9;
	    call ExprParse10;
	    call ExprParse11;
	    call ExprParse12;
	    call ExprParse13;
	    call ExprParse14;
	    call ExprParse15;
	    call ExprParse16;
	    call ExprParse17;
	    call ExprParse18;
	    call ExprParse19;
	    call ExprParse20;
	end;
    end;
end;
END;
src/plm1e.plm
plm1e: DO;
$include(:f2:plm1e.ipx)

Sub$5945: PROCEDURE BYTE public;
	declare i byte;

	call ResetStacks;
	i = 0;
	do while 1;
		if NotMatchTx2Item(L$VARIABLE) then
		do;
			call WrTx2ExtError(ERR128);	/* INVALID LEFT-HAND OPERAND OF ASSIGNMENT */
			return 0;
		end;
		call Sub$45E0;
		call PushParseByte(11);
		call ExprParse;
		if Sub$512E(exSP) then
		do;
			call WrTx2ExtError(ERR128);	/* INVALID LEFT-HAND OPERAND OF ASSIGNMENT */
			call ExprPop;
		end;
		else
			i = i + 1;
		if NotMatchTx2Item(L$COMMA) then
			goto done;
	end;
done:	
	if MatchTx2Item(L$EQ) then
	do;
		call PushParseByte(0);
		call ExprParse;
		if i <> 0 then
		do;
			call ExprMakeNode(I$COLONEQUALS, i + 1);
			call MoveExpr2Stmt;
			markedStSP = stSP;
			return TRUE;
		end;
		else
			return FALSE;
	end;
	else
	do;
		call WrTx2ExtError(ERR116);	/* MISSING '=' IN ASSIGNMENT STATEMENT */
		return FALSE;
	end;
end;

Sub$59D4: PROCEDURE BYTE public;
	declare i byte;
	call ResetStacks;
	if NotMatchTx2Item(L$VARIABLE) then
	do;
		call WrTx2ExtError(ERR117);	/* MISSING PROCEDURE NAME IN CALL STATEMENT */
		return FALSE;
	end;
	call Sub$467D;
	i = GetType;
	if i = PROC$T then
	do;
		call Sub$50D5;
		if GetDataType <> 0 then
			call WrTx2ExtError(ERR129);	/* ILLEGAL 'CALL' WITH TYPED PROCEDURE */
		call ExprPush2(I$VARIABLE, curInfo$p);
		call PushParseWord(GetParamCnt);
		call PushOperator(0);
		call PushParseByte(16);
		if MatchTx2Item(L$LPAREN) then
		do;
			call PushParseByte(15);
			call PushParseByte(0);
		end;
	end;
	else if i = BUILTIN$T then
	do;
		if GetDataType <> 0 then
		do;
			call WrTx2ExtError(ERR129);	/* ILLEGAL 'CALL' WITH TYPED PROCEDURE */
			return FALSE;
		end;
		call PushParseWord(builtinsMap(GetBuiltinId));
		call PushParseWord(GetParamCnt);
		call PushOperator(0);
		call PushParseByte(17);
		if MatchTx2Item(L$LPAREN) then
		do;
			call PushParseByte(15);
			call PushParseByte(0);
		end;
	end;
	else
	do;
	    if i <> ADDRESS$T or TestInfoFlag(F$ARRAY) then
	    do;
		call WrTx2ExtError(ERR118);	/* INVALID INDIRECT CALL, IDENTIFIER NOT AN ADDRESS SCALAR */
		return FALSE;
	    end;
	    call Sub$4D2C;
	    call PushOperator(0);
	    call PushParseByte(18);
	    if MatchTx2Item(L$LPAREN) then
	    do;
	    	call PushParseByte(15);
	    	call PushParseByte(0);
	    end;
	end;
	call ExprParse;
	call MoveExpr2Stmt;
	markedStSP = stSP;
	return TRUE;
end;

Sub$5AD8: PROCEDURE public;
	call ResetStacks;
	call PushParseByte(0);
	call ExprParse;
	call MoveExpr2Stmt;
	markedStSP = stSP;
end;

StmtParse: PROCEDURE(arg1w) ADDRESS public;
	declare arg1w address;
	declare i byte, (w99BF, w99C1, p) address;


	FlgVisited: PROCEDURE(arg1w, arg2w);
		declare (arg1w, arg2w) address;
		st1Stack(arg1w) = 255;
		st3Stack(arg1w) = arg2w;
	end;

	Sub$5BF5: PROCEDURE(arg1w);
	    declare arg1w address;
	    declare i byte, p address, j byte;

	    p = st3Stack(arg1w);
	    if (i := st1Stack(arg1w)) = I$VARIABLE then 
		w99C1 = WrTx2Item1Arg(T2$VARIABLE, p - botInfo);
	    else if i = I$NUMBER then
	    do;
		if high(p) = 0 then
			j = T2$NUMBER;
		else
			j = T2$BIGNUMBER;
		w99C1 = WrTx2Item1Arg(j, p);
	    end;
	    else if i = I$INPUT then
		w99C1 = WrTx2Item1Arg(T2$INPUT, p);
	    else if i = I$LENGTH or i = I$LAST or i = I$SIZE then
		w99C1 = WrTx2Item1Arg(b413F(i), p - botInfo);
	    else
		w99C1 = WrTx2Item(b413F(i));
	    call FlgVisited(arg1w, w99C1);
	end;

	StmtParse0: PROCEDURE;
		declare i byte;
		w99BF = parseStack(parseSP);
		call PopParseStack;
		if (i := st1Stack(w99BF)) = I$OUTPUT then
			return;
		if st2Stack(w99BF) = 0 then
			call Sub$5BF5(w99BF);
		else
		do;
			call PushParseWord(w99BF);
			if i = I$CALL then
				call PushParseByte(3);
			else if i = I$CALLVAR then
			do;
				call PushParseByte(6);
				call PushParseWord(st3Stack(w99BF));
				call PushParseByte(0);
			end;
			else if i = I$COLONEQUALS then
				call PushParseByte(9);
			else if i = I$MOVE then
			do;
				call PushParseByte(14);
				call PushParseWord(st3Stack(w99BF));
				call PushParseByte(0);
			end;
			else if i = I$BYTEINDEX or i = I$WORDINDEX then
			do;
				call PushParseByte(8);
				call PushParseWord(2);		/* serialise 2 leaves */
				call PushParseWord(st3Stack(w99BF));
				call PushParseByte(1);
			end;
			else
			do;
				call PushParseByte(13);					/* post serialisation */
				call PushParseWord(st2Stack(w99BF));	/* num args */
				call PushParseWord(st3Stack(w99BF));	/* loc of args */
				call PushParseByte(1);
			end;
		end;
	end;


	StmtParse1: PROCEDURE;	/* serialise 1 leaf then check */
		w99BF = parseStack(parseSP);
		call PushParseByte(2);	/* flag to check for more leaves */
		call PushParseWord(w99BF);	/* serialise this leaf */
		call PushParseByte(0);
	end;

	StmtParse2: PROCEDURE;	/* check for any more leaves */
		declare p address;
		p = parseSP - 1;
		parseStack(p) = parseStack(p) - 1;
		if parseStack(p) = 0 then
		do;
			call PopParseStack;
			call PopParseStack;
		end;
		else
		do;
			parseStack(parseSP) = parseStack(parseSP) + 1;
			call PushParseByte(1);
		end;
	end;

	StmtParse3: PROCEDURE;	/* parse call args */
		w99BF = parseStack(parseSP);
		call PushParseByte(5);	/* final call wrap up */
		if st2Stack(w99BF) > 1 then
		do;	/* any args */
			call PushParseWord(st2Stack(w99BF) - 1);	/* num args  */
			call PushParseWord(st3Stack(w99BF) + 1);	/* index of arg info */
			curInfo$p = st3Stack(st3Stack(w99BF));	/* info of procedure */
			call AdvNxtInfo;							/* adv to arginfo */
			call PushParseWord(curInfo$p);
			call PushParseByte(4);
			call PushParseWord(st3Stack(w99BF) + 1);	/* index of arg info */
			call PushParseByte(0);						/* serialise the arg */
		end;
		w99C1 = WrTx2Item(T2$BEGCALL);
	end;

	StmtParse4: PROCEDURE;
		declare (p, q) address, (i, j) byte;

		q = (p := parseSP - 1) - 1;
		curInfo$p = parseStack(parseSP);
		w99BF = parseStack(p);
		i = parseStack(q);
		if i > 2 then
		do;	/* all bar first 2 args to stack */
			if curInfo$p = 0 then 
				w99C1 = WrTx2Item1Arg(T2$STKARG, Sub$42EF(st3Stack(w99BF)));
			else
			do;
				if GetType = BYTE$T then
					j = T2$STKBARG;
				else
					j = T2$STKWARG;
				w99C1 = WrTx2Item1Arg(j, Sub$42EF(st3Stack(w99BF)));
				call AdvNxtInfo;
				parseStack(parseSP) = curInfo$p;
			end;
			call FlgVisited(w99BF, w99C1);
		end;
		i = i - 1;
		if i = 0 then
		do;			/* all done, clear working data */
			call PopParseStack;
			call PopParseStack;
			call PopParseStack;
		end;
		else
		do;
			parseStack(q) = i;
			w99BF = w99BF + 1;
			parseStack(p) = w99BF;
			call PushParseByte(4);
			call PushParseWord(w99BF);	/* serialise the arg */
			call PushParseByte(0);
		end;
	end;


	StmtParse5: PROCEDURE;
		declare (p, q) address, i byte, r address;
		w99BF = parseStack(parseSP);
		call PopParseStack;
		r = st3Stack(w99BF);
		i = st2Stack(w99BF) - 1;
		p, q = 0;
		if i > 1 then
		do;
			p = Sub$42EF(st3Stack(r + i - 1));
			q = Sub$42EF(st3Stack(r + i));
		end;
		else if i > 0 then
			p = Sub$42EF(st3Stack(r + i));
		w99C1 = WrTx2Item3Arg(T2$CALL, p, q, st3Stack(r) - botInfo);
		call FlgVisited(w99BF, w99C1);
	end;

	StmtParse6: PROCEDURE;
		declare i byte, p address;
		w99C1 = WrTx2Item(T2$BEGCALL);
		w99BF = parseStack(parseSP);
		call PushParseByte(7);
		if (i := st2Stack(w99BF) - 1) <> 0 then
		do;
			call PushParseWord(i);
			p = st3Stack(w99BF) + 1;
			call PushParseWord(p);
			call PushParseWord(0);	/* no arg info */
			call PushParseByte(4);
			call PushParseWord(p);
			call PushParseByte(0);
		end;
	end;

	StmtParse7: PROCEDURE;
		declare i byte;
		declare (p, q, r) address;
		w99BF = parseStack(parseSP);
		call PopParseStack;
		i = st2Stack(w99BF) - 1;
		p = st3Stack(w99BF);
		q, r = 0;
		if i > 1 then
		do;
			q = Sub$42EF(st3Stack(p + i - 1));
			r = Sub$42EF(st3Stack(p + i));
		end;
		else if i > 0 then
			q = Sub$42EF(st3Stack(p + i));
		w99C1 = WrTx2Item3Arg(T2$CALLVAR, q, r, Sub$42EF(st3Stack(p)));
		call FlgVisited(w99BF, w99C1);
	end;

	StmtParse8: PROCEDURE;
		declare i byte, p address;
		w99BF = parseStack(parseSP);
		call PopParseStack;
		i = st1Stack(w99BF);
		p = st3Stack(w99BF);
		w99C1 = WrTx2Item3Arg(b413F(i), Sub$42EF(st3Stack(p)),
					Sub$42EF(st3Stack(p+1)), st3Stack(p+2));
		call FlgVisited(w99BF, w99C1);
	end;


	StmtParse9: PROCEDURE;
		w99BF = parseStack(parseSP);
		call PushParseByte(10);	/* post serialise LHS */
		call PushParseWord(st3Stack(w99BF) + st2Stack(w99BF) - 1);
		call PushParseByte(0);
	end;


	StmtParse10: PROCEDURE;
		declare i byte, p address;
		w99BF = parseStack(parseSP);
		call PushParseByte(12);		/* mark LHS as used at end */
		i = st2Stack(w99BF) - 1;	/* num RHS */
		p = st3Stack(w99BF);		/* base RHS */
		call PushParseWord(i);
		call PushParseWord(p);
		call PushParseWord(p + i);			/* LHS */
		call PushParseByte(11);				/* after serialised leaf */
		call PushParseWord(p);				/* do the leaf */
		call PushParseByte(0);
	end;


	StmtParse11: PROCEDURE;		/* do one RHS assignment */
		declare (p, q) address, i byte;
		declare (r, s) address;

		i = parseStack(q := (p := parseSP - 1) - 1);
		s = parseStack(parseSP);
		if st1Stack(r := parseStack(p)) = I$OUTPUT then
		do;
			w99C1 = WrTx2Item1Arg(T2$NUMBER, st3Stack(r));
			w99C1 = WrTx2Item2Arg(T2$OUTPUT, Sub$42EF(w99C1), Sub$42EF(st3Stack(s)));
		end;
		else 
			w99C1 = WrTx2Item2Arg(T2$STORE, Sub$42EF(st3Stack(r)), Sub$42EF(st3Stack(s)));
		i = i - 1;
		if i = 0 then
		do;		/* all done */
			call PopParseStack;
			call PopParseStack;
			call PopParseStack;
		end;
		else
		do;			/* no so do another */
			parseStack(q) = i;
			r = r + 1;
			parseStack(p) = r;
			call PushParseByte(11);	/* state 11 after serialise */
			call PushParseWord(r);	/* serialise leaf */
			call PushParseByte(0);
		end;
	end;

	StmtParse12: PROCEDURE;		/* mark LHS as used */
		w99BF = parseStack(parseSP);
		call PopParseStack;
		w99C1 = st3Stack(st3Stack(w99BF) + st2Stack(w99BF) - 1);
		call FlgVisited(w99BF, w99C1);
	end;


	StmtParse13: PROCEDURE;	/* binary or unary op */
		declare p address, i byte;

		w99BF = parseStack(parseSP);
		call PopParseStack;
		p = st3Stack(w99BF);
		i = b413F(st1Stack(w99BF));
		if st2Stack(w99BF) = 1 then 
			w99C1 = WrTx2Item1Arg(i, Sub$42EF(st3Stack(p)));
		else 
			w99C1 = WrTx2Item2Arg(i, Sub$42EF(st3Stack(p)), Sub$42EF(st3Stack(p+1)));
		call FlgVisited(w99BF, w99C1);
	end;


	StmtParse14: PROCEDURE;
		declare p address;
		p = st3Stack(w99BF := parseStack(parseSP));
		/* emit the count leaf */
		w99C1 = WrTx2Item1Arg(T2$BEGMOVE, Sub$42EF(st3Stack(p)));
		call FlgVisited(p, w99C1);
		call PushParseByte(15);		/* MOVE post serialise */
		call PushParseWord(2);		/* serialise the address leaves */
		call PushParseWord(p + 1);
		call PushParseByte(1);
	end;

	StmtParse15: PROCEDURE;		/* rest of MOVE */
		declare p address;
		w99BF = parseStack(parseSP);
		call PopParseStack;
		p = st3Stack(w99BF);
		w99C1 = WrTx2Item3Arg(T2$MOVE, Sub$42EF(st3Stack(p+1)),
				Sub$42EF(st3Stack(p+2)), Sub$42EF(st3Stack(p)));
		call FlgVisited(w99BF, w99C1);
	end;

	p = curInfo$p;
	parseSP = 0;
	call PushParseWord(arg1w);
	call PushParseByte(0);
	do while parseSP <> 0;
		i = parseStack(parseSP);
		parseSP = parseSP - 1;
		do case i;
			call StmtParse0;
			call StmtParse1;
			call StmtParse2;
			call StmtParse3;
			call StmtParse4;
			call StmtParse5;
			call StmtParse6;
			call StmtParse7;
			call StmtParse8;
			call StmtParse9;
			call StmtParse10;
			call StmtParse11;
			call StmtParse12;
			call StmtParse13;
			call StmtParse14;
			call StmtParse15;
		end;
	end;
	curInfo$p = p;
	return st3Stack(arg1w);
end;



Sub$6523: PROCEDURE public;

declare b99FF(20) byte,
	b9A13(20) byte,
	procInfoStack(20) address,
	hNodes(20) address,
	eNodes(20) address,
	w9A9F(20) address,
	w9AC7(20) address,
	controlSP address;



	PushScope: PROCEDURE(arg1w);
		declare arg1w address;
		if blockDepth = 22h then
			call FatalError(ERR164);	/* COMPILER Error: SCOPE STACK OVERFLOW */
		else 
			procChains(blockDepth := blockDepth + 1) = arg1w;
	end;

	PopScope: PROCEDURE;
		if blockDepth = 0 then
			call FatalError(ERR165);	/* COMPILER Error: SCOPE STACK UNDERFLOW */
		else
			blockDepth = blockDepth - 1;
	end;

	PushControl: PROCEDURE(arg1b);
		declare arg1b byte;
		if controlSP = 13h then
			call FatalError(ERR84);	/*  LIMIT EXCEEDED: BLOCK NESTING */
		else
		do;
			b99FF(controlSP := controlSP + 1) = arg1b;
			b9A13(controlSP) = 0;
			procInfoStack(controlSP) = 0;
			hNodes(controlSP) = 0;
			eNodes(controlSP) = 0;
			w9A9F(controlSP) = 0;
			w9A9F(controlSP) = 0;	/* duplicate !! */
		end;
	end;


	PopControl: PROCEDURE;
		if controlSP = 0 then
			call FatalError(ERR167);	/* COMPILER Error: CONTROL STACK UNDERFLOW */
		else
		do;
			if b99FF(controlSP) <> 0 then 
				b9A13(controlSP-1) = b9A13(controlSP) or b9A13(controlSP-1);
			controlSP = controlSP - 1;
		end;
	end;

	GenLocalLabel: PROCEDURE ADDRESS;
		call Alloc(3, 3);
		return (localLabelCnt := localLabelCnt + 1);
	end;


	Sub$671D: PROCEDURE(arg1w) ADDRESS;
		declare arg1w address, (p, q) address;
		curInfo$p = arg1w;
		q = WrTx2Item1Arg(T2$VARIABLE, arg1w - botInfo);
		if TestInfoFlag(F$MEMBER) then
		do;
			curInfo$p = GetParentOffset;
			p = WrTx2Item1Arg(T2$VARIABLE, curInfo$p - botInfo);
			q = WrTx2Item2Arg(T2$MEMBER, Sub$42EF(p), Sub$42EF(q));
		end;
		return q;
	end;

	Sub$677C: PROCEDURE(arg1w) ADDRESS;
		declare arg1w address, (p, q) address;
		q = Sub$671D(arg1w);
		if TestInfoFlag(F$BASED) then
		do;
			p = Sub$671D(GetBaseOffset);
			q = WrTx2Item2Arg(T2$BASED, Sub$42EF(p), Sub$42EF(q));
		end;
		return q;
	end;

	ChkEndOfStmt: PROCEDURE;
		if MatchTx2AuxFlag(128) then
		do;
			call WrTx2ExtError(ERR32);	/* INVALID SYNTAX, TEXT IGNORED UNTIL ';' */
			do while (tx1Aux2 and 80h) <> 0;
				call GetTx1Item;
			end;
			call SetRegetTx1Item;
		end;
	end;


	Sub$67E3: PROCEDURE;
		declare (p, q, r, s, t, u ,v, w) address;

		p = procInfoStack(controlSP);
		u = hNodes(controlSP);
		v = eNodes(controlSP);
		if (w := w9A9F(controlSP)) = 0 then
		do;
			curInfo$p = p;
			if GetType = BYTE$T then
				t = WrTx2Item1Arg(T2$LOCALLABEL, GenLocalLabel);
			q = Sub$677C(p);
			r = Sub$677C(p);
			s = WrTx2Item1Arg(T2$NUMBER, 1);
			if GetType = BYTE$T then
			do;
				r = WrTx2Item2Arg(T2$ADDB, Sub$42EF(r), Sub$42EF(s));
				q = WrTx2Item2Arg(T2$STORE, Sub$42EF(q), Sub$42EF(r));
				q = WrTx2Item2Arg(T2$JNZ, u, 3);
			end;
			else
			do;
				r = WrTx2Item2Arg(T2$ADDW, Sub$42EF(r), Sub$42EF(s));
				q = WrTx2Item2Arg(T2$STORE, Sub$42EF(q), Sub$42EF(r));
				q = WrTx2Item1Arg(T2$JNC, u);
			end;
		end;
		else 
			q = WrTx2Item1Arg(T2$JMP, w);
		q = WrTx2Item1Arg(T2$LOCALLABEL, v);
	end;


	Sub$6917: PROCEDURE ADDRESS;
		call Sub$5AD8;
		return StmtParse(markedStSP);
	end;


	Sub$6923: PROCEDURE;
		declare p address;
		p = Sub$6917;
		call ChkEndOfStmt;
		if MatchTx2Item(L$JMPFALSE) then
			p = WrTx2Item2Arg(T2$JMPFALSE, tx1Item.dataw(0), Sub$42EF(p));
		else
			call FatalError(ERR168);  /* COMPILER Error: BRANCH MISSING IN 'IF' STATEMENT */
	end;

	ParseStmtcnt: PROCEDURE;
		T2CntForStmt = 0;
		call MapLToT2;
		curStmtNum = tx1Item.dataw(0);
	end;


	ParseIf: PROCEDURE;
		call Sub$6923;
	end;

	ParseProcedure: PROCEDURE;
		tx1Item.dataw(0) = tx1Item.dataw(0) - botInfo;
		call MapLToT2;
		call PushControl(0);
		procInfoStack(controlSP) = curProcInfo$p;
		curProcInfo$p, curInfo$p = tx1Item.dataw(0) + botInfo;
		call SetInfoFlag(F$DECLARED);
	end;

	ParseWhile: PROCEDURE;
		declare (p, q, r) address;
		call PushControl(2);
		p = GenLocalLabel;
		q = GenLocalLabel;
		hNodes(controlSP) = p;
		eNodes(controlSP) = q;
		r = WrTx2Item1Arg(T2$LOCALLABEL, p);
		r = Sub$6917;
		r = WrTx2Item2Arg(T2$JMPFALSE, q, Sub$42EF(r));
		call ChkEndOfStmt;
	end;

	ParseCASE: PROCEDURE;
		declare (p, q) address;
		call PushControl(3);
		call MapLToT2;
		q = Sub$6917;
		p = GenLocalLabel;
		q = WrTx2Item2Arg(T2$63, p, Sub$42EF(q));
		hNodes(controlSP) = p;
		call ChkEndOfStmt;
	end;

	ParseDOLOOP: PROCEDURE;
		declare (p, q, r, s, t, u, v, w) address;

		call PushControl(1);
		if NotMatchTx2Item(L$VARIABLE) then
		do;
			call WrTx2Error(ERR138);	/* MISSING INDEX VARIABLE */
			return;
		end;
		call Sub$467D;
		w = curInfo$p;
		procInfoStack(controlSP) = w;
		if (GetType <> BYTE$T and GetType <> ADDRESS$T) or TestInfoFlag(F$ARRAY) then
		do;
			call WrTx2ExtError(ERR139);	/* INVALID INDEX VARIABLE TYPE, NOT BYTE OR ADDRESS */
			return;
		end;
		if NotMatchTx2Item(L$EQ) then
		do;
			call WrTx2ExtError(ERR140);	/* MISSING '=' FOLLOWING INDEX VARIABLE */
			return;
		end;
		b99FF(controlSP) = 4;
		p = Sub$677C(w);
		q = Sub$6917;
		p = WrTx2Item2Arg(T2$STORE, Sub$42EF(p), Sub$42EF(q));
		s = GenLocalLabel;
		hNodes(controlSP) = s;
		p = WrTx2Item1Arg(T2$LOCALLABEL, s);
		p = Sub$677C(w);

		if MatchTx2Item(L$TO) then
			q = Sub$6917;
		else
		do;
			call WrTx2ExtError(ERR141);	/* MISSING 'TO' CLAUSE */
			q = WrTx2Item1Arg(T2$NUMBER, 0);
		end;

		p = WrTx2Item2Arg(T2$LE, Sub$42EF(p), Sub$42EF(q));
		t = GenLocalLabel;
		eNodes(controlSP) = t;
		p = WrTx2Item2Arg(T2$JMPFALSE, t, Sub$42EF(p));

		if NotMatchTx2Item(L$BY) then
			return;
		v = GenLocalLabel;
		w9AC7(controlSP) = v;
		p = WrTx2Item1Arg(T2$JMP, v);
		u = GenLocalLabel;
		w9A9F(controlSP) = u;
		p = WrTx2Item1Arg(T2$LOCALLABEL, u);
		p = Sub$677C(w);
		q = Sub$677C(w);
		r = Sub$6917;
		q = WrTx2Item2Arg(T2$ADDW, Sub$42EF(q), Sub$42EF(r));
		p = WrTx2Item2Arg(T2$STORE, Sub$42EF(p), Sub$42EF(q));
		p = WrTx2Item1Arg(T2$JNC, s);
		p = WrTx2Item1Arg(T2$JMP, t);
		p = WrTx2Item1Arg(T2$LOCALLABEL, v);
	end;

	ParseEND: PROCEDURE;
		declare p address;
		do case b99FF(controlSP);
			do;
				curInfo$p = curProcInfo$p;
				call SetInfoFlag(F$DEFINED);
				if GetDataType <> 0 and not b9A13(controlSP) then
					call WrTx2Error(ERR156);	/* MISSING RETURN STATEMENT IN TYPED PROCEDURE */
				p = WrTx2Item(T2$ENDPROC);
				curProcInfo$p = procInfoStack(controlSP);
			end;
			;
			do;
				p = WrTx2Item1Arg(T2$JMP, hNodes(controlSP));
				p = WrTx2Item1Arg(T2$LOCALLABEL, eNodes(controlSP));
			end;
			do;
				p = WrTx2Item1Arg(T2$LOCALLABEL, hNodes(controlSP));
				p = WrTx2Item(T2$ENDCASE);
			end;
			call Sub$67E3;
		end;
		call PopControl;
		call PopScope;
	end;

	ParseStatement: PROCEDURE;
		declare p address;
		if Sub$5945 then 
			p = StmtParse(markedStSP);
		call ChkEndOfStmt;
	end;


	ParseCALL: PROCEDURE;
		declare p address;
		if Sub$59D4 then
			p = StmtParse(markedStSP);
		call ChkEndOfStmt;
	end;

	ParseReturn: PROCEDURE;
		declare p address, i byte;
		if curProcInfo$p = 0 then
		do;
			call WrTx2Error(ERR155);	/* INVALID RETURN IN MAIN PROGRAM */
			return;
		end;
		curInfo$p = curProcInfo$p;
		i = GetDataType;
		if MatchTx2AuxFlag(128) then	/* there is an expression */
		do;
			call SetRegetTx1Item;
			if i = 0 then
				call WrTx2Error(ERR136);	/* INVALID RETURN FOR UNTYPED PROCEDURE, VALUE ILLEGAL */
			p = Sub$6917;
			if i = 2 then 
				p = WrTx2Item1Arg(T2$RETURNBYTE, Sub$42EF(p));
			else
				p = WrTx2Item1Arg(T2$RETURNWORD, Sub$42EF(p));
		end;
		else
		do;
			if i <> 0 then
				call WrTx2Error(ERR137);	/* MISSING VALUE IN RETURN FOR TYPED PROCEDURE */
			p = WrTx2Item(T2$RETURN);
		end;
		b9A13(controlSP) = 0ffh;
		call ChkEndOfStmt;
	end;

	ParseEIDIHLT: PROCEDURE;
		call MapLToT2;
		call ChkEndOfStmt;
	end;

	ParseGoto: PROCEDURE;
		declare p address;
		if NotMatchTx2Item(L$VARIABLE) then 
			call WrTx2Error(ERR142);	/* MISSING IDENTIFIER FOLLOWING GOTO */
		else
		do;
			call Sub$45E0;
			if GetType <> LABEL$T then 
				call WrTx2ExtError(ERR143);	/* INVALID REFERENCE FOLLOWING GOTO, NOT A LABEL */
			else
			do;
				if high(GetScope) = 1 and high(procChains(blockDepth)) <> 1 then
					call SetInfoFlag(F$MODGOTO);
				if high(GetScope) = 1 or high(GetScope) = high(procChains(blockDepth)) then
				do;
					p = WrTx2Item1Arg(T2$GO$TO, curInfo$p - botInfo);
					call ChkEndOfStmt;
				end;
				else 
					call WrTx2ExtError(ERR144); /* INVALID GOTO LABEL, NOT AT LOCAL OR MODULE LEVEL */
			end;
		end;
	end;


	ParseGo: PROCEDURE;
		if NotMatchTx2Item(L$TO) then
			call WrTx2Error(ERR145); 	/* MISSING 'TO' FOLLOWING 'GO' */
		call ParseGoto;
	end;

	ParseAT: PROCEDURE;
		declare p address;
		p = tx1Item.dataw(0);
		call GetTx1Item;
		call GetRestrictedExpr;
		call WrAtFileByte(ATI$AHDR);
		call WrAtFileWord(p - botInfo);
		call WrAtFileWord(curStmtNum);
		call WrAtFileWord(varInfoOffset);
		call WrAtFileWord(varArrayIndex);
		call WrAtFileWord(varNestedArrayIndex);
		call WrAtFileWord(varVal);
		call ExpectRparen(ERR146);	/* MISSING ') ' AFTER 'AT' RESTRICTED EXPRESSION */
	end;

	ParseDATA$INITIAL: PROCEDURE;
		declare (p, q) address;
		p = tx1Item.dataw(0);
		call GetTx1Item;
		q = ParseDataItems(p);
		if (curInfo$p := p) <> botInfo then
		    if TestInfoFlag(F$STARDIM) then
			call SetDimension(q);
	end;

	controlSP = 0;
	call GetTx1Item;
	do while tx1Item.type <> L$EOF;
        	curInfo$p = 0;
		do case b40B7(tx1Item.type);
			call ParseStmtcnt; 	/* L$STMTCNT */
			call PushScope(tx1Item.dataw(0));  /* L$SCOPE */
			call ParseEND;	/* L$END */
			call ParseIf;	/* L$IF */
			do;
				call ParseDOLOOP;		/* L$DOLOOP */
				call ChkEndOfStmt;
			end;
			call ParseWhile;	/* L$WHILE */
			call PushControl(1);	/* L$DO */
			call ParseProcedure;	/* L$PROCEDURE */
			call ParseCASE;	/* L$CASE */
			call ParseStatement;	/* L$STATEMENT */
			call ParseCALL;	/* L$CALL */
			call ParseReturn;	/* L$RETURN */
			call ParseGoto;	/* L$GOTO */
			call ParseGo;	/* L$GO */
			;			/* L$SEMICOLON */
			call ParseEIDIHLT;	/* L$ENABLE, L$DISABLE, L$HALT */
			call ParseAT;	/* L$AT */
			call ParseDATA$INITIAL;	/* L$DATA, L$INITIAL */
			;		/* expression items */
			call MapLToT2;	/* L$LABELDEF, L$LOCALLABEL, L$JMP, L$JMPFALSE, L$CASELABEL */
			do;
				curInfo$p = tx1Item.dataw(0);	/* L$EXTERNAL */
				call SetInfoFlag(F$DECLARED);
				call SetInfoFlag(F$DEFINED);
			end;
		end;
		call GetTx1Item;
	end;
end;
END;
src/plm1f.plm
plm1f: DO;
$include(:f2:plm1f.ipx)



declare externalsCnt byte initial(0),
	atStmtNum address initial(0),
	b9B40 byte;

Sub$6EE0: PROCEDURE public;

    Sub$6EF6: PROCEDURE(arg);
	DECLARE arg ADDRESS;
	DECLARE p ADDRESS;

	hasErrors = TRUE;
	p = curInfo$p - botInfo;
	call fwrite(.tx2File, .(T2$Error), 1);
	call fwrite(.tx2File, .arg, 2);
	call fwrite(.tx2File, .p, 2);
	call fwrite(.tx2File, .atStmtNum, 2);
    end;

    GetElementSize: PROCEDURE ADDRESS;
	DECLARE i BYTE;
	i = GetType - 2;
	if i > 2 then
	    return 0;
	do case i;
	    return 1;		/* byte */
	    return 2;		/* address */
	    return GetParentOffset; /* structure. Returns val not offeset for struct */
	end;
    end;

    GetVarSize: PROCEDURE ADDRESS;
	if TestInfoFlag(F$ARRAY) then
	    return GetDimension * GetElementSize;
	else
	    return GetElementSize;
    end;

    RevMemMov: PROCEDURE(srcp, dstp, cnt);
	DECLARE (srcp, dstp, cnt) ADDRESS;
	DECLARE srcw BASED srcp ADDRESS,
	    dstw BASED dstp ADDRESS;

	srcp = srcp + cnt - 2;
	dstp = dstp + cnt - 2;
	do while cnt > 1;
	    dstw = srcw;
	    cnt = cnt - 2;
	    dstp = dstp - 2;
	    srcp = srcp - 2;
	end;
	if cnt = 1 then
	    dstw = (dstw and 0ffh) or (srcw and 0ff00h);
    end;

    AdvNextDataInfo: PROCEDURE;
	do while 1;
	    call AdvNxtInfo;
	    if curInfo$p = 0 then
		return;
	    if GetType >= BYTE$T and GetType <= STRUCT$T then
		return;
	end;
    end;

    Sub$7049: PROCEDURE;
	DECLARE p ADDRESS, i BYTE;
	DECLARE hashChains BASED hashChains$p(1) ADDRESS;

	if  not b9B40 and not IXREF then
	    return;
	p = topSymbol - 1;
	do i = 0 to 63;
	    curSymbol$p = hashChains(i);
	    do while curSymbol$p <> 0;
		if (curInfo$p := cursym.info$p) <> 0 and high(curInfo$p) <> 0ffh then
		do;
			p = p - cursym.name(0) - 1;
			do while curInfo$p <> 0; 
				call SetSymbol(p);
				curInfo$p = GetLinkOffset;
			end;
			call fwrite(.nmsFile, .cursym.name, cursym.name(0) + 1);
		end;
		curSymbol$p = cursym.link;
	    end;
	end;
	call fwrite(.nmsFile, .(0), 1);
    end;


    Sub$711F: PROCEDURE;
	DECLARE (p, q, r, s) ADDRESS;

	curInfo$p = botInfo + 2;

	call AdvNextDataInfo;
	do while curInfo$p <> 0;
	    if GetType = STRUCT$T then
		call SetParentOffset(0);	/* struct size is 0 */
	    else if TestInfoFlag(F$MEMBER) then
	    do;
		r = GetVarSize;
		p = curInfo$p;
		curInfo$p = GetParentOffset;	/* get structure info */
		q = GetParentOffset;		/* this gets size so far */
		if (s := q + r) < r then	/* add in the new element */
			call Sub$6EF6(ERR208);	/* LIMIT EXCEEDED: STRUCTURE SIZE */
		call SetParentOffset(s);	/* store the running size */
		curInfo$p = p;
		call SetLinkVal(q);		/* use link value for offset of this memeber */
	    end;
	    call AdvNextDataInfo;
	end;
    end;

    Sub$719D: PROCEDURE;
        DECLARE i BYTE, p ADDRESS;


	AllocVarAddress: PROCEDURE(arg1w$p);
	    DECLARE arg1w$p ADDRESS,
		arg1w BASED arg1w$p ADDRESS;

	    call SetLinkVal(arg1w);		/* allocate this var's address */
	    arg1w = arg1w + GetVarSize;		/* reserve it's space */
	    if arg1w < GetVarSize then
		call Sub$6EF6(ERR207);	/* LIMIT EXCEEDED: SEGMENT SIZE */
	end;


	Sub$7323: PROCEDURE;
	    DECLARE (p, q) ADDRESS;

	    p = curInfo$p;
	    curInfo$p = procInfo(high(GetScope));
	    q = .info.parent;		/* varsize union with parent */
	    curInfo$p = p;
	    call AllocVarAddress(q);
	end;



	/* allocate external data ids */
        curInfo$p = botInfo + 2;
        standAlone = haveModule;
        
        do while curInfo$p <> 0;
		if GetType >= BYTE$T and GetType <= STRUCT$T 
		    or GetType = PROC$T or GetType = LABEL$T then
		do;
		    if TestInfoFlag(F$EXTERNAL) then
		    do;
			    call SetExternId(externalsCnt);
			    externalsCnt = externalsCnt + 1;
			    if externalsCnt = 0 then
				call Sub$6EF6(ERR219);	/* LIMIT EXCEEDED: NUMBER OF EXTERNALS > 255 */
			    call SetLinkVal(0);
			    standAlone = false;
		    end;
		    else if TestInfoFlag(F$PUBLIC) then
			    standAlone = false;
		end;
		call AdvNxtInfo;
        end;
        
	/* allocate data variables */
        curInfo$p = botInfo + 2;	/* start at bottom */
        call AdvNextDataInfo;			/* find next data */
        
        do while curInfo$p <> 0;
		if not (TestInfoFlag(F$MEMBER) or TestInfoFlag(F$AT) or TestInfoFlag(F$EXTERNAL)) then
		do;
		    if TestInfoFlag(F$PARAMETER) then
		    do;
			    p = curInfo$p;
			    curInfo$p = procInfo(high(GetScope));
			    i = TestInfoFlag(F$EXTERNAL);	/* only allocate parameter if not external */
			    curInfo$p = p;
		    end;
		    else 
			    i = FALSE;
		    if i then
			    call SetLinkVal(0);		/* external parameter has 0 offset */
		    else if TestInfoFlag(F$BASED) then
			    call SetLinkVal(0);		/* based var has 0 offset */
		    else if TestInfoFlag(F$DATA) then
			    call AllocVarAddress(.csegSize);	/* allocate initialised data var */
		    else if TestInfoFlag(F$MEMORY) then
			    ;				/* memory is predefined */
		    else if TestInfoFlag(F$AUTOMATIC) then	/* allocate stack var */
			    call Sub$7323;
		    else
			    call AllocVarAddress(.dsegSize);	/* allocate uninitalised data */
		end;
		call AdvNextDataInfo;		/* get next data */
        end;
    end;



    ProcAtFile: PROCEDURE;
	   declare atFData STRUCTURE(type byte, info$p address, stmtNum address,
		varInfoOffset address, varArrayIndex address, varNestedArrayIndex address,
		val address, pad(242) byte); 

	    Sub$73DC: PROCEDURE;
		declare atOffset address;

		    Sub$7486: PROCEDURE;
			DECLARE (i, j) BYTE;
			if atFData.varInfoOffset = 0 then
			    i = 0;
			else if GetType > STRUCT$T or GetType < BYTE$T then
			do;
			    i = 0;
			    call Sub$6EF6(ERR211);	/* INVALID IDENTIFIER IN 'AT' RESTRICTED REFERENCE */
			end;
			else if TestInfoFlag(F$EXTERNAL) then
			do;
			    i = 1;
			    j = GetExternId;
			end;
			else if TestInfoFlag(F$DATA) then
			    i = 2;
			else if TestInfoFlag(F$AUTOMATIC) then
			    i = 3;
			else if TestInfoFlag(F$MEMORY) then
			    i = 4;
			else if TestInfoFlag(F$BASED) then
			do;
			    i = 0;
			    call Sub$6EF6(ERR212);	/* INVALID RESTRICTED REFERENCE IN 'AT' , BASE ILLEGAL */
			end;
			else if TestInfoFlag(F$ABSOLUTE) then
			    i = 0;
			else
			    i = 5;
			curInfo$p = atFData.info$p;

			do while 1;
			    if not TestInfoFlag(F$MEMBER) then
			    do;
				if TestInfoFlag(F$DATA) then
				do;
					call ClrFlag(.info.flag, F$DATA);
					call SetInfoFlag(F$INITIAL);
				end;
				call SetLinkVal(atOffset);
				atOffset = atOffset + GetVarSize;
				do case i;
				call SetInfoFlag(F$ABSOLUTE); 
				do;
				    if TestInfoFlag(F$PUBLIC) then
					call Sub$6EF6(ERR178); /* INVALID 'AT' RESTRICTED REFERENCE, EXTERNAL
							    ATTRIBUTE CONFLICTS WITH PUBLIC ATTRIBUTE */
				    call SetInfoFlag(F$EXTERNAL);
				    call SetExternId(j);
				end;
				call SetInfoFlag(F$DATA);
				call SetInfoFlag(F$AUTOMATIC); 
				call SetInfoFlag(F$MEMORY);
				;
				end;
			    end;
			    call AdvNextDataInfo;
			    if curInfo$p = 0 then
				return;
			    if not (TestInfoFlag(F$PACKED) or TestInfoFlag(F$MEMBER)) then
				return;
			end;
		    end;


		call fread(.atFile, .atFData.info$p, 12);
		if atFData.info$p = 0 then
		    return;
		atFData.info$p = atFData.info$p + botInfo;
		atStmtNum = atFData.stmtNum;
		atOffset = atFData.val;
		if atFData.varInfoOffset <> 0 then
		do;
		    curInfo$p = atFData.varInfoOffset + botInfo;
		    if TestInfoFlag(F$MEMBER) then
		    do;
			atOffset = GetElementSize * atFData.varNestedArrayIndex + atOffset + GetLinkVal;
			curInfo$p = GetParentOffset;
		    end;
		    atOffset =  GetLinkVal + GetElementSize * atFData.varArrayIndex + atOffset;
		    if TestInfoFlag(F$AT) then
			if curInfo$p >= atFData.info$p then
				call Sub$6EF6(ERR213);	/* UNDEFINED RESTRICTED REFERENCE IN 'AT' */
		end;
		call Sub$7486;
	    end;
	
	do while 1;
	    call fread(.atFile, .atFData.type, 1);
	    do case atFData.type;
	    call Sub$73DC;					/* AT$AHDR */
	    call fread(.atFile, .atFData.info$p, 4);	/* AT$DHDR */
	    call fread(.atFile, .atFData.val, 2);		/* AT$2 */
	    do;						/* AT$STRING */
		call fread(.atFile, .atFData.val, 2);
		call fread(.atFile, .atFData.type, atFData.val);
	    end;
	    call fread(.atFile, .atFData.varInfoOffset, 8); /* AT$DATA */
	    ;						/* AT$END */
	    return;						/* AT$EOF */
	    end;
	end;
    end;





    Sub$75F7: PROCEDURE;
	DECLARE w BASED w3822 ADDRESS;

	botInfo = botMem + topMem - topInfo;
	topInfo = topMem;
	call RevMemMov(botMem, botInfo, topInfo - botInfo + 1);
	helpers$p = botInfo - shl(117,1);
	localLabels$p = helpers$p - (localLabelCnt+1) * 2;
	w381E = localLabels$p - (localLabelCnt+1);
	w3822 = botInfo - 2;
	do while w3822 >= w381E;
	    w = 0;
	    w3822 = w3822 - 2;
	end;
	if w3822 = w381E - 1 then
	    w = w and 0ffh;
	w3822 = w381E - 2;
    end;


    Sub$7695: PROCEDURE;
	if (b9B40 := OBJECT or PRINT) or IXREF then
	do;
	    call OpenF(.nmsFile, 3);
	    call CreatF(.nmsFile, .xrfBuf, 512, 2);
	end;
	call CreatF(.atFile, .atBuf, 512, 1);
	csegSize, dsegSize = 0;
    end;


    Sub$76D9: PROCEDURE;
        DECLARE i BYTE;
        
        if b9B40 or IXREF then
        do;
	call Fflush(.nmsFile);
	call Rewind(.nmsFile);
        end;
        call Rewind(.atFile);		/* used for string data */
        call fwrite(.tx2File, .(T2$EOF), 1);
        call Fflush(.tx2File);
        call Rewind(.tx2File);
	do i = 1 to procCnt;
	    procInfo(i) = procInfo(i) - botMem;
	end;
    end;


    call Sub$7695;
    call Sub$7049;
    call Sub$711F;
    call Sub$719D;
    call ProcAtFile;
    call Sub$75F7;
    call Sub$76D9;
end Sub$6EE0;

end;

src/plm2a.plm
plm2a: DO;
$include(:f2:plm2a.ipx)

declare unused(*) BYTE public DATA(2, 2, 3, 4, 3, 4, 2, 2, 3, 4, 2, 3, 2, 3, 3, 3, 3,
			2, 2, 3, 4, 2, 3, 2, 3, 2, 2, 2, 2, 3, 2, 2, 2, 3,
			2, 3, 2, 2, 3, 2, 2, 1, 2, 2, 3, 4),

	b3FCD(*) BYTE public DATA(0, 2, 4, 7, 0Bh, 0Eh, 12h, 14h, 16h, 19h, 1Dh, 1Fh,
			22h, 24h, 27h, 2Ah, 2Dh, 30h, 32h, 34h, 37h, 3Bh, 3Dh,
			40h, 42h, 45h, 47h, 49h, 4Bh, 4Dh, 50h, 52h, 54h, 56h,
			59h, 5Bh, 5Eh, 60h, 62h, 65h, 67h, 69h, 6Ah, 6Ch, 6Eh,
			71h, 24h, 24h, 24h, 24h, 13h, 13h, 18h, 18h, 18h, 18h,
			16h, 2Ch, 15h, 1Fh, 1Fh, 20h, 20h, 19h, 19h, 19h, 19h,
			8, 8, 9, 9, 6, 7, 25h, 25h, 25h, 25h, 25h, 0Ah, 0Ah,
			0Bh, 0Bh, 14h, 14h, 14h, 14h, 14h, 39h, 1Ah, 1Ah, 1Ah,
			1Ah),

	b4029(*) BYTE public DATA(0, 0, 0, 0, 26h, 30h, 30h, 26h, 30h, 20h, 30h, 12h,
			12h, 12h, 0, 10h, 10h, 10h, 10h, 10h, 10h, 60h, 0,
			26h, 20h, 20h, 0, 0, 0, 0, 0, 0, 10h, 80h, 80h, 80h,
			90h, 90h, 40h, 0A0h, 0A0h, 0A0h, 80h, 0B0h, 90h, 80h,
			0B0h, 90h, 80h, 0B0h, 90h, 80h, 0B0h, 90h, 80h, 0B0h,
			90h, 20h, 30h, 30h, 30h, 10h, 10h, 70h, 70h, 30h, 30h,
			30h, 30h, 80h, 80h, 80h, 80h, 80h, 80h, 80h, 80h, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20h, 20h, 0, 0, 20h,
			0, 0, 2Ch, 40h, 0, 10h, 10h, 60h, 20h, 0, 0, 0A0h,
			0A0h, 0A0h, 0A0h, 32h, 16h, 10h, 20h, 0, 10h, 10h,
			10h, 10h, 10h, 60h, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 70h, 60h, 60h, 70h, 50h, 70h, 60h, 60h,
			0E0h, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 80h, 80h, 80h, 80h, 80h, 80h,
			0, 0, 80h, 80h, 80h, 80h, 80h, 80h, 80h, 80h, 80h,
			80h, 80h, 80h, 80h, 80h, 80h, 80h, 80h, 80h, 80h, 80h,
			80h, 80h, 80h, 80h, 80h, 80h, 80h, 80h, 80h, 80h, 80h,
			80h, 80h, 80h, 80h, 80h, 80h, 80h, 80h, 80h, 80h, 80h,
			80h, 80h, 80h, 80h, 80h, 80h, 80h, 80h, 80h, 80h, 80h,
			80h, 80h, 80h, 80h, 80h, 80h, 80h, 80h, 80h, 80h, 80h,
			80h, 80h, 80h, 80h, 80h, 80h, 80h, 80h, 80h, 80h, 80h,
			80h, 80h, 80h, 80h, 80h, 80h),

	b4128(*) BYTE public DATA(0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8,
			9, 0Ah),

	b413B(*) BYTE public DATA(0, 2, 4, 6, 8, 0Ah, 0Ch, 10h, 11h, 0Eh, 12h, 0, 2,
			4, 6, 8, 0Ah, 0Ch, 10h, 11h, 0Eh, 12h, 0, 2, 4, 6,
			8, 0Ah, 0Ch, 10h, 11h, 0Eh, 12h, 0, 2, 4, 6, 8, 0Ah,
			0Ch, 10h, 11h, 0Eh, 12h, 0, 2, 4, 6, 8, 0Ah, 0Ch, 10h,
			11h, 0Eh, 12h, 0Ch, 11h, 12h, 0Ch, 11h, 12h, 2, 6,
			0, 4, 6, 8, 0Ah, 0Ch, 0Eh, 10h, 11h, 12h, 0Dh, 0Fh,
			7, 9, 0Bh, 1, 5, 3),

	b418C(*) BYTE public DATA(90h, 91h, 94h, 95h, 98h, 99h, 9Ah, 9Ch, 0A0h, 0A1h,
			9Dh, 6Ch, 6Dh, 70h, 71h, 74h, 75h, 76h, 78h, 7Ch, 7Dh,
			79h, 0, 0, 0, 0, 0, 0, 64h, 65h, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 68h, 69h, 0, 0, 0, 0, 58h, 0, 0, 59h, 5Ah,
			54h, 55h, 0, 0, 0, 0, 60h, 0, 0, 61h, 62h, 5Ch, 5Dh,
			0, 0, 0, 0, 84h, 0, 0, 85h, 86h, 80h, 81h, 0, 0, 0,
			0, 8Ch, 0, 0, 8Dh, 8Eh, 88h, 89h, 0, 0, 0, 0, 0, 0,
			0, 10h, 11h, 12h, 14h, 15h, 16h, 17h, 0, 1, 4, 5, 8,
			9, 0Ah, 0Ch, 0Dh, 0Eh, 0Fh, 0, 30h, 0, 31h, 0, 0, 0,
			0, 0, 0, 0, 0, 28h, 0, 29h, 0, 0, 0, 0, 0, 0, 0, 18h,
			19h, 1Ch, 1Dh, 20h, 21h, 22h, 24h, 25h, 26h, 27h, 44h,
			45h, 48h, 49h, 4Ch, 4Dh, 4Eh, 50h, 51h, 52h, 53h, 0A8h,
			0A9h, 0ACh, 0ADh, 0B0h, 0B1h, 0B2h, 0B4h, 0B5h, 0B6h,
			0B7h, 34h, 36h, 35h, 38h, 39h, 3Ah, 0, 0, 0, 0, 0,
			3Ch, 3Dh, 3Eh, 40h, 41h, 42h, 0, 0, 0, 0, 0, 0, 2Ch,
			0, 0, 2Dh, 2Eh, 0, 0, 0, 0, 0, 0A4h, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0),

	b425D(*) BYTE public DATA(8, 1Ch, 0Ch, 0, 0Bh, 11h, 1, 0Ah, 0Fh, 10h, 0Dh, 9,
			2, 3, 4, 5, 6, 7, 0, 1Eh, 12h, 0Eh),

	b4273(*) BYTE public DATA(3, 3, 3, 3, 3, 3, 0Ch, 0Dh, 0Eh, 0Fh, 10h, 11h, 0,
			0, 0, 0, 0, 0, 0, 0, 12h, 7, 4, 4, 2, 0Ah, 15h, 0,
			0, 0, 0, 8, 9, 0, 0, 0, 0Bh, 6, 12h, 12h, 12h, 12h,
			12h, 12h, 5, 1, 1, 1, 13h, 13h, 13h, 1, 1, 1, 13h,
			13h, 13h, 14h, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 1, 1, 0Ch, 0Ch, 0Ch, 0Ch, 0Ch, 0Ch,
			0Ch, 0Ch, 0Dh, 0Dh, 0Dh, 0Dh, 0Dh, 0Dh, 0Dh, 0Dh, 0,
			0Eh, 0Eh, 0Eh, 0Eh, 0Fh, 0Fh, 0Fh, 0Fh, 0, 0Fh, 0Fh,
			0Fh, 0Fh, 0Eh, 0Eh, 0Eh, 0Eh, 0, 10h, 10h, 10h, 10h,
			10h, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0,
			0),

	b42F9(*) BYTE public DATA(0, 0, 0, 0, 0, 0, 0, 0, 0, 10h, 0, 0, 0, 0, 0, 0, 0,
			0, 10h, 0, 20h, 0, 0, 13h, 0, 0, 0, 0, 0, 0, 0, 0,
			50h, 0, 0, 0, 10h, 10h, 20h, 10h, 10h, 10h, 0, 50h,
			50h, 0, 50h, 50h, 0, 50h, 50h, 0, 50h, 50h, 0, 50h,
			50h, 40h, 0, 10h, 10h, 20h, 20h, 60h, 60h, 60h, 60h,
			60h, 60h, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 40h, 40h, 0, 0, 10h, 0, 0, 21h, 10h,
			0, 10h, 10h, 10h, 40h, 0, 0, 10h, 10h, 10h, 10h, 12h,
			0, 0, 40h, 0, 0, 0, 0, 0, 0, 10h, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),

	b43F8(*) BYTE public DATA(0, 20h, 40h, 60h, 81h, 81h, 84h, 83h, 83h, 1, 83h,
			82h, 83h, 81h, 81h, 82h, 83h, 83h, 1, 83h, 81h, 82h,
			81h, 81h, 81h, 81h, 81h, 81h, 21h, 22h, 23h, 24h, 82h,
			81h, 82h, 83h, 1, 2, 2, 21h, 22h, 23h, 1, 2, 1, 2,
			3, 2, 4, 5, 4, 4, 5, 4, 3, 4, 3, 21h, 85h, 83h, 83h,
			84h, 83h, 3, 23h, 88h, 89h, 8Dh, 91h, 1, 2, 3, 4, 5,
			4, 3, 2, 5, 4, 3, 2, 4, 5, 6, 6, 5, 4, 3, 62h, 41h,
			1, 2, 2, 2, 1, 8Ah, 82h, 83h, 1, 1, 84h, 61h, 0Ch,
			0Eh, 41h, 42h, 61h, 62h, 3, 2, 1, 62h, 61h, 0, 0, 0,
			0, 0, 84h, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 20h, 20h, 20h, 20h, 20h, 22h, 23h, 23h, 23h, 23h,
			6, 6, 6, 1, 1, 1, 2, 20h, 60h, 3, 20h, 40h, 0, 0, 0,
			0, 0, 0, 60h, 60h, 40h, 0, 80h, 84h, 7, 7, 4, 5, 0,
			0, 84h, 84h, 84h, 84h, 84h, 84h, 84h, 84h, 84h, 84h,
			84h, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
			7, 7, 7, 7, 7, 7, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
			5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 43h, 43h, 43h, 63h,
			63h, 63h, 23h, 23h, 23h, 23h, 23h, 23h, 23h, 23h, 23h,
			23h, 23h, 23h, 3, 3, 23h, 23h, 23h, 23h, 23h, 23h),

	b44F7(*) BYTE public DATA(55h, 55h, 55h, 55h, 55h, 55h, 50h, 5Ch, 5Dh, 5Eh, 5,
			50h, 5Ch, 5Dh, 0EDh, 0CDh, 0DEh, 0DCh, 0DEh, 0DCh,
			0DEh, 0DCh, 85h, 85h, 85h, 5, 15h, 25h, 35h, 0C5h,
			0D5h, 0E5h, 5, 15h, 25h, 35h, 0C5h, 0D5h, 0E5h, 0C5h,
			0D5h, 0E5h, 0FEh, 85h, 40h, 0B0h, 0B1h, 0B2h, 0BCh,
			0BDh, 80h, 81h, 82h, 8Ch, 8Dh, 5Eh, 15h, 25h, 35h,
			0C5h, 0D5h, 0E5h, 0C5h, 0D5h, 0E5h, 5, 5, 0E5h, 5,
			0E5h, 5, 0E5h, 5, 0E5h, 5, 5, 5, 5, 5, 5, 5, 5, 5,
			5, 5, 5, 5, 5, 0B1h, 0E1h, 0D1h, 0B1h, 0E1h, 0D1h,
			81h, 1, 81h, 1, 81h, 1, 0B1h, 0E1h, 0D1h, 5, 5, 0C5h,
			0D5h, 0E5h, 95h, 0B5h, 0A5h, 5, 0C5h, 0D5h, 0E5h, 95h,
			0A5h, 0B5h, 0C5h, 0D5h, 0E5h, 95h, 0A5h, 0B5h, 5, 15h,
			25h, 35h, 5, 15h, 25h, 35h, 0C5h, 0D5h, 0E5h, 65h,
			75h, 85h, 95h, 0A5h, 0B5h, 0C5h, 0D5h, 0E5h, 65h, 75h,
			85h, 95h, 0A5h, 0B5h, 0BCh, 0BDh, 9Eh, 0AEh, 8Ch, 8Dh,
			6Eh, 7Eh, 6Ah, 7Bh, 8Ah, 86h, 87h, 68h, 78h, 89h, 8Ah,
			6Bh, 7Bh, 0E6h, 0E7h, 0C8h, 0D8h, 0E9h, 0EAh, 0CBh,
			0DBh, 0A6h, 0B7h, 0A8h, 0A9h, 0BAh, 0ABh, 0C5h, 0D5h,
			0E5h, 0C5h, 0D5h, 0E5h, 0C5h, 0D5h, 0E5h, 0C5h, 0D5h,
			0E5h, 0C5h, 0D5h, 0E5h, 0C5h, 0D5h, 0E5h, 5, 0C5h,
			0D5h, 0E5h, 0E5h, 55h, 0EDh, 0CEh, 0DEh, 0ECh, 0A0h,
			0B0h, 0BDh, 0AEh, 0Ah, 0Bh, 0DBh, 0EAh, 80h, 50h, 10h,
			20h, 30h, 9Ah, 0BAh, 0CAh, 8, 5, 1, 2, 3, 0A9h, 0ABh,
			0ACh, 0A0h, 0B0h, 0BDh, 0AEh, 0Ah, 0Bh, 0DBh, 0EAh,
			80h, 50h, 10h, 20h, 30h, 9Ah, 0BAh, 0CAh, 8, 5, 1,
			2, 3, 0A9h, 0ABh, 0ACh, 0E0h, 0EDh, 0Dh, 0CDh, 0Eh,
			0DEh, 0D0h, 0DCh, 0Eh, 0DEh, 0D0h, 0DCh, 8, 5, 1, 2,
			3, 0A9h, 0ABh, 0ACh, 0Bh, 0DBh, 0A0h, 0AEh, 0A9h, 0ABh,
			0ACh, 0Bh, 0DBh, 0A0h, 0AEh, 0Eh, 0DEh, 0D0h, 0DCh,
			8, 5, 1, 2, 3, 8, 5, 1, 2, 3, 0A9h, 0ABh, 0ACh, 0Bh,
			0DBh, 0A0h, 0AEh, 0Eh, 0DEh, 0D0h, 0DCh, 9Ah, 0BAh,
			0CAh, 0B0h, 0BDh, 0Ah, 0EAh, 0E0h, 0EDh, 0Dh, 0CDh,
			80h, 50h, 10h, 20h, 30h, 80h, 50h, 10h, 20h, 30h, 9Ah,
			0BAh, 0CAh, 0B0h, 0BDh, 0Ah, 0EAh, 0E0h, 0EDh, 0Dh,
			0CDh, 8, 5, 1, 2, 3, 0A9h, 0ABh, 0ACh, 0Bh, 0DBh, 0A0h,
			0AEh, 0Eh, 0DEh, 0D0h, 0DCh, 80h, 50h, 10h, 20h, 30h,
			9Ah, 0BAh, 0CAh, 0B0h, 0BDh, 0Ah, 0EAh, 0E0h, 0EDh,
			0Dh, 0CDh, 8, 5, 1, 2, 3, 0A9h, 0ABh, 0ACh, 0Bh, 0DBh,
			0A0h, 0AEh, 0Eh, 0DEh, 0D0h, 0DCh, 80h, 50h, 10h, 20h,
			30h, 9Ah, 0BAh, 0CAh, 0B0h, 0BDh, 0Ah, 0EAh, 0E0h,
			0EDh, 0Dh, 0CDh, 8, 5, 1, 2, 3, 0A9h, 0ABh, 0ACh, 0Bh,
			0DBh, 0A0h, 0AEh, 0Eh, 0DEh, 0D0h, 0DCh, 80h, 50h,
			10h, 20h, 30h, 9Ah, 0BAh, 0CAh, 0B0h, 0BDh, 0Ah, 0EAh,
			0E0h, 0EDh, 0Dh, 0CDh, 8, 5, 1, 2, 3, 0A9h, 0ABh, 0ACh,
			0Bh, 0DBh, 0A0h, 0AEh, 0Eh, 0DEh, 0D0h, 0DCh, 80h,
			50h, 10h, 20h, 30h, 9Ah, 0BAh, 0CAh, 0B0h, 0BDh, 0Ah,
			0EAh, 0E0h, 0EDh, 0Dh, 0CDh, 0CDh, 35h, 0E5h, 15h,
			25h, 35h, 0C5h, 0D5h, 0E5h, 0C5h, 0D5h, 0E5h, 0E5h,
			65h, 75h, 85h, 95h, 0A5h, 0B5h, 65h, 75h, 85h, 65h,
			75h, 85h),

	b46EB(*) BYTE public DATA(18h, 26h, 18h, 18h, 18h, 18h, 0, 12h, 12h, 12h, 2Eh,
			27h, 27h, 27h, 2Dh, 2Ah, 2Dh, 2Ah, 2Bh, 28h, 2Ch, 29h,
			0, 0, 0, 12h, 7, 5, 2, 7, 5, 2, 12h, 7, 5, 2, 7, 5,
			2, 7, 5, 2, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12h, 12h, 2, 12h, 2,
			12h, 2, 12h, 2, 12h, 12h, 12h, 12h, 12h, 12h, 12h,
			12h, 12h, 12h, 12h, 12h, 12h, 12h, 0Ah, 9, 0Bh, 0Ah,
			9, 0Bh, 17h, 17h, 17h, 17h, 17h, 17h, 23h, 22h, 24h,
			12h, 12h, 1Eh, 1Eh, 1Dh, 1Fh, 20h, 1Ch, 12h, 12h, 12h,
			12h, 12h, 12h, 2, 12h, 12h, 12h, 0Dh, 10h, 13h, 12h,
			7, 5, 2, 12h, 7, 5, 2, 7, 5, 2, 7, 5, 2, 7, 5, 2, 7,
			5, 2, 7, 5, 2, 7, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1Ch,
			20h, 1Ch, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
			2, 2, 1Ch, 20h, 1Ch, 1Ch, 20h, 1Ch, 7, 5, 2, 7, 5,
			2, 7, 5, 2, 7, 5, 2, 7, 5, 2, 7, 5, 2, 0, 0, 0, 0,
			0, 0, 2, 2, 2, 2, 1Ch, 20h, 20h, 1Ch, 1Ch, 20h, 20h,
			1Ch, 12h, 12h, 12h, 12h, 12h, 1Ah, 21h, 1Ch, 12h, 12h,
			12h, 12h, 12h, 1Ah, 21h, 1Ch, 1Ch, 20h, 20h, 1Ch, 1Ch,
			20h, 20h, 1Ch, 12h, 12h, 12h, 12h, 12h, 1Ah, 21h, 1Ch,
			12h, 12h, 12h, 12h, 12h, 1Ah, 21h, 1Ch, 1Bh, 1Dh, 19h,
			1Dh, 1Bh, 1Dh, 19h, 1Dh, 1Bh, 1Dh, 19h, 1Dh, 12h, 12h,
			12h, 12h, 12h, 1Ah, 21h, 1Ch, 20h, 20h, 1Ch, 1Ch, 1Ah,
			21h, 1Ch, 20h, 20h, 1Ch, 1Ch, 1Bh, 1Dh, 19h, 1Dh, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 1Ah, 21h, 1Ch, 20h, 20h,
			1Ch, 1Ch, 1Bh, 1Dh, 19h, 1Dh, 1Ah, 21h, 1Ch, 20h, 20h,
			1Ch, 1Ch, 1Bh, 1Dh, 19h, 1Dh, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 1Ah, 21h, 1Ch, 20h, 20h, 1Ch, 1Ch, 1Bh, 1Dh,
			19h, 1Dh, 12h, 12h, 12h, 12h, 12h, 0Eh, 16h, 11h, 15h,
			15h, 11h, 11h, 0Fh, 14h, 0Ch, 14h, 12h, 12h, 12h, 12h,
			12h, 0Eh, 16h, 11h, 15h, 15h, 11h, 11h, 0Fh, 14h, 0Ch,
			14h, 12h, 12h, 12h, 12h, 12h, 0Eh, 16h, 11h, 15h, 15h,
			11h, 11h, 0Fh, 14h, 0Ch, 14h, 12h, 12h, 12h, 12h, 12h,
			0Eh, 16h, 11h, 15h, 15h, 11h, 11h, 0Fh, 14h, 0Ch, 14h,
			12h, 12h, 12h, 12h, 12h, 0Eh, 16h, 11h, 15h, 15h, 11h,
			11h, 0Fh, 14h, 0Ch, 14h, 12h, 12h, 12h, 12h, 12h, 0Eh,
			16h, 11h, 15h, 15h, 11h, 11h, 0Fh, 14h, 0Ch, 14h, 12h,
			12h, 12h, 12h, 12h, 0Eh, 16h, 11h, 15h, 15h, 11h, 11h,
			0Fh, 14h, 0Ch, 14h, 12h, 12h, 12h, 12h, 12h, 0Eh, 16h,
			11h, 15h, 15h, 11h, 11h, 0Fh, 14h, 0Ch, 14h, 25h, 26h,
			26h, 0, 0, 0, 0, 0, 0, 7, 5, 2, 2, 7, 5, 2, 7, 5, 2,
			7, 5, 2, 7, 5, 2),

	w48DF(*) ADDRESS public DATA(0, 1, 1000h, 1000h, 2000h, 2000h, 2000h, 4000h, 4000h,
			5000h, 6008h, 6000h, 5080h, 8040h, 0D088h, 3010h, 8008h,
			9008h, 8000h, 8001h, 9000h, 0A008h, 0D088h, 0C000h,
			0F000h, 5080h, 0D088h, 3010h, 9008h, 9000h, 0A000h,
			0B008h, 0A008h, 0D088h, 0D000h, 0E008h, 0E000h, 0E000h,
			0F000h, 0F000h, 0B000h, 0B000h, 0B000h, 0E000h, 0E000h,
			0E000h, 0C000h),

	w493D(*) ADDRESS public DATA(123h, 123h, 124h, 126h, 134h, 143h, 163h, 423h, 623h,
			624h, 634h, 634h, 4026h, 4123h, 4126h, 4106h, 4123h,
			4126h, 4123h, 4123h, 4126h, 4136h, 4326h, 4623h, 4666h,
			6024h, 6124h, 6104h, 6124h, 6124h, 6134h, 6114h, 6134h,
			6324h, 6624h, 6634h, 6634h, 6663h, 6664h, 6666h, 5146h,
			5164h, 5154h, 5346h, 5364h, 5354h, 5623h),

	b499B(*) BYTE public DATA(10h, 10h, 20h, 20h, 10h, 10h, 2, 2, 5, 5, 5, 5, 1,
			3, 1, 6, 3, 3, 3, 1Ch, 10h, 4, 2, 2, 20h, 20h, 20h,
			0Eh, 7, 4, 8, 7, 7, 6, 6, 6, 20h, 10h, 10h, 10h, 20h,
			20h, 10h, 10h, 3, 7, 7, 3, 7, 7, 3, 1, 1, 1, 1, 1,
			1, 1, 6, 3, 1, 0Eh, 4, 2, 6, 0Dh, 1, 1, 1, 1, 1, 4,
			1, 1, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			1, 1, 1, 1, 4, 1, 1, 1, 1, 1, 1, 1, 1, 4, 1, 1, 1,
			1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1,
			1, 1, 1, 1, 3, 3, 3, 1Ch, 2, 1, 1),

	b4A21(*) BYTE public DATA(3Fh, 40h, 44h, 43h, 41h, 42h, 60h, 6Ch, 6Ch, 6Ch, 61h,
			64h, 5Fh, 5Fh, 0EBh, 0EFh, 0EBh, 0EFh, 0EBh, 0EFh,
			0EBh, 0EFh, 21h, 22h, 23h, 24h, 24h, 24h, 24h, 27h,
			27h, 27h, 25h, 25h, 25h, 25h, 28h, 28h, 28h, 29h, 29h,
			29h, 3Bh, 26h, 3Ch, 3Dh, 3Dh, 3Dh, 3Eh, 3Eh, 14h, 14h,
			14h, 14h, 14h, 16h, 17h, 17h, 17h, 17h, 17h, 17h, 17h,
			17h, 17h, 4Ch, 45h, 1Ch, 46h, 1Dh, 47h, 1Eh, 48h, 1Fh,
			49h, 4Ah, 4Bh, 4Dh, 4Eh, 4Fh, 50h, 51h, 52h, 53h, 54h,
			55h, 56h, 57h, 0FEh, 0FBh, 0FAh, 0FEh, 0FBh, 0FAh,
			0F7h, 0F8h, 0F7h, 0F8h, 0F7h, 0F8h, 0FEh, 0FBh, 0FAh,
			5Eh, 5Ah, 0F9h, 0FAh, 0FBh, 0FCh, 0FEh, 0FDh, 5Bh,
			62h, 62h, 62h, 9, 9, 12h, 63h, 63h, 63h, 5Ch, 5Ch,
			5Dh, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3,
			3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 58h, 58h, 6Fh, 6Fh, 59h,
			59h, 59h, 59h, 0E5h, 0E6h, 0E7h, 59h, 59h, 59h, 59h,
			65h, 65h, 65h, 65h, 59h, 59h, 59h, 59h, 65h, 65h, 65h,
			65h, 0E5h, 0E6h, 0E7h, 0E8h, 0E9h, 0EAh, 2, 2, 2, 68h,
			68h, 68h, 69h, 69h, 69h, 3, 3, 3, 6Ah, 6Ah, 6Ah, 6Bh,
			6Bh, 6Bh, 1Bh, 20h, 20h, 20h, 1Bh, 1Bh, 39h, 39h, 39h,
			39h, 0F3h, 0F4h, 0F5h, 0F6h, 0F3h, 0F4h, 0F5h, 0F6h,
			2Ah, 2Bh, 2Ch, 2Ch, 2Ch, 0F0h, 0F1h, 0F2h, 2Ah, 2Bh,
			2Ch, 2Ch, 2Ch, 0F0h, 0F1h, 0F2h, 0F3h, 0F4h, 0F5h,
			0F6h, 0F3h, 0F4h, 0F5h, 0F6h, 2Ah, 2Bh, 2Ch, 2Ch, 2Ch,
			0F0h, 0F1h, 0F2h, 2Ah, 2Bh, 2Ch, 2Ch, 2Ch, 0F0h, 0F1h,
			0F2h, 0EDh, 0EBh, 0EEh, 0EFh, 0EDh, 0EBh, 0EEh, 0EFh,
			0EDh, 0EBh, 0EEh, 0EFh, 2Ah, 2Bh, 2Ch, 2Ch, 2Ch, 0F0h,
			0F1h, 0F2h, 0F4h, 0F5h, 0F3h, 0F6h, 0F0h, 0F1h, 0F2h,
			0F4h, 0F5h, 0F3h, 0F6h, 0EDh, 0EBh, 0EEh, 0EFh, 2Ah,
			2Bh, 2Ch, 2Ch, 2Ch, 2Ah, 2Bh, 2Ch, 2Ch, 2Ch, 0B2h,
			0B3h, 0B4h, 0B5h, 0B6h, 0B7h, 0B8h, 0AEh, 0AFh, 0B0h,
			0B1h, 0B2h, 0B3h, 0B4h, 0B5h, 0B6h, 0B7h, 0B8h, 0AEh,
			0AFh, 0B0h, 0B1h, 2Ah, 2Bh, 2Ch, 2Ch, 2Ch, 2Ah, 2Bh,
			2Ch, 2Ch, 2Ch, 0F0h, 0F1h, 0F2h, 0F4h, 0F5h, 0F3h,
			0F6h, 0EDh, 0EBh, 0EEh, 0EFh, 2Dh, 2Eh, 2Fh, 2Fh, 2Fh,
			0D3h, 0D4h, 0D5h, 0D6h, 0D7h, 0D8h, 0D9h, 0CFh, 0D0h,
			0D1h, 0D2h, 2Dh, 2Eh, 2Fh, 2Fh, 2Fh, 0D3h, 0D4h, 0D5h,
			0D6h, 0D7h, 0D8h, 0D9h, 0CFh, 0D0h, 0D1h, 0D2h, 36h,
			37h, 38h, 38h, 38h, 0DEh, 0DFh, 0E0h, 0E1h, 0E2h, 0E3h,
			0E4h, 0DAh, 0DBh, 0DCh, 0DDh, 36h, 37h, 38h, 38h, 38h,
			0DEh, 0DFh, 0E0h, 0E1h, 0E2h, 0E3h, 0E4h, 0DAh, 0DBh,
			0DCh, 0DDh, 30h, 31h, 32h, 32h, 32h, 0BDh, 0BEh, 0BFh,
			0C0h, 0C1h, 0C2h, 0C3h, 0B9h, 0BAh, 0BBh, 0BCh, 30h,
			31h, 32h, 32h, 32h, 0BDh, 0BEh, 0BFh, 0C0h, 0C1h, 0C2h,
			0C3h, 0B9h, 0BAh, 0BBh, 0BCh, 33h, 34h, 35h, 35h, 35h,
			0C8h, 0C9h, 0CAh, 0CBh, 0CCh, 0CDh, 0CEh, 0C4h, 0C5h,
			0C6h, 0C7h, 33h, 34h, 35h, 35h, 35h, 0C8h, 0C9h, 0CAh,
			0CBh, 0CCh, 0CDh, 0CEh, 0C4h, 0C5h, 0C6h, 0C7h, 66h,
			0, 1, 17h, 17h, 17h, 17h, 17h, 17h, 2, 2, 2, 70h, 2,
			2, 2, 3, 3, 3, 2, 2, 2, 3, 3, 3),

	b4C15(*) BYTE public DATA(21h, 42h, 42h, 43h, 41h, 24h, 34h, 43h, 42h, 42h, 42h,
			43h, 45h, 45h, 52h, 53h, 50h, 50h, 0, 0, 60h, 10h,
			70h, 70h),

	b4C2D(*) BYTE public DATA(79h, 1, 61h, 61h, 61h, 61h, 89h, 88h, 89h, 1, 89h,
			89h, 49h, 89h, 89h, 89h, 69h, 89h, 8Fh, 6Fh, 80h, 60h,
			80h, 80h),

	b4C45(*) BYTE public DATA(63h, 0, 37h, 46h, 4, 5, 6, 3Bh, 3Ch, 3, 3Ah, 3, 4,
			4, 6, 3Ah, 3Bh, 3Bh, 5, 6, 3, 4, 5, 4, 5, 6, 5, 5,
			7, 7, 8, 8, 9, 9, 0Bh, 0Bh, 0Ch, 3Bh, 3Ch, 3Ch, 3Ch,
			3Dh, 3Eh, 3Eh, 3Fh, 3Fh, 40h, 40h, 3, 2, 2, 39h, 1,
			2, 4, 4, 38h, 39h, 1, 38h, 3, 4, 4, 5, 7, 8, 3Bh, 3Ch,
			3, 3, 3Ah, 1, 38h, 3, 5, 6, 7, 9, 0Ah, 3Ch, 3Dh, 3Eh,
			2, 39h, 1, 2, 3, 4, 38h, 39h, 2, 2, 4, 4, 5, 39h, 39h,
			1, 2, 4, 2, 4, 5, 6, 8, 9, 39h, 3Bh, 3Ch, 3Dh, 38h),

	b4CB4(*) BYTE public DATA(63h, 0, 1, 32h, 1, 2, 2, 1, 2, 1, 1, 1, 0Bh, 0Dh, 0Dh,
			1, 0Bh, 0Dh, 1, 0Bh, 1, 0Bh, 0Dh, 1, 0Bh, 0Dh, 11h,
			13h, 11h, 13h, 11h, 1Bh, 19h, 1Bh, 19h, 1Bh, 19h, 1,
			0Bh, 11h, 13h, 0Dh, 11h, 13h, 11h, 1Bh, 19h, 1Bh, 1,
			2, 1, 1, 1, 2, 1, 2, 1, 2, 2Fh, 2Fh, 2Fh, 2Dh, 2Fh,
			2Dh, 2Dh, 2Dh, 2Dh, 2Dh, 2Dh, 2Fh, 2Dh, 3, 3, 3, 29h,
			29h, 29h, 29h, 29h, 29h, 29h, 29h, 3, 3, 1, 1, 1, 1,
			1, 1, 1Dh, 1Fh, 1Dh, 1Fh, 1Dh, 1Dh, 1Fh, 3, 3, 3, 2Bh,
			2Bh, 2Bh, 2Bh, 2Bh, 2Bh, 2Bh, 2Bh, 2Bh, 2Bh, 3),

	b4D23(*) BYTE public DATA(1, 47h, 47h, 47h, 0, 0, 0, 0, 0, 0, 0, 0, 49h, 49h,
			49h, 0, 47h, 1, 47h, 47h, 0, 0, 0, 0, 0, 0, 0, 0, 31h,
			49h, 49h, 0, 47h, 47h, 1, 61h, 0, 0, 0, 0, 0, 0, 0,
			0, 49h, 31h, 63h, 0, 47h, 47h, 61h, 1, 0, 0, 0, 0,
			0, 0, 0, 0, 49h, 63h, 31h, 0, 9, 0Dh, 0Ch, 0Bh, 1,
			0, 30h, 30h, 30h, 0, 0, 0, 0Eh, 13h, 12h, 0, 32h, 32h,
			32h, 32h, 0, 1, 0, 0, 0, 0, 0, 0, 30h, 30h, 30h, 0,
			34h, 35h, 35h, 35h, 0, 0, 1, 52h, 52h, 0, 0, 0, 36h,
			37h, 37h, 0, 34h, 64h, 64h, 64h, 0, 0, 52h, 1, 61h,
			0, 0, 0, 65h, 65h, 65h, 0, 3Ah, 3Ah, 3Ah, 3Ah, 0, 0,
			52h, 61h, 1, 0, 0, 0, 3Ch, 3Ch, 3Ch, 0, 38h, 39h, 39h,
			39h, 0, 0, 2, 53h, 53h, 1, 52h, 52h, 4Ah, 4Ah, 4Bh,
			0, 38h, 6Ah, 6Ah, 6Ah, 0, 0, 53h, 2, 6Eh, 52h, 1, 61h,
			65h, 65h, 66h, 0, 3Bh, 3Bh, 3Bh, 3Bh, 0, 0, 53h, 6Eh,
			2, 52h, 61h, 1, 45h, 45h, 3Eh, 0, 48h, 2, 48h, 48h,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 52h, 52h, 0, 48h, 48h, 2,
			6Eh, 0, 0, 0, 0, 0, 0, 0, 0, 52h, 1, 61h, 0, 48h, 48h,
			6Eh, 2, 0, 0, 0, 0, 0, 0, 0, 0, 52h, 61h, 1, 0, 0Ah,
			11h, 10h, 0Fh, 0, 0, 0, 0, 0, 30h, 30h, 30h, 16h, 15h,
			14h, 1, 33h, 33h, 33h, 33h, 0, 0, 0, 0, 0, 0, 0, 0,
			30h, 30h, 30h, 0, 0, 0, 0, 0, 0, 0, 30h, 30h, 30h,
			30h, 30h, 30h, 0, 0, 0, 0, 4Bh, 4Ch, 4Ch, 4Ch, 0, 0,
			4Ah, 4Ah, 4Bh, 0, 0, 0, 4Dh, 4Dh, 4Dh, 0, 66h, 67h,
			67h, 67h, 0, 0, 65h, 65h, 66h, 0, 0, 0, 68h, 68h, 68h,
			0, 3Dh, 3Fh, 3Fh, 3Fh, 0, 0, 44h, 44h, 3Dh, 0, 0, 0,
			40h, 40h, 40h, 0, 50h, 51h, 51h, 51h, 0, 0, 4Fh, 4Fh,
			50h, 4Ah, 4Ah, 4Bh, 4Dh, 4Dh, 4Eh, 0, 6Ch, 6Dh, 6Dh,
			6Dh, 0, 0, 6Bh, 6Bh, 6Ch, 65h, 65h, 66h, 68h, 68h,
			69h, 0, 42h, 43h, 43h, 43h, 0, 0, 46h, 46h, 42h, 44h,
			44h, 3Dh, 40h, 40h, 41h, 0, 47h, 1, 47h, 47h, 0, 0,
			0, 0, 0, 0, 0, 0, 1, 52h, 52h, 0, 47h, 47h, 1, 61h,
			0, 0, 0, 0, 0, 0, 0, 0, 52h, 1, 61h, 0, 47h, 47h, 61h,
			1, 0, 0, 0, 0, 0, 0, 0, 0, 52h, 61h, 1, 0, 8, 8, 8,
			7, 0, 3, 0, 0, 0, 0, 0, 0, 6, 5, 4, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 19h, 18h, 17h, 19h, 18h, 17h, 0, 0, 0, 0, 2Dh, 2Fh,
			2Eh, 2Eh, 0, 0, 2Bh, 2Ah, 2Ch, 1Dh, 1Ch, 1Eh, 23h,
			22h, 24h, 0, 59h, 60h, 5Fh, 5Fh, 0, 0, 58h, 58h, 58h,
			54h, 54h, 54h, 5Dh, 5Ch, 5Eh, 0, 28h, 28h, 27h, 27h,
			0, 0, 29h, 26h, 25h, 19h, 18h, 17h, 1Dh, 1Ch, 1Eh,
			0, 59h, 58h, 58h, 58h, 0, 0, 0, 0, 0, 0, 0, 0, 54h,
			54h, 54h, 0, 55h, 54h, 54h, 54h, 0, 0, 0, 0, 0, 0,
			0, 0, 54h, 54h, 54h, 0, 1Fh, 21h, 20h, 20h, 0, 0, 1Dh,
			1Ch, 1Eh, 0, 0, 0, 23h, 22h, 22h, 0, 55h, 5Bh, 5Ah,
			5Ah, 0, 0, 54h, 54h, 54h, 0, 0, 0, 5Dh, 5Ch, 5Ch, 0,
			1Bh, 1Bh, 1Ah, 1Ah, 0, 0, 19h, 18h, 17h, 0, 0, 0, 1Dh,
			1Ch, 1Ch, 0, 55h, 54h, 54h, 54h, 0, 0, 0, 0, 0, 0,
			0, 0, 56h, 56h, 56h, 0, 54h, 55h, 55h, 55h, 0, 0, 0,
			0, 0, 0, 0, 0, 57h, 57h, 57h, 0),

	b4FA3(*) BYTE public DATA(17h, 16h, 16h, 16h, 0, 0, 0, 0, 0, 1, 1, 2, 2, 2, 2,
			2, 2, 2, 3, 3, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5,
			5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6,
			7, 8, 8, 9, 9, 9, 9, 9, 9, 0Ah, 0Ah, 0Bh, 0Ch, 0Ch,
			0Ch, 0Ch, 0Ch, 0Ch, 0Ch, 0Dh, 0Dh, 0Dh, 0Eh, 0Eh, 0Fh,
			10h, 10h, 10h, 10h, 10h, 10h, 10h, 10h, 11h, 11h, 12h,
			12h, 12h, 12h, 12h, 12h, 13h, 13h, 13h, 13h, 13h, 13h,
			13h, 14h, 14h, 14h, 14h, 14h, 14h, 14h, 14h, 14h, 14h,
			14h, 14h, 14h, 14h),

	b5012(*) BYTE public DATA(6, 8, 0Ah, 3Ah, 0Ah, 6, 7, 0Fh, 6Dh, 9, 12h, 11h, 10h,
			10h, 0Dh, 0Ch, 0Bh, 0Bh, 4, 4, 0Eh, 5, 0, 0),

	w502A(*) ADDRESS public DATA(0, 1, 2, 3, 4, 8, 9, 0Ah, 10h, 0FDh, 0FEh, 0FFh, 0FFFDh,
			0FFFEh, 0FFFFh),

	b5048(*) BYTE public DATA(0, 2Ah, 0, 2Ah, 0, 32h, 0, 32h, 0, 2Ah, 2Ah, 0, 2Ah,
			0, 5Ah, 2, 0Ah, 0, 2, 0, 9, 9, 11h, 11h, 19h, 71h,
			59h, 69h, 51h, 61h, 1, 1, 1, 0, 1, 1, 0, 0Ah, 0Ah,
			12h, 12h, 1Ah, 72h, 5Ah, 6Ah, 52h, 62h, 2, 2, 2, 0,
			0, 11h, 21h, 29h, 39h, 41h, 9, 9, 0, 9, 9, 0, 8, 0,
			59h, 59h, 71h, 71h, 0, 0, 0, 0, 1, 1, 1, 5Bh, 73h,
			0, 1, 1, 1, 59h, 71h, 0, 2, 0Ah, 12h, 2, 0Ah, 12h,
			0, 1, 0, 1, 0, 1, 0, 1, 1, 0),

	b50AD(*) BYTE public DATA(0FFh, 22h, 0FFh, 22h, 0FFh, 22h, 0FFh, 22h, 0FFh, 22h,
			62h, 0FFh, 22h, 0FFh, 4, 4, 4, 0FFh, 50h, 0FFh, 64h,
			85h, 64h, 85h, 64h, 64h, 0A5h, 64h, 0A5h, 64h, 64h,
			5, 4, 0FFh, 64h, 5, 0FFh, 64h, 85h, 64h, 85h, 64h,
			64h, 0A5h, 64h, 0A5h, 64h, 64h, 5, 4, 0FFh, 4, 4, 4,
			4, 4, 4, 64h, 4, 0FFh, 64h, 4, 0FFh, 4, 0FFh, 25h,
			24h, 64h, 4, 4, 0FFh, 4, 0FFh, 64h, 5, 4, 24h, 4, 0FFh,
			64h, 5, 4, 25h, 64h, 0FFh, 14h, 14h, 14h, 4, 4, 4,
			0FFh, 4, 0FFh, 4, 0FFh, 4, 0FFh, 14h, 4, 0FFh),

	b5112(*) BYTE public DATA(5Ah, 61h, 69h, 92h, 92h, 92h, 91h, 91h, 91h, 5Dh, 0D3h,
			0D3h, 0DCh, 9Bh, 9Bh, 98h, 98h, 1Ah),

	b5124(*) BYTE public DATA(2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0Eh, 1, 1, 1, 1,
			1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 2, 1, 1, 1,
			1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 6, 1, 0, 0, 0,
			0, 3, 0, 9, 9, 8, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 2, 9, 0Bh, 0Bh, 81h,
			99h, 91h, 91h, 91h, 81h, 89h, 89h, 89h, 8Ah, 80h, 80h,
			80h, 80h, 80h, 80h, 90h, 0A1h, 0A3h, 0A0h, 0A1h, 0A2h,
			0B0h, 0A0h, 0A0h, 0A0h, 0A0h, 0A0h, 0A3h, 0A3h, 0,
			0, 0, 0, 0, 0, 0, 0, 41h, 41h, 41h, 40h, 0, 0, 0, 0,
			0, 0C0h, 0C0h, 0C0h, 0C0h, 0C0h, 0D8h, 41h, 41h, 41h,
			0C0h),

	b51E3(*) BYTE public DATA(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 12h, 14h, 22h, 33h, 47h, 47h, 41h, 49h, 4Fh, 0,
			5Ch, 5Eh, 60h),

	b5202(*) BYTE public DATA(0, 0, 0, 0, 0, 0, 1, 3, 5, 7, 9, 0Ch, 0Eh, 0, 0, 0,
			0, 0, 0, 14h, 25h, 33h, 3Ch, 3Fh, 41h, 49h, 4Fh, 55h,
			0, 0, 62h),

	b5221(*) BYTE public DATA(0, 4Dh, 0, 55h, 0, 5Dh, 0, 66h, 0, 6Fh, 6Fh, 0, 77h,
			0, 0B6h, 8Dh, 0B6h, 0, 41h, 0, 2Dh, 2Dh, 2Eh, 2Eh,
			2Fh, 30h, 30h, 31h, 31h, 32h, 41h, 41h, 12h, 0, 1Fh,
			1Fh, 0, 30h, 30h, 31h, 31h, 32h, 2Dh, 2Dh, 2Eh, 2Eh,
			2Fh, 41h, 41h, 41h, 0, 0ADh, 42h, 43h, 44h, 2Ch, 46h,
			41h, 12h, 0, 41h, 12h, 0, 0ADh, 0, 41h, 12h, 41h, 12h,
			0ADh, 0, 0ADh, 0, 41h, 41h, 12h, 0ADh, 0ADh, 0, 41h,
			41h, 12h, 20h, 20h, 0, 4Ah, 4Bh, 4Ch, 7Fh, 80h, 81h,
			0, 0Dh, 0, 0Eh, 0, 0Fh, 0, 10h, 11h, 0),

	b5286(*) BYTE public DATA(0Ch, 9, 0, 1, 8, 0, 0),

	b528D(*) BYTE public DATA(0, 0, 0, 0, 0, 0, 2, 2, 2, 3, 3, 3, 1, 1, 1, 1, 1,
			8, 4, 4, 4, 5, 5, 5, 6, 6, 6, 0Ah, 9, 8, 3, 3, 1, 1,
			6, 2, 2, 0, 0, 0Bh),

	b52B5(*) BYTE public DATA(0, 1, 2, 3, 4, 8, 1, 2, 3, 1, 2, 3, 1, 2, 3, 4, 8,
			4, 1, 2, 3, 1, 2, 3, 1, 2, 3, 8, 8, 0Ah, 0Ah, 9, 0Ah,
			9, 9, 0Ah, 9, 0Ah, 9, 9),

	b52DD(*) BYTE public DATA(0, 1, 2, 3, 4, 0, 0, 0, 5, 26h, 25h, 0, 0Ch, 0Dh, 0Eh,
			0Fh, 0, 0, 0, 10h, 21h, 20h, 0, 6, 7, 8, 0, 0, 0, 0,
			0, 24h, 23h, 0, 9, 0Ah, 0Bh, 0, 0, 0, 0, 0, 1Fh, 1Eh,
			0, 12h, 13h, 14h, 0, 0, 0, 0, 0, 0, 0, 0, 15h, 16h,
			17h, 0, 0, 0, 0, 0, 0, 0, 0, 18h, 19h, 1Ah, 0, 0, 0,
			0, 0, 22h, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 11h, 0, 0, 0, 0, 0, 1Dh, 0, 0, 0, 0, 0, 0, 0,
			0, 1Ch, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1Bh, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 27h, 0);



WrFragData: procedure public;
	if not (PRINT or OBJECT) then
	do;
		if buf$C1E7(0) = 9Ah or buf$C1E7(0) = 9Bh or buf$C1E7(0) = 0A3h then
			programErrCnt = programErrCnt + 1;  
		return;
	end;
	call fwrite(.tx1File, .buf$C1E7, bC1E6);
end;


PutTx1Byte: procedure(arg1b) public;
	declare arg1b byte;
	buf$C1E7(bC1E6) = arg1b;
	bC1E6 = bC1E6 + 1;
end;


PutTx1Word: procedure(arg1w) public;
	declare arg1w address;
	call PutTx1Byte(low(arg1w));
	call PutTx1Byte(high(arg1w));
end;

EncodeFragData: procedure(arg1b) public;
	declare arg1b byte;

	Sub$5410: procedure;
		declare (bC214, bC215) byte;

		Sub$545D: procedure;
			declare j byte;
			j = wC1DC(bC214);
			if wC1DC(0) <= 12 then
			do;
				if bC1E6 = bC215 then
					call PutTx1Byte(j);
				else	
					buf$C1E7(bC215)  = ROL(buf$C1E7(bC215), 4) or j;
			end;
			bC214 = bC214 + 1;  
			if j > 7 then
			do;
				if j = 8 or j = 13 or j = 10 then
					call PutTx1Byte(wC1DC(bC214));
				else
					call PutTx1Word(wC1DC(bC214));

				bC214 = bC214 + 1;  
				if j >= 10 and j < 12 then
				do;
					call PutTx1Word(wC1DC(bC214));
					bC214 = bC214 + 1;  
				end;
				else if j = 12 then
				do;
					call PutTx1Word(wC1DC(bC214));
					call PutTx1Word(wC1DC(bC214+1));
					bC214 = bC214 + 2;
				end;
			end;
		end Sub$545D;

/* Sub$5410 */	bC214 = 0;
		bC215 = bC1E6;
		if (shr(b4029(arg1b), 4) and 7) <> 0 then
		do;
			call Sub$545D;
			if wC1DC(bC214) <> 0 or wC1DC(0) <= 12 then
				call Sub$545D;
		end;
	end Sub$5410;

/* EncodeFragData */
	bC1E6 = 0;
	call PutTx1Byte(arg1b);
	if rol(b4029(arg1b), 1) then
		call PutTx1Byte(curOp);
	call Sub$5410;
	call FILLX(10, .wC1DC(0), 0);
	call WrFragData;
end;



EmitTopItem: procedure public;
	bC1E6 = 0;
	if not PRINT then
		if tx2opc(tx2qp) = T2$LINEINFO or tx2opc(tx2qp) = T2$INCLUDE then
			return;
	call PutTx1Byte(tx2opc(tx2qp));
	if rol(b4029(tx2opc(tx2qp)), 1) then
	do;
		call PutTx1Byte(tx2op2(tx2qp));
		call PutTx1Word(tx2op1(tx2qp));
	end;
	else 
		do case b5124(tx2opc(tx2qp)) and 3;
			;
			call PutTx1Word(tx2op1(tx2qp));
			do;
				call PutTx1Word(tx2op1(tx2qp));
				call PutTx1Word(tx2op2(tx2qp));
			end;
			do;
				call PutTx1Word(tx2op1(tx2qp));
				call PutTx1Word(tx2op2(tx2qp));
				call PutTx1Word(tx2op3(tx2qp));
			end;
		end;
	call WrFragData;
end;

Tx2SyntaxError: procedure(arg1b) public;
	declare arg1b byte;
	tx2opc(tx2qp) = T2$SyntaxError;
	tx2op1(tx2qp) = arg1b;
end;

Sub$5679: procedure(arg1b) byte public;
	declare arg1b byte;
	if arg1b = 0 then
		return shr(b44F7(wC1D6), 4);
	else
		return b44F7(wC1D6) and 0fh;
end;

Sub$56A0: procedure(arg1b, arg2b) public;
	declare arg1b byte, arg2b byte;
	tx2opc(arg2b) = tx2opc(arg1b);
	tx2Aux1b(arg2b) = tx2Aux1b(arg1b);
	tx2Aux2b(arg2b) = tx2Aux2b(arg1b);
	tx2op1(arg2b) = tx2op1(arg1b);
	tx2op2(arg2b) = tx2op2(arg1b);
	tx2op3(arg2b) = tx2op3(arg1b);
	tx2Auxw(arg2b) = tx2Auxw(arg1b);
end;


Sub$5748: procedure(arg1b) byte public;
	declare arg1b byte;
	if arg1b = 8 then
		return 2;
	else
		return arg1b + 2;
end;

Sub$575E: procedure(arg1w) address public;
	declare arg1w address;
	declare i byte;

	curInfo$p = arg1w;
	i = GetType;
	if i = BYTE$T then
		return 1;
	if i = ADDRESS$T then
		return 2;
	if i = STRUCT$T then
		return GetParentOffset;
	/*  fall though appears suspect */
end;

Sub$5795: procedure(arg1w) public;
	declare arg1w address;
	declare (p, q) address;
	p = arg1w + shl(wC1C3, 1);
	q = shr(p, 1) + (p and 1) + 2;
	if curOp = T2$RETURNWORD then
		q = q - 2;
	if q > 7 then
	do;
		if bC0B5(0) = 3 then
			call EncodeFragData(CF$XCHG);
		wC1DC(0) = 9;
		wC1DC(1) = p;
		call EncodeFragData(CF$6);
		call EncodeFragData(CF$SPHL);
		if bC0B5(0) = 3 then
		do;
			call EncodeFragData(CF$XCHG);
			pc = pc + 7;
		end;
		else 
			pc = pc + 5;
	end;
	else
	do;
		if p then
		do;
			call EncodeFragData(CF$INXSP);
			pc = pc + 1;  
		end;
		do while p > 1;
			if bC0B5(0) = 3 then
				wC1DC(0) = 2;	/*  pop d */
			else
				wC1DC(0) = 3;	/*  pop h */
			wC1DC(1) = 8;
			call EncodeFragData(CF$POP);
			pc = pc + 1;  
			p = p - 2;
		end;
	end;
	if arg1w > 0ff00h then
		wC1C3 = shr(-arg1w, 1);
	else
		wC1C3 = 0;
end;

EnterBlk: procedure byte public;
	if blkSP < 14h then
	do;
		blkSP = blkSP + 1;  
		return TRUE;
	end;
	else
	do;
		if blkOverCnt = 0 then
		do;
		  call Tx2SyntaxError(ERR204);	/*  LIMIT EXCEEDED: NUMBER OF ACTIVE */
						/*  PROCEDURES AND DO CASE GROUPS */
		  call EmitTopItem;
		end;
		blkOverCnt = blkOverCnt + 1;  
		return FALSE;
	end;
end;



ExitBlk: procedure byte public;
	if blkOverCnt > 0 then
	do; 
		blkOverCnt = blkOverCnt - 1;  
		return FALSE;
	end;
	else if blkSP > 0 then
	do; 
		blkSP = blkSP - 1;  
		return TRUE;
	end;
	else
	do;
		call Tx2SyntaxError(ERR205);	/*  ILLEGAL NESTING OF BLOCKS, ENDS NOT BALANCED */
		call EmitTopItem;
		return FALSE;
	end;
end;


Sub$58F5: procedure(arg1b) public;
	declare arg1b byte;
	fatalErrorCode = arg1b;
	buf$C1E7(0) = 9ah;
	buf$C1E7(1) = fatalErrorCode;
	buf$C1E7(2) = 0;
	bC1E6 = 3;
	call WrFragData;

	do while blkSP > 0;
		if ExitBlk then
		do;
			if procChainId > blkSP then
			do;
				curInfo$p = blkCurInfo(procChainId);
				call SetDimension(pc);
				call SetBaseVal(wC1C5);
				procChainId = procChainNext(procChainId);
				pc = wB488(procChainId);
				wC1C5 = wB4D8(procChainId);
			end;
		end;
	end;
	goto finalise;
end;


Sub$597E: procedure public;
	declare (i, j, k, m, n) byte;
	bC0B2 = 0;
	bC0B1 = 0;
	do i = 0 to 3;
		boC069(i) = FALSE;
		boC072(i) = FALSE;
		boC07B(i) = FALSE;
		k = bC04E(i);
		n = b5124(tx2opc(k)) and 0c0h;
		if k <> 0 then
		do;
			boC060(i) = TRUE;
			if bC0B5(0) = i or bC0B5(1) = i then
			do;
				boC069(i) = TRUE;
				if i > 0 then
					bC0B2 = bC0B2 + 1;  
			end;
			if n = 0 or n = 80h then
			do;
				if tx2op3(k) = 0 then
				do;
					if tx2Aux1b(k) = bC045(i)
					  or (tx2Aux1b(k) = 0 and bC045(i) = 6) then
					do;
						if tx2Auxw(k) > 1 or boC069(i)
						  or (bC0B7(0) <> k and k <> bC0B7(1)) then
							boC072(i) = TRUE;
					end;
				end;
			end;
		end;
		else 
			boC060(i) = boC057(i);
	end;

	do i = 0 to 3;
		if boC072(i) then
		do;
			boC07B(i) = TRUE;
			m = boC069(i);
			j = 3;
			do while j > i;
				if boC072(j) then
				do;
					if bC04E(j) = bC04E(i) then
					do;
						boC072(j) = FALSE;
						if i <> 0 then
						do;
							boC072(i) = FALSE;
							m = m or  boC069(j);
						end;
					end;
				end;
				j = j - 1;
			end;
			if i <> 0 and not m then
				bC0B1 = bC0B1 + 1;  
		end;
	end;
end;


Sub$5B96: procedure(arg1b, arg2b) public;
	declare arg1b byte, arg2b byte;
	bC04E(arg2b) = bC04E(arg1b);
	bC045(arg2b) = bC045(arg1b);
	wC084(arg2b) = wC084(arg1b);
	bC0A8(arg2b) = bC0A8(arg1b);
	wC096(arg2b) = wC096(arg1b);
	boC057(arg2b) = boC057(arg1b);
end;


Sub$5C1D: procedure(arg1b) public;
	declare arg1b byte;
	declare i byte;
	call Sub$597E;
	i, bC140(wC1C3) = bC04E(arg1b);
	if boC072(arg1b) then
		tx2op3(i) = wC1C3;

	if arg1b <> 0 then
		bC0C3(wC1C3) = shl(bC045(arg1b), 4) or (bC0A8(arg1b) and 0fh);
	else
		bC0C3(wC1C3) = 0B0h;
end;

Sub$5C97: procedure(arg1b) public;
	declare arg1b byte;
	declare i byte;
	i, bC04E(arg1b) = bC140(wC1C3);
	if wC1C3 = tx2op3(i) then
		tx2op3(i) = 0;

	boC057(arg1b) = 0;
	bC045(arg1b) = shr(bC0C3(wC1C3), 4);
	bC0A8(arg1b) = bC0C3(wC1C3) and 0fh;
	if bC0A8(arg1b) > 7 then
		bC0A8(arg1b) = bC0A8(arg1b) or  0f0h;
end;


Sub$5D27: procedure(arg1b) public;
	declare arg1b byte;
	if wC1C5 < shl(wC1C3 := wC1C3 + 1, 1) then
		wC1C5 = shl(wC1C3, 1);
	call Sub$5C1D(arg1b);
	wC1DC(0) = arg1b;
	wC1DC(1) = 0Ah;
	wC1DC(2)= wC1C3;
	call EncodeFragData(CF$PUSH);
	pc = pc + 1;  
end;


Sub$5D6B: procedure(arg1b) public;
	declare arg1b byte;
	declare bC233 byte;

	Sub$5E16: procedure	/*  nested */;
		do bC233 = 0 to 3;
			if boC072(bC233) then
				if not boC069(bC233) then
					call Sub$5D27(bC233);
		end;
		if bC0B5(0) = arg1b then
			bC0B5(0) = 9;
		else
			bC0B5(1) = 9;
	end Sub$5E16;

/* Sub$5D6B */
	if boC072(arg1b) then
	do;
		if boC069(arg1b) then
			call Sub$5E16;
		call Sub$5D27(arg1b);
	end;
	else if boC069(arg1b) then
	do;
		do bC233 = 0 to 3;
			if bC04E(bC233) = bC04E(arg1b) then
			do;
				if bC233 <> arg1b then
				do;
					if bC045(bC233) = bC045(arg1b) then
					do;
						if bC0B5(0)  = arg1b then
							bC0B5(0) = bC233;
						else
							bC0B5(1) = bC233;
						return;
					end;
				end;
			end;
		end;
		call Sub$5E16;
		call Sub$5D27(arg1b);
	end;
end;




Sub$5E66: procedure(arg1b) public;
	declare arg1b byte;
	declare (i, j, k) byte;
	j = bC0B7(0);
	k = bC0B7(1);
	bC0B7(0) = 0;
	bC0B7(1) = 0;
	arg1b = ROR(arg1b, 3);
	call Sub$597E;
	do i = 0 to 3;
		if arg1b then
		do;
			if boC072(i) then
				call Sub$5D27(i);
			boC057(i) = 0;
			bC04E(i) = 0;
			call Sub$597E;
		end;
		arg1b = ROL(arg1b, 1);
	end;
	bC0B7(0) = j;
	bC0B7(1) = k;
end;


Sub$5EE8: procedure public;
	declare i byte;
	call Sub$5795(wC1C7);
	if (curInfo$p := blkCurInfo(procChainId)) <> 0 then
	do;
		if TestInfoFlag(F$INTERRUPT) then
		do;
			do i = 0 to 3;
				wC1DC(0) = i;	/*  pop psw, pop b, pop d, pop h */
				wC1DC(1) = 8;
				call EncodeFragData(CF$POP);
			end;
			call EncodeFragData(CF$EI);
			pc = pc + 5;
		end;
	end;
end;


Sub$5F4B: procedure(arg1w, arg2w, arg3b, arg4b) public;
	declare arg1w address, arg2w address, arg3b byte, arg4b byte;
	tx2op2(tx2qp) = arg1w;
	tx2op1(tx2qp) = arg2w;
	tx2Aux1b(tx2qp) = arg3b;
	tx2Aux2b(tx2qp) = arg4b;
	if arg4b = 8 then
		tx2opc(tx2qp) = T2$NUMBER;
	else
		tx2opc(tx2qp) = T2$VARIABLE;
end;

Sub$5FBF: procedure(arg1b, arg2w$p, arg3w$p) public;
	declare arg1b byte, arg2w$p address, arg3w$p address;
	declare arg2w based arg2w$p address;
	declare arg3w based arg3w$p address;

	if tx2opc(arg1b) = T2$VARIABLE or tx2opc(arg1b) = T2$NUMBER then
	do;
		arg2w = tx2op2(arg1b);
		if (curInfo$p := tx2op1(arg1b)) = 0 then
			arg3w = 0;
		else if TestInfoFlag(F$MEMBER) then
			arg3w = 0;
		else if TestInfoFlag(F$BASED) then
			arg3w = 0;
		else if TestInfoFlag(F$ABSOLUTE) then
			arg3w = 0;
		else if TestInfoFlag(F$AUTOMATIC) then
			arg3w = 100h;
		else if TestInfoFlag(F$EXTERNAL) then
			arg3w = 400h or GetExternId;
		else if TestInfoFlag(F$MEMORY) then
			arg3w = 800h;
		else if GetType = PROC$T then
			arg3w = 1000h or GetProcId;
		else if TestInfoFlag(F$DATA) then
			arg3w = 200h;
		else
			arg3w = 2000h;
	end;
	else if arg1b = 0 then
	do; 
		arg2w = 0;
		arg3w = 0;
	end;
	else
	do;
		arg2w = 0;
		arg3w = 4000h;
	end;
end;


Sub$611A: procedure public;
	declare (i, j, k) byte;
	do i = 0 to 1;
		j = bC0B7(i);
		if j <> 0 then
		do;
			tx2Auxw(j) = tx2Auxw(j) - 1;
			if tx2Auxw(j) = 0 then
			do;
				do k = 0 to 3;
					if bC04E(k) = j then
						bC04E(k) = 0;
				end;
				bC140(tx2op3(j)) = 0;
			end;
		end;
	end;
end;



Sub$61A9: procedure(arg1b) public;
	declare arg1b byte;
	bC0C1(arg1b) = b52DD(11 * bC0B3(arg1b) + bC0B5(arg1b));
end;

Sub$61E0: procedure(arg1b) public;
	declare arg1b byte;
	if (b5124(tx2opc(arg1b)) and 0c0h) = 0 then
	do;
		wC1DC(bC1DB) = 0ah;
		wC1DC(bC1DB + 1) = tx2op3(arg1b);
		wC1DC(bC1DB + 2) = shl(wC1C3 - tx2op3(arg1b), 1);
		bC1DB = bC1DB + 3;
	end;
	else if tx2op1(arg1b) <> 0 then
	do;
		curInfo$p = tx2op1(arg1b);
		wC1DC(bC1DB + 2) = curInfo$p - botInfo;
		wC1DC(bC1DB + 1) = tx2op2(arg1b) - GetLinkVal;
		if TestInfoFlag(F$AUTOMATIC) then
		do;
			wC1DC(bC1DB) = 0ch;
			wC1DC(bC1DB + 3) = tx2op2(arg1b) + shl(wC1C3, 1);
			bC1DB = bC1DB + 4;
		end;
		else
		do;
			wC1DC(bC1DB) = 0bh;
			bC1DB = bC1DB + 3;
		end;
	end;
	else
	do;
		if tx2op2(arg1b) < 100h then
			wC1DC(bC1DB) = 8;
		else
			wC1DC(bC1DB) = 9;
		wC1DC(bC1DB + 1) = tx2op2(arg1b);
		bC1DB = bC1DB + 2;
	end;
end;


Sub$636A: procedure(arg1b) public;
	declare arg1b byte;
	if bC0B5(arg1b) <= 3 then
	do;
		wC1DC(bC1DB) = bC0B5(arg1b);
		bC1DB = bC1DB + 1;  
	end;
	else
		call Sub$61E0(bC0B7(arg1b));
end;


Sub$63AC: procedure(arg1b) public;
	declare arg1b byte;
	if arg1b > 3 then
		return;
	if bC045(arg1b) <= 6 then
	do;
		do while bC0A8(arg1b) <> 0;
			if bC0A8(wC1DC(0) := arg1b) > 7fh then
			do;
				bC0A8(arg1b) = bC0A8(arg1b) + 1;  
				call EncodeFragData(CF$INX);
			end;
			else
			do;
				bC0A8(arg1b) = bC0A8(arg1b) - 1;  
				call EncodeFragData(CF$DCX);
			end;
			pc = pc + 1;  
		end;
	end;
end;


Sub$6416: procedure(arg1b) public;
	declare arg1b byte;
	wC1DC(0) = arg1b;
	wC1DC(1) = 0ah;
	wC1DC(2) = wC1C3;
	call EncodeFragData(CF$POP);
	pc = pc + 1;  
	call Sub$5C97(arg1b);
	wC1C3 = wC1C3 - 1;  
end;

GetTx2Item: procedure public;
	call fread(.tx2File, .tx2opc(tx2qp), 1);
	do case 3 and b5124(tx2opc(tx2qp));
		if tx2opc(tx2qp) = T2$EOF then
			eofSeen = TRUE;
		call fread(.tx2File, .tx2op1(tx2qp), 2);
		do;
			call fread(.tx2File, .tx2op1(tx2qp), 2);
			call fread(.tx2File, .tx2op2(tx2qp), 2);
		end;
		do;
			call fread(.tx2File, .tx2op1(tx2qp), 2);
			call fread(.tx2File, .tx2op2(tx2qp), 2);
			call fread(.tx2File, .tx2op3(tx2qp), 2);
		end;
	end;
end;


Sub$652B: procedure public;
	if curOp = T2$MODULE then
	do;
		if tx2opc(tx2qp - 1) = T2$LABELDEF then
		do;
			curInfo$p = tx2op1(tx2qp - 1) + botInfo;
			if not (TestInfoFlag(F$MODGOTO) or TestInfoFlag(F$PUBLIC)) then
				tx2qp = tx2qp - 1;  
		end;
	end;
	else if curOp = T2$LINEINFO then
	do;
		if tx2op2(tx2qp) = 0 then
		do;
			if tx2opc(tx2qp - 1) = T2$LINEINFO then
			do;
				if tx2op2(tx2qp - 1) = 0 then
				do;
					tx2op3(tx2qp - 1) = tx2op1(tx2qp);
					tx2qp = tx2qp - 1;  
				end;
			end;
		end;
	end;
end;


FillTx2Q: procedure public;
	declare (i, j, k) byte;
	tx2qp = 4;
	if tx2qEnd > bC1BF then
	do;
		k = tx2qEnd - bC1BF;
		call movmem(k, .tx2opc(bC1BF), .tx2opc(tx2qp));
		call movmem(k, .tx2Aux1b(bC1BF), .tx2Aux1b(tx2qp));
		call movmem(k, .tx2Aux2b(bC1BF), .tx2Aux2b(tx2qp));
		call movmem(k * 2, .tx2op1(bC1BF), .tx2op1(tx2qp));
		call movmem(k * 2, .tx2op2(bC1BF), .tx2op2(tx2qp));
		call movmem(k * 2, .tx2op3(bC1BF), .tx2op3(tx2qp));
		call movmem(k * 2, .tx2Auxw(bC1BF), .tx2Auxw(tx2qp));
		tx2qp = k + 4;
		bC1BF = bC1BF + k;
	end;
	i = TRUE;
	j = FALSE;
	do while tx2qp < 255 and not eofSeen;
		call GetTx2Item;
		curOp = tx2opc(tx2qp);
		call Sub$652B;
		if tx2qp = 4 then
		do;
			if curOp = T2$STMTCNT or curOp = T2$LOCALLABEL
			  or curOp = T2$EOF then
				tx2qp = tx2qp + 1;  
			else if (b5124(curOp) and 20h) <> 0 then
				call EmitTopItem;
			else if i then
			do;
				i = FALSE;
				call Tx2SyntaxError(ERR200);	/*  LIMIT EXCEEDED */
							/*  STATEMENT SIZE */
				call EmitTopItem;
			end;
		end;
		else
			tx2qp = tx2qp + 1;  

		if (b5124(curOp) and 8) <> 0 then
			j = TRUE;
		if j then
			if curOp  = T2$STMTCNT or curOp = T2$EOF
			  or curOp = T2$LOCALLABEL then
				goto break;
	end;
break:
	tx2qEnd = tx2qp;
end;



Sub$67A9: procedure public;
	declare i byte;

	SkipBB: procedure(arg1b, arg2b);
		declare arg1b byte, arg2b byte;
		bC1BF = arg1b + arg2b;
		do while tx2opc(bC1BF) <> T2$STMTCNT and tx2opc(bC1BF) <> T2$EOF
		  and tx2opc(bC1BF) <> T2$LOCALLABEL;
			bC1BF = bC1BF + arg2b;
		end;
	end;

	call SkipBB(tx2qEnd, 0ffh);
	i = 0;
	if bC1BF = 4 and not eofSeen then
		bC1BF = tx2qEnd;
	else
		do tx2qp = 4 to bC1BF - 1;
			bC1D2 = b5124(tx2opc(tx2qp));
			if (bC1D2 and 10h) <> 0 then
			do;
				if i + 4 < tx2qp then
				do;
					if tx2opc(tx2qp) = T2$LOCALLABEL then
						bC1BF = tx2qp;
					else
						call SkipBB(tx2qp, 0ffh);
					return;
				end;
				i = i + 1;  
			end;
			if (bC1D2 and 8) <> 0 then
			do;
				call SkipBB(tx2qp, 1);
				return;
			end;
			if (bC1D2 and 20h) <> 0 then
				i = i + 1;  
		end;
end;


end;
src/plm2b.plm
plm2b: DO;
$include(:f2:plm2b.ipx)

Sub$689E: procedure public;
	Sub$68E8: procedure;
		declare bC252 byte;
		declare i byte;

		Sub$69EB: procedure(arg1b, arg2w$p);
		    declare arg1b byte, arg2w$p address;
		    declare arg2w based arg2w$p address;
		    declare p address;
		    if arg2w <> 0 then
		    do;
			if arg1b > bC252 then
			    arg2w = 0;
			else
			do;
			    p = arg2w;
			    arg2w = tx2qp;

			    do while p <> 0;
				p = p - 1;  
				arg2w = arg2w - 1;
				if tx2opc(arg2w) = T2$LINEINFO then
				    if tx2op2(arg2w) = 0 then
					if tx2op3(arg2w) <> 0 then
					    p = p -(tx2op3(arg2w) - tx2op1(arg2w));
			    end;
			end;
		    end;
		end sub69EB;

	/* Sub$68E8 */
		bC252 = bC1D2 and 3;
		if (bC1D2 and 4) <> 0 then
		do;
			tx2op2(1) = tx2op1(tx2qp);
			tx2op1(tx2qp) = 1;
		end;
		else
			call Sub$69EB(1, .tx2op1(tx2qp));

		call Sub$69EB(2, .tx2op2(tx2qp));
		if bC252 = 3 then
		do;
			if curOp = T2$CALL then
				tx2op3(tx2qp) = tx2op3(tx2qp) + botInfo;
			else if  curOp = T2$BYTEINDEX or curOp = T2$WORDINDEX then
			do;
				i = tx2op1(tx2qp);
				tx2op2(i) = tx2op2(i) + tx2op3(tx2qp) *Sub$575E(tx2op1(i));
			end;
			else
				call Sub$69EB(3, .tx2op3(tx2qp));
		end;
		tx2Aux1b(tx2qp) = 0ch;
		tx2Aux2b(tx2qp) = 9;
	end;

	Sub$6AA4: procedure;
		if curOp = T2$VARIABLE then
		do;
			curInfo$p, tx2op1(tx2qp) = tx2op1(tx2qp) + botInfo;
			if TestInfoFlag(F$MEMBER) then
			do;
				curInfo$p = GetParentOffset;
				tx2Aux2b(tx2qp) = 4;
			end;
			else if TestInfoFlag(F$AUTOMATIC) then
				tx2Aux2b(tx2qp) = 0ah;
			else
				tx2Aux2b(tx2qp) = 4;
			curInfo$p = tx2op1(tx2qp);
			tx2op2(tx2qp) = GetLinkVal;
			tx2Aux1b(tx2qp) = b5286(GetType);
		end;
		else if curOp <= T2$BIGNUMBER then
		do;
			tx2op2(tx2qp) = tx2op1(tx2qp);
			tx2Aux2b(tx2qp) = 8;
			tx2op1(tx2qp) = 0;
			if curOp = T2$BIGNUMBER then
			do;
				tx2Aux1b(tx2qp) = 1;
				tx2opc(tx2qp) = T2$NUMBER;
			end;
			else
				tx2Aux1b(tx2qp) = 0;
		end;
		else
		do;
			tx2Aux1b(tx2qp) = 0;
			tx2op2(tx2qp) = 0;
		end;
	end;

/* sub$679E */
	do tx2qp = 4 to bC1Bf - 1;
		curOp = tx2opc(tx2qp);
		bC1D2 = b5124(curOp);
		if (bC1D2 and 0c0h) = 0 then
			call Sub$68E8;
		else if (bC1D2 and 0c0h) = 40h then
			call Sub$6AA4;
	end;
end;

END;
src/plm2c.plm
plm2c: DO;
$include(:f2:plm2c.ipx)


Sub$6BD6: procedure public;
	declare (bC259, bC25A) byte;



	Sub$6C54: procedure(arg1b);
	    declare arg1b byte;
	    if arg1b <> 0 then
		tx2Auxw(arg1b) = tx2Auxw(arg1b) + 1;  
	end;



	Sub$6C73: procedure(arg1b);
	    declare arg1b byte;
	    if OPTIMIZE  then
		do while tx2qp - 1 > arg1b;
		    arg1b = arg1b + 1;
		    if tx2opc(arg1b) = curOp then
		    do;
			if tx2op1(arg1b) = tx2op1(tx2qp) then
			do;
			    if tx2op2(arg1b) = tx2op2(tx2qp) then
			    do;
				if tx2Aux1b(arg1b) = tx2Aux1b(tx2qp) then
				do;
				    if tx2op3(arg1b) <> 0ff00h then
				    do;
				    	tx2opc(tx2qp) = T2$OPTBACKREF;
				    	tx2op1(tx2qp) = arg1b;
				    	return;
				    end;
				end;
			    end;
			end;
		    end;
		end; 
	    if (bC1D2 and 0c0h) = 0 then
	    do;
		call Sub$6C54(tx2op1(tx2qp));
		call Sub$6C54(tx2op2(tx2qp));
	    end;
	    tx2op3(tx2qp) = tx2qp;
	end;


	Sub$6D52: procedure;
	    declare boC25D byte;

	 	Sub$6EAB: procedure(arg1w$p);
		    declare arg1w$p address;
		    declare arg1w based arg1w$p address;
		    if arg1w <> 0 then
		    do;
			if tx2opc(arg1w) = T2$OPTBACKREF then 
			    arg1w = tx2op1(arg1w);
		    end;
		end;

	


		Sub$6EE1: procedure(arg1b);
		    declare arg1b byte;

			Sub$6F20: procedure(arg1b);
			    declare arg1b byte;
			    declare i byte;
			    if (i := tx2opc(arg1b)) = T2$BASED then
				boC25D = 0ffh;
			    else if i = T2$BYTEINDEX or i = T2$WORDINDEX then
			    do;
				if tx2opc(tx2op2(arg1b)) <> T2$NUMBER then
				    boC25D = 0ffh;
				else
				do;
				    curInfo$p = tx2op1(tx2op1(arg1b));
				    if tx2op2(tx2op2(arg1b)) >= GetDimension or TestInfoFlag(F$AT) then
					boC25D = 0ffh;
				end;
			    end;
			    else if i = T2$VARIABLE then
			    do;
				curInfo$p = tx2op1(arg1b);
				if TestInfoFlag(F$AT) then
				    boC25D = 0ffh;
			    end;
			end Sub$6F20;

	/* Sub$6EE1 */
		    boC25D = 0;
		    if tx2opc(arg1b) = T2$MEMBER then
		    do;
			call Sub$6F20(tx2op1(arg1b));
			call Sub$6F20(tx2op2(arg1b));
		    end;
		    else
			call Sub$6F20(arg1b);
		end;





		Sub$6FE2: procedure byte;
		    declare bC263 byte;

		    Sub$7018: procedure(arg1b);
			declare arg1b byte;
			if tx2opc(arg1b) <> T2$CALL then
			    arg1b = tx2op3(arg1b);
			if arg1b <> 0 then
			    if arg1b > bC263 then
				bC263 = arg1b;
		    end;

		    if boC25D then
			bC263 = bC259;
		    else
			bC263 = bC25A;

		    call Sub$7018(tx2op1(tx2qp));
		    call Sub$7018(tx2op2(tx2qp));
		    return bC263;
		end;


		Sub$7055: procedure;
			Bsub$70BC: procedure(nodeLoc) byte;
			    declare nodeLoc byte;
			    call Sub$6EE1(tx2op1(nodeLoc));
			    if boC25D then
				return TRUE;
                /* the code below appears to be wrong
                   a more appropriate test would be

                   tx2opc(tx2op1(nodeLoc)) == T2$VARIABLE

                   as is the condition should be false except
                   for complex statements with more than
                   172 nodes at which point the behaviour
                   is likely to be indeterminate and may
                   access out of bound locations

                   Note: The code only impacts re-entrant procs
                   In the C-Port this is modified and in certain
                   cases leads to better code, otherwise the code
                   is the same
                */

			    if tx2op1(nodeLoc) = 0ach then
			    do;
				curInfo$p = tx2op1(tx2op1(nodeLoc));
				if TestInfoFlag(F$AUTOMATIC) then
				    return TRUE;
			    end;
			    return FALSE;
			end;
		/* Sub$7055 */
		    if Bsub$70BC(tx2qp) then
			bC25A = tx2qp;
		    if tx2op3(tx2op1(bC259 := tx2qp)) <> 0ff00h then
			tx2op3(tx2op1(tx2qp)) = tx2qp;
		    call Sub$6C54(tx2op1(tx2qp));
		    call Sub$6C54(tx2op2(tx2qp));
		end;

	    call Sub$6EAB(.tx2op1(tx2qp));
	    call Sub$6EAB(.tx2op2(tx2qp));
	    if curOp = T2$STORE then
		call Sub$7055;
	    else if procCallDepth > 0 then
	    do;
		call Sub$6C54(tx2op1(tx2qp));
		call Sub$6C54(tx2op2(tx2qp));
		if curOp = T2$CALL then
		    procCallDepth = procCallDepth - 1;  
		else if curOp = T2$MOVE or curOp = T2$CALLVAR then
		do;
		    procCallDepth = procCallDepth - 1;  
		    call Sub$6EAB(.tx2op3(tx2qp));
		    call Sub$6C54(tx2op3(tx2qp));
		end;
		else
		    tx2op3(tx2qp) = 0ff00h;
	    end;
	    else if curOp = T2$OUTPUT or curOp = T2$TIME then
	    do;
		call Sub$6C54(tx2op1(tx2qp));
		call Sub$6C54(tx2op2(tx2qp));
	    end;
	    else
	    do;
		tx2op3(tx2qp) = 0;
		call Sub$6EE1(tx2qp);
		call Sub$6C73(Sub$6FE2);
		if curOp = T2$JMPFALSE then
		do;
		    if tx2opc(tx2qp - 1) = T2$NOT then
		    do;
			boC20F = TRUE;
			tx2op2(tx2qp) = tx2op1(tx2qp - 1);
			call Sub$56A0(tx2qp, tx2qp - 1);
			tx2opc(tx2qp) = T2$SEMICOLON;
		    end;
		end;
	    end;
	end;






	Sub$7111: procedure;
	    if procCallDepth > 0 then
		tx2op3(tx2qp) = 0ff00h;
	    else
	    do;
		tx2op3(tx2qp) = 0;
		if curOp = T2$VARIABLE then
		do;
		    curInfo$p = tx2op1(tx2qp);
		    if TestInfoFlag(F$AT) then
			call Sub$6C73(bC259);
		    else
			call Sub$6C73(bC25A);
		end;
		else
		    call Sub$6C73(bC25A);
	    end;
	end;

/* Sub$6BD6 */
	bC259 = 4;
	bC25A = 4;
	do tx2qp = 4 to bC1BF - 1;
		tx2Auxw(tx2qp) = 0;
		curOp = tx2opc(tx2qp);
		bC1D2 = b5124(curOp);
		if (bC1D2 and 0c0h) = 0 then
			call Sub$6D52;
		else if (bC1D2 and 0c0h) = 40h then
			call Sub$7111;
		if curOp = T2$BEGCALL or curOp = T2$BEGMOVE then
			procCallDepth = procCallDepth + 1;  

	end;
end;
END;
src/plm2d.plm
plm2d: DO;
$include(:f2:plm2d.ipx)

Sub$717B: procedure public;
	declare bC266 byte,
		(wC267, wC269, wC26B, wC26D) address,
		bC26F byte,
		p address,
		(bC272, bC273) byte;

	Bsub$7254: procedure(arg1b, arg2w) byte;
	    declare arg1b byte, arg2w address;
	    if arg1b = 0 then
	    do;
		if tx2Aux2b(bC26F) <> 4 then
		    return FALSE;
	    end;
	    else if arg1b <> 3 then
	    do;
		if tx2Aux2b(bC26F) <> 8 then
		    return FALSE;
		if arg2w <> 0 then
		do;
		    if arg1b = 2 then
			return FALSE;
		    if arg1b = 4 then
		    do;
			if wC269 <> 0 then
			   return FALSE;
		    end;
		    else if arg1b = 5 then
		    do;
			if wC269 <> wC26D then
			   return FALSE;
		    end;
		end;
	    end;
	    else if arg2w = 4000h then
		    return FALSE;
	    return TRUE;
	end;


	Sub$72F2: procedure address;
	    do case bC266;
		return wC267;
		return wC267 + wC26B;
		return wC267 - wC26B;
		return wC267 * wC26B;
		return wC267 / wC26B;
		return wC267 mod wC26B;
		return wC267 and wC26B;
		return wC267 or wC26B;
		return wC267 xor wC26B;
		return wC267 + wC26B;
		return wC267 + wC26B;
		return wC267 + wC26B + wC26B;
		return wC267 + wC26B;
		return -wC267;
		return not wC267;
		return low(wC267);
		return high(wC267);
		return wC267;
	    end;
	end;

	Sub$73C5: procedure;
	    if curOp = T2$MEMBER and tx2Aux2b(tx2op1(tx2qp)) = 0ah then
	    do;
		bC272 = tx2Aux1b(tx2op2(tx2qp));
		bC273 = 0Ah;
	    end;
	    else 
		do case b5112(bC266) and 7;
		    do;
			bC272 = 0;
			bC273 = 8;
		    end;
		    do;
			if tx2Aux1b(tx2op1(tx2qp)) = 0 and tx2Aux1b(tx2op2(tx2qp)) = 0 then
			   bC272 = 0;
			else
			   bC272 = 1;
			bC273 = 8;
		    end;
		    do;
			bC272 = 1;
			bC273 = 8;
		    end;
		    do;
			bC272 = tx2Aux1b(tx2op1(tx2qp));
			bC273 = tx2Aux2b(tx2op1(tx2qp));
		    end;
		    do;
			bC272 = tx2Aux1b(tx2op2(tx2qp));
			bC273 = tx2Aux2b(tx2op2(tx2qp));
		    end;
		    do;
			bC272 = Sub$5748(tx2Aux1b(tx2op2(tx2qp)));
			bC273 = 8;
		    end;
		end;
	    if wC269 = wC26D then
		curInfo$p = 0;
	    else if wC26D = 0  then
		curInfo$p = tx2op1(tx2op1(tx2qp));
	    else
		curInfo$p = tx2op1(tx2op2(tx2qp));
	end;

/* Sub$717B */
	bC266 = curOp - 12h;
	bC26F = tx2op1(tx2qp);
	call Sub$5FBF(bC26F, .wC267, .wC269);
	if Bsub$7254(shr(b5112(bC266), 6), wC269) then
	do;
		bC26F = tx2op2(tx2qp);
		call Sub$5FBF(bC26F, .wC26B, .wC26D);
		if Bsub$7254(shr(b5112(bC266), 3) and 7h, wC26D) then
		do;
			call Sub$611A;
			p = Sub$72F2;
			call Sub$73C5;
			if bC272 = 0 and bC273 = 8 then
				p = p and 0FFh;
			call Sub$5F4B(p, curInfo$p, bC272, bC273);
			bC1D2 = b5124(curOp := tx2opc(tx2qp));
		end;
	end;
end;


Sub$7550: procedure public;

	Bsub$765B: procedure(arg1b, arg2b, arg3b) byte;
		declare arg1b byte, arg2b byte, arg3b byte,
			bC27A byte, (wC27B, wC27D) address,
			(bC27F, i) byte, p address;


		Bsub$76E2: procedure(arg1b) byte;
			declare arg1b byte;
			if (bC27F and 40h) <> 0 then
			do;
				if tx2Aux1b(arg1b) = 1 then
					return TRUE;
				if tx2Aux1b(arg1b) = 3 then
					return TRUE;
				return FALSE;
			end;
			else if tx2Aux1b(arg1b) = 0 then
				return TRUE;
			else if tx2Aux1b(arg1b) = 2 then
				return TRUE;
			else if tx2Aux1b(arg1b) = 8 then
				return TRUE;
			else
				return FALSE;
		end;

		Sub$7754: procedure;
			declare (i, j) byte;
			i = tx2qp + 1;
			do while tx2opc(i) = T2$OPTBACKREF and i < bC1BF;
				i = i + 1;  
			end;
			j = tx2qp;
			if tx2opc(i) = T2$STORE then
			do;
				if arg3b= tx2op1(i) then
				do;
					if tx2op2(i) = j then
					do;
						if tx2Auxw(j) = 1 then
						do;
							bC27A = 6;
							tx2opc(i) = T2$SEMICOLON;
							tx2Auxw(j) = 0;
							tx2Auxw(arg3b) = tx2Auxw(arg3b) - 1;  
						end;
					end;
				end;
			end;
		end;

		Bsub$7801: procedure  byte;
			if wC27D <> 0 or (curOp < T2$BASED and tx2Aux2b(arg2b) <> 8) then
				return FALSE;
			if (bC27F and 20h) <> 0 then
				if not Bsub$76E2(arg3b) then
					return FALSE;
			if (bC27F and 1) <> 0 then
				if Bsub$76E2(arg2b) <> Bsub$76E2(arg3b) then
					return FALSE;
			if (bC27F and 4) <> 0 then
			do;
				if (bC27F and 8) <> 0 then
					if wC27B <> 0 then
						return TRUE;
					else
						return FALSE;
				p = w502A(shr(b5048(arg1b), 3));
				if p <> wC27B then
					return FALSE;
				if (bC27F and 80h) <> 0 then
					call Sub$7754;
				return 0FFh;
			end;
			if (bC27F and 40h) = 0 then
			do;
				p = w502A(shr(b5048(arg1b), 3));
				bC27A = wC27B mod p;
				return TRUE;
			end;
			else if wC27B <= 4 then
			do;
				bC27A = wC27B;
				return TRUE;
			end;
			else
				return FALSE;
		end;

		Sub$7925: procedure;
			declare (i, j, k) byte;
			arg1b = arg1b - 1;
			i = b5221(arg1b) + bC27A;
			j = b5048(arg1b) and 3;
			if i = 0ADh then
			do;
				if j = 0 then
					wC27B = 0;
				call Sub$611A;
				bC27F = 0;
				k = 1;
				if curOp <> T2$STAR then
				    if curOp <> T2$SLASH then
					if curOp <> T2$MOD then
					    if wC27B < 100h then
						if Bsub$76E2(arg2b) then
						    if arg3b = 0 then
							k = 0;
						    else if Bsub$76E2(arg2b) then
							k = 0;
				call Sub$5F4B(wC27B, 0, k, 8);
			end;
			else
			do;
				if j = 1 then
				do;
					tx2op1(tx2qp) = arg3b;
					tx2Auxw(arg2b) = tx2Auxw(arg2b) - 1;  
				end;
				else
				do;
					if tx2op2(tx2qp) <> 0 then
						tx2Auxw(tx2op2(tx2qp)) = tx2Auxw(tx2op2(tx2qp)) - 1;  
					if (bC1D2 and 4) <> 0 then
					do;
						tx2op1(tx2qp) = tx2op2(1);
						if boC20F then
						do;
							i = 43h - i;
							boC20F = 0;
						end;
					end;
				end;
				tx2opc(tx2qp) = i;
				tx2op2(tx2qp) = 0;
			end;
			bC1D2 = b5124(curOp := i);
		end;

/* Bsub$765B */
		call Sub$5FBF(arg2b, .wC27B, .wC27D);
		bC27A = 0;
		i = TRUE;

		do while i;
			if (bC27F := b50AD(arg1b)) = 0ffh then
				return FALSE;
			if (bC27F and 10h) <> 0 then
			do;
				i = not Bsub$76E2(arg2b);
				if (bC27F and 4) <> 0 and not i then
					i = not Bsub$7801;
			end;
			else 
				i = not Bsub$7801;
			arg1b = arg1b + 1;  
		end;
		call Sub$7925;
		return TRUE;
	end Bsub$765B;

/* Sub$7550 */
	if curOp <= T2$GT then
	do;
		if tx2opc(tx2qp+1) = T2$JMPFALSE and tx2Auxw(tx2qp) = 1 then
		do;
			tx2opc(tx2qp + 1) = T2$JNZ;
			tx2op1(tx2qp + 1) = tx2op2(1);
			if boC20F then
			do;
				tx2op2(tx2qp + 1) = bC209(curOp);
				boC20F = 0;
			end;
			else
				tx2op2(tx2qp + 1) = curOp;
			tx2Auxw(tx2qp) = 0;
		end;
		else
			tx2opc(tx2qp), curOp = curOp + 26h;
	end;
	else if Bsub$765B(b5202(curOp), tx2op2(tx2qp), tx2op1(tx2qp)) then
		;
	else if Bsub$765B(b51E3(curOp), tx2op1(tx2qp), tx2op2(tx2qp)) then
			;
end;


end;
src/plm2e.plm
plm2e: DO;
$include(:f2:plm2e.ipx)

declare b7A81(4) byte data(3CH, 46H, 50H, 5AH);


Sub$7A85: procedure public;
	declare (i, j) byte,
		bC28B(4) byte, bC28F byte,
		(k, m, n) byte;

	Sub$7D32: procedure;
		call EncodeFragData(CF$XCHG);
		pc = pc + 1;  
		call Sub$5B96(3, 4);
		call Sub$5B96(2, 3);
		call Sub$5B96(4, 2);
	end;

	Sub$7D54: procedure;

		wC1DC(0) = 0ah;
		wC1DC(1) = wC1C3;
		call EncodeFragData(CF$XTHL);
		pc = pc + 1;  
		call Sub$5C97(4);
		call Sub$5C1D(3);
		call Sub$5B96(4, 3);
	end;


	Sub$7D7E: procedure(arg1b);
		declare arg1b byte;
		if arg1b <= 3 then 
			if bC28B(arg1b) < 0c8h then
				bC28B(arg1b) = bC28B(arg1b) + bC28F;
	end;

/* Sub$7A85 */
	call Sub$597E;
	do i = 0 to 3;
		if boC072(i) or boC069(i) then
			bC28B(i) = 0c8h;
		else if boC060(i) then
			bC28B(i) = b7A81(i) + 0fh;
		else
			bC28B(i) = b7A81(i);
	end;

	if shr(bC0C3(wC1C3), 4) <> 0bh and bC140(wC1C3) <> 0 then
		bC28B(0) = 0C8h;
	do m = 0 to 1;
		if bC0B7(m) <> 0 then
		do;
			if bC0B5(m) = 9 and bC140(wC1C3) = bC0B7(m) then
			do;
				k = m;
				bC28F = 0ceh;
				boC1D8 = 0;
			end;
			else
				bC28F = 32h;
			call Sub$7D7E(b52B5(bC0BF(m)));
			call Sub$7D7E(shr(b4C2D(bC0BD(m)), 5));
		end;
	end;

	n = 0c8h;
	do i = 0 to 3;
		if bC28B(i) <= n then
			n = bC28B(j := i);
	end;

	if n = 0C8h then
	do;
		if boC069(3) then
		do;
			call Sub$7D32;
			if bC0B5(0) = 3 then
			do;
				bC0B5(0) = 2;
				call Sub$61A9(0);
			end;
			else
			do;
				bC0B5(1) = 2;
				call Sub$61A9(1);
			end;
		end;
		call Sub$7D54;
		j = 3;
	end;
	else
		call Sub$6416(j);

	if bC045(j) = 0bh then
	do;
		bC045(j) = 0;
		if j <> 0 and bC04E(j) <> 0 then
		do;
			wC1DC(0) = j;
			call EncodeFragData(CF$MOVLRHR);
			pc = pc + 1;  
		end;
	end;
	if not boC1D8 then
	do;
		if bC0B5(1 - k) = 9 then
		do;
			if bC0B7(1 - k) = bC0B7(k) then
			do;
				bC0B5(1 - k) = j;
				bC0B3(1 - k) = bC045(j);
				call Sub$61A9(1 - k);
			end;
			else
				boC1D8 = 0ffh;
		end;
		bC0B5(k) = j;
		bC0B3(k) = bC045(j);
		call Sub$61A9(k);
	end;
end;





Sub$7DA9: procedure public;
	declare (bC294, bC295, bC296, bC297, bC298, i) byte;

	Sub$7F19: procedure;

		Bsub$7FD9: procedure(arg1b) bool;
			declare arg1b byte;
			if arg1b <= 3 then
				if bC0B5(bC296) = arg1b then
					return true;
			return false;
		end;

		do bC295 = 0 to 1;
			if bC0B7(bC295) <> 0 and bC0BB(bC295) <> 0 then
			do;
				if bC0BB(bC296 := 1 - bC295) <> 0 then
				do;
					if Bsub$7FD9(shr(b4C2D(bC0BD(bC295)), 5)) 
					  or Bsub$7FD9(b52B5(bC0BF(bC295))) then
						bC0BB(bC296) = 10 + bC0BB(bC296);
				end;
			end;
		end;

		if bC0BB(0) > bC0BB(1) then
			bC295 = 0;
		else
			bC295 = 1;

		bC296 = 1 - bC295;
		bC298 = bC0BD(bC295);
	end;



	Sub$7FFC: procedure;
		if bC298 = 13h then
		do;
			if boC072(3) or boC069(3) then
				bC298 = 15h;
		end;
		else if bC298 = 14h then
		do;
			bC294 = 5 - bC297;
			if bC0B5(0) = bC0B5(1) then
				if bC0B3(bC295) = 0 then
					bC298 = 0Eh;
				else
					bC298 = 11h;
		end;
		else if bC298 = 8 then
		do;
			if tx2op1(bC0B7(bC295)) <> 0 then
			do;
				bC298 = 6;
				if bC294 = 0 then
					bC294 = 1;
			end;
		end;
	end;



	Sub$8086: procedure;
		if 9 <= bC298 and bC298 <= 13 then
			call Sub$63AC(bC297);

		if b4C2D(bC298) then
		do;
			if bC294 <> bC297 then 
				call Sub$5D6B(bC294);
			else if 9 <= bC298 and bC298 <= 13 then
			do;
				bC0B5(bC295) = 9;
				call Sub$597E;
				call Sub$5D6B(bC294);
				bC0B5(bC295) = bC297;
				call Sub$597E;
			end;
		end;
		else if bC298 = 15h then
		do;
			if boC069(3) then
				bC0B5(bC296) = 9;
		end;
		else if bC298 = 14h then
		do; 
			if bC0B5(bC296) = bC294 then
				bC0B5(bC296) = bC297;
		end;
	end;

	Sub$8148: procedure(arg1b, arg2b);
		declare arg1b byte, arg2b byte;
		declare i byte;
		if arg2b = 0 then
			return;
		if arg2b = 1 or arg2b = 2 then
		do;
			if arg1b = 0 then
				wC1DC(bC1DB) = bC297;
			else
				wC1DC(bC1DB) = bC294;
			bC1DB = bC1DB + 1;  
		end;
		else if arg1b = 2 then
		do;
			wC1DC(bC1DB) = 8;
			bC1DB = bC1DB + 2;
		end;
		else if arg1b = 3 then
		do;
			wC1DC(bC1DB) = 0Ah;
			wC1DC(bC1DB+1) = wC1C3;
			bC1DB = bC1DB + 3;
		end;
		else
		do;
			i = bC1DB;
			call Sub$636A(bC295);
		end;

	end;

	Sub$8207: procedure;
		do case shr(b4C15(bC298), 4);
			do;
				call Sub$5C97(bC294);
				wC1C3 = wC1C3 - 1;  
			end;
			do;
				call Sub$5C97(4);
				call Sub$5C1D(3);
				call Sub$5B96(4, 3);
			end;
			do;
				boC057(bC294) = true;
				bC0A8(bC294) = 0;
				bC04E(bC294) = bC0B7(bC295);
				wC096(bC294) = 100h;
				if wC1DC(0) = 0Ah then
				do;
					wC084(bC294) = - shl(wC1DC(1), 1);
					if bC0C3(tx2op3(bC0B7(bC295))) = 0b0h then
						if bC298 = 5 then
						do;
							wC084(bC294) = wC084(bC294) - 1;  
							wC1DC(2) = wC1DC(2) + 1;  
						end;
				end;
				else
					wC084(bC294) = wC1DC(3) - shl(wC1C3, 1);
			end;
			do;
				boC057(bC294) = true;
				bC0A8(bC294) = 0;
				bC04E(bC294) = bC0B7(bC295);
				call Sub$5FBF(bC04E(bC294), .wC084(bC294), .wC096(bC294));
			end;
			do;
				boC057(bC294) = 0;
				bC04E(bC294) = bC0B7(bC295);
				if bC0B3(bC295) = 4 or bC0B3(bC295) = 5 then
				do;
					bC0A8(bC294) = bC0C3(tx2op3(bC0B7(bC295))) and 0fh;
					if bC0A8(bC294) > 7 then
						bC0A8(bC294) = bC0A8(bC294) or  0f0h;
				end;
				else
					bC0A8(bC294) = 0;
			end;
			call Sub$5B96(bC297, bC294);
			do;
				call Sub$5B96(3, 4);
				call Sub$5B96(2, 3);
				call Sub$5B96(4, 2);
			end;
			;
		end;
	end;

	Sub$841E: procedure;
		do case b4C15(bC298) and 0fh;
			;
			bC045(bC294) = 1;
			bC045(bC294) = 0;
			bC045(bC294) = 6;
			do;
				if bC0B5(bC295) <> 8 then
					bC045(bC294) = Sub$5748(bC0B3(bC295));
				else if bC0B3(bC295) = 0 then
					bC045(bC294) = 6;
				else
					bC045(bC294) = bC0B3(bC295);
			end;
			do;
				bC045(bC294) = bC0B3(bC295) - 2;
				bC0A8(3) = bC0A8(3) + 1;  
			end;
		end;
	end;




/* Sub$7DA9 */
	call Sub$7F19;
	if bC298 = 17h then
		call Sub$58F5(ERR214);
	else if bC298 = 16h then
	do;
		bC0C1(bC295) = bC0BF(bC295);
		bC0B3(bC295) = b528D(bC0C1(bC295));
		bC0B5(bC295) = b52B5(bC0C1(bC295));
	end;
	else if bC298 = 12h then
		boC1D8 = TRUE;
	else
	do;
		bC294 = shr(b4C2D(bC298), 5);
		if bC294 > 3 then
			bC294 = b52B5(bC0BF(bC295));
		bC297 = bC0B5(bC295);
		call Sub$597E;
		call Sub$7FFC;
		i = b5012(bC298);
		call Sub$8086; 
		bC1DB = 0;
		call Sub$8148(shr(b4C2D(bC298), 3) and 3, shr(b4029(i), 4) and 7);
		call Sub$8148(shr(b4C2D(bC298), 1) and 3, shr(b4029(i), 1) and 7);
		call Sub$8207;
		call Sub$841E;
		bC0B3(bC295) = bC045(bC294);
		bC0B5(bC295) = bC294;
		call Sub$61A9(0);
		call Sub$61A9(1);
		call EncodeFragData(i);
		pc = pc + (b43F8(i) and 01fh);


	end;
end;



Sub$84ED: procedure public;
	declare i byte;
	declare helpers based helpers$p(1) address;

	Sub$8683: procedure(arg1b) byte;
		declare arg1b byte;
		if bC0B5(0) = arg1b then
			return 1;
		else
			return 0;
	end;


	Sub$8698: procedure(arg1b, arg2b);
		declare arg1b byte, arg2b byte;
		declare i byte;
		declare p address;
		do case arg1b;
			return;
			i = 0;
			i = 1;
			do;
				wC1DC(bC1DB) = 0Ah;
				wC1DC(bC1DB + 1) = wC1C3;
				bC1DB = bC1DB + 3;
				return;
			end;
			i = Sub$8683(3);
			i = Sub$8683(0);
			do;
				if arg2b = 7 then
				do;
					wC1DC(bC1DB) = 10h;
					wC1DC(bC1DB + 1) = tx2op3(tx2qp) - botInfo;
					bC1DB = bC1DB + 2;
				end;
				else
					call Sub$61E0(tx2op3(tx2qp));
				return;
			end;
		end;
		if arg2b <= 3 then
			call Sub$636A(i);
		else
		do;
			wC1DC(bC1DB) = arg2b + 9;
			if arg2b = 6 then
				wC1DC(bC1DB + 1) = tx2op2(1);
			else
				call Sub$5FBF(bC0B7(i), .wC1DC(bC1DB+1), .p);
			bC1DB = bC1DB + 2;
		end;
	end;

/* Sub$84ED */
	if cfrag1 > CF$3 then
	do;
		bC1DB = 0;
		call Sub$8698(shr(b42F9(cfrag1), 4), shr(b4029(cfrag1), 4) and 7);
		if cfrag1 = CF$67 or cfrag1 = CF$68 then
			wC1DC(bC1DB - 1) = wC1DC(bC1DB - 1) + 2;
		call Sub$8698(b42F9(cfrag1) and 0fh, shr(b4029(cfrag1), 1) and 7);
		call EncodeFragData(cfrag1);
		pc = pc + (b43F8(cfrag1) and 01fh);
		if cfrag1 = CF$DELAY then
		do; 
			helpers(105) = 1;
			if wC1C5 < shl(wC1C3 + 1, 1) then
				wC1C5 = shl(wC1C3 + 1, 1);
		end;
		else if cfrag1 > CF$171 then
		do;
			i = b413B(cfrag1 - CF$174);
			i = b4128(i) + 11 * b425D(b4273(curOp));
			i = b3FCD(shr(b418C(i), 2)) + (b418C(i) and 3);
			helpers(i) = 1;
			if curOp = T2$SLASH or curOp = T2$MOD
			 or curOp = T2$44 then
			do;
				if wC1C5 < shl(wC1C3 + 2, 1) then
					wC1C5 = shl(wC1C3 + 2, 1);
			end;
			else if wC1C5 < shl(wC1C3 + 1, 1) then
					wC1C5 = shl(wC1C3 + 1, 1);
		end;
	end;
end;


END;
src/plm2f.plm
plm2f: DO;
$include(:f2:plm2f.ipx)

Sub$87CB: procedure public;
	declare (bC2A5, bC2A6, bC2A7, bC2A8) byte,
		(wC2A9, wC2AB, wC2AD) address;

	Bsub$8861: procedure bool;
		declare i byte;
		do wC1D6 = wC2AB to wC2AD;
			i = Sub$5679(bC2A5);
			if 0 <= i and i <= 3 then
				return true;
			if 12 <= i and i <= 14 then
				return true;
		end;
		return false;
	end Bsub$8861;


	Sub$88C1: procedure;
		if Bsub$8861 then
		do;
			do bC2A8 = 0 to 3;
				if bC04E(bC2A8) = bC2A6 then
				do;
					if bC045(bC2A8) = 0 or bC045(bC2A8) = 1
					   or bC045(bC2A8) = 6 then
					do;
						bC0B3(bC2A5) = bC045(bC2A8);
						bC0B5(bC2A5) = bC2A8;
						if bC0B5(1 - bC2A5) <> bC2A8 then
							return;
					end;
				end;
			end;
		end;
	end Sub$88C1;

	Sub$894A: procedure;
		if bC0B5(bC2A5) > 3 then
		do;
			do bC2A8 = 1 to 3;
				if bC04E(bC2A8) = bC2A6 then
				do;
					if bC045(bC2A8) = 2 or bC045(bC2A8) = 3 then
					do;
						bC0B3(bC2A5) = bC045(bC2A8);
						bC0B5(bC2A5) = bC2A8;
						if bC0B5(1 - bC2A5) <> bC2A8 then
							return;
					end;
				end;
			end;
		end;
	end Sub$894A;


	Sub$89D1: procedure;
		declare i byte;
		declare p address;
		if bC0B5(bC2A5) = 0Ah then
			wC2A9 = tx2op2(bC2A6);
		else if bC0B5(bC2A5) = 9 then
		do;
			wC2A9 = tx2op3(bC2A6);
			if ( not boC069(0) and boC072(0)) or bC0B1 > 0 or wC2A9 <> wC1C3 then
			do;
				i = bC0B1 + bC0B2;
				do p = wC2A9 to wC1C3;
					if bC140(p) <> 0 then
						i = i + 1;  
				end;
				if i < 4 then
					boC1D8 = true;
				else
					bC0B5(bC2A5) = 0Ah;
			end;
			wC2A9 = - shl(wC2A9, 1);
		end;
	end Sub$89D1;

	Sub$8A9C: procedure;
		declare (p, q) address;
		declare (i, j) byte, r address;
		if bC0B5(bC2A5) = 0Ah then
		do;
			p = wC2A9;
			q = 100h;
			i = 4;
			j = Sub$5748(bC0B3(bC2A5));
		end;
		else if bC0B5(bC2A5) = 8 and bC0B3(bC2A5) = 1 then
		do;
			call Sub$5FBF(bC0B7(bC2A5), .p, .q);
			i = 2;
			j = 1;
		end;
		else if bC0B5(bC2A5) = 4 and
		   (bC0B3(bC2A5) = 0 or bC0B3(bC2A5) = 8 or  not Bsub$8861) then
		do;
			call Sub$5FBF(bC0B7(bC2A5), .p, .q);
			i = 2;
			j = Sub$5748(bC0B3(bC2A5));
		end;
		else
			return;

		do bC2A8 = 1 to 3;
			if boC069(bC2A8) then
			do;
				if bC0B7(0) = bC0B7(1) and curOp <> T2$STORE then
					if bC0B5(bC2A5) > 3 then
						bC0B5(bC2A5) = bC2A8;
			end;
			else if not boC072(bC2A8) and wC096(bC2A8) = q
				    and boC057(bC2A8) and 1 <= bC045(bC2A8)
				    and bC045(bC2A8) <= 6 then
			do;
				r = wC084(bC2A8) + bC0A8(bC2A8) - p;
				if r > 0ffh then
					r = -r;
				if r < i then
				do;
					bC0B5(bC2A5) = bC2A8;
					i = r;
				end;
			end;
		end;
		if bC0B5(bC2A5) <= 3 then
		do;
			bC2A8 = bC0B5(bC2A5);
			bC045(bC2A8), bC0B3(bC2A5) = j;
			bC04E(bC2A8) = bC0B7(bC2A5);
			bC0A8(bC2A8) = wC084(bC2A8) + bC0A8(bC2A8) - p;
			wC084(bC2A8) = p;
		end;
	end Sub$8A9C;



	Sub$8CF5: procedure;
		bC0B5(0) = 8;
		bC0B5(1) = 8;
		do bC2A5 = 0 to 1;
			if (bC2A6 := bC0B7(bC2A5)) = 0 then
			do;
				bC0B3(bC2A5) = 0Ch;
			end;
			else if (bC2A7 := tx2opc(bC2A6)) = T2$STACKPTR then
			do;
				bC0B3(bC2A5) = 0Ah;
			end;
			else if bC2A7 = T2$LOCALLABEL then
			do; 
				bC0B3(bC2A5) = 9;
			end;
			else
			do;
				bC0B3(bC2A5) = tx2Aux1b(bC2A6);
				bC0B5(bC2A5) = tx2Aux2b(bC2A6);
				call Sub$88C1; 
				call Sub$894A;/*  checked */
			end;
		end;
		do bC2A5 = 0 to 1;
			bC2A6 = bC0B7(bC2A5);
			call Sub$597E;
			call Sub$89D1;
			call Sub$8A9C;
			call Sub$61A9(bC2A5);
		end;
	end Sub$8CF5;



	Sub$8DCD: procedure;
		declare (h, i, j, k, m, n) byte;

		Sub$8E7E: procedure(arg1b)  byte;
			declare arg1b byte;
			declare p address, i byte;

			if bC0B7(arg1b) = 0 or bC0B7(arg1b) = 1 then
				return 1;
			i = Sub$5679(arg1b);
			return b4D23(p := bC0C1(arg1b) * 16 + i);
		end Sub$8E7E;

		Sub$8ECD: procedure(arg1b, arg2b);
			declare arg1b byte, arg2b byte;
			bC0B9(arg1b) = b4C45(arg2b);
			bC0BB(arg1b) = b4CB4(arg2b);
			bC0BD(arg1b) = b4FA3(arg2b);
		end Sub$8ECD;

/* Sub$8DCD */
		j = 198;
		do wC1D6 = wC2AB to wC2AD;
			k = Sub$8E7E(0);
			m = Sub$8E7E(1);
			n = b4C45(k) + b4C45(m) + (b43F8(b4A21(wC1D6)) and 1fh);
			if n < j then
			do;
				j = n;
				h = k;
				i = m;
				cfrag1 = b4A21(wC1D6);
				bC1D9 = b46EB(wC1D6);
				bC0BF(0) = Sub$5679(0);
				bC0BF(1) = Sub$5679(1);
			end;
		end;
		call Sub$8ECD(0, h);
		call Sub$8ECD(1, i);
	end Sub$8DCD;



	Sub$8F16: procedure;
		if bC0B7(0) <> 0 then
			call Sub$63AC(bC0B5(0));

		if bC0B7(1) <> 0 then 
			call Sub$63AC(bC0B5(1));

	end Sub$8F16;


	Sub$8F35: procedure;
		declare p address;
		if curOp = T2$STKARG or curOp = T2$STKBARG or curOp = T2$STKWARG then
		do;
			call Sub$5795(-shl(wB53C(procCallDepth), 1));
			wB53C(procCallDepth) = wB53C(procCallDepth) + 1;  
			wC1C3 = wC1C3 + 1;  
		end;
		else if curOp = T2$CALL then
		do;
			call Sub$5795(-shl(wB53C(procCallDepth), 1));
			curInfo$p = tx2op3(tx2qp);
			if TestInfoFlag(F$EXTERNAL) then
				p = shl(wB53C(procCallDepth) + 1, 1);
			else
				p = shl(wB528(procCallDepth) + 1, 1) + GetBaseVal;
			if p > wC1C5 then
				wC1C5 = p;
		end;
		else if curOp = T2$CALLVAR then
		do;
			call Sub$5795(-shl(wB53C(procCallDepth), 1));
			if wC1C5 < shl(wC1C3, 1) then
				wC1C5 = shl(wC1C3, 1);
		end;
		else if curOp = T2$RETURN or curOp = T2$RETURNBYTE
		    or curOp = T2$RETURNWORD then
		do;
			boC1CD = 0ffh;
			call Sub$5EE8;
		end;
		else if curOp = T2$JMPFALSE then
		do;
			call Sub$5795(0);
			if boC20F then
			do;
				cfrag1 = CF$JMPTRUE;
				boC20F = 0;
			end;
		end;
		else if curOp = T2$63 then 
			call Sub$5795(0);
		else if curOp = T2$MOVE then
		do;
			if wB53C(procCallDepth) <> wC1C3 then
			do;
				call Sub$5795(-shl(wB53C(procCallDepth) + 1, 1));
				call Sub$6416(3);
			end;
			if bC045(3) = 1 then
				cfrag1 = CF$MOVE$HL;
		end;
	end Sub$8F35;


	Sub$90EB: procedure;
		declare (p, q) address;
		declare (i, j, k) byte;

		Sub$940D: procedure;
			do bC2A8 = 0 to 3;
				if bC04E(bC2A8) = bC0B7(0) then
					if bC045(bC2A8) < 2 or 5 < bC045(bC2A8) then
						bC04E(bC2A8) = 0;
			end;
		end;

		p = w48DF(bC1D9) * 16;
		q = w493D(bC1D9);
		k = 0;
		if curOp = T2$STORE then
		do;
			call Sub$940D;
			if tx2Auxw(bC0B7(1)) = 0 then
			    if tx2Auxw(bC0B7(0)) > 0 then
				do;
					if cfrag1 = CF$MOVMLR or cfrag1 = CF$STA then
					do;
						bC045(bC0B5(1)) = 0;
						bC04E(bC0B5(1)) = bC0B7(0);
					end;
					else if cfrag1 = CF$SHLD or cfrag1 = CF$MOVMRP then
					do;
						bC045(bC0B5(1)) = 1;
						bC04E(bC0B5(1)) = bC0B7(0);
					end;
				end;
		end;
		else if T2$51 <= curOp and curOp <= T2$56 then
			call Sub$940D;
		do bC2A8 = 5 to 8;
			i = shr(p, 13);
			j = shr(q, 12);
			p = shl(p, 3);
			q = shl(q, 4);
			if j <= 3 then
			do;
				call Sub$5B96(j, bC2A8);
				if i = 1 then
					bC0A8(bC2A8) = bC0A8(bC2A8) + 1;  
				else if i = 2 then
				do;
					if bC045(bC2A8) = 0 then
					do;
						bC045(bC2A8) = 6;
					end;
					else
					do;
						bC045(bC2A8) = 1;
						boC057(bC2A8) = 0;
					end;
				end;
			end;
			else if j = 4 then
			do;
				boC057(k := bC2A8) = 0;
				if 0 < tx2Auxw(tx2qp) then
				do;
					bC04E(bC2A8) = tx2qp;
					bC045(bC2A8), tx2Aux1b(tx2qp) = shr(b43F8(cfrag1), 5);
					bC0A8(bC2A8) = 0;
				end;
				else
					bC04E(bC2A8) = 0;
			end;
			else if j = 5 then
			do;
				bC04E(bC2A8) = 0;
				wC096(bC2A8) = 0;
				bC0A8(bC2A8) = 0;
				boC057(bC2A8) = 0FFh;
				bC045(bC2A8) = 0;
				wC084(bC2A8) = i;
			end;
			else
			do;
				bC04E(bC2A8) = 0;
				boC057(bC2A8) = 0;
			end;
		end;
		if k = 0 and tx2Auxw(tx2qp) > 0 then
		do;
			do bC2A8 = 5 to 8;
				if bC04E(bC2A8) = 0 then 
					if not boC057(k := bC2A8) then
						goto break;
			end;
		break:
			if k <> 0 then
			do;
				bC04E(k) = tx2qp;
				boC057(k) = 0;
				bC045(k) = 0;
				tx2Aux1b(tx2qp) = 0;
				bC0A8(k) = 0;
			end;
		end;
		do bC2A8 = 0 to 3;
			call Sub$5B96(bC2A8 + 5, bC2A8);
		end;
	end Sub$90EB;

/* Sub$87CB */
	bC0B7(0) = tx2op1(tx2qp);
	bC0B7(1) = tx2op2(tx2qp);
	wC2AB = wAF54(curOp);
	wC2AD = wC2AB + b499B(curOp) - 1;
	call Sub$8CF5;

	do while 1;
		call Sub$8DCD;	/*  OK */
		if bC0B9(0) = 0 then
			if bC0B9(1) = 0 then
				goto break;
		if boC1D8 then
			call Sub$7A85;
		else
			call Sub$7DA9;
	end;
break:
	call Sub$8F16;
	call Sub$611A;
	call Sub$5E66(shr(w48DF(bC1D9), 12));
	call Sub$8F35;
	call Sub$84ED;
	call Sub$90EB;
end Sub$87CB;


Sub$9457: procedure public;
	if EnterBlk then
	do;
		wB488(procChainId) = pc;
		wB4B0(procChainId) = wC1C3;
		wB4D8(procChainId) = wC1C5;
		extProcId(procChainId) = curExtProcId;
		procChainNext(blkSP) = procChainId;
		procChainId = blkSP;
		curInfo$p, blkCurInfo(blkSP) = tx2op1(tx2qp) + botInfo;
		curExtProcId = GetProcId;
		pc = 0;
		call EmitTopItem;
		call Sub$981C;
	end;
end;
end;
src/plm2g.plm
plm2g: DO;
$include(:f2:plm2g.ipx)

declare curParamCnt byte,
	bC2D1 byte,
	(bC2D2, bC2D3) byte,
	wC2D4 address;


FindParamInfo: procedure(arg1b) public;
	declare arg1b byte;
	curInfo$p = blkCurInfo(blkSP);
	do while arg1b <> 0;
		call AdvNxtInfo;
		arg1b = arg1b - 1;  
	end;
end;



Sub$9514: procedure public;
	if GetType = ADDRESS$T then
	do;
		wC1DC(0) = bC2D1;
		call EncodeFragData(CF$MOVMRPR);
		pc = pc + 3;
	end;
	else
	do;
		wC1DC(0) = bC2D1;
		call EncodeFragData(CF$MOVMLR);
		pc = pc + 1;  
	end;
	if bC2D2 <> curParamCnt then
	do;
		call EncodeFragData(CF$DCXH);
		pc = pc + 1;  
	end;
end;

Sub$9560: procedure public;
	declare i byte;
	if (i := curParamCnt) = 1 then
		bC2D1 = 1;
	else
		bC2D1 = 2;
	do bC2D2 = 1 to curParamCnt;
		call FindParamInfo(i);
		if bC2D2 = 2 then
			bC2D1 = 1;
		else if bC2D2 = 3 then
		do; 
			wC1DC(0) = 2;	/*  pop d */
			wC1DC(1) = 8;
			call EncodeFragData(CF$POP);
			wC1DC(0) = 1;	/*  pop b */
			wC1DC(1) = 8;
			call EncodeFragData(CF$POP);
			pc = pc + 2;
		end;
		else if bC2D2 > 3 then
		do;
			wC1DC(0) = 1;	/*  pop b */
			wC1DC(1) = 8;
			call EncodeFragData(CF$POP);
			pc = pc + 1;  
		end;
		call Sub$9514;
		i = i - 1;  
	end;
	if curParamCnt > 2 then
	do; 
		wC1DC(0) = 2;	/*  push d */
		wC1DC(1) = 8;
		call EncodeFragData(CF$PUSH);
		pc = pc + 1;  
	end;
end;

Sub$9624: procedure(arg1w) public;
	declare arg1w address;
	wC1DC(0) = 9;
	wC1DC(1) = arg1w;
	call EncodeFragData(CF$6);
	pc = pc + 4;
end;


Sub$9646: procedure(arg1w) public;
	declare arg1w address;
	if shr(arg1w, 1) + (arg1w and 1) <= 5 then
	do; 
		if arg1w then
		do;
			call EncodeFragData(CF$DCXSP);
			pc = pc + 1;  
		end;
		do while arg1w > 1;
			wC1DC(0) = 3;	/*  push h */
			wC1DC(1) = 8;
			call EncodeFragData(CF$PUSH);
			pc = pc + 1;  
			arg1w = arg1w - 2;
		end; 
	end;
	else
	do;
			call Sub$9624(-arg1w);
			call EncodeFragData(CF$SPHL);
			pc = pc + 1;  
	end;
end;


Inxh: procedure public;
	wC1DC(0) = 3;
	call EncodeFragData(CF$INX);
	pc = pc + 1;  
end;


OpB: procedure(arg1b) public;
	declare arg1b byte;
	wC1DC(0) = 1;
	call EncodeFragData(arg1b);
	pc = pc + 1;  
end;

OpD: procedure(arg1b) public;
	declare arg1b byte;
	wC1DC(0) = 2;
	call EncodeFragData(arg1b);
	pc = pc + 1;  
end;


Sub$9706: procedure public;
	call Inxh;
	if GetType = ADDRESS$T then
	do;
		call OpB(CF$MOVLRM);
		if bC2D3 = 1 then
			call OpD(CF$MOVMLR);

		call Inxh;
		call OpB(CF$MOVHRM);
	end;
	else
	do;
		call OpB(CF$MOVHRM);
		if bC2D3 = 1 then
			call OpD(CF$MOVMLR);
		call Inxh;
	end;
	if bC2D3 = 1 then
		call OpD(CF$MOVMHR);
end;



MovDem: procedure public;
	call OpD(CF$MOVRPM);
	pc = pc + 2;
end;


Sub$975F: procedure public;
	wC1DC(0) = bC2D1;
	wC1DC(1) = 8;
	call EncodeFragData(CF$PUSH);
	pc = pc + 1;  
	if GetType = BYTE$T then
	do;
		call EncodeFragData(CF$INXSP);
		pc = pc + 1;  
	end;
end;


Sub$978E: procedure public;
	if (bC2D3 := curParamCnt) > 2 then
		call Sub$9624(wC2D4);
	if curParamCnt = 1 then
		bC2D1 = 1;
	else
		bC2D1 = 2;
	do bC2D2 = 1 to curParamCnt;
		call FindParamInfo(bC2D3);
		if bC2D2 > 3 then
			call Sub$9706;
		else if bC2D2 = 3 then
		do;
			call MovDem;
			call Sub$9706;
		end;
		else if GetType = BYTE$T then
		do;
			wC1DC(0) = bC2D1;
			call EncodeFragData(CF$MOVHRLR);
			pc = pc + 1;  
		end;
		call Sub$975F;
		bC2D1 = 1;
		bC2D3 = bC2D3 - 1;  
	end;
end;


Sub$981C: procedure public;
	declare (i, j) byte;
	curParamCnt = GetParamCnt;
	if TestInfoFlag(F$INTERRUPT) then
	do;
		do j = 0 to 3;
			wC1DC(0) = 3 - j;
			wC1DC(1) = 8;	/*  push h, push d, push b, push psw */
			call EncodeFragData(CF$PUSH);
			pc = pc + 1;  
		end;
	end;
	if TestInfoFlag(F$REENTRANT) then
	do;
		wC1C7 = GetParentVal; /* or Size */;
		if curParamCnt > 0 then
		do;
			call FindParamInfo(curParamCnt);
			wC2D4 = wC1C7 - GetLinkVal - 1;
			if GetType = ADDRESS$T then
				wC2D4 = wC2D4 - 1;  
			call Sub$9646(wC2D4);
			call Sub$978E;
		end;
		else
			call Sub$9646(wC1C7);

		if curParamCnt > 2 then
			wC1C7 = wC1C7 + shl(curParamCnt - 2, 1);

		wC1C5 = 0;
	end;
	else
	do;
		if curParamCnt > 0 then
		do;
			call FindParamInfo(curParamCnt);	/*  locate info for first param */
			if GetType = ADDRESS$T then
				i = 1;
			else
				i = 0;
			wC1DC(0) = 3;
			wC1DC(1) = 0bh;
			wC1DC(2) = i;
			wC1DC(3) = curInfo$p - botInfo;	/*  info for first param */
			call EncodeFragData(CF$7);
			call Sub$9560;
			pc = pc + 3;
		end;
		wC1C7 = 0;
		if curParamCnt > 2 then
			wC1C5 = shl(curParamCnt - 2, 1);
		else
			wC1C5 = 0;
	end;
end;

Sub$994D: procedure public;
	declare (i, j) byte;
	declare localLabels based localLabels$p(1) address,
		barray based w381E(1) byte,
		mwords based botMem(1) address;

	if curOp = T2$LABELDEF then
	do;
		boC1CC = 0;
		curInfo$p = tx2op1(tx2qp) + botInfo;
		call SetLinkVal(pc);
	end;
	else if curOp = T2$LOCALLABEL then
	do;
		boC1CC = 0;
		localLabels(tx2op1(tx2qp)) = pc;
		barray(tx2op1(tx2qp)) = curExtProcId;
	end;
	else if curOp = T2$CASELABEL then
	do;
		localLabels(tx2op1(tx2qp)) = pc;
		barray(tx2op1(tx2qp)) = curExtProcId;
		if (w3822 - botMem)/2 >= wC1CF then
		do;
			mwords(wC1CF) = tx2op1(tx2qp);
			wC1CF = wC1CF + 1;  
		end;
		else
		do;
			call EmitTopItem;
			call Tx2SyntaxError(ERR202);	/*  LIMIT EXCEEDED: NUMBER OF */
						/*  ACTIVE CASES */
		end;
	end;
	else if curOp = T2$JMP or curOp = T2$JNC
	   or curOp = T2$JNZ or curOp = T2$GO$TO then
	do;
		i = tx2opc(tx2qp - 1);
		if i = T2$RETURN or i = T2$RETURNBYTE
		  or i = T2$RETURNWORD or i = T2$GO$TO then
			return;
		call Sub$5795(0);
	end;
	else if curOp = T2$INPUT or (T2$SIGN <= curOp and curOp <= T2$CARRY) then
	do;
		bC0B7(0) = 0;
		bC0B7(1) = 0;
		bC0B5(0) = 8;
		bC0B5(1) = 8;
		call Sub$597E;
		call Sub$5D6B(0);
		bC045(0) = 0;
		bC04E(0) = tx2qp;
		boC057(0) = 0;
		bC0A8(0) = 0;
		tx2Aux1b(tx2qp) = 0;
		tx2Aux2b(tx2qp) = 9;
	end;
	else if curOp = T2$STMTCNT then
	do;
			j = tx2qp + 1;

			do while tx2opc(j) <> T2$STMTCNT and tx2opc(j) <> T2$EOF
			    and j < 0FFh;
				if (b5124(tx2opc(j)) and 20h) = 0 or tx2opc(j) = T2$MODULE then
					goto L9B8D;
				j = j + 1;  
			end;
			curOp = CF$134;
			tx2opc(tx2qp) = CF$134;
	end;
L9B8D:
	call EmitTopItem;
	pc = pc + (b43F8(curOp) and 1fh);
end;
END;
src/plm2h.plm
plm2h: DO;
$include(:f2:plm2h.ipx)

declare b9BA8(2) byte data(12, 13),
	b9BAA(2) byte data(1, 2),
	b9BAC(2) byte data(12, 13),
	b9BAE(2) byte data(1, 2);

Sub$9BB0: procedure public;

	Bsub$9C33: procedure  byte;
		declare (i, j, k) byte;

		i = tx2op1(tx2qp);
		if (b5124(tx2opc(i)) and 0c0h) = 0 then
		do;
			if tx2Auxw(i) > 1 then
				return 0;
			if tx2op3(i) <> 0 then
				bC140(tx2op3(i)) = tx2qp;
		end;
		k = tx2Auxw(tx2qp);
		call Sub$56A0(i, tx2qp);
		tx2Auxw(tx2qp) = k;
		tx2Auxw(i) = tx2Auxw(i) - 1;  
		do j = 0 to 3;
			if bC04E(j) = i then
				bC04E(j) = tx2qp;
		end;
		return true;
	end;


/* Sub$9BB0 */
	bC0B7(0) = tx2op1(tx2qp);
	bC0B7(1) = tx2op2(tx2qp);
	if T2$DOUBLE <= curOp and curOp <= T2$ADDRESSOF then
		call Sub$717B;
	if curOp <= T2$MEMBER then
	do;
		call Sub$7550;
		if curOp = T2$65 then
			if Bsub$9C33 then
				return;
	end;
	if (bC1D2 and 0c0h) = 0 then
	do;
		call Sub$87CB;
		if curOp = T2$MOVE then
			procCallDepth = 0;
	end;
	else if (bC1D2 and 0c0h) = 80h then
		call Sub$994D;
end;



Sub$9D06: procedure public;
	declare (i, j, k) byte, pbyt address, m byte;
	declare byt based pbyt byte;

	if procCallDepth <= 10 then
	do;
		curInfo$p = tx2op3(tx2qp);
		i = GetDataType;
		if i = 3 then
			wAF54(132) = 1;
		else
			wAF54(132) = 0;
		j, m = GetParamCnt;
		pbyt = .b44F7(wAF54(132));
		k = 0;

		do while j > 0;
			call AdvNxtInfo;
			j = j - 1;
			if j < 2 then
			do;
				byt = rol(byt, 4) and 0f0h;
				if GetType = ADDRESS$T then
					byt = byt or  b9BA8(k);
				else
					byt = byt or  b9BAA(k);
				k = 1;
			end;
		end;

		if m = 1 then
			byt = rol(byt, 4) and 0f0h;
		call Sub$9BB0;
		wC1C3 = wB528(procCallDepth);
	end;
	procCallDepth = procCallDepth - 1;  
end;



Sub$9DD7: procedure public;
	declare pb$C2EB address;
	declare byt based pb$C2EB byte;

	Sub$9EAA: procedure(arg1b, arg2b);
		declare arg1b byte, arg2b byte;
		
		byt = rol(byt, 4) and 0f0h;
		if arg1b <> 0 then
			if tx2Aux1b(arg1b) = 0 then
				byt = byt or  b9BAE(arg2b);
			else
				byt = byt or  b9BAC(arg2b);
	end;

	declare i byte;

	if procCallDepth <= 10 then
	do;
		i = tx2op3(tx2qp);
		if tx2opc(i) = T2$VARIABLE then
		do;
			curInfo$p = tx2op1(i);
			if TestInfoFlag(F$AUTOMATIC) then
				wAF54(133) = 3;
			else
				wAF54(133) = 4;
		end;
		else if tx2op3(i) = wB53C(procCallDepth) then
		do;
			wAF54(133) = 5;
			wB528(procCallDepth) = wB528(procCallDepth) - 1;  
		end;
		else
			wAF54(133) = 2;

		pb$C2EB = .b44F7(wAF54(133));
		call Sub$9EAA(tx2op1(tx2qp), 0);
		call Sub$9EAA(tx2op2(tx2qp), 1);
		call Sub$9BB0;
		wC1C3 = wB528(procCallDepth);
	end;
	procCallDepth = procCallDepth - 1;  
end;




Sub$9EF8: procedure public;
	procCallDepth = 1;
	call Sub$9BB0;
	wB53C(procCallDepth) = wC1C3;
end;



Sub$9F14: procedure public;
	if EnterBlk then
		blkCurInfo(blkSP) = wC1CF;
end;


Sub$9F2F: procedure public;
	declare (p, q) address;
	declare memwds based botMem(1) address;
	p, q = blkCurInfo(blkSP);
	if ExitBlk then
	do;
		do while p < wC1CF;
			wC1DC(0) = 14;
			wC1DC(1) = memwds(p);
			call EncodeFragData(CF$DW);
			pc = pc + 2;
			p = p + 1;  
		end;
		if wC1CF = q then
		do;
			call Tx2SyntaxError(ERR201);	/*  Invalid DO CASE block, */
						/*  at least on case required */
			call EmitTopItem;
		end;
		wC1CF = q;
	end;
end;



Sub$9F9F: procedure public;
	if ExitBlk then
	do;
		curInfo$p = blkCurInfo(procChainId);
		if not boC1CC then
		do;
			call Sub$5EE8;
			call EncodeFragData(CF$RET);
			pc = pc + 1;  
		end;
		if TestInfoFlag(F$INTERRUPT) then
			wC1C5 = wC1C5 + 8;

		call SetDimension(pc);
		call SetBaseVal(wC1C5 + wC1C7);
		pc = wB488(procChainId := procChainNext(procChainId));
		bC1E6 = 0;
		call PutTx1Byte(0a4h);
		call PutTx1Word(blkCurInfo(procChainId) - botInfo);
		call PutTx1Word(pc);
		call WrFragData;
		wC1C3 = wB4B0(procChainId);
		wC1C5 = wB4D8(procChainId);
		wC1C7 = 0;
		curExtProcId = extProcId(procChainId);
	end;
end;

Sub$A072: procedure(arg1b) public;
	declare arg1b byte;
	declare p address;
	curInfo$p = tx2op1(tx2qp) + botInfo;
	p = GetDimension - arg1b;
	if p < 100h then
		call Sub$5F4B(p, 0, 0, 8);
	else
		call Sub$5F4B(p, 0, 1, 8);
end;


Sub$A0C4: procedure public;
	declare p address;
	p = Sub$575E(tx2op1(tx2qp) + botInfo);
	if p < 100h then
		call Sub$5F4B(p, 0, 0, 8);
	else
		call Sub$5F4B(p, 0, 1, 8);
end;

Sub$A10A: procedure public;
	procCallDepth = procCallDepth + 1;
	if procCallDepth <= 10 then
	do;
		call Sub$5E66(0fh);
		wB528(procCallDepth) = wC1C3;
		wB53C(procCallDepth) = wC1C3;
	end;
	else if procCallDepth = 11 then
	do;
		call Tx2SyntaxError(ERR203);	/*  LIMIT EXCEEDED: NESTING OF TYPED */
					/*  PROCEDURE CALLS */
		call EmitTopItem;
	end;
end;




Sub$A153: procedure public;
	Sub$A266: procedure;
		declare i byte;

		boC1CD = 0;
		do i = 0 to 3;
			bC045(i) = 0ch;
			bC04E(i) = 0;
			boC057(i) = 0;
		end;
	end;

/* Sub$A153 */
	call Sub$A266;
	do tx2qp = 4 to bC1BF - 1;
		curOp = tx2opc(tx2qp);
		bC1D2 = b5124(curOp);
		do case shr(bC1D2, 6);
			do;
				if curOp = T2$CALL then
					call Sub$9D06;
				else if curOp = T2$CALLVAR then
					call Sub$9DD7;
				else if curOp = T2$BEGMOVE then
					call Sub$9EF8;
				else
					call Sub$9BB0;
			end;
			do;
				if curOp = T2$LENGTH then
					call Sub$A072(0);
				else if curOp = T2$LAST then
					call Sub$A072(1);
				else if curOp = T2$SIZE then
					call Sub$A0C4;
			end;
			do;
				if curOp = T2$PROCEDURE then
					call Sub$9457;
				else
					call Sub$994D;
			end;
			do;
				if curOp = T2$CASE then
					call Sub$9F14;
				else if curOp = T2$ENDCASE then
					call Sub$9F2F;
				else if curOp = T2$ENDPROC then
					call Sub$9F9F;
				else if curOp = T2$BEGCALL then
					call Sub$A10A;
			end;
		end;

		tx2op3(tx2qp) = 0;
	end;
	call Sub$5795(0);
	boC1CC = boC1CD;
end;




END;
src/plm3a.plm
plm3a: DO;
/* as this defines the record sizes so override the VALx$SIZE literals */

declare	VAL2$SIZE	literally	'51',
	VAL6$SIZE	literally	'300',
	VAL12$SIZE	literally	'1021',
	VAL16$SIZE	literally	'301',
	VAL18$SIZE	literally	'300',
	VAL20$SIZE	literally	'150',
	VAL22$SIZE	literally	'151',
	VAL24$SIZE	literally	'151';



$include(:f2:plm3a.ipx)

declare b42A8(*) byte public data(
	2, 2, 3, 4, 3, 4, 2, 2, 3, 4, 2, 3, 2, 3, 3, 3,
	3, 2, 2, 3, 4, 2, 3, 2, 3, 2, 2, 2, 2, 3, 2, 2,
	2, 3, 2, 3, 2, 2, 3, 2, 2, 1, 2, 2, 3, 4);

declare b42D6(*) byte public data(
	0, 2, 4, 7, 0Bh, 0Eh, 12h, 14h,
	16h, 19h, 1Dh, 1Fh, 22h, 24h, 27h, 2Ah,
	2Dh, 30h, 32h, 34h, 37h, 3Bh, 3Dh, 40h,
	42h, 45h, 47h, 49h, 4Bh, 4Dh, 50h, 52h,
	54h, 56h, 59h, 5Bh, 5Eh, 60h, 62h, 65h,
	67h, 69h, 6Ah, 6Ch, 6Eh, 71h);

declare b4304(*) byte data(
    24h, 24h, 24h, 24h, 13h, 13h, 18h, 18h,
    18h, 18h, 16h, 2Ch, 15h, 1Fh, 1Fh, 20h,
    20h, 19h, 19h, 19h, 19h, 8, 8, 9,
    9, 6, 7, 25h, 25h, 25h, 25h, 25h,
    0Ah, 0Ah, 0Bh, 0Bh, 14h, 14h, 14h, 14h,
    14h, 39h, 1Ah, 1Ah, 1Ah, 1Ah);

declare b4813(*) byte public data(
	3, 7, 3, 7, 2, 3, 8, 1, 3, 1, 8, 2, 3, 8, 1, 3,
	1, 8, 3, 7, 3, 7, 2, 3, 8, 1, 3, 1, 8, 2, 1Dh, 3,
	1, 7, 2, 12h, 2, 1, 0Ah, 2, 1, 8, 2, 1, 8, 2, 1, 7,
	3, 7, 3, 7, 2, 3, 8, 1, 3, 1, 8, 1, 6, 3, 1, 0Bh,
	1, 6, 3, 1, 0Bh, 1, 6, 1, 6, 3, 7, 3, 7, 2, 3, 8,
	3, 8, 3, 9, 1, 6, 3, 1, 6, 1, 7, 3, 1, 0Ch, 3, 7,
	3, 7, 2, 3, 8, 3, 8, 3, 9, 0Ch, 3, 7, 3, 7, 2, 3,
	8, 1, 3, 1, 8);



declare (tx1Buf, nmsBuf,  atBuf, objBuf) (1280) byte public,
	w7197 address public,
	b7199 byte public,
	rec2 REC2$ST public initial(2, 0),
	rec18 REC18$ST public initial(18h, 0),
	rec16$1 REC16$ST public initial(16h, 0, 0),
	rec16$2 REC16$ST public initial(16h, 0, 1),
	rec16$3 REC16$ST public initial(16h, 0, 2),
	rec16$4 REC16$ST public initial(16h, 0, 4),
	rec12 REC12$ST public initial(12h, 0, 1),
	rec6 REC6$ST public initial(6, 0, 0),
	rec22 REC22$ST public initial(22h, 0, 3),
	rec24$1 REC24$ST public initial(24h, 0, 1, 3),
	rec24$2 REC24$ST public initial(24h, 0, 2, 3),
	rec24$3 REC24$ST public initial(24h, 0, 4, 3),
	rec20 REC20$ST public initial(20h, 0, 3);

$list

Sub$4889: procedure public;
	call WriteRec(.rec6, 3);
	call WriteRec(.rec22, 1);
	call WriteRec(.rec24$1, 2);
	call WriteRec(.rec24$2, 2);
	call WriteRec(.rec24$3, 2);
	call WriteRec(.rec20, 1);
end;



Sub$48BA: procedure(arg1w, arg2b, arg3b, arg4b$p) public;
	declare arg1w address, (arg2b, arg3b) byte, arg4b$p address;
	declare i byte;
	declare arg4b based arg4b$p(1) byte;

	call RecAddByte(arg1w, arg2b, arg3b);
	i = 0;
	do while i <> arg3b;
		call RecAddByte(arg1w, arg2b, arg4b(i));
		i = i + 1;
	end;
end;




Sub$4908: procedure(arg1w$p, arg2w, arg3b) public;
	declare arg1w$p address, arg2w address, arg3b byte;
	declare arg1w based arg1w$p address;

	arg1w$p = arg1w$p + 1;
	if arg1w + arg3b >= arg2w then
	do;
		call Sub$4889;
		rec6.addr = w7197;
	end;
end;




Sub$4938: procedure address public;
	declare (p, q) address;
	q = 0;
	do p = 1 to procCnt;
		curInfo$p = procInfo(p) + botInfo;
		if q < GetBaseVal then
			q = GetBaseVal;
	end;
	return q;
end;




Sub$4984: procedure address public;
	declare i byte;

	i = GetType - 2;
	if i > 2 then
		return 0;
	do case i;
		return 1;	/* BYTE$T */
		return 2;	/* ADDRESS$T */
		return GetParentOffset;	/* STRUCT$T */
	end;
end;


Sub$49BC: procedure(arg1w, arg2w, arg3w) public;
	declare (arg1w, arg2w, arg3w) address;

	if b7199 then
	do; 
		call fwrite(.tx1File, .(0a3h), 1);
		call fwrite(.tx1File, .arg1w, 6);
	end;
	else
		programErrCnt = programErrCnt + 1;
end;



Sub$49F9: procedure public;
	declare atFData STRUCTURE(type byte, info$p address, stmtNum address,
		atVarInfoOffset address, atVarArrayIndex address, atNestedArrayIndex address,
		atVal address), dat(255) byte;
	

	Sub$4A31: procedure;
		declare (w8115, w8117, w8119, w811B) address,
			b811D byte, w811E address;

		Sub$4B6C: procedure;
			if curInfo$p = 0 or not TestInfoFlag(F$MEMBER) then
			do;
				if w8119 > 1 then
				do;
					w8119 = w8119 - 1;
					curInfo$p = atFData.info$p;
				end;
				else if curInfo$p = 0 then
				do;
					b811D = 0;
					return;
				end;
				else
				do;
					if not TestInfoFlag(F$PACKED) then
						b811D = 0;
					if GetType  = STRUCT$T then
					do;
						if TestInfoFlag(F$ARRAY) then
							w8119 = GetDimension;
						call AdvNxtInfo;
						atFData.info$p = curInfo$p;
					end;
				end;
			end;
			if TestInfoFlag(F$ARRAY) then
				w811B = GetDimension;
		end;

		Sub$4BF4: procedure;
			if not b811D or w8117 >= w8115 then
			do;
				call fread(.atFile, .atFData.type, 1);
				do case atFData.type - 2;
					call fread(.atFile, .atFData.atVal, 2); /* ATI$2 */
					do;		/* ATI$STRING */
						call fread(.atFile, .w8115, 2);
						call fread(.atFile, .dat, w8115);
						w8117 = 0;
					end;
					call fread(.atFile, .atFData.atVarInfoOffset, 8); /* ATI$DATA */
					;		/* ATI$END */
				end;
			end;
		end;



		Sub$4C7A: procedure;
			Sub$4CAC: procedure;
				if GetType = BYTE$T then
				do;
					call Sub$4908(.rec6, 12ch, 1);
					call RecAddByte(.rec6, 3, atFData.atVal);
					w7197 = w7197 + 1;
				end;
				else
				do;
					call Sub$4908(.rec6, 12Ch, 2);
					call RecAddWord(.rec6, 3, atFData.atVal);
					w7197 = w7197 + 2;
				end;
			end;

			Sub$4CF9: procedure;
				call Sub$49BC(0d2h, curInfo$p - botInfo, atFData.stmtNum);
				call Sub$4CAC;
			end;

			Sub$4D13: procedure;
				declare w8120 address, bytpr based w8120(2) byte; 

				if GetType = BYTE$T then
				do;
					atFData.atVal = dat(w8117);
					w8117 = w8117 + 1;
				end;
				else
				do;
						w8120 = .atFData.atVal;
						bytpr(1) = dat(w8117);
						w8117 = w8117 + 1;
						if w8117 < w8115 then
						do;
							bytpr(0) = dat(w8117);
							w8117 = w8117 + 1;
						end;
						else
						do;
								bytpr(0) = bytpr(1);
								bytpr(1) = 0;
						end;
				end;
				call Sub$4CAC;
			end;



			Sub$4D85: procedure;
				if atFData.atVal > 255 and GetType = BYTE$T then
					call Sub$4CF9;
				else
					call Sub$4CAC;
			end;

			Sub$4DA8: procedure;
				declare i byte, (p, q) address, j byte;

				if atFData.atVarInfoOffset = 0 then
					call Sub$4D85;
				else if GetType = BYTE$T then
					call Sub$4CF9;
				else
				do;
					p = curInfo$p;
					curInfo$p = botInfo + atFData.atVarInfoOffset;
					if TestInfoFlag(F$MEMBER) then
					do;
						atFData.atVal = atFData.atVal + Sub$4984 * atFData.atNestedArrayIndex + GetLinkVal;
						curInfo$p = GetParentOffset;
					end;

					atFData.atVal = atFData.atVal + Sub$4984 * atFData.atVarArrayIndex + GetLinkVal;
					if TestInfoFlag(F$EXTERNAL) then
					do;
						i = GetExternId;
						curInfo$p = p;
						call Sub$4908(.rec20, 95h, 4);
						call Sub$4CAC;
						call RecAddWord(.rec20, 1, i);
						call RecAddWord(.rec20, 1, w7197 - 2);
					end;
					else if TestInfoFlag(F$ABSOLUTE) then
					do;
						curInfo$p = p;
						call Sub$4CAC;
					end;
					else
					do;
						if GetType = PROC$T or GetType = LABEL$T or TestInfoFlag(F$DATA) then
						do;
							q = .rec24$1;
							i = 1;
						end;
						else if TestInfoFlag(F$MEMORY) then
						do;
							q = .rec24$3;
							i = 4;
						end;
						else
						do;
							q = .rec24$2;
							i = 2;
						end;

						if i = rec6.seg then
						do;
							q = .rec22;
							j = 1;
						end;
						else
							j = 2;

						curInfo$p = p;
						call Sub$4908(q, 95h, 2);
						call Sub$4CAC;
						call RecAddWord(q, j, w7197 - 2);
					end;
				end;
			end Sub$4DA8;

	/* Sub$4C7A */	if b811D then
			do;
				do case atFData.type - 2;
					call Sub$4D85;	/* ATI$2 */
					call Sub$4D13;	/* ATI$STRING */
					call Sub$4DA8;	/* ATI$DATA */
				end;
			end;
		end;

	/* Sub$4A31 */
		call fread(.atFile, .atFData.info$p, 4);
		curInfo$p = (w811E := atFData.info$p) + botInfo;
		w8119,  w811B, w8115, w8117 = 0;
		if TestInfoFlag(F$DATA) then
			rec6.seg = 1;
		else if TestInfoFlag(F$MEMORY) then
			rec6.seg = 4;
		else if TestInfoFlag(F$ABSOLUTE) then
			rec6.seg = 0;
		else
			rec6.seg = 2;

		rec6.addr = GetLinkVal;
		w7197 = rec6.addr;
		if curInfo$p = botInfo then
			b811D = 0;
		else if TestInfoFlag(F$EXTERNAL) then
		do;
			call Sub$49BC(0d9h, w811E, atFData.stmtNum);
			b811D = 0;
		end;
		else
		do;
			call Sub$4B6C;
			b811D = 0ffh;
		end;

		call Sub$4BF4;
		if atFData.type = ATI$END then
		do;
			call Sub$4889;
			return;
		end;

		do while 1;
			call Sub$4C7A;
			call Sub$4BF4;
			if atFData.type = ATI$END then
			do; 
				call Sub$4889;
				return;
			end;
			else if b811D then
			do;
				if w811B > 1 then
					w811B = w811B - 1;
				else
				do;
					call AdvNxtInfo;
					do while curInfo$p <> 0;
						if BYTE$T <= GetType and GetType <= STRUCT$T then
							goto break;
						call AdvNxtInfo;
					end;
				break:
					call Sub$4B6C;
					if not b811D then
						call Sub$49BC(0d1h, w811E, atFData.stmtNum);
				end;
			end;
		end;
	end;

	do while 1;
		call fread(.atFile, .atFData.type, 1);
		if atFData.type = ATI$AHDR then
			call fread(.atFile, .atFData.info$p, 12);
		else if atFData.type = ATI$DHDR then
			call Sub$4A31;
		else
			return;
	end;
end;
END;
src/plm3b.plm
plm3b: do;
$include(:f2:plm3b.ipx)

WriteRec: procedure(rec$p, arg2b) public;
	declare rec$p address, arg2b byte;
	declare (p, len$p) address, crc byte, cnt address;
	declare len based len$p address;
	declare brec based rec$p(1) byte;

	len$p = rec$p + 1;
	if len > 0 and OBJECT then
	do;
			crc = 0;
			p = 0;
			len = len + arg2b + 1;
			cnt = len + 2;
			do while p < cnt;
				crc = crc - brec(p);
				p = p + 1;
			end;
			brec(cnt) = crc;	/* insert checksum */
			call fwrite(.objFile, rec$p, cnt + 1);
	end;
	len = 0;
end;



RecAddByte: procedure(rec$p, arg2b, arg3b) public;
	declare rec$p address, (arg2b, arg3b) byte;
	declare len$p address, len based len$p address;
	declare rec based rec$p structure(type byte, len address, val(1) byte);

	len$p = .rec.len;
	rec.val(len + arg2b) = arg3b;
	len = len + 1;
end;



RecAddWord: procedure(arg1w, arg2b, arg3w) public;
	declare arg1w address, arg2b byte, arg3w address;

	call RecAddByte(arg1w, arg2b, low(arg3w));
	call RecAddByte(arg1w, arg2b, high(arg3w));
end;
end;
src/plm4a.plm
plm4a: DO;
$include(:f2:plm4a.ipx)

declare b42A8(*) byte public data(
	2, 2, 3, 4, 3, 4, 2, 2, 
	3, 4, 2, 3, 2, 3, 3, 3, 
	3, 2, 2, 3, 4, 2, 3, 2, 
	3, 2, 2, 2, 2, 3, 2, 2, 
	2, 3, 2, 3, 2, 2, 3, 2, 
	2, 1, 2, 2, 3, 4),

	b42D6(*) byte public data(
	  0,  2,  4,  7,0Bh,0Eh,12h,14h,
	16h,19h,1Dh,1Fh,22h,24h,27h,2Ah,
	2Dh,30h,32h,34h,37h,3Bh,3Dh,40h,
	42h,45h,47h,49h,4Bh,4Dh,50h,52h,
	54h,56h,59h,5Bh,5Eh,60h,62h,65h,
	67h,69h,6Ah,6Ch,6Eh,71h),

	b4304(*) byte public data(
	24h,24h,24h,24h,13h,13h,18h,18h,
	18h,18h,16h,2Ch,15h,1Fh,1Fh,20h,
	20h,19h,19h,19h,19h,   8,   8,   9,
	   9,   6,   7,25h,25h,25h,25h,25h,
	 0Ah, 0Ah, 0Bh, 0Bh,14h,14h,14h,14h,
	14h,39h,1Ah,1Ah,1Ah,1Ah),

	b4029(*) byte public data(
	   0,   0,   0,   0,26h,30h,30h,26h,
	30h,20h,30h,12h,12h,12h,   0,10h,
	10h,10h,10h,10h,10h,60h,   0,26h,
	20h,20h,   0,   0,   0,   0,   0,   0,
	10h,80h,80h,80h,90h,90h,40h,0A0h,
	0A0h,0A0h,80h,0B0h,90h,80h,0B0h,90h,
	80h,0B0h,90h,80h,0B0h,90h,80h,0B0h,
	90h,20h,30h,30h,30h,10h,10h,70h,
	70h,30h,30h,30h,30h,80h,80h,80h,
	80h,80h,80h,80h,80h,   0,   0,   0,
	   0,   0,   0,   0,   0,   0,   0,   0,
	20h,20h,   0,   0,20h,   0,   0,2Ch,
	40h,   0,10h,10h,60h,20h,   0,   0,
	0A0h,0A0h,0A0h,0A0h,32h,16h,10h,20h,
	   0,10h,10h,10h,10h,10h,60h,   0,
	   0,   0,   0,   0,   0,   0,   0,   0,
	   0,   0,   0,   0,   0,   0,   0,70h,
	60h,60h,70h,50h,70h,60h,60h,0E0h,
	   0,   0,   0,   0,   0,   0,   0,   0,
	   0,   0,   0,   0,   0,   0,   0,   0,
	   0,   0,   0,   0,   0,   0,80h,80h,
	80h,80h,80h,80h,   0,   0,80h,80h,
	80h,80h,80h,80h,80h,80h,80h,80h,
	80h,80h,80h,80h,80h,80h,80h,80h,
	80h,80h,80h,80h,80h,80h,80h,80h,
	80h,80h,80h,80h,80h,80h,80h,80h,
	80h,80h,80h,80h,80h,80h,80h,80h,
	80h,80h,80h,80h,80h,80h,80h,80h,
	80h,80h,80h,80h,80h,80h,80h,80h,
	80h,80h,80h,80h,80h,80h,80h,80h,
	80h,80h,80h,80h,80h,80h,80h,80h,
	80h,80h,80h,80h,80h,80h,80h),

	b4128(*) byte public data(
	0, 0, 1, 1, 2, 2, 3, 3,
	4, 4, 5, 5, 6, 6, 7, 7,
	8, 9, 0Ah),

	b413B(*) byte public data(
	   0,   2,   4,   6,   8, 0Ah, 0Ch,10h,
	11h, 0Eh,12h,   0,   2,   4,   6,   8,
	 0Ah, 0Ch,10h,11h, 0Eh,12h,   0,   2,
	   4,   6,   8, 0Ah, 0Ch,10h,11h, 0Eh,
	12h,   0,   2,   4,   6,   8, 0Ah, 0Ch,
	10h,11h, 0Eh,12h,   0,   2,   4,   6,
	   8, 0Ah, 0Ch,10h,11h, 0Eh,12h, 0Ch,
	11h,12h, 0Ch,11h,12h,   2,   6,   0,
	   4,   6,   8, 0Ah, 0Ch, 0Eh,10h,11h,
	12h, 0Dh, 0Fh,   7,   9, 0Bh,   1,   5,
	   3),

	b418C(*) byte public data(	/* 11 byte entries */
	90h,91h,94h,95h,98h,99h,9Ah,9Ch,0A0h,0A1h,9Dh,
	6Ch,6Dh,70h,71h,74h,75h,76h,78h,7Ch,7Dh,79h,
	   0,   0,   0,   0,   0,   0,64h,65h,   0,   0,   0,
	   0,   0,   0,   0,   0,   0,68h,69h,   0,   0,   0,
	   0,58h,   0,   0,59h,5Ah,54h,55h,   0,   0,   0,
	   0,60h,   0,   0,61h,62h,5Ch,5Dh,   0,   0,   0,
	   0,84h,   0,   0,85h,86h,80h,81h,   0,   0,   0,
	   0,8Ch,   0,   0,8Dh,8Eh,88h,89h,   0,   0,   0,
	   0,   0,   0,   0,10h,11h,12h,14h,15h,16h,17h,
	   0,   1,   4,   5,   8,   9, 0Ah, 0Ch, 0Dh, 0Eh, 0Fh,
	   0,30h,   0,31h,   0,   0,   0,   0,   0,   0,   0,
	   0,28h,   0,29h,   0,   0,   0,   0,   0,   0,   0,
	18h,19h,1Ch,1Dh,20h,21h,22h,24h,25h,26h,27h,
	44h,45h,48h,49h,4Ch,4Dh,4Eh,50h,51h,52h,53h,
	0A8h,0A9h,0ACh,0ADh,0B0h,0B1h,0B2h,0B4h,0B5h,0B6h,0B7h,
	34h,36h,35h,38h,39h,3Ah,   0,   0,   0,   0,   0,
	3Ch,3Dh,3Eh,40h,41h,42h,   0,   0,   0,   0,   0,
	   0,2Ch,   0,   0,2Dh,2Eh,   0,   0,   0,   0,   0,
	0A4h,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0),

	b425D(*) byte public data(
	   8,1Ch, 0Ch,   0, 0Bh,11h,   1, 0Ah,
	 0Fh,10h, 0Dh,   9,   2,   3,   4,   5,
	   6,   7,   0,1Eh,12h,0Eh),

	b4273(*) byte public data(
	   3,   3,   3,   3,   3,   3, 0Ch, 0Dh,
	 0Eh, 0Fh,10h,11h,   0,   0,   0,   0,
	   0,   0,   0,   0,12h,   7,   4,   4,
	   2, 0Ah,15h,   0,   0,   0,   0,   8,
	   9,   0,   0,   0, 0Bh,   6,12h,12h,
	12h,12h,12h,12h,   5,   1,   1,   1,
	13h,13h,13h,   1,   1,   1,13h,13h,
	13h,14h,   0,   0,   0,   0,   0,   0,
	   0,   0,   0,   0,   0,   0,   0,   0,
	   0,   0,   0,   1,   1, 0Ch, 0Ch, 0Ch,
	 0Ch, 0Ch, 0Ch, 0Ch, 0Ch, 0Dh, 0Dh, 0Dh,
	 0Dh, 0Dh, 0Dh, 0Dh, 0Dh,   0, 0Eh, 0Eh,
	 0Eh, 0Eh, 0Fh, 0Fh, 0Fh, 0Fh,   0, 0Fh,
	 0Fh, 0Fh, 0Fh, 0Eh, 0Eh, 0Eh, 0Eh,   0,
	10h,10h,10h,10h,10h,   0,   0,   0,
	   0,   0,   0,   0,   0,   0,   0,   0,
	   1,   1,   0,   0,   0,0),

	b4602(*) byte public data(
	0A7h,0A7h,0A7h,0A7h,0A7h,0A7h,0A7h,0A7h,
	0A7h,0A7h,0A7h,0A8h,0A8h,0A8h,0A8h,0A8h,
	0A8h,0A8h,0A8h,0A8h,0A8h,0A8h,0A9h,0A9h,
	0A9h,0A9h,0A9h,0A9h,0A9h,0A9h,0A9h,0A9h,
	0A9h,0AAh,0AAh,0AAh,0AAh,0AAh,0AAh,0AAh,
	0AAh,0AAh,0AAh,0AAh,0ABh,0ABh,0ABh,0ABh,
	0ABh,0ABh,0ABh,0ABh,0ABh,0ABh,0ABh,0A6h,
	0A6h,0A6h,0A6h,0A6h,0A6h,0A6h,0A6h,0A6h,
	0A6h,0A6h,0A6h,0A6h,0A6h,0A6h,0A6h,0A6h,
	0A6h,0A6h,0A6h,0A6h,0A6h,0A6h,0A6h,0A6h,
	0A6h),

	opcodes(*) byte public data(
	3, 'SUB', 3, 'SBB', 3, 'RLC', 3, 'RRC',
	3, 'RAL', 3, 'RAR', 3, 'SHL', 3, 'SHR',
	3, 'ADD', 3, 'ADC', 3, 'MUL', 3, 'DIV',
	3, 'ANA', 3, 'ORA', 3, 'XRA', 3, 'NEG',
	3, 'NOT', 3, 'M10', 3, 'CPI', 3, 'CMP',
	3, 'SUI', 3, 'SBI', 3, 'ADI', 3, 'ACI',
	3, 'ANI', 3, 'ORI', 3, 'XRI', 3, 'INR',
	3, 'INX', 3, 'DCR', 3, 'DCX', 5, 'ADD', tab, 'A',
	3, 'PSW', 1, 'A', 1, 'B', 1, 'C',
	1, 'D', 1, 'E', 1, 'H', 1, 'L',
	1, 'M', 2, 'AH', 2, 'DH', 2, 'DA',
	2, 'DB', 3, 'DBP', 3, 'DHP', 3, 'PDB',
	3, 'APH', 3, 'DPH', 3, 'PDA', 3, 'PDH',
	2, 'PB', 2, 'PD', 2, 'PH', 3, 'BPH',
	3, 'BBA', 0),

	regNo(*) byte public data(7, 0, 2, 4, 7, 1, 3, 5, 6),
					/* A B D H A C E L M */
	regIdx(*) byte public data(86h,88h,8Ch,90h,86h,8Ah,8Eh,92h,94h),
	stkRegNo(*) byte public data(3, 0, 1, 2),
	stkRegIdx(*) byte public data(82h, 88h, 8Ch, 90h),	/* psw b d h */

	b473D(*) byte public data(
	90h, 98h, 7, 0Fh, 17h, 1Fh, 0, 0, 
	80h, 88h, 0, 0, 0A0h, 0B0h, 0A8h, 0, 
	0, 0, 0, 0FEh, 0B8h, 0D6h, 0DEh, 0C6h, 
	0CEh, 0E6h, 0F6h, 0EEh, 4, 3, 5, 0Bh, 
	87h),

	b475E(*) byte public data(
	9, 1Dh, 0Ch, 1, 0, 0, 1, 0, 
	0, 0, 0Dh, 9, 2, 3, 4, 5, 
	20h, 0, 1, 1Fh, 0, 0Eh),

	b4774(*) byte public data(
	17h, 0, 19h, 13h, 0, 0, 16h, 0, 0, 0, 1Ah, 18h, 3, 
	2, 5, 4, 0, 0, 15h, 0, 0, 1Bh),

	b478A(*) byte public data(
	8, 0, 0Ch, 14h, 0, 0, 1, 0, 
	0, 0, 0Dh, 9, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0Eh),

	b47A0(*) byte public data(
	0,4,8,0Ch,10h,14h,18h,1Ch,
	20h,24h,28h,2Ch,30h,34h,38h,3Ch,
	40h,44h,0CFh,48h,4Ch,50h,54h,58h,
	5Ch,60h,64h,68h,6Ch,70h,74h,78h,
	7Ch),

	w47C1(*) address public data(
	0,0,0,0,1000h,1001h,2002h,1004h,
	1005h,1006h,1007h,2008h,200Ah,100Ch,100Dh,100Eh,
	300Fh,2012h,1014h,3015h,1018h,1019h,101Ah,101Bh,
	101Ch,101Dh,101Eh,101Fh,1022h,2022h,3022h,4022h,
	2020h,1026h,2026h,3026h,1029h,2029h,120Fh,102Ch,
	202Ch,302Ch,102Fh,1030h,1031h,2032h,2034h,2036h,
	3038h,303Bh,303Eh,3041h,3044h,3047h,304Ah,304Dh,
	3050h,1053h,2054h,1056h,1057h,3058h,305Bh,105Eh,
	105Eh,405Fh,7063h,906Ah,0D073h,1083h,2083h,3083h,
	4083h,5083h,4080h,3081h,2082h,4088h,308Ch,208Fh,
	2091h,3093h,4096h,509Ah,509Fh,40A4h,30A8h,20ABh,
	20AEh,10ADh,10B0h,20B1h,20B3h,20B5h,10B7h,80B8h,
	10C0h,10FCh,10C1h,10C2h,20C3h,10C5h,80C6h,0A0CEh,
	102Ch,202Ch,102Ch,202Ch,220Dh,1210h,1211h,2212h,
	1022h,1214h,1215h,1216h,1217h,1218h,2219h,0,
	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,10D8h,
	0,0,0,10D9h,10DAh,10DAh,10DBh,10DCh,
	30DDh,30E0h,30E3h,10E6h,10E7h,10E8h,20E9h,0,
	0,10EBh,0,0,0,0,0,0,
	0,0,0,0,0,0,10ECh,20EDh,
	40EFh,40F3h,20F7h,30F9h),

	w4919(*) address public data(
	134h,137h,13Fh,142h,14Ah,14Dh,151h,15Ah,
	15Ch,15Fh,161h,14Ah,14Dh,151h,15Ah,15Ch,
	15Fh,161h,134h,137h,13Fh,142h,14Ah,14Dh,
	151h,15Ah,15Ch,15Fh,161h,11Ah,11Dh,0FDh,
	101h,103h,10Bh,10Eh,1F6h,1F9h,1FBh,1E9h,
	1ECh,1EEh,1DBh,1DEh,1E0h,1CEh,1D1h,1D3h,
	134h,137h,13Fh,142h,14Ah,14Dh,151h,15Ah,
	15Ch,15Fh,161h,183h,185h,1AEh,1B2h,1B4h,
	183h,185h,1BEh,1C2h,1C4h,183h,185h,183h,
	185h,134h,137h,13Fh,142h,14Ah,14Dh,151h,
	177h,17Ah,16Ah,16Dh,183h,185h,192h,196h,
	198h,18Ah,18Ch,19Dh,1A1h,1A3h,134h,137h,
	13Fh,142h,14Ah,14Dh,151h,177h,17Ah,16Ah,
	16Dh,205h,134h,137h,13Fh,142h,14Ah,14Dh,
	151h,15Ah,15Ch,15Fh,161h),

	b4A03(*) byte public data(
	0Bh, 8, 0Bh, 8, 10h, 0Dh, 9, 10h, 
	0Eh, 0Bh, 9, 10h, 0Dh, 9, 10h, 0Eh, 
	0Bh, 9, 0Bh, 8, 0Bh, 8, 10h, 0Dh, 
	9, 10h, 0Eh, 0Bh, 9, 1Ah, 17h, 0Eh, 
	0Ah, 8, 0Fh, 0Ch, 0Fh, 0Ch, 0Ah, 0Dh, 
	0Ah, 8, 0Eh, 0Bh, 9, 0Dh, 0Ah, 8, 
	0Bh, 8, 0Bh, 8, 10h, 0Dh, 9, 10h, 
	0Eh, 0Bh, 9, 7, 5, 10h, 0Ch, 0Ah, 
	7, 5, 10h, 0Ch, 0Ah, 7, 5, 7, 
	5, 0Bh, 8, 0Bh, 8, 10h, 0Dh, 9, 
	0Ch, 9, 0Dh, 0Ah, 7, 5, 0Bh, 7, 
	5, 8, 6, 11h, 0Dh, 0Bh, 0Bh, 8, 
	0Bh, 8, 10h, 0Dh, 9, 0Ch, 9, 0Dh, 
	0Ah, 8, 0Bh, 8, 0Bh, 8, 10h, 0Dh, 
	9, 10h, 0Eh, 0Bh, 9),

	b4A78(*) byte public data(
/* 0000 */ 8Dh, tab, 'ADC', tab, 'L', 80h,
/* 0008 */ 0C6h, tab, 'ADI', tab, 84h, 0FFh, 80h,
/* 0011 */ 0E6h, tab, 'ANI', tab, 84h, 01h, 80h,
/* 001A */ 0E6h, tab, 'ANI', tab, 84h, 03h, 80h,
/* 0023 */ 0E6h, tab, 'ANI', tab, 84h, 07h, 80h,
/* 002C */ 0E6h, tab, 'ANI', tab, 84h, 80h,
/* 0034 */ 80h, 0E6h, tab, 'ANI', tab, 84h, 0c0h, 80h,
/* 003E */ 0E6h, tab, 'ANI', tab, 84h, 0E0h, 80h,
/* 0047 */ 0E6h, tab, 'ANI', tab, 84h, 0F8h, 80h,
/* 0050 */ 0E6h, tab, 'ANI', tab, 84h, 0FCh, 80h,
/* 0059 */ 0E6h, tab, 'ANI', tab, 84h, 0FEh, 80h,
/* 0062 */ 0E6h, tab, 'ANI', tab, 84h, 0F0h, 80h,
/* 006B */ 0CDh, tab, 'CALL', tab, 82h, 80h,
/* 0074 */ 0CDh, tab, 'CALL', tab, 83h, ' ', 80h,
/* 007E */ 0CDh, tab, 'CALL', tab, 93h, '     ', 80h,
/* 008C */ 2Fh, tab, 'CMA', 80h,
/* 0092 */ 27h, tab, 'DAA', 80h,
/* 0098 */ 09h, tab, 'DAD', tab, 'B', 80h,
/* 00A0 */ 29h, tab, 'DAD', tab, 'H', 80h,
/* 00A8 */ 09h, tab, 'DAD', tab, 0C0h, 80h,
/* 00B0 */ 39h, tab, 'DAD', tab, 'SP', 80h,
/* 00B9 */ 3Dh, tab, 'DCR', tab, 'A', 80h,
/* 00C1 */ 0Dh, tab, 'DCR', tab, 'C', 80h,
/* 00C9 */ 1Bh, tab, 'DCX', tab, 'D', 80h,
/* 00D1 */ 2Bh, tab, 'DCX', tab, 'H', 80h,
/* 00D9 */ 0F3h, tab, 'DI', 80h,
/* 00DE */ 00h, tab, 'DW', tab, 82h, 80h,
/* 00E5 */ 0FBh, tab, 'EI', 80h,
/* 00EA */ 00h, 089h, 'AH:', 80h,
/* 00F0 */ 00h, 089h, 'APH:', 80h,
/* 00F7 */ 00h, 089h, 'B:', 80h,
/* 00FC */ 00h, 089h, 'BBA:', 80h,
/* 0103 */ 00h, 089h, 'BPH:', 80h,
/* 010A */ 00h, 089h, 'D:', 80h,
/* 010F */ 00h, 089h, 'DA:', 80h,
/* 0115 */ 00h, 089h, 'DB:', 80h,
/* 011B */ 00h, 089h, 'DBP:', 80h,
/* 0122 */ 00h, 089h, 'DH:', 80h,
/* 0128 */ 00h, 089h, 'DHP:', 80h,
/* 012F */ 00h, 089h, 'DPH:', 80h,
/* 0136 */ 00h, 089h, 'H:', 80h,
/* 013B */ 00h, 089h, 'PB:', 80h,
/* 0141 */ 00h, 089h, 'PD:', 80h,
/* 0147 */ 00h, 089h, 'PDA:', 80h,
/* 014E */ 00h, 089h, 'PDB:', 80h,
/* 0155 */ 00h, 089h, 'PDH:', 80h,
/* 015C */ 00h, 089h, 'PH:', 80h,
/* 0162 */ 76h, tab, 'HLT', 80h,
/* 0168 */ 0DBh, tab, 'IN', tab, 86h, 80h,
/* 016F */ 3Ch, tab, 'INR', tab, 'A', 80h,
/* 0177 */ 13h, tab, 'INX', tab, 'D', 80h,
/* 017F */ 23h, tab, 'INX', tab, 'H', 80h,
/* 0187 */ 0C2h, tab, 'J', 88h, tab, 82h, 80h,
/* 018E */ 0FAh, tab, 'JM', tab, 87h, 04h, 80h,
/* 0196 */ 0C3h, tab, 'JMP', tab, 82h, 80h,
/* 019E */ 0D2h, tab, 'JNC', tab, 82h, 80h,
/* 01A6 */ 0D2h, tab, 'JNC', tab, 87h, 04h, 80h,
/* 01AF */ 0D2h, tab, 'JNC', tab, 87h, 05h, 80h,
/* 01B8 */ 0C2h, tab, 'JNZ', tab, 87h, 0FEh, 80h,
/* 01C1 */ 0C2h, tab, 'JNZ', tab, 87h, 0ECh, 80h,
/* 01CA */ 0C2h, tab, 'JNZ', tab, 87h, 0FDh, 80h,
/* 01D3 */ 0C2h, tab, 'JNZ', tab, 87h, 0F9h, 80h,
/* 01DC */ 0C2h, tab, 'JNZ', tab, 87h, 0F8h, 80h,
/* 01E5 */ 0C2h, tab, 'JNZ', tab, 87h, 0F7h, 80h,
/* 01EE */ 0EAh, tab, 'JPE', tab, 87h, 04h, 80h,
/* 01F7 */ 0CAh, tab, 'JZ', tab, 87h, 04h, 80h,
/* 01FF */ 3Ah, tab, 'LDA', tab, 82h, 80h,
/* 0207 */ 0Ah, tab, 'LDAX', tab, 0C0h, 80h,
/* 0210 */ 2Ah, tab, 'LHLD', tab, 82h, 80h,
/* 0219 */ 21h, tab, 'LXI', tab, 'H,', 82h, tab, 8Ah, 80h,
/* 0225 */ 21h, tab, 'LXI', tab, 'H,', 87h, 0Dh, 80h,
/* 0230 */ 21h, tab, 'LXI', tab, 'H,', 87h, 11h, 80h,
/* 023B */ 21h, tab, 'LXI', tab, 'H,', 87h, 08h, 80h,
/* 0246 */ 21h, tab, 'LXI', tab, 'H,', 87h, tab, 80h,
/* 0251 */ 21h, tab, 'LXI', tab, 'H,', 94h, 00h, 80h,
/* 025C */ 01h, tab, 'LXI', tab, 0C0h, ',', 92h, 80h,
/* 0266 */ 31h, tab, 'LXI', tab, 'SP,', 85h, 80h,
/* 0271 */ 7Ah, tab, 'MOV', tab, 'A,D', 80h,
/* 027B */ 7Bh, tab, 'MOV', tab, 'A,E', 80h,
/* 0285 */ 7Ch, tab, 'MOV', tab, 'A,H', 80h,
/* 028F */ 7Dh, tab, 'MOV', tab, 'A,L', 80h,
/* 0299 */ 78h, tab, 'MOV', tab, 'A,', 0E0h, 80h,
/* 02A3 */ 78h, tab, 'MOV', tab, 'A,', 0E2h, 80h,
/* 02AD */ 7Eh, tab, 'MOV', tab, 'A,M', 80h,
/* 02B7 */ 44h, tab, 'MOV', tab, 'B,H', 80h,
/* 02C1 */ 4Fh, tab, 'MOV', tab, 'C,A', 80h,
/* 02CB */ 4Dh, tab, 'MOV', tab, 'C,L', 80h,
/* 02D5 */ 57h, tab, 'MOV', tab, 'D,A', 80h,
/* 02DF */ 50h, tab, 'MOV', tab, 'D,B', 80h,
/* 02E9 */ 56h, tab, 'MOV', tab, 'D,M', 80h,
/* 02F3 */ 5Fh, tab, 'MOV', tab, 'E,A', 80h,
/* 02FD */ 59h, tab, 'MOV', tab, 'E,C', 80h,
/* 0307 */ 5Eh, tab, 'MOV', tab, 'E,M', 80h,
/* 0311 */ 67h, tab, 'MOV', tab, 'H,A', 80h,
/* 031B */ 66h, tab, 'MOV', tab, 'H,M', 80h,
/* 0325 */ 6Fh, tab, 'MOV', tab, 'L,A', 80h,
/* 032F */ 46h, tab, 'MOV', tab, 0D0h, ',M', 80h,
/* 0339 */ 40h, tab, 'MOV', tab, 0D2h, ',', 0e0h, 80h,
/* 0343 */ 46h, tab, 'MOV', tab, 0D2h, ',M', 80h,
/* 034D */ 40h, tab, 'MOV', tab, 0D0h, ',', 0e1h, 80h,
/* 0357 */ 40h, tab, 'MOV', tab, 0D2h, ',', 0e3h, 80h,
/* 0361 */ 70h, tab, 'MOV', tab, 'M,', 0E0h, 80h,
/* 036B */ 70h, tab, 'MOV', tab, 'M,', 0E2h, 80h,
/* 0375 */ 3Eh, tab, 'MVI', tab, 'A,', 84h, 10h, 80h,
/* 0380 */ 3Eh, tab, 'MVI', tab, 'A,', 84h, 0FFh, 80h,
/* 038B */ 3Eh, tab, 'MVI', tab, 'A,', 84h, 00h, 80h,
/* 0396 */ 06h, tab, 'MVI', tab, 'B,', 84h, 00h, 80h,
/* 03A1 */ 16h, tab, 'MVI', tab, 'D,', 84h, 00h, 80h,
/* 03AC */ 26h, tab, 'MVI', tab, 'H,', 84h, 00h, 80h,
/* 03B7 */ 06h, tab, 'MVI', tab, 0D2h, ',', 96h, 80h,
/* 03C1 */ 06h, tab, 'MVI', tab, 0D0h, ',', 84h, 0, 80h,
/* 03CC */ 36h, tab, 'MVI', tab, 'M,', 84h, 00h, 80h,
/* 03D7 */ 00h, tab, 9Bh, 80h,
/* 03DB */ 00h, tab, 9Bh, tab, 0E5h, 80h,
/* 03E1 */ 00h, tab, 9Bh, tab, 0E7h, 80h,
/* 03E7 */ 00h, tab, 9Bh, tab, 0C0h, 80h,
/* 03ED */ 00h, tab, 9Bh, tab, 0ECh, 80h,
/* 03F3 */ 00h, tab, 0ABh, 80h,
/* 03F7 */ 00h, tab, 0ABh, tab, 86h, 80h,
/* 03FD */ 00h, tab, 0BBh, tab, 0ECh, 80h,
/* 0403 */ 00h, tab, 8Bh, tab, 0E9h, 80h,
/* 0409 */ 00h, tab, 8Bh, tab, 0EBh, 80h,
/* 040F */ 00h, tab, 8Bh, tab, 0ECh, 80h,
/* 0415 */ 00h, tab, 8Bh, tab, 0DCh, 80h,
/* 041B */ 0B7h, tab, 'ORA', tab, 'A', 80h,
/* 0423 */ 0B5h, tab, 'ORA', tab, 'L', 80h,
/* 042B */ 0D3h, tab, 'OUT', tab, 86h, 80h,
/* 0433 */ 0E9h, tab, 'PCHL', 80h,
/* 043A */ 00h, '; PROC', tab, 81h, 80h,
/* 0444 */ 0C1h, tab, 'POP', tab, 'B', 80h,
/* 044C */ 0C1h, tab, 'POP', tab, 0C0h, tab, 8Ah, 80h,
/* 0456 */ 0F1h, tab, 'POP', tab, 'PSW', 80h,
/* 0460 */ 0E5h, tab, 'PUSH', tab, 'H', 80h,
/* 0469 */ 0C5h, tab, 'PUSH', tab, 0C0h, tab, 8Ah, 80h,
/* 0474 */ 0F5h, tab, 'PUSH', tab, 'PSW', 80h,
/* 047F */ 17h, tab, 'RAL', 80h,
/* 0485 */ 1Fh, tab, 'RAR', 80h,
/* 048B */ 0C9h, tab, 'RET', 80h,
/* 0491 */ 9Fh, tab, 'SBB', tab, 'A', 80h,
/* 0499 */ 98h, tab, 'SBB', tab, 'B', 80h,
/* 04A1 */ 9Ch, tab, 'SBB', tab, 'H', 80h,
/* 04A9 */ 9Eh, tab, 'SBB', tab, 'M', 80h,
/* 04B1 */ 22h, tab, 'SHLD', tab, 82h, 80h,
/* 04BA */ 0F9h, tab, 'SPHL', 80h,
/* 04C1 */ 32h, tab, 'STA', tab, 82h, 80h,
/* 04C9 */ 97h, tab, 'SUB', tab, 'A', 80h,
/* 04D1 */ 91h, tab, 'SUB', tab, 'C', 80h,
/* 04D9 */ 95h, tab, 'SUB', tab, 'L', 80h,
/* 04E1 */ 96h, tab, 'SUB', tab, 'M', 80h,
/* 04E9 */ 0D6h, tab, 'SUI', tab, 84h, 01h, 80h,
/* 04F2 */ 0EBh, tab, 'XCHG', 80h,
/* 04F9 */ 0E3h, tab, 'XTHL', tab, tab, 8Ah, 80h,
/* 0503 */ 03h, tab, 'INX', tab, 0C0h, 80h,
/* 050B */ 0Bh, tab, 'DCX', tab, 0C0h, 80h,
/* 0513 */ 69h, tab, 'MOV', tab, 'L,C', 80h,
/* 051D */ 60h, tab, 'MOV', tab, 'H,B', 80h,
/* 0527 */ 4Eh, tab, 'MOV', tab, 'C,M', 80h,
/* 0531 */ 46h, tab, 'MOV', tab, 'B,M', 80h,
/* 053B */ 1Ah, tab, 'LDAX', tab, 'D', 80h,
/* 0544 */ 0Ah, tab, 'LDAX', tab, 'B', 80h,
/* 054D */ 12h, tab, 'STAX', tab, 'D', 80h,
/* 0556 */ 0C2h, tab, 'JNZ', tab, 87h, 0FBh, 80h,
/* 055F */ 06h, tab, 'MVI', tab, 'B,', 84h, 0Ch, 80h,
/* 056A */ 48h, tab, 'MOV', tab, 'C,B', 80h,
/* 0574 */ 0C2h, tab, 'JNZ', tab, 87h, 0FFh, 80h,
/* 057D */ 0C2h, tab, 'JNZ', tab, 87h, 0FAh, 80h,
/* 0586 */ 21h, tab, 'LXI', tab, 'H,', 92h, 80h,
/* 0590 */ 03h, tab, 'INX', tab, 'B', 80h,
/* 0598 */ 78h, tab, 'MOV', tab, 'A,', 0E3h, 80h,
/* 05A2 */ 36h, tab, 'MVI', tab, 'M,', 86h, 80h,
/* 05AC */ 00h, tab, 8Bh, tab, 0D2h, 80h,
/* 05B2 */ 00h, tab, 0BBh, tab, 0E2h, 80h,
/* 05B8 */ 2Dh, tab, 'DCR', tab, 'L', 80h,
/* 05C0 */ 00h, 89h, 80h,
/* 05C3 */ 40h, tab, 'MOV', tab, 0D0h, ',', 0e2h, 80h,
/* 05CD */ 33h, tab, 'INX', tab, 'SP', 80h,
/* 05D6 */ 3Bh, tab, 'DCX', tab, 'SP', 80h,
/* 05DF */ 0DAh, tab, 'JC', tab, 82h, 80h,
/* 05E6 */ 2Ch, tab, 'INR', tab, 'L', 80h,
/* 05EE */ 0C3h, tab, 'JMP', tab, 87h, 07h, 80h),

	w506F(*) address public data(
/*  A4-1 */ 44ch,
/*  A5-1 */ 4f9h,
/*  A6-2 */ 219h, 0b0h,
/*  A7-1 */ 25ch,
/*  A8-1 */ 1ffh,
/*  A9-1 */ 207h,
/*  A10-1 */ 210h,
/*  A11-2 */ 34dh, 357h,
/*  A12-2 */ 357h, 3c1h,
/*  A13-1 */ 357h,
/*  A14-1 */ 4f2h,
/*  A15-1 */ 3c1h,
/*  A16-3 */ 343h, 17fh, 32fh,
/*  A17-2 */ 343h, 3c1h,
/*  A18-1 */ 343h,
/*  A19-3 */ 361h, 0d1h, 36bh,
/*  A20-1 */ 36bh,
/*  A21-1 */ 0deh,
/*  A22-1 */ 4bah,
/*  A23-1 */ 469h,
/*  A24-1 */ 503h,
/*  A25-1 */ 50bh,
/*  A26-1 */ 0d1h,
/*  A27-1 */ 48bh,
/*  A32-2 */ 2a3h, 48bh,
/*  A28-1 A29-2 A30-3 A31-4 A112-1 */ 0a0h, 0a0h, 0a0h, 0a0h,
/*  A33-1 A34-2 A35-3 */ 415h, 415h, 415h,
/*  A36-1 A37-2 */ 5ach, 5ach, 5ach,
/*  A39-1 A40-2 A41-3 A104-1 A105-2 A106-1 A107-2 */ 3e7h, 3e7h, 3e7h,
/*  A42-1 */ 3fdh,
/*  A43-1 */ 3f7h,
/*  A44-1 */ 5b2h,
/*  A45-2 */ 3fdh, 491h,
/*  A46-2 */ 3f7h, 491h,
/*  A47-2 */ 5b2h, 491h,
/*  A48-3 */ 3fdh, 4e9h, 491h,
/*  A49-3 */ 3f7h, 4e9h, 491h,
/*  A50-3 */ 5b2h, 4e9h, 491h,
/*  A51-3 */ 3fdh, 8h, 491h,
/*  A52-3 */ 3f7h, 8h, 491h,
/*  A53-3 */ 5b2h, 8h, 491h,
/*  A54-3 */ 3fdh, 491h, 8ch,
/*  A55-3 */ 3f7h, 491h, 8ch,
/*  A56-3 */ 5b2h, 491h, 8ch,
/*  A57-1 */ 0a8h,
/*  A58-2 */ 210h, 3ach,
/*  A59-1 */ 4b1h,
/*  A60-1 */ 4c1h,
/*  A61-3 */ 36bh, 17fh, 3cch,
/*  A62-3 */ 36bh, 17fh, 361h,
/*  A63-1 A64-1 */ 6bh,
/*  A65-4 */ 23bh, 460h, 210h, 433h,
/*  A66-7 */ 246h, 4f9h, 2adh, 17fh, 31bh, 325h, 433h,
/*  A67-9 */ 225h, 460h, 219h, 0b0h, 2adh, 17fh, 31bh, 325h, 433h,
/*  A68-13 */ 230h, 460h, 219h, 0b0h, 2adh, 17fh, 31bh, 325h, 2adh, 17fh, 31bh, 325h, 433h,
/*  A74-4 */ 3f3h,
/*  A75-3 */ 3f3h,
/*  A76-2 */ 3f3h,
/*  A69-1 A70-2 A71-3 A72-4 A73-5 */ 3d7h, 3d7h, 3d7h, 3d7h, 3d7h,
/*  A77-4 */ 23h, 485h, 485h, 485h,
/*  A78-3 */ 1ah, 485h, 485h,
/*  A79-2 */ 11h, 485h,
/*  A80-2 */ 41bh, 485h,
/*  A81-3 */ 59h, 485h, 485h,
/*  A82-4 */ 50h, 485h, 485h, 485h,
/*  A83-5 */ 47h, 485h, 485h, 485h, 485h,
/*  A84-5 */ 62h, 47fh, 47fh, 47fh, 47fh,
/*  A85-4 */ 3eh, 47fh, 47fh, 47fh,
/*  A86-3 */ 35h, 47fh, 47fh,
/*  A87-2 */ 2ch, 47fh,
/*  A89-1 */ 0a8h,
/*  A88-2 */ 0a8h, 0a8h,
/*  A90-1 */ 8ch,
/*  A91-2 */ 8ch, 16fh,
/*  A92-2 */ 503h, 207h,
/*  A93-2 */ 17fh, 2adh,
/*  A94-1 */ 92h,
/*  A95-8 */ 586h, 0a8h, 0a8h, 307h, 17fh, 2e9h, 4f2h, 433h,
/*  A96-1 */ 42bh,
/*  A98-1 */ 2a3h,
/*  A99-1 */ 299h,
/*  A100-2 */ 485h, 19eh,
/*  A101-1 */ 0a8h,
/*  A102-8 */ 5e6h, 5eeh, 544h, 54dh, 590h, 177h, 5b8h, 556h,
/*  A103-10 */ 17fh, 5eeh, 544h, 54dh, 590h, 177h, 0d1h, 285h, 423h, 1d3h,
/*  A135-1 */ 43ah,
/*  A139-1 */ 168h,
/*  A140-1 A141-1 */ 196h,
/*  A142-1 */ 19eh,
/*  A143-1 */ 187h,
/*  A144-3 */ 380h, 18eh, 4c9h,
/*  A145-3 */ 380h, 1f7h, 4c9h,
/*  A146-3 */ 380h, 1eeh, 4c9h,
/*  A147-1 */ 491h,
/*  A148-1 */ 0d9h,
/*  A149-1 */ 0e5h,
/*  A150-2 */ 0e5h, 162h,
/*  A153-1 */ 266h,
/*  A166-1 */ 74h,
/*  A167-2 */ 74h, 423h,
/*  A168-4 */ 74h, 423h, 4e9h, 491h,
/*  A169-4 */ 74h, 423h, 8h, 491h,
/*  A170-2 */ 74h, 491h,
/*  A171-3 */ 74h, 491h, 8ch,
/*  A97-1 */ 7eh,
/*  B31-14 */ 15ch, 307h, 17fh, 2e9h,
/*  B32-10 */ 10ah, 4f2h,
/*  B33-8 */ 136h, 0a0h, 460h, 0a0h, 0a0h, 444h, 98h, 48bh,
/*  B34-15 */ 122h, 2b7h, 2cbh,
/*  B35-12 */ 115h, 251h, 375h, 0a0h, 4f2h, 0a0h, 4f2h, 1a6h, 98h, 0b9h, 1e5h, 48bh,
/*  B29-26 */ 122h, 2b7h, 2cbh,
/*  B30-23 */ 115h, 251h, 375h, 474h, 0a0h, 4f2h, 4c9h, 0a0h, 4f2h, 0h, 4d1h, 325h,
	      285h, 499h, 311h, 177h, 1afh, 98h, 0c9h, 456h, 0b9h, 1c1h, 48bh,
/*  B0 B18 B48 B73 B94 B106 -11 */ 0eah, 2f3h, 3a1h,
/*  B1 B19 B49 B74 B95 B107 -8 */ 122h, 27bh, 409h, 325h, 271h, 3e1h, 311h, 48bh,
/*  B2 B20 B50 B75 B96 B108 -11 */ 10fh, 2c1h, 396h,
/*  B3 B21 B51 B76 B97 B109 -8 */ 115h, 27bh, 403h, 325h, 271h, 3dbh, 311h, 48bh,
/*  B4 B11 B22 B52 B77 B98 B110 -16 */ 11bh, 513h, 51dh,
/*  B5 B12 B23 B53 B78 B99 B111 -13 */ 128h, 527h, 17fh, 531h,
/*  B6 B13 B24 B54 B79 B100 B112 -9 */ 14eh, 53bh, 403h, 325h, 177h, 53bh, 3dbh, 311h, 48bh,
/*  B7 B14 B25 B55 B113 -16 */ 147h, 4f2h,
/*  B8 B15 B26 B56 B114 -14 */ 0f0h, 2f3h, 3a1h,
/*  B9 B16 B27 B57 B115 -11 */ 12fh, 4f2h,
/*  B10 B17 B28 B58 B116 -9 */ 155h, 53bh, 409h, 325h, 177h, 53bh, 3e1h, 311h, 48bh,
/*  B82 B103 -13 */ 0f0h, 2f3h, 3a1h,
/*  B83 B104 -10 */ 12fh, 27bh, 40fh, 2f3h, 271h, 17fh, 3edh, 2d5h, 4f2h, 48bh,
/*  B80 B101 -12 */ 147h, 325h, 3ach,
/*  B81 B102 -9*/ 155h, 53bh, 409h, 325h, 177h, 53bh, 3e1h, 311h, 48bh,
/*  B59 B64 B69 B71 B84 -7 */ 103h, 2adh,
/*  B60 B65 B70 B72 B85 -5 */ 0fch, 3d7h, 0c1h, 1b8h, 48bh,
/*  B89-8 */ 103h, 2adh,
/*  B90-6 */ 0fch, 41bh, 485h, 0c1h, 1cah, 48bh,
/*  B86-11 */ 15ch, 307h, 17fh, 2e9h,
/*  B87-7 */ 10ah, 4f2h,
/*  B88-5 */ 136h, 0a0h, 0c1h, 1b8h, 48bh,
/*  B91-17 */ 15ch, 307h, 17fh, 2e9h,
/*  B92-13 */ 10ah, 4f2h,
/*  B93-11 */ 136h, 285h, 41bh, 485h, 311h, 28fh, 485h, 325h, 0c1h, 1dch, 48bh,
/*  B61-16 */ 15ch, 307h, 17fh, 2e9h,
/*  B62-12 */ 10ah, 4f2h,
/*  B63-10 */ 136h, 28fh, 47fh, 325h, 285h, 47fh, 311h, 0c1h, 1d3h, 48bh,
/*  B66-16 */ 15ch, 307h, 17fh, 2e9h,
/*  B67-12 */ 10ah, 4f2h,
/*  B68-10 */ 136h, 285h, 485h, 311h, 28fh, 485h, 325h, 0c1h, 1d3h, 48bh,
/*  B45-13 */ 0f7h, 2fdh, 2dfh,
/*  B46-10 */ 10ah, 4f2h,
/*  B47-8 */ 136h, 28fh, 8ch, 325h, 285h, 8ch, 311h, 48bh,
/*  B42-14 */ 13bh, 513h, 51dh,
/*  B43-11 */ 15ch, 4f2h,
/*  B44-9 */ 141h, 53bh, 8ch, 325h, 177h, 53bh, 8ch, 311h, 48bh,
/*  B39-13 */ 0f7h, 2fdh, 2dfh,
/*  B40-10 */ 10ah, 4f2h,
/*  B41-8 */ 136h, 4c9h, 4d9h, 325h, 38bh, 4a1h, 311h, 48bh,
/*  B36-15 */ 13bh, 2fdh, 2dfh,
/*  B37-12 */ 141h, 4f2h,
/*  B38-10 */ 15ch, 4c9h, 4e1h, 2f3h, 38bh, 17fh, 4a9h, 2d5h, 4f2h, 48bh,
/*  B105-8 */ 5c0h, 55fh, 56ah, 0c1h, 574h, 0b9h, 57dh, 48bh,
/*  A108-2 */ 598h, 42bh,
/*  A38-1 */ 5a2h,
/*  A109-1 */ 3b7h,
/*  A110-1 */ 339h,
/*  A111-2 */ 0a0h, 0a8h,
/*  A113-1 */ 5c3h,
/*  A114-1 */ 32fh,
/*  A115-1 */ 361h,
/*  A116-1 */ 5cdh,
/*  A117-1 */ 5d6h,
/*  A118-2 */ 485h, 5dfh
),
	stack$origin(*) byte public data(14, '@STACK$ORIGIN ');

$list

Sub$54BA: procedure public;

	EmitSource: procedure;
		declare p(3) address, (s, t) address;

		call fread(.tx1File, .p, 6);
		if p(1) > 0 or p(2) = 0 then
			s = p(0);
		else
		do;
			s = p(2);
			p(2) = 0;
		end;
		do t = p(0) to s;
			call LinePrefix;
			w812F = t;
			lineNo = p(1);
			depth = p(2);
			call GetSourceLine;
		end;
	end;



	NewStatementNo: procedure;
		call fread(.tx1File, .stmtNo, 2);
		if stmtNo = 0 then
			return;
		if DEBUG then
		do; 
			if rec8.len + 4 >= 1020 then
				call WriteRec(.rec8.type, 1);
			call RecAddWord(.rec8.type, 1, baseAddr);
			call RecAddWord(.rec8.type, 1, stmtNo);
		end;
		if codeOn then
			call EmitStatementNo;
	end;


	AddrCheck: procedure(arg1w);
		declare arg1w address;
		if arg1w <> baseAddr then
			call FatalError(0D8h);
	end;


	EmitLocalLabel: procedure;
		declare localLabels based localLabels$p(1) address;

		call fread(.tx1File, .w96D7, 2);
		locLabStr(1) = '@';
		locLabStr(0) = Num2Asc(w96D7, 0, 10, .locLabStr(2)) + 1;
		call AddrCheck(localLabels(w96D7));
		call EmitLabel;
	end;

	EmitSymLabel: procedure;
		call fread(.tx1File, .curInfo$p, 2);
		curInfo$p = curInfo$p + botInfo;
		curSymbol$p = GetSymbol;
		locLabStr(0) = cursym.name(0);
		call movmem(locLabStr(0), .cursym.name(1), .locLabStr(1));
		call AddrCheck(GetLinkVal);
		call EmitLabel;
	end;

	EmitSimpleError: procedure;
		call fread(.tx1File, .errData, 2);
        errData.info = 0;
        errData.stmt = stmtNo;
		call EmitError;
	end;


	EmitNearError: procedure;
		call fread(.tx1File, .errData, 4);
        errData.stmt = stmtNo;
		call EmitError;
	end;

	EmitFullError: procedure;
		call fread(.tx1File, .errData, 6);
		call EmitError;
	end;

	MiscControl: procedure;
		declare pad byte, fname(19) byte;

		do case cfCode - 9dh;
			listOff = false;
			listOff = true;
			codeOn = PRINT;
			codeOn = false;
			if listing then
				call NewPageNextChLst;
			do;
				call LinePrefix;
				call TellF(.srcFil, .srcFileTable(srcFileIdx + 8));
				call Backup(.srcFileTable(srcFileIdx + 8), offLastCh - offCurCh);
				srcFileIdx = srcFileIdx + 10;
				call fread(.tx1File, .fname(13), 6);
				call fread(.tx1File, .fname(6), 7);
				call fread(.tx1File, .fname(0), 7);
				call movmem(16, .fname(1), .srcFileTable(srcFileIdx));
				call CloseF(.srcFil);
				call InitF(.srcFil, .('SOURCE'), .fname(1));
				call OpenF(.srcFil, 1);
				offCurCh = offLastCh;
			end;
		end;
	end;

	SetNewAddr: procedure;
		call fread(.tx1File, .curInfo$p, 2);
		call fread(.tx1File, .baseAddr, 2);
		curInfo$p = curInfo$p + botInfo;
		baseAddr = baseAddr + GetLinkVal;
		call FlushRecs;
	end;

/* Sub$54BA */


	call fread(.tx1File, .cfCode, 1);
	if cfCode = 98h then
		call EmitSource;
	else if cfCode = 86h then
		call fread(.tx1File, .stmtNo, 2);
	else if cfCode = 97h then
		call NewStatementNo;
	else if cfCode = 88h or cfCode = 89h then
		call EmitLocalLabel;
	else if cfCode = 8Ah then
		call EmitSymLabel;
	else if cfCode = 0A4h then
		call SetNewAddr;
	else if cfCode = 9Ah then
		call EmitSimpleError;
	else if cfCode = 9Bh then
		call EmitNearError;
	else if 9Dh <= cfCode and cfCode <= 0A2h then
		call MiscControl;
	else if cfCode = 9Ch then
		bo812B = 0;
	else if cfCode = 0A3h then
		call EmitFullError;
	else
		call Sub$668B;
end;

end;
src/plm4b.plm
plm4b: DO;
$include(:f2:plm4b.ipx)

/* plm4a.plm */
declare	digits(*) byte data(' 123456789'),
	ErrStrings(*) byte data(
	0ACh, 'INVALID LABEL: UNDEFINED', 0,
	0C8h, 'LIMIT EXCEEDED: STATEMENT SIZE', 0,
	0C9h, 'INVALID DO CASE BLOCK, AT LEAST ONE CASE REQUIRED', 0,
	0CAh, 'LIMIT EXCEEDED: NUMBER OF ACTIVE CASES', 0,
	0CBh, 'LIMIT EXCEEDED: NESTING OF TYPED PROCEDURE CALLS', 0,
	0CCh, 'LIMIT EXCEEDED: NUMBER OF ACTIVE PROCEDURES AND DO CASE GROUPS', 0,
	0CDh, 'ILLEGAL NESTING OF BLOCKS, ENDS NOT BALANCED', 0,
	0CEh, 'LIMIT EXCEEDED: CODE SEGMENT SIZE', 0,
	0D1h, 'ILLEGAL INITIALIZATION OF MORE SPACE THAN DECLARED', 0,
	0D2h, 'ILLEGAL INITIALIZATION OF A BYTE TO A VALUE > 255', 0,
	0D6h, 'COMPILER ERROR: OPERAND CANNOT BE TRANSFORMED', 0,
	0D7h, 'COMPILER ERROR: EOF READ IN FINAL ASSEMBLY', 0,
	0D8h, 'COMPILER ERROR: BAD LABEL ADDRESS', 0,
	0D9h, 'ILLEGAL INITIALIZATION OF AN EXTERNAL VARIABLE', 0,
	0);

$list

FlushRecs: procedure public;
	call WriteRec(.rec8.type, 1);
	call WriteRec(.rec6$4.type, 3);
	call WriteRec(.rec22.type, 1);
	call WriteRec(.rec24$1.type, 2);
	call WriteRec(.rec24$2.type, 2);
	call WriteRec(.rec24$3.type, 2);
	call WriteRec(.rec20.type, 1);
	rec6$4.addr = baseAddr;
end;



AddWrdDisp: procedure(str$p, arg2w) public;
	declare str$p address, arg2w address;
	declare str based str$p(1) byte;

	if arg2w <> 0 then
	do; 
		str(0) = str(0) + 1;
		if arg2w > 8000h then
		do;
			str(str(0)) = '-';
			arg2w = -arg2w;
		end;
		else
			str(str(0)) = '+';
		str(0) = str(0) + Num2Asc(arg2w, 0, -16, .str(str(0) + 1));
	end;
end;


LinePrefix: procedure public;
	if  not linePrefixChecked and listing then
	do;
		call SetStartAndTabW(15, 4);
		if lineNo <> 0 then
			call LstLineNo;
		call TabLst(-7);
		if depth < 10 then
		do;
			call putLst(' ');
			call putLst(digits(depth));
		end;
		else
			call XnumLst(depth, 2, 10);
		if srcFileIdx <> 0 then
		do; 
			call TabLst(-11);
			call XwrnstrLst(.('='), 1);
			if srcFileIdx <> 10 then 
				call XnumLst(srcFileIdx / 10 - 1, 1, 10);
		end;
		if lstLineLen > 0 then
		do;
			call TabLst(-15);
			call XwrnstrLst(.lstLine, lstLineLen);
		end;

		call NewLineLst;
		linePrefixListed = true;
	end;
	linePrefixChecked = true;
	listing = not listOff and PRINT;
end;



EmitStatementNo: procedure public;
	call LinePrefix;
	call TabLst(-50);
	call XwrnstrLst(.('; STATEMENT # '), 14);
	call XnumLst(stmtNo, 0, 0Ah);
	call NewLineLst;
end;


EmitLabel: procedure public;
	if codeOn then
	do; 
		call LinePrefix;
		call TabLst(-26);
		call XwrnstrLst(.locLabStr(1), locLabStr(0));
		call XwrnstrLst(.(':'), 1);
		call NewLineLst;
	end;
end;


EmitError: procedure public;
	declare (ErrOff, ErrLen) address;


	FindErrStr: procedure;
		declare (p, q) address;

		q = 0;
		do while ErrStrings(q) <> 0;
			p = q;
			do while ErrStrings(q) <> 0;
				q = q + 1;
			end;
			if ErrStrings(p) = errData.num then
			do;
				ErrOff = p + 1;
				ErrLen = q - ErrOff;
				return;
			end;
			q = q + 1;
		end;
		ErrLen = 0;
	end;


	programErrCnt = programErrCnt + 1;
	if PRINT then
	do;
		linePrefixChecked = linePrefixListed;
		listing = true;
		call LinePrefix;
		call XwrnstrLst(.('*** ERROR #'), 11);
		call XnumLst(errData.num, 0, 10);
		call XwrnstrLst(.(', '), 2);
		if errData.stmt <> 0 then
		do;
			call XwrnstrLst(.('STATEMENT #'), 11);
			call XnumLst(errData.stmt, 0, 10);
			call XwrnstrLst(.(', '), 2);
		end;
		if errData.info <> 0 then
		do; 
			call XwrnstrLst(.('NEAR '''), 6);
			curInfo$p = errData.info + botInfo;
			curSymbol$p = GetSymbol;
			if curSymbol$p <> 0 then
				call XwrnstrLst(.cursym.name(1), cursym.name(0));
			else
				call Xputstr2cLst(.('<LONG CONSTANT>', 0), 0);
			call XwrnstrLst(.(''', '), 3);
		end;
		call FindErrStr;
		call TabLst(2);
		if ErrLen = 0 then 
			call XwrnstrLst(.('UNKNOWN ERROR'), 13);
		else
			call XwrnstrLst(.ErrStrings(ErrOff), ErrLen);
		call NewLineLst;
	end;
end;




FatalError: procedure(arg1b) public;
	declare arg1b byte;
	fatalErrorCode, errData.num = arg1b;
	errData.info = 0;
	errData.stmt = stmtNo;
	call EmitError;
	goto errCont;
end;

ListCodeBytes: procedure public;
	declare i byte;
	if codeOn then
	do; 
		if opByteCnt > 0 then
		do;
			call TabLst(-12);
			call XnumLst(baseAddr, -4, 10h);
			i = 0;
			call TabLst(-18);
			do while i < opByteCnt;
				call XnumLst(opBytes(i), -2, 10h);
				i = i + 1;
			end;
		end;
		call TabLst(-26);
		call SetStartAndTabW(26, 8);
		call XwrnstrLst(.line, lineLen);
		call NewLineLst;
	end;
end;




GetSourceLine: procedure public;
	declare crCnt byte;

	GetSourceCh: procedure byte;
		if offCurCh = offLastCh then
		do;
			do while 1;
				call Readf(.srcFil, .srcbuf, 640, .offLastCh);
				offCurCh = 0;
				if offLastCh > 0 then
					goto break;
				if lstLineLen <> 0 then
					return lf;

				if srcFileIdx = 0 then
				do;
					if crCnt <> 0 then
						return lf;
					else
						call FatalError(0D7h);
				end;

				crCnt = 0;
				call CloseF(.srcFil);
				srcFileIdx = srcFileIdx - 10;
				call InitF(.srcFil, .('SOURCE'), .srcFileTable(srcFileIdx));
				call OpenF(.srcFil, 1);
				call SeekF(.srcFil, .srcFileTable(srcFileIdx + 8));
			end;
		break:	offLastCh = offLastCh - 1;
		end;
		else
			offCurCh = offCurCh + 1;
		return srcbuf(offCurCh) and 7fh;
	end;



	lstLineLen = 0;
	crCnt = 0;

	do while 1;
		lstLine(lstLineLen) = GetSourceCh;
		if lstLine(lstLineLen) = lf then
		do;
			linePrefixChecked = false;
			linePrefixListed = false;
			return;
		end;
		else if lstLine(lstLineLen) = cr then
			crCnt = crCnt + 1;
		else if lstLine(lstLineLen) <> cr and lstLineLen < 80h  then
			lstLinelen = lstLineLen + 1;
	end;
end;

end;
src/plm4c.plm
plm4c: DO;
$include(:f2:plm4c.ipx)

declare ccBits(*) byte data(10h, 18h, 8, 0, 18h, 10h),
	ccCodes(*) byte data( 2, 'NC', 1, 'C ', 1, 'Z ', 2, 'NZ', 1, 'C ', 2, 'NC');


Sub$5FE7: procedure(arg1w, arg2b) public;
	declare arg1w address, arg2b byte;
	declare p address, wA18D address,
		bA18F byte, bA190 byte;


	Sub$603C: procedure;

		PstrCat2Line: procedure(str$p);
			declare str$p address;
			declare len based str$p byte;
			if str$p <> 0 then
			do;
				call movmem(len, str$p + 1, .line(lineLen));
				lineLen = lineLen + len;
			end;
		end;

		Sub$6175: procedure;
			declare i byte, p address, j byte;

			j= ror(bA18F, 4) and 3;	
			bA190 = bA18F and 0fh;
			if bA190 < 4 then
			do;
				i= wValAry(bA190);
				p= sValAry(bA190);
			end;
			else if j= 0 then
			do;
				i= stkRegNo(bA190 - 4);
				p= .opcodes(stkRegIdx(bA190 - 4));
			end;
			else
			do;
				i= regNo(bA190 - 4);
				p= .opcodes(regIdx(bA190 - 4));
			end;

			do case j;
				i = rol(i, 4);
				i = rol(i, 3);
				;
			end;
			opBytes(0) = opBytes(0) or i;
			call PstrCat2Line(p);
		end;



		AddWord: procedure;
			declare pw address,
				w based pw address;

			dstRec = b96D6;
			pw = .opBytes(opByteCnt);
			w = wValAry(bA190);
			opByteCnt = opByteCnt + 2;
			call PstrCat2Line(sValAry(bA190));
		end;



		AddHelper: procedure;
			declare (pw, q) address,
				(i, j) byte;
			declare w based pw address;
			declare helpers based helpers$p(1) address;

			pw = .opBytes(opByteCnt);
			if bA190 = 1 then
				q = 69h;
			else
			do;
				i = b425D(b969D);
				j = b418C(b9692 + 11 * i);
				q = b42D6(shr(j, 2)) + (j and 3);
			end;
			helperStr(0) = Num2Asc(q, -4, 10, .helperStr(3)) + 2;
			call PstrCat2Line(.helperStr);
			if standAlone then
			do;
				w = helpers(q);
				dstRec = 1;
			end;
			else
			do;
				w = 0;
				dstRec = 5;
				curExtId = helpers(q);
			end;
			opByteCnt = opByteCnt + 2;
		end;


		AddSmallNum: procedure;
			declare i byte;
			
			wA18D = wA18D + 1;
			i = b4A78(wA18D);
			opBytes(opByteCnt) = i;
			opByteCnt = opByteCnt + 1;
			/* extend to word on opBytes if not 84h */
			if bA190 <> 0 then
			do;
				opBytes(opByteCnt) = 0;
				opByteCnt = opByteCnt + 1;
			end;
			lineLen = lineLen + Num2Asc(i, 0, 10, .line(lineLen));
		end;



		AddStackOrigin: procedure;
			dstRec = 3;
			opBytes(opByteCnt) = 0;
			opBytes(opByteCnt + 1) = 0;
			opByteCnt = opByteCnt + 2;
			call PstrCat2Line(.stack$origin);
		end;



		AddByte: procedure;
			declare str$p address,
				str based str$p(1) byte;

			opBytes(opByteCnt) = wValAry(bA190);
			opByteCnt = opByteCnt + 1;
			if wValAry(bA190) > 255 then
			do;		/* reformat number to byte size */
				str$p = sValAry(bA190);
				str(0) = Num2Asc(low(wValAry(bA190)), 0, -16, .str(1));
			end;
			call PstrCat2Line(sValAry(bA190));
		end;

		AddPCRel: procedure;
			declare (pw, q) address,
				w based pw address;

			dstRec = 1;
			pw = .opBytes(opByteCnt);
			wA18D = wA18D + 1;
			q = b4A78(wA18D);
			if q > 127 then	/* sign extend */
				q = q or 0ff00h;
			w = baseAddr + q;
			opByteCnt = opByteCnt + 2;
			line(lineLen) = '$';
			lineLen = lineLen + 1;
			call AddWrdDisp(.lineLen, q);
		end;




		AddCcCode: procedure;
			opBytes(0) = opBytes(0) or ccBits(b969C);
			call PstrCat2Line(.ccCodes(3 * b969C));
		end;


		EmitHelperLabel: procedure;
			helperStr(0) = Num2Asc(helperId, -4, 10, .helperStr(3)) + 3;
			call PstrCat2Line(.helperStr);
			helperId = helperId + 1;
		end;


		Sub$64CF: procedure;
			declare i byte;
			do case bA190;
				i= b425D(b969D);
				i= b475E(b969D);
				i= b4774(b969D);
				i= b478A(b969D);
			end;
			opBytes(0) = b473D(i);
			opByteCnt = 1;
			call PstrCat2Line(.opcodes(b47A0(i)));
		end;


/* Sub$603C */
		wA18D = w506F(arg1w);
		if b4A78(wA18D) = 0 then
			opByteCnt = 0;
		else
		do;
			opBytes(0) = b4A78(wA18D);
			opByteCnt = 1;
		end;

		dstRec = 0;
		lineLen = 0;

		do while 1;
			wA18D = wA18D + 1;
			bA18F = b4A78(wA18D);
			if bA18F < 80h then
			do;
				line(lineLen) = bA18F;
				lineLen = lineLen + 1;
			end;
			else if bA18F >= 0c0h then 
				call Sub$6175;
			else
			do;
				bA190 = shr(bA18F,4) and 3;
				do case bA18F and 0fh;
					return;
					call PstrCat2Line(sValAry(bA190));
					call AddWord;
					call AddHelper;
					call AddSmallNum;
					call AddStackOrigin;
					call AddByte;
					call AddPCRel;
					call AddCcCode;
					call EmitHelperLabel;
					call PstrCat2Line(w969E);
					call Sub$64CF;
				end;
			end;
		end;
	end;




	Sub$654F: procedure;
		declare p address, i byte;

		if opByteCnt = 0 or not OBJECT then
			return;
		if rec6$4.len + opByteCnt >= 1018 then
			call FlushRecs;
		p = baseAddr + opByteCnt - 2;	
		do case dstRec;
			;
			do;
				if rec22.len + 2 >= 1018 then
					call FlushRecs;
				call RecAddWord(.rec22.type, 1, p);
			end;
			do;
				if rec24$1.len + 2 >= 1017 then
					call FlushRecs;
				call RecAddWord(.rec24$1.type, 2, p);
			end;
			do;
				if rec24$2.len + 2 >= 99 then
					call FlushRecs;
				call RecAddWord(.rec24$2.type, 2, p);
			end;
			do;
				if rec24$3.len + 2 >= 99 then
					call FlushRecs;
				call RecAddWord(.rec24$3.type, 2, p);
			end;
			do;
				if rec20.len + 4 >= 1018 then
					call FlushRecs;
				call RecAddWord(.rec20.type, 1, curExtId);
				call RecAddWord(.rec20.type, 1, p);
			end;
		end;
		do i = 0 to opByteCnt - 1;
			call RecAddByte(.rec6$4.type, 3, opBytes(i));
		end;
	end Sub$654F;

/* Sub$5FE7 */
	do while arg2b > 0;
		call Sub$603C;
		call Sub$654F;
		call ListCodeBytes;
		arg1w = arg1w + 1;
		arg2b = arg2b - 1;
		p = baseAddr + opByteCnt;
		if baseAddr > p then
		do;
			errData.stmt, errData.info = 0;
			errData.num = 0CEh;
			call EmitError;
		end; 
		baseAddr = p;
	end;
end;





Sub$668B: procedure public;
	declare i byte;
	declare bA1AB byte;

	Sub$66F1: procedure;

		if cfCode >= 0AEh then
		do; 
			i = cfCode - 0AEh;
			cfCode = b4602(i);
			i = b413B(i);
			b9692 = b4128(i);
		end;
	end;


	Sub$6720: procedure;
		declare i byte;


		Sub$67AD: procedure(arg1b, arg2b);
			declare (arg1b, arg2b) byte;


			Sub$685C: procedure(arg1b, arg2b, arg3b);
				declare (arg1b, arg2b, arg3b) byte;
				wValAry(arg1b) = arg2b;
				sValAry(arg1b) = .opcodes(arg3b);
			end;



			RdBVal: procedure;
				call fread(.tx1File, .wValAry(arg2b), 1);
				wValAry(arg2b) = wValAry(arg2b) and 0ffh;
				b96B0 = Num2Asc(wValAry(arg2b), 0, -16, .b96B1);
				sValAry(arg2b) = .b96B0;
			end;



			RdWVal: procedure;
				call fread(.tx1File, .wValAry(arg2b), 2);
				b96B0 = Num2Asc(wValAry(arg2b), 0, -16, .b96B1);
				sValAry(arg2b) = .b96B0;
			end;

			RdLocLab: procedure;
				declare localLabels based localLabels$p(1) address;

				call fread(.tx1File, .w96D7, 2);
				wValAry(arg2b) = localLabels(w96D7);
				locLabStr(1) = '@';
				locLabStr(0) = Num2Asc(w96D7, 0, 10, .locLabStr(2)) + 1;
				sValAry(arg2b) = .locLabStr(0);
				b96D6 = 1;
			end;



			Sub$6982: procedure;
				declare s structure(i byte, p address);

				call fread(.tx1File, .s, 3);
				w969E = .commentStr;
				commentStr(0) = Num2Asc(s.i, 0, 10, .commentStr(3)) + 2;
				wValAry(arg2b) = s.p;
				b96B0 = Num2Asc(s.p, 0, 10, .b96B1);
				sValAry(arg2b) = .b96B0;
			end;


			Sub$69E1: procedure(disp);
				declare disp address;
				call fread(.tx1File, .curInfo$p, 2);
				curInfo$p = curInfo$p + botInfo;
				wValAry(arg2b) = GetLinkVal + disp;
				curSymbol$p = GetSymbol;
				if curSymbol$p <> 0 then
				do;
					b96B0 = cursym.name(0);
					call movmem(b96B0, .cursym.name(1), .b96B1);
				end;
				else
				do;
					b96B0 = 1;
					b96B1(0) = '$';
					disp = wValAry(arg2b) - baseAddr;
				end;
				sValAry(arg2b) =  .b96B0;
				call AddWrdDisp(sValAry(arg2b), disp);
				if TestInfoFlag(F$EXTERNAL) then
				do;
					b96D6 = 5;
					curExtId = GetExternId;
				end;
				else if GetType = PROC$T then
					b96D6 = 1;
				else if GetType = LABEL$T then 
					b96D6 = 1;
				else if TestInfoFlag(F$MEMBER) then
					;
				else if TestInfoFlag(F$BASED) then
					;
				else if TestInfoFlag(F$DATA) then
					b96D6 = 1;
				else if TestInfoFlag(F$MEMORY) then
					b96D6 = 4;
				else if not TestInfoFlag(F$ABSOLUTE) then
					b96D6 = 2;
			end;




			Sub$6B0E: procedure;
				declare p(3) address;

				call fread(.tx1File, .p, 6);
				curInfo$p = p(1) + botInfo;
				wValAry(arg2b) = p(2);
				b96B0 = Num2Asc(p(2), 0, -16, .b96B1);
				sValAry(arg2b) = .b96B0;
				w969E = .commentStr;
				curSymbol$p = GetSymbol;
				commentStr(0) = cursym.name(0) + 2;
				call movmem(cursym.name(0), .cursym.name(1), .commentStr(3));
				call AddWrdDisp(w969E, p(0));
			end;



			Sub$6B9B: procedure;
				declare wA1BD address;
				do case arg1b - 8;
					call RdBVal;
					call RdWVal;
					call Sub$6982;
					do;
						call fread(.tx1File, .wA1BD, 2);
						call Sub$69E1(wA1BD);
					end;
					call Sub$6B0E;
				end;
			end;


		/* Sub$67AD */

			do case bA1AB;
				return;
				do;
					call Sub$685C(arg2b, regNo(arg1b), regIdx(arg1b));
					call Sub$685C(arg2b + 2, regNo(4 + arg1b), regIdx(4 + arg1b));
				end;
				call Sub$685C(arg2b, stkRegNo(arg1b), stkRegIdx(arg1b));
				call Sub$6B9B;
				call RdBVal;
				call RdWVal;
				call RdLocLab;
				call Sub$69E1(0);
			end;
		end Sub$67AD;


/* Sub$6720 */

		b96D6 = 0;
		if rol(b4029(cfCode), 1) then
		do;
			call fread(.tx1File, .b969C, 1);
			b969D = b4273(b969C);
		end;
		w969E = 0;
		bA1AB = ror(b4029(cfCode), 4) and 7;
		if bA1AB <> 0 then
		do;
			if bA1AB <= 3 then
				call fread(.tx1File, .i, 1);
			call Sub$67AD(ror(i, 4) and 0fh, 0);
			bA1AB = ror(b4029(cfCode), 1) and 7;
			call Sub$67AD(i and 0fh, 1);
		end;
	end Sub$6720;

/* Sub$668B */

	call Sub$66F1;
	call Sub$6720;
	if cfCode = 87h then
	do; 
		baseAddr = GetLinkVal;
		if DEBUG then
		do;
			rec8.len = rec8.len - 4;
			call RecAddWord(.rec8.type, 1, baseAddr);
			rec8.len = rec8.len + 2;
		end;
		call FlushRecs;
	end;
	call LinePrefix;
	call Sub$5FE7(w47C1(cfCode) and 0fffh, shr(w47C1(cfCode), 12));
end;


end;
src/plm5a.plm
plm5a: DO;
$include(:f2:plm5a.ipx)

Sub$557A: procedure;
	declare i byte, line(30) byte, actual address, j byte;

	do i = 0 to 25;
		debugSwitches(i) = false;
	end;
	if not debugFlag then
		return;

	call PrintStr(.('ENTER DEBUG SWITCHES', cr, lf, '*'), 23);
	call Readf(.conFile, .line, 30, .actual);
	if actual <> 0 then
	do;
		actual = actual - 1;
		do i = 0 to actual;
			j = line(i);
			if 'A' <= j and j <= 'Z' then
				debugSwitches(j - 'A') = true;	
		end;
	end;
	call PrintStr(.('BEGINNING PHASE EXECUTION', cr, lf), 27);
end;


Sub$561E: procedure(arg1b) byte;
	declare arg1b byte;
	if debugSwitches(arg1b - 'A') then
		return true;
	else
		return false;
end;
end;
src/plm6a.plm
plm6a: DO;
$include(:f2:plm6a.ipx)

declare b5124(*) byte data(
	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0Eh, 1, 1, 1, 1,
	1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 2, 1, 1, 1,
	1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 6, 1, 0, 0, 0,
	0, 3, 0, 9, 9, 8, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 2, 9, 0Bh, 0Bh, 81h,
	99h, 91h, 91h, 91h, 81h, 89h, 89h, 89h, 8Ah, 80h, 80h,
	80h, 80h, 80h, 80h, 90h, 0A1h, 0A3h, 0A0h, 0A1h, 0A2h,
	0B0h, 0A0h, 0A0h, 0A0h, 0A0h, 0A0h, 0A3h, 0A3h, 0,
	0, 0, 0, 0, 0, 0, 0, 41h, 41h, 41h, 40h, 0, 0, 0, 0,
	0, 0C0h, 0C0h, 0C0h, 0C0h, 0C0h, 0D8h, 41h, 41h, 41h,
	0C0h);


Sub$42E7: procedure public;
	declare cfCode byte, itemArgs(4) address;

	Sub$4396: procedure;
		declare i address;
		if itemArgs(1) > 0 or itemArgs(2) = 0 then
			itemArgs(3) = itemArgs(0);
		else
		do;
			itemArgs(3) = itemArgs(2);
			itemArgs(2) = 0;
		end;
		do i = itemArgs(0) to itemArgs(3);
			call LinePrefix;
			w7AE5 = i;
			lineNo = itemArgs(1);
			depth = itemArgs(2);
			call GetSourceLine;
		end;
	end;

	Sub$4400: procedure;
		errData.num = itemArgs(0);
		errData.info = 0;
		errData.stmt = stmtNo;
		call EmitError;
	end;


	Sub$4416: procedure;
		errData.num = itemArgs(0);
		errData.info = itemArgs(1);
		errData.stmt = stmtNo;
		call EmitError;
	end;


	Sub$442C: procedure;
		errData.num = itemArgs(0);
		errData.info = itemArgs(1);
		errData.stmt = itemArgs(2);
		call EmitError;
	end;


	Sub$4442: procedure;
		declare name(19) byte;

		do case cfCode - 9dh;
			listOff = false;
			listOff = true;
			codeOn = PRINT;
			codeOn = false;
			if listing then
				call NewPageNextChLst;
			do;
				call LinePrefix;
				call TellF(.srcFil, .srcFileTable(srcFileIdx + 8));
				call Backup(.srcFileTable(srcFileIdx + 8), offLastCh - offCurCh);
				srcFileIdx = srcFileIdx + 10;
				call fread(.tx2File, .name(13), 6);	/* Read in name of include file */
				call fread(.tx2File, .name(6), 7);
				call fread(.tx2File, .name(0), 7);	/* overwrites the type byte */
				call movmem(16, .name(1), .srcFileTable(srcFileIdx));
				call CloseF(.srcFil);
				call InitF(.srcFil, .('SOURCE'), .name(1));
				call OpenF(.srcFil, 1);
				offCurCh = offLastCh;	/* force Read next time	*/
			end;
		end;
	end;


/* Sub$42E7 */
	itemArgs(0), itemArgs(1), itemArgs(2) = 0;
	call fread(.tx2File, .cfCode, 1);
	if cfCode <> 0a2h then
		call fread(.tx2File, .itemArgs, shl(b5124(cfCode) and 3,1));
	if cfCode = 98h then
		call Sub$4396;
	else if cfCode = 97h then
		stmtNo = itemArgs(0);
	else if cfCode = 9Ah then
		call Sub$4400;
	else if cfCode = 9Bh then
		call Sub$4416;
	else if cfCode = 0A3h then
		call Sub$442C;
	else if 9Dh <= cfCode and cfCode <= 0A2h then
		call Sub$4442;
	else if cfCode = 9Ch then
		b7AE4 = 0;
end;
end;
src/plm6b.plm
plm6b: DO;
$include(:f2:plm6b.ipx)

declare digits(*) byte data(' 123456789');

declare ERRStrings(*) byte data(
	1h, 'INVALID PL/M-80 CHARACTER',0,
	2h, 'UNPRINTABLE ASCII CHARACTER',0,
	3h, 'IDENTIFIER, STRING, OR NUMBER TOO LONG, TRUNCATED',0,
	4h, 'ILLEGAL NUMERIC CONSTANT TYPE',0,
	5h, 'INVALID CHARACTER IN NUMERIC CONSTANT',0,
	6h, 'ILLEGAL MACRO REFERENCE, RECURSIVE EXPANSION',0,
	7h, 'LIMIT EXCEEDED: MACROS NESTED TOO DEEPLY',0,
	8h, 'INVALID CONTROL FORMAT',0,
	9h, 'INVALID CONTROL',0,
	0Ah, 'ILLEGAL USE OF PRIMARY CONTROL AFTER NON-CONTROL LINE',0,
	0Bh, 'MISSING CONTROL PARAMETER',0,
	0Ch, 'INVALID CONTROL PARAMETER',0,
	0Dh, 'LIMIT EXCEEDED: INCLUDE NESTING',0,
	0Eh, 'INVALID CONTROL FORMAT, INCLUDE NOT LAST CONTROL',0,
	0Fh, 'MISSING INCLUDE CONTROL PARAMETER',0,
	10h, 'ILLEGAL PRINT CONTROL',0,
	11h, 'INVALID PATH-NAME',0,
	12h, 'INVALID MULTIPLE LABELS AS MODULE NAMES',0,
	13h, 'INVALID LABEL IN MODULE WITHOUT MAIN PROGRAM',0,
	14h, 'MISMATCHED IDENTIFIER AT END OF BLOCK',0,
	15h, 'MISSING PROCEDURE NAME',0,
	16h, 'INVALID MULTIPLE LABELS AS PROCEDURE NAMES',0,
	17h, 'INVALID LABELLED END IN EXTERNAL PROCEDURE',0,
	18h, 'INVALID STATEMENT IN EXTERNAL PROCEDURE',0,
	19h, 'UNDECLARED PARAMETER',0,
	1Ah, 'INVALID DECLARATION, STATEMENT OUT OF PLACE',0,
	1Bh, 'LIMIT EXCEEDED: NUMBER OF DO BLOCKS',0,
	1Ch, 'MISSING ''THEN''',0,
	1Dh, 'ILLEGAL STATEMENT',0,
	1Eh, 'LIMIT EXCEEDED: NUMBER OF LABELS ON STATEMENT',0,
	1Fh, 'LIMIT EXCEEDED: PROGRAM TOO COMPLEX',0,
	20h, 'INVALID SYNTAX, TEXT IGNORED UNTIL '';''',0,
	21h, 'DUPLICATE LABEL DECLARATION',0,
	22h, 'DUPLICATE PROCEDURE DECLARATION',0,
	23h, 'LIMIT EXCEEDED: NUMBER OF PROCEDURES',0,
	24h, 'MISSING PARAMETER',0,
	25h, 'MISSING '')'' AT END OF PARAMETER LIST',0,
	26h, 'DUPLICATE PARAMETER NAME',0,
	27h, 'INVALID ATTRIBUTE OR INITIALIZATION, NOT AT MODULE LEVEL',0,
	28h, 'DUPLICATE ATTRIBUTE',0,
	29h, 'CONFLICTING ATTRIBUTE',0,
	2Ah, 'INVALID INTERRUPT VALUE',0,
	2Bh, 'MISSING INTERRUPT VALUE',0,
	2Ch, 'ILLEGAL ATTRIBUTE, ''INTERRUPT'' WITH PARAMETERS',0,
	2Dh, 'ILLEGAL ATTRIBUTE, ''INTERRUPT'' WITH TYPED PROCEDURE',0,
	2Eh, 'ILLEGAL USE OF LABEL',0,
	2Fh, 'MISSING '')'' AT END OF FACTORED DECLARATION',0,
	30h, 'ILLEGAL DECLARATION STATEMENT SYNTAX',0,
	31h, 'LIMIT EXCEEDED: NUMBER OF ITEMS IN FACTORED DECLARE',0,
	32h, 'INVALID ATTRIBUTES FOR BASE',0,
	33h, 'INVALID BASE, SUBSCRIPTING ILLEGAL',0,
	34h, 'INVALID BASE, MEMBER OF BASED STRUCTURE OR ARRAY OF STRUCTURES',0,
	35h, 'INVALID STRUCTURE MEMBER IN BASE',0,
	36h, 'UNDECLARED BASE',0,
	37h, 'UNDECLARED STRUCTURE MEMBER IN BASE',0,
	38h, 'INVALID MACRO TEXT, NOT A STRING CONSTANT',0,
	39h, 'INVALID DIMENSION, ZERO ILLEGAL',0,
	3Ah, 'INVALID STAR DIMENSION IN FACTORED DECLARATION',0,
	3Bh, 'ILLEGAL DIMENSION ATTRIBUTE',0,
	3Ch, 'MISSING '')'' AT END OF DIMENSION',0,
	3Dh, 'MISSING TYPE',0,
	3Eh, 'INVALID STAR DIMENSION WITH ''STRUCTURE'' OR ''EXTERNAL''',0,
	3Fh, 'INVALID DIMENSION WITH THIS ATTRIBUTE',0,
	40h, 'MISSING STRUCTURE MEMBERS',0,
	41h, 'MISSING '')'' AT END OF STRUCTURE MEMBER LIST',0,
	42h, 'INVALID STRUCTURE MEMBER, NOT AN IDENTIFIER',0,
	43h, 'DUPLICATE STRUCTURE MEMBER NAME',0,
	44h, 'LIMIT EXCEEDED: NUMBER OF STRUCTURE MEMBERS',0,
	45h, 'INVALID STAR DIMENSION WITH STRUCTURE MEMBER',0,
	46h, 'INVALID MEMBER TYPE, ''STRUCTURE'' ILLEGAL',0,
	47h, 'INVALID MEMBER TYPE, ''LABEL'' ILLEGAL',0,
	48h, 'MISSING TYPE FOR STRUCTURE MEMBER',0,
	49h, 'INVALID ATTRIBUTE OR INITIALIZATION, NOT AT MODULE LEVEL',0,
	4Ah, 'INVALID STAR DIMENSION, NOT WITH ''DATA'' OR ''INITIAL''',0,
	4Bh, 'MISSING ARGUMENT OF ''AT'', ''DATA'', OR ''INITIAL''',0,
	4Ch, 'CONFLICTING ATTRIBUTE WITH PARAMETER',0,
	4Dh, 'INVALID PARAMETER DECLARATION, BASE ILLEGAL',0,
	4Eh, 'DUPLICATE DECLARATION',0,
	4Fh, 'ILLEGAL PARAMETER TYPE, NOT BYTE OR ADDRESS',0,
	50h, 'INVALID DECLARATION, LABEL MAY NOT BE BASED',0,
	51h, 'CONFLICTING ATTRIBUTE WITH ''BASE''',0,
	52h, 'INVALID SYNTAX, MISMATCHED ''(''',0,
	53h, 'LIMIT EXCEEDED: DYNAMIC STORAGE',0,
	54h, 'LIMIT EXCEEDED: BLOCK NESTING',0,
	55h, 'LONG STRING ASSUMED CLOSED AT NEXT SEMICOLON OR QUOTE',0,
	56h, 'LIMIT EXCEEDED: SOURCE LINE LENGTH',0,
	57h, 'MISSING ''END'', END-OF-FILE ENCOUNTERED',0,
	58h, 'INVALID PROCEDURE NESTING, ILLEGAL IN REENTRANT PROCEDURE',0,
	59h, 'MISSING ''DO'' FOR MODULE',0,
	5Ah, 'MISSING NAME FOR MODULE',0,
	5Bh, 'ILLEGAL PAGELENGTH CONTROL VALUE',0,
	5Ch, 'ILLEGAL PAGEWIDTH CONTROL VALUE',0,
	5Dh, 'MISSING ''DO'' FOR ''END'', ''END'' IGNORED',0,
	5Eh, 'ILLEGAL CONSTANT, VALUE > 65535',0,
	5Fh, 'ILLEGAL RESPECIFICATION OF PRIMARY CONTROL IGNORED',0,
	60h, 'COMPILER ERROR: SCOPE STACK UNDERFLOW',0,
	61h, 'COMPILER ERROR: PARSE STACK UNDERFLOW',0,
	62h, 'INCLUDE FILE IS NOT A DISKETTE FILE',0,
	/* 63h */
	64h, 'INVALID STRING CONSTANT IN EXPRESSION',0,
	65h, 'INVALID ITEM FOLLOWS DOT OPERATOR',0,
	66h, 'MISSING PRIMARY OPERAND',0,
	67h, 'MISSING '')'' AT END OF SUBEXPRESSION',0,
	68h, 'ILLEGAL PROCEDURE INVOCATION WITH DOT OPERATOR',0,
	69h, 'UNDECLARED IDENTIFIER',0,
	6Ah, 'INVALID INPUT/OUTPUT PORT NUMBER',0,
	6Bh, 'ILLEGAL INPUT/OUTPUT PORT NUMBER, NOT NUMERIC CONSTANT',0,
	6Ch, 'MISSING '')'' AFTER INPUT/OUTPUT PORT NUMBER',0,
	6Dh, 'MISSING INPUT/OUTPUT PORT NUMBER',0,
	6Eh, 'INVALID LEFT OPERAND OF QUALIFICATION, NOT A STRUCTURE',0,
	6Fh, 'INVALID RIGHT OPERAND OF QUALIFICATION, NOT IDENTIFIER',0,
	70h, 'UNDECLARED STRUCTURE MEMBER',0,
	71h, 'MISSING '')'' AT END OF ARGUMENT LIST',0,
	72h, 'INVALID SUBSCRIPT, MULTIPLE SUBSCRIPTS ILLEGAL',0,
	73h, 'MISSING '')'' AT END OF SUBSCRIPT',0,
	74h, 'MISSING ''='' IN ASSIGNMENT STATEMENT',0,
	75h, 'MISSING PROCEDURE NAME IN CALL STATEMENT',0,
	76h, 'INVALID INDIRECT CALL, IDENTIFIER NOT AN ADDRESS SCALAR',0,
	77h, 'LIMIT EXCEEDED: PROGRAM TOO COMPLEX',0,
	78h, 'LIMIT EXCEEDED: EXPRESSION TOO COMPLEX',0,
	79h, 'LIMIT EXCEEDED: EXPRESSION TOO COMPLEX',0,
	7Ah, 'LIMIT EXCEEDED: PROGRAM TOO COMPLEX',0,
	7Bh, 'INVALID DOT OPERAND, BUILT-IN PROCEDURE ILLEGAL',0,
	7Ch, 'MISSING ARGUMENTS FOR BUILT-IN PROCEDURE',0,
	7Dh, 'ILLEGAL ARGUMENT FOR BUILT-IN PROCEDURE',0,
	7Eh, 'MISSING '')'' AFTER BUILT-IN PROCEDURE ARGUMENT LIST',0,
	7Fh, 'INVALID SUBSCRIPT ON NON-ARRAY',0,
	80h, 'INVALID LEFT-HAND OPERAND OF ASSIGNMENT',0,
	81h, 'ILLEGAL ''CALL'' WITH TYPED PROCEDURE',0,
	82h, 'ILLEGAL REFERENCE TO OUTPUT FUNCTION',0,
	83h, 'ILLEGAL REFERENCE TO UNTYPED PROCEDURE',0,
	84h, 'ILLEGAL USE OF LABEL',0,
	85h, 'ILLEGAL REFERENCE TO UNSUBSCRIPTED ARRAY',0,
	86h, 'ILLEGAL REFERENCE TO UNSUBSCRIPTED MEMBER ARRAY',0,
	87h, 'ILLEGAL REFERENCE TO AN UNQUALIFIED STRUCTURE',0,
	88h, 'INVALID RETURN FOR UNTYPED PROCEDURE, VALUE ILLEGAL',0,
	89h, 'MISSING VALUE IN RETURN FOR TYPED PROCEDURE',0,
	8Ah, 'MISSING INDEX VARIABLE',0,
	8Bh, 'INVALID INDEX VARIABLE TYPE, NOT BYTE OR ADDRESS',0,
	8Ch, 'MISSING ''='' FOLLOWING INDEX VARIABLE',0,
	8Dh, 'MISSING ''TO'' CLAUSE',0,
	8Eh, 'MISSING IDENTIFIER FOLLOWING GOTO',0,
	8Fh, 'INVALID REFERENCE FOLLOWING GOTO, NOT A LABEL',0,
	90h, 'INVALID GOTO LABEL, NOT AT LOCAL OR MODULE LEVEL',0,
	91h, 'MISSING ''TO'' FOLLOWING ''GO''',0,
	92h, 'MISSING '')'' AFTER ''AT'' RESTRICTED EXPRESSION',0,
	93h, 'MISSING IDENTIFIER FOLLOWING DOT OPERATOR',0,
	94h, 'INVALID QUALIFICATION IN RESTRICTED REFERENCE',0,
	95h, 'INVALID SUBSCRIPTING IN RESTRICTED REFERENCE',0,
	96h, 'MISSING '')'' AT END OF RESTRICTED SUBSCRIPT',0,
	97h, 'INVALID OPERAND IN RESTRICTED EXPRESSION',0,
	98h, 'MISSING '')'' AFTER CONSTANT LIST',0,
	99h, 'INVALID NUMBER OF ARGUMENTS IN CALL, TOO MANY',0,
	9Ah, 'INVALID NUMBER OF ARGUMENTS IN CALL, TOO FEW',0,
	9Bh, 'INVALID RETURN IN MAIN PROGRAM',0,
	9Ch, 'MISSING RETURN STATEMENT IN TYPED PROCEDURE',0,
	9Dh, 'INVALID ARGUMENT, ARRAY REQUIRED FOR LENGTH OR LAST',0,
	9Eh, 'INVALID DOT OPERAND, LABEL ILLEGAL',0,
	9Fh, 'COMPILER ERROR: PARSE STACK UNDERFLOW',0,
	0A0h, 'COMPILER ERROR: OPERAND STACK UNDERFLOW',0,
	0A1h, 'COMPILER ERROR: ILLEGAL OPERAND STACK EXCHANGE',0,
	0A2h, 'COMPILER ERROR: OPERATOR STACK UNDERFLOW',0,
	0A3h, 'COMPILER ERROR: GENERATION FAILURE',0,
	0A4h, 'COMPILER ERROR: SCOPE STACK OVERFLOW',0,
	0A5h, 'COMPILER ERROR: SCOPE STACK UNDERFLOW',0,
	0A6h, 'COMPILER ERROR: CONTROL STACK OVERFLOW',0,
	0A7h, 'COMPILER ERROR: CONTROL STACK UNDERFLOW',0,
	0A8h, 'COMPILER ERROR: BRANCH MISSING IN ''IF'' STATEMENT',0,
	0A9h, 'ILLEGAL FORWARD CALL',0,
	0AAh, 'ILLEGAL RECURSIVE CALL',0,
	0ABh, 'INVALID USE OF DELIMITER OR RESERVED WORD IN EXPRESSION',0,
	0ACh, 'INVALID LABEL: UNDEFINED',0,
	0ADh, 'INVALID LEFT SIDE OF ASSIGNMENT: VARIABLE DECLARED WITH DATA ATTRIBUTE',0,
	0AEh, 'INVALID NULL PROCEDURE',0,
	/* xAF */
	0B0h, 'INVALID INTVECTOR INTERVAL VALUE',0,
	0B1h, 'INVALID INTVECTOR LOCATION VALUE',0,
	0B2h, 'INVALID ''AT'' RESTRICTED REFERENCE, EXTERNAL ATTRIBUTE CONFLICTS WITH PUBLIC ATTRIBUTE',0,
	0B3h, 'OUTER ''IF'' MAY NOT HAVE AN ''ELSE'' PART',0,
	0B4h, 'MISSING OR INVALID CONDITIONAL COMPILATION PARAMETER',0,
	0B5h, 'MISSING OR INVALID CONDITIONAL COMPILATION CONSTANT',0,
	0B6h, 'MISPLACED ELSE OR ELSEIF OPTION',0,
	0B7h, 'MISPLACED ENDIF OPTION',0,
	0B8h, 'CONDITIONAL COMPILATION PARAMETER NAME TOO LONG',0,
	0B9h, 'MISSING OPERATOR IN CONDITIONAL COMPILATION EXPRESSION',0,
	0BAh, 'INVALID CONDITIONAL COMPILATION CONSTANT, TOO LARGE',0,
	0BBh, 'LIMIT EXCEEDED: NUMBER OF SAVE LEVELS > 5',0,
	0BCh, 'MISPLACED RESTORE OPTION',0,
	0BDh, 'NULL STRING NOT ALLOWED',0,
	/* 0BEh, 0BFh, 0C0h, 0C1h, 0C2h, 0C3h, 0C4h, 0c5h, 0c7h */
	0C8h, 'LIMIT EXCEEDED: STATEMENT SIZE',0,
	0C9h, 'INVALID DO CASE BLOCK, AT LEAST ONE CASE REQUIRED',0,
	0CAh, 'LIMIT EXCEEDED: NUMBER OF ACTIVE CASES',0,
	0CBh, 'LIMIT EXCEEDED: NESTING OF TYPED PROCEDURE CALLS',0,
	0CCh, 'LIMIT EXCEEDED: NUMBER OF ACTIVE PROCEDURES AND DO CASE GROUPS',0,
	0CDh, 'ILLEGAL NESTING OF BLOCKS, ENDS NOT BALANCED',0,
	0CEh, 'LIMIT EXCEEDED: CODE SEGMENT SIZE',0,
	0CFh, 'LIMIT EXCEEDED: SEGMENT SIZE',0,
	0D0h, 'LIMIT EXCEEDED: STRUCTURE SIZE',0,
	0D1h, 'ILLEGAL INITIALIZATION OF MORE SPACE THAN DECLARED',0,
	0D2h, 'ILLEGAL INITIALIZATION OF A BYTE TO A VALUE > 255',0,
	0D3h, 'INVALID IDENTIFIER IN ''AT'' RESTRICTED REFERENCE',0,
	0D4h, 'INVALID RESTRICTED REFERENCE IN ''AT'', BASE ILLEGAL',0,
	0D5h, 'UNDEFINED RESTRICTED REFERENCE IN ''AT''',0,
	0D6h, 'COMPILER ERROR: OPERAND CANNOT BE TRANSFORMED',0,
	0D7h, 'COMPILER ERROR: EOF READ IN FINAL ASSEMBLY',0,
	0D8h, 'COMPILER ERROR: BAD LABEL ADDRESS',0,
	0D9h, 'ILLEGAL INITIALIZATION OF AN EXTERNAL VARIABLE',0,
	0DAh, 'ILLEGAL SUCCESSIVE USES OF RELATIONAL OPERATORS',0,
	0DBh, 'LIMIT EXCEEDED: NUMBER OF EXTERNALS > 255',0,
	0);

$list
LinePrefix: procedure public;
	if not linePrefixChecked and listing then
	do;
		call SetStartAndTabW(15, 4);
		if lineNo <> 0 then
			call LstLineNo;
		call TabLst(-7);
		if depth < 10 then
		do;
			call putLst(' ');
			call putLst(digits(depth));
		end;
		else
			call XnumLst(depth, 2, 10);
		if srcFileIdx <> 0 then
		do;
			call TabLst(-11);
			call XwrnstrLst(.('='), 1);
			if srcFileIdx <> 10 then
				call XnumLst(srcFileIdx / 10 - 1, 1, 10);
		end;
		if lstLineLen > 0 then
		do;
			call TabLst(-15);
			call XwrnstrLst(.lstbuf, lstLineLen);
		end;
		call NewLineLst;
		linePrefixListed = true;
	end;
	linePrefixChecked = true;
	listing = not listOff and PRINT;
end;


EmitError: procedure public;
	declare (ErrOff, ErrLen) address;

	FindErrStr: procedure;
		declare (i, j) address;
		j = 0;
		do while ERRStrings(j) <> 0;
			i = j;
			do while ERRStrings(j) <> 0;
				j = j + 1;
			end;
			if ERRStrings(i) = errData.num then
			do;
				ErrOff = i + 1;
				Errlen = j - ErrOff;
				return;
			end;
			j = j + 1;
		end;
		Errlen = 0;
	end;

	programErrCnt = programErrCnt + 1;
	if PRINT then
	do;
		linePrefixChecked = linePrefixListed;
		listing = true;
		call LinePrefix;
		call XwrnstrLst(.('*** ERROR #'), 11);
		call XnumLst(errData.num, 0, 10);
		call XwrnstrLst(.(', '), 2);
		if errData.stmt <> 0 then
		do;
			call XwrnstrLst(.('STATEMENT #'), 11);
			call XnumLst(errData.stmt, 0, 10);
			call XwrnstrLst(.(', '), 2);
		end;
		if errData.info <> 0 then
		do;
			call XwrnstrLst(.('NEAR '''), 6);
			curInfo$p = errData.info + botInfo;
			curSymbol$p = GetSymbol;
			if curSymbol$p <> 0 then
				call XwrnstrLst(.cursym.name(1), cursym.name(0));
			else
				call Xputstr2cLst(.('<LONG CONSTANT>', 0), 0);
			call XwrnstrLst(.(''', '), 3);
		end;
		call FindErrStr;
		call TabLst(2);
		if ErrLen = 0 then
			call XwrnstrLst(.('UNKNOWN ERROR'), 13);
		else
			call XwrnstrLst(.ErrStrings(ErrOff), ErrLen);
		call NewLineLst;
	end;
end;


FatalError: procedure(arg1b) public;
	declare arg1b byte;
	fatalErrorCode, errData.num = arg1b;
	errData.info = 0;
	errData.stmt = stmtNo;
	call EmitError;
	goto errCont;
end;

GetSourceLine: procedure public;
	declare crCnt byte;

	GetSourceCh: procedure byte;
		if offCurCh = offLastCh then
		do;
			do while 1;
				call Readf(.srcFil, .srcbuf, 1280, .offLastCh);
				offCurCh = 0;
				if offLastCh > 0 then
					goto break;		/* there are more chars */
				if lstLineLen <> 0 then		/* we already have a part line */
					return lf;

				if srcFileIdx = 0 then		/* top level file */
				do;
					if crCnt <> 0 then	/* allow file to finish with cr */
						return lf;
					else
						call FatalError(ERR215);
				end;
				call CloseF(.srcFil);		/* unnest include file */
				srcFileIdx = srcFileIdx - 10;
				call InitF(.srcFil, .('SOURCE'), .srcFileTable(srcFileIdx));
				call OpenF(.srcFil, 1);
				call SeekF(.srcFil, .srcFileTable(srcFileIdx + 8));
			end;
		break:	offLastCh = offLastCh - 1;		/* correct for 0 index */
		end;
		else
			offCurCh = offCurCh + 1;		/* advance to next char */
		return srcbuf(offCurCh) and 7fh;		/* remove high bits */
	end;

	lstLineLen = 0;
	crCnt = 0;
	do while 1;
		lstbuf(lstLineLen) = GetSourceCh;
		if lstbuf(lstLineLen) = lf then
		do;
			linePrefixChecked = false;
			linePrefixListed = false;
			return;
		end;
		else if lstbuf(lstLineLen) = cr then		/* allow cr */
			crCnt = crCnt + 1;
		else if lstbuf(lstLineLen) <> cr and lstLineLen < 128 then
			lstLineLen = lstLineLen + 1;
	end;
end;
END;
src/plma.plm
PLMA: DO;
$include(:f2:plma.ipx)

DECLARE
	signonMsg(*) BYTE DATA(CR, LF, 'ISIS-II PL/M-80 COMPILER '),
	noMemMsg(*) BYTE DATA('NOT ENOUGH MEMORY FOR A COMPILATION'),
	a$ixi(*) BYTE DATA('.IXI'),
	a$obj(*) BYTE DATA('.OBJ'),
	a$lst(*) BYTE DATA('.LST'),
	plmtx1(*) BYTE DATA(':F1:PLMTX1.TMP '),
	plmtx2(*) BYTE DATA(':F1:PLMTX2.TMP '),
	plmat(*) BYTE DATA(':F1:PLMAT.TMP '),
	plmnms(*) BYTE DATA(':F1:PLMNMS.TMP '),
	plmxrf(*) BYTE DATA(':F1:PLMXRF.TMP '),
	aInvocationComm(*) BYTE DATA('INVOCATION COMMAND DOES NOT END WITH <CR><LF>'),
	aIncorrectDevice(*) BYTE DATA('INCORRECT DEVICE SPEC'),
	aSourceFileNotDisk(*) BYTE DATA('SOURCE FILE NOT A DISKETTE FILE'),
	aSourceFileName(*) BYTE DATA('SOURCE FILE NAME INCORRECT'),
	aSourceFileBadExt(*) BYTE DATA('SOURCE FILE EXTENSION INCORRECT'),
	aIllegalCommand(*) BYTE DATA('ILLEGAL COMMAND TAIL SYNTAX');

DECLARE
	cmdText$p ADDRESS PUBLIC,
	cmdch BASED cmdText$p BYTE;


SignOnAndGetSourceName: PROCEDURE PUBLIC;

	LocalRescan: procedure (conn, status$p);
	    declare (conn, status$p) address;
		call ISIS(IRESCAN, .conn);
	end LocalRescan;


	SkipSpace: PROCEDURE;
		do while cmdch = ' ' or cmdch = '&';
			if cmdch = ' ' then
				cmdText$p = cmdText$p + 1;
			else if 0 <> cmd.link then
			do;
				cmdLine$p = cmd.link;
				cmdText$p = cmdLine$p + 3;
			end;
		end;
	end SkipSpace;


	TestToken: PROCEDURE(str, len) bool;
		DECLARE str ADDRESS, len BYTE;
		DECLARE p ADDRESS;
		DECLARE strch BASED str BYTE;

		p = cmdText$p;
		do while len <> 0;
			if (cmdch and 5FH) <> strch then
			do;
				cmdText$p = p;
				return false;
			end;
			cmdText$p = cmdText$p + 1;
			str = str + 1;
			len = len - 1;
		end;
		return true;
	end TestToken;


	SkipAlphaNum: PROCEDURE;
		
		do while 'A' <= cmdch and cmdch <= 'Z' or 'a' <= cmdch and cmdch <= 'z'
					or '0' <= cmdch and cmdch <= '9';
			cmdText$p = cmdText$p + 1;
		end;
	end SkipAlphaNum;



	GetCmdLine: PROCEDURE;
		DECLARE (actual, status) ADDRESS;
		DECLARE (i, inQuote) BYTE;

		call LocalRescan(1, .status);
		if status <> 0 then
			call FatlIO(.conFile, status);
		startCmdLine$p = 0;
		cmdLine$p = topMem;

		loop: do;
			call Readf(.conFile, .ioBuffer, 128, .actual);
			if ioBuffer(actual - 1) <> LF or ioBuffer(actual - 2) <> CR then
				call Fatal(.aInvocationComm, length(aInvocationComm));
			topMem = cmdLine$p - actual - 3;
			if startCmdLine$p = 0 then
				startCmdLine$p = topMem;
			else
				cmd.link = topMem;
			cmdLine$p = topMem;
			cmd.pstr(0) = actual;
			call movmem(actual, .ioBuffer, .cmd.pstr(1));
			inQuote = 0;
			do i = 0 to actual - 1;
				if ioBuffer(i) = QUOTE then
					inQuote = not inQuote;
				else if ioBuffer(i) = '&' then
					if not inQuote then
						goto extend;
			end;
			cmd.link = 0;
			cmdLine$p = startCmdLine$p;
			topMem = topMem - 1;
			return;
		extend:
			call PrintStr(.('**'), 2);
			goto loop;
		end;
	end GetCmdLine;

	ParseInvokeName: PROCEDURE;
		DECLARE (p, start$p, len) ADDRESS;
		DECLARE ch BASED cmdText$p BYTE;

		call SkipSpace;
		if TestToken(.('DEBUG'), 5) then
			debugFlag = 0FFH;
		else
			debugFlag = 0;
		call SkipSpace;
		start$p = cmdText$p;
		if ch = ':' then
			cmdText$p = cmdText$p + 4;
		call SkipAlphaNum;
		if (len := cmdText$p - start$p) > 10 then
			len = 10;
		do p = .overlay1 to .overlay5 by FILE$NAME$LEN;
			call movmem(len, start$p, p);
		end;
		call movmem(len, start$p, .invokeName);
		call movmem(len, start$p, .overlay6);
		do p = .overlay1 to .overlay5 by FILE$NAME$LEN;
			call movmem(5, p + 10, p + len);
		end;
		call movmem(5, .ov0, .invokeName(len));
		call movmem(5, .ov6, .overlay6 + len);
	end ParseInvokeName;


	ParseSrcFileName: PROCEDURE;
		DECLARE cmdText BASED cmdText$p(1) BYTE;
		DECLARE fullName ADDRESS;
		DECLARE fileName ADDRESS;
		DECLARE nameLen ADDRESS;

		do while  cmdch <> ' ' and cmdch <> CR and cmdch <> '&';
			cmdText$p = cmdText$p + 1;
		end;
		call SkipSpace;
		fullName = cmdText$p;
		if cmdch = ':' then
		do;
			if cmdText(3) <> ':' then
				call Fatal(.aIncorrectDevice, length(aIncorrectDevice));
			if cmdText(1) >= 'a' then
				cmdText(1) = cmdText(1) and 05FH;
			if cmdText(1) <> 'F' then
				call Fatal(.aSourceFileNotDisk, length(aSourceFileNotDisk));
			cmdText$p = cmdText$p + 4;
		end;
		fileName = cmdText$p;
		call SkipAlphaNum;
		if (nameLen := cmdText$p - fileName) = 0 or nameLen > 6 then
			call Fatal(.aSourceFileName, length(aSourceFileName));
		srcStemLen = cmdText$p - fullname;
		call FILLX(10, .srcStemName, double(' '));
		call movmem(srcStemLen, fullname, .srcStemName);
		if cmdch = '.' then
		do;
			filename = (cmdText$p := cmdText$p + 1);
			call SkipAlphaNum;
			if (namelen := cmdText$p - filename) = 0 or nameLen > 3 then
				call Fatal(.aSourceFileBadExt, length(aSourceFileBadExt));
		end;
		namelen = cmdText$p - fullname;
		srcFileIdx = 0;
		call FILLX(16, .srcFileTable, double(' '));
		call movmem(namelen, fullname, .srcFileTable);
		call FILLX(4, .srcFileTable(8), double(0));
		call SkipSpace;
		if cmdch = '$' then
			call Fatal(.aIllegalCommand, length(aIllegalCommand));
		if cmdch = CR then
			offNxtCmdChM1 = 0;
		else
			offNxtCmdChM1 = cmdText$p - cmdLine$p - 1;
	end ParseSrcFileName;

	InitFilesAndDefaults: PROCEDURE;
		LEFTMARGIN = 1;
		call FILLX(15, .ixiFileName, double(' '));
		call movmem(srcStemLen, .srcStemName, .ixiFileName);
		call movmem(4, .a$ixi, .ixiFileName(srcStemLen));
		call InitF(.ixiFile, .('IXREF '), .ixiFileName);
		objBlk, objByte = 0;
		call FILLX(15, .objFileName, double(' '));	
		call movmem(srcStemLen, .srcStemName, .objFileName);
		call movmem(4, .a$obj, .objFileName(srcStemLen));
		call InitF(.objFile, .('OBJECT'), .objFileName);
		call FILLX(15, .lstFileName, double(' '));	
		call movmem(srcStemLen, .srcStemName, .lstFileName);
		call movmem(4, .a$lst, .lstFileName(srcStemLen));
		call InitF(.lstFil, .('LIST '), .lstFileName);
		call InitF(.tx1File, .('UT1 '), .plmtx1);
		call InitF(.tx2File, .('UT2 '), .plmtx2);
		call InitF(.atFile, .('AT  '), .plmat);
		call InitF(.nmsFile, .('NAMES '), .plmnms);
		call InitF(.xrfFile, .('XREF '), .plmxrf);
		IXREF = false;
		IXREFSET = false;
		PRINT = true;
		PRINTSet = true;
		XREF = false;
		SYMBOLS = false;
		DEBUG = false;
		PAGING = true;
		OBJECT = true;
		OBJECTSet = true;
		OPTIMIZE = true;
		call SetDate(.(' '), 1);
		call SetPageLen(57);
		call SetMarkerInfo(20, '-', 21);
		call SetPageNo(0);
		call SetMarginAndTabW(0FFH, 4);
		call SetTitle(.(' '), 1);
		call SetPageWidth(120);
	end InitFilesAndDefaults;


	call movmem(4, .verNo, .version);
	call InitF(.conFile, .('CONSOL'), .(':CI: '));
	call OpenF(.confile, 1);
	topMem = MEMCHK - 12;
	if topMem < 0C000H then
		call Fatal(.noMemMsg, length(noMemMsg));
	call GetCmdLine;
	call PrintStr(.signonMsg, length(signonMsg));
	call PrintStr(.version, 4);
	call PrintStr(.(CR, LF), 2);
	cmdText$p = cmdLine$p + 3;
	blkSize1 = topMem - blkSize1 - 256;
	blkSize2 = topMem - blkSize2 - 256;
	call ParseInvokeName;
	call ParseSrcFileName;
	call InitFilesAndDefaults;
end SignOnAndGetSourceName;

END;

src/plmb.plm
PLMB: DO;
$include(:f2:plmb.ipx)


InitKeywordsAndBuiltins: PROCEDURE PUBLIC;

	InstallBuiltins: PROCEDURE;
		DECLARE p ADDRESS;
		DECLARE len BASED p BYTE;
		DECLARE charray BASED p(1) BYTE;

		p = .builtins;
		do while len <> 0;
			call Lookup(p);
			call CreateInfo(0, BUILTIN$T);
			call SetBuiltinId(charray(len + 1));
			call SetParamCnt(charray(len + 2));
			call SetDataType(charray(len + 3));
			p = p + len +  4;
		end;	
		call Lookup(.(6, 'MEMORY'));
		call CreateInfo(0, BYTE$T);
		call SetInfoFlag(F$LABEL);
		call SetInfoFlag(F$MEMORY);
		call SetInfoFlag(F$ARRAY);
	end InstallBuiltins;


	InstallKeywords: PROCEDURE;
		DECLARE p ADDRESS;
		DECLARE pstr BASED p STRUCTURE(len BYTE, array(1) BYTE);
	
		p = .keywords;
		do while pstr.len <> 0;
			call Lookup(p);
			cursym.info$p = 0FF00H or pstr.array(pstr.len);
			p = p + pstr.len + 2;
		end;
	end InstallKeywords;


	InitInfoAndSym: PROCEDURE;
		DECLARE i ADDRESS;
		DECLARE hashChains BASED hashChains$p(1) ADDRESS;

		if w3C44 > w3C34 then
			botMem = w3C44;
		else
			botMem = w3C34;
		botMem = botMem + 256;
		botSymbol = (topSymbol := (hashChains$p := topMem + 1 - DOUBLE(128)) - 1) + 1;
		topInfo = (botInfo := botMem) + 1;
		do i = 0 to 63;
			hashChains(i) = 0;
		end;
		call SetPageNo(1);
		locallabelCnt = 0;
		w382A = w382A + 1;
		procChains(0), procChains(1), blockDepth = 0;
	end InitInfoAndSym;

	call InitInfoAndSym;
	call InstallKeywords;
	call InstallBuiltins;
end InitKeywordsAndBuiltins;


END;
src/plmc.plm
plmc: DO;
	DECLARE vtext(*) BYTE DATA('program_version_number='),
		verno(*) BYTE PUBLIC DATA('V4.0');

END;



src/plmd.plm
plmd: DO;
$include(:f2:plmd.ipx)

SetDate: PROCEDURE(str, len) PUBLIC;
	DECLARE str ADDRESS, len BYTE;
	if len > 9 then
		len = 9;
	call fill(9, .DATE, ' ');
	call movmem(len, str, .DATE);
end SetDate;


SetPageLen: PROCEDURE(len) PUBLIC;
	DECLARE len ADDRESS;
	PAGELEN = len;
end SetPageLen;


SetMarkerInfo: PROCEDURE(markerCol, marker, textCol) PUBLIC;
	DECLARE (markerCol, marker, textCol) BYTE;
	wrapMarkerCol = markerCol;
	wrapMarker = marker;
	wrapTextCol = textCol;
end;

SetPageNo: PROCEDURE(v) PUBLIC;
	DECLARE v ADDRESS;

	pageNo = v - 1;
end;


SetMarginAndTabW: PROCEDURE(b1, b2) PUBLIC;
	DECLARE (b1, b2) BYTE;

	margin = b1 - 1;
	tWidth = b2;
end;


SetTitle: PROCEDURE(str, len) PUBLIC;
	DECLARE str ADDRESS, len BYTE;
	if len > 60 then
		len = 60;
	call movmem(len, str, .TITLE);
	TITLELEN = len;
end SetTitle;


SetPageWidth: PROCEDURE(width) PUBLIC;
	DECLARE width ADDRESS;
	PWIDTH = width;
end SetPageWidth;



END;
src/plme.plm
plmE:
DO;
DECLARE ioBuffer(2048) BYTE PUBLIC,
	builtins(*) BYTE PUBLIC INITIAL(
	5, 'CARRY', 0 , 0 , 2,
	3, 'DEC', 1 , 1 , 2 ,
	6, 'DOUBLE', 2 , 1 , 3 ,
	4, 'HIGH', 3 , 1 , 2 ,
	5, 'INPUT', 4 , 1 , 2 ,
	4, 'LAST', 5 , 1 , 3 ,
	6, 'LENGTH', 6 , 1 , 3 ,
	3, 'LOW', 7 , 1 , 2 ,
	4, 'MOVE', 8 , 3 , 0 ,
	6, 'OUTPUT', 9 , 1 , 0 ,
	6, 'PARITY', 0Ah , 0 , 2 ,
	3, 'ROL', 0Bh , 2 , 2 ,
	3, 'ROR', 0Ch , 2 , 2 ,
	3, 'SCL', 0Dh , 2 , 2 ,
	3, 'SCR', 0Eh , 2 , 2 ,
	3, 'SHL', 0Fh , 2 , 2 ,
	3, 'SHR', 10h , 2 , 2 ,
	4, 'SIGN', 11h , 0 , 2 ,
	4, 'SIZE', 12h , 1 , 2 ,
	8, 'STACKPTR', 13h , 0 , 3 ,
	4, 'TIME', 14h , 1 , 0 ,
	4, 'ZERO', 15h , 0 , 2 ,
	0),
	pad(17) BYTE,

	keywords(*) BYTE PUBLIC INITIAL(
	7, 'ADDRESS', 28h,
	3, 'AND', 0Ah,
	2, 'AT', 29h,
	5, 'BASED', 2Ah,
	2, 'BY', 35h,
	4, 'BYTE', 2Bh,
	4, 'CALL', 1Ch,
	4, 'CASE', 36h,
	4, 'DATA', 2Ch,
	7, 'DECLARE', 1Dh,
	7, 'DISABLE', 1Eh,
	2, 'DO', 1Fh,
	4, 'ELSE', 37h,
	6, 'ENABLE', 20h,
	3, 'END', 21h,
	3, 'EOF', 38h,
	8, 'EXTERNAL', 2Dh,
	2, 'GO', 22h,
	4, 'GOTO', 23h,
	4, 'HALT', 24h,
	2, 'IF', 25h,
	7, 'INITIAL', 2Eh,
	9, 'INTERRUPT', 2Fh,
	5, 'LABEL', 30h,
	9, 'LITERALLY', 31h,
	5, 'MINUS', 9  ,
	3, 'MOD', 7  ,
	3, 'NOT', 0Dh,
	2, 'OR', 0Bh,
	4, 'PLUS', 8  ,
	9, 'PROCEDURE', 26h,
	6, 'PUBLIC', 32h,
	9, 'REENTRANT', 33h,
	6, 'RETURN', 27h,
	9, 'STRUCTURE', 34h,
	4, 'THEN', 39h,
	2, 'TO', 3Ah,
	5, 'WHILE', 3Bh,
	3, 'XOR', 0Ch,
        0);

END;
src/wrec.plm
wrec: do;
$include(:f2:wrec.ipx)

WriteRec: procedure(rec$p, arg2b) public;
	declare rec$p address, arg2b byte;
	declare (p, len$p) address, crc byte, cnt address;
	declare len based len$p address;
	declare brec based rec$p(1) byte;

	len$p = rec$p + 1;
	if len > 0 and OBJECT then
	do;
			crc = 0;
			p = 0;
			len = len + arg2b + 1;
			cnt = len + 2;
			do while p < cnt;
				crc = crc - brec(p);
				p = p + 1;
			end;
			brec(cnt) = crc;	/* insert checksum */
			call fwrite(.objFile, rec$p, cnt + 1);
	end;
	len = 0;
end;



RecAddByte: procedure(rec$p, arg2b, arg3b) public;
	declare rec$p address, (arg2b, arg3b) byte;
	declare len$p address, len based len$p address;
	declare rec based rec$p structure(type byte, len address, val(1) byte);

	len$p = .rec.len;
	rec.val(len + arg2b) = arg3b;
	len = len + 1;
end;



RecAddWord: procedure(arg1w, arg2b, arg3w) public;
	declare arg1w address, arg2b byte, arg3w address;

	call RecAddByte(arg1w, arg2b, low(arg3w));
	call RecAddByte(arg1w, arg2b, high(arg3w));
end;
end;
shared/fill.asm
	public FILL,FILLX

	CSEG

; FILLX(cnt$w, dest$p, val$w)
; FILL(cnt$w, dest$p, val$b)
FILLX:
FILL:	pop	h
	xthl
	mov	a, e
	inr	l
	inr	h
	jmp	L2

L1:	stax	b
	inx	b

L2:	dcr	l
	jnz	L1
	dcr	h
	jnz	L1
	ret

	END

shared/fread.asm
	PUBLIC	fread
	extrn	movmem
	extrn	Readf
	extrn	FatlIO
	extrn	@P0099	; hl@deiSUBhli
	extrn	@P0095	; hl@deSUBhl
	extrn	@P0012	; hl@deiADDhli
	extrn	@P0102	; hl@deiSUBhl

DSEG
file:	ds 2
buf:	ds 2
cnt:	ds 2
avail:	ds 2

; file structure offsets
aftn	equ 0
snam	equ 2
fnam	equ 8
bufptr	equ 24
size	equ 26
actual	equ 28
curoff	equ 30

CSEG

; fread: procedure(file, buf, cnt) public; declare (file, buf, cnt) address; end;

fread:	xchg
	shld	cnt
	mov	h, b
	mov	l, c
	shld	buf
	pop	h
	xthl
	shld	file
	xchg
	lxi	h, actual
	dad	d
	push	h
	xchg
	lxi	b, curoff
	dad	b
	push	h
	call	@P0099
	xchg

L1:	lhld	cnt
	call	@P0095
	lhld	cnt
	jnc	L2
	xchg

L2:	shld	avail
	lhld	file
	mov	b, h
	mov	c, l
	lxi	h, actual
	dad	b
	mov	a, m
	inx	h
	mov	e, m
	ora	e
	jnz	L3
	lxi	d, 0FEh
	call	FatlIO		; fatalIO(arg1w, arg2w)

L3:	lhld	file
	lxi	d, bufptr
	dad	d
	pop	d
	push	d
	call	@P0012
	mov	b, h
	mov	c, l
	lhld	avail
	push	h
	lhld	buf
	xchg
	call	movmem
	pop	h
	push	h
	lxi	d, avail
	call	@P0012
	xchg
	pop	h
	push	h
	mov	m, e
	inx	h
	mov	m, d
	lhld	avail
	mov	b, h
	mov	c, l
	lxi	d, cnt
	call	@P0102
	shld	cnt
	mov	a, h
	ora	l
	jz	L5
	lhld	buf
	dad	b
	shld	buf
	pop	d
	pop	h
	push	d
	push	h
	call	@P0099
	jc	L4
	lhld	file
	push	h
	xchg
	lxi	h, bufptr
	dad	d
	mov	c, m
	inx	h
	mov	b, m
	push	b
	inx	h
	mov	c, m
	inx	h
	mov	b, m
	inx	h
	xchg
	call	Readf
	lxi	b, curoff
	lhld	file
	dad	b
	mvi	m, 0
	inx	h
	mvi	m, 0

L4:	pop	h
	mov	e, m
	inx	h
	mov	d, m
	dcx	h
	xthl
	push	h
	jmp	L1

L5:	pop	h
	pop	h
	ret

	end
shared/fwrite.asm
	public	fwrite
	extrn	movmem
	extrn	Fflush
	extrn	@P0099	; hl@deiSUBhli
	extrn	@P0095	; hl@deSUBhl
	extrn	@P0012	; hl@deiADDhli
	extrn	@P0102	; hl@deiSUBhl

; file structure offsets
aftn	equ	0
sNam	equ	aftn + 2
fNam	equ	sNam + 6
bufp	equ	fNam + 16
bsize	equ	bufp + 2
actual	equ	bsize + 2
curoff	equ	actual + 2

DSEG
file:	ds 2
buf:	ds 2
len:	ds 2
wcnt:	ds 2

CSEG
; fwrite(file, buf, len)

fwrite:	xchg
	shld	len
	mov	h, b
	mov	l, c
	shld	buf
	pop	h
	xthl
	shld	file
	xchg
	lxi	h, bsize
	dad	d
	push	h
	xchg
	lxi	b, curoff
	dad	b
	push	h
	call	@P0099		; hl = m[de] - (bc = m[hl])
	xchg			; room in buffer

L1:	lhld	len
	call	@P0095
	lhld	len
	jnc	L2
	xchg

L2:	shld	wcnt
	lhld	file
	lxi	d, bufp
	dad	d
	pop	d		; current offset
	push	d		; current offset
	call	@P0012
	xchg
	lhld	buf		; copy first lot of bytes
	mov	b, h
	mov	c, l
	lhld	wcnt
	push	h		; wcnt
	call	movmem
	pop	h		; advance the offset
	push	h		; current offset
	lxi	d, wcnt
	call	@P0012
	xchg
	pop	h
	push	h		; current offset
	mov	m, e
	inx	h
	mov	m, d
	lhld	wcnt		; work out bytes left to copy
	mov	b, h
	mov	c, l
	lxi	d, len
	call	@P0102
	shld	len
	mov	a, h
	ora	l
	jz	L4		; all done
	lhld	buf		; advance the buf pointer
	dad	b
	shld	buf
	pop	d		; cur offset
	pop	h		; buf size
	push	d
	push	h
	call	@P0099		; hl = m[de] - (bc = m[hl])
	jc	L3		; ok still room	in buffer
	lhld	file		; Write	what we	have
	mov	b, h
	mov	c, l
	call	Fflush		; flushFile(arg1w)

L3:	pop	h		; set as bufSize byte space available
	mov	e, m
	inx	h
	mov	d, m
	dcx	h
	xthl
	push	h
	jmp	L1

L4:	pop	h
	pop	h
	ret

	end
shared/memchk.asm
	public MEMCHK

	CSEG

MEMCHK:		
	call	0F81Bh
	mov	h, b
	mov	l, a
	ret

	end;
shared/movmem.asm
	public MOVMEM

	CSEG


; movmem(cnt, src, dest)

movmem:	pop	h		; hl = cnt arg
	xthl
	push	b		; src
	mov	b, h		; xchg hl,bc
	mov	c, l
	pop	h
	dcx	b
	mov	a, e
	sub	l
	mov	a, d
	jz	L1
	sbb	h
	jmp	L2

L1:	sbb	h
	rz

L2:	push	h
	lxi	h, L5
	jc	L3
	pop	h
	dad	b
	push	h
	xchg
	dad	b
	xchg
	lxi	h, L7

L3:	inx	b
	mov	a, b
	rrc
	rrc
	rrc
	mov	b, a
	mvi	a, 7
	ana	c
	push	psw
	xra	c
	rrc
	rrc
	rrc
	xra	b
	ani	1Fh
	xra	b
	mov	c, a
	mvi	a, 1Fh
	ana	b
	mov	b, a
	inr	b
	inr	c
	pop	psw
	rlc
	rlc
	push	b
	cma
	mov	c, a
	mvi	b, 0FFh
	inx	b
	dad	b
	pop	b
	xthl
	ret

L4:	mov	a, m
	stax	d
	inx	h
	inx	d
	mov	a, m
	stax	d
	inx	h
	inx	d
	mov	a, m
	stax	d
	inx	h
	inx	d
	mov	a, m
	stax	d
	inx	h
	inx	d
	mov	a, m
	stax	d
	inx	h
	inx	d
	mov	a, m
	stax	d
	inx	h
	inx	d
	mov	a, m
	stax	d
	inx	h
	inx	d
	mov	a, m
	stax	d
	inx	h
	inx	d

L5:	dcr	c
	jnz	L4
	dcr	b
	jnz	L4
	ret

L6:	mov	a, m
	stax	d
	dcx	h
	dcx	d
	mov	a, m
	stax	d
	dcx	h
	dcx	d
	mov	a, m
	stax	d
	dcx	h
	dcx	d
	mov	a, m
	stax	d
	dcx	h
	dcx	d
	mov	a, m
	stax	d
	dcx	h
	dcx	d
	mov	a, m
	stax	d
	dcx	h
	dcx	d
	mov	a, m
	stax	d
	dcx	h
	dcx	d
	mov	a, m
	stax	d
	dcx	h
	dcx	d

L7:	dcr	c
	jnz	L6
	dcr	b
	jnz	L6
	ret

	END

shared/putlst.asm
	public putLst
	extrn	wrcLst
	extrn	NlLead
	extrn	NewPgl
	extrn	PWIDTH
	extrn	tWidth
	extrn	margin
	extrn	skpCnt
	extrn	linLft
	extrn	col
	extrn	@P0029	; dehl@deDIVhl
	extrn	@P0094	; hl@0aSUBhl

	DSEG
i:	ds	2

	CSEG
putLst:			
	push	b
	lda	col
	ora	a
	jnz	L76B8
	lda	linLft
	ora	a
	jnz	L7695
	call	NewPgl
	jmp	L76BF

L7695:	mov	b, a
	lda	skpCnt
	cmp	b
	jc	L76A3
	call	NewPgl
	jmp	L76BF

L76A3:	ora	a
	jz	L76BF
	mvi	c, 0Ah
	call	wrcLst
	lxi	h, linLft
	dcr	m
	lxi	h, skpCnt
	dcr	m
	mov	a, m
	jmp	L76A3

L76B8:	lxi	h, PWIDTH
	cmp	m
	cnc	NlLead

L76BF:	pop	b
	mvi	a, 9
	cmp	c
	jnz	L770C
	lxi	h, margin
	lda	col
	cmp	m
	rc
	lxi	h, margin
	lda	col
	sub	m
	mov	e, a
	mvi	d, 0
	lhld	tWidth
	mvi	h, 0
	call	@P0029		; de = de/hl; hl = de %	hl
	mov	a, c
	call	@P0094
	xchg
	lxi	h, i
	mov	m, e
	lda	col
	add	e
	lxi	h, PWIDTH
	cmp	m
	jc	L76F8
	call	NlLead
	ret

L76F8:	mov	a, e

L76F9:	ora	a
	rz
	mvi	c, 20h
	call	wrcLst
	lxi	h, col
	inr	m
	lxi	h, i
	dcr	m
	mov	a, m
	jmp	L76F9

L770C:	push	b
	call	wrcLst
	pop	b
	mvi	a, 0Dh
	cmp	c
	lxi	h, col
	jnz	L771D
	mvi	m, 0
	ret

L771D:	inr	m
	ret

	end
shared/wrclst.asm
	extrn	lchCnt
	extrn	lbufp
	extrn	lbufsz
	extrn	lfopen
	extrn	lstFil
	extrn	OpenF
	extrn	WriteF
	extrn	@P0095		;hl@deSUBhl
	public	wrcLst

	
TRUE	equ	0ffh

	CSEG

wrcLst:	lhld	lchCnt
	xchg
	lhld	lbufp
	dad	d
	mov	m, c
	lhld	lbufsz
	call	@P0095
	ora	l
	jnz	L7DBA
	lda	lfOpen
	rar
	jc	L7DA3
	mvi	e, 2
	lxi	b, lstFil
	call	OpenF
	lxi	h, lfOpen
	mvi	m, TRUE

L7DA3:	lxi	b, lstFil
	push	b
	lhld	lbufsz
	inx	h
	xchg
	lhld	lbufp
	mov	b, h
	mov	c, l
	call	WriteF
	lxi	h, 0
	jmp	L7DBE


L7DBA:	lhld	lchCnt
	inx	h

L7DBE:	shld	lchCnt
	ret

	end
src/plm0c.asm
CSEG
	public gnxtch
	public ingetc
	extrn inChrp
	extrn GetLin
	extrn lastch
	extrn Readf
	extrn oCurCh
	extrn oLstCh
	extrn srcFil
	extrn inbuf
	public trunc
	public rsrcln

gnxtch:	lhld	inChrp
	inx	h
	shld	inChrp

L58E6:
	mov	a, m
	cpi	0Ah
	jnz	L58F5
	call	GetLin
	lhld	inChrp
	jmp	L58E6

L58F5:	sta	lastch
	ret

; inSrcCh
; get next char	into m[inChr$p]
; char is 0x81 on EOF, cr is discarded
; Attributes: hidden

ingetc:	lhld	oCurCh
	lxi	d, oLstCh	; see if characters left in buffer
	ldax	d
	cmp	l
	jnz	L593A
	inx	d
	ldax	d
	cmp	h
	jnz	L593A
	lxi	h, 0
	shld	oCurCh
	lxi	b, srcFil
	push	b
	lxi	b, inbuf
	push	b
	lxi	b, 200h
	lxi	d, oLstCh
	call	Readf
	lhld	oLstCh
	mov	a, h
	ora	l
	jnz	L5930
	lhld	inChrp
	mvi	a, 81h
	mov	m, a
	ret

L5930:	dcx	h
	shld	oLstCh
	lhld	oCurCh
	jmp	L593E

L593A:	inx	h
	shld	oCurCh

L593E:	lxi	b, inbuf
	dad	b
	mvi	a, 7Fh
	ana	m
	cpi	0Dh
	jz	ingetc		; inSrcCh
				; get next char	into m[inChr$p]
				; char is 0x81 on EOF, cr is discarded
	lhld	inChrp
	mov	m, a
	ret

	DSEG
i:	ds 1
trunc:	db 0

	CSEG

rSrcLn:
	lxi	h, i
	mvi	m, 7Fh		; max 127 chars
	lhld	inChrp
	mov	a, m

L5958:	cpi	0Ah
	rz
	cpi	81h
	rz
	lda	i
	dcr	a
	jz	L5972
	sta	i
	inx	h
	shld	inChrp
	call	ingetc		; inSrcCh
				; get next char	into m[inChr$p]
				; char is 0x81 on EOF, cr is discarded
	jmp	L5958

L5972:
	mvi	a, 0FFh
	sta	trunc

L5977:
	call	ingetc		; inSrcCh
				; get next char	into m[inChr$p]
				; char is 0x81 on EOF, cr is discarded
	cpi	0Ah		; waste	rest of	line
	rz
	cpi	81h
	rz
	jmp	L5977
end
