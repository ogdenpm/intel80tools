$EJECT
;******************************************************************************
;
;    NAME: DISASSEMBLY_CMD
;
;    ABSTRACT: This routine gets a token and partition and displays
;	<address>=. It then gets a byte of memory from code memory.
;	searches the hash table for a match to that byte and dissassembles
;	it if one is found.
;
;    INPUTS: None
;
;    OUTPUTS: None
;
;    VARIABLES MODIFIED: PARAM1, PARAM2, MEMORY_TRACE_ADDR_LOW,
;	MEMORY_TRACE_ADDR_HIGH, A, POINT1, PNTLOW, PNTHGH, SELECT,
;	TEMP_LOW, POINT0, PARTIT_LO_HIGH
;
;    ERROR EXITS: None
;
;    SUBROUTINES ACCESSED DIRECTLY: GETOKE, GET_PART, EOL_CHECK,
;	NEWLINE, LSTWRD, CO, FETCH, GET_HASH_VALUE, DISASSEMBLE,
;	CONTINUATION_LINE, WAIT_FOR_USER
;
;******************************************************************************
DISASSEMBLY_CMD:
	LCALL	GETOKE
	LCALL	GET_PART
	LCALL	EOL_CHECK
DS0:
	LCALL	NEWLINE
	MOV	PARAM1,PARTIT_LO_HIGH
	MOV	PARAM2,PARTIT_LO_LOW
	LCALL	LSTWRD
	MOV	PARAM1,#'='			;Display Adr = to console
	LCALL	CO
	MOV	MEMORY_TRACE_ADDR_LOW,PARTIT_LO_LOW
	MOV	MEMORY_TRACE_ADDR_HIGH,PARTIT_LO_HIGH
	MOV	POINT1,#000H
DS4:
	MOV	A,POINT1
	CJNE	A,#003H,DS1
DS1:
	JNC	DS2
	MOV	A,PARTIT_LO_LOW
	ADD	A,POINT1
	MOV	PNTLOW,A
	MOV	PNTHGH,PARTIT_LO_HIGH
	JNC	DS3
	INC	PNTHGH
DS3:	MOV	SELECT,#(CBYTE_TOKE AND 007H)
	LCALL	FETCH				;Get a byte from code memory
	MOV	TEMP_LOW,A
	MOV	A,#WORKING_SPACE
	ADD	A,POINT1
	MOV	POINT0,A
	MOV	@POINT0,TEMP_LOW
	INC	POINT1
	JMP	DS4
DS2:	LCALL	GET_HASH_VALUE			;Search hash table for match
	LCALL	DISASSEMBLE
	XCH	A,PARTIT_LO_LOW
	ADD	A,NUMBER_OF_BYTES
	XCH	A,PARTIT_LO_LOW
	JNC	DS5
	INC	PARTIT_LO_HIGH
DS5:	CLR	C
	MOV	A,PARTIT_HI_LOW
	SUBB	A,PARTIT_LO_LOW			;Subtract actual partition address low
						;From ending address and carry borrow
	MOV	A,PARTIT_HI_HIGH
	SUBB	A,PARTIT_LO_HIGH		;Subtract actual partition address high
						;From ending address high
	JC	DSRET				;Exit if carry generated
	LCALL	CONTINUATION_LINE
	JMP	DS0
DSRET:	LJMP	WAIT_FOR_USER
$EJECT
;******************************************************************************
;
;    NAME: GET_HASH_VALUE
;
;    ABSTRACT: This routine takes the hash value in OUR_CODE and
;	divides it into one the 4 ordinals. They are MEMONIC ORDINAL,
;	FIRST_OPER_ORDINAL, SECOND_OPER_ORDINAL and THIRD_OPER_ORDINAL.
;
;    INPUTS: WORKING_SPACE
;
;    OUTPUTS: MNEMONIC_ORDINAL, FIRST_OPER_ORDINAL, SECOND_OPER_ORDINAL,
;	THIRD_OPER_ORDINAL
;
;    VARIABLES MODIFIED: A, ERRNUM, DPTR, C, TEMP_LOW, OUR_CODE_LOW,
;	OUR_CODE_HIGH, DIVISOR, DIVIDEND_HIGH, DIVIDEND_LOW, PARAM5,
;	PARAM6, S, QUOTIENT_LOW, QUOTIENT_HIGH, MNEMONIC_ORDINAL,
;	NUMBER_OF_OPERANDS, FIRST_OPER_ORDINAL, SECOND_OPER_ORDINAL,
;	OPERAND_CHECK, NUMBER_OF_BYTES, THIRD_OPER_ORDINAL
;
;    ERROR EXITS: 0FH (UNDEFINED OPCODE)
;
;    SUBROUTINES ACCESSED DIRECTLY: ERROR, START_DIVIDE, OPERAND_BYTE_CHECK
;
;******************************************************************************
GET_HASH_VALUE:
	MOV	A,WORKING_SPACE			;Memory containing opcode to be
	CJNE	A,#UNDEFINED_OPCODE,HASH_CONTINUE ;disassembled
	MOV	ERRNUM,#00FH			;Undefined opcode
	LJMP	ERROR
HASH_CONTINUE:
	MOV	DPTR,#INSTRUCTION_CODE		;Starting adr of hash tbl
	CLR	C
	RLC	A				;Multiply pointer by two
	JNC	GHV_A1
	INC	DPH				;Increment DPH if rotate overflows
GHV_A1:	MOV	TEMP_LOW,A
	MOVC	A,@A+DPTR
	MOV	OUR_CODE_HIGH,A
	INC	TEMP_LOW
	MOV	A,TEMP_LOW
	MOVC	A,@A+DPTR
	MOV	OUR_CODE_LOW,A			;Ordinal of hashed value
	MOV	DIVISOR,#MNEMONIC_FACTOR
	MOV	DIVIDEND_HIGH,OUR_CODE_HIGH
	MOV	DIVIDEND_LOW,OUR_CODE_LOW
	CALL    START_DIVIDE
	MOV	PARAM5,QUOTIENT_LOW
	MOV	PARAM6,QUOTIENT_HIGH
	MOV	A,QUOTIENT_LOW
	MOV	B,#MNEMONIC_FACTOR
	MUL	AB
	MOV	QUOTIENT_LOW,A
	MOV	QUOTIENT_HIGH,B
	MOV	A,PARAM6
	MOV	B,#MNEMONIC_FACTOR
	MUL	AB
	ADD	A,QUOTIENT_HIGH
	MOV	QUOTIENT_HIGH,A
	MOV	A,OUR_CODE_LOW
	CLR	C
	SUBB	A,QUOTIENT_LOW
	MOV	MNEMONIC_ORDINAL,A		;Mnemonic ord
	MOV	OUR_CODE_HIGH,PARAM6
	MOV	OUR_CODE_LOW,PARAM5
	MOV	A,OUR_CODE_LOW
	JNZ	GHV1
	MOV	A,OUR_CODE_HIGH
	JNZ	GHV1
	MOV	NUMBER_OF_OPERANDS,#000H
	LJMP	GHV9
GHV1:
	MOV	DIVISOR,#OPERAND_FACTOR
	MOV	DIVIDEND_HIGH,OUR_CODE_HIGH
	MOV	DIVIDEND_LOW,OUR_CODE_LOW
	CALL	START_DIVIDE
	MOV	PARAM5,QUOTIENT_LOW
	MOV	PARAM6,QUOTIENT_HIGH
	MOV	A,QUOTIENT_LOW
	MOV	B,#OPERAND_FACTOR
	MUL	AB
	MOV	QUOTIENT_LOW,A
	MOV	QUOTIENT_HIGH,B
	MOV	A,PARAM6
	MOV	B,#OPERAND_FACTOR
	MUL	AB
	ADD	A,QUOTIENT_HIGH
	MOV	QUOTIENT_HIGH,A
	MOV	A,OUR_CODE_LOW
	CLR	C
	SUBB	A,QUOTIENT_LOW
	MOV	FIRST_OPER_ORDINAL,A		;First operand ord
	CJNE	A,#00FH,GHV2
	LJMP	GHV2_2
GHV2:
	JNC	GHV3
GHV2_2:
	DEC	FIRST_OPER_ORDINAL
GHV3:
	MOV	OUR_CODE_HIGH,PARAM6
	MOV	OUR_CODE_LOW,PARAM5
	MOV	A,OUR_CODE_LOW
	JNZ	GHV5
	MOV	A,OUR_CODE_HIGH
	JNZ	GHV5
	MOV	NUMBER_OF_OPERANDS,#001H
	LJMP	GHV9
GHV5:
	MOV	SECOND_OPER_ORDINAL,OUR_CODE_LOW ;Second operand ord
	MOV	A,SECOND_OPER_ORDINAL
	CJNE	A,#00FH,GHV6
	LJMP	GHV6_6
GHV6:
	JNC	GHV7
GHV6_6:
	DEC	SECOND_OPER_ORDINAL
GHV7:
	MOV	NUMBER_OF_OPERANDS,#002H
GHV9:
	MOV	A,MNEMONIC_ORDINAL
	CJNE	A,#009H,GHV10
	MOV	NUMBER_OF_BYTES,#002H
	MOV	THIRD_OPER_ORDINAL,#016H
	LJMP	GHV11
GHV10:
	MOV	NUMBER_OF_BYTES,#001H
GHV11:
	MOV	DPTR,#GHVTBL
	MOV	A,NUMBER_OF_OPERANDS
	MOV	OPERAND_CHECk,FIRST_OPER_ORDINAL
	RL	A
	JMP	@A+DPTR
GHVTBL:
	RET					;Entry 1 for GHVTBL
	NOP
	SJMP	OPERAND_BYTE_CHECK		;Entry 2 for GHVTBL
	LCALL	OPERAND_BYTE_CHECK		;Entry 3 for GHVTBL
	MOV	OPERAND_CHECK,SECOND_OPER_ORDINAL

$EJECT
;******************************************************************************
;
;    NAME: OPERAND_BYTE_CHECK
;
;    ABSTRACT: This routine is updating the number of bytes in the
;	opcode based on OPERAND_CHECK.
;
;	CAUTION: This routine is position sensitive. It is entered from
;	the previous routine, GET_HASH_VALUE as 'in line' code.
;
;    INPUTS: OPERAND_CHECK
;
;    OUTPUTS: NUMBER_BYTES
;
;    VARIABLES MODIFIED: A, NUMBER_OF_BYTES
;
;    ERROR EXITS: None
;
;    SUBROUTINES ACCESSED DIRECTLY: None
;
;
;******************************************************************************
OPERAND_BYTE_CHECK:
	MOV	A,OPERAND_CHECK
	CJNE	A,#010H,OBC0
OBC0:
	JC	OBC1
	CJNE	A,#016H,OBC2
	LJMP	OBC2_2
OBC2:
	JNC	OBC1
OBC2_2:
	INC	NUMBER_OF_BYTES
OBC1:
	CJNE	A,#014H,OBCRET
	INC	NUMBER_OF_BYTES
OBCRET:	RET
$EJECT
;******************************************************************************
;
;    NAME: DISPLAY_OPERAND
;
;    ABSTRACT: This routine displays an operand of the disassembled
;	opcode to the console.
;
;    INPUTS: NUNBER_OF_OPERANDS_PRINTED, FIRST_OPER_ORDINAL,
;	SECOND_OPER_ORDINAL, THIRD_OPER_ORDINAL
;
;    OUTPUTS: NUMBER_OF_OPERANDS_PRINTED
;
;    VARIABLES MODIFIED: A, DPTR, CURRENT_OPERAND, C, PARAM1, POINT0,
;	VALHGH, VALLOW, PARAM2, EXPRESSIONS_PRINTED, MEMORY_TRACE_ADDR_HIGH,
;	TEMP_LOW, NO_OF_OPERANDS_PRINTED
;
;    ERROR EXITS: None
;
;    SUBROUTINES ACCESSED DIRECTLY: DISPLAY_TOKEN, LSTBYT, CO, LSTWRD,
;	PRINT STRING
;
;
;******************************************************************************
DISPLAY_OPERAND:
	MOV	A,NO_OF_OPERANDS_PRINTED
	DEC	A
	RL	A
	RL	A
	MOV	DPTR,#DDTBL
	JMP	@A+DPTR
DDTBL:	MOV	A,FIRST_OPER_ORDINAL
	SJMP	DD0
	MOV	A,SECOND_OPER_ORDINAL
	SJMP	DD0
	MOV	A,THIRD_OPER_ORDINAL
DD0:	MOV	CURRENT_OPERAND,A
	CJNE	A,#00CH,DD0_1
	MOV	A,#0A1H
	LJMP	DD4_1
DD0_1:	CJNE	A,#00FH,DD1
	LJMP	DD1_1
DD1:	JNC	DD2
DD1_1:	CJNE	A,#003H,DD3
DD3:	JC	DD4
	CJNE	A,#00AH,DD5
	LJMP	DD5_5
DD5:	JNC	DD4
DD5_5:	CLR	C
	ADD	A,#08DH
	LJMP	DD4_1
DD4:	CLR	C
	ADD	A,#(OFST + REG + 1)
DD4_1:	MOV	PARAM1,A
	LCALL	DISPLAY_TOKEN
DD2:	MOV	A,CURRENT_OPERAND
	CLR	C
	SUBB	A,#010H
	CJNE	A,#000H,DD_CASE_1		;Byte expression 8-bits
DD_CASE_EXP8:					;Generalized byte expression display
	MOV	A,#WORKING_SPACE
	ADD	A,EXPRESSIONS_PRINTED
	MOV	POINT0,A
	MOV	A,@POINT0
	MOV	PARAM1,A
	LCALL	LSTBYT
	INC	EXPRESSIONS_PRINTED
	LJMP	DD_CASE_END
DD_CASE_1:
	CJNE	A,#001H,DD_CASE_2		;Bit expression, 8-bits
	JMP	DD_CASE_EXP8
DD_CASE_2:
	CJNE	A,#002H,DD_CASE_3		;Immediate expression, 8-bits
	MOV	PARAM1,#'#'
	LCALL	CO
	JMP	DD_CASE_EXP8
DD_CASE_3:
	CJNE	A,#003H,DD_CASE_4		;Complimented byte expression, 8-bits
	MOV	PARAM1,#'/'
	LCALL	CO
	JMP	DD_CASE_EXP8
DD_CASE_4:
	CJNE	A,#004H,DD_CASE_5		;Expression, 16-bits
	MOV	POINT0,#WORKING_SPACE
	INC	POINT0
	MOV	VALHGH,@POINT0
	INC	POINT0
	MOV	VALLOW,@POINT0
	MOV	A,MNEMONIC_ORDINAL
	CJNE	A,#00FH,DD_CASE_4_0
	MOV	PARAM1,#'#'
	LCALL	CO
DD_CASE_EXP16:					;Generalized word expression display
	MOV	PARAM1,VALHGH
	MOV	PARAM2,VALLOW
	LCALL	LSTWRD
	LJMP	DD_CASE_END
DD_CASE_4_0:
	MOV	A,CURRENT_OPERAND
	CJNE	A,#014H,SS0
	LJMP	SS3
SS0:	CJNE	A,#21,SS1
	LJMP	SS3
SS1:	CJNE	A,#016H,SS2
SS3:	MOV	PARAM1,VALHGH
	MOV	PARAM2,VALLOW
	LCALL	LSTWRD
	LJMP	DD_CASE_END
SS2:	MOV	PARAM1,VALLOW
	LCALL	LSTBYT
	LJMP	DD_CASE_END
DD_CASE_5:
	CJNE	A,#005H,DD_CASE_6		;Expression, 11-bits
	MOV	POINT0,#WORKING_SPACE
	MOV	A,@POINT0
	ANL	A,#0E0H
	SWAP	A
	RR	A
	MOV	VALHGH,A
	INC	POINT0
	MOV	VALLOW,@POINT0
	JMP	DD_CASE_EXP16
DD_CASE_6:
	CJNE	A,#006H,DD_CASE_7		;Relative offset
	MOV	A,MEMORY_TRACE_ADDR_LOW
	ADD	A,NUMBER_OF_BYTES
	MOV	MEMORY_TRACE_ADDR_LOW,A
	JNC	DD_CASE_6_0
	INC	MEMORY_TRACE_ADDR_HIGH
DD_CASE_6_0:
	MOV	A,#WORKING_SPACE
	ADD	A,EXPRESSIONS_PRINTED
	MOV	POINT0,A
	MOV	A,@POINT0
	CJNE	A,#007FH,DD_CASE_6_1
	LJMP	DD_CASE_6_2
DD_CASE_6_1:
	JC	DD_CASE_6_2
	CPL	A
	INC	A
	MOV	TEMP_LOW,A
	MOV	A,MEMORY_TRACE_ADDR_LOW
	CLR	C
	SUBB	A,TEMP_LOW
	MOV	VALLOW,A
	MOV	A,MEMORY_TRACE_ADDR_HIGH
	JNC	DD_CASE_6_3
	DEC	A
DD_CASE_6_3:
	MOV	VALHGH,A
	LJMP	DD_CASE_6_5
DD_CASE_6_2:
	ADD	A,MEMORY_TRACE_ADDR_LOW
	MOV	VALLOW,A
	MOV	A,MEMORY_TRACE_ADDR_HIGH
	JNC	DD_CASE_6_4
	INC	A
DD_CASE_6_4:
	MOV	VALHGH,A
DD_CASE_6_5:
	INC	EXPRESSIONS_PRINTED
	JMP	DD_CASE_EXP16
DD_CASE_7:
	CJNE	A,#007H,DD_CASE_8		;Special case for @A+DPTR
	MOV	PARAM1,#HIGH(DD_CASE_7_MSG)
	MOV	PARAM2,#LOW(DD_CASE_7_MSG)
	LCALL	PRINT_STRING
	LJMP	DD_CASE_END
DD_CASE_7_MSG:
	DB	07,'@A+DPTR'
DD_CASE_8:
	CJNE	A,#8,DD_CASE_END		;Special case for @A+PC
	MOV	PARAM1,#HIGH(DD_CASE_8_MSG)
	MOV	PARAM2,#LOW(DD_CASE_8_MSG)
	CALL	PRINT_STRING
	LJMP	DD_CASE_END
DD_CASE_8_MSG:
	DB	05,'@A+PC'
DD_CASE_END:
	INC	NO_OF_OPERANDS_PRINTED
	RET
$EJECT
;******************************************************************************
;
;    NAME: DISPLAY_COMMA
;
;    ABSTRACT: This routine displays a comma symbol to the console.
;
;    INPUTS: None
;
;    OUTPUTS: None
;
;    VARIABLES MODIFIED: PARAM1
;
;    ERROR EXITS: None
;
;    SUBROUTINES ACCESSED DIRECTLY: CO
;
;
;******************************************************************************
DISPLAY_COMMA:
	MOV	PARAM1,#','
	LJMP	CO
$EJECT
;******************************************************************************
;
;    NAME: DISASSEMBLE
;
;    ABSTRACT: This routine displays one disassembled opcode on the
;	console.
;
;    INPUTS: MNEMONIC_ORDINAL
;
;    OUTPUTS: None
;
;    VARIABLES MODIFIED: A, PARAM1, DPTR, INSTRUCTION_VALUE,
;	NO_OF_OPERANDS_PRINTED, EXPRESSIONS_PRINTED, C
;
;    ERROR EXITS: None
;
;    SUBROUTINES ACCESSED DIRECTLY: DISPLAY_TOKEN, CO, DISPLAY_OPERAND,
;	DISPLAY_COMMA
;
;******************************************************************************
DISASSEMBLE:
	MOV	A,MNEMONIC_ORDINAL
	ADD	A,#OFST
	MOV	PARAM1,A
	LCALL	DISPLAY_TOKEN
	MOV	DPTR,#MNEMONIC_TAB
	MOV	A,MNEMONIC_ORDINAL
	MOVC	A,@A+DPTR
	MOV	INSTRUCTION_VALUE,A
	MOV	PARAM1,#' '
	LCALL	CO
	MOV	NO_OF_OPERANDS_PRINTED,#1
	MOV	EXPRESSIONS_PRINTED,#1
	MOV	A,INSTRUCTION_VALUE
	CLR	C
	SUBB	A,#007H
	CJNE	A,#000H,DISCASE_1
	RET
DISCASE_1:
	CJNE	A,#001H,DISCASE_2
	JMP	DISPLAY_OPERAND
DISCASE_2:
	CJNE	A,#002H,DISCASE_3
	MOV	A,WORKING_SPACE
	CJNE	A,#085H,DISCASE_2_1		;Check for special case of MOV
	MOV	A,(WORKING_SPACE + 1)		; /,/ where operands are in
	MOV	(WORKING_SPACE + 1),(WORKING_SPACE + 2)	;reverse order.
	MOV	(WORKING_SPACE + 2),A
DISCASE_2_1:
	CALL	DISPLAY_OPERAND
	CALL	DISPLAY_COMMA
	JMP	DISPLAY_OPERAND
DISCASE_3:
	CJNE	A,#003H,DISCASE_4
	CALL	DISPLAY_OPERAND
	CALL	DISPLAY_COMMA
	JMP	DISPLAY_OPERAND
DISCASE_4:
	CJNE	A,#004H,DISCASE_5
	CALL	DISPLAY_OPERAND
	CALL	DISPLAY_COMMA
	CALL	DISPLAY_OPERAND
	CALL	DISPLAY_COMMA
	JMP	DISPLAY_OPERAND
DISCASE_5:
	CJNE	A,#005H,DISCASE_6
	JMP	DISPLAY_OPERAND
DISCASE_6:
	CJNE	A,#006H,DISCASE_7
	CALL	DISPLAY_OPERAND
	CALL	DISPLAY_COMMA
	JMP	DISPLAY_OPERAND
DISCASE_7:
	CJNE	A,#007H,DISCASE_8
	JMP	DISPLAY_OPERAND
DISCASE_8:
	CJNE	A,#008H,DISCASE_END
	CALL	DISPLAY_OPERAND
DISCASE_END:
	RET
