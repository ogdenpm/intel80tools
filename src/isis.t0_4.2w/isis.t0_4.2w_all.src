aldadr.plm
aldadr: do;
$include(aldadr.ipx)
    /*
        aldadr loads the absolute ISIS file into memory
        hdrblk - location of ISIS file
    
        returns - address where file is loaded
        the format of the file is basically the content records
        from an normal isis executable with the record type, segment id and CRC removed
    */

aldadr: PROCEDURE(hdrblk) ADDRESS public;
    /* load into memory the abs load file at 'hdrblk' */
    DECLARE hdrblk ADDRESS;
    DECLARE buf(128) BYTE, bufptr BYTE;
    DECLARE pointers(64) ADDRESS, ptrptr BYTE;
    DECLARE loadadr ADDRESS, target BASED loadadr BYTE;
    DECLARE length ADDRESS;

    DECLARE FLINK   LITERALLY   '1';    /* indexes into the pointers array */

    l1b: PROCEDURE; /* load 1 byte from buffer into memory */
        target = buf(bufptr);   
        bufptr = bufptr + 1;
        length = length - 1;
        loadadr = loadadr + 1;
    end;

    g128b: PROCEDURE(bufadr); /* get 128 bytes into buffer at bufadr */
        DECLARE bufadr ADDRESS;

        if (ptrptr := ptrptr + 1) = 64 then
        do;
            if pointers(FLINK) = 0 then
                call mdsmon;
            call absio(DISK$READ, stat AND 0fh, pointers(FLINK), .pointers);
            ptrptr = 2;
        end;
        if pointers(ptrptr) = 0 then
            call mdsmon;
        call absio(DISK$READ, stat AND 0fh, pointers(ptrptr), bufadr);
    end;

    g1b: PROCEDURE BYTE;    /* get 1 byte */
        if (bufptr AND 7Fh) = 0 then
        do;
            call g128b(.buf);
            bufptr = 0;
        end;    
        bufptr = bufptr + 1;
        return buf(bufptr - 1);
    end;

    g2b: PROCEDURE ADDRESS; /* get 2 bytes */
        return g1b + (256 * g1b);
    end;




    pointers(FLINK) = hdrblk;   /* initialisze g128b */
    ptrptr = 63;
    bufptr = 0;

start$loading$next$record:
    do while TRUE;
        length = g2b;
        loadadr = g2b;
        if length = 0 then
            return loadadr;
        do while bufptr <> 128;
            if length > 0 then
                call l1b;
            else
                goto start$loading$next$record;
        end;
        do while length >= 128;
            call g128b(loadadr);
            loadadr = loadadr + 128;
            length = length - 128;
        end;
        
        bufptr = 0;
        if length <> 0 then
        do;
            call g128b(.buf);
            do while length > 0;
                call l1b;
            end;
        end;
    end;
    return loadadr; /* cannot reach here !! */
end;
end;


boot.asm
    public  CO, CI, CSTS
    public  IOCHK
    public  IOSET
    public  ISIS
    extrn   t0boot;

    ASEG
isis    equ 40h
CO      equ 0F809h
CI      equ 0F803h
CSTS    equ 0F812h
IOCHK   equ 0F815h
IOSET   equ 0F818h
IOCCOM  equ 0F841h
IOCDR1  equ 0F821h
IOCDR2  equ 0F844h
WPBC    equ 15h     ; write parameter block command
WPCC    equ 16h     ; write parameter block command continuation

    CSEG

    jmp t0boot
    db  '            4'  ; likley to be junk filler

    mov b, c
    jmp IOCDR1      ; call the bios directly

triopb:
    push b
    pop h
    mov c, m        ; data
    mvi b, WPBC     ; WPBC - enables 1st of 5 diskette operation bytes
    call    IOCDR2
    mvi d, 4        ; 4 remaining bytes

trloop:     
    inx h
    mov c, m        ; data
    mvi b, WPCC     ; WPBCC - enables bytes 2-5 of disket operation bytes
    call    IOCDR2
    dcr d
    jnz trloop
    ret

    end

config.plm
config: do;
$include(config.ipx)
/*
  config dtermins the configuration of disk drive on the system and
      puts the information into an array called config$table which, is
  composed of 6 seperate sub arrays each, of 10 bytes one for the
  possible number of drives

  The procedure inputs from the ports associated with, the disk controllers.
  It determines whether the floppy drives is double density, single density or
  integrated single density. It also it a hard drive is present in which, case this
  is used for drives F0..F3.

  The config$able is significantly different from that documented in the isis internals document
  in that it has six sets of information
  t0$dk$cf$tb(x) which, drives the control logic as follows.
         1 for double density, 2 for single density
         3 for integrated single density and 4 for the hard disk
  t0$dk$ct$tb(x) indicates the controller used as follows. 
         1 for the controller at 78h, 2 for controller at 88h
         3 for integrated controller and 4 for the hard disk
   
  t0$unitmp(x)   bit mask to select the drive
  t0$rdymsk(x)   bit mask to determine if the drive is ready
  t0$tracksTable(x)    the number of logical tracks on the drive
  t0$sectorsTable(x)   the number of logical sectors per track

*/ 
/* the winchester device information */
/* declare the winchester control blocks that are in isis.bin */
/* WINLOC is defined in the pex file */
declare wiSbuf(12) byte public at (WINLOC - 12),
        wiWake WWAKE$T public at(WINLOC),
        wiCcb WCCB$T public at(WINLOC + 6),
        wiCtlb WCONTROL$T public at(WINLOC + 16h),
        wiIopb WDCB$T public at(WINLOC + 26h);
declare wiInit(68) byte external;   /* the initialisation values in diskio.asm */
declare dkcont byte public at(DKCONTLOC);  /* in isis.bin */
declare cdksat address public at(CDKSATLOC);  /* in isis.bin */

config: PROCEDURE public;
   DECLARE i BYTE, padding BYTE, addr ADDRESS, byt BASED addr BYTE;
   declare badDiskPortWord address at(.badDiskPort);
   declare wiRevision byte at (.wiIopb.actual(0));
   cli(2) = '0';   /* write the disk drive for the cli load */
   call clrtables;

   stat = INPUT(FDCC$STATUS$0);
   if (stat AND CON$MASK) <> 0 then
       if (stat AND DD$MASK) <> 0 then /* double density */
           /* create F0-F3 */
           call setConfig(.ddConfig);
       else
           /* create F0-F1 */
           call setConfig(.sdConfig);
   stat = INPUT(FDCC$STATUS$1);
   if (stat and CON$MASK) <> 0 then
       if (stat AND DD$MASK) <> 0 then /* only single density supported */
       do;
           badDiskPort = '8';  /* convert port to 88H */
           call errBadDiskDev;
       end;
       else
       do;
           i = 2;
           if t0$dk$cf$tb(2) = 0 then
               if t0$dk$cf$tb(3) = 0 then
                   i = 0;
           /* add to more drives, F2-F3 if first are single density else F4-F5 */
           sdConfig.slot = i + 2;
           sdConfig.endslot = i + 3;
           sdConfig.ctlId = FDCC1$CONTROLLER;
           call setConfig(.sdConfig);
       end;
   /* determine if system is an MDS or INTELLEC. if it is an
      INTELLEC, then read statys of the integrated single
      density controller and fill config$table accordingly */

   if sys$flg = 1 then /* system is an INTELLEC */
   do;
       output(0ffh) = 0dh;
       i = 25;
wait1: do;  /* input DBB status; loop until F0 = IBF = OBF = 0 */
       if (INPUT(0c1h) AND 7) <> 0 then
           if (i := i - 1) <> 0 then
               goto wait1;
       end;
       if i = 0 then
           output(0FFh) = 5;
       else
       do;
           OUTPUT(0c1h) = RDSTS$COMMAND;
           i = 250;    
    wait2: do;  /* input DBB status; loop until F0 = IBF = OBF = 0 */
            if (INPUT(0c1h) AND 7) <> 1 then 
               if (i := i - 1) <> 0 then
                   goto wait2;
           end;
           if i = 0 then
               output(0ffh) = 5;
           else
           do;
               stat = input(0c0h);
               output(0ffh) = 5;
               if (stat AND CON$MASK) <> 0 then
                   if t0$dk$cf$tb(0) = 0 then
                       call setConfig$ISD(0);
                   else
                       call setConfig$ISD(4);
           end;
       end;
   end;
   call move(double(68), .wiInit, WINLOC);
   output(5) = 2;      /* reset the iSBC 215G board */
   output(5) = 0;      /* clear the reset */
   output(5) = 1;      /* establish, host-iSBC communications */
   do i = 0 to 255;    /* delay */
   end;
   if wiccb.busy1 = 0 then  /* reset complete */
   do;
       errdisk = 0;
       wiIopb.buffer(0) = .wiDevParam;
       wiIopb.unit = 0;
x:  /* force hl reload !! */
       wiIopb.function = 0;    /* initialize */
       dkcont = WD$CONTROLLER;
       call startio(.wiIopb);
       if (cdksat := rbyte) <> 0 then
       do;
           if (cdksat and 1fh) <> 0fh then
               call err(DISK$IO$ERROR);
           else
               cli(2) = '4';
       end;
       else if (wiRevision and 3) <> 1 then /* mask off ver & revision */
       do;
           badDiskPortWord = '50';
           call errBadDiskDev;
       end;
       wiDevParam(0), wiDevParam(1), wiDevParam(2), wiDevParam(3) = 0;
       do i = 1 to 3;      /* take devices 1-3 offline */
           wiIopb.buffer(0) = .wiDevParam;
           wiIopb.unit = i;
           wiIoPb.function = 0;    /* initialise */
           dkcont = WD$CONTROLLER;
           call startio(.wiIopb);
           if (cdksat := rbyte) <> 0 then
               call err(DISK$IO$ERROR);
       end;
   wiIopb.unit = 0;
   call insert;
   call setConfig(.wdConfig);
   end;
end;

/*
  sets the location of the isis.bin file which, is located
  at slightly different positions based on the boot drive
*/
setIsisHdrBlk: PROCEDURE public;
   stat = cli(2);
   temp = t0$dk$cf$tb(cli(2) AND 0Fh);
   if temp = WD$TYPE then
       hdr$blk = 22Eh;     /* winchester drive */
   else if temp = DD$TYPE then
       hdr$blk = 206h;     /* double density drive */
   else
       hdr$blk = 204h;     /* single density - track 2 sector 4 */
end;

end;
consol.plm
console:
do;
$include(consol.ipx)

consol: procedure (ci$p, co$p, status$p) public;
    declare (ci$p, co$p, status$p) address;
    call ISIS(ICONSOL, .ci$p);
end consol;
end;
eof

diskio.asm
        name diskio
        extrn wiSbuf, wiWake, wiCcb, wiCtlb, wiIopb     ; locations of winchster control blocks
        extrn dkcont, tdcttb, tuntmp, trdymk, errdsk
        extrn cdksat
        extrn err
        extrn @P0029, @P0016
        cseg
; /*
;    diskio provides access to the FDCC and HD controllers
;    controller 1 = base address 78h, (drives 0, 1, 2, 3 for DD
;                     drives 0, 1 for SD)
;    controller 2 = base address 88h (drives 2, 3 for SD
;                     or drives 4,5 when 0-3 is DD)
;    Intergrated single density controller = port 0c1h
;    hard disk controller = base address 68h (drives 0, 1, 2, 3 if present
;                         also all other drives shited up
;                         to 4+)

;    drive: an integer 0-9, specifying the disk to be accessed
;    iopb:  the address of a parameter block to be sent to the
;       FDCC/HD controller. This parameter must be set up
;       as if it were for drive 0; if 'drive' selects
;       another drive, 'diskio' will set all the necessary
;       bits

;    The caller provides a parameter block specifying some
;    valid disk operation on drive 0 and an integer drive select value
;    in this boot code only READ and RECAL are used
;    The procedure waits for the controller to go unbusy, then
;    performs the desired action. In case of a controller error,
;    the disk drive is recalibrated and the action is tried again.
;    If successful completion cannot be obtained after 'MAX$RETRIES'
;    attempts, a fatal error occurs, otherwise a normal return is made

; */
IOCCOM  equ 0F841h
IOCDR1  equ 0F821h
IOCDR2  equ 0F844h
WPBC    equ 15h     ; write parameter block command
WPCC    equ 16h     ; write parameter block command continuation
; DECLARE recal$pb STRUCTURE(
;         iocw BYTE,
;         ioins BYTE,
;         nsec BYTE,
;         tadr BYTE,
;         sadr BYTE) INITIAL(80h, 3, 1, 0, 0);
rcalpb: db  80h, 3, 1, 0, 0
; DECLARE readDCB STRUCTURE(
;         iocw BYTE,  /* channel word */
;         ioins BYTE, /* instruction */
;         nsec BYTE,  /* number of sectors */
;         tadr BYTE,  /* track address */
;         sadr BYTE,  /* sector address */
;         buf ADDRESS)    /* buffer address */
;         INITIAL(80h, 0, 1, 0, 0, 0);
rddcb:  db  80h, 0, 1, 0, 0
        dw  0


;     DECLARE temp ADDRESS,  (temp2, temp1) BYTE AT (.temp);
temp:
temp2:  db  0ffh
temp1:  db  0ffh
drive:  db  0ffh        ; initialised with junk?
iopb:   dw  0
i:      db  0ffh
realtk: dw  0
ival:   db  0ffh

; winchester disk structure initialisation
;     declare offsets(4) address data(0, 128, 256, 384);
offset: dw  0, 80h, 100h, 180h

        public  wiInit
wiInit:                 ; see config.plm for the data structure details
; wake control block
        db  1, 0        ; wake reserved
        dw  wiCcb,0     ; location of chanel control block
; channel control block
        db  1, 0ffh     ; ccw1 & busy1
        dw  wiCtlb+4, 0 ; address of wiCtlb.csa
        dw  0           ; reserved
        db  1, 0        ; ccw2 & busy2
        dw  wiccb+14, 0 ; address of wccb.controlPtr
        dw  4           ; control pointer
; controller invocation block
        db  0, 0, 0, 0ffh ; res1, opStatus, cmdSem, stSem
        dw  0, 0        ; csa
        dw  wiIopb, 0   ; address of iopb
        dw  0, 0        ; res2
; io parameter block
        dw  0, 0, 0, 0  ; reserved & actual
        dw  0           ; device
        db  0, 0        ; unit & function
        dw  1, 0        ; modifier & cylinder
        db  0, 0        ; head & sector
        dw  0, 0, 0, 0  ; buffer & count
        dw  0, 0        ; general address pointer

        
; diskio: PROCEDURE(drive, iopb);
;     DECLARE drive BYTE, iopb ADDRESS;
;     declare realtk address;
;     DECLARE ival BYTE;

cfgbse  equ 858h        ; config base
        public  diskio
diskio:
        lxi     h,iopb+1
        mov     m, d
        dcx     h
        mov     m, e
        dcx     h
        mov     m, c
        lxi     b, 3
        lhld    iopb
        dad     b
        mov     a, m            ; issTrk  = dcb.tadr;
        sta     cfgbse + 61           
        inx     h
        mov     a, m
        sta     cfgbse + 62     ; issSec = dcb.sadr;
        dcr     a
        sta     wiIopb+17       ; wiIopb.sector = issSec - 1;
        in      0FCh
        sta     ival            ; ival = input(0fch);
        ori     2
        out     0FCh            ; output(0fch) = ival or 2;
        lhld    drive           ; dkcont = t0$dk$ct$tb(drive);
        mvi     h, 0
        lxi     b, tdcttb
        dad     b
        mov     a, m
        sta     dkcont          ; if dkcont = WD$CONTROLLER then
        cpi     9
        jnz     L3669           ; do;
        lxi     b, 3            ;     realTk = double(dcb.tadr) * 3;
        lhld    iopb
        dad     b
        mov     l, m
        mov     c, l
        mvi     h, 0
        dad     h
        dad     b
        shld    realTk
        lxi     h, wiIopb+11h   ;     if wiIopb.sector >= 140 then
        mov     a, m
        cpi     8Ch
        jc      L360C           ;     do;
        sui     8Ch             ;         wiIopb.sector = wiIopb.sector - 140;
        mov     m, a
        lhld    realTk          ;         realTk = realTk + 2;
        inx     h
        inx     h
        shld    realTk
        jmp     L361B           ;     end;
L360C:                          ;     else if wiIopb.sector >= 70 then
        cpi     46h
        jc      L361B           ;     do;
        sui     46h             ;         wiIopb.sector = wiIopb - 70;
        mov     m, a
        lhld    realTk          ;         realTk = realTk + 1;
        inx     h
        shld    realTk          ;     end;
L361B:
        lhld    realTk          ;     wiIopb.head = realTk mod 5;
        xchg
        lxi     h, 5
        call    @P0029
        mov     a, l
        sta     wiIopb+16
        lhld    drive           ;     wiIopb.cyl = realTk / 5 + offsets(drive);
        mvi     h, 0
        lxi     b, offset
        dad     h
        dad     b
        call    @P0016
        shld    wiIopb+14
        lhld    iopb            ;     if (dcb.ioins and 0fh) <> CMD$READ then
        inx     h
        mov     a, m
        ani     0Fh
        cpi     4
        jz      L3648           ;         if (dcb.ioins and 0fh) <> CMD$WRITE then
        cpi     6
        rnz                     ;             return
L3648:
        sta     wiIopb+11       ;     wiIopb.function = dcb.ioins and 0fh;
        inx     h               ;     wiIopb.count(0) = dcb.nsec * 128;
        mov     a, m
        stc
        cmc
        rar
        sta     wiIopb+23
        mvi     a, 0
        rar
        sta     wiIopb+22
        inx     h               ;     wiIopb.buf(0) = dcb.buf;
        inx     h
        inx     h
        mov     e, m
        inx     h
        mov     d, m
        xchg
        shld    wiIopb+18
        lxi     h, wiIopb       ;     iopb2 = .wiIopb;
        jmp     dexit      ;    ;     goto dexit;
                           ; end;
L3669:                     ; else
                           ; do;
        lhld    drive      ;     dcb.ioins = t0$unit$mp(drive) or dcb.ioins;
        mvi     h, 0
        lxi     b, tuntmp
        dad     b
        mov     a, m
        lhld    iopb
        inx     h
        ora     m
        mov     m, a
        lxi     h, i        ;     do i = 0 to MAX$RETRIES;
        mvi     m, 0
L367E:
        mvi     a, 0Ah
        cmp     m
        jc      L36F2
L3684:
        call    dkstat      ;         do while (disk$stat and 4) <> = 0; 
        ani     4
        cpi     0
        jz      L3697
        call    rtype       ;             temp1 = r$type;   /* assignments removed in asm */
        call    rbyte       ;             temp1 = r$byte;
        jmp     L3684       ;         end;
L3697:                                   ;         CODE XREF: diskio+DD?j
        call    dkstat      ;         if (disk$stat and t0$rdy$msk(drive)) = 0 then
        lhld    drive
        mvi     h, 0
        lxi     b, trdymk
        dad     b
        ana     m
        cpi     0
        jnz     L36AE
        mvi     c, 1Eh      ;             call abortx(DRIVE$NOT$READY);
        call    err 
L36AE:
        lhld    iopb        ;         iopb2 = iopb;
dexit:                      ;     dexit: /* shared diskio exit code */
        mov     b, h        ;         call strtio(iopb2);
        mov     c, l
        call    strtio
        call    rtype       ;         temp1 = rtype;
        sta     temp1
        call    rbyte       ;         if (temp1 := rbyte) = 0 then
        sta     temp2
        cpi     0
        jnz     L36CD       ;         do;
        lda     ival        ;             output(0fch) = ival;
        out     0FCh
        ret                 ;             return;
                            ;         end;
L36CD:
        lda     dkcont      ;         if dkcont = WD$CONTROLLER then
        cpi     9
        jz      L36F2       ;             goto L36F2;
        lhld    drive       ;          rcal$pb.ioins = rcal$pb.ioins or unit$mp(drive);
        mvi     h, 0
        lxi     b, tuntmp
        dad     b
        lda     rcalpb+1
        ora     m
        sta     rcalpb+1
        lxi     b, rcalpb
        call    strtio      ;         call strtio(.rcalpb);
        lxi     h, i        ;     end
        inr     m
        jnz     L367E
L36F2:                      ; end;
        lda     drive       ; errdisk = drive;
        sta     errdsk
        lhld    temp        ; cdksat = temp;
        shld    cdksat
        mvi     c, 18h      ; call abortx(DISK$IO$ERROR);
        call    err
        ret
; end



;     /* asbio: accomplishes the transfer of 128 bytes of data from the disk */
;     /*
;        disk     the drive from which, to read
;        block    high, byte is track number, low byte is the sector number
;        buffer$ptr   the address of a 128 byte buffer in ram
;     */
;     absio: PROCEDURE (cmd, disk, block, buffer$ptr) public;
;         DECLARE (cmd, disk) BYTE, (block, buffer$ptr) ADDRESS;
;         readDCB.buf = buffer$ptr;
;         readDCB.sadr = low(block);
;         readDCB.tadr = high(block);
;         readDCB.ioins = DISK$READ;
;         call diskio(disk, .readDCB);
;     end;
        public absio
absio:
        xchg
        shld    rddcb+5
        lxi     h,rddcb+4
        mov     m,c
        dcx     h
        mov     m,b
        pop     d
        pop     b
        mov     a,c
        pop     b
        push    d       ; return address
        dcx     h
        dcx     h
        mov     m,c
        mov     c,a
        lxi     d,rddcb
        call    diskio
        ret

;  /* return the disk drive status */
;  disk$stat: PROCEDURE BYTE;
dkstat: lda     dkcont      ; if dkcont = 0 then return
        ora     a
        rz
        cpi     9           ; if dkcont <> WD$CONTROLLER then
        jz      L3736
        cpi     3           ;     if dkcont = ISD$CONTROLLER then
        jnz     L3733       ;         return iocdr1(RDSTS$COMMAND);
        mvi     b, 1Ch
        call    IOCDR1
        ret
L3733:                      ;     else
        in      78h         ;         return input(FDCC$STATUS$0);    
        ret
L3736:
        lda     wictlb+3     ; if wiCtlb.stSem <> 0 then
        ana     a
        jz      L373F
        mvi     a, 4         ;     return 5;
L373F: 
        ori     1            ; return 1;
        ret
; end;

; /* return the result type of a disk operation */
; 
; r$type: PROCEDURE BYTE public;
        public  rtype
rtype:  lda     dkcont      ; if dkcont <> WD$CONTROLLER or 
        cpi     9
        jz      L374F
        cpi     3           ;   dkcont = ISD$CONTROLLER then
        jnz     L3751
L374F:
        xra     a           ;         return 0;
        ret
L3751:
        in      79h         ; return input(RESULT$TYPE$0);
        ret
; end;

; /* return the reult byte of a disk operation */
; r$byte: PROCEDURE BYTE public;
; declare wiStatusPair address at(.wiSbuf.status(0)); 
; declare tmp1 byte, tmp2 address;  /* pseudo vars */
; declare i byte;
        public  rbyte
rbyte:  lda     dkcont      ; if dkcont <> WS$CONTROLLER then
        cpi     9
        jz      L376A
        cpi     3           ;     if dkcont = ISD$CONTROLLER then
        jnz     L3767
        mvi     b, 1Bh      ;         return iodcr1(RRSTS$COMMAND);
        call    IOCDR1
        ret
L3767:                      ;     else
        in      7Bh         ;         return input(RESULT$BYTE$0);
        ret
L376A: 
        lda     wiCtlb+1    ; if wiCtlb.opStatus and 40h, = 0 then
        ani     40h         ;     return 0;
        rz
        lxi     h, wiSbuf   ; wiIopb.buf(0) = .wiStatusBuf
        shld    wiIopb+18
        mvi     a, 1        ; wiIopb.function = 1;  /* transfer status */
        sta     wiIopb+11
        lxi     b, wiIopb   ; call strtio(.wiIopb);
        call    strtio
        lda     wiSbuf+2    ; tmp1 = rol(wiSbuf.status(2) and 38h, 2);
        ani     38h         ; /*  drive fault, id field ecc error, data field ecc error */
        rlc
        rlc
        mov     b,a
        lhld    wiSbuf      ; tmp2 = (wiStatusPair and 0fff8h) or 
        mov     a,l
        ani     0f8h
        mov     l,a
        lda     wiSbuf+2    ;        rol (wiSbuf.status(2) and 0c0h)
        ani     0c0h        ; /* merge top 2 bits as low 2 bits of status byte 0 */
        rlc
        rlc
        ora     l
        mov     l,a
; at this point
; hl has from high, to low bit
; write protect, unit not ready, invalid address, sector not found,
; invalid  function, no index, diagnostic fault, illegal sector size
; end of medium, illegal format type, seek in progress, isbc rom error
; isbc ram error, 0, seek error, cylinder address miscompare
; and b has from high, to low bit
; drive fault, id field ecc error, data field ecc error
        mvi     c,10h       ; do i = 16 to 0 by -1; /*pseudo code */
    rbyte3:                 ; find first set bit
        mvi     a,80h       ;      if (tmp2 and 8000h) <> 0 then
        ana     h
        jnz     rbyte4      ;          goto rbyte4;
        dad     h           ;      tmp2 = tmp2 + tmp2;
        dcr     c
        jnz     rbyte3      ; end;
    rbyte4:                 
        mov     a,c         ; return i or tmp1;
        ora     b
        ret

; /*
;    start$io outputs the address of the iopb to the disk controller
;    and in the case of the 8271 ISD involving a data transfer operation
;    it also transfers the data on a byte by byte basis
; */
; start$io:   PROCEDURE(iopb) public;
;     DECLARE iopb ADDRESS;
        public  strtio
strtio: lda     dkcont      ; if dkcont <> WD$CONTROLLER then
        cpi     9
        jz      L37C3       ; do;
        cpi     3           ;     if dkcont = ISD$CONTROLLER then
        jnz     L37BA       ;     do;
        call    intISD      ;         call iniISD(iopb);
        ret                 ;         return;
L37BA:                      ;     end;
        mov     a, c        ;     OUTPUT(FDCC0$LOW$IOPB) = low(iopb);
        out     79h
        mov     a, b        ;     OUTPUT(FDCC0$HIGH$IOPB) = high(iopb);
        out     7Ah
        jmp     L37D3       ; end;
L37C3:                      ; else
                            ; do;
        mov     a, c        ;     wiCtlb.iopb(0) = iopb;
        sta     6Eh
        mov     a, b
        sta     6Fh
        xra     a
        sta     69h
        mvi     a, 1        ;     output(5) = 1;
        out     5
L37D3:                      ; end
        call    dkstat   ; do while (disk$stat and 4) = 0;
        ani     4
        jz      L37D3       ; end;
        ret
; end;


; initISD: procedure(iopb);
;     declare iopb address;
;     declare nsec byte,i byte;
;     declare bufp address, ch, based bufp byte;
intISD: push    b
        inx     b       ; if dcb.ions = DISK$READ then
        ldax    b
        cpi     4
        jnz     L3815
        pop     h       ; do;
        push    h
        inx     h
        inx     h
        mov     d, m    ;     nsec = dcb.nsec;
        pop     h       ;     call triopb(iopb);   /* iopb in hl */
        push    d
        call    triopb
        inx     h
        mov     e, m
        inx     h
        mov     d, m    ;     bufp = dcb.buf;
        xchg
        mvi     b, 19h  ;    call ioccom(RDBC$COMMAND * 256 + ???);
        call    IOCCOM  ;    /* low byte is not used */
        pop     d
L37F9:                  ; L1: do;
        mvi     e, 80h  ;         i = 128;
                        ; /* input DBB status; loop until F0 = IBF = 0 AND OBF = 1 */
L37FB:                  ;     L2: do;
                        ;             do while (INPUT(0c1h) AND 7) <> 1; 
        in      0C1h 
        ani     7
        cpi     1
        jnz     L37FB   ;             end;
        in      0C0h    ;             ch, = INPUT(0c0h);    /* input data from DBB */
        mov     m, a
        inx     h       ;             bufp = bufp + 1;
        dcr     e       ;             if (i := i - 1) <> 0 then /* get 128 bytes */
                        ;                 goto L2;
        jnz     L37FB   ;         end;
        dcr     d       ;     if (nsec := nsec - 1) <> 0 then   /* get all the sectors */
        jnz     L37F9   ;         goto L1;
                        ;     end;
        mvi     a, 5    ;     output(CPUC) = ENABL;
        out     0FFh
        ret             ;     return;
L3815:                  ; end;
        cpi     2       ; if dcb.ioins = 2 or dcb.ioins = 6 or dcb.ioins = 7 then
        jz      L3824
        cpi     6
        jz      L3824
        cpi     7
        jnz     L385D   ; do;
L3824:
        pop     h
        push    h       ;     if dcb.ioins <> 2 then
        inx     h
        mov     a, m
        cpi     2
        inx     h
        jz      L3832
        mov     c, m    ;         nsec = dcb.nsec;
        jmp     L3834
L3832:                  ;     else
        mvi     c, 1    ;         nsec = 1;
L3834:
        inx     h       ;     bufp = ioins.buf;
        inx     h
        inx     h
        mov     e, m
        inx     h
        mov     d, m
        xchg
        mvi     b, 17h
        call    IOCCOM  ;     call ioccom(WDBC * 256 + nsec);
        call    wtDone  ;     call wtDone
        mov     a, c    ;     output(IOCO) = nsec;
        out     0C0h
L3846:                  ; L3: do;
        push    psw
        mvi     d, 80h  ;         i = 128;
L3849:                  ;     L4: do;
        call    wtDone  ;             call wtDone;
        mov     a, m    ;             output(IOCO) = ch;
        out     0C0h
        inx     h       ;             bufp = bufp + 1;
        dcr     d       ;             if (i := i -1) <> 0 then
        jnz     L3849   ;                 goto L4;
                        ;         end;
        pop     psw     ;         if (nsec := nsec - 1) <> 0 then
        dcr     a
        jnz     L3846   ;             goto L3;
                        ;     end;
        mvi     a, 5    ;     output(CPUC) = ENABL;
        out     0FFh
L385D:                  ; end;
        pop     h       ; call triopb(iopb);    /* iobp in hl */
        call    triopb
        ret
; end


wtDone:
        in      0c1h
        ani     7
        jnz     wtDone
        ret

triopb:
        mov     c,m         ; data
        mvi     b,WPBC      ; disk command
        call    iocdr2
        mvi     d,4

tri1:   inx     h
        mov     c,m
        mvi     b,WPCC      ; bytes 2-5 of operation
        call    iocdr2
        dcr     d
        jnz     tri1

tri2:   call    dkstat
        ani     4
        jz      tri2
        ret

        end
exit.plm
exit:
do;
$include(exit.ipx)

exit: procedure public;
    declare tmp address;
    tmp = .tmp;
    call ISIS(IEXIT, .tmp); /* call replaced with jmp to load WSI code in WSI version */
end exit;
end;
eof

isis.t0_4.2w.patch
; diskio uninitialised data
356A 20 20 34
356F 42
3572 4C
; err uninitialised data
38D8 55 50
; setconfig uninitialised data
3958 20 x 05
; stack
3AAC 20 20 36 35 43 37 48 20 53 59 4D 20 20 48 45 41 44 45 52
3ABF 20 x 11
; error msg uninitialised data
3B19 48 20 53 59
3B26 20 x 04
3B33 20 x 04
3B3C 20
3B60 20
APPEND
20 x 0C 36 35 44 32 48 20 53
isist0.pex
@badDiskPort    'bddkpt'
@initio$base    'initb'
@errDisk        'errdsk'
@ErrBadDIskDev  'errbdd'
@SetConfig$ISD  'setISD'
@StartIo        'strtio'
@t0$dk$ct$tb    'tdcttb'
@t0$dk$cf$tb    'tdcftb'
@t0$unitmp      'tuntmp'
@t0$rdymsk      'trdymk'
@t0$tracksTable  'ttrktb'
@t0$sectorsTable 'tsectb'
@DiskStat       'dkstat'
@CopyConfigToIsis 'cpycfg'
@SetConfig      'setcfg'
@ClrTables      'clrtab'
CR  '0dh'
LF  '0ah'
TRUE    '0ffh'
FALSE   '0'
# isis commands
IWRITE  '4'
ICONSOL '8'
IEXIT   '9'
word    'address'
bool    'byte'
# isis locations
WINLOC '50h'
CLILOC '2DAFh'
AFTLOC '2B30h'
DKCONTLOC   '0894h'
CDKSATLOC   '2D72h'
CONFIGBASE  '858h'

CMSK '0fch';

CON$MASK   '00001000B' /* disk controller present */
DD$MASK   '00010000B' /* DD present */
ISD$MASK   '0001000B' /* ISD floppy present */
READ$STATUS$COMMAND   '01Ch'     /* read status command of ISD */

ENABL   '5'           /* pseudo enable of interrupt */
DISABL  '0dh,          /* pseudo disable of interrupt */
CPUC    '0ffh'        /* controller port */

DISK$IO$ERROR   '18h',
DRIVE$NOT$READY  '1eh'





$file(boot.asm)
isis    P(B cmd,A  parameter$ptr)
triopb  P(A iopb)
CO  P(B val)
IOCHK   PB
IOSET   P(B val)
iocdr1  P(B cmd)B 

$file(memchk.asm)
memchk  PA

$file(t0boot.plm)
t0boot  L
CONFIG$T1   'slot byte, endslot byte, ctlId byte, dtype byte'
CONFIG$T2   'trk byte, sec byte, unitmap(4) byte, rdymsk(4) byte'
CONFIG$T 'STRUCTURE(CONFIG$T1,CONFIG$T2)'
DCB$T 'STRUCTURE (iocw BYTE, ioins BYTE, nsec BYTE, tadr BYTE, sadr BYTE, buf ADDRESS)'
WSTATUS$T 'structure(status(3) byte, cyl word, head byte, sector byte, aCyl word, ahead byte, aSec byte, retries byte)'
WWAKE$T 'structure(wake byte, reserved byte, ccb(2) address)'
WCCB$T 'structure(ccw1 byte, busy1 byte, cib(2) address, res word, ccw2 byte, busy2 byte, cp(2) address, cptr word)'
WCONTROL$T 'structure(res1 byte, opStatus byte, cmdSem byte, stSem byte, csa(2) address, iopb(2) address, res2(2) word)'
WDCB$T1 'reserved(2) word, actual(2) word, device word, unit byte, function byte, modifier word'
WDCB$T2 'cyl word, head byte, sector byte, buffer(2) address, count(2) word, gaptr(2) address'
WDCB$T 'STRUCTURE(WDCB$T1, WDCB$T2)';
           
FDCC$STATUS$0   '78h'
FDCC$STATUS$1   '88h'
HD$STATUS       '68h'
RESULT$TYPE$0   '79h'
FDCC0$LOW$IOPB  '79h'
FDCC0$HIGH$IOPB '7Ah'
RESULT$HD       '69h'
HD$LOW$IOPB     '69h'
HD$HIGH$IOPB    '6Ah'
RESULT$BYTE$0   '7Bh'
RESULT$BYTE$1   '8Bh'
RESULT$BYTE$HD  '6Bh'

MAX$RETRIES     '10'
DISK$DONE       '4'
RDBC$COMMAND    '19h'
RRSTS$COMMAND   '1bh'
RDSTS$COMMAND   '1ch'
FDCC0$CONTROLLER '1'
FDCC1$CONTROLLER '2'
HD$CONTROLLER   '4'
DD$TYPE         '1'
SD$TYPE         '2'
ISD$CONTROLLER  '3'
ISD$TYPE        '3'
HD$TYPE         '4'
WD$TYPE         '9'
WD$CONTROLLER   '9'
DISK$READ       '4'

cli     BS
sys$flg     B

t0$dk$cf$tb     B(10)
t0$dk$ct$tb     B(10)
t0$unitmp       B(10)
t0$rdymsk       B(10)
t0$tracksTable  B(10)
t0$sectorsTable B(10)
dk$cf$tb     B(10)
dk$ct$tb     B(10)
unitmp       B(10)
rdymsk       B(10)
tracksTable  B(10)
sectorsTable B(10)


aldadr   P(A hdr$blk)A
config  P
csts    PB
ci      PB
ErrBadDiskDev   P
mdsmon  A

absio       P(B cmd,B disk,"word" block,A buffer$ptr)

SetIsisHdrBlk   P
CopyConfigToIsis    P
ClrTables   P
err         P(B error$type)
insert      P
rbyte       PB
rtype       PB
SetConfig   P(A config)
SetConfig$ISD   P(B slot)
StartIO     P(A iopb)


sdConfig    "CONFIG$T"
ddConfig    "CONFIG$T"
wdConfig    "CONFIG$T"

intio$base  A
initio  B..initio$base
msg1    bs
msg2    bs
msg4    bs
msg7    bs
errDisk b
badDiskPort b
messx8  bs
wiDevParam  AS
user$status A
pc$p    A
pc      A..pc$p
start$addr  A
temp    B
hdr$blk A
stat    B


wiSbuf  B(12)
wiWake  "WWAKE$T"
wiCcb   "WCCB$T"
wiCtlb  "WCONTROL$T"
wiIopb  "WDCB$T"


$file(consol.plm)
consol  P(A ci$p,A co$p,A status$p)

$file(exit.plm)
exit    P

$file(write.plm)
write   P(A conn,A buff$p,A count,A status$p)
junk.asm
$macrofile
    name junk
    ASEG

CR  equ 0dh
LF  equ 0ah
; this file loads specific junk data into memory to make sure isis.t0 is the same
; the file is loaded as a binary file, this file recreates the
; the data that appears to have been at the locations of the uninitialised data
; when the binary snap shot was taken
; for isis.t0 v4.3w these all appear to be 0ffh
    aseg
    org 3A9Bh   ; stack area
    db 0FFh, 0FFh, 0FFh, 0FFh
    db 0FFh, 0FFh, 0FFh, 0FFh
    db 0FFh, 0FFh, 0FFh, 0FFh
    db 0FFh, 0FFh, 0FFh, 0FFh
    db 0FFh, 0FFh, 0FFh, 0FFh
    db 0FFh, 0FFh, 0FFh, 0FFh
    db 0FFh, 0FFh, 0FFh, 0FFh
    db 0FFh, 0FFh, 0FFh, 0FFh
    db 0FFh, 0FFh, 0FFh, 0FFh

    org 3B08h   ; msg2
    db 0FFh, 0FFh, 0FFh, 0FFh

    org 3B15h   ; msg4
    db 0FFh, 0FFh, 0FFh, 0FFh

    org 3B22h   ; msg7
    db 0FFh, 0FFh, 0FFh, 0FFh

    org 3B2Bh   ; errdisk
    db  0FFh

    org 3B4Fh   ; badDiskPort
    db  0FFh

    org 3B5Ch   ; padding to end of file
    REPT 36
    db  0FFh
    ENDM
    end


memchk.asm

    public MEMCHK

    CSEG

MEMCHK:     
    call    0F81Bh
    mov h, b
    mov l, a
    ret

    end;

t0boot.plm

tb:
do;
$include(t0boot.ipx)
DECLARE t0boot LABEL PUBLIC;

/* this version of t0boot has been modified to work on
   single density, double density and hard disk. It will work
   on both the MDS and the INTELLEC.
*/
/* several uninitialised data areas contain junk from when the file was located
   the file junk.asm overlaps this code to initialise this data for an exact match.
   A previous version of this file did explicit initialisation here but it was clunky
*/

DECLARE copyright(*) BYTE DATA('(C) 1976,1977,1978,1979,1980,1981,1982 INTEL CORP');

/*
   the following are used as initialisation into the bitmaps to select a drive
   or determine it's ready status.
   the 'setConfig' routine populates these into the appropriate slots in config$table
   the main use is in the isis main file
*/
declare mdsmon ADDRESS public DATA (0);

DECLARE RTC LITERALLY   '0ffh',     /* real time clock */
    BOOT LITERALLY  '2';
/* Input from RTC us a byte. The second bit from the right
   corresponds so the boot switch. If this bit is 1 the switch is
   on, and if it 0 the switch is off.
*/


declare sdConfig CONFIG$T public initial(0, 1, 1, 2, 76, 26, 0, 30h, 0, 30h, 1, 2, 1, 2);
declare ddConfig CONFIG$T public initial(0, 3, 1, 1, 76, 52, 0, 10h, 20h, 30h, 1, 2, 20h, 40h);
declare wdConfig CONFIG$T public initial(0, 3, 9, 9, 211, 210, 0, 0, 0, 0, 1, 1, 1, 1);
        
DECLARE isis$signon(*) BYTE INITIAL(CR, LF, 'ISIS-II(W), V', 0, '4.', 0, '2', CR, LF);

DECLARE sys$flg BYTE public AT (0ffffh);   /* 1 for INTELLEC, 0 for MDS */
DECLARE initio$base ADDRESS public INITIAL(6);
DECLARE msg1(7) BYTE public INITIAL(CR, LF, 'ERROR'),
        msg2(4) BYTE public,    /* error number goes here */
        msg3(9) BYTE INITIAL(' USER PC '),
        msg4(4) BYTE public,    /* user PC in hex goes here */
        msg5(2) BYTE INITIAL(CR, LF),
        msg6(7) BYTE INITIAL('STATUS='),
        msg7(4) BYTE public,    /* status goes here */
        msg8(5) BYTE INITIAL(CR, LF, 'D= '),
        errDisk BYTE PUBLIC,   /* disk with, error goes here */
        msg10(5) BYTE INITIAL('   ', CR, LF),
        messx8(30) BYTE public INITIAL(CR, LF, 'ILLEGAL DISK DEVICE AT PORT '),
        badDiskPort BYTE PUBLIC, /* disk port high, nibble goes here */
        messx81(4) BYTE INITIAL('8H', CR, LF);

/* the winchester device information */
declare wiDevParam structure(ncyl address, nhead byte, notused byte, secPerTrk byte, bps address, nAltCyl byte)
              public initial(525         , 5         , 0           , 70            , 128        , 13);
DECLARE user$status ADDRESS public;
DECLARE pc$p ADDRESS public, pc BASED pc$p ADDRESS;
DECLARE start$addr ADDRESS public;
DECLARE temp BYTE public, hdr$blk address public, padb byte;
DECLARE stat BYTE public, padw address;

DECLARE config$table(60) BYTE,  /* main config table shared with, isis.bin */
    /* the individual config table elements */
        (t0$dk$cf$tb, t0$dk$ct$tb, t0$unitmp, t0$rdymsk, t0$tracksTable, t0$sectorsTable) (10)
                     BYTE PUBLIC AT(.config$table);
/*
   these are the target locations in isis.bin
   an option would have been to use the public symbols from isis.bin
   but for simiplicity they are hard coded
*/
/* the isis internal tables */
DECLARE (dk$cf$tb, dk$ct$tb, unit$mp, rdy$msk, tracksTable, sectorsTable) (10) BYTE public AT (CONFIGBASE);

DECLARE aft(18) STRUCTURE (     /* ISIS internal aft table */
        empty   BYTE,
        device  BYTE,
        access  BYTE,
        edit    BYTE,
        lbuf    ADDRESS,
        dbuf    ADDRESS,
        pbuf    ADDRESS,
        data$ptr BYTE,
        i$no    ADDRESS,
        ptr$ptr BYTE,
        eofcnt  BYTE,
        ptr$change BYTE,
        data$change BYTE,
        blk$count ADDRESS,
        blk$seq ADDRESS,
        ptr$blk ADDRESS,
        hdr$blk ADDRESS,
        data$blk$count ADDRESS,
        dbuf$read BYTE) public AT (AFTLOC);

DECLARE cli(13) BYTE public AT (CLILOC);        /* used to record boot disk */
/* end of ISIS.BIN interface */

DECLARE CMSK LITERALLY '0fch';

DECLARE CON$MASK    LITERALLY   '00001000B',    /* disk controller present */
    DD$MASK     LITERALLY   '00010000B',    /* DD present */
    ISD$MASK    LITERALLY   '0001000B', /* ISD floppy present */
    READ$STATUS$COMMAND LITERALLY   '01Ch',     /* read status command of ISD */

    ENABL   LITERALLY   '5',            /* pseudo enable of interrupt */
    DISABL  LITERALLY   '0dh',          /* pseudo disable of interrupt */
    CPUC    LITERALLY   '0ffh';         /* controller port */

DECLARE DISK$IO$ERROR   LITERALLY   '18h',
    DRIVE$NOT$READY LITERALLY   '1eh';

    /*
      The num procedure converts a number (value) to ascii format @bufaddr
      base is the numeric base to use, only 10 and 16 are actually used
      the number is assumed to be max of 4 digits
    */
    num: PROCEDURE(value, base, bufaddr) PUBLIC;
        DECLARE value ADDRESS, base BYTE, bufaddr ADDRESS;
        DECLARE buf based bufaddr(4) BYTE;
        DECLARE (div, digit) ADDRESS, (i, asciiOffset) BYTE;
        do i = 1 to 4;
            asciiOffset = '0';
            div = value / base;
            digit = value - div * base;
            if digit > 9 then
                asciiOffset = '7';
            buf(4 - i) = digit + asciiOffset;
            value = div;
        end;
        do i = 0 to 2;
            if buf(i) = '0' then
                buf(i) = ' ';
            else
                return;
        end;
    end;

t0boot:
    temp = INPUT(RESULT$TYPE$0);
    temp = INPUT(RESULT$BYTE$0);
    ENABLE;
    if sys$flg = 0 then /* system is an MDS, wait for boot switch, */
    do while (INPUT(RTC) AND BOOT) <> 0;
        ;
    end;
    call config;
    if csts then
        if (CI and 5fh) = 'F' then
            cli(2) = '4';
        else
            ;
    call setIsisHdrBlk;
    start$addr = aldadr(hdr$blk);
    cli(2) = stat;
    call copyConfigToIsis;
    call consol(.MEMORY, .MEMORY, .user$status);
    call write(0, .isis$signon, 22, .user$status);
    call exit;
end;
eof


t0bota.asm
        name t0bota
; vars accessed within isis
        extrn cdksat, dkcftb
; vars accessed within isis.t0
        extrn mdsmon, pcp, tdcftb, tdcttb, ttrktb, tsectb
        extrn trdymk, tuntmp, aft
; external procs
        extrn   iochk, ioset, co, num

        cseg
; setConfig$ISD: PROCEDURE(slot) public;
;     DECLARE slot BYTE;
; 
;     t0$dk$cf$tb(slot)  = ISD$CONTROLLER;
;     t0$dk$ct$tb(slot) = ISD$CONTROLLER;
;     t0$unitmp(slot) = 0;
;     t0$rdymsk(slot) = 1;
;     t0$tracksTable(slot) = 76;
;     t0$sectorsTable(slot) = 26;
; end;
        public setISD
setISD: mvi     b,0         ; index into slot
        lxi     h,tdcftb
        dad     b
        lxi     b,10        ; size of each, array
        mvi     m,3
        dad     b
        mvi     m,3
        dad     b
        mvi     m,0
        dad     b
        mvi     m,1
        dad     b
        mvi     m,76
        dad     b
        mvi     m,26
        ret


;    copyConfigToIsis: PROCEDURE;
;       do i = 0 to 9;
;           dk$cf$tb(i) = t0$dk$cf$tb(i);
;           dk$ct$tb(i) = t0$dk$ct$tb(i);
;           unit$mp(i) = t0$unitmp(i);
;           rdy$msk(i) = t0$rdymsk(i);
;           tracksTable(i) = t0$tracksTable(i);
;           sectorsTable(i) = t0$sectorsTable(i);
;       end;
;       if t0$dk$cf$tb(0) = WD$TYPE then
;           do i = 0 to 3;
;               aft(i).blk$count = 124;
;           end;
;   end;
        public  cpycfg
cpycfg:
        mvi     c,60
        lxi     h,tdcftb
        lxi     d,dkcftb

        public  cpy
cpy:    mov     a,m     ; copy tables over
        stax    d
        inx     h
        inx     d
        dcr     c
        jnz     cpy
        lda     tdcftb  ; unit 0 drive type
        cpi     9       ; winchester
        rnz             ; done if not
        lxi     h,aft+11h ; set aft(0).blk,aft(1).blk,aft(2).blk,aft(3).blk = 124
        mvi     a,124   ; adjust atf(i).blk$count for WDTYPE
        lxi     d,28    ; size of aft entry
        mov     m,a
        dad     d
        mov     m,a
        dad     d
        mov     m,a
        dad     d
        mov     m,a
        ret




; /*
; The err procedure is used to handle error condiitons.
; An error message is issued to the console, which, for
; disk errors has extended content
; control then passes to the MDS monitor
; error$type is the error number which, identifies the particualar
; type of error, such, as disk i/o error
; */

        extrn  initb, msg1, msg2, msg4, msg7, errdsk
        extrn  messx8, bddkpt

PAD     equ     0ffh

        cseg
; err: PROCEDURE(error$type) public;
; DECLARE (error$type, i, imax) BYTE;
errtyp: db  pad
; i optimised away
imax:   db  pad

        public  err
err:
        LXI     H,errtyp
        MOV     M,C
        mov     l,c     ; call num(error$type, 10, .msg2);
        MVI     H,0
        PUSH    H 
        LXI     D,MSG2
        MVI     C,0AH
        CALL    NUM
        LHLD    PCP     ; call num(pc, 16, .msg4);
        MOV     C,M
        INX     H
        MOV     B,M
        PUSH    B
        LXI     D,MSG4
        MVI     C,10H
        CALL    NUM
        CALL    IOCHK   ; call IOSET((IOCHK AND CMSK) OR (initio AND 3));
        ANI     0FCH
        mov     c,a
        LHLD    initb
        MVI     A,3H
        ANA     M
        ORA     C
        MOV     C,A
        CALL    IOSET
        LXI     H,IMAX  ; imax = 25;
        MVI     M,19H
        LDA     errtyp  ; if error$type = DISK$IO$ERROR then
        CPI     18H
        JNZ     @4
                        ; do;
        lda     cdksat+1;     if high(c$dk$sat) <> 0 then
        ora     a
        JZ      @5
        LXI     H,80H   ;         c$dk$sat = 80h;
        SHLD    cdksat
@5:     LXI     H,IMAX  ;     imax = 47;
        MVI     M,2FH
        LHLD    cdksat  ;     call num(c$dk$sat, 16, .msg7);
        PUSH    H
        LXI     D,MSG7
        MVI     C,10H
        CALL    NUM
        lxi     h,errdsk;     errDisk = errDisk OR '0';
        mov     a,m
        ORI     30H
        mov     m,a     ; end;
@4:
                        ; do i = 0 to imax;
                        ;     call co(msg1(i));
                        ; end;
        lda     imax
        lxi     h,msg1
        inr     a
@69:
errwr:
        mov     c,m
        push    h
        push    psw
        call    CO
        pop     psw
        pop     h
        inx     h
        dcr     a
        jnz     @69

        LXI     H,$+8  ; call mdsmon;
        PUSH    H
        LHLD    MDSMON
        PCHL            ; doesn't return
; end;

; setConfig: PROCEDURE(cfg$p) public
;     declare cfg$p address, cfg based cfg$p CONFIG$T;
;     DECLARE adjust BYTE, slot address, nslot address;
adjust: db  pad
slot:   dw  0ffffh
nslot:  dw  0ffffh

;     adjust = 0  ;  /* offset to add to allow sharing of unitMap and rdyMask */
;     if cfg.slot = 4 then
;         adjust = -4;
; 
;     do slot = cfg.slot to cfg.end$slot;
;         t0$dk$ct$tb(slot) = cfg.ctlId;
;         t0$dk$cf$tb(slot) = cfg.dType;
;         t0$tracksTable(slot) = cfg.tracks;
;         t0$sectorsTable(slot) = cfg.sectors;
;         t0$unitmp(slot) = cfg.unitMap(slot + adjust);
;         t0$rdymsk(slot) = cfg.rdyMask(slot + adjust);
;     end;
; end;
        public setcfg
setcfg:
        lxi     h,adjust    ; adjust = 0; /* offset to add to allow sharing of unitMap and readyMask */
        mvi     m,0
        ldax    b           ; if slot = 4 then
        cpi     4
        jnz     @1
        mvi     m,0fch      ;     adjust = -4;
@1:
        inx     h           ; slot = cfg.slot 
        mov     m,a
        inx     b
        ldax    b
        sub     m           ; /* nslot = endslot - slot */
        inx     h
        mvi     m,0         ; /* upper byte of slot */
        inr     a           ; nslot = endslot - slot + 1
        inx     h
        mov     m,a
        inx     h
        mvi     m,0
        lxi     d,tdcttb    ; fill the controller ids
        call    setvls
        lxi     d,tdcftb    ; the disktype    
        call    setvls
        lxi     d,ttrktb    ; tracksTable
        call    setvls
        lxi     d,tsectb    ; sectorsTable
        call    setvls
        inx     b
        push    b
        lxi     d,tuntmp    ; unitmap
        call    stadvl
        pop     b
        inx     b
        inx     b
        inx     b
        inx     b
        lxi     d,trdymk    ; rdymsk
        call    stadvl
        ret

setvls:
        inx     b       ; point to next config value
        lhld    slot    ; de = .table
        dad     d       ; hl = .table(slot)
        ldax    b       ; b = value
        mov     d,a     ; d = value
        lda     nslot   ; i = nslot;
@100:
        mov     m,d     ; save value
        inx     h
        dcr     a
        jnz     @100
        ret

stadvl: lhld    slot    ; get adjusted slot
        mov     a,l
        dad     d
        xchg
        lxi     h,adjust
        add     m
        mvi     h,0
        mov     l,a
        dad     b
        lda     nslot
        mov     c,a
        jmp     cpy     ; use shared copy routine


; errBadDiskDev: PROCEDURE public;
;     do i = 0 to 35;
;         call CO(messx8(i));
;     end;
;     call mdsmon;
; end;
        public  errbdd
errbdd: mvi     a,24h
        lxi     h,messx8
        jmp     errwr       ; use shared code


        public  clrtab
clrtab: lxi     h,tdcftb
        mvi     c,60
        xra     a

clr1:   mov     m,a
        inx     h
        dcr     c
        jnz     clr1
        ret

        public  insert
insert: lxi     h,tsectb+9  ; insert slot
        lxi     d,tsectb+5
        mvi     c,56
ins1:   ldax    d
        mov     m,a
        dcx     h
        dcx     d
        dcr     c
        jnz     ins1
        ret
        end
write.plm
write:
do;
$include(write.ipx)
write: procedure (conn, buff$p, count, status$p) public;
    declare (conn, buff$p, count, status$p) address;
    call ISIS(IWRITE, .conn);
end write;

end;
eof

