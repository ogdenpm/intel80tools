as80.plm
1C00H:
    DECLARE LIT LITERALLY 'LITERALLY',
            CR  LIT '0DH',
            LF  LIT '0AH',
            FF  LIT '0CH',
            TAB LIT '9',
            TRUE    LIT '0FFH',
            FALSE   LIT '0';

    DECLARE VER DATA(1, 3),
            COPYRIGHT DATA('(C) 1975,1976 INTEL CORP');

    DECLARE ASMCOMPLETE DATA(CR, LF, LF, 'ASSEMBLY COMPLETE, NO PROGRAM ERRORS',
                             CR, LF, '0 BLOCK');
    DECLARE PAGEHEADER DATA(0, LF, '16K ISIS 8080 ASSEMBLER, V1.0',
                            TAB, TAB, TAB, 'PAGE ', CR, LF, LF, LF, TAB, TAB, 0);
    DECLARE ACCUM1(0) ADDRESS, ACC1B(0) BYTE, (ACC1LOW, ACC1HIGH) BYTE,
            ACCUM2(0) ADDRESS, (ACC2LOW, ACC2HIGH) BYTE, PAD3760 BYTE;
    DECLARE BUFFER(80) BYTE,
            ERRCNT BYTE,
            STATUS ADDRESS,
            ENDBUF$PTR ADDRESS,
            (IN$NAME, LST$NAME) ADDRESS,
            (AFTIN, AFTHEX, AFTLST) ADDRESS,
            (BUFFER$PTR, MEMORY$P, ITABLE$P) ADDRESS;
            /* B37C8 IS REFERENCED BUT NOT SET - TREAT AS ZERO */
    DECLARE (NUMTMP, WORDOPERAND, B37C8, HAVETITLE, CUR$OP$FLAGS, IFDEPTH) BYTE,
            (IFSTATE, SKIPIF)(8) BYTE,
            (SYMTAB$END, SYMTAB)(2) ADDRESS,
            (ENDRAM, SYMHIGHMARK) ADDRESS,
            (PASS, MAXRECLEN) BYTE,
            (RECLEN, CHECKSUM, ENDSEEN) BYTE,
            RECBUF(17) BYTE,
            RECADDR ADDRESS;
    DECLARE (REF$P, MID$P, HIGH$P, LOW$P) ADDRESS,
            REFCH BASED REF$P BYTE,
            MIDCH BASED MID$P BYTE,
            MIDSYM BASED MID$P (8) BYTE,
            LOWWD BASED LOW$P ADDRESS,
            HIGHWD BASED HIGH$P ADDRESS;
    DECLARE (II, JJ) BYTE, OPSP BYTE, OPSTACK(7) BYTE;
    DECLARE (PC, ADDR) ADDRESS, PAD3816 BYTE;
    DECLARE (NEWACTION, ACTION, NEXT$TOK$TYPE) BYTE,
            (TOKID, LASTCHREAD, RADIX, SHOWADDR) BYTE,
            (LINECOL, LINEEND, PAGEWIDTH, ROWCNT) BYTE,
            PAGENO ADDRESS,
            LINEBUF(120) BYTE, TITLE(66) BYTE,  TITLELEN BYTE;
    DECLARE (GETNEW, ERRORCH, TOKENCNT) BYTE,
            (TOKEN$P, SYM$P)(8) ADDRESS,
            TOKEN BASED TOKEN$P (8) BYTE,
            SYM BASED SYM$P (8) BYTE,
            SYMWD BASED SYM$P (4) ADDRESS,
            (TOKEN$TYPE, TOKEN$LEN)(8) BYTE,
            END$WORKBUF$P ADDRESS;


    ISIS: PROCEDURE(CMD, PARAM$P);
        DECLARE CMD BYTE, PARAM$P ADDRESS;
        GOTO 40H;
    END ISIS;

    OPEN: PROCEDURE(CONN$P, PATH$P, ACCESS, ECHO, STATUS$P);
        DECLARE (CONN$P, PATH$P, ACCESS, ECHO, STATUS$P) ADDRESS;

        CALL ISIS(0, .CONN$P);
    END;

    CLOSE: PROCEDURE(CONN, STATUS$P);
        DECLARE (CONN, STATUS$P) ADDRESS;

        CALL ISIS(1, .CONN);
    END;

    READ: PROCEDURE(CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P) ADDRESS;

        CALL ISIS(3, .CONN);
    END;

    WRITE: PROCEDURE(CONN, BUFF$P, COUNT, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, STATUS$P) ADDRESS;

        CALL ISIS(4, .CONN);
    END;

    EXIT: PROCEDURE;
        DECLARE STATUS ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(9, .STATUS);
    END;

    ERROR: PROCEDURE(ERROR$NUM);
        DECLARE (ERROR$NUM, STATUS) ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(12, .ERROR$NUM);
    END;

    CHECKSTATUS: PROCEDURE;
        IF STATUS = 0 THEN
            RETURN;
        CALL ERROR(STATUS);
        CALL EXIT;
    END;

    BUFSKIPSPC: PROCEDURE;
        DECLARE CH BASED BUFFER$PTR BYTE;

        DO WHILE CH = ' ' AND BUFFER$PTR <> ENDBUF$PTR;
            BUFFER$PTR = BUFFER$PTR + 1;
        END;
    END;

    OPENFILE: PROCEDURE(ACCESS) ADDRESS;
        DECLARE ACCESS ADDRESS;
        DECLARE AFTN ADDRESS, PAD BYTE;
        DECLARE CH BASED BUFFER$PTR BYTE;

        CALL BUFSKIPSPC;
        CALL OPEN(.AFTN, BUFFER$PTR, ACCESS, 0, .STATUS);    
        CALL CHECKSTATUS;
        DO WHILE CH <> ' ' AND BUFFER$PTR <> ENDBUF$PTR;
            BUFFER$PTR = BUFFER$PTR + 1;
        END;
        CALL BUFSKIPSPC;
        RETURN AFTN;
    END;

    /* CHECK FOR TO (N = 1) OR LIST (N = 2) */
    CHK$TO$LIST: PROCEDURE(N);
        DECLARE N BYTE,  OFFSET BYTE;
        DECLARE KEYWORDS DATA ('TOLIST');
        DECLARE BUF BASED BUFFER$PTR (1) BYTE;

        OFFSET = 0;
        IF N = 4 THEN
            OFFSET = 2;
        DO II = 0 TO N - 1;
            IF BUF(II) <> KEYWORDS(II + OFFSET) THEN DO;
                STATUS = 0CBH;
                CALL CHECKSTATUS;
            END;
        END;
        BUFFER$PTR = BUFFER$PTR + N;
    END;

    READCH: PROCEDURE BYTE;
        DECLARE CH BYTE, ACTUAL ADDRESS, PAD BYTE;
        CALL READ(AFTIN, .CH, 1, .ACTUAL, .STATUS);
        IF ACTUAL = 0 THEN
            STATUS = 0CFH;
        CALL CHECKSTATUS;
        RETURN CH AND 7FH;
    END;

    WRITECH$CO: PROCEDURE(CH);
        DECLARE CH BYTE;
        CALL WRITE(0, .CH, 1, .STATUS);
        CALL CHECKSTATUS;
    END;

    WRITECH$HEX: PROCEDURE(CH);
        DECLARE CH BYTE;
        CALL WRITE(AFTHEX, .CH, 1, .STATUS);
        CALL CHECKSTATUS;
    END;

    WRITECH$LST: PROCEDURE(CH);
        DECLARE CH BYTE;
        CALL WRITE(AFTLST, .CH, 1, .STATUS);
        CALL CHECKSTATUS;
    END;

    MEMCHK: PROCEDURE ADDRESS;
        GOTO 0F81BH;
    END;


    HEX1: PROCEDURE(CH) BYTE;
        DECLARE CH BYTE;
        IF (CH := (CH AND 0FH) + '0') > '9' THEN
            CH = CH + 7;
        RETURN CH;
    END;

    WRITEHEX2$CO: PROCEDURE(N);
        DECLARE N BYTE;
        CALL WRITECH$CO(HEX1(ROR(N, 4)));
        CALL WRITECH$CO(HEX1(N));
    END;


    BUFCH$LST: PROCEDURE(CH);
        DECLARE CH BYTE;
        IF CH = LF THEN DO;
            CH = 0;
            DO WHILE CH < LINEEND;
                CH = CH + 1;
                CALL WRITECH$LST(LINEBUF(CH));
            END;
            LINEEND = 0;
            CALL WRITECH$LST(CR);
            CALL WRITECH$LST(LF);
        END;
        ELSE DO;
            IF CH >= ' ' THEN
                LINEBUF(LINECOL) = CH;
            IF LINECOL > LINEEND THEN
                LINEEND = LINECOL;
        END;
    END;

    ADDCH$LST: PROCEDURE(CH);
        DECLARE CH BYTE;
        DECLARE (SPACES, I) BYTE;

        IF CH = FF THEN DO;
            DO WHILE ROWCNT <> 0;
                IF (ROWCNT := ROWCNT + 1) = 66 THEN
                    ROWCNT = 0;
                CALL BUFCH$LST(LF);
            END;
            RETURN;
        END;   
        IF CH = CR THEN
            LINECOL = 0;
        IF CH = LF THEN
            ROWCNT = ROWCNT + 1;
        SPACES = CH = TAB AND (7 - (LINECOL AND 7));
        IF CH = TAB THEN
            CH = ' ';
        DO I = 0 TO SPACES;
            IF LINECOL < PAGEWIDTH THEN DO;
                LINECOL = LINECOL + (CH >= ' ' AND 1);
                CALL BUFCH$LST(CH);
            END;
        END;
    END;

    PUTCH$LST: PROCEDURE(CH);
        DECLARE CH BYTE;
        DECLARE (I, HDRCH, J) BYTE;
        DECLARE DIV ADDRESS, PAD BYTE;

        IF CH = FF OR NOT ROWCNT < 60 THEN DO;
            CALL ADDCH$LST(CR);
            CALL ADDCH$LST(FF);
            I = 0;
            DO WHILE (HDRCH := PAGEHEADER(I := I + 1)) <> 0;
                IF HDRCH = CR THEN DO;
                    DIV = 10000;
                    DO WHILE DIV > 0;
                        IF PAGENO >= DIV THEN
                            CALL ADDCH$LST(LOW(PAGENO / DIV MOD 10) + '0');
                        DIV = DIV / 10;
                    END;
                    CALL ADDCH$LST(CR);
                    CALL ADDCH$LST(LF);

                    DO J = 1 TO TITLELEN;
                        CALL ADDCH$LST(TITLE(J));
                    END;
                END;
                CALL ADDCH$LST(HDRCH);
            END;
                PAGENO = PAGENO + 1;
        END;
        IF CH <> FF THEN
            CALL ADDCH$LST(CH);
    END;


    DOPASS: PROCEDURE;
        RECORDERROR: PROCEDURE(CH);
            DECLARE CH BYTE;
            IF NOT ROR(SKIPIF(0),1) AND ERRORCH = ' ' THEN DO;
                ERRORCH = CH;
                IF PASS = 3 OR PASS = 2 THEN
                    ERRCNT = ERRCNT + 1;
            END;
        END;

        /* TREAT PTR AS POINTER TO AN ARRAY OF NIBBLES */
        /* INDEX INTO THIS ARRAY TO RETRIEVE THE NIBBLE */
        GETNIBBLEAT: PROCEDURE(PTR, N) BYTE;
            DECLARE PTR ADDRESS, N BYTE;
            DECLARE BA BASED PTR (1) BYTE;
            DECLARE TMP BYTE;
            TMP = BA(SHR(N, 1));
            IF N THEN
                TMP = ROR(TMP, 4);
            RETURN TMP AND 0FH;
        END;

        WRITEHEX2$HEX: PROCEDURE(N);
            DECLARE N BYTE;
            CALL WRITECH$HEX(HEX1(ROR(N, 4)));
            CALL WRITECH$HEX(HEX1(N));
        END;

        PUTHEX2$LST: PROCEDURE(N);
            DECLARE N BYTE;
            CALL PUTCH$LST(HEX1(ROR(N, 4)));
            CALL PUTCH$LST(HEX1(N));
        END;

        WRITEHEXREC$HEX: PROCEDURE(RECTYPE);
            DECLARE RECTYPE BYTE, I BYTE;

            CALL WRITECH$HEX(':');
            CALL WRITEHEX2$HEX(RECLEN);
            CALL WRITEHEX2$HEX(HIGH(RECADDR));
            CALL WRITEHEX2$HEX(LOW(RECADDR));
            CALL WRITEHEX2$HEX(RECTYPE);
            DO I = 1 TO RECLEN;
                CALL WRITEHEX2$HEX(RECBUF(I));
            END;
            CHECKSUM = CHECKSUM - HIGH(RECADDR) - LOW(RECADDR) - RECTYPE - RECLEN;
            CALL WRITEHEX2$HEX(CHECKSUM);
            CALL WRITECH$HEX(CR);
            CALL WRITECH$HEX(LF);
            CHECKSUM = 0;
            RECLEN = 0;
            MAXRECLEN = 16;
        END; 
                

        MKCODE: PROCEDURE(CODE);
            DECLARE CODE BYTE;
            
            IF (CODE AND 3) <> 0 THEN DO;
                IF ACC2HIGH <> 0 OR ACC2LOW > 7 OR (CODE AND ACC2LOW)
                   OR ((CODE AND 3) = 3 AND ACC2LOW > 2) THEN DO;
                    ACC2LOW = 0;
                    CALL RECORDERROR('R');
                END;

                IF ROR(CODE, 2) THEN
                    ACC2LOW = ROL(ACC2LOW, 3);

                ACC1LOW = ACC1LOW OR ACC2LOW;
            END;
            IF SHR(CODE, 3) THEN
                IF ACC2HIGH + 1 > 1 THEN
                    CALL RECORDERROR('V');

            IF (ACTION := SHR(CODE, 4) + 22H) = 22H THEN DO;
                IF ACC1HIGH > 0 THEN
                    CALL RECORDERROR('V');
                NEXT$TOK$TYPE = 6;
            END;
        END;

        /* NESTIF / UNNESTIF ROUTINES */
        /* LOCATION 0 HOLDS THE CURRENT ACCUM1(0) */
        /* PUSH COPIES CURRENT TO END OF LIST */
        /* POP COPIES END OF LIST TO CURRENT */
        UNNESTIF: PROCEDURE(STATE);
            DECLARE STATE BYTE;

            IF STATE <> IFSTATE(0) THEN DO;
                CALL RECORDERROR((STATE = 0FFH AND 5) + 'N');
                IF IFDEPTH > 1 THEN
                    IFDEPTH = 2;
            END;
            IF IFDEPTH > 1 THEN DO;
                SKIPIF(0) = SKIPIF(IFDEPTH);
                IFSTATE(0) = IFSTATE(IFDEPTH);
                IFDEPTH = IFDEPTH - 1;
            END;
        END;


        NESTIF: PROCEDURE(STATE);
            DECLARE STATE BYTE;
            IF ENDSEEN THEN
                RETURN;
            IF (IFDEPTH := IFDEPTH + 1) >= 8 THEN
                CALL UNNESTIF(0FFH);
            ELSE DO;
                SKIPIF(IFDEPTH) = SKIPIF(0);
                IFSTATE(IFDEPTH) = IFSTATE(0);
                IFSTATE(0) = STATE;
            END;
        END;


        WRITESYM$HEX: PROCEDURE;
            IF PASS = 3 THEN
                CALL PUTCH$LST(FF);

            MID$P = SYMTAB(1);
            DO WHILE MID$P < SYMTAB$END(1);
                IF PASS = 3 THEN DO;
                    IF (II := (II + 1) AND 3) = 1 THEN DO;
                        CALL PUTCH$LST(CR);
                        CALL PUTCH$LST(LF);
                    END;
                    DO JJ = 0 TO 4;
                        CALL PUTCH$LST(MIDSYM(JJ));
                    END;

                    CALL PUTCH$LST(' ');
                    CALL PUTHEX2$LST(MIDSYM(7));
                    CALL PUTHEX2$LST(MIDSYM(6));
                    IF MIDSYM(5) = 3 THEN
                        CALL PUTCH$LST('M');
                    CALL PUTCH$LST(TAB);
                END;
                ELSE DO;
                    CALL WRITECH$HEX('0');
                    CALL WRITECH$HEX(' ');
                    DO JJ = 0 TO 4;
                        CALL WRITECH$HEX(MIDSYM(JJ));
                    END;
                    CALL WRITECH$HEX(' ');
                    CALL WRITECH$HEX('0');
                    CALL WRITEHEX2$HEX(MIDSYM(7));
                    CALL WRITEHEX2$HEX(MIDSYM(6));
                    CALL WRITECH$HEX('H');
                    CALL WRITECH$HEX(CR);
                    CALL WRITECH$HEX(LF);
                END;
                MID$P = MID$P + 8;
            END;
            IF PASS = 3 THEN
                CALL ADDCH$LST(FF);
            ELSE DO;
                CALL WRITECH$HEX(' ');
                CALL WRITECH$HEX('$');
                CALL WRITECH$HEX(CR);
                CALL WRITECH$HEX(LF);
            END;
        END;

        GETCH:  PROCEDURE BYTE;
            IF GETNEW <> 0 THEN DO;
                DO WHILE (LASTCHREAD := READCH) = 0 OR LASTCHREAD = 07FH;
                END;
                IF PASS = 3 THEN
                    CALL PUTCH$LST(LASTCHREAD);
            END;
            GETNEW = 1;
            RETURN TOKID := LASTCHREAD;
        END; 

        /* CLASSIFY CHARACTER READ */
        /* 0 ILLEGAL */
        /* 1 WHITE SPACE TAB, LF, FF, SPACE */
        /* 2 SEMICOLON */
        /* 3 COLON */
        /* 4 CR */
        /* 5 ( ) * , -  / */
        /* 6 $ */
        /* 7 quote */
        /* 8 NUMERIC */
        /* 9 LETTER */

        CLASSIFY: PROCEDURE BYTE;
            DECLARE TABLE DATA(  0,   0,   0,   0, 10h,   1, 41h,   0,
                                 0,   0,   0,   0,   0,   0,   0,   0,
                                 1,   0,   6, 70h, 55h, 55h, 55h, 50h,
                               88h, 88h, 88h, 88h, 88h, 23h,   0,   0);
            IF GETCH > 7AH THEN       /* LOWER Z */
                RETURN 0;
            IF TOKID > 60H THEN         /* LOWER A - Z */
                RETURN 9;
            IF TOKID > 5AH THEN         /* > Z */
                RETURN 0;
            IF TOKID > 3EH THEN         /* @ - Z */
                RETURN 9;
            RETURN GETNIBBLEAT(.TABLE, TOKID);
        END; 

        PUSH$TOKEN: PROCEDURE(NEW$TOKEN$TYPE);
            DECLARE NEW$TOKEN$TYPE BYTE;
            IF (TOKENCNT := TOKENCNT + 1) >= 8 THEN DO;
                TOKENCNT = 2;
                CALL RECORDERROR('S');
            END;
            /* PUSH PREVIOUS TOKEN */
            TOKEN$P(TOKENCNT) = TOKEN$P(0);
            SYM$P(TOKENCNT) = SYM$P(0);
            TOKEN$TYPE(TOKENCNT) = TOKEN$TYPE(0);
            TOKEN$LEN(TOKENCNT) = TOKEN$LEN(0);
            /* NEW TOKEN STARTS JUST AFTER PREVIOUS ONE */
            TOKEN$P(0) = TOKEN$P(0) + TOKEN$LEN(0);
            SYM$P(0) = 0;
            TOKEN$TYPE(0) = NEW$TOKEN$TYPE;
            TOKEN$LEN(0) = 0;
        END;

        ADDCH$TOKEN: PROCEDURE(CH);
            DECLARE CH BYTE;
            IF TOKEN$P(0) + TOKEN$LEN(0) < END$WORKBUF$P THEN DO;
                TOKEN(TOKEN$LEN) = CH;
                TOKEN$LEN = TOKEN$LEN + 1;
            END;
            ELSE
                CALL RECORDERROR('T');
        END;
                

        POP$TOKEN: PROCEDURE;
            TOKEN$P(0) = TOKEN$P(TOKENCNT);
            SYM$P(0) = SYM$P(TOKENCNT);
            TOKEN$TYPE(0) = TOKEN$TYPE(TOKENCNT);
            TOKEN$LEN(0) = TOKEN$LEN(TOKENCNT);
            TOKENCNT = TOKENCNT - 1;
        END;


        GETID: PROCEDURE(NEW$TOKEN$TYPE);
            DECLARE NEW$TOKEN$TYPE BYTE;

            CALL PUSH$TOKEN(NEW$TOKEN$TYPE);
            GETNEW = GETNEW - 1;

            DO WHILE CLASSIFY > 7;
                IF TOKID > 40H THEN
                    TOKID = TOKID AND 0DFH;
                CALL ADDCH$TOKEN(TOKID);
            END;
            GETNEW = GETNEW - 1;
        END;

        PRECEDENCE: PROCEDURE(N) BYTE;
            DECLARE N BYTE, PAD BYTE;
            DECLARE TABLE DATA(  0,   0, 67h, 61h, 76h, 56h, 34h, 73h,
                               77h, 11h, 11h, 11h, 11h,   0, 11h, 11h,
                               11h, 11h, 11h, 11h, 11h, 11h, 11h);

            RETURN GETNIBBLEAT(.TABLE, N);
        END;

        /* LOOK UP TOKEN IN ONE OF THE TWO SYMBOL TABLES */ /* USING A BINARY SEARCH */
        /* SYMBOLS ARE STORED AS 8 BYTE ENTRIES
           NAME(5) BYTE,
           TYPE BYTE,
           ACCUM1(0) ADDRESS
        */
        LOOKUP: PROCEDURE(TABLEID) BYTE;
            DECLARE TABLEID BYTE;
            DECLARE CMP BYTE;

            LOW$P = SYMTAB(TABLEID);
            HIGH$P, MID$P = SYMTAB$END(TABLEID);
            DECLARE MIDCH BASED MID$P BYTE,
                    REFCH BASED REF$P BYTE,
                    SYM BASED SYM$P(0) BYTE;

            DO WHILE (REF$P := LOW$P + SHR((HIGH$P - LOW$P) AND 0FFF0H, 1)) <> MID$P;
                MID$P = REF$P;
                REF$P = TOKEN$P(0);
                DO WHILE (CMP := MIDCH - REFCH) = 0;
                    MID$P = MID$P + 1;
                    IF (REF$P := REF$P + 1) = TOKEN$P(0) + TOKEN$LEN THEN DO;
                        IF TOKEN$LEN = 5 OR MIDCH = ' ' THEN DO;
                            SYM$P(0) = MID$P - TOKEN$LEN;
                            TOKEN$TYPE = SYM(5);
                            IF TOKEN$TYPE = 2AH OR TOKEN$TYPE = 22H OR  /* IMM16, LXI */
                               TOKEN$TYPE = 13H OR TOKEN$TYPE = 14H OR  /* DS DW */
                               TOKEN$TYPE = 18H OR TOKEN$TYPE = 1DH OR  /* EQU ORT */
                               TOKEN$TYPE = 1EH THEN                    /* SET */
                                WORDOPERAND = 1;
                            RETURN TOKEN$TYPE;
                        END;
                        ELSE GOTO BREAK;
                    END;
                END;
            BREAK:
                MID$P = (MID$P - REF$P) + TOKEN$P(0);
                IF ROL(CMP, 1) THEN   /* SIGN TEST */
                    LOW$P = MID$P;
                ELSE
                    HIGH$P = MID$P;
                
            END;
            SYM$P(0) = HIGH$P;
            RETURN 0;
        END;

        DECLARE W396C ADDRESS;

        INSERTSYM: PROCEDURE(NEWTYPE, N);
            DECLARE (NEWTYPE, N) BYTE, I BYTE;
            IF TOKENCNT <> 1 THEN
                CALL RECORDERROR('F');
            ELSE DO;
                IF TOKEN$TYPE = 0 THEN DO;
                    IF (HIGH$P := (LOW$P := SYMHIGHMARK) + 8) >= ENDRAM THEN DO;
                        CALL RECORDERROR('T'); 
                        GOTO DONE;
                    END;
                    ELSE DO;
                        SYMHIGHMARK = HIGH$P;
                        SYMTAB$END(N) = SYMTAB$END(N) + 8;
                        DO WHILE LOW$P >= SYM$P;
                            HIGHWD = LOWWD;
                            HIGH$P = HIGH$P - 2;
                            LOW$P = LOW$P - 2;
                        END;
                        DO I = 0 TO 4;                        
                            N = ' ';
                            IF TOKEN$LEN > I THEN
                                N = TOKEN(I);
                            SYM(I) = N;
                        END;
                        TOKEN$TYPE = NEWTYPE;
                    END;
                END;
                ELSE IF (TOKEN$TYPE <> 4 OR TOKEN$TYPE <> NEWTYPE) AND PASS = 1 THEN
                    TOKEN$TYPE = 3;
                ELSE IF TOKEN$TYPE <> 4 THEN
                    IF SYMWD(3) <> W396C THEN
                        CALL RECORDERROR(((TOKEN$TYPE <> 3) AND 3) + 'M' + ((SYM$P(0) = 0) AND 1));
                IF SYM$P <> 0 THEN DO;
                    SYM(5) = TOKEN$TYPE;
                    IF TOKEN$TYPE = NEWTYPE THEN
                        SYMWD(3) = W396C;
                END;
        DONE:
                CALL POP$TOKEN;
            END;
        END;

        GETNUMVAL: PROCEDURE ADDRESS;
            ACCUM1 = 0;
            IF TOKENCNT < 1 THEN
                CALL RECORDERROR('F');
            ELSE DO;
                IF TOKEN$TYPE <> 0 THEN
                    ;
                ELSE
                    TOKEN$TYPE = LOOKUP(1);
                IF TOKEN$TYPE = 0 THEN
                    CALL RECORDERROR('U');
                ELSE DO;
                    IF TOKEN$TYPE <= 4 THEN DO;
                        TOKEN$P(0) = SYM$P +  6;
                        TOKEN$LEN = 2;
                    END;
                    ELSE IF TOKEN$LEN > 2 THEN
                        CALL RECORDERROR('V');
                    ACC1LOW = TOKEN(0);
                    IF TOKEN$LEN > 1 THEN
                        ACC1HIGH = TOKEN(1);
                    /* SEE IF NEED TO SWAP HIGH AND LOW BYTES */
                    IF TOKEN$TYPE = 5 AND WORDOPERAND AND TOKEN$LEN = 2 THEN DO;
                        NUMTMP = ACC1LOW;
                        ACC1LOW = ACC1HIGH;
                        ACC1HIGH = NUMTMP;
                    END;
                END;
            CALL POP$TOKEN;
            END;
            RETURN ACCUM1(0);
        END;

        DECLARE WORKBUF(66) BYTE;
                

        IF PASS = 2 THEN
            CALL WRITESYM$HEX;
        WORDOPERAND = 0;
        HAVETITLE = 0;
        SKIPIF(0) = 0;
        ADDR = 0;
        SHOWADDR = 0;
        ERRCNT = 0;
        SYMTAB(0) = ITABLE$P;
        SYMTAB$END(0) = MEMORY$P;
        IF PASS = 1 THEN DO;
            ENDRAM = MEMCHK + 250;          /* USE THE MONITOR RAM ASWELL */
            SYMTAB(1), SYMTAB$END(1) = MEMORY$P + 2;
            SYMHIGHMARK = SYMTAB$END(0);    /* NO SYMBOLS YET */
            TITLELEN = 0;
        END;
        IF PASS = 3 THEN DO;
            ROWCNT = 0;
            LINECOL = 0;
            LINEEND = 0;
            PAGENO = 1;
            PAGEWIDTH = 120;
            CALL WRITECH$LST(0Ch);
            CALL PUTCH$LST(0Ch);
        END;
        ERRORCH = ' ';
        RECLEN = 0;
        CHECKSUM = 0;
        ENDSEEN = 0;
        GETNEW = 0;
        TOKENCNT = 0;
        IFDEPTH = 0;
        TOKEN$LEN = 0;
        TOKEN$TYPE = 0;
        OPSP = 0;
        OPSTACK(0) = 0;
        PC = 0;
        RECADDR = 0;
        LASTCHREAD = CR;
        MAXRECLEN = 16;
        CALL NESTIF(2);
        PC = 0;
        RECADDR = 0;
        END$WORKBUF$P = (TOKEN$P(0) := .WORKBUF) + 66;
        NEWACTION = 1;


COLLECTLOOP:
        IF NEWACTION = 0 THEN
            CALL RECORDERROR('E');

        NEWACTION = 0;
LOOP:
        DO CASE CLASSIFY;
            DO;                         /* CASE 0 ILLEGAL */
                CALL RECORDERROR('I');
                GOTO LOOP;
            END;
            GOTO LOOP;                  /* CASE 1 WHITESPACE */
            DO;                         /* CASE 2 SEMICOLON  */
                DO WHILE CLASSIFY <> 4;
                END;
                TOKID = 1;
            END;
            DO;                         /* CASE 3 COLON */
                NEWACTION = 1;
                IF SKIPIF(0) THEN DO;
                    IF NOT B37C8 THEN
                        CALL POP$TOKEN;
                END;
                ELSE DO;
                    W396C = PC;
                    CALL INSERTSYM(2, 1);
                END;
                GOTO LOOP;
            END;
            DO;                         /* CASE 4 CR */
                TOKID = 1;
            END;
            DO;                         /* CASE 5 ( ) *, - / */
                IF (TOKID = '+' OR TOKID = '-') AND NEWACTION <> 0 AND NEWACTION <> 3 THEN
                    TOKID = TOKID + 3;
                TOKID = TOKID - '(' + 2;
            END;
            DO;                         /* CASE 6 $ */
                CALL PUSH$TOKEN(7);
                CALL ADDCH$TOKEN(LOW(PC));
                CALL ADDCH$TOKEN(HIGH(PC));
                GOTO COLLECTLOOP;
            END;
            DO;                         /* CASE 7 QUOTE */
                CALL PUSH$TOKEN(5);
                DO WHILE GETCH <> CR;
                    IF TOKID = '''' THEN
                        IF GETCH <> '''' THEN
                            GOTO GOTSTRING;
                    CALL ADDCH$TOKEN(TOKID);
                END;
                CALL RECORDERROR('B');
    GOTSTRING:
                GETNEW = GETNEW - 1; 
                GOTO COLLECTLOOP;
            END;
            DO;                         /* CASE 8 NUMBER */
                CALL GETID(7); 
                IF (RADIX := TOKEN(TOKEN$LEN := TOKEN$LEN - 1)) = 'H' THEN
                    RADIX = 16;
                IF RADIX = 'O' THEN
                    RADIX = 8;
                IF RADIX = 'Q' THEN
                    RADIX = 8;
                IF RADIX = 'B' THEN
                    RADIX = 2;
                IF RADIX = 'D' THEN
                    RADIX = 10;
                IF RADIX > 16 THEN
                    RADIX = 10;
                ELSE
                    TOKEN$LEN = TOKEN$LEN - 1;
                ACCUM1(0) = 0;
                DO II = 0 TO TOKEN$LEN;
                    IF (TOKID := TOKEN(II) - '0') > 9 THEN
                        TOKID = TOKID - 7;
                    IF TOKID >= RADIX THEN DO;
                        TOKID = 0;
                        CALL RECORDERROR('I');
                    END;
                    ACCUM1(0) = ACCUM1(0) * RADIX + TOKID;
                END;
                TOKEN$LEN = 0;
                CALL ADDCH$TOKEN(LOW(ACCUM1(0)));
                CALL ADDCH$TOKEN(HIGH(ACCUM1(0)));
                GOTO COLLECTLOOP;
            END;
            DO;                     /* CASE 9 LETTER */
                CALL GETID(0);
                IF TOKEN$LEN > 5 THEN
                    TOKEN$LEN = 5;
                IF  LOOKUP(0) = 0 THEN
                    TOKEN$TYPE = LOOKUP(1);
                IF (TOKID := TOKEN$TYPE) >= 31 THEN
                    TOKEN$TYPE = 2;
                IF TOKEN$TYPE > 10 THEN
                    CALL POP$TOKEN;
                IF TOKID > 4 THEN
                    GOTO HANDLEOP;
                GOTO COLLECTLOOP;
            END;
        END;    /* OF CASE */

                
DECLARE BA2DA2 DATA(  0, 80h,   0,   0, 0Fh, 0Fh,   0, 0Fh,
                    0Dh, 0Fh, 0Dh, 0Dh, 0Fh, 0Fh, 0Fh, 0Fh,
                    0Fh, 0Fh, 40h,   1, 4Dh, 80h, 80h, 80h,
                      1, 81h, 80h, 40h, 40h,   1,   1, 40h,
                    40h, 40h, 47h,   7,   7,   7, 17h, 47h,
                      7, 47h, 37h,   5);

HANDLEOP:
        IF BA2DA2(TOKID) < 80H AND SKIPIF(0) THEN
            GOTO LOOP;
        IF PRECEDENCE(NEWACTION := TOKID) > PRECEDENCE(ACTION := OPSTACK(OPSP)) OR NEWACTION = 2 THEN DO;
            OPSTACK(OPSP := OPSP + 1) = NEWACTION;
            GOTO LOOP;
        END;
        IF ACTION = 0 THEN
            ACTION = NEWACTION;
        ELSE
            OPSP = OPSP - 1;
        IF (CUR$OP$FLAGS := BA2DA2(ACTION)) THEN
            ACCUM2(0) = GETNUMVAL;
        IF (CUR$OP$FLAGS := ROR(CUR$OP$FLAGS, 1)) THEN
            ACCUM1(0) = GETNUMVAL;
        NEXT$TOK$TYPE = 7;
        DO CASE ACTION;
        ;               /* CASE 0 */
        DO;             /* CASE 1 */
            REF$P = TOKEN$P(0) + TOKEN$LEN;
            IF SKIPIF(0) THEN
                REF$P = .WORKBUF;
            DO WHILE TOKENCNT > 0;
                IF TOKEN$TYPE <> 6 THEN
                    CALL RECORDERROR('Q');
                CALL POP$TOKEN;
            END;
            MID$P = .WORKBUF;
            II = 1;
            IF PASS = 3 THEN DO;
                DO WHILE II;
                    CALL PUTCH$LST(0Dh);
                    CALL PUTCH$LST(0);
                    CALL PUTCH$LST(ERRORCH); 
                    CALL PUTCH$LST(20h);
                    IF (SHOWADDR := MID$P <> REF$P OR SHOWADDR) THEN DO;
                        CALL PUTHEX2$LST(HIGH(ADDR));
                        CALL PUTHEX2$LST(LOW(ADDR));
                    END;
                    SHOWADDR = SHL(NOT SHOWADDR AND 1, 2);
                    DO JJ = 0 TO SHOWADDR;
                        CALL PUTCH$LST(' ');
                    END;
                    DO JJ = 1 TO 4;
                        IF MID$P < REF$P THEN
                            CALL PUTHEX2$LST(MIDCH);
                        ELSE DO;
                            CALL PUTCH$LST(' ');
                            CALL PUTCH$LST(' ');
                        END;
                        II = (MID$P := MID$P + 1) < REF$P;
                    END;
                    IF II THEN
                        CALL PUTCH$LST(LF);
                    ADDR = ADDR + 4;
                END;
            END;    /* PASS 3 */
            IF PASS = 2 THEN DO;
                MID$P = .WORKBUF;
                IF RECADDR + RECLEN <> PC OR ENDSEEN THEN DO;
                    IF RECLEN > 0 THEN
                        CALL WRITEHEXREC$HEX(0);
                    RECADDR = PC;
                END;
                DO WHILE MID$P < REF$P; 
                    IF RECLEN = MAXRECLEN THEN DO;
                        CALL WRITEHEXREC$HEX(0);
                        RECADDR = RECADDR + 16;
                    END;
                    CHECKSUM = CHECKSUM - (RECBUF(RECLEN := RECLEN + 1) := MIDCH);
                    MID$P = MID$P + 1;
                END; 
                IF ENDSEEN THEN
                    CALL WRITEHEXREC$HEX(1);
            END;     /* PASS 2 */
            ADDR, PC = PC + REF$P - .WORKBUF;
            SHOWADDR = 0;
            WORDOPERAND = 0;
            ERRORCH = ' ';
            OPSP = 0;
            SKIPIF(0) = SKIPIF(0) > 0;
            IF ENDSEEN THEN DO;
                ENDSEEN = 0;
                IF PASS = 3 THEN
                    CALL WRITESYM$HEX;
                RETURN;
            END; 
            GOTO LOOP;
        END;
        GOTO CASE$3;            /* CASE 2 ) */
CASE$3: DO;                     /* CASE 3 ( */
            IF NOT (ACTION = 2 AND NEWACTION = 3) THEN
                CALL RECORDERROR('B');
            IF TOKEN$TYPE  = 6 THEN
                TOKEN$LEN = 1;
            IF NEWACTION = 3 THEN
                GOTO LOOP; 
        END;
        ACCUM1(0) = ACCUM1(0) * ACCUM2(0);  /* CASE 4 * */
        ACCUM1(0) = ACCUM1(0) + ACCUM2(0);  /* CASE 5 + */ 
        CALL RECORDERROR('F');              /* CASE 6 , */
        ACCUM1(0) = ACCUM1(0) - ACCUM2(0);  /* CASE 7 - */
        ;                                   /* CASE 8 UNARY + */
        ACCUM1(0) = ACCUM1(0) / ACCUM2(0);  /* CASE 9  / */
        ACCUM1(0) = -ACCUM1(0);             /* CASE 10 UNARY - */
        ACCUM1(0) = NOT ACCUM1(0);          /* CASE 11 NOT */
        ACCUM1(0) = ACCUM1(0) AND ACCUM2(0); /* CASE 12 AND */
        ACCUM1(0) = ACCUM1(0) OR ACCUM2(0);  /* CASE 13 OR */
        ACCUM1(0) = ACCUM1(0) XOR ACCUM2(0); /* CASE 14 XOR */
        ACCUM1(0) = ACCUM1(0) MOD ACCUM2(0); /* CASE 15 MOD */
        DO;                                  /* CASE 16 SHL */
            IF ACC2LOW <> 0 THEN
            ACCUM1(0) = SHL(ACCUM1(0), ACC2LOW);
        END;
        DO;                                  /* CASE 17 SHR */
            IF ACC2LOW <> 0 THEN
            ACCUM1(0) = SHR(ACCUM1(0), ACC2LOW);
        END;
        DO;                                 /* CASE 18 DB */
            IF TOKEN$TYPE <> 5 AND TOKEN$TYPE <> 6 THEN DO;
                ACCUM1(0) = GETNUMVAL;
                IF ACC1HIGH -1  < 0FEH THEN 
                    CALL RECORDERROR('V');
                CUR$OP$FLAGS = 22H;
            END;
            TOKEN$TYPE = 6;
            NEXT$TOK$TYPE = 6;
        END;
        DO;                                 /* CASE 19 DS */
            SHOWADDR = 1;
            PC = PC + ACCUM2(0);            /* EXPECTED ACCUM1 */
            GOTO HANDLEOP;
        END;
        NEXT$TOK$TYPE = 6;                          /* CASE 20 DW */
        DO;                                 /* CASE 21 END */
            PC = 0;
            ACCUM1(0) = 0;
            IF TOKENCNT > 0 THEN
                PC = GETNUMVAL;
            SHOWADDR = 1;
            ENDSEEN = 1;
            SKIPIF(0) = 0;
            CALL UNNESTIF(2);
        END;
        CALL UNNESTIF(0);                   /* CASE 22 ENDIF */
        ;                                   /* CASE 23 */
        DO;                                 /* CASE 24 EQU */
            SHOWADDR = 1;
            W396C = ACCUM1(0);
            CALL INSERTSYM(2, 1);
        END;
        DO;                                 /* CASE 25 IF */
            CALL NESTIF(0);
            SKIPIF(0) = IFDEPTH > 1 AND (((ACCUM1(0) = 0) AND 1) OR SKIPIF(0));
        END;
        ;                           /* CASE 26 */
        ;                           /* CASE 27 */
        ;                           /* CASE 28 */
        DO;                         /* CASE 29 ORG */
            SHOWADDR = 1;
            PC = ACCUM1(0);
        END;
        DO;                         /* CASE 30 SET */
            IF LOOKUP(1) <> 4 AND TOKEN$TYPE <> 0 THEN
                CALL RECORDERROR('M');
            SHOWADDR = 1;
            W396C = ACCUM1(0);
            CALL INSERTSYM(4, 1);
        END;
        DO;                         /* CASE 31 TITLE */
            IF NEWACTION = 1 THEN DO;
                IF PASS <> 1 OR NOT HAVETITLE THEN DO;
                    REF$P = .WORKBUF + 5;
                    TITLELEN = 0;
                    DO WHILE TOKEN$P(0) + TOKEN$LEN > REF$P;
                        IF TITLELEN < 66 AND (II := REFCH) <> FF THEN
                            TITLE(TITLELEN := TITLELEN + 1) = II;
                        REF$P = REF$P + 1;
                    END;
                END; 
                DO WHILE TOKENCNT > 0;
                    CALL POP$TOKEN;
                END;
                IF PASS = 1 THEN
                    HAVETITLE = 1;
            END;
        END;
        ;                          /* CASE 32 */
        ;                          /* CASE 33 */
        CALL MKCODE(85h);          /* CASE 34 */
        CALL MKCODE(5);            /* CASE 35 */
        CALL MKCODE(7);            /* CASE 36 */
        CALL MKCODE(2);            /* CASE 37 */
        CALL MKCODE(8);            /* CASE 38 */
        CALL MKCODE(46h);          /* CASE 39 */
        CALL MKCODE(6);            /* CASE 40 */
        CALL MKCODE(36h);          /* CASE 41 */
        CALL MKCODE(0);            /* CASE 42 */
        CALL MKCODE(0);            /* CASE 43 */
        END; /* END OF CASE */
        IF SHOWADDR THEN
            ADDR = ACCUM1(0);
        IF (CUR$OP$FLAGS AND 1EH) <> 0 THEN
            CALL PUSH$TOKEN(NEXT$TOK$TYPE);
        DO II = 0 TO 3;
            IF (CUR$OP$FLAGS := ROR(CUR$OP$FLAGS, 1)) THEN
                CALL ADDCH$TOKEN(ACC1B(II));
        END;
        IF ROR(CUR$OP$FLAGS, 1) THEN
            IF NEWACTION = 6 THEN
                TOKID = ACTION;
        GOTO HANDLEOP;
    END;
    

        DECLARE ITABLE(840) BYTE INITIAL(
                'A    ',     3,     7,     0,
                'ACI  ',   26h,  0CEh,     0,
                'ADC  ',   25h,   88h,     0,
                'ADD  ',   25h,   80h,     0,
                'ADI  ',   26h,  0C6h,     0,
                'ANA  ',   25h,  0A0h,     0,
                'AND  ',   0Ch,     0,     0,
                'ANI  ',   26h,  0E6h,     0,
                'B    ',     3,     0,     0,
                'C    ',     3,     1,     0,
                'CALL ',   2Ah,  0CDh,     0,
                'CC   ',   2Ah,  0DCh,     0,
                'CM   ',   2Ah,  0FCh,     0,
                'CMA  ',   2Bh,   2Fh,     0,
                'CMC  ',   2Bh,   3Fh,     0,
                'CMP  ',   25h,  0B8h,     0,
                'CNC  ',   2Ah,  0D4h,     0,
                'CNZ  ',   2Ah,  0C4h,     0,
                'CP   ',   2Ah,  0F4h,     0,
                'CPE  ',   2Ah,  0ECh,     0,
                'CPI  ',   26h,  0FEh,     0,
                'CPO  ',   2Ah,  0E4h,     0,
                'CZ   ',   2Ah,  0CCh,     0,
                'D    ',     3,     2,     0,
                'DAA  ',   2Bh,   27h,     0,
                'DAD  ',   23h,     9,     0,
                'DB   ',   12h,     0,     0,
                'DCR  ',   28h,     5,     0,
                'DCX  ',   23h,   0Bh,     0,
                'DI   ',   2Bh,  0F3h,     0,
                'DS   ',   13h,     0,     0,
                'DW   ',   14h,     0,     0,
                'E    ',     3,     3,     0,
                'EI   ',   2Bh,  0FBh,     0,
                'END  ',   15h,     0,     0,
                'ENDIF',   16h,     0,     0,
                'EQU  ',   18h,     0,     0,
                'H    ',     3,     4,     0,
                'HLT  ',   2Bh,   76h,     0,
                'IF   ',   19h,     0,     0,
                'IN   ',   26h,  0DBh,     0,
                'INR  ',   28h,     4,     0,
                'INX  ',   23h,     3,     0,
                'JC   ',   2Ah,  0DAh,     0,
                'JM   ',   2Ah,  0FAh,     0,
                'JMP  ',   2Ah,  0C3h,     0,
                'JNC  ',   2Ah,  0D2h,     0,
                'JNZ  ',   2Ah,  0C2h,     0,
                'JP   ',   2Ah,  0F2h,     0,
                'JPE  ',   2Ah,  0EAh,     0,
                'JPO  ',   2Ah,  0E2h,     0,
                'JZ   ',   2Ah,  0CAh,     0,
                'L    ',     3,     5,     0,
                'LDA  ',   2Ah,   3Ah,     0,
                'LDAX ',   24h,   0Ah,     0,
                'LHLD ',   2Ah,   2Ah,     0,
                'LXI  ',   22h,     1,     0,
                'M    ',     3,     6,     0,
                'MOD  ',   0Fh,     0,     0,
                'MOV  ',   29h,   40h,     0,
                'MVI  ',   27h,     6,     0,
                'NOP  ',   2Bh,     0,     0,
                'NOT  ',   0Bh,     0,     0,
                'OR   ',   0Dh,     0,     0,
                'ORA  ',   25h,  0B0h,     0,
                'ORG  ',   1Dh,     0,     0,
                'ORI  ',   26h,  0F6h,     0,
                'OUT  ',   26h,  0D3h,     0,
                'PCHL ',   2Bh,  0E9h,     0,
                'POP  ',   23h,  0C1h,     0,
                'PSW  ',     3,     6,     0,
                'PUSH ',   23h,  0C5h,     0,
                'RAL  ',   2Bh,   17h,     0,
                'RAR  ',   2Bh,   1Fh,     0,
                'RC   ',   2Bh,  0D8h,     0,
                'RET  ',   2Bh,  0C9h,     0,
                'RLC  ',   2Bh,     7,     0,
                'RM   ',   2Bh,  0F8h,     0,
                'RNC  ',   2Bh,  0D0h,     0,
                'RNZ  ',   2Bh,  0C0h,     0,
                'RP   ',   2Bh,  0F0h,     0,
                'RPE  ',   2Bh,  0E8h,     0,
                'RPO  ',   2Bh,  0E0h,     0,
                'RRC  ',   2Bh,   0Fh,     0,
                'RST  ',   28h,  0C7h,     0,
                'RZ   ',   2Bh,  0C8h,     0,
                'SBB  ',   25h,   98h,     0,
                'SBI  ',   26h,  0DEh,     0,
                'SET  ',   1Eh,     0,     0,
                'SHL  ',   10h,     0,     0,
                'SHLD ',   2Ah,   22h,     0,
                'SHR  ',   11h,     0,     0,
                'SP   ',     3,     6,     0,
                'SPHL ',   2Bh,  0F9h,     0,
                'STA  ',   2Ah,   32h,     0,
                'STAX ',   24h,     2,     0,
                'STC  ',   2Bh,   37h,     0,
                'SUB  ',   25h,   90h,     0,
                'SUI  ',   26h,  0D6h,     0,
                'TITLE',   1Fh,     0,     0,
                'XCHG ',   2Bh,  0EBh,     0,
                'XOR  ',   0Eh,     0,     0,
                'XRA  ',   25h,  0A8h,     0,
                'XRI  ',   26h,  0EEh,     0,
                'XTHL ',   2Bh,  0E3h,     0);
        DECLARE PAD3CFC ADDRESS, LASTADDRESS ADDRESS;

MAIN:
    CALL READ(1, .BUFFER, 80, .ENDBUF$PTR, .STATUS);
    BUFFER$PTR = .BUFFER;
    CALL CHECKSTATUS;
    ENDBUF$PTR = ENDBUF$PTR + .BUFFER;
    ITABLE$P = .ITABLE;
    MEMORY$P = .LASTADDRESS;
    CALL WRITECH$CO(CR);
    II = 0;
    DO WHILE (JJ := PAGEHEADER(II := II + 1)) <> TAB;
        CALL WRITECH$CO(JJ);
    END; 
    DO PASS = 1 TO 3;
        DO CASE PASS; 
        ;                /* CASE 0 */
        DO;              /* CASE 1 */
            IN$NAME = BUFFER$PTR;
            AFTIN = OPENFILE(1);
            CALL CHK$TO$LIST(2);   /* CHECK FOR TO */
        END;
        DO;              /* CASE 2 */
            AFTHEX = OPENFILE(2);
            CALL CHK$TO$LIST(4);    /* CHECK FOR LIST */
            LST$NAME = BUFFER$PTR;
            IF AFTHEX = 0FFH THEN
                GOTO CONTINUE;
        END;
        DO;
            CALL CLOSE(AFTHEX, .STATUS);
            CALL CHECKSTATUS;
            IF (AFTLST := OPENFILE(2)) = 0FFH THEN
                GOTO CONTINUE;
        END;
        END; /* OF CASE */
        IF PASS > 1 THEN DO;
            CALL CLOSE(AFTIN, .STATUS);
            CALL CHECKSTATUS;
            BUFFER$PTR = IN$NAME;
            AFTIN = OPENFILE(1);
            BUFFER$PTR = LST$NAME;
        END;
        CALL DOPASS;
CONTINUE:
    END;

    IF ERRCNT = 0 THEN
        CALL WRITE(0, .ASMCOMPLETE, 41, .STATUS);
    ELSE DO;
        CALL WRITE(0, .ASMCOMPLETE, 22, .STATUS);
        CALL WRITEHEX2$CO(ERRCNT);
        CALL WRITECH$CO('H');
        CALL WRITE(0, .ASMCOMPLETE + 24, 17, .STATUS);
    END;
    CALL EXIT;
EOF
attrib.plm
1C00H:
DO;
    DECLARE TRUE    LITERALLY '0FFH',
            FALSE   LITERALLY '0',
            CR      LITERALLY '0DH',
            LF      LITERALLY '0AH';

    DECLARE VER DATA(1, 10H);
    DECLARE COPYRIGNT DATA('COPYRIGHT (C) INTEL 1975,1976');

    ISIS: PROCEDURE(CMD, PARAM$P);
        DECLARE CMD BYTE, PARAM$P ADDRESS;
        GOTO 40H;
    END ISIS;

    READ: PROCEDURE(CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P) ADDRESS;

        CALL ISIS(3, .CONN);
    END;

    WRITE: PROCEDURE(CONN, BUFF$P, COUNT, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, STATUS$P) ADDRESS;

        CALL ISIS(4, .CONN);
    END;

    ATTRIB: PROCEDURE (PATH$P, ATTRIB, ON$OFF, STATUS$P);
        DECLARE (PATH$P, ATTRIB, ON$OFF, STATUS$P) ADDRESS;

        CALL ISIS(10, .PATH$P);
    END ATTRIB;

    EXIT: PROCEDURE;
        DECLARE STATUS ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(9, .STATUS);
    END;

    ERROR: PROCEDURE(ERROR$NUM);
        DECLARE (ERROR$NUM, STATUS) ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(12, .ERROR$NUM);
    END;



    DEBLANK: PROCEDURE(PTR) ADDRESS;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE (C = ' ');
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;

    DELIMIT: PROCEDURE(PTR) ADDRESS;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE (C = ':' OR C = '.' OR
                 ('0' <= C AND C <= '9') OR
                 ('A' <= C AND C <= 'Z'));
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;

    NUMOUT: PROCEDURE(VALUE, BASE, LC, BUFADR, WIDTH);
        DECLARE (VALUE, BUFADR) ADDRESS, (BASE, LC, WIDTH) BYTE; 
        DECLARE DIGITS DATA('0123456789ABCDEF');
        DECLARE I BYTE;
        DECLARE BUF BASED BUFADR (1) BYTE;

        DO I = 1 TO WIDTH;
            BUF(WIDTH - I) = DIGITS(VALUE MOD BASE);
            VALUE = VALUE / BASE;   
        END;

        I = 0;
        DO WHILE BUF(I) = '0' AND I < WIDTH - 1;
            BUF(I) = LC;
            I = I + 1;
        END;
    END;

    REPORTERROR: PROCEDURE(ERRNUM);
        DECLARE ERRNUM ADDRESS;
        DECLARE NUMBERBUFFER(3) BYTE, I ADDRESS, STATUS ADDRESS;
     

        DECLARE ERRMSG DATA(0, 0,
            2, 'ILLEGAL AFTN ARGUMENT', 0,
            4, 'INCORRECTLY SPECIFIED FILE', 0,
            5, 'UNRECOGNIZED DEVICE NAME', 0,
            6, 'ATTEMPT TO WRITE TO INPUT DEVICE', 0,
            8, 'ATTEMPT TO READ FROM OUTPUT DEVICE', 0,
            9, 'DIRECTORY FULL', 0,
            0AH, 'NOT ON SAME DISK', 0,
            0BH, 'FILE ALREADY EXISTS', 0,
            0CH, 'FILE IS ALREADY OPEN', 0,
            0DH, 'NO SUCH FILE', 0,
            0EH, 'WRITE PROTECTED', 0,
            0FH, 'LOAD TOO LOW', 0,
            10H, 'BAD LOAD FORMAT', 0,
            11H, 'NOT A DISK FILE', 0,
            12H, 'ILLEGAL ISIS COMMAND', 0,
            13H, 'ATTEMPTED SEEK ON NON-DISK FILE', 0,
            14H, 'ATTEMPTED BACK SEEK TO FAR', 0,
            16H, 'ILLEGAL ACCESS MODE TO OPEN', 0,
            17H, 'MISSING FILENAME', 0,
            19H, 'ILLEGAL ECHO FILE', 0,
            1AH, 'ILLEGAL ATTRIBUTE IDENTIFIER', 0,
            1BH, 'ILLEGAL SEEK COMMAND', 0,
            1CH, 'MISSING EXTENSION', 0,
            1FH, 'CAN', 27H, 'T SEEK ON WRITE ONLY FILE', 0,
            20H, 'CAN', 27H, 'T DELETE OPEN FILE', 0,
            23H, 'SEEK PAST EOF', 0,
            0C9H, 'UNRECOGNIZED SWITCH', 0,
            0CAH, 'UNRECOGNIZED DELIMITER', 0,
            0CBH, 'INVALID SYNTAX', 0,
            0CCH, 'PREMATURE EOF', 0,
            0CEH, 'ILLEGAL DISKETTE LABEL', 0,
            0D0H, 'CHECKSUM ERROR', 0
        );



        IF ERRNUM <> 0 THEN
        DO;
            I = 0;
            DO WHILE I < LENGTH(ERRMSG);
                IF ERRNUM = ERRMSG(I) AND ERRMSG(I + 1) <> 0 THEN
                DO;
                    I = I + 1;
                    CALL WRITE(0, .(' '), 1, .STATUS);
                    DO WHILE ERRMSG(I) <> 0;
                        CALL WRITE(0, .ERRMSG(I), 1, .STATUS);
                        I = I + 1;
                    END;
                    CALL WRITE(0, .(0DH, 0AH), 2, .STATUS);
                    return;
                END;
                ELSE
                DO;
                    DO WHILE ERRMSG(I) <> 0;
                        I = I + 1;
                    END;
                    I = I + 1;
                END;
            end;
            CALL ERROR(ERRNUM);
        END;
    END;


    FILE$ERROR: PROCEDURE(STATUS, PTR, CALLEXIT);
        DECLARE (STATUS, PTR) ADDRESS, CALLEXIT BYTE;
        DECLARE ERR$STATUS ADDRESS;

        IF STATUS <> 0 THEN
        DO;
            PTR = DEBLANK(PTR);
            CALL WRITE(0, .(' '), 1, .ERR$STATUS);
            CALL WRITE(0, PTR, DELIMIT(PTR) - PTR, .ERR$STATUS);
            CALL WRITE(0, .(','), 1, .ERR$STATUS);
            CALL REPORTERROR(STATUS);
            IF CALLEXIT THEN
                CALL EXIT;
        END;
    END;

        
    DECLARE (PADW, ACTUAL, STATUS) ADDRESS;
    DECLARE BUFPTR ADDRESS, CH BASED BUFPTR BYTE;
    DECLARE BUFFER(128) BYTE;
    DECLARE SWID ADDRESS;
    DECLARE (PAD, ONOFF) BYTE;

MAIN:
    CALL READ(1, .BUFFER, 128, .ACTUAL, .STATUS);
    BUFPTR = DEBLANK(.BUFFER);
    IF CH = CR THEN DO;
        CALL REPORTERROR(0CBH);
        CALL EXIT;
    END;

    BUFPTR = DEBLANK(DELIMIT(BUFPTR));
   
    DO WHILE CH = '$';
        BUFPTR = BUFPTR + 1;
        IF CH = 'I' THEN
            SWID = 0;
        ELSE IF CH = 'S' THEN
            SWID = 1;
        ELSE IF CH = 'W' THEN
            SWID = 2;
        ELSE IF CH = 'F' THEN
            SWID = 3;
        ELSE DO;
            CALL REPORTERROR(0C9H);
            CALL EXIT;
        END;
        BUFPTR = DEBLANK(BUFPTR + 1);
        IF CH = '0' THEN
            ONOFF = 0;
        ELSE IF CH = '1' THEN
            ONOFF = 1;
        ELSE DO;
            CALL REPORTERROR(0C9H);
            CALL EXIT;
        END;
        CALL ATTRIB(.BUFFER, SWID, ONOFF, .STATUS);
        CALL FILEERROR(STATUS, .BUFFER, TRUE);
        BUFPTR = DEBLANK(BUFPTR + 1);
    END;
    IF CH <> CR THEN DO;
        CALL REPORTERROR(0C9H);
        CALL EXIT;
    END;
    CALL EXIT;
END;
EOF
copy.plm
1C00H:
DO;
    DECLARE TRUE    LITERALLY '0FFH',
            FALSE   LITERALLY '0',
            CR      LITERALLY '0DH',
            LF      LITERALLY '0AH';

    DECLARE READMODE    LITERALLY '1',
            WRITEMODE   LITERALLY '2',
            UPDATEMODE  LITERALLY '3';

    /* ERROR CODES */
    DECLARE FILE$EXISTS LITERALLY '0BH',
            NO$SUCH$FILE LITERALLY '0DH',
            BAD$SWITCH  LITERALLY '0C9H',
            BAD$SYNTAX  LITERALLY '0CBH';

    DECLARE VER DATA(1, 10H);
    DECLARE COPYRIGNT DATA('COPYRIGHT (C) INTEL 1975,1976');

    MEMCHK: PROCEDURE ADDRESS;
        GOTO 0F81BH;
    END;

    ISIS: PROCEDURE(CMD, PARAM$P);
        DECLARE CMD BYTE, PARAM$P ADDRESS;
        GOTO 40H;
    END ISIS;

    OPEN: PROCEDURE(CONN$P, PATH$P, ACCESS, ECHO, STATUS$P);
        DECLARE (CONN$P, PATH$P, ACCESS, ECHO, STATUS$P) ADDRESS;

        CALL ISIS(0, .CONN$P);
    END;

    READ: PROCEDURE(CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P) ADDRESS;

        CALL ISIS(3, .CONN);
    END;

    WRITE: PROCEDURE(CONN, BUFF$P, COUNT, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, STATUS$P) ADDRESS;

        CALL ISIS(4, .CONN);
    END;

    CLOSE: PROCEDURE(CONN, STATUS$P);
        DECLARE (CONN, STATUS$P) ADDRESS;

        CALL ISIS(1, .CONN);
    END;

    ERROR: PROCEDURE(ERROR$NUM);
        DECLARE (ERROR$NUM, STATUS) ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(12, .ERROR$NUM);
    END;

	RENAME: PROCEDURE(OLD$P, NEW$P, STATUS$P);
    	DECLARE (OLD$P, NEW$P, STATUS$P) ADDRESS;
    	
    	CALL ISIS(7, .OLD$P);
	END;

    EXIT: PROCEDURE;
        DECLARE STATUS ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(9, .STATUS);
    END;


    DEBLANK: PROCEDURE(PTR) ADDRESS;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE (C = ' ');
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;

    DELIMIT: PROCEDURE(PTR) ADDRESS;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE (C = ':' OR C = '.' OR
                 ('0' <= C AND C <= '9') OR
                 ('A' <= C AND C <= 'Z'));
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;

    SEQ: PROCEDURE(S1, S2, CNT) BYTE;
        DECLARE (S1,S2) ADDRESS, CNT BYTE;
        DECLARE S1A BASED S1(1) BYTE;
        DECLARE S2A BASED S2(1) BYTE;
        DECLARE I BYTE;
        CNT = CNT - 1;
        DO I = 0 TO CNT;
            IF S1A(I) <> S2A(I) THEN
                RETURN 0;
        END;
        RETURN 0FFH;
    END;

    NUMOUT: PROCEDURE(VALUE, BASE, LC, BUFADR, WIDTH);
        DECLARE (VALUE, BUFADR) ADDRESS, (BASE, LC, WIDTH) BYTE; 
        DECLARE DIGITS DATA('0123456789ABCDEF');
        DECLARE I BYTE;
        DECLARE BUF BASED BUFADR (1) BYTE;

        DO I = 1 TO WIDTH;
            BUF(WIDTH - I) = DIGITS(VALUE MOD BASE);
            VALUE = VALUE / BASE;   
        END;

        I = 0;
        DO WHILE BUF(I) = '0' AND I < WIDTH - 1;
            BUF(I) = LC;
            I = I + 1;
        END;
    END;

    REPORTERROR: PROCEDURE(ERRNUM);
        DECLARE ERRNUM ADDRESS;
        DECLARE NUMBERBUFFER(4) BYTE, I ADDRESS, STATUS ADDRESS;
     

        DECLARE ERRMSG DATA(0, 0,
            2, 'ILLEGAL AFTN ARGUMENT', 0,
            4, 'INCORRECTLY SPECIFIED FILE', 0,
            5, 'UNRECOGNIZED DEVICE NAME', 0,
            6, 'ATTEMPT TO WRITE TO INPUT DEVICE', 0,
            8, 'ATTEMPT TO READ FROM OUTPUT DEVICE', 0,
            9, 'DIRECTORY FULL', 0,
            0AH, 'NOT ON SAME DISK', 0,
            0BH, 'FILE ALREADY EXISTS', 0,
            0CH, 'FILE IS ALREADY OPEN', 0,
            0DH, 'NO SUCH FILE', 0,
            0EH, 'WRITE PROTECTED', 0,
            0FH, 'LOAD TOO LOW', 0,
            10H, 'BAD LOAD FORMAT', 0,
            11H, 'NOT A DISK FILE', 0,
            12H, 'ILLEGAL ISIS COMMAND', 0,
            13H, 'ATTEMPTED SEEK ON NON-DISK FILE', 0,
            14H, 'ATTEMPTED BACK SEEK TO FAR', 0,
            16H, 'ILLEGAL ACCESS MODE TO OPEN', 0,
            17H, 'MISSING FILENAME', 0,
            19H, 'ILLEGAL ECHO FILE', 0,
            1AH, 'ILLEGAL ATTRIBUTE IDENTIFIER', 0,
            1BH, 'ILLEGAL SEEK COMMAND', 0,
            1CH, 'MISSING EXTENSION', 0,
            1FH, 'CAN', 27H, 'T SEEK ON WRITE ONLY FILE', 0,
            20H, 'CAN', 27H, 'T DELETE OPEN FILE', 0,
            23H, 'SEEK PAST EOF', 0,
            0C9H, 'UNRECOGNIZED SWITCH', 0,
            0CAH, 'UNRECOGNIZED DELIMITER', 0,
            0CBH, 'INVALID SYNTAX', 0,
            0CCH, 'PREMATURE EOF', 0,
            0CEH, 'ILLEGAL DISKETTE LABEL', 0,
            0D0H, 'CHECKSUM ERROR', 0
        );



        IF ERRNUM <> 0 THEN
        DO;
            I = 0;
            DO WHILE I < LENGTH(ERRMSG);
                IF ERRNUM = ERRMSG(I) AND ERRMSG(I + 1) <> 0 THEN
                DO;
                    I = I + 1;
                    CALL WRITE(0, .(' '), 1, .STATUS);
                    DO WHILE ERRMSG(I) <> 0;
                        CALL WRITE(0, .ERRMSG(I), 1, .STATUS);
                        I = I + 1;
                    END;
                    CALL WRITE(0, .(0DH, 0AH), 2, .STATUS);
                    return;
                END;
                ELSE
                DO;
                    DO WHILE ERRMSG(I) <> 0;
                        I = I + 1;
                    END;
                    I = I + 1;
                END;
            end;
            CALL ERROR(ERRNUM);
        END;
    END;

    CHECKERROR: PROCEDURE(ERRCODE);
        DECLARE ERRCODE ADDRESS;
        IF ERRCODE <> 0 THEN DO;
            CALL REPORTERROR(ERRCODE);
            CALL EXIT;
        END;
    END;

    DECLARE DEVICES(21) ADDRESS INITIAL(
        'F0', 'F1', 'TI', 'TO', 'VI', 'VO', 'I1', 'O1',
        'TR', 'HR', 'R1', 'R2', 'TP', 'HP', 'P1', 'P2',
        'LP', 'L1', 'CI', 'CO', 'BB');
    DECLARE PN(20) BYTE;

    CANON: PROCEDURE(FILENAME, INFO$P) BYTE;
        DECLARE (FILENAME, INFO$P) ADDRESS;
        DECLARE PATHCH BASED FILENAME BYTE;
        DECLARE PATH BASED FILENAME (1) BYTE;
        DECLARE INFO BASED INFO$P (1) BYTE;
        DECLARE PAIR(0) ADDRESS, (B1, B2) BYTE;
        DECLARE JUNK ADDRESS;
        DECLARE I BYTE;

        ALPHANUM: PROCEDURE BYTE;
            RETURN (PATHCH >= 'A' AND PATHCH <= 'Z')
                OR (PATHCH >= '0' AND PATHCH <= '9');
        END;

        GETFNCHAR: PROCEDURE;
            IF ALPHANUM THEN DO;
                INFO(I) = PATHCH;
                FILENAME = FILENAME + 1;
                B1 = FALSE;
            END;
        END;

        DO I = 0 TO 9;
            INFO(I) = 0;
        END;

        DO WHILE PATHCH  = ' ';
            FILENAME = FILENAME + 1;
        END;
        IF PATHCH = ':' THEN DO;
            INFO(0) = 0FFH;
            /* DEVICE COMPARISON IS DONE BACKWARDS */
            /* AS PL/M SWAPS WORD STRINGS */
            B2 = PATH(1);
            B1 = PATH(2);
            IF PATH(3) <> ':' THEN
                RETURN 4; 
            DO I = 0 TO LAST(DEVICES);
                IF DEVICES(I) = PAIR(0) THEN
                    INFO(0) = I;
            END;
            IF INFO(0) = 0FFH THEN
                RETURN 5;
            FILENAME = FILENAME + 4;
        END;
        B1 = TRUE;
        DO I = 1 TO 6;
            CALL GETFNCHAR;
        END;
        B2 = B1;
        B1 = PATHCH = '.';
        IF B1 THEN DO;
            FILENAME = FILENAME + 1;
            DO I = 7 TO 9;
                CALL GETFNCHAR;
            END;
        END;
        IF INFO(0) <= 1 THEN
            IF B2 THEN
                RETURN 17H;
            ELSE IF B1 THEN
                RETURN 1CH;
        IF ALPHANUM OR PATHCH = '.' OR PATHCH = ':' THEN
            RETURN 4;
        RETURN 0;
    END;

    DECLARE MODE BYTE INITIAL(WRITEMODE);
    DECLARE MEMSIZE ADDRESS;
    DECLARE BUFFER(128) BYTE;
    DECLARE (SWITCHPTR, FILEPTR, BUFPTR, ACTUAL, STATUS) ADDRESS;
    DECLARE SWITCH BASED SWITCHPTR (1) BYTE;
    DECLARE (AFTOUT, AFTIN) ADDRESS;


    FILE$ERROR: PROCEDURE(STATUS, PTR, CALLEXIT);
        DECLARE (STATUS, PTR) ADDRESS, CALLEXIT BYTE;
        DECLARE ERR$STATUS ADDRESS;

        IF STATUS <> 0 THEN
        DO;
            PTR = DEBLANK(PTR);
            CALL WRITE(0, .(' '), 1, .ERR$STATUS);
            CALL WRITE(0, PTR, DELIMIT(PTR) - PTR, .ERR$STATUS);
            CALL WRITE(0, .(','), 1, .ERR$STATUS);
            CALL REPORTERROR(STATUS);
            IF CALLEXIT THEN
                CALL EXIT;
        END;
    END;





MAIN:
    CALL READ(1, .BUFFER, 128, .ACTUAL, .STATUS);
    CALL CHECKERROR(STATUS);
    BUFPTR = DEBLANK(DELIMIT(DEBLANK(.BUFFER)));
    DO WHILE SEQ(BUFPTR, .(','), 1);
        BUFPTR = DEBLANK(DELIMIT(DEBLANK(BUFPTR + 1)));
    END;
    IF NOT SEQ(.('TO '), BUFPTR, 3) THEN
        CALL CHECKERROR(BAD$SYNTAX);
    ELSE
        FILEPTR = DEBLANK(DELIMIT(BUFPTR));

    SWITCHPTR = DEBLANK(DELIMIT(FILEPTR));
    DO WHILE SWITCH(0) <> CR;
        IF SWITCH(0) = '$' THEN DO;
            IF SWITCH(1) = 'U' THEN
                MODE = UPDATEMODE;
            ELSE DO;
                CALL REPORTERROR(BAD$SWITCH);
                CALL EXIT;
            END;
            SWITCHPTR = DEBLANK(SWITCHPTR + 2);
        END;
        ELSE DO;
            CALL REPORTERROR(BAD$SWITCH);
            CALL EXIT;
        END;
    END; 
    
    if (STATUS := CANON(FILEPTR, .PN)) <> 0 THEN 
        CALL FILEERROR(STATUS, FILEPTR, TRUE);
    IF PN(0) = 0 OR PN(0) = 1 THEN DO;
        CALL RENAME(FILEPTR, FILEPTR, .STATUS);
        IF STATUS <> NO$SUCH$FILE THEN
            IF STATUS <> FILE$EXISTS THEN
                CALL CHECKERROR(STATUS);
            ELSE IF MODE <> UPDATEMODE THEN DO;
                CALL FILEERROR(STATUS, FILEPTR, FALSE);
                /* NOTE ORIGINAL USES ACTUAL VS. STATUS */
                CALL WRITE(0, .(' DELETE', 3FH, ' '), 9, .ACTUAL);
                CALL READ(1, .MEMORY, 128, .ACTUAL, .STATUS);
                CALL CHECKERROR(STATUS);
                IF (MEMORY(0) = 'Y' OR MEMORY = 'Y' + 20H) THEN
                    ;
                ELSE
                    CALL EXIT;
            END;
    END;
    CALL OPEN(.AFTOUT, FILEPTR, MODE, 0, .STATUS);
    CALL FILEERROR(STATUS, FILEPTR, TRUE);
    MEMSIZE = (MEMCHK - .MEMORY) AND 0FF80H;
    IF PN(0) > 1 THEN
        MEMSIZE = 128;      /* NONE FILE DEVICE */
    FILEPTR = DEBLANK(.BUFFER);
    DO WHILE BUFPTR >= FILEPTR;  /* TILL WE HAVE PROCESSED ALL SOURCE */
        STATUS = CANON(FILEPTR, .PN);
        IF PN(0) > 1 THEN
            MEMSIZE = 128;
        CALL OPEN(.AFTIN, FILEPTR, READMODE, 0, .STATUS);
        CALL FILEERROR(STATUS, FILEPTR, TRUE);
        ACTUAL = 1;
        DO WHILE ACTUAL <> 0;
            CALL READ(AFTIN, .MEMORY, MEMSIZE, .ACTUAL, .STATUS);
            CALL WRITE(AFTOUT, .MEMORY, ACTUAL, .STATUS);
        END;
        CALL CLOSE(AFTIN, .STATUS);
        FILEPTR = DEBLANK(DEBLANK(DELIMIT(FILEPTR)) + 1);
    END;
    CALL CLOSE(AFTOUT, .STATUS);
    CALL EXIT;

END;
EOF
delete.plm
1C00H:
DO;
    DECLARE TRUE    LITERALLY '0FFH',
            FALSE   LITERALLY '0',
            CR      LITERALLY '0DH',
            LF      LITERALLY '0AH';

    DECLARE VER DATA(1, 12H);
    DECLARE COPYRIGNT DATA('COPYRIGHT (C) INTEL 1975,1976');

    ISIS: PROCEDURE(CMD, PARAM$P);
        DECLARE CMD BYTE, PARAM$P ADDRESS;
        GOTO 40H;
    END ISIS;

    READ: PROCEDURE(CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P) ADDRESS;

        CALL ISIS(3, .CONN);
    END;

    WRITE: PROCEDURE(CONN, BUFF$P, COUNT, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, STATUS$P) ADDRESS;

        CALL ISIS(4, .CONN);
    END;

    DELETE: PROCEDURE (PATH$P, STATUS$P);
        DECLARE (PATH$P, STATUS$P) ADDRESS;

        CALL ISIS(2, .PATH$P);
    END DELETE;

    ERROR: PROCEDURE(ERROR$NUM);
        DECLARE (ERROR$NUM, STATUS) ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(12, .ERROR$NUM);
    END;

    EXIT: PROCEDURE;
        DECLARE STATUS ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(9, .STATUS);
    END;

    DEBLANK: PROCEDURE(PTR) ADDRESS;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE (C = ' ');
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;

    DELIMIT: PROCEDURE(PTR) ADDRESS;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE (C = ':' OR C = '.' OR
                 ('0' <= C AND C <= '9') OR
                 ('A' <= C AND C <= 'Z'));
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;

    NUMOUT: PROCEDURE(VALUE, BASE, LC, BUFADR, WIDTH);
        DECLARE (VALUE, BUFADR) ADDRESS, (BASE, LC, WIDTH) BYTE; 
        DECLARE DIGITS DATA('0123456789ABCDEF');
        DECLARE I BYTE;
        DECLARE BUF BASED BUFADR (1) BYTE;

        DO I = 1 TO WIDTH;
            BUF(WIDTH - I) = DIGITS(VALUE MOD BASE);
            VALUE = VALUE / BASE;   
        END;

        I = 0;
        DO WHILE BUF(I) = '0' AND I < WIDTH - 1;
            BUF(I) = LC;
            I = I + 1;
        END;
    END;

    REPORTERROR: PROCEDURE(ERRNUM);
        DECLARE ERRNUM ADDRESS;
        DECLARE NUMBERBUFFER(4) BYTE, I ADDRESS, STATUS ADDRESS;
     

        DECLARE ERRMSG DATA(0, 0,
            2, 'ILLEGAL AFTN ARGUMENT', 0,
            4, 'INCORRECTLY SPECIFIED FILE', 0,
            5, 'UNRECOGNIZED DEVICE NAME', 0,
            6, 'ATTEMPT TO WRITE TO INPUT DEVICE', 0,
            8, 'ATTEMPT TO READ FROM OUTPUT DEVICE', 0,
            9, 'DIRECTORY FULL', 0,
            0AH, 'NOT ON SAME DISK', 0,
            0BH, 'FILE ALREADY EXISTS', 0,
            0CH, 'FILE IS ALREADY OPEN', 0,
            0DH, 'NO SUCH FILE', 0,
            0EH, 'WRITE PROTECTED', 0,
            0FH, 'LOAD TOO LOW', 0,
            10H, 'BAD LOAD FORMAT', 0,
            11H, 'NOT A DISK FILE', 0,
            12H, 'ILLEGAL ISIS COMMAND', 0,
            13H, 'ATTEMPTED SEEK ON NON-DISK FILE', 0,
            14H, 'ATTEMPTED BACK SEEK TO FAR', 0,
            16H, 'ILLEGAL ACCESS MODE TO OPEN', 0,
            17H, 'MISSING FILENAME', 0,
            19H, 'ILLEGAL ECHO FILE', 0,
            1AH, 'ILLEGAL ATTRIBUTE IDENTIFIER', 0,
            1BH, 'ILLEGAL SEEK COMMAND', 0,
            1CH, 'MISSING EXTENSION', 0,
            1FH, 'CAN', 27H, 'T SEEK ON WRITE ONLY FILE', 0,
            20H, 'CAN', 27H, 'T DELETE OPEN FILE', 0,
            23H, 'SEEK PAST EOF', 0,
            0C9H, 'UNRECOGNIZED SWITCH', 0,
            0CAH, 'UNRECOGNIZED DELIMITER', 0,
            0CBH, 'INVALID SYNTAX', 0,
            0CCH, 'PREMATURE EOF', 0,
            0CEH, 'ILLEGAL DISKETTE LABEL', 0,
            0D0H, 'CHECKSUM ERROR', 0
        );



        IF ERRNUM <> 0 THEN
        DO;
            I = 0;
            DO WHILE I < LENGTH(ERRMSG);
                IF ERRNUM = ERRMSG(I) AND ERRMSG(I + 1) <> 0 THEN
                DO;
                    I = I + 1;
                    CALL WRITE(0, .(' '), 1, .STATUS);
                    DO WHILE ERRMSG(I) <> 0;
                        CALL WRITE(0, .ERRMSG(I), 1, .STATUS);
                        I = I + 1;
                    END;
                    CALL WRITE(0, .(0DH, 0AH), 2, .STATUS);
                    return;
                END;
                ELSE
                DO;
                    DO WHILE ERRMSG(I) <> 0;
                        I = I + 1;
                    END;
                    I = I + 1;
                END;
            end;
            CALL ERROR(ERRNUM);
        END;
    END;

    DECLARE (STATUS, ACTUAL) ADDRESS;
    DECLARE BUFFER(128) BYTE;
    DECLARE BUFPTR ADDRESS, CH BASED BUFPTR BYTE;

MAIN:
    CALL READ(1, .BUFFER, 128, .ACTUAL, .STATUS);
    IF STATUS <> 0 THEN DO;
        CALL REPORTERROR(STATUS);
        CALL EXIT;
    END;

    BUFPTR = DEBLANK(.BUFFER);

    DO WHILE 1;
        ACTUAL = DELIMIT(BUFPTR) - BUFPTR;
        CALL WRITE(0, .(' '), 1, .STATUS);
        CALL WRITE(0, BUFPTR, ACTUAL, .STATUS);
        CALL WRITE(0, .(', '), 2, .STATUS);
        CALL DELETE(BUFPTR, .STATUS);
        IF STATUS <> 0 THEN
            CALL REPORTERROR(STATUS);
        ELSE
            CALL WRITE(0, .('DELETED', CR, LF), 9, .STATUS);
        BUFPTR = DEBLANK(DELIMIT(BUFPTR));
        IF CH = CR THEN
            CALL EXIT;
        IF CH = ',' THEN
            BUFPTR = DEBLANK(BUFPTR + 1);
        ELSE DO;
            CALL REPORTERROR(0CBH);
            CALL EXIT;
        END;
    END;
END;
EOF
dir.plm
1C00H:
DO;
    DECLARE TRUE    LITERALLY '0FFH',
            FALSE   LITERALLY '0',
            CR      LITERALLY '0DH',
            LF      LITERALLY '0AH';

    DECLARE VER DATA(1, 13H);
    DECLARE COPYRIGNT DATA('COPYRIGHT (C) INTEL 1975,1976');

    ISIS: PROCEDURE(CMD, PARAM$P);
        DECLARE CMD BYTE, PARAM$P ADDRESS;
        GOTO 40H;
    END ISIS;

    OPEN: PROCEDURE(CONN$P, PATH$P, ACCESS, ECHO, STATUS$P);
        DECLARE (CONN$P, PATH$P, ACCESS, ECHO, STATUS$P) ADDRESS;

        CALL ISIS(0, .CONN$P);
    END;

    READ: PROCEDURE(CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P) ADDRESS;

        CALL ISIS(3, .CONN);
    END;

    WRITE: PROCEDURE(CONN, BUFF$P, COUNT, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, STATUS$P) ADDRESS;

        CALL ISIS(4, .CONN);
    END;

    CLOSE: PROCEDURE(CONN, STATUS$P);
        DECLARE (CONN, STATUS$P) ADDRESS;

        CALL ISIS(1, .CONN);
    END;

    ERROR: PROCEDURE(ERROR$NUM);
        DECLARE (ERROR$NUM, STATUS) ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(12, .ERROR$NUM);
    END;

    EXIT: PROCEDURE;
        DECLARE STATUS ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(9, .STATUS);
    END;

    DEBLANK: PROCEDURE(PTR) ADDRESS;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE (C = ' ');
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;

    DELIMIT: PROCEDURE(PTR) ADDRESS;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE (C = ':' OR C = '.' OR
                 ('0' <= C AND C <= '9') OR
                 ('A' <= C AND C <= 'Z'));
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;

    NUMOUT: PROCEDURE(VALUE, BASE, LC, BUFADR, WIDTH);
        DECLARE (VALUE, BUFADR) ADDRESS, (BASE, LC, WIDTH) BYTE; 
        DECLARE DIGITS DATA('0123456789ABCDEF');
        DECLARE I BYTE;
        DECLARE BUF BASED BUFADR (1) BYTE;

        DO I = 1 TO WIDTH;
            BUF(WIDTH - I) = DIGITS(VALUE MOD BASE);
            VALUE = VALUE / BASE;   
        END;

        I = 0;
        DO WHILE BUF(I) = '0' AND I < WIDTH - 1;
            BUF(I) = LC;
            I = I + 1;
        END;
    END;

    REPORTERROR: PROCEDURE(ERRNUM);
        DECLARE ERRNUM ADDRESS;
        DECLARE NUMBERBUFFER(4) BYTE, I ADDRESS, STATUS ADDRESS;
     

        DECLARE ERRMSG DATA(0, 0,
            2, 'ILLEGAL AFTN ARGUMENT', 0,
            4, 'INCORRECTLY SPECIFIED FILE', 0,
            5, 'UNRECOGNIZED DEVICE NAME', 0,
            6, 'ATTEMPT TO WRITE TO INPUT DEVICE', 0,
            8, 'ATTEMPT TO READ FROM OUTPUT DEVICE', 0,
            9, 'DIRECTORY FULL', 0,
            0AH, 'NOT ON SAME DISK', 0,
            0BH, 'FILE ALREADY EXISTS', 0,
            0CH, 'FILE IS ALREADY OPEN', 0,
            0DH, 'NO SUCH FILE', 0,
            0EH, 'WRITE PROTECTED', 0,
            0FH, 'LOAD TOO LOW', 0,
            10H, 'BAD LOAD FORMAT', 0,
            11H, 'NOT A DISK FILE', 0,
            12H, 'ILLEGAL ISIS COMMAND', 0,
            13H, 'ATTEMPTED SEEK ON NON-DISK FILE', 0,
            14H, 'ATTEMPTED BACK SEEK TO FAR', 0,
            16H, 'ILLEGAL ACCESS MODE TO OPEN', 0,
            17H, 'MISSING FILENAME', 0,
            19H, 'ILLEGAL ECHO FILE', 0,
            1AH, 'ILLEGAL ATTRIBUTE IDENTIFIER', 0,
            1BH, 'ILLEGAL SEEK COMMAND', 0,
            1CH, 'MISSING EXTENSION', 0,
            1FH, 'CAN', 27H, 'T SEEK ON WRITE ONLY FILE', 0,
            20H, 'CAN', 27H, 'T DELETE OPEN FILE', 0,
            23H, 'SEEK PAST EOF', 0,
            0C9H, 'UNRECOGNIZED SWITCH', 0,
            0CAH, 'UNRECOGNIZED DELIMITER', 0,
            0CBH, 'INVALID SYNTAX', 0,
            0CCH, 'PREMATURE EOF', 0,
            0CEH, 'ILLEGAL DISKETTE LABEL', 0,
            0D0H, 'CHECKSUM ERROR', 0
        );



        IF ERRNUM <> 0 THEN
        DO;
            I = 0;
            DO WHILE I < LENGTH(ERRMSG);
                IF ERRNUM = ERRMSG(I) AND ERRMSG(I + 1) <> 0 THEN
                DO;
                    I = I + 1;
                    CALL WRITE(0, .(' '), 1, .STATUS);
                    DO WHILE ERRMSG(I) <> 0;
                        CALL WRITE(0, .ERRMSG(I), 1, .STATUS);
                        I = I + 1;
                    END;
                    CALL WRITE(0, .(0DH, 0AH), 2, .STATUS);
                    return;
                END;
                ELSE
                DO;
                    DO WHILE ERRMSG(I) <> 0;
                        I = I + 1;
                    END;
                    I = I + 1;
                END;
            end;
            CALL ERROR(ERRNUM);
        END;
    END;

    UNPATH: PROCEDURE(DIR$P, FILENAME$P);
        DECLARE (DIR$P, FILENAME$p) ADDRESS;
        DECLARE FILENAME BASED FILENAME$P (1) BYTE;
        DECLARE DIR BASED DIR$P (1) BYTE;
        DECLARE I BYTE;

        FILENAME(0) = ':';
        FILENAME(1) = 'F';
        FILENAME(3) = ':';
        IF DIR(0) = 0 THEN
            FILENAME(2) = '0';
        ELSE
            FILENAME(2) = '1';
        FILENAME$P = FILENAME$P + 4;
        DO I = 0 TO 5;
            if (FILENAME(0) := DIR(I + 1)) <> 0 THEN
                FILENAME$P = FILENAME$P + 1;
        END;
        IF DIR(7) <> 0 THEN DO;
            FILENAME(0) = '.';
            FILENAME$P = FILENAME$P + 1;
        END; 
        DO I = 0 TO 2;
            if (FILENAME(0) := DIR(I + 7)) <> 0 THEN
                FILENAME$P = FILENAME$P + 1;
        END;
        FILENAME(0) = ' ';
    END; 


    /* READ IN DIRECTORY ENTRY */
    DECLARE DIRECT$STATUS BYTE,
            DIRECT$NAME(6) BYTE,
            DIRECT$EXT(3) BYTE,
            DIRECT$ATTRIB BYTE,
            DIRECT$EOF$CNT BYTE,
            DIRECT$BLKCNT ADDRESS,
            DIRECT$HDRBLK ADDRESS;
    DECLARE PADDING(4) BYTE;
    

    LISTDIR: PROCEDURE(DRIVE, AFTOUT, FASTOUTPUT, LISTINVISIBLE);
        DECLARE (DRIVE, AFTOUT, FASTOUTPUT, LISTINVISIBLE) BYTE;
        DECLARE (AFT, STATUS, ACTUAL, PAD, USED) ADDRESS;

        DECLARE (HIFSIZE, LOFSIZE, BLKTOTAL) ADDRESS;
        DECLARE BUF(15) BYTE;
        DECLARE ISISLAB(13) BYTE INITIAL(':F :ISIS.LAB ');
        DECLARE ISISDIR(13) BYTE INITIAL(':F :ISIS.DIR ');
        DECLARE CRLF(2) BYTE INITIAL(CR, LF);
        DECLARE NAME(15) BYTE, I BYTE, NAMEPART BYTE;

        ADDTOTAL: PROCEDURE(DELTA);
            DECLARE DELTA ADDRESS;
            IF (LOFSIZE := LOFSIZE + DELTA) > 9999 THEN DO;
                LOFSIZE = LOFSIZE - 10000;
                HIFSIZE = HIFSIZE + 1;
            END;
            
        END;

        BLKTOTAL = 0;
        ISISLAB(2), ISISDIR(2) = DRIVE + '0';
        CALL OPEN(.AFT, .ISISLAB, 1, 0, .STATUS);
        BUF(0) = DRIVE;
        CALL READ(AFT, .BUF + 1, 9, .ACTUAL, .STATUS);
        CALL WRITE(AFTOUT, .('DIRECTORY OF '), 13, .STATUS);
        CALL UNPATH(.BUF, .NAME);
        I = DELIMIT(.NAME) - .NAME;
        CALL WRITE(AFTOUT, .NAME, I, .STATUS);
        CALL WRITE(AFTOUT, .(CR, LF), 2, .STATUS);
        CALL CLOSE(AFT, .STATUS);

        IF NOT FASTOUTPUT THEN
            CALL WRITE(AFTOUT, .('NAME  .EXT BLKS   LENGTH ATTR', CR, LF),
                                                                    31, .STATUS);
     
        
        CALL OPEN(.AFT, .ISISDIR, 1, 0, .STATUS);
        ACTUAL = 16;
        DIRECT$STATUS = 10H;
       
        DO WHILE ACTUAL = 16 AND DIRECT$STATUS <> 7FH;
            CALL READ(AFT, .DIRECT$STATUS, 16, .ACTUAL, .STATUS);
            IF ACTUAL = 16 AND NOT DIRECT$STATUS  
              AND ((DIRECT$ATTRIB AND 1) = 0 OR LISTINVISIBLE) THEN DO;
                DO I = 0 TO 8;
                    IF DIRECT$NAME(I) = 0 THEN
                        DIRECT$NAME(I) = ' ';
                END;
                I = 9;
                IF FASTOUTPUT THEN
                    DO WHILE DIRECT$NAME(I - 1) = ' ';
                        I = I - 1;
                    END;
                IF NOT FASTOUTPUT OR I > 6 THEN
                    NAMEPART = 6;
                ELSE
                    NAMEPART = I; 
                CALL WRITE(AFTOUT, .DIRECT$NAME, NAMEPART, .STATUS);
                IF FASTOUTPUT THEN DO;
                    IF I > 6 THEN DO;
                        CALL WRITE(AFTOUT, .('.'), 1, .STATUS);
                        CALL WRITE(AFTOUT, .DIRECT$EXT, I - 6, .STATUS);
                    END;
                END;
                ELSE DO;
                    IF DIRECT$EXT(0) <> ' ' THEN
                        CALL WRITE(AFTOUT, .('.'), 1, .STATUS);
                    CALL WRITE(AFTOUT, .DIRECT$EXT, 3, .STATUS);
                    IF DIRECT$EXT(0) = ' ' THEN
                        CALL WRITE(AFTOUT, .(' '), 1, .STATUS);

                    USED = DIRECT$BLKCNT;
                    IF USED > 0 THEN
                        USED = USED + (USED + 61) / 62;
                    ELSE
                        USED = 1;
                    BLKTOTAL = BLKTOTAL + USED;
                    CALL NUMOUT(USED, 10, ' ', .BUF, 5);
                    CALL WRITE(AFTOUT, .BUF, 5, .STATUS);
                    
                    USED = DIRECT$BLKCNT;
                    LOFSIZE = 0;
                    HIFSIZE = 0;
                    IF USED > 0 THEN DO;
                        USED = USED - 1;
                        CALL ADDTOTAL(DIRECT$EOF$CNT);
                        DO WHILE USED > 0;
                            USED = USED - 1;
                            CALL ADDTOTAL(128);
                        END;
                    END;
                    IF HIFSIZE <> 0 THEN DO;
                        CALL NUMOUT(HIFSIZE, 10, ' ', .BUF, 5);
                        CALL NUMOUT(LOFSIZE, 10, '0', .BUF(5), 4);
                    END;
                    ELSE
                        CALL NUMOUT(LOFSIZE, 10, ' ', .BUF, 9);
                    CALL WRITE(AFTOUT, .BUF, 9, .STATUS);

                    IF DIRECT$ATTRIB <> 0 THEN DO;
                        DO I = 0 TO 4;
                            BUF(I) = ' ';
                        END;
                        IF (DIRECT$ATTRIB AND 4) <> 0 THEN
                            BUF(1) = 'W';
                        IF (DIRECT$ATTRIB AND 2) <> 0 THEN
                            BUF(2) = 'S';
                        IF (DIRECT$ATTRIB AND 1) <> 0 THEN
                            BUF(3) = 'I';
                        IF (DIRECT$ATTRIB AND 80H) <> 0 THEN
                            BUF(4) = 'F';
                        CALL WRITE(AFTOUT, .BUF, 5, .STATUS);
                    END; 
                END;
                CALL WRITE(AFTOUT, .CRLF, 2, .STATUS);
            END;
        END;
        IF NOT FASTOUTPUT THEN DO;
            CALL NUMOUT(BLKTOTAL, 10, ' ', .BUF, 15);
            CALL WRITE(AFTOUT, .BUF, 15, .STATUS);
            CALL WRITE(AFTOUT, .CRLF, 2, .STATUS);
        END;
        CALL CLOSE(AFTOUT, .STATUS);
    END;


    SEQ: PROCEDURE(S1, S2, CNT) BYTE;
        DECLARE (S1,S2) ADDRESS, CNT BYTE;
        DECLARE S1A BASED S1(1) BYTE;
        DECLARE S2A BASED S2(1) BYTE;
        DECLARE I BYTE;
        CNT = CNT - 1;
        DO I = 0 TO CNT;
            IF S1A(I) <> S2A(I) THEN
                RETURN 0;
        END;
        RETURN 0FFH;
    END;





    DECLARE (AFTOUT, ACTUAL, STATUS) ADDRESS;
    DECLARE PAD BYTE,
            DRIVE BYTE INITIAL(0),
            LISTINVISIBLE BYTE INITIAL(FALSE),
            FASTOUTPUT BYTE INITIAL(FALSE);
    DECLARE BUFPTR ADDRESS, CH BASED BUFPTR BYTE;
    DECLARE BUFFER(128) BYTE;

MAIN:
    CALL READ(1, .BUFFER, 128, .ACTUAL, .STATUS);
    BUFPTR = DEBLANK(.BUFFER);
    AFTOUT = 0;
    IF SEQ(.('TO'), BUFPTR, 2) THEN DO;
        BUFPTR = DEBLANK(BUFPTR + 2);
        CALL OPEN(.AFTOUT, BUFPTR, 2, 0, .STATUS);
        IF STATUS <> 0 THEN DO;
            CALL REPORTERROR(STATUS);
            CALL EXIT;
        END;
        BUFPTR = DEBLANK(DELIMIT(BUFPTR));
    END;
    DO WHILE CH = '$';
        BUFPTR = BUFPTR + 1;
        IF CH = '1' THEN
            DRIVE = 1;
        ELSE IF CH = 'I' THEN
            LISTINVISIBLE = TRUE;
        ELSE IF CH = 'F' THEN
            FASTOUTPUT = TRUE;
        ELSE DO;
            CALL REPORTERROR(0C9H);
            CALL EXIT;
        END;
        BUFPTR = DEBLANK(DELIMIT(BUFPTR));
    END;
    IF CH <> CR THEN DO;
        CALL REPORTERROR(0C9H);
        CALL EXIT;
    END;
    CALL LISTDIR(DRIVE, AFTOUT, FASTOUTPUT, LISTINVISIBLE);
    CALL EXIT; 
         

END;
EOF
edit.plm
1C00H:

DECLARE LIT LITERALLY 'LITERALLY';
DECLARE BELL LIT '7',
        BS  LIT '8',
        TAB LIT '9',
        LF  LIT '0AH',
        VT  LIT '0BH',
        FF  LIT '0CH',
        CR  LIT '0DH',
        ESC LIT '1BH',
        DQUOTE LIT '22H',
        HASH LIT '23H';

DECLARE CTRLC   LIT '3',
        CTRLR   LIT '12h',
        CTRLX   LIT '18h',
        CTRLZ   LIT '1Ah',
        RUBOUT  LIT '7FH';

DECLARE ISALPHA LIT '0',
        ISNUMBER   LIT '1',
        ISOTHER lIT '2';

DECLARE TRUE    LIT '0FFH',
        FALSE   LIT '0',
        BOOL    LIT 'BYTE';

DECLARE VERS DATA(1, 9),
        COPYRIGHT DATA('COPYRIGHT (C) INTEL 1975,1976');

DECLARE SIGNON DATA(CR, LF, '16K ISIS TEXT EDITOR, V1.2', CR, LF);

DECLARE ILLEGAL DATA(DQUOTE, ' ILLEGAL IN THIS CONTEXT', CR, LF);
DECLARE NOTFOUND DATA(CR, LF, 'CANNOT FIND ');
DECLARE DQCHAR DATA(DQUOTE);    /* NOT ACTUALLY USED */
/* ONLY THE FIRST CHAR OF BEGIN PUNCH IS EVER USED */
DECLARE BEGINPUNCH DATA(CR, LF, CR, LF, 'START PUNCH, TYPE CHAR', CR, LF);
DECLARE ITERFAULT DATA(CR, LF, 'ITERATION STACK FAULT');

DECLARE USRBREAK DATA(CR, LF, '*BREAK*', CR, LF);
DECLARE NEWFILE DATA('NEW FILE', CR, LF);

DECLARE W37CA ADDRESS,
        (TEXTPTR, ENDPTR) ADDRESS,
        (W37D0, W37D2) ADDRESS,
        (CMDCNT, W37D6, W37D8) ADDRESS,
        MEMSIZE ADDRESS,
        (CHAR, CHTYPE, BACKWARDS, CURCOL) BYTE,
        (ITER$SP, B37E1, B37E2) BYTE,
        FINDLEN BYTE;
DECLARE INBUF(128) BYTE,
        INACTUAL ADDRESS,
        INPTR ADDRESS,
        ACTUAL ADDRESS,
        STATUS ADDRESS,
        (AFTIN, AFTOUT) ADDRESS,
        PAD3870(3) BYTE,
        MODE BYTE,
        (INPUT$PTR, BUFFER$PTR, OUTPUT$PTR) ADDRESS,
        W387A ADDRESS,
        PAD37C BYTE,
        BUFFER(128) BYTE,
        BA38FD(16) BYTE,
        FINDBUF(17) BYTE,
        ITER$STACK$PTR(8) ADDRESS,
        ITER$STACK$CNT(8) ADDRESS;


DECLARE BREAK LABEL;

    CI: PROCEDURE BYTE;
        GOTO 0F803H;
    END;

    CO: PROCEDURE(C);
        DECLARE C BYTE;
        GOTO 0F809H;
    END;

	CSTS: PROCEDURE BYTE;
		GOTO 0F812H;
	END;

    IOCHK: PROCEDURE BYTE;
        GOTO 0F815H;
    END;

    MEMCHK: PROCEDURE ADDRESS;
        GOTO 0F81BH;
    END;

    ISIS: PROCEDURE(CMD, PARAM$P);
        DECLARE CMD BYTE, PARAM$P ADDRESS;
        GOTO 40H;
    END ISIS;

    READ: PROCEDURE(CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P) ADDRESS;

        CALL ISIS(3, .CONN);
    END;

    WRITE: PROCEDURE(CONN, BUFF$P, COUNT, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, STATUS$P) ADDRESS;

        CALL ISIS(4, .CONN);
    END;

    EXIT: PROCEDURE;
        DECLARE STATUS ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(9, .STATUS);
    END;

    OPEN: PROCEDURE(CONN$P, PATH$P, ACCESS, ECHO, STATUS$P);
        DECLARE (CONN$P, PATH$P, ACCESS, ECHO, STATUS$P) ADDRESS;

        CALL ISIS(0, .CONN$P);
    END;

    CLOSE: PROCEDURE(CONN, STATUS$P);
        DECLARE (CONN, STATUS$P) ADDRESS;

        CALL ISIS(1, .CONN);
    END;

    DELETE: PROCEDURE (PATH$P, STATUS$P);
        DECLARE (PATH$P, STATUS$P) ADDRESS;

        CALL ISIS(2, .PATH$P);
    END DELETE;

	RENAME: PROCEDURE(OLD$P, NEW$P, STATUS$P);
    	DECLARE (OLD$P, NEW$P, STATUS$P) ADDRESS;
    	
    	CALL ISIS(7, .OLD$P);
	END;

    ERROR: PROCEDURE(ERROR$NUM);
        DECLARE (ERROR$NUM, STATUS) ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(12, .ERROR$NUM);
    END;

    SEQ: PROCEDURE(S1, S2, CNT) BYTE;
        DECLARE (S1,S2) ADDRESS, CNT BYTE;
        DECLARE S1A BASED S1(1) BYTE;
        DECLARE S2A BASED S2(1) BYTE;
        DECLARE I BYTE;
        CNT = CNT - 1;
        DO I = 0 TO CNT;
            IF S1A(I) <> S2A(I) THEN
                RETURN 0;
        END;
        RETURN 0FFH;
    END;

    NUMOUT: PROCEDURE(VALUE, BASE, LC, BUFADR, WIDTH);
        DECLARE (VALUE, BUFADR) ADDRESS, (BASE, LC, WIDTH) BYTE; 
        DECLARE DIGITS DATA('0123456789ABCDEF');
        DECLARE I BYTE;
        DECLARE BUF BASED BUFADR (1) BYTE;

        DO I = 1 TO WIDTH;
            BUF(WIDTH - I) = DIGITS(VALUE MOD BASE);
            VALUE = VALUE / BASE;   
        END;

        I = 0;
        DO WHILE BUF(I) = '0' AND I < WIDTH - 1;
            BUF(I) = LC;
            I = I + 1;
        END;
    END;

    REPORTERROR: PROCEDURE(ERRNUM);
        DECLARE ERRNUM ADDRESS;
        DECLARE NUMBERBUFFER(4) BYTE, I ADDRESS, STATUS ADDRESS;
     

        DECLARE ERRMSG DATA(0, 0,
            2, 'ILLEGAL AFTN ARGUMENT', 0,
            4, 'INCORRECTLY SPECIFIED FILE', 0,
            5, 'UNRECOGNIZED DEVICE NAME', 0,
            6, 'ATTEMPT TO WRITE TO INPUT DEVICE', 0,
            8, 'ATTEMPT TO READ FROM OUTPUT DEVICE', 0,
            9, 'DIRECTORY FULL', 0,
            0AH, 'NOT ON SAME DISK', 0,
            0BH, 'FILE ALREADY EXISTS', 0,
            0CH, 'FILE IS ALREADY OPEN', 0,
            0DH, 'NO SUCH FILE', 0,
            0EH, 'WRITE PROTECTED', 0,
            0FH, 'LOAD TOO LOW', 0,
            10H, 'BAD LOAD FORMAT', 0,
            11H, 'NOT A DISK FILE', 0,
            12H, 'ILLEGAL ISIS COMMAND', 0,
            13H, 'ATTEMPTED SEEK ON NON-DISK FILE', 0,
            14H, 'ATTEMPTED BACK SEEK TO FAR', 0,
            16H, 'ILLEGAL ACCESS MODE TO OPEN', 0,
            17H, 'MISSING FILENAME', 0,
            19H, 'ILLEGAL ECHO FILE', 0,
            1AH, 'ILLEGAL ATTRIBUTE IDENTIFIER', 0,
            1BH, 'ILLEGAL SEEK COMMAND', 0,
            1CH, 'MISSING EXTENSION', 0,
            1FH, 'CAN', 27H, 'T SEEK ON WRITE ONLY FILE', 0,
            20H, 'CAN', 27H, 'T DELETE OPEN FILE', 0,
            23H, 'SEEK PAST EOF', 0,
            0C9H, 'UNRECOGNIZED SWITCH', 0,
            0CAH, 'UNRECOGNIZED DELIMITER', 0,
            0CBH, 'INVALID SYNTAX', 0,
            0CCH, 'PREMATURE EOF', 0,
            0CEH, 'ILLEGAL DISKETTE LABEL', 0,
            0D0H, 'CHECKSUM ERROR', 0
        );



        IF ERRNUM <> 0 THEN
        DO;
            I = 0;
            DO WHILE I < LENGTH(ERRMSG);
                IF ERRNUM = ERRMSG(I) AND ERRMSG(I + 1) <> 0 THEN
                DO;
                    I = I + 1;
                    CALL WRITE(0, .(' '), 1, .STATUS);
                    DO WHILE ERRMSG(I) <> 0;
                        CALL WRITE(0, .ERRMSG(I), 1, .STATUS);
                        I = I + 1;
                    END;
                    CALL WRITE(0, .(0DH, 0AH), 2, .STATUS);
                    return;
                END;
                ELSE
                DO;
                    DO WHILE ERRMSG(I) <> 0;
                        I = I + 1;
                    END;
                    I = I + 1;
                END;
            end;
            CALL ERROR(ERRNUM);
        END;
    END;

    DEBLANK: PROCEDURE(PTR) ADDRESS;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE (C = ' ');
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;

    DELIMIT: PROCEDURE(PTR) ADDRESS;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE (C = ':' OR C = '.' OR
                 ('0' <= C AND C <= '9') OR
                 ('A' <= C AND C <= 'Z'));
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;

    FILE$ERROR: PROCEDURE(STATUS, PTR, CALLEXIT);
        DECLARE (STATUS, PTR) ADDRESS, CALLEXIT BYTE;
        DECLARE ERR$STATUS ADDRESS;

        IF STATUS <> 0 THEN
        DO;
            PTR = DEBLANK(PTR);
            CALL WRITE(0, .(' '), 1, .ERR$STATUS);
            CALL WRITE(0, PTR, DELIMIT(PTR) - PTR, .ERR$STATUS);
            CALL WRITE(0, .(','), 1, .ERR$STATUS);
            CALL REPORTERROR(STATUS);
            IF CALLEXIT THEN
                CALL EXIT;
        END;
    END;

    /* POSSIBLY PAD BYTE NEEDED HERE */

    DECLARE DEVICES(21) ADDRESS INITIAL(
        'F0', 'F1', 'TI', 'TO', 'VI', 'VO', 'I1', 'O1',
        'TR', 'HR', 'R1', 'R2', 'TP', 'HP', 'P1', 'P2',
        'LP', 'L1', 'CI', 'CO', 'BB');
    DECLARE PN(20) BYTE;

    CANON: PROCEDURE(FILENAME, INFO$P) BYTE;
        DECLARE (FILENAME, INFO$P) ADDRESS;
        DECLARE PATHCH BASED FILENAME BYTE;
        DECLARE PATH BASED FILENAME (1) BYTE;
        DECLARE INFO BASED INFO$P (1) BYTE;
        DECLARE PAIR(0) ADDRESS, (B1, B2) BYTE;
        DECLARE (JUNK, I) BYTE;

        ALPHANUM: PROCEDURE BYTE;
            RETURN (PATHCH >= 'A' AND PATHCH <= 'Z')
                OR (PATHCH >= '0' AND PATHCH <= '9');
        END;

        GETFNCHAR: PROCEDURE;
            IF ALPHANUM THEN DO;
                INFO(I) = PATHCH;
                FILENAME = FILENAME + 1;
                B1 = FALSE;
            END;
        END;

        DO I = 0 TO 9;
            INFO(I) = 0;
        END;

        DO WHILE PATHCH  = ' ';
            FILENAME = FILENAME + 1;
        END;
        IF PATHCH = ':' THEN DO;
            INFO(0) = 0FFH;
            /* DEVICE COMPARISON IS DONE BACKWARDS */
            /* AS PL/M SWAPS WORD STRINGS */
            B2 = PATH(1);
            B1 = PATH(2);
            IF PATH(3) <> ':' THEN
                RETURN 4; 
            DO I = 0 TO LAST(DEVICES);
                IF DEVICES(I) = PAIR(0) THEN
                    INFO(0) = I;
            END;
            IF INFO(0) = 0FFH THEN
                RETURN 5;
            FILENAME = FILENAME + 4;
        END;
        B1 = TRUE;
        DO I = 1 TO 6;
            CALL GETFNCHAR;
        END;
        B2 = B1;
        B1 = PATHCH = '.';
        IF B1 THEN DO;
            FILENAME = FILENAME + 1;
            DO I = 7 TO 9;
                CALL GETFNCHAR;
            END;
        END;
        IF INFO(0) <= 1 THEN
            IF B2 THEN
                RETURN 17H;
            ELSE IF B1 THEN
                RETURN 1CH;
        IF ALPHANUM OR PATHCH = '.' OR PATHCH = ':' THEN
            RETURN 4;
        RETURN 0;
    END;

    UNPATH: PROCEDURE(DIR$P, FILENAME$P);
        DECLARE (DIR$P, FILENAME$p) ADDRESS;
        DECLARE FILENAME BASED FILENAME$P (1) BYTE;
        DECLARE DIR BASED DIR$P (1) BYTE;
        DECLARE I BYTE;

        FILENAME(0) = ':';
        FILENAME(1) = 'F';
        FILENAME(3) = ':';
        IF DIR(0) = 0 THEN
            FILENAME(2) = '0';
        ELSE
            FILENAME(2) = '1';
        FILENAME$P = FILENAME$P + 4;
        DO I = 0 TO 5;
            if (FILENAME(0) := DIR(I + 1)) <> 0 THEN
                FILENAME$P = FILENAME$P + 1;
        END;
        IF DIR(7) <> 0 THEN DO;
            FILENAME(0) = '.';
            FILENAME$P = FILENAME$P + 1;
        END; 
        DO I = 0 TO 2;
            if (FILENAME(0) := DIR(I + 7)) <> 0 THEN
                FILENAME$P = FILENAME$P + 1;
        END;
        FILENAME(0) = ' ';
    END;


    GETCHAR: PROCEDURE BYTE;
        RETURN CI AND 7FH;
    END;

    DISPLAYCHAR: PROCEDURE(CH);
        DECLARE (CH, SPACES, I) BYTE;

        SPACES = CH = TAB AND (7 - (CURCOL AND 7));
        IF CH = TAB THEN
            CH = ' ';
        DO I = 0 TO SPACES;
            IF CH = CR THEN
                CURCOL = 0;
            IF CH = FF THEN
                CH = 21H;  /* EXCLAMATION MARK */
            IF CH = ESC OR CH = 07DH THEN
                CH = '$';
            IF CH >= ' ' THEN
                CURCOL = CURCOL + 1;
            CALL CO(CH);
        END;
    END;


    DISPLAYTEXT: PROCEDURE(STR$P,  LEN);
        DECLARE (STR$P, LEN, I) ADDRESS;
        DECLARE STR BASED STR$P (1) BYTE;

        DO I = 0 TO LEN;
            CALL DISPLAYCHAR(STR(I));
            IF CSTS AND (IOCHK AND 0FCH) <> 2 THEN
                IF GETCHAR = 3 THEN DO;
                    GOTO BREAK;
                END;
        END;
    END;
                
    GETC: PROCEDURE BYTE;
        IF INPTR >= INACTUAL THEN DO;
            CALL READ(AFTIN, .INBUF, 128, .INACTUAL, .STATUS);
            CALL FILEERROR(STATUS, INPUT$PTR, TRUE);
            IF INACTUAL < 128 THEN
                INBUF(INACTUAL) = CTRLZ;
            INPTR = 0;
        END;
        INPTR = INPTR + 1;
        RETURN INBUF(INPTR - 1) AND 7FH;
    END;

    MOVEUP: PROCEDURE;
        DECLARE DSTIDX ADDRESS;

        IF ITER$SP <> 0 THEN
            RETURN;
        DSTIDX = MEMSIZE - 1;

        DO WHILE W37D8 >= W37CA;
            MEMORY(DSTIDX) = MEMORY(W37D8);
            DSTIDX = DSTIDX - 1;
            W37D8 = W37D8 - 1;
        END;
        W37CA = DSTIDX + 1;
        W37D8 = MEMSIZE - 1;
    END;


    ISMARKER: PROCEDURE(CHAR) BOOL;
        DECLARE (CHAR, I) BYTE;
        DECLARE MARKERS DATA(LF, VT, FF);
        DO I = 0 TO 2;
            IF MARKERS(I) = CHAR THEN
                RETURN TRUE;
        END;
        RETURN FALSE;
    END;

    /* GET TEXT INTO MEMORY UNTIL ESC ESC */
    /* NOTE TEXT IS COLLECTED BACKWARDS FROM TOP OF MEMORY */
    GETTEXT: PROCEDURE;
        DECLARE (INCH, PREVINCH) BYTE;
        DECLARE IDX ADDRESS;

        DO WHILE 1;
            B37E1 = FALSE;
            W37CA = MEMSIZE;
            W37D8 = MEMSIZE - 1;
            PREVINCH = FALSE;
            ITER$SP = 0;
            CALL DISPLAYCHAR('*');
            INCH = GETCHAR;

            DO WHILE INCH <> CTRLC;    /* 27B2 */
                DO WHILE INCH = RUBOUT;
                    IF W37CA <> MEMSIZE THEN DO;
                        IF (INCH := MEMORY(W37CA)) = ESC THEN
                            INCH = '$';
                        CALL DISPLAYCHAR(INCH);
                        W37CA = W37CA + 1;
                        INCH = GETCHAR;
                        PREVINCH = 0;
                    END;
                    ELSE DO;
                        INCH = 3;
                        CALL DISPLAYCHAR(BELL);
                    END;
                END;
                IF INCH = CTRLX THEN DO;
                    CALL DISPLAYCHAR(HASH);
                    CALL DISPLAYTEXT(.BEGINPUNCH, 1);
                    DO WHILE W37CA <> MEMSIZE AND NOT ISMARKER(MEMORY(W37CA));
                        W37CA = W37CA + 1;
                    END;
                    INCH = GETCHAR;
                END;
                ELSE IF INCH = CTRLR THEN DO;
                    CALL DISPLAYTEXT(.BEGINPUNCH, 1);
                    IDX = W37CA;
                    DO WHILE IDX < MEMSIZE AND NOT ISMARKER(MEMORY(IDX));
                        IDX = IDX + 1;
                    END;
                    DO WHILE IDX <> W37CA;
                        CALL DISPLAYCHAR(MEMORY(IDX := IDX - 1));
                    END;
                    INCH = GETCHAR;
                END;
                ELSE IF ENDPTR >= W37CA - 10 THEN DO;
                    INCH = GETCHAR;
                    CALL DISPLAYCHAR(BELL);
                END;
                ELSE DO;
                    IF INCH = CR THEN DO;
                        MEMORY(W37CA := W37CA - 1) = CR;
                        CALL DISPLAYCHAR(CR);
                        INCH = LF;
                    END;
                    IF INCH  <> 3 THEN DO;
                        IF INCH = 7DH THEN
                            INCH = ESC;
                        IF INCH = ESC THEN
                            CALL DISPLAYCHAR('$');
                        ELSE
                            CALL DISPLAYCHAR(INCH);
                        MEMORY(W37CA := W37CA - 1) = INCH;
                        IF INCH = ESC and PREVINCH = ESC THEN DO;
                            CALL DISPLAYTEXT(.BEGINPUNCH, 1);
                            RETURN;
                        END;
                        PREVINCH = INCH;
                        INCH = GETCHAR;                   
                    END;
                END; /* 2982 */
            END;
            CALL  DISPLAYTEXT(.BEGINPUNCH, 1);
        END;    /* WHILE 1 */
    END;

    GETCMDCH: PROCEDURE BYTE;
        DECLARE CH BYTE;

        IF W37D8 < W37CA THEN
            CALL GETTEXT;
        IF CSTS AND (IOCHK AND 0FCH) <> 2 THEN
            IF GETCHAR = 3 THEN
                CALL GETTEXT;
        CHTYPE = ISOTHER;
        CH = MEMORY(W37D8); 
        IF CH >= 'A' AND CH <= 'Z' THEN
            CHTYPE = ISALPHA;
        IF (CH >= '0' AND CH <= '9') OR CH = '+' OR CH = '-' THEN
            CHTYPE = ISNUMBER;
        W37D8 = W37D8 - 1;
        RETURN CH;
     END;

    GETCMDNUM: PROCEDURE ADDRESS;
        DECLARE VAL ADDRESS;
        IF CHAR = '-' THEN DO;
            BACKWARDS = TRUE;
            CHAR = GETCMDCH;
        END;
        ELSE IF CHAR = '+' THEN
            CHAR = GETCMDCH;
        VAL =  0;
        DO WHILE CHTYPE = ISNUMBER;
            /* VAL = VAL * 10 + CHAR - '0' */
            VAL = SHL(SHL(VAL, 2) + VAL, 1) + CHAR - '0';
            CHAR = GETCMDCH;
        END;
        IF VAL = 0 AND BACKWARDS THEN
            RETURN 1;
        RETURN VAL;
    END;

    FINDREL: PROCEDURE ADDRESS;
        DECLARE START ADDRESS, (I, CH) BYTE;

        START = 0;
        DO WHILE MEMORY(TEXTPTR + START) <> 0FFH;
            I = 0;
            DO WHILE (CH := MEMORY(TEXTPTR + START + I)) = FINDBUF(I);
                IF FINDBUF(I + 1) = ESC THEN
                    RETURN START;
                I = I + 1;
            END;
            IF CH = 0FFH THEN
                RETURN 0FFFFH;
            START = START + 1;
        END;
        RETURN 0FFFFH;
    END;



    SEEKLINE: PROCEDURE ADDRESS;
        DECLARE STARTLINE ADDRESS, (JUNK, CH) BYTE;

        STARTLINE = TEXTPTR;
        IF CMDCNT = 0 OR BACKWARDS THEN DO;
            IF TEXTPTR = ENDPTR AND TEXTPTR <> 1 THEN
                STARTLINE = STARTLINE - 1;
            CMDCNT = CMDCNT + 1;
            DO WHILE CMDCNT <> 0 and TEXTPTR <> 1;
                IF (CH := MEMORY(STARTLINE)) = 0FFH THEN
                    RETURN STARTLINE + 1;
                IF (ISMARKER(CH)) THEN
                    CMDCNT = CMDCNT - 1;
                STARTLINE = STARTLINE - 1;
            END;
            RETURN STARTLINE + 2;   /* AFTER THE MARKER */
        END;
        DO WHILE CMDCNT <> 0;
            IF (CH := MEMORY(STARTLINE)) = 0FFH THEN
                RETURN STARTLINE;
            IF (ISMARKER(CH)) THEN
                CMDCNT = CMDCNT - 1;
            STARTLINE = STARTLINE + 1;
        END;
        RETURN STARTLINE;
    END;


    FINDLOC: PROCEDURE ADDRESS;
        DECLARE RELOFFSET ADDRESS;
 
        FINDLEN = 0;
        DO WHILE (FINDBUF(FINDLEN) := GETCMDCH) <> ESC;
            IF FINDLEN < 16 THEN
                FINDLEN = FINDLEN + 1;
        END;
        if (RELOFFSET := FINDREL) = 0FFFFH THEN DO;
            CALL DISPLAYTEXT(.NOTFOUND, 14);
            IF FINDLEN <> 0 THEN
                CALL DISPLAYTEXT(.FINDBUF, FINDLEN - 1);
            CALL CO(DQUOTE);
            CALL DISPLAYTEXT(.BEGINPUNCH, 1);
            GOTO BREAK;
        END;
        ELSE
            RETURN RELOFFSET + TEXTPTR;
    END;

    MOVEDOWN: PROCEDURE;
        ENDPTR = TEXTPTR;
        DO WHILE W37D2 >= W37D0;
            MEMORY(ENDPTR) = MEMORY(W37D0);
            W37D0 = W37D0 + 1;
            ENDPTR = ENDPTR + 1;
        END;
        MEMORY(ENDPTR := ENDPTR - 1) = 0FFH;
        CALL MOVEUP;
    END;

MAIN:

    INPUT$PTR = .(':CI:');
    CALL READ(1, .BUFFER, 128, .ACTUAL, .STATUS);
    CALL FILEERROR(STATUS, INPUT$PTR, TRUE);
    BUFFER(ACTUAL) = CR;
    INPUT$PTR = DEBLANK(.BUFFER);
    BUFFER$PTR = DEBLANK(DELIMIT(INPUT$PTR));
    CALL DISPLAYTEXT(.SIGNON, 29);
    IF SEQ(BUFFER$PTR, .('TO'), 2) THEN DO;
        OUTPUT$PTR = DEBLANK(BUFFER$PTR + 2 );
        MODE = 2;
    END;
    ELSE DO;
        OUTPUT$PTR = INPUT$PTR;
        MODE = 1;
    END;

    STATUS = CANON(OUTPUT$PTR, .PN);
    IF STATUS <> 0 THEN
        CALL FILEERROR(STATUS, OUTPUT$PTR, TRUE);
    IF PN(0) > 1 THEN DO;
        IF MODE <> 2 THEN
            CALL FILEERROR(11H, OUTPUT$PTR, TRUE);
        BUFFER$PTR = OUTPUT$PTR;
    END;
    ELSE DO;
        IF PN(0) = 0 THEN
            BUFFER$PTR = .('EDIT.TMP ');
        ELSE
            BUFFER$PTR = .(':F1:EDIT.TMP ');
        IF MODE = 1 THEN DO;
            CALL RENAME(INPUT$PTR, INPUT$PTR, .STATUS);
            IF STATUS = 0BH THEN DO;
                PN(7) = 'B';
                PN(8) = 'A';
                PN(9) = 'K';
                CALL UNPATH(.PN, .BA38FD);
                W387A = .BA38FD;
            END;
            ELSE IF STATUS = 0DH THEN DO;
                MODE = 3;
                CALL DISPLAYTEXT(.NEWFILE, 9);
                INPUT$PTR = .(':BB: ');
            END;
            ELSE
                CALL FILEERROR(STATUS, INPUT$PTR, TRUE);
        END;
    END; /* 2F0E */

    CALL OPEN(.AFTIN, INPUT$PTR, 1, 0, .STATUS);
    CALL FILEERROR(STATUS, INPUT$PTR, TRUE);
    INPTR = INACTUAL;
    CALL OPEN(.AFTOUT, BUFFER$PTR, 2, 0, .STATUS);
    CALL FILEERROR(STATUS, BUFFER$PTR, TRUE);
    MEMSIZE = MEMCHK - .MEMORY;
    MEMORY(0) = 0FFH;
    MEMORY(1) = 0FFH;
    TEXTPTR = 1;
    ENDPTR = 1;
    CALL GETTEXT;

CMDLOOP:
    DO WHILE 1;
        W37D0 = TEXTPTR;
        W37D2 = ENDPTR;
        BACKWARDS = FALSE;
        CMDCNT = 1;
        CHAR = GETCMDCH;
        IF CHTYPE = ISNUMBER THEN
            CMDCNT = GETCMDNUM;
        IF CHAR = '<' THEN DO;
                IF (ITER$SP := ITER$SP + 1) > 8 THEN DO;
                    CALL DISPLAYTEXT(.ITERFAULT, 22);
                    GOTO BREAK;
                END;
                ITER$STACK$PTR(ITER$SP) = W37D8;
                ITER$STACK$CNT(ITER$SP) = CMDCNT;
        END;
        ELSE IF CHAR = '>' AND ITER$SP <> 0 THEN DO;
            IF (ITER$STACK$CNT(ITER$SP) := ITER$STACK$CNT(ITER$SP) - 1) <> 0 THEN
                W37D8 = ITER$STACK$PTR(ITER$SP);
            ELSE
                ITER$SP = ITER$SP - 1;
            GOTO CMDLOOP;
        END;
        ELSE IF CHTYPE = ISALPHA THEN DO;
            DO CASE CHAR - 'A';
                DO;             /* 'A' APPEND */
                    B37E2 = TRUE;
                    CMDCNT = 0;
                    DO WHILE B37E2;
                        if ENDPTR >= W37CA - 10 OR B37E1 THEN
                            B37E2 = 0;
                        ELSE IF (CHAR := GETC) <> CTRLZ THEN DO; 
                            IF CHAR <> 0 AND CHAR <> 7FH THEN DO;
                                IF CHAR = FF THEN
                                    B37E2 = 0;
                                MEMORY(ENDPTR) = CHAR;
                                ENDPTR = ENDPTR + 1;
                                IF CHAR = LF THEN
                                    IF (CMDCNT := CMDCNT + 1) = 50 THEN
                                        B37E2 = 0;
                            END;
                        END;
                        ELSE DO;
                            B37E1 = 0FFH;
                            B37E2 = 0;
                        END;
                    END;
                    MEMORY(ENDPTR) = 0FFH;
                    GOTO CMDLOOP;
                END;
                DO;                 /* 'B' TEXT POINTER TO BEGINNING */
                    TEXTPTR = 1;
                    GOTO CMDLOOP;
                END;
                DO;                 /* 'C' TEXT POINTER CHARACTER */
                    IF BACKWARDS THEN DO;
                        IF TEXTPTR - 1 < CMDCNT THEN DO;
                            TEXTPTR = 1;
                            GOTO CMDLOOP;
                        END;
                        ELSE
                            TEXTPTR = TEXTPTR - CMDCNT;
                        GOTO CMDLOOP;
                    END;
                    ELSE IF (W37D6 := TEXTPTR + CMDCNT) > ENDPTR THEN
                        TEXTPTR = ENDPTR;
                    ELSE
                        TEXTPTR = W37D6;
                    GOTO CMDLOOP;
                END;
                DO;             /* 'D' DELETE */
                    IF BACKWARDS THEN DO;
                        IF TEXTPTR < CMDCNT THEN
                            TEXTPTR = 1;
                        ELSE
                            TEXTPTR = TEXTPTR - CMDCNT;
                    END;
                    ELSE IF (W37D6 := TEXTPTR + CMDCNT) > ENDPTR THEN
                        W37D0 = ENDPTR;
                    ELSE
                        W37D0 = W37D6;
                    CALL MOVEDOWN;
                    GOTO CMDLOOP;
                END;
                DO;         /* 'E' EXIT */
                    CALL WRITE(AFTOUT, .MEMORY + 1, ENDPTR - 1, .STATUS);
                    CALL FILEERROR(STATUS, BUFFER$PTR, TRUE);
                    DO WHILE INPTR < INACTUAL;
                        IF (CHAR := GETC) = CTRLZ THEN
                            INPTR = 128;
                        ELSE DO;
                            CALL WRITE(AFTOUT, .CHAR, 1, .STATUS);
                            CALL FILEERROR(STATUS, BUFFER$PTR, TRUE);
                        END;
                    END;

                    ACTUAL = MEMSIZE;
                    DO WHILE ACTUAL <> 0;
                        CALL READ(AFTIN, .MEMORY, MEMSIZE, .ACTUAL, .STATUS);
                        CALL FILEERROR(STATUS, INPUT$PTR, TRUE);
                        CALL WRITE(AFTOUT, .MEMORY, ACTUAL, .STATUS);
                        CALL FILEERROR(STATUS, BUFFER$PTR, TRUE);
                        IF ACTUAL < MEMSIZE THEN
                            ACTUAL = 0;
                    END;
                
                    CALL CLOSE(AFTOUT, .STATUS);
                    CALL FILEERROR(STATUS, BUFFER$PTR, TRUE);
                    CALL CLOSE(AFTIN, .STATUS);
                    CALL FILEERROR(STATUS, INPUT$PTR, TRUE);
                    IF PN(0) <= 1 THEN DO;  /* FILE BASED */
                        IF MODE = 1 THEN DO; 
                            CALL DELETE(W387A, .STATUS);
                            IF STATUS = 0EH THEN
                                CALL FILEERROR(STATUS, W387A, TRUE);
                            CALL RENAME(INPUT$PTR, W387A, .STATUS);
                            CALL FILEERROR(STATUS, INPUT$PTR, TRUE);
                        END;
                        CALL DELETE(OUTPUT$PTR, .STATUS);
                        IF STATUS = 0EH THEN
                            CALL FILEERROR(STATUS, OUTPUT$PTR, TRUE);
                        CALL RENAME(BUFFER$PTR, OUTPUT$PTR, .STATUS);
                        CALL FILEERROR(STATUS, OUTPUT$PTR, TRUE);
                    END;
                    CALL EXIT;
                    GOTO CMDLOOP;
                END;
                DO;             /* 'F' FIND */
                    TEXTPTR = FINDLOC + FINDLEN;
                    GOTO CMDLOOP;
                END;
                GOTO BADCMD; /* 'G' */
                GOTO BADCMD; /* 'H' */
    CASE$I:     DO;             /* 'I' INSERT */
                    DO WHILE (CHAR := GETCMDCH) <> ESC;
                        IF TEXTPTR = W37D0 THEN DO; 
                            CALL MOVEUP;
                            IF W37CA - 11 < W37D2 THEN
                                GOTO BREAK;
                            W37D6 = W37D2;
                            W37D2, W37D0 = W37CA - 10;
                            DO WHILE W37D6 >= TEXTPTR;
                                MEMORY(W37D0) = MEMORY(W37D6);
                                W37D6 = W37D6 - 1;
                                W37D0 = W37D0 - 1;
                            END;
                            W37D0 = W37D0 + 1;
                        END;
                        MEMORY(TEXTPTR) = CHAR;
                        TEXTPTR = TEXTPTR + 1; 
                    END; 
                    CALL MOVEDOWN;
                    GOTO CMDLOOP;
                END;
                GOTO BADCMD;            /* 'J' */
                DO;                     /* 'K' KILL */
                    IF (W37D0 := SEEKLINE) < TEXTPTR THEN DO;
                        W37D6 = TEXTPTR;
                        TEXTPTR = W37D0;
                        W37D0 = W37D6;
                    END;
                    CALL MOVEDOWN;
                    GOTO CMDLOOP;
                END;
                DO;
                    TEXTPTR = SEEKLINE;      /* 'L' TEXT POINTER LINE*/
                    GOTO CMDLOOP;
                END;
                GOTO BADCMD;            /* 'M' */
                GOTO BADCMD;            /* 'N' */
                GOTO BADCMD;            /* 'O' */
                GOTO BADCMD;            /* 'P' */
                DO;                     /* 'Q' QUIT */
                    CALL CLOSE(AFTOUT, .STATUS);
                    CALL DELETE(BUFFER$PTR, .STATUS);
                    CALL EXIT;
                    GOTO CMDLOOP;
                END;
                GOTO BADCMD;            /* 'R' */
                DO;                     /* 'S' SUBSTITUTE */
                    W37D0 = (TEXTPTR := FINDLOC) + FINDLEN;
                    GOTO CASE$I;
                END;
                DO;                     /* 'T' TYPE */
                    IF (W37D6 := SEEKLINE) = TEXTPTR THEN
                        GOTO CMDLOOP;
                    IF TEXTPTR < W37D6 THEN
                        CALL DISPLAYTEXT(.MEMORY + TEXTPTR, W37D6 - TEXTPTR - 1);
                    ELSE
                        CALL DISPLAYTEXT(.MEMORY + W37D6, TEXTPTR - W37D6 - 1);
                    GOTO CMDLOOP;
                END;
                GOTO BADCMD;            /* 'U' */
                GOTO BADCMD;            /* 'V' */
                DO;                     /* 'W' WRITE */
                    BACKWARDS = 0;
                    TEXTPTR = 1;
                    W37D0 = SEEKLINE;
                    CALL WRITE(AFTOUT, .MEMORY + 1, W37D0 - 1, .STATUS);
                    CALL FILEERROR(STATUS, BUFFER$PTR, TRUE);
                    CALL MOVEDOWN;
                    GOTO CMDLOOP;
                END;
                GOTO BADCMD;            /* 'X' */
                GOTO BADCMD;            /* 'Y' */
                DO;                     /* 'Z' TEXT POINTER END*/
                    TEXTPTR = ENDPTR;
                    GOTO CMDLOOP;
                END;
            END;    /* OF CASE */
        END;        /* OF IF */
        ELSE
BADCMD: IF CHAR > ' ' THEN DO;
            CALL DISPLAYTEXT(.BEGINPUNCH, 1);
            CALL CO(DQUOTE);
            CALL DISPLAYCHAR(CHAR);
            CALL DISPLAYTEXT(.ILLEGAL, 26);
            CALL GETTEXT;
        END;
    END; /* OF CMDLOOP */
BREAK:
    CALL DISPLAYTEXT(.USRBREAK, 10);
    CALL GETTEXT;
    GOTO CMDLOOP;
EOF
edit_1.2.patch
; the current compiler does not generate a stack load for
; calls from nested procedures, unlike more recent compilers
; and as used in the original binary
; I have hacked the code to do a GOTO BREAK twice so that the first
; one can be replaced by an lxi sp instruction
; the 4 bytes to patch are noted below
2670 31 C4
2CAC 31 C4
format.plm
1C00H:
DO;
    DECLARE NSECTORS LITERALLY '26';
    DECLARE NTRACKS LITERALLY '77';
    DECLARE IOCW    LITERALLY '0',
            IOINS   LITERALLY '1',
            NSEC    LITERALLY '2',
            TADR    LITERALLY '3',
            SADR    LITERALLY '4',
            BUFLO   LITERALLY '5',
            BUFHI   LITERALLY '6';

    DECLARE TRUE    LITERALLY '0FFH',
            FALSE   LITERALLY '0',
            CR      LITERALLY '0DH',
            LF      LITERALLY '0AH';

    DECLARE DCMD$READ  LITERALLY '4',
            DCMD$WRITE LITERALLY '6';

    DECLARE INVISIBLE$A LITERALLY '1',
            SYSTEM$A    LITERALLY '2',
            WRITEP$A    LITERALLY '4',
            FORMAT$A    LITERALLY '80H';

    DECLARE VER DATA(1, 14H);
    DECLARE COPYRIGNT DATA('COPYRIGHT (C) INTEL 1975,1976');
/*
	THE CODE BLOCK BELOW IS LOADED INTO ISIS.T0 ON NON SYSTEM DISKS TO PRINT A MESSAGE
	THE CORRESPONDING ASM CODE IS

		ASEG
		org 3000h

		IN	79H
		IN	7BH
	L3004:	IN	0FFH
		ANI	2
		JNZ	L3004
		LXI	H, MSG
		MVI	B, 32
	L3010:	MOV	C, M
		CALL	0F809H	; CO
		INX	H
		DCR	B
		JNZ	L3010
		RST	0
	MSG:	DB	0DH, 0AH
		DB	'NON-SYSTEM DISK, TRY ANOTHER'
		DB	0DH, 0AH
		END
*/
DECLARE CODEBLOCK DATA(0DBH, 79H, 0DBH, 7BH, 0DBH, 0FFH, 0E6H, 2,
			       0C2H, 4, 30H, 21H, 1AH, 30H, 6, 20H, 4EH,
			       0CDH, 9, 0F8H, 23H, 5, 0C2H, 10H, 30H, 0C7H,
			       CR, LF, 'NON-SYSTEM DISK, TRY ANOTHER', CR, LF);
DECLARE ATTRIBMAP DATA(INVISIBLE$A, SYSTEM$A, WRITEP$A);
DECLARE CRLF DATA(CR, LF);
DECLARE	ISIST0 DATA(':F1:ISIS.T0 '),
        ISISBIN DATA(':F1:ISIS.BIN '),
        ISISMAP DATA(':F1:ISIS.MAP '),
        ISISLAB DATA(':F1:ISIS.LAB '),
        ISISDIR DATA(':F1:ISIS.DIR ');

/* GLOBAL VARIABLES */
DECLARE BITMAP(256) BYTE,
        MAPCHANGE BYTE INITIAL(0),      /* NOT USED */
        MAPDCB(10) BYTE INITIAL(80H, DCMD$WRITE, 2, 2, 2),    /* NOT USED */
        MAPDRV BYTE INITIAL(0FFH),      /* NOT USED */
        BASTRKSEC ADDRESS,              /* NOT USED */
        BITMAPINDEX ADDRESS,            /* NOT USED */
        BITMASK(8) BYTE INITIAL(80H, 40H, 20H, 10H, 8, 4, 2, 1);
DECLARE DIRECT(10) BYTE,  DIRECTATTR BYTE, DIRECTOTHER(5) BYTE, PAD1(3) BYTE;
DECLARE FMTTABLE(77) BYTE INITIAL(
            1, 12,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,
            3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,
            3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,
            3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,
            3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3);
DECLARE MEMSIZE ADDRESS;
DECLARE ACTUAL ADDRESS, PAD2 ADDRESS;
DECLARE (BUFFERPTR, II, JJ, NAMELEN) ADDRESS, PAD3 BYTE;
DECLARE (SYSTEM, COPYALL, COPY) BYTE;
DECLARE (AFTIN, AFTOUT, AFTDIR, STATUS) ADDRESS, PAD4 BYTE;
DECLARE SRCNAME(16) BYTE, DSTNAME(16) BYTE;



    MEMCK: PROCEDURE ADDRESS;
        GOTO 0F81BH;
    END;

    ISIS: PROCEDURE(CMD, PARAM$P);
        DECLARE CMD BYTE, PARAM$P ADDRESS;
        GOTO 40H;
    END ISIS;

    OPEN: PROCEDURE(CONN$P, PATH$P, ACCESS, ECHO, STATUS$P);
        DECLARE (CONN$P, PATH$P, ACCESS, ECHO, STATUS$P) ADDRESS;

        CALL ISIS(0, .CONN$P);
    END;

    READ: PROCEDURE(CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P) ADDRESS;

        CALL ISIS(3, .CONN);
    END;

    WRITE: PROCEDURE(CONN, BUFF$P, COUNT, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, STATUS$P) ADDRESS;

        CALL ISIS(4, .CONN);
    END;

    CLOSE: PROCEDURE(CONN, STATUS$P);
        DECLARE (CONN, STATUS$P) ADDRESS;

        CALL ISIS(1, .CONN);
    END;

    ERROR: PROCEDURE(ERROR$NUM);
        DECLARE (ERROR$NUM, STATUS) ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(12, .ERROR$NUM);
    END;

    EXIT: PROCEDURE;
        DECLARE STATUS ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(9, .STATUS);
    END;

    ATTRIB: PROCEDURE (PATH$P, ATTRIB, ON$OFF, STATUS$P);
        DECLARE (PATH$P, ATTRIB, ON$OFF, STATUS$P) ADDRESS;

        CALL ISIS(10, .PATH$P);
    END ATTRIB;

    DELETE: PROCEDURE (PATH$P, STATUS$P);
        DECLARE (PATH$P, STATUS$P) ADDRESS;

        CALL ISIS(2, .PATH$P);
    END DELETE;


    DISKIO: PROCEDURE(DRIVE, IOPB);
        DECLARE (DRIVE, IOPB) ADDRESS;
        DECLARE PARAMS(4) ADDRESS;

        PARAMS(0) = 'SK';
        PARAMS(1) = DRIVE;
        PARAMS(2) = IOPB;
        CALL ISIS(44H, .PARAMS);
    END;

    CLRBUF: PROCEDURE(PTR);
        DECLARE PTR ADDRESS, CH BASED PTR BYTE;
        DECLARE I BYTE;
        I = 128;
        DO WHILE I <> 0;
            I = I - 1;
            CH = 0;
            PTR = PTR + 1;
        END;
    END;

    /* NOT ACTUALLY USED */
    NUMOUT: PROCEDURE(VALUE, BASE, LC, BUFADR, WIDTH);
        DECLARE (VALUE, BUFADR) ADDRESS, (BASE, LC, WIDTH) BYTE; 
        DECLARE DIGITS DATA('0123456789ABCDEF');
        DECLARE I BYTE;
        DECLARE BUF BASED BUFADR (1) BYTE;

        DO I = 1 TO WIDTH;
            BUF(WIDTH - I) = DIGITS(VALUE MOD BASE);
            VALUE = VALUE / BASE;   
        END;

        I = 0;
        DO WHILE BUF(I) = '0' AND I < WIDTH - 1;
            BUF(I) = LC;
            I = I + 1;
        END;
    END;

    REPORTERROR: PROCEDURE(ERRNUM);
        DECLARE ERRNUM ADDRESS;
        DECLARE NUMBERBUFFER(4) BYTE, I ADDRESS, STATUS ADDRESS;
     

        DECLARE ERRMSG DATA(0, 0,
            2, 'ILLEGAL AFTN ARGUMENT', 0,
            4, 'INCORRECTLY SPECIFIED FILE', 0,
            5, 'UNRECOGNIZED DEVICE NAME', 0,
            6, 'ATTEMPT TO WRITE TO INPUT DEVICE', 0,
            8, 'ATTEMPT TO READ FROM OUTPUT DEVICE', 0,
            9, 'DIRECTORY FULL', 0,
            0AH, 'NOT ON SAME DISK', 0,
            0BH, 'FILE ALREADY EXISTS', 0,
            0CH, 'FILE IS ALREADY OPEN', 0,
            0DH, 'NO SUCH FILE', 0,
            0EH, 'WRITE PROTECTED', 0,
            0FH, 'LOAD TOO LOW', 0,
            10H, 'BAD LOAD FORMAT', 0,
            11H, 'NOT A DISK FILE', 0,
            12H, 'ILLEGAL ISIS COMMAND', 0,
            13H, 'ATTEMPTED SEEK ON NON-DISK FILE', 0,
            14H, 'ATTEMPTED BACK SEEK TO FAR', 0,
            16H, 'ILLEGAL ACCESS MODE TO OPEN', 0,
            17H, 'MISSING FILENAME', 0,
            19H, 'ILLEGAL ECHO FILE', 0,
            1AH, 'ILLEGAL ATTRIBUTE IDENTIFIER', 0,
            1BH, 'ILLEGAL SEEK COMMAND', 0,
            1CH, 'MISSING EXTENSION', 0,
            1FH, 'CAN', 27H, 'T SEEK ON WRITE ONLY FILE', 0,
            20H, 'CAN', 27H, 'T DELETE OPEN FILE', 0,
            23H, 'SEEK PAST EOF', 0,
            0C9H, 'UNRECOGNIZED SWITCH', 0,
            0CAH, 'UNRECOGNIZED DELIMITER', 0,
            0CBH, 'INVALID SYNTAX', 0,
            0CCH, 'PREMATURE EOF', 0,
            0CEH, 'ILLEGAL DISKETTE LABEL', 0,
            0D0H, 'CHECKSUM ERROR', 0
        );



        IF ERRNUM <> 0 THEN
        DO;
            I = 0;
            DO WHILE I < LENGTH(ERRMSG);
                IF ERRNUM = ERRMSG(I) AND ERRMSG(I + 1) <> 0 THEN
                DO;
                    I = I + 1;
                    CALL WRITE(0, .(' '), 1, .STATUS);
                    DO WHILE ERRMSG(I) <> 0;
                        CALL WRITE(0, .ERRMSG(I), 1, .STATUS);
                        I = I + 1;
                    END;
                    CALL WRITE(0, .(0DH, 0AH), 2, .STATUS);
                    return;
                END;
                ELSE
                DO;
                    DO WHILE ERRMSG(I) <> 0;
                        I = I + 1;
                    END;
                    I = I + 1;
                END;
            end;
            CALL ERROR(ERRNUM);
        END;
    END;



    CHECKERROR: PROCEDURE(ERRCODE);
        DECLARE ERRCODE BYTE;
        IF ERRCODE = 0 THEN
            RETURN;
        CALL REPORTERROR(ERRCODE);
        CALL EXIT;
    END;


    SETBITMAP: PROCEDURE(TRKSEC);
        DECLARE TRKSEC ADDRESS;
        DECLARE MAPBYTE BYTE;

        TRKSEC = HIGH(TRKSEC) * 26 + LOW(TRKSEC) - 1;
        MAPBYTE = SHR(TRKSEC, 3);
        BITMAP(MAPBYTE) = BITMAP(MAPBYTE) OR BITMASK(LOW(TRKSEC) AND 7);
    END;

    /*
     ASBIO: ACCOMPLISHES THE TRANSFER OF 128 BYTES OF DATA FROM THE DISK 
       COMMAND  MUST BE THE NUMERIC VALUE OF THE FDCC COMMAND
                DESIRED. (LITERALS 'READ$COMMAND' AND 'WRITE$COMMAND'
                EXIST FOR THE COMMON OPERATIONS.)
       DISK     THE DRIVE FROM WHICH TO READ
       BLOCK    DISKETTE BLOCK NUMBER, A TRACK NUMBER (0-76)
                IN THE HIGH ORDER 8 BITS AND A SECTORE NUMBER (1-26)
                IN THE LOW ORDER 8 BITS
       BUFFER$PTR   THE ADDRESS OF A 128 BYTE BUFFER IN RAM
    */
    ABSIO: PROCEDURE (COMMAND, DISK, BLOCK, BUFFER$PTR);
        DECLARE (COMMAND, DISK) BYTE, (BLOCK, BUFFER$PTR) ADDRESS;
        /* VALUE OF 'DISK'  MUST BE 0 - 1 */
        DECLARE DCB BYTE INITIAL(80H);
        DECLARE DCBINST(9) BYTE;
        DECLARE IOPTR ADDRESS;
        DECLARE IOBYTE BASED IOPTR BYTE, IOWORD BASED IOPTR ADDRESS;

        IOPTR = .DCBINST;

        IOBYTE = COMMAND;
        IOPTR = IOPTR + 1;
        IOBYTE = 1;     /* IF THIS VALUE CHANGES IN THE FUTURE, */
                        /* THE 8271 DRIVER MUST BE CHANGED */
        IOPTR = IOPTR + 1;
        IOBYTE = HIGH(BLOCK);
        IOPTR = IOPTR + 1;
        IOBYTE = LOW(BLOCK);
        IOPTR = IOPTR + 1;
        IOWORD = BUFFER$PTR;
        CALL DISKIO(DISK, .DCB);
    END;


    FORMATTRACK: PROCEDURE(DISK, FIRSTTRK, LASTTRK, INTERLEAVE);
        DECLARE (DISK, FIRSTTRK, LASTTRK, INTERLEAVE) BYTE;
        DECLARE (I, J, CURTRACK) BYTE;
        DECLARE TRACKBUF(52) BYTE;
        DECLARE DCB(10) BYTE INITIAL(0C0H, 2, 0, 0, 0, 0, 0, 0, 0, 0);
        

        DO I = 1 to 51 BY 2;
            TRACKBUF(I) = 0C7H;
        END; 
        J = 0;

        DO CURTRACK = FIRSTTRK TO LASTTRK;
            DO I = 0 TO 51 BY 2;
                TRACKBUF(I) = 0;
            END;
            DO I = 1 TO NSECTORS;
                J = (J + INTERLEAVE) MOD NSECTORS;
                DO WHILE TRACKBUF(J + J) <> 0;
                    J = (J + 1) MOD NSECTORS;
                END;
                TRACKBUF(J + J) = I;
            END;
            
            DCB(TADR) = CURTRACK;
            DCB(BUFHI) = HIGH(.TRACKBUF);
            DCB(BUFLO) = LOW(.TRACKBUF);
            CALL DISKIO(DISK, .DCB);
        END;
    END;



    DEBLANK: PROCEDURE(PTR) ADDRESS;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE C = ' ';
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;

    DELIMIT: PROCEDURE(PTR) ADDRESS;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE (C = ':' OR C = '.' 
              OR ('0' <= C AND C <= '9')
              OR ('A' <= C AND C <= 'Z'));
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;

	MOVE: PROCEDURE(DST$P, SRC$P, CNT);
		DECLARE (DST$P, SRC$P) ADDRESS;
        DECLARE DST BASED DST$P (1) BYTE;
        DECLARE SRC BASED SRC$P (1) BYTE;
        DECLARE (CNT, I) BYTE;

		DO I = 0 TO CNT - 1;
            DST(I) = SRC(I);
		END;
	end;

    WRITEDIRECTORY: PROCEDURE(DRIVE);
        DECLARE DRIVE BYTE;
        DECLARE DISISDIR DATA('ISIS',0,0,'DIR');
        DECLARE DISISMAP DATA('ISIS',0,0,'MAP');
        DECLARE DISIST0  DATA('ISIS',0,0,'T0', 0);
        DECLARE DISISBIN DATA('ISIS',0,0,'BIN');
        DECLARE DISISLAB DATA('ISIS',0,0,'LAB');

        DECLARE I BYTE, JJ ADDRESS;
        DECLARE DIRBUFW(0) ADDRESS, DIRBUF(0) BYTE,
                DIR0W(0)   ADDRESS, DIR0(16) BYTE,
                DIR1W(0)   ADDRESS, DIR1(16) BYTE,
                DIR2W(0)   ADDRESS, DIR2(16) BYTE,
                DIR3W(0)   ADDRESS, DIR3(16) BYTE,
                DIR4W(0)   ADDRESS, DIR4(16) BYTE,
                DIR5W(0)   ADDRESS, DIR5(16) BYTE,
                DIR6W(0)   ADDRESS, DIR6(16) BYTE,
                DIR7W(0)   ADDRESS, DIR7(16) BYTE;

        DO I = 0 TO 255;
            BITMAP(I) = 0;
        END;
        CALL CLRBUF(.DIRBUF);
        DIRBUFW(2) = 1;
        DO I = 2 TO 23;
            DIRBUFW(I + 1) = DIRBUFW(I) + 1;
        END;
        CALL ABSIO(DCMD$WRITE, DRIVE, 18H, .DIRBUF);
        CALL CLRBUF(.DIRBUF);

        DIRBUFW(2) = 1AH;
        DO I = 2 TO 1;
            DIRBUFW(I + 1) = DIRBUFW(I) + 1;
        END;
        CALL ABSIO(DCMD$WRITE, DRIVE, 19H, .DIRBUF);
        CALL CLRBUF(.DIRBUF);

        DIRBUFW(2) = 102H;
        DO I = 2 TO 25;
            DIRBUFW(I + 1) = DIRBUFW(I) + 1;
        END;
        CALL ABSIO(DCMD$WRITE, DRIVE, 101H, .DIRBUF);
        CALL CLRBUF(.DIRBUF);

        DIRBUFW(2) = 202H;
        DO I = 2 TO 2;
            DIRBUFW(I + 1) = DIRBUFW(I) + 1;
        END;
        CALL ABSIO(DCMD$WRITE, DRIVE, 201H, .DIRBUF);
        CALL CLRBUF(.DIRBUF);

        CALL ABSIO(DCMD$WRITE, DRIVE, 204H, .DIRBUF);

        CALL CLRBUF(.DIRBUF);

        CALL MOVE(.DIR0(1), .DISISDIR, 9);
        DIR0W(6) = 19H;
        DIR0W(7) = 101H;
        DIR0(0) = 0;
        DIR0(10) = 1;
        DIR0(11) = 80H;

        CALL MOVE(.DIR1(1), .DISISMAP, 9);
        DIR1W(6) = 2H;
        DIR1W(7) = 201H;
        DIR1(0) = 0;
        DIR1(10) = 1;
        DIR1(11) = 80H;

        CALL MOVE(.DIR2(1), .DISIST0, 9);
        DIR2W(6) = 17H;
        DIR2W(7) = 18H;
        DIR2(0) = 0;
        DIR2(10) = 1;
        DIR2(11) = 80H;

        CALL MOVE(.DIR3(1), .DISISLAB, 9);
        DIR3W(6) = 1H;
        DIR3W(7) = 19H;
        DIR3(0) = 0;
        DIR3(10) = 1;
        DIR3(11) = 80H;

        CALL MOVE(.DIR4(1), .DISISBIN, 9);
        DIR4W(6) = 0;
        DIR4W(7) = 204H;
        DIR4(0) = 0;
        DIR4(10) = 1 OR 2;
        DIR4(11) = 80H;

        DO I = 5 TO 7;
            DIRBUF(I * 16) = 7FH;
        END;

        CALL ABSIO(DCMD$WRITE, DRIVE, 102H, .DIRBUF);
        CALL CLRBUF(.DIRBUF);

        DO I = 0 TO 7;
            DIRBUF(I * 16) = 7FH;
        END;

        DO I = 2 TO 25;
            CALL ABSIO(DCMD$WRITE, DRIVE, 102H - 1 + I, .DIRBUF);
        END;

        CALL SETBITMAP(101H);
        DO JJ = 102H TO 25 + 102H - 1;
            CALL SETBITMAP(JJ);
        END;

        CALL SETBITMAP(201H);
        DO JJ = 202H TO 2 + 202H - 1;
            CALL SETBITMAP(JJ);
        END;

        CALL SETBITMAP(18H);
        DO JJ = 1 TO 1 + 17H - 1;
            CALL SETBITMAP(JJ);
        END; 

        CALL SETBITMAP(19H);
        DO JJ = 1AH TO 1AH + 1 - 1;
            CALL SETBITMAP(JJ);
        END; 

        CALL SETBITMAP(204H);

        CALL ABSIO(DCMD$WRITE, DRIVE, 202H, .BITMAP);
        CALL ABSIO(DCMD$WRITE, DRIVE, 202H + 1, .BITMAP(128));


    END;


    DECLARE DEVICES(21) ADDRESS INITIAL(
        'F0', 'F1', 'TI', 'TO', 'VI', 'VO', 'I1', 'O1',
        'TR', 'HR', 'R1', 'R2', 'TP', 'HP', 'P1', 'P2',
        'LP', 'L1', 'CI', 'CO', 'BB');
    DECLARE PN(20) BYTE;

    CANON: PROCEDURE(FILENAME, INFO$P) BYTE;
        DECLARE (FILENAME, INFO$P) ADDRESS;
        DECLARE PATHCH BASED FILENAME BYTE;
        DECLARE PATH BASED FILENAME (1) BYTE;
        DECLARE INFO BASED INFO$P (1) BYTE;
        DECLARE PAIR(0) ADDRESS, (B1, B2) BYTE;
        DECLARE (JUNK, I) BYTE;

        ALPHANUM: PROCEDURE BYTE;
            RETURN (PATHCH >= 'A' AND PATHCH <= 'Z')
                OR (PATHCH >= '0' AND PATHCH <= '9');
        END;

        GETFNCHAR: PROCEDURE;
            IF ALPHANUM THEN DO;
                INFO(I) = PATHCH;
                FILENAME = FILENAME + 1;
                B1 = FALSE;
            END;
        END;

        DO I = 0 TO 9;
            INFO(I) = 0;
        END;

        DO WHILE PATHCH  = ' ';
            FILENAME = FILENAME + 1;
        END;
        IF PATHCH = ':' THEN DO;
            INFO(0) = 0FFH;
            /* DEVICE COMPARISON IS DONE BACKWARDS */
            /* AS PL/M SWAPS WORD STRINGS */
            B2 = PATH(1);
            B1 = PATH(2);
            IF PATH(3) <> ':' THEN
                RETURN 4; 
            DO I = 0 TO LAST(DEVICES);
                IF DEVICES(I) = PAIR(0) THEN
                    INFO(0) = I;
            END;
            IF INFO(0) = 0FFH THEN
                RETURN 5;
            FILENAME = FILENAME + 4;
        END;
        B1 = TRUE;
        DO I = 1 TO 6;
            CALL GETFNCHAR;
        END;
        B2 = B1;
        B1 = PATHCH = '.';
        IF B1 THEN DO;
            FILENAME = FILENAME + 1;
            DO I = 7 TO 9;
                CALL GETFNCHAR;
            END;
        END;
        IF INFO(0) <= 1 THEN
            IF B2 THEN
                RETURN 17H;
            ELSE IF B1 THEN
                RETURN 1CH;
        IF ALPHANUM OR PATHCH = '.' OR PATHCH = ':' THEN
            RETURN 4;
        RETURN 0;
    END;


    UNPATH: PROCEDURE(DIR$P, FILENAME$P);
        DECLARE (DIR$P, FILENAME$p) ADDRESS;
        DECLARE FILENAME BASED FILENAME$P (1) BYTE;
        DECLARE DIR BASED DIR$P (1) BYTE;
        DECLARE I BYTE;

        FILENAME(0) = ':';
        FILENAME(1) = 'F';
        FILENAME(3) = ':';
        IF DIR(0) = 0 THEN
            FILENAME(2) = '0';
        ELSE
            FILENAME(2) = '1';
        FILENAME$P = FILENAME$P + 4;
        DO I = 0 TO 5;
            if (FILENAME(0) := DIR(I + 1)) <> 0 THEN
                FILENAME$P = FILENAME$P + 1;
        END;
        IF DIR(7) <> 0 THEN DO;
            FILENAME(0) = '.';
            FILENAME$P = FILENAME$P + 1;
        END; 
        DO I = 0 TO 2;
            if (FILENAME(0) := DIR(I + 7)) <> 0 THEN
                FILENAME$P = FILENAME$P + 1;
        END;
        FILENAME(0) = ' ';
    END; 

    DECLARE CHAR BASED BUFFER$PTR BYTE;
 
MAIN:
    COPYALL = FALSE;
    SYSTEM = FALSE;
	CALL READ(1, .MEMORY, 128, .ACTUAL, .STATUS);
    CALL CHECKERROR(STATUS);
	BUFFER$PTR = DEBLANK(.MEMORY);
    IF CHAR = ':' THEN
        CALL CHECKERROR(0CEH);   /* ILLEGAL DISKETTE LABEL */

    STATUS = CANON(BUFFERPTR, .PN);
    CALL CHECKERROR(STATUS);

	BUFFERPTR = DEBLANK(DELIMIT(DEBLANK(.MEMORY)));
    
    DO WHILE CHAR = '$';
        BUFFERPTR = BUFFERPTR + 1;
        IF CHAR = 'S' THEN DO;
            BUFFERPTR = DELIMIT(BUFFERPTR);
            SYSTEM = TRUE;
        END;
        ELSE IF CHAR = 'A' THEN DO;
            BUFFERPTR = DELIMIT(BUFFERPTR);
            COPYALL = TRUE;
        END;
        ELSE DO;
            CALL CHECKERROR(0C9H);
            CALL EXIT;
        END;
        BUFFERPTR = DEBLANK(BUFFERPTR);
    END;
    IF CHAR <> CR THEN DO;
        CALL CHECKERROR(0CBH);
        CALL EXIT;
    END;

    DO II = 0 TO 76;
        CALL FORMATTRACK(1, II, II, FMTTABLE(II)); 
    END;

    CALL WRITEDIRECTORY(1);
    /* BUILD ISIS.LAB */
    CALL CLRBUF(.MEMORY);
    JJ = 0;
    DO II = 1 TO 9;
        MEMORY(JJ) = PN(II);
        JJ = JJ + 1;
    END;
    MEMORY(JJ) = CR;
    JJ = JJ + 1;
    MEMORY(JJ) = LF;
    JJ = JJ + 1;
    DO II = 0 to 76;
        MEMORY(JJ) = FMTTABLE(II) + '0';
        JJ = JJ + 1;
    END;
    CALL ABSIO(DCMD$WRITE, 1, 1AH, .MEMORY);

	IF SYSTEM OR COPYALL THEN DO;
		IF COPYALL THEN
			CALL WRITE(0, .('COPYING ALL FILES', CR, LF), 19, .STATUS);
        ELSE
			CALL WRITE(0, .('COPYING SYSTEM FILES', CR, LF), 22, .STATUS);

		MEMSIZE = (MEMCK - .MEMORY) AND 0FF80H;
        DO JJ = 1 TO 1 + 23 - 1;
            CALL ABSIO(DCMD$READ, 0, JJ, .MEMORY);
            CALL ABSIO(DCMD$WRITE, 1, JJ, .MEMORY);
        END;

        CALL OPEN(.AFTDIR, .('ISIS.DIR'), 1, 0, .STATUS);
        CALL CHECKERROR(STATUS);

        DIRECT(0) = 0;
        DO WHILE DIRECT(0) <> 7FH;
            CALL READ(AFTDIR, .DIRECT, 16, .ACTUAL, .STATUS);
            CALL CHECKERROR(STATUS);
            IF ACTUAL < 16 THEN
                DIRECT(0) = 7FH;
            ELSE IF NOT DIRECT(0) THEN DO;
                if (COPY := ((DIRECTATTR AND SYSTEM$A) <> 0 OR  COPYALL)
                       AND  (DIRECTATTR AND FORMAT$A) = 0) THEN DO;
                    DIRECT(0) = 0;
                    CALL UNPATH(.DIRECT, .SRCNAME);
                    DIRECT(0) = 1;
                    CALL UNPATH(.DIRECT, .DSTNAME);
                    CALL OPEN(.AFTOUT, .DSTNAME, 2, 0, .STATUS);
                    CALL CHECKERROR(STATUS);
                    CALL OPEN(.AFTIN, .SRCNAME, 1, 0, .STATUS);
                    CALL CHECKERROR(STATUS);
                    ACTUAL = 1;
                    DO WHILE ACTUAL <> 0;
                        CALL READ(AFTIN, .MEMORY, MEMSIZE, .ACTUAL, .STATUS);
                        CALL CHECKERROR(STATUS);
                        CALL WRITE(AFTOUT, .MEMORY, ACTUAL, .STATUS);
                        CALL CHECKERROR(STATUS);
                        IF ACTUAL < MEMSIZE THEN
                            ACTUAL = 0;
                    END;
                    CALL CLOSE(AFTOUT, .STATUS);
                    CALL CHECKERROR(STATUS);
                    CALL CLOSE(AFTIN, .STATUS);
                    CALL CHECKERROR(STATUS);

                    DO II = 0 TO 2;
                        IF (ATTRIBMAP(II) AND DIRECTATTR) <> 0 THEN DO;
                            CALL ATTRIB(.DSTNAME, II, 0FFH, .STATUS);
                            CALL CHECKERROR(STATUS);
                        END;
                    END;
                    NAMELEN = DELIMIT(.SRCNAME + 4) - .SRCNAME - 4;
                    CALL WRITE(0, .SRCNAME + 4, NAMELEN, .STATUS);
                    CALL WRITE(0, .CRLF, 2, .STATUS);
                END;
            END;
        END;        
        CALL CLOSE(AFTDIR, .STATUS);
        CALL CHECKERROR(STATUS);
        CALL ATTRIB(.ISIST0, 3, 0FFH, .STATUS);
        CALL CHECKERROR(STATUS);
        CALL ATTRIB(.ISISBIN, 2, 0FFH, .STATUS);
        CALL CHECKERROR(STATUS);
    END;
    ELSE DO;
        CALL WRITE(0, .('NON-SYSTEM DISKETTE', CR, LF), 21, .STATUS);
        CALL ABSIO(DCMD$WRITE, 1, 1, .CODEBLOCK);
        CALL ATTRIB(.ISIST0, 3, 0FFH, .STATUS);
        CALL CHECKERROR(STATUS);
        CALL DELETE(.ISISBIN, .STATUS);
        CALL CHECKERROR(STATUS);
    END;

    CALL ATTRIB(.ISISDIR, 3, 0FFH, .STATUS);
    CALL CHECKERROR(STATUS);
    CALL ATTRIB(.ISISLAB, 3, 0FFH, .STATUS);
    CALL CHECKERROR(STATUS);
    CALL ATTRIB(.ISISMAP, 3, 0FFH, .STATUS);
    CALL CHECKERROR(STATUS);
    CALL EXIT;
END;
EOF

hexbin.plm
1C00H:
DO;
    DECLARE TRUE    LITERALLY '0FFH',
            FALSE   LITERALLY '0',
            CR      LITERALLY '0DH',
            LF      LITERALLY '0AH';

    DECLARE READMODE    LITERALLY '1',
            WRITEMODE   LITERALLY '2',
            UPDATEMODE  LITERALLY '3';

    /* ERROR CODES */
    DECLARE FILE$EXISTS LITERALLY '0BH',
            NO$SUCH$FILE LITERALLY '0DH',
            BAD$SWITCH  LITERALLY '0C9H',
            BAD$SYNTAX  LITERALLY '0CBH',
            EARLY$EOF   LITERALLY '0CCH';

    DECLARE VER DATA(1, 16H);
    DECLARE COPYRIGNT DATA('COPYRIGHT (C) INTEL 1975,1976');

    MEMCHK: PROCEDURE ADDRESS;
        GOTO 0F81BH;
    END;

    ISIS: PROCEDURE(CMD, PARAM$P);
        DECLARE CMD BYTE, PARAM$P ADDRESS;
        GOTO 40H;
    END ISIS;

    READ: PROCEDURE(CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P) ADDRESS;

        CALL ISIS(3, .CONN);
    END;

    WRITE: PROCEDURE(CONN, BUFF$P, COUNT, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, STATUS$P) ADDRESS;

        CALL ISIS(4, .CONN);
    END;

    ERROR: PROCEDURE(ERROR$NUM);
        DECLARE (ERROR$NUM, STATUS) ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(12, .ERROR$NUM);
    END;

    EXIT: PROCEDURE;
        DECLARE STATUS ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(9, .STATUS);
    END;

    OPEN: PROCEDURE(CONN$P, PATH$P, ACCESS, ECHO, STATUS$P);
        DECLARE (CONN$P, PATH$P, ACCESS, ECHO, STATUS$P) ADDRESS;

        CALL ISIS(0, .CONN$P);
    END;

    CLOSE: PROCEDURE(CONN, STATUS$P);
        DECLARE (CONN, STATUS$P) ADDRESS;

        CALL ISIS(1, .CONN);
    END;

    DEBLANK: PROCEDURE(PTR) ADDRESS;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE (C = ' ');
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;

    DELIMIT: PROCEDURE(PTR) ADDRESS;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE (C = ':' OR C = '.' OR
                 ('0' <= C AND C <= '9') OR
                 ('A' <= C AND C <= 'Z'));
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;

    SEQ: PROCEDURE(S1, S2, CNT) BYTE;
        DECLARE (S1,S2) ADDRESS, CNT BYTE;
        DECLARE S1A BASED S1(1) BYTE;
        DECLARE S2A BASED S2(1) BYTE;
        DECLARE I BYTE;
        CNT = CNT - 1;
        DO I = 0 TO CNT;
            IF S1A(I) <> S2A(I) THEN
                RETURN 0;
        END;
        RETURN 0FFH;
    END;


    SCANINTEGER: PROCEDURE(PTRPTR) ADDRESS;
        DECLARE PTRPTR ADDRESS;
        DECLARE PTR BASED PTRPTR ADDRESS;
        DECLARE (SCANPTR, BINVAL, OCTVAL, DECVAL, HEXVAL) ADDRESS;
        DECLARE C BASED SCANPTR BYTE;
        DECLARE (I, CONTINUE) BYTE;
        DECLARE DIGITS(16) BYTE INITIAL('0123456789ABCDEF');

        BINVAL, OCTVAL, DECVAL, HEXVAL = 0;
        SCANPTR = PTR;

        DO WHILE C = ' ';
            SCANPTR = SCANPTR + 1;
        END;

        CONTINUE = TRUE;
        DO WHILE CONTINUE;
            CONTINUE = FALSE;
            DO I = 0 TO 15;
                IF C = DIGITS(I) THEN DO;
                    IF I < 2 THEN
                        BINVAL = BINVAL + BINVAL + I;
                    OCTVAL = SHL(OCTVAL, 3) + I;
                    IF I < 10 THEN
                        DECVAL = DECVAL * 10 + I;
                    HEXVAL = SHL(HEXVAL, 4) + I;
                    SCANPTR = SCANPTR + 1;
                    CONTINUE = TRUE;
                END; 
            END;
        END;
        PTR = SCANPTR + 1;
        IF C = 'H' THEN
            RETURN HEXVAL;
        IF C = 'O' OR C = 'Q' THEN
            RETURN OCTVAL;
        PTR = SCANPTR;
        SCANPTR = SCANPTR - 1;
        IF C = 'B' THEN
            RETURN BINVAL;
        RETURN DECVAL;

    END;



    NUMOUT: PROCEDURE(VALUE, BASE, LC, BUFADR, WIDTH);
        DECLARE (VALUE, BUFADR) ADDRESS, (BASE, LC, WIDTH) BYTE; 
        DECLARE DIGITS DATA('0123456789ABCDEF');
        DECLARE I BYTE;
        DECLARE BUF BASED BUFADR (1) BYTE;

        DO I = 1 TO WIDTH;
            BUF(WIDTH - I) = DIGITS(VALUE MOD BASE);
            VALUE = VALUE / BASE;   
        END;

        I = 0;
        DO WHILE BUF(I) = '0' AND I < WIDTH - 1;
            BUF(I) = LC;
            I = I + 1;
        END;
    END;

    REPORTERROR: PROCEDURE(ERRNUM);
        DECLARE ERRNUM ADDRESS;
        DECLARE NUMBERBUFFER(4) BYTE, I ADDRESS, STATUS ADDRESS;
     

        DECLARE ERRMSG DATA(0, 0,
            2, 'ILLEGAL AFTN ARGUMENT', 0,
            4, 'INCORRECTLY SPECIFIED FILE', 0,
            5, 'UNRECOGNIZED DEVICE NAME', 0,
            6, 'ATTEMPT TO WRITE TO INPUT DEVICE', 0,
            8, 'ATTEMPT TO READ FROM OUTPUT DEVICE', 0,
            9, 'DIRECTORY FULL', 0,
            0AH, 'NOT ON SAME DISK', 0,
            0BH, 'FILE ALREADY EXISTS', 0,
            0CH, 'FILE IS ALREADY OPEN', 0,
            0DH, 'NO SUCH FILE', 0,
            0EH, 'WRITE PROTECTED', 0,
            0FH, 'LOAD TOO LOW', 0,
            10H, 'BAD LOAD FORMAT', 0,
            11H, 'NOT A DISK FILE', 0,
            12H, 'ILLEGAL ISIS COMMAND', 0,
            13H, 'ATTEMPTED SEEK ON NON-DISK FILE', 0,
            14H, 'ATTEMPTED BACK SEEK TO FAR', 0,
            16H, 'ILLEGAL ACCESS MODE TO OPEN', 0,
            17H, 'MISSING FILENAME', 0,
            19H, 'ILLEGAL ECHO FILE', 0,
            1AH, 'ILLEGAL ATTRIBUTE IDENTIFIER', 0,
            1BH, 'ILLEGAL SEEK COMMAND', 0,
            1CH, 'MISSING EXTENSION', 0,
            1FH, 'CAN', 27H, 'T SEEK ON WRITE ONLY FILE', 0,
            20H, 'CAN', 27H, 'T DELETE OPEN FILE', 0,
            23H, 'SEEK PAST EOF', 0,
            0C9H, 'UNRECOGNIZED SWITCH', 0,
            0CAH, 'UNRECOGNIZED DELIMITER', 0,
            0CBH, 'INVALID SYNTAX', 0,
            0CCH, 'PREMATURE EOF', 0,
            0CEH, 'ILLEGAL DISKETTE LABEL', 0,
            0D0H, 'CHECKSUM ERROR', 0
        );

        IF ERRNUM <> 0 THEN
        DO;
            I = 0;
            DO WHILE I < LENGTH(ERRMSG);
                IF ERRNUM = ERRMSG(I) AND ERRMSG(I + 1) <> 0 THEN
                DO;
                    I = I + 1;
                    CALL WRITE(0, .(' '), 1, .STATUS);
                    DO WHILE ERRMSG(I) <> 0;
                        CALL WRITE(0, .ERRMSG(I), 1, .STATUS);
                        I = I + 1;
                    END;
                    CALL WRITE(0, .(0DH, 0AH), 2, .STATUS);
                    return;
                END;
                ELSE
                DO;
                    DO WHILE ERRMSG(I) <> 0;
                        I = I + 1;
                    END;
                    I = I + 1;
                END;
            end;
            CALL ERROR(ERRNUM);
        END;
    END;

    FILE$ERROR: PROCEDURE(STATUS, PTR, CALLEXIT);
        DECLARE (STATUS, PTR) ADDRESS, CALLEXIT BYTE;
        DECLARE ERR$STATUS ADDRESS;

        IF STATUS <> 0 THEN
        DO;
            PTR = DEBLANK(PTR);
            CALL WRITE(0, .(' '), 1, .ERR$STATUS);
            CALL WRITE(0, PTR, DELIMIT(PTR) - PTR, .ERR$STATUS);
            CALL WRITE(0, .(','), 1, .ERR$STATUS);
            CALL REPORTERROR(STATUS);
            IF CALLEXIT THEN
                CALL EXIT;
        END;
    END;


    DECLARE BUFFER$SIZE ADDRESS;
    DECLARE IBUF(128) BYTE, IPTR ADDRESS;
    DECLARE BUFFER(128) BYTE;
    DECLARE (BUFFER$PTR, OUTPUT$PTR, INPUT$PTR) ADDRESS;
    DECLARE (ACTUAL, STATUS) ADDRESS;
    DECLARE (START, ENDFILE) BYTE;
    DECLARE (AFT$OUT, AFT$IN) ADDRESS;
    DECLARE (START$VALUE, RECORD$PTR, CONTENT$PTR, LEN$PTR) ADDRESS;
    DECLARE (ADDR$PTR, RECORD$ADDR) ADDRESS;
    DECLARE (RLEN, TMP, I, CHECKSUM) BYTE;
    DECLARE LEN BASED LEN$PTR ADDRESS;
    DECLARE ADDR BASED ADDR$PTR ADDRESS;
    DECLARE CONTENT BASED CONTENT$PTR BYTE;
    DECLARE CHAR BASED BUFFER$PTR BYTE;


    GNC: PROCEDURE BYTE;

        IF IPTR = LENGTH(IBUF) THEN
        DO;
            CALL READ(AFT$IN, .IBUF, LENGTH(IBUF), .ACTUAL, .STATUS);
            CALL FILEERROR(STATUS, INPUT$PTR, TRUE);
            IF ACTUAL = 0 THEN
            DO;
                CALL FILEERROR(EARLY$EOF, INPUT$PTR, TRUE);
                CALL EXIT;
            END;
            IPTR = 0;
        END;
        IPTR = IPTR + 1;
        RETURN IBUF(IPTR - 1) AND 7FH;
    END GNC;

    HEX: PROCEDURE BYTE;
        DECLARE CHAR BYTE;

        IF (CHAR := GNC) >= '0' AND CHAR <= '9' THEN RETURN CHAR - '0';
        IF CHAR >= 'A' AND CHAR <= 'F' THEN RETURN CHAR - 37H;
        RETURN 0FFH;
    END HEX;

    BYTES: PROCEDURE BYTE;
        DECLARE CHAR BYTE;

        CHAR = SHL(HEX, 4) + HEX;
        CHECKSUM = CHECKSUM + CHAR;
        RETURN CHAR;
    END BYTES;


MAIN:
    START, ENDFILE = FALSE;
    INPUT$PTR = .(':CI: ');
    CALL READ(1, .BUFFER, LENGTH(BUFFER), .ACTUAL, .STATUS);
    CALL FILEERROR(STATUS, INPUT$PTR, TRUE);
    INPUT$PTR,BUFFER$PTR  = DEBLANK(.BUFFER);
    CALL OPEN(.AFT$IN, INPUT$PTR, READ$MODE, 0, .STATUS);
    CALL FILEERROR(STATUS, INPUT$PTR, TRUE);
    BUFFER$PTR = DEBLANK(DELIMIT(BUFFER$PTR));
    IF SEQ(.('TO '), BUFFER$PTR, 3) THEN
    DO;
        OUTPUT$PTR,BUFFER$PTR = DEBLANK(BUFFER$PTR + 2);
        BUFFER$PTR = DEBLANK(DELIMIT(BUFFER$PTR));
    END;
    ELSE DO;
        CALL REPORTERROR(BAD$SYNTAX);
        CALL EXIT;
    END;

    BUFFER$PTR = DELIMIT(DEBLANK(BUFFER$PTR));
    DO WHILE CHAR = '$';
        BUFFER$PTR = BUFFER$PTR + 1;
        IF CHAR = 'S' THEN DO;
            START = TRUE;
            BUFFER$PTR = DEBLANK(BUFFER$PTR + 1);
            IF CHAR <> '=' THEN DO;
                CALL REPORTERROR(BAD$SYNTAX);
                CALL EXIT;
            END;
            BUFFER$PTR = BUFFER$PTR + 1;
            START$VALUE = SCANINTEGER(.BUFFER$PTR);
        END;
        ELSE DO;
            CALL REPORTERROR(BAD$SWITCH);
            CALL EXIT;
        END;
        BUFFER$PTR = DEBLANK(DELIMIT(BUFFER$PTR));
    END;

    IF CHAR <> CR THEN DO;
        CALL REPORTERROR(BAD$SYNTAX);
        CALL EXIT;
    END;
    CALL OPEN(.AFT$OUT, OUTPUT$PTR, WRITEMODE, 0, .STATUS);
    CALL FILEERROR(STATUS, OUTPUT$PTR, TRUE);
    BUFFER$SIZE = MEMCHK - .MEMORY - 64;
    LEN$PTR = .MEMORY;
    LEN = 0;
    ADDR$PTR = .MEMORY + 2;
    ADDR = 0;
    CONTENT$PTR = .MEMORY + 4;
    RECORD$PTR = 0;
    IPTR = LENGTH(IBUF); 
    RLEN = 1;
    DO WHILE RLEN <> 0;
        DO WHILE GNC <> ':';
        END;
        CHECKSUM = 0;
        IF (RLEN := BYTES) <> 0 THEN DO;
            RECORD$ADDR = BYTES * 256 + BYTES;
            IF RECORD$PTR <> RECORD$ADDR OR LEN > BUFFER$SIZE THEN DO;
                IF LEN <> 0 THEN DO;
                    CALL WRITE(AFT$OUT, .MEMORY, LEN + 4, .STATUS);
                    CALL FILEERROR(STATUS, OUTPUT$PTR, TRUE);
                END;
                LEN = 0;
                RECORD$PTR = RECORD$ADDR;
                CONTENT$PTR = .MEMORY  + 4;
                ADDR = RECORD$ADDR;
            END;
            TMP = BYTES;
            DO I = 1 TO RLEN;
                CONTENT = BYTES;
                CONTENT$PTR = CONTENT$PTR + 1;
                RECORD$PTR = RECORD$PTR + 1;
                LEN = LEN + 1;
            END;
            TMP = BYTES;
            IF CHECKSUM <> 0 THEN DO;
                CALL FILEERROR(0D0H, INPUT$PTR, TRUE);
                CALL EXIT;
            END;
        END;
        ELSE DO;
            IF LEN <> 0 THEN DO;
                CALL WRITE(AFT$OUT, .MEMORY, LEN + 4, .STATUS);
                CALL FILEERROR(STATUS, OUTPUT$PTR, TRUE);
            END;
            LEN = 0;
            ADDR = BYTES * 256 + BYTES;
            IF START THEN
                ADDR = START$VALUE;
            CALL WRITE(AFT$OUT, .MEMORY, 4, .STATUS);
            CALL FILEERROR(STATUS, OUTPUT$PTR, TRUE);
        END;
    END;
    CALL CLOSE(AFT$IN, .STATUS);
    CALL FILEERROR(STATUS, INPUT$PTR, TRUE);
    CALL CLOSE(AFT$OUT, .STATUS);
    CALL FILEERROR(STATUS, OUTPUT$PTR, TRUE);
    CALL EXIT;

END;
EOF
isis.asmx
    name ISIS
    ASEG

; monitor interface
CI  equ 0f803h
RI  equ 0f806h
CO  equ 0f809h
PO  equ 0f80ch
LO  equ 0f80fh
IOCHK  equ 0f815h
IOSET  equ 0f818h


; IOPB offsets
IOCW    equ 0
IOINS   equ 1
NSEC    equ 2
TADR    equ 3
SADR    equ 4
IOBUF   equ 5

; enum E_FDCC
RDMODE  equ 1
WRMODE  equ 2
DCMD$RECAL   equ 3
OPCL    equ 4               ; disk completion status
DCMD$READ    equ 4
DCMD$WRITE   equ 6
FDCC$STATUS$0   equ 78h     ; disk status input port
LOW$ADDRESS$0   equ 79h     ; low(IOPB)
HIGH$ADDRESS$1  equ 7Ah     ; high(IOPB)
RESULT$BYTE$0   equ 7Bh     ; disk result status input port
TRACK0$LOAD$ADDRESS equ 3000h

; enum E_errors
OK  equ 0
NO$FREE$BUFFER  equ 1
BAD$AFT$NO  equ 2
AFT$FULL    equ 3
BAD$PATH    equ 4
BAD$DEVICE  equ 5
CANT$WRITE  equ 6
DISK$FULL   equ 7
DIRECTORY$FULL  equ 9
DIFFERENT$DISK  equ 0Ah
MULTIDEFINED    equ 0Bh
ALREADY$OPEN    equ 0Ch
NO$SUCH$FILE    equ 0Dh
WRITE$PROTECT   equ 0Eh
ISIS$OVERWRITE  equ 0Fh
BAD$LOAD$FORMAT equ 10h
NON$DISK$FILE   equ 11h
BAD$COMMAND equ 12h
CANT$RESCAN equ 15h
BAD$ACCESS  equ 16h
NULL$FILENAME   equ 17h
DISK$IO$ERROR   equ 18h
NULL$EXTENSION  equ 1Ch
DRIVE$NOT$READY equ 1Eh
CANT$DELETE equ 20h

; enum attrib_t, bitfield
INVISIBLE   equ 1
SYSTEM  equ 2
WRITEP  equ 4
FORMAT  equ 80h

; enum dev_t
F0DEV   equ 0
F1DEV   equ 1
TPDEV   equ 0Ch
P2DEV   equ 0Fh
CIDEV   equ 12h
CODEV   equ 13h
BBDEV   equ 14h

        org 8
loc_8:  jmp Reboot
; ---------------------------------------------------------------------------
copyright:  db 'COPYRIGHT (C) INTEL 1976'
            db '9EC', 0Dh, 0Ah, 7Fh         ; junk fill
            db ' :10107A006E260029118'
version:    db 1,1

; =============== S U B R O U T I N E =======================================


Isis:
        lxi     h, iscmd
        mov     m, c
        inx     h
        mov     m, e
        inx     h
        mov     m, d
        mov     a, c
        sui     44h             ;'D'
        jnz     loc_5C
        xchg
        inx     h               ; skip param0
        inx     h
        mov     c, m            ; param1 => drive
        inx     h
        mov     b, m
        inx     h
        mov     e, m            ; param2 => iopb
        inx     h
        mov     d, m
        call    Xeqiopb
        ret
; ---------------------------------------------------------------------------

loc_5C:
        lxi     h, 0
        dad     sp
        shld    usrsp
        lxi     h, rbyte        ; stack area
        sphl
        lxi     b, 0

loc_6A:                         ; copy the parameters over
        mvi     a, 4
        sub     c
        jc      loc_84
        lhld    ispb
        dad     b
        dad     b
        mov     e, m
        inx     h
        mov     d, m
        lxi     h, param0
        dad     b
        dad     b
        mov     m, e
        inx     h
        mov     m, d
        inr     c
        jnz     loc_6A

loc_84:                          ; work out the status return parameter and save it
        lxi     h, iscmd
        mov     c, m
        mvi     b, 0
        lxi     h, pcnts
        dad     b
        mov     c, m
        lxi     h, retStatus$p
        dad     b
        dad     b
        mov     e, m
        inx     h
        mov     d, m
        xchg
        shld    retStatus$p
        lxi     h, coldsf       ; cold start flag
        mov     a, m
        rrc
        jnc     loc_C8
        mvi     m, 0
        lda     6
        ani     1
        mvi     d, 0
        mov     e, a
        lxi     h, aTv          ; "TV"
        dad     d
        mov     a, m
        sta     cldin+1         ; " I: "
        sta     cldout+1        ; " O: "
        lxi     b, cldout       ; ": O: "
        mvi     e, 2
        call    Open
        lxi     b, cldin        ; ": I: "
        mvi     e, 1
        call    Open

loc_C8:                         ; command dispatch
        lda     iscmd
        cpi     0Dh
        jnc     CmdBad
        mov     l, a
        mvi     h, 0
        dad     h
        lxi     b, off_DD
        dad     b
        mov     e, m
        inx     h
        mov     d, m
        xchg
        pchl
; ---------------------------------------------------------------------------
off_DD: dw CmdOpen
        dw CmdClose
        dw CmdDelete
        dw CmdRead
        dw CmdWrite
        dw CmdBad
        dw CmdLoad
        dw CmdRename
        dw CmdBad
        dw CmdExit
        dw CmdAttrib
        dw CmdRescan
        dw CmdError
; ---------------------------------------------------------------------------

CmdOpen:
        lxi     h, param1
        mov     c, m            ; bc = path, e = access
        inx     h
        mov     b, m
        inx     h
        mov     e, m
        call    Open
        lhld    param0          ; save conn
        mov     m, a
        inx     h
        mvi     m, 0
        jmp     finish
; ---------------------------------------------------------------------------

CmdClose:
        call    chkaft
        lda     param0
        cpi     4
        mov     c, a            ; c = conn
        cnc     Close           ; only close conn >= 4
        jmp     finish
; ---------------------------------------------------------------------------

CmdDelete:
        lhld    param0
        mov     c, l
        mov     b, h
        call    Delete
        jmp     finish
; ---------------------------------------------------------------------------

CmdRead:                        ; set actual = 0
        lhld    param3
        mvi     m, 0
        inx     h
        mvi     m, 0
        call    chkaft
        lda     param0          ; conn == 3 (note this is user'c conn == 1)
        sui     3
        jnz     loc_14D
        lhld    param1
        shld    edit_buffer
        lxi     h, param2       ; c = count
        mov     c, m
        lhld    param3          ; de = actual$p
        xchg
        call    Edit
        jmp     finish
; ---------------------------------------------------------------------------

loc_14D:
        lda     param0
        sta     read_conn
        lhld    param1
        shld    read_buffer
        lhld    param2
        mov     c, l            ; bc = count
        mov     b, h
        lhld    param3          ; de = actual$p
        xchg
        call    Read
        jmp     finish
; ---------------------------------------------------------------------------

CmdWrite:
        call    chkaft
        lda     param0
        sta     write_conn
        lhld    param1
        mov     c, l            ; bc = buf
        mov     b, h
        lhld    param2
        xchg                    ; de = count
        call    Write
        jmp     finish
; ---------------------------------------------------------------------------

CmdBad:
        mvi     c, BAD$COMMAND
        call    Err
        jmp     finish
; ---------------------------------------------------------------------------

CmdLoad:
        lhld    param0
        shld    load_path
        lhld    param1
        shld    load_bias
        lxi     h, param2
        mov     c, m            ; c = load Switch
        lhld    param3
        xchg                    ; de = load entry
        call    Load
        jmp     finish
; ---------------------------------------------------------------------------

CmdRename:
        lhld    param0
        mov     c, l            ; bc = oldname
        mov     b, h
        lhld    param1          ; de = newname
        xchg
        call    Rename
        jmp     finish
; ---------------------------------------------------------------------------

CmdExit:
        call    Exit
        jmp     finish
; ---------------------------------------------------------------------------

CmdAttrib:
        lhld    param0
        shld    attrib_name
        lxi     h, param1
        mov     c, m            ; c  = attrib
        lxi     h, param2
        mov     e, m            ; e = on/off
        call    Attrib
        jmp     finish
; ---------------------------------------------------------------------------

CmdRescan:
        lda     param0
        dcr     a
        mvi     c, CANT$RESCAN
        cnz     RetUsr          ; can only rescan the console
        call    Rescan
        jmp     finish
; ---------------------------------------------------------------------------

CmdError:                       ; this is user invoked so temporarily clear the abort flag
        lxi     h, abort
        mvi     m, 0
        push    h
        lxi     h, param0
        mov     c, m            ; c = error number
        call    Err
        pop     h
        mvi     m, 0FFh         ; set the abort flag

finish:
        mvi     c, OK
        call    RetUsr

chkaft:
        lxi     h, param0
        mov     a, m
        cpi     0FFh            ; 255, then ignore
        mvi     c, OK
        cz      RetUsr
        adi     2               ; bias conn by 2
        mov     m, a
        cpi     7
        mvi     c, BAD$AFT$NO
        cp      RetUsr          ; >= 7 then invalid
        cpi     2
        cm      RetUsr          ; also 0 or 1 invalid
        lhld    param0
        lxi     d, closed       ; return whether inuse
        dad     d
        mov     a, m
        rrc
        ret
; End of function Isis

; ---------------------------------------------------------------------------
cldin:  db ': I: '
cldout: db ': O: '
aTv:    db 'TV'
iscmd:  db 41h                  ; junk fill
ispb:           dw 3442h        ;     "
retStatus$p:    dw 3131h        ;     "
param0:         dw 3132h        ;     "
param1:         dw 4335h        ;     "
param2:         dw 3131h        ;     "
param3:         dw 3930h        ;     "
param4:         dw 4133h        ;     "
pcnts:  db 5, 2, 2, 5, 4
        db 5, 5, 3, 3, 1
        db 4, 2, 2, 3
coldsf:         db 0FFh
edit_lptr:      db 0
edit_inMode:    db 0FFh
usrsp:          dw 3A20h        ; junk fill
        db  0C7h, 0C7h, 0C7h, 0C7h
        db  0C7h, 0C7h, 0C7h, 0C7h
        db  0C7h, 0C7h, 0C7h, 0C7h
        db  0C7h, 0C7h, 0C7h, 0C7h
        db  0C7h, 0C7h, 0C7h, 0C7h
        db  0C7h, 0C7h, 0C7h, 0C7h
        db  0C7h, 0C7h, 0C7h, 0C7h
        db  0C7h, 0C7h, 0C7h, 0C7h
        db  0C7h, 0C7h, 0C7h, 0C7h
        db  0C7h, 0C7h, 0C7h, 0C7h
        db  0C7h, 0C7h, 0C7h, 0C7h
        db  0C7h, 0C7h, 0C7h, 0C7h
        db  0C7h, 0C7h, 0C7h, 0C7h
        db  0C7h, 0C7h, 0C7h, 0C7h
        db  0C7h, 0C7h, 0C7h, 0C7h
        db  0C7h, 0C7h, 0C7h, 0C7h
rbyte:  db  36h ; 6                 ; junk fill
rtype:  db  45h ; E
        db  42h ; B
        db  45h ; E
abort:  db 0FFh
debug:  db  44h ; D                 ; junk fill

binhex_val: dw 3133h                ; junk fill
binhex_buf: dw 4431h                ;     "
binhex_len: db  41h                 ;     "

hexdig: db '0123456789ABCDEF'

; =============== S U B R O U T I N E =======================================


Binhex:
        lxi     h, binhex_buf
        mov     m, c
        inx     h
        mov     m, b
        inx     h
        mov     m, e
        mvi     d, 0
        xchg
        dad     b
        shld    binhex_buf          ; update to point to end of buf

loc_2AB:                            ; while chars still to write
        lxi     h, binhex_len
        mov     a, m
        ora     a
        rz
        dcr     m
        lhld    binhex_buf          ; advance to next slot to fill
        dcx     h
        shld    binhex_buf
        lda     binhex_val          ; convert nibble to ascii
        ani     0Fh
        mov     c, a
        mvi     b, 0
        lxi     h, hexdig           ; "0123456789ABCDEF"
        dad     b
        mov     a, m
        lhld    binhex_buf          ; and save in buffer
        mov     m, a
        mvi     c, 4
        lhld    binhex_val          ; binhex_val >>= 4

loc_2CF:
        mov     a, h
        ora     a
        rar
        mov     h, a
        mov     a, l
        rar
        mov     l, a
        dcr     c
        jnz     loc_2CF
        shld    binhex_val
        jmp     loc_2AB
; End of function binhex


; =============== S U B R O U T I N E =======================================


ResetConsoleDev:
        call    IOCHK
        ani     0FCh
        mov     c, a
        lda     6
        ani     3
        ora     c
        mov     c, a
        call    IOSET
        ret
; End of function ResetConsoleDev

; ---------------------------------------------------------------------------
err_ErrorType:  db 39h          ; junk fill
err_MsgLen:     db 26
err_Msg:        db 0Dh, 0Ah
                db 'ERROR '
err_ErrorNum:   db ' :1 USER PC '   ; first  part is junk fill
err_UserSP:     db 'F8C3', 0Dh, 0Ah, 'FDCC='
err_FDCCError:  db '7CD0'        ; junk fill
                db 0Dh, 0Ah

; =============== S U B R O U T I N E =======================================


Err:
        lxi     h, err_ErrorType
        mov     m, c
        mvi     a, 26
        sta     err_MsgLen
        mov     a, c
        lxi     h, err_ErrorNum ; " :1 USER PC "
        mvi     c, 0            ; convert errNum to decimal ascii string

loc_327:                        ; c is count of 100's
        inr     c
        sui     100
        jnc     loc_327
        dcr     c               ; went too far
        adi     100
        push    psw             ; a is errnum % 100
        mov     a, c
        adi     '0'             ; convert to digit
        mov     m, a
        inx     h
        pop     psw
        mvi     c, 0            ; now c is count of 10's

loc_339:
        inr     c
        sui     10
        jp      loc_339
        dcr     c               ; went too far
        adi     10
        push    psw             ; a = errnum % 10
        mov     a, c
        adi     '0'             ; convert to ascii
        mov     m, a
        inx     h
        pop     psw
        adi     '0'             ; convert last digit
        mov     m, a
        lhld    usrsp           ; convert user's sp to ascii form
        mov     e, m
        inx     h
        mov     d, m
        xchg
        shld    binhex_val
        lxi     b, err_UserSP   ; "F8C3\r\nFDCC="
        mvi     e, 4
        call    Binhex
        call    ResetConsoleDev
        lda     err_ErrorType   ; if diskio error issue longer message
        sui     DISK$IO$ERROR
        jnz     loc_37C
        lxi     h, err_MsgLen
        mvi     m, 37
        lhld    rbyte
        shld    binhex_val
        lxi     b, err_FDCCError ; "7CD0\r\n"
        mvi     e, 4
        call    Binhex

loc_37C:
        lxi     h, err_Msg      ; "\r\nERROR "
        lda     err_MsgLen      ; write the error message
        mov     b, a

loc_383:
        mov     c, m
        call    CO
        inx     h
        dcr     b
        jnz     loc_383
        lxi     h, abort        ; check if aborting
        mov     a, m
        rrc
        rnc
        inx     h               ; check debug
        mov     a, m
        rrc
        jc      0               ; exit via monitor
        jmp     loc_8           ; else software bootstrap
; End of function Err


; =============== S U B R O U T I N E =======================================


RetUsr:
        lhld    retStatus$p     ; save the return status
        mov     m, c
        inx     h
        mvi     m, 0
        lhld    usrsp           ; restore the user stack and return
        sphl
        ret
; End of function RetUsr

; ---------------------------------------------------------------------------
buffers:                        ; 6 x 128 byte of buffers. Junk filled
        db 'A1136003A3DD8', 0Dh, 0Ah, 7Fh
        db ' :10122C00023D215A1196DA47124E060021DF1009B1', 0Dh, 0Ah, 7Fh
        db ' :10123C004ECD09F8215A1134C22A12C3A412213DF1', 0Dh, 0Ah, 7Fh
        db ' :10124C000236000E23CD09F80E0DCD09F80E0ACD8D', 0Dh, 0Ah, 7Fh
        db ' :10125C0009F8C3A412213D024E0C060021DF10092F', 0Dh, 0Ah, 7Fh
        db ' :10126C00360A4ECD09F8CD390DC3A4123A3D02B75A', 0Dh, 0Ah, 7Fh
        db ' :10127C00CAA4124F060021DF10093A5911774FCD3D', 0Dh, 0Ah, 7Fh
        db ' :10128C0009F8CD390DC3A4120E00CD09F80E24CDEA', 0Dh, 0Ah, 7Fh
        db ' :10129C0009F8CD390DC3A412213D027ED67ACC3982', 0Dh, 0Ah, 7Fh
        db ' :1012AC000DC36F112ADD1036002336002ADD107EA7', 0Dh, 0Ah, 7Fh
        db ' :1012BC00234621DC109678DE009F4F3A3E022FA188', 0Dh, 0Ah, 7Fh
        db ' :1012CC000FD03A3D02FE7AD216132ADD104E234679', 0Dh, 0Ah, 7Fh
        db ' :1012DC002ADA1009E54F060021DF10097EE1774F6D', 0Dh, 0Ah, 7Fh
        db ' :1012EC00D60AD6019F4779D61BD6019FB00FD205DF', 0Dh, 0Ah, 7Fh
        db ' :1012FC0013213E0236FF2B36FF2ADD104E23460308', 0Dh, 0Ah, 7Fh
        db ' :10130C00702B71213D0234C3B812213E0236FF2BE3', 0Dh, 0Ah, 7Fh
        db ' :10131C003600C3B8122AFF0636802A050736012A82', 0Dh, 0Ah, 7Fh
buffer$table:   db 0, 0, 0, 0, 0, 0

; =============== S U B R O U T I N E =======================================


ClrBuf:
        mvi     e, 128          ; clear 128 byte buffer
        xra     a

loc_6B0:
        stax    b
        inx     b
        dcr     e
        jnz     loc_6B0
        ret
; End of function ClrBuf


; =============== S U B R O U T I N E =======================================


FreBuf:
        lxi     h, -3A7h        ; (bc - buffers) >> 7
        dad     b
        mvi     e, 7

loc_6BD:
        mov     a, h
        ora     a
        rar
        mov     h, a
        mov     a, l
        rar
        mov     l, a
        dcr     e
        jnz     loc_6BD
        lxi     d, buffer$table ; mark this buffer as now being free
        dad     d
        mvi     m, 0
        ret
; End of function FreBuf


; =============== S U B R O U T I N E =======================================


GetBuf:
        mvi     c, 6            ; number of buffers
        lxi     h, buffer$table
        lxi     d, buffers

loc_6D7:                                ; check if in use
        mov     a, m
        ora     a
        jnz     loc_6E1
        mvi     m, 2            ; mark as in use
        mov     a, e            ; return the address
        mov     b, d
        ret
; ---------------------------------------------------------------------------

loc_6E1:                                ; next entry in buffer table
        inx     h
        push    h
        lxi     h, 128          ; next buffer location
        dad     d
        xchg
        pop     h
        dcr     c               ; try all buffers
        jnz     loc_6D7
        mvi     c, NO$FREE$BUFFER
        call    Err
; End of function GetBuf

; ---------------------------------------------------------------------------
aft$current:    db 0FFh
pointer$base:   dw 3733h        ; junk filled
datum$base:     dw 3230h        ;     "
close$p:        dw 3041h        ;     "
device$p:       dw 3033h        ;     "
access$p:       dw 3537h        ;     "
dbuf$p:         dw 3245h        ;     "
byteNo$p:       dw 4433h        ;     "
dnum$p:         dw 0D44h        ;     "
lbuf$p:         dw 7F0Ah        ;     "
dptr$p:         dw 3A20h        ;     "
lastByte$p:     dw 3530h        ;     "
blkCnt$p:       dw 3331h        ;     "
blkNo$p:        dw 4334h        ;     "
lAddr$p:        dw 3030h        ;     "
l1Addr$p:       dw 3635h        ;     "
dAddr$p:        dw 4443h        ;     "
closed:         db     0,    0, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh
device:         db     0,    1,    0,    0,    0,    0,    0
access:         db     3,    3,    0,    0,    0,    0,    0
dbuf:           dw     0,    0,    0,    0,    0,    0,    0
byteNo:         db   80h,  80h,    0,    0,    0,    0,    0
dnum:           db     0,    0,    0,    0,    0,    0,    0
lbuf:           dw     0,    0,    0,    0,    0,    0,    0
dptr:           db     0,    0,    0,    0,    0,    0,    0
lastByte:       db   80h,  80h,    0,    0,    0,    0,    0
blkcnt:         dw    25,   25,    0,    0,    0,    0,    0
blkNo:          dw     0,    0,    0,    0,    0,    0,    0
lAddr:          dw     1,    1,    0,    0,    0,    0,    0
l1Addr:         dw  101h, 101h,    0,    0,    0,    0,    0
dAddr:          dw     2,    2,    0,    0,    0,    0,    0

; =============== S U B R O U T I N E =======================================
; Set up simple pointers to the various data elements for the given AFT


SetTab:
        lxi     h, aft$current
        mvi     b, 0
        mov     a, m
        sub     c
        jz      loc_80A         ; no change
        mov     m, c
        lxi     h, closed
        dad     b
        shld    close$p
        lxi     h, device
        dad     b
        shld    device$p
        lxi     h, access
        dad     b
        shld    access$p
        lxi     h, byteNo
        dad     b
        shld    byteNo$p
        lxi     h, dnum
        dad     b
        shld    dnum$p
        lxi     h, dptr
        dad     b
        shld    dptr$p
        lxi     h, lastByte
        dad     b
        shld    lastByte$p
        lxi     h, blkNo
        dad     b
        dad     b
        shld    blkNo$p
        lxi     h, blkcnt
        dad     b
        dad     b
        shld    blkCnt$p
        lxi     h, lAddr
        dad     b
        dad     b
        shld    lAddr$p
        lxi     h, l1Addr
        dad     b
        dad     b
        shld    l1Addr$p
        lxi     h, dAddr
        dad     b
        dad     b
        shld    dAddr$p

loc_80A:
        lxi     h, lbuf
        dad     b
        dad     b
        shld    lbuf$p
        mov     e, m
        inx     h
        mov     d, m
        xchg
        shld    pointer$base
        lxi     h, dbuf
        dad     b
        dad     b
        shld    dbuf$p
        mov     e, m
        inx     h
        mov     d, m
        xchg
        shld    datum$base
        ret
; End of function SetTab


; =============== S U B R O U T I N E =======================================


GetAft:
        lxi     h,  closed+2
        mvi     c, 2            ; check for free aft (2-6)

loc_82E:
        mvi     a, 6
        sub     c
        jc      loc_83D
        mov     a, m
        inx     h
        rrc
        mov     a, c            ; if free then return the aft which is in c
        rc
        inr     c               ; next aft
        jnz     loc_82E

loc_83D:
        mvi     c, AFT$FULL
        call    Err
; End of function GetAft

; ---------------------------------------------------------------------------
xeq_drive:      db  31h ; A     ; junk filled
xeq_dcb$p:      dw 3233h        ;     "
xeq_recal$pb:   db 80h, DCMD$RECAL, 0, 0, 0

; =============== S U B R O U T I N E =======================================


Xeqiopb:
        lxi     h, xeq_drive
        mov     m, c
        inx     h
        mov     m, e
        inx     h
        mov     m, d
        di
        lxi     h, xeq_recal$pb + IOINS
        mvi     m, DCMD$RECAL    ; recalibrate
        lxi     h, xeq_recal$pb + SADR
        mvi     m, 0
        mov     a, c            ; check if drive 0 or drive 1
        rrc
        jnc     loc_876
        mvi     m, 20h          ; select drive 1
        lxi     h, xeq_recal$pb + IOINS
        mvi     m, 33h
        xchg
        inx     h               ; update the user's iopb cmd to reflect drive 1
        mov     a, m
        ori     30h
        mov     m, a
        inx     h
        inx     h
        inx     h
        mov     a, m            ; and the sadr likewise
        ori     20h
        mov     m, a

loc_876:
        mvi     c, 10           ; retry count

loc_878:
        in      FDCC$STATUS$0   ; disk status input port
        ani     OPCL            ; disk completion status
        jz      loc_886
        in      LOW$ADDRESS$0   ; low(IOPB)
        in      RESULT$BYTE$0   ; disk result status input port
        jmp     loc_878
; ---------------------------------------------------------------------------

loc_886:
        in      FDCC$STATUS$0   ; disk status input port
        lxi     h, xeq_drive
        mov     e, m
        inr     e
        ana     e
        push    b               ; preserve retry count
        mvi     c, DRIVE$NOT$READY
        cz      Err
        pop     b
        lxi     h, xeq_dcb$p    ; issue the user's iopb command
        mov     a, m
        out     LOW$ADDRESS$0   ; low(IOPB)
        inx     h
        mov     a, m
        out     HIGH$ADDRESS$1  ; high(IOPB)

loc_89F:
        in      FDCC$STATUS$0   ; disk status input port
        ani     OPCL            ; disk completion status
        jz      loc_89F
        in      LOW$ADDRESS$0   ; low(IOPB)
        lxi     h, rtype        ; get the result type
        mov     m, a
        in      RESULT$BYTE$0   ; disk result status input port
        dcx     h
        mov     m, a            ; and result byte
        ora     a
        jnz     loc_8B6
        ei                      ; 0 then all done
        ret
; ---------------------------------------------------------------------------

loc_8B6:                                ; issue recalibrate
        lxi     d, xeq_recal$pb
        mov     a, e
        out     LOW$ADDRESS$0   ; low(IOPB)
        mov     a, d
        out     HIGH$ADDRESS$1  ; high(IOPB)

loc_8BF:                                ; disk status input port
        in      FDCC$STATUS$0
        ani     4
        jz      loc_8BF         ; wait till complete
        dcr     c               ; see if done all retries
        jnz     loc_878
        mvi     c, DISK$IO$ERROR
        call    Err
; ---------------------------------------------------------------------------
xio_Cmd:  db  33h               ; junk filled
xio_Drv:  db  41h               ; junk filled
xio_dcb:
        db 80h, 31h, 31h, 33h, 30h  ; all bar 80h junk filled
        dw 4446h                ; junk filled
        db '211'                ;     "
; ---------------------------------------------------------------------------

Xio:                                    ; de = buffer
        push    d
        push    b               ; bc = track/sec
        lxi     h, xio_dcb + IOINS
        lda     xio_Cmd         ; install the command
        mov     m, a
        inx     h
        mvi     m, 1            ; 1 sector
        inx     h
        pop     d
        mov     m, d            ; the track/sec
        inx     h
        mov     m, e
        inx     h
        pop     d
        mov     m, e            ; the buffer
        inx     h
        mov     m, d
        lxi     h, xio_Drv      ; pick up the drive
        mov     c, m
        lxi     d, xio_dcb
        call    Xeqiopb
        ret
; End of function Xeqiopb


; =============== S U B R O U T I N E =======================================


RdSec:
        lxi     h, xio_Cmd      ; bc = tracksec, de = buffer
        mvi     m, DCMD$READ
        lhld    device$p
        mov     a, m
        sta     xio_Drv
        call    Xio
        ret
; End of function RdSec


; =============== S U B R O U T I N E =======================================


WrSec:
        lxi     h, xio_Cmd
        mvi     m, CANT$WRITE
        lhld    device$p
        mov     a, m
        sta     xio_Drv
        call    Xio
        ret
; End of function WrSec

; ---------------------------------------------------------------------------
deviceNames:    db '0F1FITOTIVOV1I1ORTRH1R2RPTPH1P2PPL1LICOCBB'
pn:             db '210013097E' ; junk filled
pn2:            db '0D21521309' ;     "
canon_name:     dw 3639h        ;     "
canon_intfn$p:  dw 3243h        ;     "
canon_frst:     db 34h          ;     "
canon_second:   db 35h          ;     "
                db 31h          ;     "
canon_i:        db 34h          ;     "

; =============== S U B R O U T I N E =======================================


Canon:


        lxi     h, canon_name
        mov     m, c            ; bc = filename, de = intfn$p
        inx     h
        mov     m, b
        inx     h
        mov     m, e
        inx     h
        mov     m, d
        jmp     loc_9C2
; End of function Canon


; =============== S U B R O U T I N E =======================================


Alphanum:
        lhld    canon_name
        mov     a, m
        call    ToUpper
        sui     'A'
        sbb     a
        cma
        mov     c, a
        push    b
        mov     e, m
        mvi     a, 'Z'
        sub     e
        sbb     a
        cma
        pop     d
        ana     e
        mov     c, a
        push    b
        mov     a, m
        sui     '0'
        sbb     a
        cma
        mov     e, a
        push    d
        mov     c, m
        mvi     a, '9'
        sub     c
        sbb     a
        cma
        pop     b
        ana     c
        pop     b
        ora     c
        ret
; End of function Alphanum


; =============== S U B R O U T I N E =======================================


ToUpper:
        cpi     'a'
        rm
        cpi     'z' + 1
        rp
        ani     0DFh
        ret
; End of function ToUpper


; =============== S U B R O U T I N E =======================================


GetFnChar:
        call    Alphanum        ; only accept alpha numeric
        rrc
        jnc     locret_9C1
        lxi     h, canon_i      ; stuff the character
        mov     c, m
        mvi     b, 0
        lhld    canon_intfn$p   ; index into Fn
        dad     b
        xchg
        lhld    canon_name      ; get the name char
        mov     a, m
        stax    d               ; and save in Fn (note not uppercased !!)
        inx     h
        shld    canon_name
        lxi     h, canon_frst   ; clear flag to reflect we have a char
        mvi     m, 0

locret_9C1:
        ret
; End of function GetFnChar

; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR Canon

loc_9C2:                                ; clear the Fn
        lhld    canon_intfn$p
        mvi     c, 10

loc_9C7:
        mvi     m, 0
        inx     h
        dcr     c
        jnz     loc_9C7

loc_9CE:                                ; skip leading spaces
        lhld    canon_name
        mov     a, m
        sui     ' '
        jnz     loc_9DE
        inx     h
        shld    canon_name
        jmp     loc_9CE
; ---------------------------------------------------------------------------

loc_9DE:                                ; check for defice
        lhld    canon_name
        mov     a, m
        sui     ':'
        jnz     loc_A38
        lhld    canon_intfn$p
        mvi     m, 0FFh         ; set device to 0xff, until determined otherwise
        lhld    canon_name
        inx     h
        mov     a, m
        sta     canon_second    ; interestingly not upper cased
        inx     h
        mov     a, m
        sta     canon_frst      ; bytes are stored swapped for the comparison
        inx     h
        mov     a, m
        sui     ':'             ; should be a closing :
        mvi     a, BAD$PATH
        rnz
        lxi     b, 0            ; hunt for a match, bc is the device

loc_A03:
        mvi     a, 20
        sub     c
        jc      loc_A25         ; all done
        lxi     h, deviceNames  ; "0F1FITOTIVOV1I1ORTRH1R2RPTPH1P2PPL1LICO"...
        dad     b
        dad     b
        mov     a, m
        inx     h
        mov     d, m
        lxi     h, canon_frst   ; first char compared is 2nd char of the device
        sub     m
        inx     h
        mov     e, a            ; save difference in second char
        mov     a, d            ; check the first char
        sbb     m
        ora     e
        jnz     loc_A21
        lhld    canon_intfn$p   ; save the device
        mov     m, c

loc_A21:                                ; keep looking (even if we found already !)
        inr     c
        jnz     loc_A03

loc_A25:                                ; check we got a device
        lhld    canon_intfn$p
        mov     a, m
        sui     0FFh
        mvi     a, BAD$DEVICE
        rz
        lxi     b, 4
        lhld    canon_name      ; advance past device
        dad     b
        shld    canon_name

loc_A38:                                ; use as a flag to indicate no chars
        lxi     h, canon_frst
        mvi     m, 0FFh
        lxi     h, canon_i
        mvi     m, 1            ; collect up to 6 chars of name

loc_A42:
        mvi     a, 6
        lxi     h, canon_i
        sub     m
        jc      loc_A55
        call    GetFnChar
        lxi     h, canon_i
        inr     m
        jnz     loc_A42

loc_A55:
        lxi     h, canon_frst
        mov     c, m
        inx     h               ; copy flag for whether no name
        mov     m, c
        lhld    canon_name
        mov     a, m
        sui     '.'
        sui     1
        sbb     a
        sta     canon_frst      ; second is true if we have a . i.e. we need an extent
        rrc
        jnc     loc_A8A
        lhld    canon_name      ; past the .
        inx     h
        shld    canon_name
        lxi     h, canon_i      ; collect the extent
        mvi     m, 7

loc_A77:
        mvi     a, 9
        lxi     h, canon_i
        sub     m
        jc      loc_A8A
        call    GetFnChar
        lxi     h, canon_i
        inr     m
        jnz     loc_A77

loc_A8A:
        lhld    canon_intfn$p
        mov     c, m
        mvi     a, 1
        sub     c
        jc      loc_AA2         ; jump if not F0 or F1
        lxi     h, canon_second ; error if we had no name
        mov     a, m
        rrc
        mvi     a, NULL$FILENAME
        rc
        dcx     h               ; error if we had no ext and . was seen
        mov     a, m
        rrc
        mvi     a, NULL$EXTENSION
        rc

loc_AA2:
        call    Alphanum
        mov     c, a            ; c reflects if alpha numeric
        lhld    canon_name
        mov     a, m
        sui     '.'
        sui     1
        sbb     a
        ora     c
        mov     e, a
        mov     a, m
        sui     ':'
        sui     1
        sbb     a
        ora     e
        rrc                     ; error if we have alphanumeric, . or : after name
        mvi     a, BAD$PATH
        rc
        xra     a
        ret
; END OF FUNCTION CHUNK FOR Canon

; =============== S U B R O U T I N E =======================================


GetFn:
        call    Canon
        ora     a
        rz
        mov     c, a
        call    RetUsr
; End of function GetFn

; ---------------------------------------------------------------------------
bitMapBuffer:               ; 512 byte bit map, junk filled
        db '9960E04DC9B7C', 0Dh, 0Ah, 7Fh
        db ' :1014AD00032146094ECDA607014609CD91130F0E16', 0Dh, 0Ah, 7Fh
        db ' :1014BD000DD49B03218B144E0600218D14097E2122', 0Dh, 0Ah, 7Fh
        db ' :1014CD005B13B6773A8C140FDAE914218B144E06A0', 0Dh, 0Ah, 7Fh
        db ' :1014DD0000218D14097E2F215B13A6773A46093220', 0Dh, 0Ah, 7Fh
        db ' :0F14ED003310015113111000CD4C10CD6413C9F1', 0Dh, 0Ah, 7Fh
        db ' :1014F'
mapChange:      db    0
mapDCB: db 80h, DCMD$WRITE, 2, 2, 2
        dw bitMapBuffer
        db '000'            ; junk filled
mapDrv: db 0FFh
baseTrkSec:   dw 3030h      ; junk filled
bitMapIndex:  dw 3031h
bitMask:      db   80h,  40h,  20h,  10h,    8,    4,    2,    1

; =============== S U B R O U T I N E =======================================


RwMap:
        lda     mapDCB + IOINS
        sui     CANT$WRITE
        sui     1
        sbb     a
        lxi     h, mapChange
        mov     c, a
        mov     a, m
        cma
        ana     c
        rrc
        rc                      ; op is write and no change so nothing to do
        mvi     m, 0            ; clear the mapChg
        lxi     h, 0
        shld    bitMapIndex
        inx     h
        shld    baseTrkSec      ; sets both sector and track
        lxi     h, mapDrv
        mov     c, m
        lxi     d, mapDCB
        call    Xeqiopb
        lxi     h, mapDCB + IOINS
        mvi     m, CANT$WRITE   ; mark next op to default to write
        ret
; End of function RwMap


; =============== S U B R O U T I N E =======================================


LoadMap:
        lda     mapDrv          ; same drive so no change
        sub     c
        rz
        push    b
        call    RwMap           ; write the old map if necessary
        pop     b
        lxi     h, mapDrv       ; update the new drive
        mov     m, c
        lxi     h, mapDCB + IOINS
        mvi     m, DCMD$READ    ; make a read op
        call    RwMap
        ret
; End of function LoadMap

; ---------------------------------------------------------------------------
alloc_Drv:      db 35h          ; all below are junk filled
alloc_bitNo:    db 31h
alloc_trkSec:   dw 3045h
alloc_bitMapByte$p:dw 3030h

; =============== S U B R O U T I N E =======================================


Allocate:
        lxi     h, alloc_Drv
        mov     m, c
        call    LoadMap         ; make sure we have a valid bit map
        lda     baseTrkSec+1
        sta     alloc_trkSec+1

loc_C36:
        mvi     a, 76
        lxi     h,  alloc_trkSec+1
        sub     m
        jc      loc_CB7
        lda     baseTrkSec
        sta     alloc_trkSec

loc_C45:
        mvi     a, 26
        lxi     h, alloc_trkSec
        sub     m
        jc      loc_CAB
        lda     bitMapIndex
        ani     7
        sta     alloc_bitNo
        mvi     e, 3            ; >> 3
        lhld    bitMapIndex

loc_C5B:
        mov     a, h
        ora     a
        rar
        mov     h, a
        mov     a, l
        rar
        mov     l, a
        dcr     e
        jnz     loc_C5B
        lxi     d, bitMapBuffer
        dad     d
        shld    alloc_bitMapByte$p
        lxi     h, alloc_bitNo
        mov     c, m
        mvi     b, 0
        lxi     h, bitMask
        dad     b
        mov     a, m
        lhld    alloc_bitMapByte$p
        ana     m
        jnz     loc_C9D
        lxi     h, mapChange    ; record bit map changed
        mvi     m, 0FFh
        lxi     h, alloc_bitNo
        mov     e, m
        mvi     d, 0
        lxi     h, bitMask
        dad     d
        mov     a, m
        lhld    alloc_bitMapByte$p
        ora     m
        mov     m, a
        lhld    alloc_trkSec
        shld    baseTrkSec
        mov     a, l
        mov     b, h
        ret
; ---------------------------------------------------------------------------

loc_C9D:
        lhld    bitMapIndex
        inx     h
        shld    bitMapIndex
        lxi     h, alloc_trkSec
        inr     m
        jnz     loc_C45

loc_CAB:
        lxi     h, baseTrkSec
        mvi     m, 1
        lxi     h,  alloc_trkSec+1
        inr     m
        jnz     loc_C36

loc_CB7:
        mvi     c, DISK$FULL
        call    Err
        ret
; End of function Allocate

; ---------------------------------------------------------------------------
dealloc_drive:  db  30h         ; all below are junk filled
dealloc_trksec: dw 3236h
dealloc_bitmapByte$p:dw 4641h
dealloc_bitno:  db 42h

; this routing implements the following PL/M function

;  DEALLOC: PROCEDURE(DRIVE, TRKSEC);
;  DECLARE DRIVE BYTE, TRKSEC ADDRESS;
;  DECLARE BITMAPBYTE$P ADDRESS, BITMAPBYTE BASED BITMAPBYTE$P BYTE;
;  DECLARE BITNO BYTE;
;
;  CALL RWMAP(DRIVE, DCMD$READ);
;  IF (BITMAPBYTE$P := HIGH(TRKSEC) * 26 + LOW(TRKSEC) - 1) < BITMAPINDEX THEN
;     DO;
;        BITMAPINDEX = BITMAPBYTE$P;
;        BASETRKSEC = TRKSEC;
;     END;
;        BITNO = LOW(BITMAPBYTE$P) AND 7;
;        BITMAPBYTE$P = .BITMAPBUFFER + SHR(BITMAPBYTE$P, 3);
;        BITMAPBYTE = BITMAPBYTE AND NOT BITMASK(BITNO);
;        MAP$CHANGE = TRUE;
;  END;

; =============== S U B R O U T I N E =======================================


Dealloc:
        lxi     h, dealloc_drive
        mov     m, c
        inx     h
        mov     m, e
        inx     h
        mov     m, d
        call    LoadMap
        lhld    dealloc_trksec+1 ; track
        mvi     h, 0
        push    h               ; stack = track
        dad     h
        xchg                    ; de = track * 2
        pop     h
        push    h
        dad     d
        dad     h
        dad     h               ; hl = track * 12
        xchg
        pop     h               ; hl = track * 13
        dad     d
        dad     h               ; hl = track * 26
        xchg
        lhld    dealloc_trksec
        mvi     h, 0
        dcx     h
        dad     d
        shld    dealloc_bitmapByte$p
        xchg
        mov     a, e
        lxi     h, bitMapIndex
        sub     m
        inx     h
        mov     a, d
        sbb     m
        jnc     loc_D02
        lhld    dealloc_bitmapByte$p
        shld    bitMapIndex
        lhld    dealloc_trksec
        shld    baseTrkSec

loc_D02:
        lda     dealloc_bitmapByte$p
        ani     7
        sta     dealloc_bitno
        lhld    dealloc_bitmapByte$p
        mvi     e, 3

loc_D0F:
        mov     a, h
        ora     a
        rar
        mov     h, a
        mov     a, l
        rar
        mov     l, a
        dcr     e
        jnz     loc_D0F
        lxi     d, bitMapBuffer
        dad     d
        shld    dealloc_bitmapByte$p
        mov     c, m
        lxi     h, dealloc_bitno
        mov     e, m
        mvi     d, 0
        lxi     h, bitMask
        dad     d
        mov     a, m
        cma
        ana     c
        lhld    dealloc_bitmapByte$p
        mov     m, a
        lxi     h, mapChange
        mvi     m, 0FFh
        ret
; End of function Dealloc


; =============== S U B R O U T I N E =======================================


Rescan:
        lxi     h, edit_lptr    ; reset edit inptr & in$mode
        mvi     m, 0
        inx     h
        mvi     m, 0
        ret
; End of function Rescan
; ---------------------------------------------------------------------------
ioMask: db  0FFh, 0FFh, 0FCh, 0FCh, 0FCh, 0FCh, 0FCh, 0FCh
        db  0F3h, 0F3h, 0F3h, 0F3h, 0CFh, 0CFh, 0CFh, 0CFh
        db   3Fh,  3Fh
ioFlag: db     0,    0,    0,    0,    1,    1,    3,    3
        db     0,    4,    8,  0Ch,    0,  10h,  20h,  30h
        db   80h, 0C0h
fio_conn:       db 7Fh          ; all below are junk filled
fio_buffer:     dw 3A20h
fio_count:      dw 3031h
fio_actual:     dw 3531h
fio_writeFlag:  db 38h
fio_needwrite:  db 45h
fio_work$buf:   dw 3030h
fio_newLinks$p: dw 3730h

; =============== S U B R O U T I N E =======================================


Fio:
        lxi     h, fio_actual
        mov     m, c
        inx     h
        mov     m, b
        inx     h
        mov     m, e
        mov     h, b
        mov     l, c
        mvi     m, 0            ; Actual = 0
        inx     h
        mvi     m, 0

loc_D82:                                ; while count > actual
        lhld    fio_actual
        mov     a, m
        inx     h
        mov     b, m
        lxi     h, fio_count
        sub     m
        inx     h
        mov     a, b
        sbb     m
        rnc
        lda     fio_writeFlag   ; fioFlg is true for write
        cma
        mov     c, a
        push    b
        lhld    blkCnt$p        ; return if reading and cur$blkcnt <= cur$blkno and cur$byteno = cur$lastbyte
        mov     e, m
        inx     h
        mov     d, m
        lhld    blkNo$p
        mov     a, m
        inx     h
        mov     b, m
        sub     e
        mov     a, b
        sbb     d
        sbb     a
        cma
        pop     d
        ana     e
        mov     c, a
        push    b
        lhld    byteNo$p
        mov     a, m
        lhld    lastByte$p
        sub     m
        sui     1
        sbb     a
        pop     d
        ana     e
        rrc
        rc
        lhld    byteNo$p        ; if cur$byteno = 128
        mov     a, m
        sui     128
        jnz     loc_F2B
        mvi     m, 0            ; cur$byteno = 0
        lhld    dptr$p          ; if (cur$dptr := cur$dptr + 1) = 64
        mov     a, m
        inr     a
        mov     m, a
        sui     64
        jnz     loc_E50
        lhld    pointer$base    ; if links(FLINK) = 0
        inx     h
        inx     h
        mov     a, m
        inx     h
        ora     m
        jnz     loc_E1B
        dcx     h
        push    h
        lhld    device$p        ; links(FLINK) = alloc(cur$device)
        mov     c, m
        call    Allocate
        pop     h
        mov     m, a
        inx     h
        mov     m, b
        lhld    dbuf$p          ; clrbuf(cur$dbuf)
        mov     c, m
        inx     h
        mov     b, m
        call    ClrBuf
        lhld    dbuf$p
        mov     e, m
        inx     h
        mov     d, m
        xchg
        shld    fio_newLinks$p  ; newlnk = cur$dbuf
        lhld    lAddr$p
        mov     e, m
        inx     h
        mov     d, m
        lhld    fio_newLinks$p  ; newlnk[0] = cur$laddr
        mov     m, e
        inx     h
        mov     m, d
        call    RwMap
        lhld    pointer$base
        inx     h
        inx     h
        mov     c, m
        inx     h
        mov     b, m
        lhld    dbuf$p
        mov     e, m
        inx     h
        mov     d, m
        call    WrSec           ; wrSec(links(FLINK), cur$dbuf)

loc_E1B:
        lda     fio_writeFlag
        rrc
        jnc     loc_E34         ; jmp if reading
        call    RwMap
        lhld    lAddr$p
        mov     c, m
        inx     h
        mov     b, m
        lhld    lbuf$p
        mov     e, m
        inx     h
        mov     d, m
        call    WrSec           ; WrSec(cur$lbuf, cur$Laddr)

loc_E34:                                ; cur$Laddr = links(FLINK)
        lhld    pointer$base
        inx     h
        inx     h
        mov     c, m
        inx     h
        mov     b, m
        lhld    lAddr$p
        mov     m, c
        inx     h
        mov     m, b
        lhld    lbuf$p
        mov     e, m
        inx     h
        mov     d, m
        call    RdSec           ; RdSec(cur$Laddr, cur$Lbuf)
        lhld    dptr$p          ; cur$dptr = 2
        mvi     m, 2

loc_E50:                                ; cur$Daddr = links(cur$dptr)
        lhld    dptr$p
        mov     c, m
        mvi     b, 0
        lhld    pointer$base
        dad     b
        dad     b
        mov     a, m
        inx     h
        mov     b, m
        lhld    dAddr$p
        mov     m, a
        inx     h
        mov     m, b
        lda     fio_writeFlag
        rrc
        jnc     loc_E86         ; jmp if reading
        lhld    device$p        ; links(cur$dptr), cur$daddr = alloc(cur$device)
        mov     c, m
        call    Allocate
        lhld    dptr$p
        mov     e, m
        mvi     d, 0
        lhld    pointer$base
        dad     d
        dad     d
        mov     m, a
        inx     h
        mov     m, b
        lhld    dAddr$p
        mov     m, a
        inx     h
        mov     m, b

loc_E86:                                ; cur$blkno = cur$blkno + 1
        lhld    blkNo$p
        mov     e, m
        inx     h
        mov     d, m
        inx     d
        mov     m, d
        dcx     h
        mov     m, e
        lhld    fio_actual      ;  if (needwrite := count - actual) >= 128 and
                                ;           (not reading or  cur$blkno < cur$blkcnt))
        mov     c, m
        inx     h
        mov     b, m
        lxi     h, fio_count
        mov     a, m
        inx     h
        mov     d, m
        sub     c
        mov     e, a
        mov     a, d
        sbb     b
        mov     d, a
        mov     a, e
        sui     80h
        mov     e, a
        mov     a, d
        sbi     0
        sbb     a
        cma
        lhld    blkNo$p
        mov     e, a
        mov     a, m
        inx     h
        mov     b, m
        push    d
        lhld    blkCnt$p
        mov     c, a
        mov     a, m
        inx     h
        mov     d, m
        mov     e, a
        mov     a, c
        sub     e
        mov     c, a
        mov     a, b
        sbb     d
        sbb     a
        lxi     h, fio_writeFlag
        ora     m
        pop     d
        ana     e
        inx     h
        mov     m, a
        rrc
        jnc     loc_EF6
        lhld    byteNo$p        ; cur$byteNo := 128
        mvi     m, 128
        lhld    fio_actual      ; actual += 128
        mov     a, m
        inx     h
        mov     h, m
        mov     l, a
        lxi     d, 128
        dad     d
        xchg
        lhld    fio_actual
        mov     m, e
        inx     h
        mov     m, d
        lhld    fio_buffer      ; workbuf = buffer
        shld    fio_work$buf
        lxi     b, 128
        lhld    fio_buffer      ; buffer += 128
        dad     b
        shld    fio_buffer
        jmp     loc_F00
; ---------------------------------------------------------------------------

loc_EF6:                                ; workBuf = cur$dbuf
        lhld    dbuf$p
        mov     e, m
        inx     h
        mov     d, m
        xchg
        shld    fio_work$buf

loc_F00:
        lxi     h, fio_writeFlag
        mov     a, m
        rrc
        jnc     loc_F1E         ; jmp if reading
        inx     h
        mov     a, m
        rrc
        jnc     loc_F2B
        lhld    dAddr$p
        mov     c, m
        inx     h
        mov     b, m
        lhld    fio_work$buf
        xchg
        call    WrSec           ; WrSec(cur$daddr, workBuf)
        jmp     loc_F2B
; ---------------------------------------------------------------------------

loc_F1E:                                ; RdSec(cur$daddr, workBuf)
        lhld    dAddr$p
        mov     c, m
        inx     h
        mov     b, m
        lhld    fio_work$buf
        xchg
        call    RdSec

loc_F2B:                                ; if cur$byteno != 128
        lhld    byteNo$p
        mov     a, m
        sui     128
        jz      loc_D82
        lda     fio_writeFlag
        rrc
        jnc     loc_F4E         ; jmp if reading
        lhld    byteNo$p        ; datum[cur$byteNo) = *buffer
        mov     c, m
        mvi     b, 0
        lhld    datum$base
        dad     b
        xchg
        lhld    fio_buffer
        mov     a, m
        stax    d
        jmp     loc_F5D
; ---------------------------------------------------------------------------

loc_F4E:                                ; *buffer = dataum[cur$byteno]
        lhld    byteNo$p
        mov     c, m
        mvi     b, 0
        lhld    datum$base
        dad     b
        mov     a, m
        lhld    fio_buffer
        mov     m, a

loc_F5D:                                ; if ++cur$byteno = 128 and writing
        lhld    byteNo$p
        mov     a, m
        inr     a
        mov     m, a
        sui     128
        sui     1
        sbb     a
        lxi     h, fio_writeFlag
        ana     m
        rrc
        jnc     loc_F7F
        lhld    dAddr$p         ; WrSec(cur$daddr, cur$dbuf)
        mov     c, m
        inx     h
        mov     b, m
        lhld    dbuf$p
        mov     e, m
        inx     h
        mov     d, m
        call    WrSec

loc_F7F:                                ; ++buffer
        lhld    fio_buffer
        inx     h
        shld    fio_buffer
        lhld    fio_actual      ; actual--
        mov     e, m
        inx     h
        mov     d, m
        inx     d
        mov     m, d
        dcx     h
        mov     m, e
        jmp     loc_D82
; End of function Fio


; =============== S U B R O U T I N E =======================================


SetDev:
        lhld    device$p
        mov     e, m
        mvi     d, 0
        lxi     h, ioMask
        dad     d
        call    IOCHK
        ana     m
        mov     c, a
        lxi     h, ioFlag
        dad     d
        mov     a, m
        ora     c
        mov     c, a
        call    IOSET
        ret
; End of function SetDev

; ---------------------------------------------------------------------------
read_conn:      db 46h          ; all below are junk filled
read_buffer:    dw 4346h
read_count:     dw 3739h
read_actual:    dw 0D35h

; =============== S U B R O U T I N E =======================================


Read:
        lxi     h, read_count
        mov     m, c
        inx     h
        mov     m, b
        inx     h
        mov     m, e
        inx     h
        mov     m, d
        xchg
        mvi     m, 0            ; actual = 0
        inx     h
        mvi     m, 0
        lxi     h, read_conn
        mov     c, m
        call    SetTab
        call    SetDev
        lhld    device$p
        mov     c, m
        mvi     a, 1
        sub     c
        jc      loc_FF5         ; jmp if not file
        lda     read_conn
        sta     fio_conn
        lhld    read_buffer
        shld    fio_buffer
        lhld    read_count
        shld    fio_count
        lhld    read_actual
        mov     c, l            ; bc = actual$p
        mov     b, h
        mvi     e, 0
        call    Fio
        ret
; ---------------------------------------------------------------------------

loc_FF5:                                ; while actual != cnt
        lhld    read_actual
        mov     a, m
        inx     h
        mov     b, m
        lhld    read_count
        sub     l
        mov     c, a
        mov     a, b
        sbb     h
        ora     c
        rz
        lhld    device$p
        mov     a, m
        cpi     8
        jnc     loc_1017        ; jmp device >= 8
        call    CI              ; get from CI
        lhld    read_buffer
        mov     m, a
        jmp     loc_101F
; ---------------------------------------------------------------------------

loc_1017:                               ; get from RI
        call    RI
        lhld    read_buffer
        mov     m, a
        rc                      ; return if carry set

loc_101F:                               ; advance buffer & increase actual
        lhld    read_buffer
        inx     h
        shld    read_buffer
        lhld    read_actual
        mov     e, m
        inx     h
        mov     d, m
        inx     d
        mov     m, d
        dcx     h
        mov     m, e
        jmp     loc_FF5
; End of function Read

; ---------------------------------------------------------------------------
write_conn:     db 36h          ; write_conn to write_actual are junk filled
write_buffer:   dw 3930h
write_count:    dw 4443h
write_actual:   dw 3139h
writeCase:      db     0,    0, 0FFh,    1, 0FFh,    1, 0FFh,    1
                db  0FFh, 0FFh, 0FFh, 0FFh,    2,    2,    2,    2
                db     3,    3

; =============== S U B R O U T I N E =======================================


Write:
        lxi     h, write_buffer
        mov     m, c
        inx     h
        mov     m, b
        inx     h
        mov     m, e
        inx     h
        mov     m, d
        lxi     h, write_conn
        mov     c, m
        call    SetTab
        lhld    close$p
        mov     a, m
        rrc
        mvi     c, CANT$WRITE
        cc      RetUsr          ; error if read mode
        call    SetDev

loc_106A:                               ; while bytes to write
        lhld    write_count
        mov     a, l
        ora     h
        rz
        lhld    device$p
        mov     e, m
        mvi     d, 0
        lxi     h, writeCase    ; note read only skipped above
        dad     d
        mov     l, m
        mvi     h, 0
        dad     h
        lxi     d, off_1087
        dad     d
        mov     e, m
        inx     h
        mov     d, m
        xchg
        pchl
; ---------------------------------------------------------------------------
off_1087:
        dw wrFile
        dw wrConsole
        dw wrPunch
        dw wrList
; ---------------------------------------------------------------------------

wrFile:                                 ; file I/O
        lda     write_conn
        sta     fio_conn
        lhld    write_buffer
        shld    fio_buffer
        lhld    write_count
        shld    fio_count
        lxi     b, write_actual
        mvi     e, 0FFh
        call    Fio
        ret
; ---------------------------------------------------------------------------

wrConsole:                              ; console out
        lhld    write_buffer
        mov     c, m
        call    CO
        jmp     loc_10C8
; ---------------------------------------------------------------------------

wrPunch:                                ; punch out
        lhld    write_buffer
        mov     c, m
        call    PO
        jmp     loc_10C8
; ---------------------------------------------------------------------------

wrList:                                 ; list out
        lhld    write_buffer
        mov     c, m
        call    LO
        jmp     loc_10C8
; ---------------------------------------------------------------------------

loc_10C8:                               ; one less to process
        lhld    write_count
        dcx     h
        shld    write_count
        lhld    write_buffer    ; advance to next byte
        inx     h
        shld    write_buffer
        jmp     loc_106A
; ---------------------------------------------------------------------------
        ret
; End of function Write

; ---------------------------------------------------------------------------
edit_buffer:    dw 3330h        ; all below except edit_specialChars are junk filled
edit_count:     db  32h
edit_actual:    dw 3431h
edit_bytes:
        db 0Ah, '09097E1221541634C2A7162AF9B8', 0Dh, 0Ah, 7Fh
        db ' :1016C500067E323310015113111000CD4C10CD643C', 0Dh, 0Ah, 7Fh
        db ' :0216D50013C937', 0Dh, 0Ah, 7Fh
        db ' :1016DA0021D71671215113'
edit_char:      db 33h
edit_i:         db 36h
edit_selector:  db 46h
edit_specialChars:
        db    0                ; null
        db  7Fh                ; del key
        db  1Ah                ; control Z
        db  12h                ; control R
        db  18h                ; control X
        db  0Dh                ; CR
        db  0Ah                ; LF
        db  1Bh                ; ESC

; =============== S U B R O U T I N E =======================================


Edit:
        lxi     h, edit_count
        mov     m, c
        inx     h
        mov     m, e
        inx     h
        mov     m, d
        call    ResetConsoleDev

loc_116F:                               ; while inMode
        lda     edit_inMode
        rrc
        jnc     loc_12B0
        call    CI
        ani     7Fh
        sta     edit_char
        cpi     0Ah             ; skip putting \n in buffer
        jz      loc_1193
        lxi     h, edit_lptr    ; save & echo the character
        mov     c, m
        mvi     b, 0
        lxi     h, edit_bytes
        dad     b
        xchg
        mov     c, a
        stax    d
        call    CO

loc_1193:                               ; check for special characters
        lxi     h, edit_selector
        mvi     m, 0
        lxi     b, 0

loc_119B:
        mvi     a, 7
        sub     c
        jc      loc_11B4
        lxi     h, edit_specialChars
        dad     b
        lda     edit_char
        cmp     m
        jnz     loc_11B0
        mov     a, c
        sta     edit_selector

loc_11B0:
        inr     c
        jnz     loc_119B

loc_11B4:
        lhld    edit_selector
        mvi     h, 0
        dad     h
        lxi     b, off_11C3
        dad     b
        mov     e, m
        inx     h
        mov     d, m
        xchg
        pchl
; ---------------------------------------------------------------------------
off_11C3:
        dw edit_normal
        dw edit_rubout
        dw edit_controlZ
        dw edit_controlR
        dw edit_controlX
        dw edit_CR
        dw edit_LF
        dw edit_escape
; ---------------------------------------------------------------------------

edit_normal:                            ; normal just bump the character count
        lxi     h, edit_lptr
        inr     m
        jmp     loc_12A4
; ---------------------------------------------------------------------------

edit_rubout:                            ; ring bell if already at begining of line
        lxi     h, edit_lptr
        mov     a, m
        ora     a
        jz      loc_11F1
        dcr     m               ; echo the previous char
        mov     c, m
        mvi     b, 0
        lxi     h, edit_bytes
        dad     b
        mov     c, m
        call    CO
        jmp     loc_12A4
; ---------------------------------------------------------------------------

loc_11F1:                               ; ring the bell
        mvi     c, 7
        call    CO
        jmp     loc_12A4
; ---------------------------------------------------------------------------

edit_controlZ:                          ; actual = 0
        lhld    edit_actual
        mvi     m, 0
        inx     h
        mvi     m, 0
        lxi     h, edit_lptr    ; reset lptr & prime in$mode for next time
        mvi     m, 0
        inx     h
        mvi     m, 0FFh
        mvi     c, 0Dh          ; echo cr/lf
        call    CO
        mvi     c, 0Ah
        call    CO
        ret
; ---------------------------------------------------------------------------

edit_controlR:                          ; crlf
        mvi     c, 0Dh
        call    CO
        mvi     c, 0Ah
        call    CO
        lda     edit_lptr       ; if we have characters re echo the line
        ora     a
        jz      loc_12A4
        lxi     h, edit_i       ; retype the whole line
        mvi     m, 0

loc_122A:
        lda     edit_lptr
        dcr     a
        lxi     h, edit_i
        sub     m
        jc      loc_1247
        mov     c, m
        mvi     b, 0
        lxi     h, edit_bytes
        dad     b
        mov     c, m
        call    CO
        lxi     h, edit_i
        inr     m
        jnz     loc_122A

loc_1247:
        jmp     loc_12A4
; ---------------------------------------------------------------------------

edit_controlX:                          ; reset inptr, will remain in in$mode
        lxi     h, edit_lptr
        mvi     m, 0
        mvi     c, '#'          ; echo # CR, LF
        call    CO
        mvi     c, 0Dh
        call    CO
        mvi     c, 0Ah
        call    CO
        jmp     loc_12A4
; ---------------------------------------------------------------------------

edit_CR:                                ; append the LF
        lxi     h, edit_lptr
        mov     c, m
        inr     c
        mvi     b, 0
        lxi     h, edit_bytes
        dad     b
        mvi     m, 0Ah
        mov     c, m
        call    CO
        call    Rescan          ; set lptr to 0 and clear in$mode
        jmp     loc_12A4
; ---------------------------------------------------------------------------

edit_LF:                                ; ignore if at start of line
        lda     edit_lptr
        ora     a
        jz      loc_12A4
        mov     c, a
        mvi     b, 0
        lxi     h, edit_bytes
        dad     b
        lda     edit_char       ; append and write the LF
        mov     m, a
        mov     c, a
        call    CO
        call    Rescan          ; set lptr = 0 & clear in$mode
        jmp     loc_12A4
; ---------------------------------------------------------------------------

edit_escape:                            ; echo NULL, $ and rescan
        mvi     c, 0
        call    CO
        mvi     c, '$'
        call    CO
        call    Rescan          ; set lptr = 0 and clear in$mode
        jmp     loc_12A4
; ---------------------------------------------------------------------------

loc_12A4:                               ; rescan if we have 122 chars
        lxi     h, edit_lptr
        mov     a, m
        sui     122
        cz      Rescan          ; reset lptr = 0 and clear in$mode
        jmp     loc_116F
; ---------------------------------------------------------------------------
; Here when buffer has information and need to pass back to caller

loc_12B0:                               ; actual = 0
        lhld    edit_actual
        mvi     m, 0
        inx     h
        mvi     m, 0

loc_12B8:                               ; while actual < count & not in$mode
        lhld    edit_actual
        mov     a, m
        inx     h
        mov     b, m
        lxi     h, edit_count
        sub     m
        mov     a, b
        sbi     0
        sbb     a
        mov     c, a
        lda     edit_inMode
        cma
        ana     c
        rrc
        rnc
        lda     edit_lptr
        cpi     122             ; if lptr < 122 // max line length
        jnc     loc_1316
        lhld    edit_actual
        mov     c, m
        inx     h
        mov     b, m
        lhld    edit_buffer
        dad     b
        push    h
        mov     c, a
        mvi     b, 0            ; buffer[actual] = bytes[lptr]
        lxi     h, edit_bytes
        dad     b
        mov     a, m
        pop     h
        mov     m, a
        mov     c, a
        sui     0Ah             ; if bytes[lptr] == LF or bytes[lptr] == ESC
        sui     1
        sbb     a
        mov     b, a
        mov     a, c
        sui     1Bh
        sui     1
        sbb     a
        ora     b
        rrc
        jnc     loc_1305
        lxi     h, edit_inMode  ; set in$mode and lptr = 255
        mvi     m, 0FFh         ; reset for in$mode and set lptr = 255
        dcx     h
        mvi     m, 0FFh

loc_1305:                               ; actual++
        lhld    edit_actual
        mov     c, m
        inx     h
        mov     b, m
        inx     b
        mov     m, b
        dcx     h
        mov     m, c
        lxi     h, edit_lptr    ; lptr++
        inr     m
        jmp     loc_12B8
; ---------------------------------------------------------------------------

loc_1316:                               ; set inMode and clear lptr
        lxi     h, edit_inMode
        mvi     m, 0FFh
        dcx     h
        mvi     m, 0
        jmp     loc_12B8
; End of function Edit

; =============== S U B R O U T I N E =======================================


Rewind:
        lhld    byteNo$p
        mvi     m, 80h
        lhld    dptr$p
        mvi     m, 1
        lhld    blkNo$p
        mvi     m, 0
        inx     h
        mvi     m, 0
        lhld    dAddr$p
        mvi     m, 0
        inx     h
        mvi     m, 0
        lhld    l1Addr$p
        mov     c, m
        inx     h
        mov     b, m
        lhld    lAddr$p
        mov     m, c
        inx     h
        mov     m, b
        lhld    lbuf$p
        mov     e, m
        inx     h
        mov     d, m
        call    RdSec
        ret
; End of function Rewind

; ---------------------------------------------------------------------------
direct$empty:   db 45h          ; all below are junk filled
direct$file:    db '23462AFD0'
direct$attrib:  db 36h
direct$EOF$count:db 35h
direct$blk:     dw 3245h
direct$hdr$blk: dw 3533h
rcount:         dw 4336h
direct$ino:     db 44h

; =============== S U B R O U T I N E =======================================


Sync:
        lhld    dAddr$p         ; write the directory sector
        mov     c, m
        inx     h
        mov     b, m
        lhld    dbuf$p
        mov     e, m
        inx     h
        mov     d, m
        call    WrSec
        ret
; End of function Sync


; =============== S U B R O U T I N E =======================================


RdDir:
        lhld    device$p
        mov     a, m
        sta     read_conn
        lxi     h, direct$empty
        shld    read_buffer
        lxi     b, 16
        lxi     d, rcount
        call    Read
        ret
; End of function RdDir

; ---------------------------------------------------------------------------
search_fn:      dw 4533h        ; all below are junk filled
serach_i:       db 30h
search_aft:     db 31h
search_dnum:    db 32h
search_retval:  db 31h

; =============== S U B R O U T I N E =======================================


Search:
        lxi     h, search_fn
        mov     m, c
        inx     h
        mov     m, b
        lhld    device$p        ; dbuf[tmpAft = cur$device] = GetBuf();
        mov     a, m
        sta     search_aft
        mov     c, a
        mvi     b, 0
        lxi     h, dbuf
        dad     b
        dad     b
        push    h
        call    GetBuf
        pop     h
        mov     m, a
        inx     h
        mov     m, b
        lxi     h, search_aft   ; lbuf[tmpAft] = GetBuf();
        mov     c, m
        mvi     b, 0
        lxi     h, lbuf
        dad     b
        dad     b
        push    h
        call    GetBuf
        pop     h
        mov     m, a
        inx     h
        mov     m, b
        lxi     h, search_aft
        mov     c, m
        call    SetTab          ; setTab(tmpAft);
        call    Rewind
        lxi     h, direct$ino
        mvi     m, 0FFh
        lxi     h, search_dnum
        mvi     m, 0
        lxi     h, 1
        shld    rcount
        lxi     h, direct$empty
        mvi     m, 0
        lxi     h, search_retval
        mvi     m, 0

loc_13E5:                               ; while rcount <> 0 and direct$empty <> 7fh
        lxi     h, rcount
        mov     a, m
        inx     h
        mov     b, m
        ora     b
        jz      loc_144C
        lda     direct$empty
        sui     7Fh
        jz      loc_144C
        call    RdDir
        lda     direct$empty
        rrc
        jnc     loc_1411        ; jmp if in use
        lxi     h, direct$ino
        mov     a, m
        cpi     0FFh
        jnz     loc_1445        ; set direct$I$No if not already set
        lda     search_dnum     ; save this slot
        mov     m, a
        jmp     loc_1445
; ---------------------------------------------------------------------------

loc_1411:                               ; check the name & extent for a match
        lxi     h, serach_i
        mvi     m, 1

loc_1416:
        mvi     a, 9
        cmp     m
        jc      loc_1434
        mov     c, m
        mvi     b, 0
        lhld    search_fn
        dad     b
        mov     a, m
        dcr     c
        lxi     h, direct$file
        dad     b
        sub     m
        jnz     loc_1445        ; jmp if different
        lxi     h, serach_i
        inr     m
        jnz     loc_1416

loc_1434:                               ; match found
        lda     search_dnum
        sta     direct$ino      ; save the direct$I$No
        lxi     h, search_retval ; set retVal true
        mvi     m, 0FFh
        lxi     h, 0
        shld    rcount          ; clear rcound so we will exit

loc_1445:                               ; try next slot
        lxi     h, search_dnum
        inr     m
        jmp     loc_13E5
; ---------------------------------------------------------------------------

loc_144C:
        lda     direct$ino
        cpi     0FFh
        jz      loc_1473        ; jmp if not found
        sta     serach_i        ; save the direct$I$NO
        call    Rewind          ; rewind the directory file

loc_145A:                               ; step through to position at the correct entry
        lxi     h, serach_i
        mov     a, m
        sui     0FFh
        jz      loc_146C
        push    h
        call    RdDir
        pop     h
        dcr     m
        jmp     loc_145A
; ---------------------------------------------------------------------------

loc_146C:                               ; back of byteNo to start of the directory entry
        lhld    byteNo$p
        mov     a, m
        sui     10h
        mov     m, a

loc_1473:
        lhld    dbuf$p
        mov     c, m
        inx     h
        mov     b, m
        call    FreBuf          ; free the working buffer
        lhld    lbuf$p          ; and associated links buffer
        mov     c, m
        inx     h
        mov     b, m
        call    FreBuf
        lda     search_retval   ; return the outcome
        ret
; End of function Search

; ---------------------------------------------------------------------------
attrib_name:    dw 3639h        ; all below except attrib_mask are junk filled
attrib_swid:    db  43h ; C
attrib_value:   db 0Dh
attrib_mask:    db INVISIBLE
        db SYSTEM
        db WRITEP
        db FORMAT

; =============== S U B R O U T I N E =======================================


Attrib:
        lxi     h, attrib_swid
        mov     m, c
        inx     h
        mov     m, e
        lxi     h, attrib_name
        mov     c, m
        inx     h
        mov     b, m
        lxi     d, pn
        call    GetFn           ; GetNn(filename, .pn)
        mvi     a, 1
        lxi     h, pn           ; error if not file
        sub     m
        mvi     c, BAD$PATH
        cc      RetUsr
        lxi     h, pn           ; set up the file pointers
        mov     c, m
        call    SetTab
        lxi     b, pn           ; find the file
        call    Search
        rrc
        mvi     c, NO$SUCH$FILE ; not found
        cnc     RetUsr
        lxi     h, attrib_swid  ; set the relevant attribute
        mov     c, m
        mvi     b, 0
        lxi     h, attrib_mask
        dad     b
        mov     a, m
        lxi     h, direct$attrib
        ora     m
        mov     m, a
        lda     attrib_value
        rrc
        jc      loc_14E9        ; jmp if was setting
        lxi     h, attrib_swid  ; clear the relevant attibute
        mov     c, m
        mvi     b, 0
        lxi     h, attrib_mask
        dad     b
        mov     a, m
        cma
        lxi     h, direct$attrib
        ana     m
        mov     m, a

loc_14E9:                        ; write back the directory entry
        lda     pn
        sta     write_conn
        lxi     b, direct$empty
        lxi     d, 10h
        call    Write
        call    Sync            ; and sync
        ret
; End of function Attrib

; ---------------------------------------------------------------------------
close_conn:     db 33h          ; junk filled
dirCnt:         db 43h          ;     "
close_crlf:     db 0Dh, 0Ah
zero:           db 0
closeCase:      db     0,    0,    1,    2,    1,    2,    1,    2
                db     1,    1,    1,    1,    3,    3,    3,    3
                db     4,    4

; =============== S U B R O U T I N E =======================================


Close:
        lxi     h, close_conn
        mov     m, c
        call    SetTab
        lhld    close$p         ; check if already closed
        mov     a, m
        rrc
        rc
        lhld    device$p
        mov     c, m
        mvi     b, 0
        lxi     h, closeCase
        dad     b
        mov     l, m
        mvi     h, 0
        dad     h
        lxi     b, off_1537
        dad     b
        mov     e, m
        inx     h
        mov     d, m
        xchg
        pchl
; ---------------------------------------------------------------------------
off_1537:       dw closeDisk
        dw closeTrivial        ; console type input
        dw closeCo
        dw closePo
        dw closeTrivial        ; line printer
; ---------------------------------------------------------------------------

closeDisk:                              ; disk close
        lhld    lbuf$p
        mov     c, m
        inx     h
        mov     b, m
        call    FreBuf
        lhld    dbuf$p
        mov     c, m
        inx     h
        mov     b, m
        call    FreBuf
        lhld    access$p
        mov     a, m
        sui     2
        jnz     closeTrivial    ; jmp if file was in read mode
        lhld    lAddr$p
        mov     c, m
        inx     h
        mov     b, m
        lhld    lbuf$p
        mov     e, m
        inx     h
        mov     d, m
        call    WrSec
        lhld    byteNo$p
        mov     a, m
        sui     80h
        jz      loc_1583
        lhld    dAddr$p
        mov     c, m
        inx     h
        mov     b, m
        lhld    dbuf$p
        mov     e, m
        inx     h
        mov     d, m
        call    WrSec

loc_1583:                               ; flush the bit map if necessary
        call    RwMap
        lhld    device$p
        mov     c, m
        mvi     b, 0
        lxi     h, dbuf         ; update dbuf
        dad     b
        dad     b
        xchg
        lhld    dbuf$p
        mov     a, m
        inx     h
        stax    d
        inx     d
        mov     a, m
        stax    d
        lhld    device$p
        mov     c, m
        mvi     b, 0
        lxi     h, lbuf         ; update lbuf
        dad     b
        dad     b
        xchg
        lhld    lbuf$p
        mov     a, m
        inx     h
        stax    d
        inx     d
        mov     a, m
        stax    d
        lhld    dnum$p
        mov     a, m
        sta     dirCnt
        lhld    device$p
        mov     c, m
        call    SetTab
        call    Rewind

loc_15C1:                               ; seek to the directory location
        lxi     h, dirCnt
        mov     a, m
        sui     0FFh
        jz      loc_15D3
        push    h
        call    RdDir
        pop     h
        dcr     m
        jmp     loc_15C1
; ---------------------------------------------------------------------------

loc_15D3:                               ; back up to start of dir entry
        lhld    byteNo$p
        mov     a, m
        sui     10h
        mov     m, a
        lxi     h, close_conn   ; set the directory entry's eof for this conn
        mov     c, m
        mvi     b, 0
        lxi     h, byteNo
        dad     b
        mov     a, m
        sta     direct$EOF$count
        lxi     h, close_conn   ; and blk entry
        mov     c, m
        mvi     b, 0
        lxi     h, blkNo
        dad     b
        dad     b
        mov     a, m
        inx     h
        mov     b, m
        lxi     h, direct$blk
        mov     m, a
        inx     h
        mov     m, b
        lhld    device$p        ; and write back the dir entry
        mov     a, m
        sta     write_conn
        lxi     b, direct$empty
        lxi     d, 10h
        call    Write
        call    Sync
        jmp     closeTrivial
; ---------------------------------------------------------------------------

closeCo:                                ; console out devices
        lda     close_conn
        sta     write_conn      ; write cr lf
        lxi     b, close_crlf     ; "\r\n"
        lxi     d, 2
        call    Write
        jmp     closeTrivial
; ---------------------------------------------------------------------------

closePo:                                ; write 120 null trailer
        lxi     h, dirCnt
        mvi     m, 0

loc_1629:
        mvi     a, 119
        sub     m
        jc      closeTrivial
        dcx     h
        mov     a, m
        sta     write_conn
        lxi     b, zero
        lxi     d, 1
        call    Write
        lxi     h, dirCnt
        inr     m
        jnz     loc_1629
        jmp     closeTrivial
; ---------------------------------------------------------------------------

closeTrivial:                           ; mark the device as closed
        lxi     h, close_conn
        mov     c, m
        mvi     b, 0
        lxi     h, closed
        dad     b
        mvi     m, 0FFh
        ret
; End of function Close
; ---------------------------------------------------------------------------
rename_i: db  46h               ; junk filled

; =============== S U B R O U T I N E =======================================


Rename:
        push    d               ; bc = oldname, de = newname
        lxi     d, pn2
        call    GetFn           ; getfn(oldname, .pn2)
        pop     b
        lxi     d, pn
        call    GetFn           ; getfn(newname, .pn)
        mvi     a, 1            ; check if disk file
        lxi     h, pn
        sub     m
        mvi     c, NON$DISK$FILE
        cc      RetUsr
        lda     pn2             ; check if same disk
        sub     m
        mvi     c, DIFFERENT$DISK
        cnz     RetUsr
        lxi     h, pn
        mov     c, m
        call    SetTab
        lxi     b, pn
        call    Search          ; search for newname
        push    psw             ; psw (already$exists)
        lxi     b, pn2
        call    Search          ; search for oldname
        rrc
        mvi     c, NO$SUCH$FILE
        cnc     RetUsr
        lda     direct$attrib   ; check not write protected
        ani     WRITEP or FORMAT
        mvi     c, WRITE$PROTECT
        cnz     RetUsr
        pop     psw             ; recover status of looking for newname
        rrc
        mvi     c, MULTIDEFINED
        cc      RetUsr
        lxi     h, rename_i
        mvi     m, 0

loc_16A7:
        mvi     a, 8
        sub     m
        jc      loc_16C3
        mov     c, m
        mvi     b, 0
        lxi     h, direct$file  ; copy new name to the old name directory entry found with 2nd search
        dad     b
        xchg
        inx     b
        lxi     h, pn
        dad     b
        mov     a, m
        stax    d
        lxi     h, rename_i
        inr     m
        jnz     loc_16A7

loc_16C3:                               ; update the directory and flush to disk
        lhld    device$p
        mov     a, m
        sta     write_conn
        lxi     b, direct$empty
        lxi     d, 16
        call    Write
        call    Sync
        ret
; End of function Rename

; ---------------------------------------------------------------------------
scratch_drive:  db 30h          ; junk filled
scratch_linkbuf$p:dw 3739h
; =============== S U B R O U T I N E =======================================


Scratch:
        lxi     h, scratch_drive
        mov     m, c
        lxi     h, direct$empty ; mark directory entry as free
        mvi     m, 0FFh
        call    SetTab          ; c already holds drive so set up file pointers for this
        lda     scratch_drive
        sta     write_conn
        lxi     b, direct$empty
        lxi     d, 10h
        call    Write           ; write the directory entry
        lxi     h, xio_Cmd
        mvi     m, DCMD$WRITE
        lda     scratch_drive
        sta     xio_Drv
        lhld    dAddr$p
        mov     c, m
        inx     h
        mov     b, m
        lhld    dbuf$p
        mov     e, m
        inx     h
        mov     d, m
        call    Xio             ; xio(DCMD$WRITE, scratch_drive, cur$daddr, cur$dbuf)
        lhld    byteNo$p        ; backup to start of directory entry
        mov     a, m
        sui     10h
        mov     m, a
        lhld    dbuf$p
        mov     e, m
        inx     h
        mov     d, m
        xchg
        shld    scratch_linkbuf$p ; linkbuf$p = cur$dbuf

loc_1720:                               ; while direct$hdr$blk <> 0
        lxi     h, direct$hdr$blk
        mov     a, m
        mov     e, a
        inx     h
        ora     m
        mov     d, m
        jz      loc_177C
        lxi     h, scratch_drive
        mov     c, m
        call    Dealloc         ; Dealloc(drive, direct$hdr$blk)
        lxi     h, xio_Cmd
        mvi     m, 4
        lda     scratch_drive
        sta     xio_Drv
        lxi     h, direct$hdr$blk
        mov     c, m
        inx     h
        mov     b, m
        lhld    scratch_linkbuf$p
        xchg
        call    Xio
        lhld    scratch_linkbuf$p
        inx     h
        inx     h
        mov     e, m
        inx     h
        mov     d, m
        xchg
        shld    direct$hdr$blk
        lxi     b, 2

loc_1759:
        mvi     a, 3Fh ; '?'
        sub     c
        jc      loc_1720
        lhld    scratch_linkbuf$p
        dad     b
        dad     b
        mov     a, m
        mov     e, m
        inx     h
        ora     m
        mov     d, m
        jz      loc_1775
        push    b
        lxi     h, scratch_drive
        mov     c, m
        call    Dealloc
        pop     b

loc_1775:
        inr     c
        jnz     loc_1759
        jmp     loc_1720
; ---------------------------------------------------------------------------

loc_177C:
        lxi     h, xio_Cmd
        mvi     m, 4
        lda     scratch_drive
        sta     xio_Drv
        lhld    dAddr$p
        mov     c, m
        inx     h
        mov     b, m
        lhld    dbuf$p
        mov     e, m
        inx     h
        mov     d, m
        call    Xio
        call    RwMap
        ret
; End of function Scratch


; =============== S U B R O U T I N E =======================================


Delete:
        lxi     d, pn           ; check the name
        call    GetFn
        mvi     a, 1            ; error if not disk file
        lxi     h, pn
        sub     m
        mvi     c, NON$DISK$FILE
        cc      RetUsr
        mov     c, m
        call    SetTab          ; set up the pointer to the file info
        lxi     b, pn           ; find on disk
        call    Search
        cma
        rrc
        mvi     c, NO$SUCH$FILE ; error if not foundj
        cc      RetUsr
        lda     direct$attrib   ; or write protected
        ani     WRITEP or FORMAT
        mvi     c, WRITE$PROTECT
        cnz     RetUsr
        lxi     b, 2            ; check if file is currently open

loc_17C9:
        mvi     a, 6
        sub     c
        jc      loc_17FB
        lxi     h, closed
        dad     b
        mov     a, m
        cma
        lxi     h, device       ; device match
        dad     b
        mov     e, a
        lda     pn
        sub     m
        sui     1
        sbb     a
        ana     e
        mov     e, a
        lxi     h, dnum         ; and direc$ino matches
        dad     b
        lda     direct$ino
        sub     m
        sui     1
        sbb     a
        ana     e
        rrc
        push    b
        mvi     c, CANT$DELETE
        cc      RetUsr
        pop     b
        inr     c
        jnz     loc_17C9

loc_17FB:                               ; clean out the file info
        lxi     h, pn
        mov     c, m
        call    Scratch
        ret
; End of function Delete
; ---------------------------------------------------------------------------
access$support: db     3,    3,    1,    2,    1,    2,    1,    2
                db     1,    1,    1,    1,    2,    2,    2,    2
                db     2,    2,    1,    2
open_access:    db 41h          ; junk filled
open_aft:       db 30h          ;     "
open_found:     db 37h          ;     "
open_zero:      db 0

; =============== S U B R O U T I N E =======================================


Open:

; FUNCTION CHUNK AT 183B SIZE 00000202 BYTES

        push    b               ; open path
        lxi     h, open_access  ; save the open access
        mov     m, e
        jmp     loc_183B
; End of function Open


; =============== S U B R O U T I N E =======================================


Free3:
        push    b               ; bc = errNum
        lhld    dbuf$p
        mov     c, m
        inx     h
        mov     b, m
        call    FreBuf          ; free$buf(cur$dbuf)
        lhld    lbuf$p
        mov     c, m
        inx     h
        mov     b, m
        call    FreBuf          ; free$buf(cur$lbuf)
        pop     b
        call    RetUsr          ; retusr(errnum)
        ret
; End of function Free3

; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR Open

loc_183B:                               ; access > WRMODE
        mvi     a, WRMODE
        sub     m
        sbb     a
        mov     c, a
        mov     a, m            ; or access == 0
        ora     a
        sui     1
        sbb     a
        ora     c
        rrc
        mvi     c, BAD$ACCESS
        cc      RetUsr          ; error if not RDMODE or WRMODE (doen't support RWMODE as no seek)
        pop     b               ; bc = path
        lxi     d, pn
        call    GetFn
        lxi     h, pn
        mov     a, m
        sui     BBDEV           ; check for BB
        mvi     a, 0FFh         ; conn is 0xff
        rz
        mov     a, m
        sui     0FFh            ; check for bad device
        mvi     c, BAD$DEVICE
        cz      RetUsr
        mov     c, m
        mvi     b, 0
        lxi     h, access$support ; check if device support ths r/w mode
        dad     b
        lda     open_access
        ana     m
        mvi     c, BAD$ACCESS
        cz      RetUsr
        lxi     h, pn
        mov     a, m
        sui     CIDEV           ; check for CI
        mvi     a, 1            ; conn = 1
        rz
        mov     a, m
        sui     CODEV           ; check for CO, conn = 0
        rz
        call    GetAft          ; allocate an aft
        sta     open_aft
        mov     c, a
        call    SetTab          ; set pointers for it
        lda     open_access
        lhld    access$p        ; set the access mode
        mov     m, a
        lxi     h, pn
        mov     c, m            ; save the device
        lhld    device$p
        mov     m, c
        mvi     a, 1
        sub     c
        jc      loc_19DB        ; jmp if not file device
        lxi     b, pn           ; lookup the file
        call    Search
        lxi     h, open_found
        mov     m, a
        dcx     h
        mov     c, m            ; c = aft
        call    SetTab          ; reset the pointers
        lda     open_found
        rrc
        jnc     loc_18ED        ; jmp if new file
        lxi     b, 2            ; check file isn't already open

loc_18B9:
        mvi     a, 6
        sub     c
        jc      loc_18ED
        lxi     h, closed
        dad     b
        mov     a, m
        cma
        rrc
        jnc     loc_18E9
        lxi     h, dnum
        dad     b
        lda     direct$ino      ; ino & device match then already open
        sub     m
        sui     1
        sbb     a
        mov     e, a
        lxi     h, device
        dad     b
        lda     pn
        sub     m
        sui     1
        sbb     a
        ana     e
        rrc
        push    b
        mvi     c, ALREADY$OPEN
        cc      RetUsr
        pop     b

loc_18E9:
        inr     c
        jnz     loc_18B9

loc_18ED:                               ; set the aft values from the directory lookup
        lda     direct$ino
        lhld    dnum$p          ; allocate data and link buffers
        mov     m, a
        call    GetBuf
        lhld    dbuf$p
        mov     m, a
        inx     h
        mov     m, b
        call    GetBuf
        lhld    lbuf$p
        mov     m, a
        inx     h
        mov     m, b
        lda     open_access
        dcr     a
        jnz     loc_1937        ; jmp if write access
        lda     open_found      ; if read and not found then error
        rrc
        mvi     c, NO$SUCH$FILE
        cnc     Free3
        lhld    direct$hdr$blk
        xchg
        lhld    l1Addr$p        ; set first link address
        mov     m, e
        inx     h
        mov     m, d
        lhld    direct$blk      ; and block count
        xchg
        lhld    blkCnt$p
        mov     m, e
        inx     h
        mov     m, d
        lda     direct$EOF$count ; and last sector size
        lhld    lastByte$p
        mov     m, a
        call    Rewind          ; set up rest of data to point at start of the file
        jmp     loc_1A32
; ---------------------------------------------------------------------------

loc_1937:                               ; if writing, check not write protected
        lda     open_found
        rrc
        jnc     loc_1956
        lda     direct$attrib
        ani     84h
        mvi     c, WRITE$PROTECT
        cnz     Free3
        lhld    device$p        ; delete the existing contents
        mov     c, m
        call    Scratch
        lxi     h, open_aft     ; reset the pointer info
        mov     c, m
        call    SetTab

loc_1956:                               ; check we didn't run out of directory space
        lda     direct$ino
        sui     0FFh
        mvi     c, DIRECTORY$FULL
        cz      Free3
        lxi     h, direct$attrib ; setup for initial zero size file
        mvi     m, 0            ; direct$attrib = 0
        inx     h
        mvi     m, 128          ; direct$eof$count = 128
        inx     h
        mvi     m, 0            ; direct$blk = 0
        inx     h
        mvi     m, 0
        lhld    device$p        ; allocate a sector for the header block
        mov     c, m
        call    Allocate
        lxi     h, direct$hdr$blk
        mov     m, a
        inx     h
        mov     m, b
        lhld    l1Addr$p        ; and set l1Addr$p to also point to it
        mov     m, a
        inx     h
        mov     m, b
        lxi     h, direct$empty ; update directory entry to say now used
        mvi     m, 0
        lxi     b, 0            ; copy the filename over

loc_1989:
        mvi     a, 8
        sub     c
        jc      loc_19A0
        lxi     h, direct$file
        dad     b
        xchg
        inx     b
        lxi     h, pn
        dad     b
        dcx     b
        mov     a, m
        stax    d
        inr     c
        jnz     loc_1989

loc_19A0:
        lhld    device$p
        mov     a, m
        sta     write_conn
        lxi     b, direct$empty ; write the directory entry
        lxi     d, 16
        call    Write           ; write the directory info
        call    Sync
        lxi     h, open_aft     ; get up aft pointers and rewind file
        mov     c, m
        call    SetTab
        call    Rewind
        lhld    lbuf$p          ; zero the link buffer
        mov     c, m
        inx     h
        mov     b, m
        call    ClrBuf
        call    RwMap           ; make sure bit map is loaded
        lhld    l1Addr$p        ; write the link buffer
        mov     c, m
        inx     h
        mov     b, m
        lhld    lbuf$p
        mov     e, m
        inx     h
        mov     d, m
        call    WrSec
        jmp     loc_1A32
; ---------------------------------------------------------------------------

loc_19DB:                               ; check for non file device already open
        lxi     b, 2

loc_19DE:
        mvi     a, 6
        sub     c
        jc      loc_1A02
        lxi     h, closed
        dad     b
        mov     a, m
        cma
        rrc
        jnc     loc_19FE
        lhld    device$p
        mov     a, m
        lxi     h, device
        dad     b
        sub     m
        push    b
        mvi     c, ALREADY$OPEN
        cz      RetUsr
        pop     b

loc_19FE:
        inr     c
        jnz     loc_19DE

loc_1A02:                               ; see if punch device
        lhld    device$p
        mov     a, m
        sui     TPDEV
        sbb     a
        cma
        mov     c, a
        mov     e, m
        mvi     a, P2DEV
        sub     e
        sbb     a
        cma
        ana     c
        rrc
        jnc     loc_1A32
        mvi     c, 120          ; write 120 null leader
        lhld    close$p
        mvi     m, 0

loc_1A1D:
        lda     open_aft
        sta     write_conn
        push    b
        lxi     b, open_zero
        lxi     d, 1
        call    Write
        pop     b
        dcr     c
        jnz     loc_1A1D

loc_1A32:
        lhld    close$p
        mvi     m, 0
        lda     open_aft        ; remove aft bias
        sui     2
        ret
; END OF FUNCTION CHUNK FOR Open
; ---------------------------------------------------------------------------
load_path:      dw 3130h        ; all below are junk filled
load_bias:      dw 4539h
load_retsw:     db 41h
load_entry$p:   dw 3030h
load_len:       dw 4630h
load_addr:      dw 3244h
load_actual:    dw 4546h
load_conn:      db 31h

; =============== S U B R O U T I N E =======================================


Load:
        lxi     h, load_retsw
        mov     m, c
        inx     h
        mov     m, e
        inx     h
        mov     m, d
        lhld    load_path
        mov     b, h
        mov     c, l
        mvi     e, RDMODE
        call    Open
        adi     2               ; convert to external conn
        sta     load_conn
        lxi     h, 1
        shld    load_len        ; force read of first record

loc_1A68:                               ; all done
        lhld    load_len
        mov     a, h
        ora     l
        jz      loc_1ACA
        lda     load_conn       ; read in the header
        sta     read_conn
        lxi     h, load_len
        shld    read_buffer
        lxi     b, 4            ; read length and address
        lxi     d, load_actual
        call    Read
        lhld    load_addr       ; adjust for user specified offset
        xchg
        lhld    load_bias
        dad     d
        shld    load_addr
        lxi     b, EndIS        ; check we are above ISIS itself
        lhld    load_addr
        mov     a, l
        sub     c
        mov     e, a
        mov     a, h
        sbb     b
        mvi     c, ISIS$OVERWRITE
        cc      Err
        lda     load_conn
        sta     read_conn
        lhld    load_addr
        shld    read_buffer
        lhld    load_len
        mov     c, l
        mov     b, h
        lxi     d, load_actual
        call    Read            ; read the actual data into memory
        lhld    load_actual     ; check we read all of the data
        mov     a, l
        mov     b, h
        lhld    load_len
        sub     l
        mov     a, b
        sbb     h
        mvi     c, BAD$LOAD$FORMAT
        cc      Err
        jmp     loc_1A68
; ---------------------------------------------------------------------------

loc_1ACA:                               ; close the file
        lxi     h, load_conn
        mov     c, m
        call    Close
        lda     load_retsw      ; check if just loading
        ora     a
        jnz     loc_1AE3
        lhld    load_addr
        xchg
        lhld    load_entry$p    ; save the found entry point
        mov     m, e
        inx     h
        mov     m, d
        ret
; ---------------------------------------------------------------------------

loc_1AE3:                               ; switch to user stack space
        lhld    usrsp
        sphl
        lda     load_retsw      ; switch == 1 ?
        dcr     a
        jnz     loc_1AF9
        lxi     h, debug        ; clear the debug flag
        mvi     m, 0
        inx     sp
        inx     sp
        lhld    load_addr       ; go execute
        pchl
; ---------------------------------------------------------------------------

loc_1AF9:                               ; code looks a little convoluted
        lxi     h, 0            ; pop h ; lhld entry; push h would be shorter
        dad     sp
        shld    load_entry$p    ; save the current stack
        lhld    load_addr       ; write the entry point at the top of the stack (i.e. return address)
        xchg
        lhld    load_entry$p
        mov     m, e
        inx     h
        mov     m, d
        lxi     h, debug        ; set debug flag
        mvi     m, 0FFh
        jmp     0               ; goto monitor
; End of function Load

; ---------------------------------------------------------------------------
isisCli:        db 'ISIS.CLI '

; =============== S U B R O U T I N E =======================================


Exit:
        mvi     c, 4            ; close files 4, 5, 6

loc_1B1D:
        mvi     a, 6
        sub     c
        jc      loc_1B2C
        push    b
        call    Close
        pop     b
        inr     c
        jnz     loc_1B1D

loc_1B2C:
        lxi     h, mapChange
        mvi     m, 0
        lxi     h, mapDCB + IOINS
        mvi     m, 6
        lxi     h, mapDrv
        mvi     m, 0FFh
        lxi     h, isisCli      ; "ISIS.CLI "
        shld    load_path
        lxi     h, 0
        shld    load_bias
        mvi     c, 1
        lxi     d, 0
        call    Load            ; continue with ISIS.CLI
        ret
; End of function Exit

; ---------------------------------------------------------------------------
bootload: db 80h, DCMD$READ, 26, 0, 1
        dw 3000h               ; boot memory location
; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR Err

Reboot:                                 ; reset stack
        lxi     h, rbyte
        sphl
        mvi     c, 2            ; close files 2 - 6

loc_1B5D:
        mvi     a, 6
        sub     c
        jc      loc_1B6C
        push    b
        call    Close
        pop     b
        inr     c
        jnz     loc_1B5D

loc_1B6C:
        mvi     c, 0
        lxi     d, bootload
        call    Xeqiopb
        jmp     3000h
; END OF FUNCTION CHUNK FOR Err
; ---------------------------------------------------------------------------
EndIS:
        db 'C602324A1A21010022441A2A441AC0', 0Dh, 0Ah, 7Fh
        db ' :101A6B007CB5CACA1A3A4A1A32AD0F21441A22AEB1', 0Dh, 0Ah, 7Fh
        db ' :101A7B000F01040011481ACDB40F2A461AEB2A3F66', 0Dh, 0Ah, 7Fh
        db ' :101A8B00'
        end 0

isis.cli.plm
/*
    THE SOURCE BELOW NEEDS TO BE COMPILED WITH THE FORTRAN CROSS COMPILER
    UNFORTUNATELY INTEL SEEM TO HAVE USED A LATER VERSION THAT SUPPORTED
    'AT' AND DID NOT FILL UNINITIALISED DATA WITH ZEROS

*/
1C00H: DO; 
    DECLARE BOOLEAN LITERALLY 'BYTE';
    DECLARE TRUE    LITERALLY '0FFH';
    DECLARE FALSE   LITERALLY '0';
    DECLARE CR  LITERALLY '0DH',
            LF  LITERALLY '0AH';

    DECLARE BTSTRP LITERALLY '8';
    DECLARE MDSMON LITERALLY '0';

    DECLARE CVER DATA(1, 13H);     /* ISIS.CLI VERSION ? */
    DECLARE COPYRIGHT DATA('COPYRIGHT (C) INTEL 1975,1976');

    ISIS: PROCEDURE(CMD, PARAM$P);
        DECLARE CMD BYTE, PARAM$P ADDRESS;
        GOTO 40H;
    END ISIS;

    READ: PROCEDURE(CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P) ADDRESS;

        CALL ISIS(3, .CONN);
    END;

    WRITE: PROCEDURE(CONN, BUFF$P, COUNT, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, STATUS$P) ADDRESS;

        CALL ISIS(4, .CONN);
    END;


    LOAD: PROCEDURE(PATH$P, LOAD$OFFSET, RETSW, ENTRY$P, STATUS$P);
        DECLARE (PATH$P, LOAD$OFFSET, RETSW, ENTRY$P, STATUS$P) ADDRESS;

        CALL ISIS(6, .PATH$P);
    END;
    
    RESCAN: PROCEDURE(CONN, STATUS$P);
        DECLARE (CONN, STATUS$P) ADDRESS;

        CALL ISIS(11, .CONN);
    END;

    ERROR: PROCEDURE(ERROR$NUM);
        DECLARE (ERROR$NUM, STATUS) ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(12, .ERROR$NUM);
    END;

    EXIT: PROCEDURE;
        DECLARE STATUS ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(9, .STATUS);
    END;

    DEBLANK: PROCEDURE(PTR) ADDRESS;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE (C = ' ');
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;

    DELIMIT: PROCEDURE(PTR) ADDRESS;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE (C = ':' OR C = '.' OR
                 ('0' <= C AND C <= '9') OR
                 ('A' <= C AND C <= 'Z'));
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;

    MEMCK: PROCEDURE ADDRESS;
        GOTO 0F81BH;
    END;


    SEQ: PROCEDURE(S1, S2, CNT) BYTE;
        DECLARE (S1,S2) ADDRESS, CNT BYTE;
        DECLARE S1A BASED S1(1) BYTE;
        DECLARE S2A BASED S2(1) BYTE;
        DECLARE I BYTE;
        CNT = CNT - 1;
        DO I = 0 TO CNT;
            IF S1A(I) <> S2A(I) THEN
                RETURN 0;
        END;
        RETURN 0FFH;
    END;

    /* NOT ACTUALLY USED */
    NUMOUT: PROCEDURE(VALUE, BASE, LC, BUFADR, WIDTH);
        DECLARE (VALUE, BUFADR) ADDRESS, (BASE, LC, WIDTH) BYTE; 
        DECLARE DIGITS DATA('0123456789ABCDEF');
        DECLARE I BYTE;
        DECLARE BUF BASED BUFADR (1) BYTE;

        DO I = 1 TO WIDTH;
            BUF(WIDTH - I) = DIGITS(VALUE MOD BASE);
            VALUE = VALUE / BASE;   
        END;

        I = 0;
        DO WHILE BUF(I) = '0' AND I < WIDTH - 1;
            BUF(I) = LC;
            I = I + 1;
        END;
    END;

    REPORTERROR: PROCEDURE(ERRNUM);
        DECLARE ERRNUM ADDRESS;
        DECLARE NUMBERBUFFER(3) BYTE, I ADDRESS, STATUS ADDRESS;
     

        DECLARE ERRMSG DATA(0, 0,
            2, 'ILLEGAL AFTN ARGUMENT', 0,
            4, 'INCORRECTLY SPECIFIED FILE', 0,
            5, 'UNRECOGNIZED DEVICE NAME', 0,
            6, 'ATTEMPT TO WRITE TO INPUT DEVICE', 0,
            8, 'ATTEMPT TO READ FROM OUTPUT DEVICE', 0,
            9, 'DIRECTORY FULL', 0,
            0AH, 'NOT ON SAME DISK', 0,
            0BH, 'FILE ALREADY EXISTS', 0,
            0CH, 'FILE IS ALREADY OPEN', 0,
            0DH, 'NO SUCH FILE', 0,
            0EH, 'WRITE PROTECTED', 0,
            0FH, 'LOAD TOO LOW', 0,
            10H, 'BAD LOAD FORMAT', 0,
            11H, 'NOT A DISK FILE', 0,
            12H, 'ILLEGAL ISIS COMMAND', 0,
            13H, 'ATTEMPTED SEEK ON NON-DISK FILE', 0,
            14H, 'ATTEMPTED BACK SEEK TO FAR', 0,
            16H, 'ILLEGAL ACCESS MODE TO OPEN', 0,
            17H, 'MISSING FILENAME', 0,
            19H, 'ILLEGAL ECHO FILE', 0,
            1AH, 'ILLEGAL ATTRIBUTE IDENTIFIER', 0,
            1BH, 'ILLEGAL SEEK COMMAND', 0,
            1CH, 'MISSING EXTENSION', 0,
            1FH, 'CAN', 27H, 'T SEEK ON WRITE ONLY FILE', 0,
            20H, 'CAN', 27H, 'T DELETE OPEN FILE', 0,
            23H, 'SEEK PAST EOF', 0,
            0C9H, 'UNRECOGNIZED SWITCH', 0,
            0CAH, 'UNRECOGNIZED DELIMITER', 0,
            0CBH, 'INVALID SYNTAX', 0,
            0CCH, 'PREMATURE EOF', 0,
            0CEH, 'ILLEGAL DISKETTE LABEL', 0,
            0D0H, 'CHECKSUM ERROR', 0
        );



        IF ERRNUM <> 0 THEN
        DO;
            I = 0;
            DO WHILE I < LENGTH(ERRMSG);
                IF ERRNUM = ERRMSG(I) AND ERRMSG(I + 1) <> 0 THEN
                DO;
                    I = I + 1;
                    CALL WRITE(0, .(' '), 1, .STATUS);
                    DO WHILE ERRMSG(I) <> 0;
                        CALL WRITE(0, .ERRMSG(I), 1, .STATUS);
                        I = I + 1;
                    END;
                    CALL WRITE(0, .(0DH, 0AH), 2, .STATUS);
                    return;
                END;
                ELSE
                DO;
                    DO WHILE ERRMSG(I) <> 0;
                        I = I + 1;
                    END;
                    I = I + 1;
                END;
            end;
            CALL ERROR(ERRNUM);
        END;
    END;


    FILE$ERROR: PROCEDURE(STATUS, PTR, CALLEXIT);
        DECLARE (STATUS, PTR) ADDRESS, CALLEXIT BYTE;
        DECLARE ERR$STATUS ADDRESS;

        IF STATUS <> 0 THEN
        DO;
            PTR = DEBLANK(PTR);
            CALL WRITE(0, .(' '), 1, .ERR$STATUS);
            CALL WRITE(0, PTR, DELIMIT(PTR) - PTR, .ERR$STATUS);
            CALL WRITE(0, .(','), 1, .ERR$STATUS);
            CALL REPORTERROR(STATUS);
            IF CALLEXIT THEN
                CALL EXIT;
        END;
    END;

MAIN:

    DECLARE BUFFER(128) BYTE;
    DECLARE DEBUG BOOLEAN;
    DECLARE BUFFER$PTR ADDRESS, CHAR BASED BUFFER$PTR BYTE;
    DECLARE (PATHNAME$PTR,ACTUAL,STATUS,ENTRY,RETSW) ADDRESS;
    DECLARE TOPSTACK ADDRESS, STACKWORD BASED TOPSTACK ADDRESS;


    STACKPTR = MEMCK;
    OUTPUT(0FCH) = 0FCH; /* ENABLE CONSOLE INTERRUPTS 0 AHD 1 */
    ENABLE;
    OUTPUT(0FDH) = 20H; /* SEND END OF INTERRUPT COMMAND */
    BUFFER$PTR = .(':CI: ');
    CALL RESCAN(1,.STATUS);
    IF STATUS = 0 THEN
    DO;
      CALL READ(1,.BUFFER,LENGTH(BUFFER),.ACTUAL,.STATUS);
      CALL FILE$ERROR(STATUS,BUFFER$PTR,TRUE);
    END;
    DO WHILE TRUE;
      CALL WRITE(0,.('-'),1,.STATUS);
      CALL REPORTERROR(STATUS);
      CALL READ(1,.BUFFER,LENGTH(BUFFER),.ACTUAL,.STATUS);
      CALL FILE$ERROR(STATUS,BUFFER$PTR,TRUE);
      BUFFER(ACTUAL) = CR;
      BUFFER$PTR = DEBLANK(.BUFFER);
      IF CHAR <> CR THEN
      DO;
        /* NOW CHECK FDR DEBUG MODE (PATHNAHE PRECEDED BY 'DEBUG' */
        DEBUG = FALSE; /* ASSUME NORMAL CASE, NOT DEBUGGING */
        IF SEQ(.('DEBUG'),BUFFER$PTR,5)
        AND (DELIMIT(BUFFER$PTR)=BUFFER$PTR+5) THEN
        DO;
          BUFFER$PTR = DEBLANK(DELIMIT(BUFFER$PTR+5));
          DEBUG = TRUE;
          IF CHAR = CR THEN DO;
            TOPSTACK = STACKPTR;
            STACKWORD = BTSTRP;
            GOTO MDSMON;
          END;
        END;
        PATHNAME$PTR = BUFFER$PTR;
        BUFFER$PTR = DELIMIT(DEBLANK(BUFFER$PTR));
        CALL RESCAN(1,.STATUS);
        CALL REPORTERROR(STATUS);
        CALL READ(1,.BUFFER,BUFFER$PTR-.BUFFER,.ACTUAL,.STATUS);
        CALL REPORTERROR(STATUS);
        IF DEBUG THEN RETSW = 2; ELSE RETSW = 1;
        CALL LOAD(PATHNAME$PTR,0,RETSW,.ENTRY,.STATUS);
        CALL FILE$ERROR(STATUS,PATHNAME$PTR,FALSE);
        CALL READ(1,.BUFFER,LENGTH(BUFFER),.ACTUAL,.STATUS);
        CALL REPORTERROR(STATUS);
      END;
    END;
END;
EOF
isis.t0.plm
/*
    THE SOURCE BELOW NEEDS TO BE COMPILED WITH THE FORTRAN CROSS COMPILER
    UNFORTUNATELY INTEL SEEM TO HAVE USED A LATER VERSION THAT SUPPORTED
    'AT' AND DID NOT FILL UNINITIALISED DATA WITH ZEROS

    THE PERL ROUTINE LOADANDFIX.PL LOADS THE HEX FILE CREATED, 
    AND REPLACES UNITIALISED AND DATA PAST MEMORY WITH THE
    BYTES IN THE ORIGINAL ISIS.T0 FILE
*/
3000H: DO; 

    DECLARE BOOLEAN LITERALLY 'BYTE';
    DECLARE TRUE    LITERALLY '0FFH';
    DECLARE CMSK    LITERALLY '0FCH';
    DECLARE CR  LITERALLY '0DH',
            LF  LITERALLY '0AH';

    DECLARE T0VER DATA(1, 19H);     /* ISIS.T0 VERSION ? */
    DECLARE COPYRIGHT DATA('COPYRIGHT (C) INTEL 1975,1976');

    DECLARE VERSION$LEVEL   LITERALLY   'BYTE$AT(3EH)',
            EDIT$LEVEL      LITERALLY   'BYTE$AT(3FH)';

    DECLARE (USER$STATUS, USER$STACKPTR, START$ADDR) ADDRESS;
    DECLARE A$DEVICE BYTE;
    DECLARE MEMBASE ADDRESS INITIAL(0);
    DECLARE BYTE$AT BASED MEMBASE (1) BYTE;

    DECLARE TEMP BYTE;
    DECLARE ISIS$SIGNON(13) BYTE INITIAL(CR, LF, '16K ISIS, V'),
            SIGN$V(2) BYTE INITIAL(0, 0), /* VERSION NUMBER */
            SIGN$DOT(1) BYTE INITIAL('.'),
            SIGN$E(2) BYTE INITIAL(0, 0),  /* EDIT NUMBER */
            SIGN$CRLF(2) BYTE INITIAL (CR, LF);


    ISIS: PROCEDURE(CMD, PARAM$P);
        DECLARE CMD BYTE, PARAM$P ADDRESS;
        GOTO 40H;
    END ISIS;

    READ: PROCEDURE(CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P) ADDRESS;

        CALL ISIS(3, .CONN);
    END;

    WRITE: PROCEDURE(CONN, BUFF$P, COUNT, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, STATUS$P) ADDRESS;

        CALL ISIS(4, .CONN);
    END;

    EXIT: PROCEDURE;
        DECLARE STATUS ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(9, .STATUS);
    END;

    NUMOUT: PROCEDURE(VALUE, BASE, LC, BUFADR, WIDTH);
        DECLARE (VALUE, BUFADR) ADDRESS, (BASE, LC, WIDTH) BYTE; 
        DECLARE DIGITS DATA('0123456789ABCDEF');
        DECLARE I BYTE;
        DECLARE BUF BASED BUFADR (1) BYTE;

        DO I = 1 TO WIDTH;
            BUF(WIDTH - I) = DIGITS(VALUE MOD BASE);
            VALUE = VALUE / BASE;   
        END;

        I = 0;
        DO WHILE BUF(I) = '0' AND I < WIDTH - 1;
            BUF(I) = LC;
            I = I + 1;
        END;
    END;



    /* THE FOLLOWING VARIABLES ARE USED IN THE ERR PROCEDURE */
    DECLARE FDCC$ERROR$TYPE(0) ADDRESS, (FDCC$ERROR$LOW, FDCC$ERROR$HIGH) BYTE;
                                    /* HAS DATA ON DISK I/O ERRORS */
    DECLARE JUNK ADDRESS INITIAL(0);
    DECLARE ABORT BYTE INITIAL(0FFH);   /* TRUE IF ABORT ON ERR */
    DECLARE DEBUG$TOGGLE BOOLEAN;   /* GOVERNES ACTION WHEN ERROR OCCURS */

    /* USEFUL LITERALS */
    DECLARE WARNING LITERALLY '0',
            MESSAGE LITERALLY '1';

    DECLARE DISK$IO$ERROR   LITERALLY   '18H',
            DRIVE$NOT$READY LITERALLY   '1EH';

    DECLARE ISIS$HDR$BLK LITERALLY   '204H';


    DECLARE RTC LITERALLY '0FFH';   /* REAL TIME CLOCK */
    DECLARE BOOT LITERALLY '2';
    /* INPUT FROM RTC IS A BYTE. THE SECOND BIT FROM THE RIGHT
       CORRESPONDS TO THE BOOT SWITCH. IF THIS BIT IS 1 THE SWITCH IS
       ON, AND IF IT IS 0 THE  SWITCH IS OFF.
    */

    DECLARE MDSMON  LITERALLY   '0',
            BTSTRP  LITERALLY   '8';


    CI: PROCEDURE BYTE;
        GOTO 0F803H;
    END;

    RI: PROCEDURE BYTE;
        GOTO 0F806H;
    END;

    CO: PROCEDURE(C);
        DECLARE C BYTE;
        GOTO 0F809H;
    END;

    PO: PROCEDURE(C);
        DECLARE C BYTE;
        GOTO 0F80CH;
    END;

    LO: PROCEDURE(C);
        DECLARE C BYTE;
        GOTO 0F80FH;
    END;

    IOCHK: PROCEDURE BYTE;
        GOTO 0F815H;
    END;

    IOSET: PROCEDURE(C);
        DECLARE C BYTE;
        GOTO 0F818H;
    END;


    
    DECLARE INITIO$BASE ADDRESS INITIAL(6), INITIO BASED INITIO$BASE BYTE;

    HEXOUT: PROCEDURE(VALUE, BUFADR, WIDTH);
        DECLARE (VALUE, BUFADR) ADDRESS, WIDTH BYTE;
        DECLARE CH BASED BUFADR BYTE;
        DECLARE DIGITS(16) BYTE INITIAL('0123456789ABCDEF');

        BUFADR = BUFADR + WIDTH;
        DO WHILE WIDTH <> 0;
            WIDTH = WIDTH - 1;
            BUFADR = BUFADR - 1;
            CH = DIGITS(VALUE AND 0FH);
            VALUE = SHR(VALUE, 4); 
        END;
    END;

    SETDEV: PROCEDURE;
        CALL IOSET((IOCHK AND CMSK) OR (INITIO AND 3));
    END;

    /*
       THE ERR PROCEDURE IS USED TO HANDLE ERROR CONDIITONS.
           AN ERROR MESSAGE IS ISSUED TO THE CONSOLE, WHICH FOR
           DISK ERRORS HAS EXTENDED CONTENT
       CONTROL THEN PASSES TO THE MDS MONITOR

       ERROR$TYPE IS THE ERROR NUMBER WHICH IDENTIFIES THE PARTICUALAR
              TYPE OF ERROR, SUCH AS DISK I/O ERROR
    */

    ERR: PROCEDURE(ERROR$TYPE);
        DECLARE ERROR$TYPE BYTE;
        DECLARE PC BASED USER$STACK$PTR ADDRESS;
        DECLARE I BYTE INITIAL(0);
        DECLARE IMAX BYTE INITIAL(25);
        DECLARE MSG1(8) BYTE INITIAL(CR, LF, 'ERROR '),
                MSG2(3) BYTE INITIAL(0, 0, 0),     /* ERROR NUMBER GOES HERE */
                MSG3(9) BYTE INITIAL(' USER PC '),
                MSG4(4) BYTE INITIAL(0, 0, 0, 0),  /* USER PC IN HEX GOES HERE */
                MSG5(2) BYTE INITIAL(CR, LF),
                MSG6(5) BYTE INITIAL('FDCC='),
                MSG7(4) BYTE INITIAL(0, 0, 0, 0), /* FDCC ERROR DATA GOES HERE */
                MSG8(2) BYTE INITIAL(CR, LF);

        CALL HEXOUT(ERROR$TYPE, .MSG2, 3);
        CALL HEXOUT(PC,.MSG4,4);
        CALL SETDEV;

        IF ERROR$TYPE = DISK$IO$ERROR THEN DO;
            IMAX = 36;
            CALL HEXOUT(FDCC$ERROR$TYPE, .MSG7, 4);
        END;

        DO I = 0 TO IMAX;
            CALL CO(MSG1(I));
        END;
        
        IF NOT ABORT THEN
            RETURN;
        IF DEBUG$TOGGLE THEN
            GOTO MDSMON;    /* EXIT VIA MONITOR */
        GOTO BTSTRP;        /* EXIT VIA SOFTWARE BOOTSTRAP */
    END;

    RETUSER: PROCEDURE(ERROR$TYPE);     /* NOT CALLED */
        DECLARE ERROR$TYPE BYTE;

        USER$STATUS = ERROR$TYPE;
        STACKPTR = USER$STACK$PTR;
    END;

    /*
       DISKIO PROVIDES ACCESS TO THE FDCC
       CONTROLLER 1 = BASE ADDRESS 78H (DRIVES 0, 1 FOR SD)
       CONTROLLER 2 = BASE ADDRESS 88H (DRIVES 2, 3 FOR SD)

       DRIVE: AN INTEGER 0-3, SPECIFYING THE DISK TO BE ACCESSED
       IOPB:  THE ADDRESS OF A PARAMETER BLOCK TO BE SENT TO THE
          FDCC CONTROLLER. THIS PARAMETER MUST BE SET UP
          AS IF IT WERE FOR DRIVE 0; IF 'DRIVE' SELECTS
          ANOTHER DRIVE, 'DISKIO' WILL SET ALL THE NECESSARY
          BITS

       THE CALLER PROVIDES A PARAMETER BLOCK SPECIFYING SOME
       VALID DISK OPERATION ON DRIVE 0 AND AN INTEGER DRIVE SELECT VALUE
       IN THIS BOOT CODE ONLY READ AND RECAL ARE USED
       THE PROCEDURE WAITS FOR THE CONTROLLER TO GO UNBUSY, THEN
       PERFORMS THE DESIRED ACTION. IN CASE OF A CONTROLLER ERROR,
       THE DISK DRIVE IS RECALIBRATED AND THE ACTION IS TRIED AGAIN.
       IF SUCCESSFUL COMPLETION CANNOT BE OBTAINED AFTER 'MAX$RETRIES'
       ATTEMPTS, A FATAL ERROR OCCURS, OTHERWISE A NORMAL RETURN IS MADE

    */
        DECLARE FDCC$STATUS   LITERALLY   '78H',
                RESULT$TYPE   LITERALLY   '79H',
                RESULT$BYTE   LITERALLY   '7BH',
                LOW$ADDRESS   LITERALLY   '79H',
                HIGH$ADDRESS  LITERALLY   '7AH';

        DECLARE MAX$RETRIES     LITERALLY   '10',
                DISK$DONE       LITERALLY   '4',
                READ$COMMAND    LITERALLY   '4',
                WRITE$COMMAND   LITERALLY   '6',
                RECALIBRATE     LITERALLY   '3';

        DECLARE IOCW    LITERALLY '0',
                IOINS   LITERALLY '1',
                NSEC    LITERALLY '2',
                TADR    LITERALLY '3',
                SADR    LITERALLY '4',
                BUFLO   LITERALLY '5',
                BUFHI   LITERALLY '6';


    DISKIO: PROCEDURE(DRIVE, IOPB);
        /* THIS PROCEDURE ISSUES THE IOPB TO THE DISK CONTROLLER, IN THE */
        /* CASE OF THE 8271 IT ALSO TRANSFERS THE DATA ON A BYTE BY BYTE BASIS */
        DECLARE DRIVE BYTE; /* DRIVE NUMBER: ASSUMES VALUE 0,1 */
        DECLARE IOPB ADDRESS;   /* POINTER TO THE PARAMATER BLOCK NAMED DCB */
        DECLARE DCB BASED IOPB (7) BYTE; 


        /* RECALIBRATE COMMAND */
        DECLARE RECAL$PB(5) BYTE INITIAL(80H, RECALIBRATE, 0, 0, 0);
        DECLARE I BYTE;     /* RETRY COUNTER */

        DISABLE;
        RECAL$PB(IOINS) = RECALIBRATE;
        RECAL$PB(SADR) = 0;
        IF DRIVE THEN
        DO;
            RECAL$PB(IOINS) = RECALIBRATE OR 30H; 
            RECAL$PB(SADR) = 20H;
            DCB(IOINS) = DCB(IOINS) OR 30H;
            DCB(SADR) = DCB(SADR) OR 20H;
        END;
        
        I = MAX$RETRIES;
        DO WHILE I <> 0;
            I = I - 1;
        
            DO WHILE (INPUT(FDCC$STATUS) AND DISK$DONE) <> 0;
                FDCC$ERROR$HIGH = INPUT(RESULT$TYPE);
                FDCC$ERROR$LOW = INPUT(RESULT$BYTE);
            END;
            /* IF DISK DRIVE NOT READY, GIVE FATAL ERROR */
            IF (INPUT(FDCC$STATUS) AND (DRIVE + 1)) = 0 THEN
                CALL ERR(DRIVE$NOT$READY);

            /* START THE IO OPERATION */
            OUTPUT(LOW$ADDRESS) = LOW(IOPB);
            OUTPUT(HIGH$ADDRESS) = HIGH(IOPB);

            DO WHILE (INPUT(FDCC$STATUS) AND DISK$DONE) = 0; 
                ;
            END;
            FDCC$ERROR$HIGH = INPUT(RESULT$TYPE);

            IF (FDCC$ERROR$LOW := INPUT(RESULT$BYTE)) = 0 THEN
            DO;
                ENABLE;
                RETURN;
            END;
            /* DO A RECALIBRATION */
            OUTPUT(LOW$ADDRESS) = LOW(.RECAL$PB);
            OUTPUT(HIGH$ADDRESS) = HIGH(.RECAL$PB);

            DO WHILE (INPUT(FDCC$STATUS) AND DISK$DONE) = 0; 
                ;
            END;
        END;
        CALL ERR(DISK$IO$ERROR);
        
    END;


    /*
     ASBIO: ACCOMPLISHES THE TRANSFER OF 128 BYTES OF DATA FROM THE DISK 
       COMMAND  MUST BE THE NUMERIC VALUE OF THE FDCC COMMAND
                DESIRED. (LITERALS 'READ$COMMAND' AND 'WRITE$COMMAND'
                EXIST FOR THE COMMON OPERATIONS.)
       DISK     THE DRIVE FROM WHICH TO READ
       BLOCK    DISKETTE BLOCK NUMBER, A TRACK NUMBER (0-76)
                IN THE HIGH ORDER 8 BITS AND A SECTORE NUMBER (1-26)
                IN THE LOW ORDER 8 BITS
       BUFFER$PTR   THE ADDRESS OF A 128 BYTE BUFFER IN RAM
    */
    ABSIO: PROCEDURE (COMMAND, DISK, BLOCK, BUFFER$PTR);
        DECLARE (COMMAND, DISK) BYTE, (BLOCK, BUFFER$PTR) ADDRESS;
        /* VALUE OF 'DISK'  MUST BE 0 - 1 */
        DECLARE DCB BYTE INITIAL(80H);
        DECLARE DCBINST(9) BYTE;
        DECLARE IOPTR ADDRESS;
        DECLARE IOBYTE BASED IOPTR BYTE, IOWORD BASED IOPTR ADDRESS;

        IOPTR = .DCBINST;

        IOBYTE = COMMAND;
        IOPTR = IOPTR + 1;
        IOBYTE = 1;     /* IF THIS VALUE CHANGES IN THE FUTURE, */
                        /* THE 8271 DRIVER MUST BE CHANGED */
        IOPTR = IOPTR + 1;
        IOBYTE = HIGH(BLOCK);
        IOPTR = IOPTR + 1;
        IOBYTE = LOW(BLOCK);
        IOPTR = IOPTR + 1;
        IOWORD = BUFFER$PTR;
        CALL DISKIO(DISK, .DCB);
    END;

    ABS$READ: PROCEDURE(BLOCK, BUFFER);
        DECLARE (BLOCK, BUFFER) ADDRESS;

        CALL ABSIO(READ$COMMAND, A$DEVICE, BLOCK, BUFFER);
    END;

    ABS$WRITE: PROCEDURE(BLOCK, BUFFER);
        DECLARE (BLOCK, BUFFER) ADDRESS;

       CALL ABSIO(WRITE$COMMAND, A$DEVICE, BLOCK, BUFFER);
    END;

    /*

        ALDADR LOADS THE ABSOLUTE ISIS FILE INTO MEMORY
        HDRBLK - LOCATION OF ISIS FILE

        RETURNS - ADDRESS WHERE FILE IS LOADED
        THE FORMAT OF THE FILE IS BASICALLY THE CONTENT RECORDS
        FROM AN NORMAL ISIS EXECUTABLE WITH THE RECORD TYPE, SEGMENT ID AND CRC REMOVED
    */

    ALDADR: PROCEDURE(HDRBLK) ADDRESS;
        /* LOAD INTO MEMORY THE ABS LOAD FILE AT 'HDRBLK' */
        DECLARE HDRBLK ADDRESS;
        DECLARE BUF(128) BYTE, BUFPTR BYTE;
        DECLARE POINTERS(64) ADDRESS, PTRPTR BYTE;
        DECLARE LOADADR ADDRESS, TARGET BASED LOADADR BYTE;
        DECLARE LENGTH ADDRESS;

        DECLARE FLINK   LITERALLY   '1';    /* INDEXES INTO THE POINTERS ARRAY */

        L1B: PROCEDURE; /* LOAD 1 BYTE FROM BUFFER INTO MEMORY */
            TARGET = BUF(BUFPTR);   
            BUFPTR = BUFPTR + 1;
            LENGTH = LENGTH - 1;
            LOADADR = LOADADR + 1;
        END;

        G128B: PROCEDURE(BUFADR); /* GET 128 BYTES INTO BUFFER AT BUFADR */
            DECLARE BUFADR ADDRESS;

            IF (PTRPTR := PTRPTR + 1) = 64 THEN
            DO;
                IF POINTERS(FLINK) = 0 THEN
                    GOTO MDSMON;
                CALL ABSIO(READ$COMMAND, 0, POINTERS(FLINK), .POINTERS);
                PTRPTR = 2;
            END;
            IF POINTERS(PTRPTR) = 0 THEN
                GOTO MDSMON;
            CALL ABSIO(READ$COMMAND, 0, POINTERS(PTRPTR), BUFADR);
        END;

        G1B: PROCEDURE BYTE;    /* GET 1 BYTE */
            IF (BUFPTR AND 7FH) = 0 THEN
            DO;
                CALL G128B(.BUF);
                BUFPTR = 0;
            END;    
            BUFPTR = BUFPTR + 1;
            RETURN BUF(BUFPTR - 1);
        END;

        G2B: PROCEDURE ADDRESS; /* GET 2 BYTES */
            RETURN G1B + (256 * G1B);
        END;




        POINTERS(FLINK) = HDRBLK;   /* INITIALISZE G128B */
        PTRPTR = 63;
        BUFPTR = 0;

    START$LOADING$NEXT$RECORD:
        DO WHILE TRUE;
            LENGTH = G2B;
            LOADADR = G2B;
            IF LENGTH = 0 THEN
                RETURN LOADADR;
            DO WHILE BUFPTR <> 128;
                IF LENGTH > 0 THEN
                    CALL L1B;
                ELSE
                    GOTO START$LOADING$NEXT$RECORD;
            END;
            DO WHILE LENGTH >= 128;
                CALL G128B(LOADADR);
                LOADADR = LOADADR + 128;
                LENGTH = LENGTH - 128;
            END;
            
            BUFPTR = 0;
            IF LENGTH <> 0 THEN DO;
                CALL G128B(.BUF);
                DO WHILE LENGTH > 0;
                    CALL L1B;
                END;
            END;
        END;
        /* CANNOT REACH HERE !! */
    END; 


    T0BOOT:
    TEMP = INPUT(RESULT$TYPE);
    TEMP = INPUT(RESULT$BYTE);
    ENABLE;
    DO WHILE (INPUT(RTC) AND BOOT) <> 0;
        ;
    END;
    DEBUG$TOGGLE = TRUE;
    START$ADDR = ALDADR(ISIS$HDR$BLK);
    IF START$ADDR <> 0 THEN
        GOTO START$ADDR;

    CALL NUMOUT(VERSION$LEVEL, 16, 0, .SIGN$V, 2);
    CALL NUMOUT(EDIT$LEVEL, 16, 0, .SIGN$E, 2);
    CALL WRITE(0, .ISIS$SIGNON, 20, .USERSTATUS);
    CALL EXIT;


END;
EOF;
isis.t0_1.1.patch
3628 39
362A 39
362C 39
362E 39
3630 39
3632 39
3634 39
3636 39
3638 39
363A 39
363C 39
363E 39
3640 39
3642 39
3644 39
3646 39
3648 39
364A 39
364C 39
364E 39
APPEND
00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
00 39 00 39 00 39 00 39 00 39 00 39 FF 39 00 39 00 39 00 39 00
39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
39 00 39 00 39 00 39 00 39 00 39 00 39 FF 39 00 39 00 39 00 39
00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
00 39 00 39 00 39 00 39 00 39 00 39 00 39 FF 39 00 39 00 39 00
39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 FF 39 00 39 00 39
00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 FF 39 00 39 00
39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 FF 39 00 39
00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 FF 39 00
39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 FF 39
00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 FF
39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
FF 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
39 FF 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
00 39 FF 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
39 00 39 FF 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
00 39 00 39 FF 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
39 00 39 00 39 FF 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
00 39 00 39 00 39 FF 39 00 39 00 39 00 39 00 39 00 39 00 39 00
39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
39 00 39 00 39 00 39 FF 39 00 39 00 39 00 39 00 39 00 39 00 39
00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00
39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
00 39 00 39 00 39 00 39 FF 39 00 39 00 39 00 39 00 39 00 39 00
39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39 00 39
00 39 00 39 00 39 00
makefile
# path to root of build tree
ROOT := ../..
TARGETS := format delete isis.cli attrib dir rename copy hexbin\
   		   isis.t0 isis.bin edit as80

include $(ROOT)/tools/isis.mk

REF = $(call ipath,isis,1.1)
ISIST0PATCH = isis.t0_1.1.patch
PROTECT = $(ISIST0PATCH)

all:: $(TARGETS)

%.omf: %.hex
	$(HEXOBJ) $^ $@

% : %.omf
	$(OBJBIN) -i $^ $@

isis.t0: isis.t0.omf $(ISIST0PATCH)
	$(OBJBIN) $^ $@

# isis.bin is in assembler, creating the standard .obj output
isis.bin: isis.obj
	$(OBJBIN) -i $^ $@


%.hex %.lst %.prn: %.plm
	$(PLM81) $^
	$(PLM82) $^
	@perl $(ROOT)/tools/pretty.pl $*.lst $*.prn
	@rm -fr $*.pol $*.sym

clean::
	rm -fr *.hex *.prn *.lst *.obj *.omf
rename.plm
1C00H:
DO;
    DECLARE TRUE    LITERALLY '0FFH',
            FALSE   LITERALLY '0',
            CR      LITERALLY '0DH',
            LF      LITERALLY '0AH';

    DECLARE VER DATA(1, 11H);
    DECLARE COPYRIGNT DATA('COPYRIGHT (C) INTEL 1975,1976');

    ISIS: PROCEDURE(CMD, PARAM$P);
        DECLARE CMD BYTE, PARAM$P ADDRESS;
        GOTO 40H;
    END ISIS;

    READ: PROCEDURE(CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P) ADDRESS;

        CALL ISIS(3, .CONN);
    END;

    WRITE: PROCEDURE(CONN, BUFF$P, COUNT, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, STATUS$P) ADDRESS;

        CALL ISIS(4, .CONN);
    END;

	RENAME: PROCEDURE(OLD$P, NEW$P, STATUS$P);
    	DECLARE (OLD$P, NEW$P, STATUS$P) ADDRESS;
    	
    	CALL ISIS(7, .OLD$P);
	END;

    ERROR: PROCEDURE(ERROR$NUM);
        DECLARE (ERROR$NUM, STATUS) ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(12, .ERROR$NUM);
    END;

    EXIT: PROCEDURE;
        DECLARE STATUS ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(9, .STATUS);
    END;

    DELETE: PROCEDURE (PATH$P, STATUS$P);
        DECLARE (PATH$P, STATUS$P) ADDRESS;

        CALL ISIS(2, .PATH$P);
    END DELETE;

    DEBLANK: PROCEDURE(PTR) ADDRESS;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE (C = ' ');
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;

    DELIMIT: PROCEDURE(PTR) ADDRESS;
        DECLARE PTR ADDRESS;
        DECLARE C BASED PTR BYTE;

        DO WHILE (C = ':' OR C = '.' OR
                 ('0' <= C AND C <= '9') OR
                 ('A' <= C AND C <= 'Z'));
            PTR = PTR + 1;
        END;
        RETURN PTR;
    END;

    SEQ: PROCEDURE(S1, S2, CNT) BYTE;
        DECLARE (S1,S2) ADDRESS, CNT BYTE;
        DECLARE S1A BASED S1(1) BYTE;
        DECLARE S2A BASED S2(1) BYTE;
        DECLARE I BYTE;
        CNT = CNT - 1;
        DO I = 0 TO CNT;
            IF S1A(I) <> S2A(I) THEN
                RETURN 0;
        END;
        RETURN 0FFH;
    END;

    NUMOUT: PROCEDURE(VALUE, BASE, LC, BUFADR, WIDTH);
        DECLARE (VALUE, BUFADR) ADDRESS, (BASE, LC, WIDTH) BYTE; 
        DECLARE DIGITS DATA('0123456789ABCDEF');
        DECLARE I BYTE;
        DECLARE BUF BASED BUFADR (1) BYTE;

        DO I = 1 TO WIDTH;
            BUF(WIDTH - I) = DIGITS(VALUE MOD BASE);
            VALUE = VALUE / BASE;   
        END;

        I = 0;
        DO WHILE BUF(I) = '0' AND I < WIDTH - 1;
            BUF(I) = LC;
            I = I + 1;
        END;
    END;

    REPORTERROR: PROCEDURE(ERRNUM);
        DECLARE ERRNUM ADDRESS;
        DECLARE NUMBERBUFFER(4) BYTE, I ADDRESS, STATUS ADDRESS;
     

        DECLARE ERRMSG DATA(0, 0,
            2, 'ILLEGAL AFTN ARGUMENT', 0,
            4, 'INCORRECTLY SPECIFIED FILE', 0,
            5, 'UNRECOGNIZED DEVICE NAME', 0,
            6, 'ATTEMPT TO WRITE TO INPUT DEVICE', 0,
            8, 'ATTEMPT TO READ FROM OUTPUT DEVICE', 0,
            9, 'DIRECTORY FULL', 0,
            0AH, 'NOT ON SAME DISK', 0,
            0BH, 'FILE ALREADY EXISTS', 0,
            0CH, 'FILE IS ALREADY OPEN', 0,
            0DH, 'NO SUCH FILE', 0,
            0EH, 'WRITE PROTECTED', 0,
            0FH, 'LOAD TOO LOW', 0,
            10H, 'BAD LOAD FORMAT', 0,
            11H, 'NOT A DISK FILE', 0,
            12H, 'ILLEGAL ISIS COMMAND', 0,
            13H, 'ATTEMPTED SEEK ON NON-DISK FILE', 0,
            14H, 'ATTEMPTED BACK SEEK TO FAR', 0,
            16H, 'ILLEGAL ACCESS MODE TO OPEN', 0,
            17H, 'MISSING FILENAME', 0,
            19H, 'ILLEGAL ECHO FILE', 0,
            1AH, 'ILLEGAL ATTRIBUTE IDENTIFIER', 0,
            1BH, 'ILLEGAL SEEK COMMAND', 0,
            1CH, 'MISSING EXTENSION', 0,
            1FH, 'CAN', 27H, 'T SEEK ON WRITE ONLY FILE', 0,
            20H, 'CAN', 27H, 'T DELETE OPEN FILE', 0,
            23H, 'SEEK PAST EOF', 0,
            0C9H, 'UNRECOGNIZED SWITCH', 0,
            0CAH, 'UNRECOGNIZED DELIMITER', 0,
            0CBH, 'INVALID SYNTAX', 0,
            0CCH, 'PREMATURE EOF', 0,
            0CEH, 'ILLEGAL DISKETTE LABEL', 0,
            0D0H, 'CHECKSUM ERROR', 0
        );



        IF ERRNUM <> 0 THEN
        DO;
            I = 0;
            DO WHILE I < LENGTH(ERRMSG);
                IF ERRNUM = ERRMSG(I) AND ERRMSG(I + 1) <> 0 THEN
                DO;
                    I = I + 1;
                    CALL WRITE(0, .(' '), 1, .STATUS);
                    DO WHILE ERRMSG(I) <> 0;
                        CALL WRITE(0, .ERRMSG(I), 1, .STATUS);
                        I = I + 1;
                    END;
                    CALL WRITE(0, .(0DH, 0AH), 2, .STATUS);
                    return;
                END;
                ELSE
                DO;
                    DO WHILE ERRMSG(I) <> 0;
                        I = I + 1;
                    END;
                    I = I + 1;
                END;
            end;
            CALL ERROR(ERRNUM);
        END;
    END;

    FILE$ERROR: PROCEDURE(STATUS, PTR, CALLEXIT);
        DECLARE (STATUS, PTR) ADDRESS, CALLEXIT BYTE;
        DECLARE ERR$STATUS ADDRESS;

        IF STATUS <> 0 THEN
        DO;
            PTR = DEBLANK(PTR);
            CALL WRITE(0, .(' '), 1, .ERR$STATUS);
            CALL WRITE(0, PTR, DELIMIT(PTR) - PTR, .ERR$STATUS);
            CALL WRITE(0, .(','), 1, .ERR$STATUS);
            CALL REPORTERROR(STATUS);
            IF CALLEXIT THEN
                CALL EXIT;
        END;
    END;


    DECLARE (ACTUAL, STATUS) ADDRESS;
    DECLARE BUFFER(128) BYTE;
    DECLARE BUFPTR ADDRESS;

    DECLARE BADCMD DATA('CANNOT READ COMMAND LINE.', CR, LF);
MAIN:
    CALL READ(1, .BUFFER, 128, .ACTUAL, .STATUS);
    IF STATUS <> 0 THEN DO;
        CALL REPORTERROR(STATUS);
        CALL WRITE(0, .BADCMD, 27, .STATUS);
        CALL EXIT;
    END;

    BUFPTR = DEBLANK(DELIMIT(DEBLANK(.BUFFER)));
    IF SEQ(.('TO '), BUFPTR, 3) THEN DO;
        BUFPTR = BUFPTR + 3;
        CALL RENAME(.BUFFER, .BUFFER, .STATUS);
        IF STATUS <> 0BH THEN
            CALL FILEERROR(STATUS, .BUFFER, TRUE);
        CALL RENAME(.BUFFER, BUFPTR, .STATUS);
        IF STATUS = 0BH THEN DO;
            CALL WRITE(0, .(' '), 1, .STATUS);
            CALL WRITE(0, BUFPTR, DELIMIT(BUFPTR) - BUFPTR, .STATUS);
            CALL WRITE(0, .(', ALREADY EXISTS, DELETE', 3FH, ' '), 26, .STATUS);
            CALL READ(1, .MEMORY, 128, .ACTUAL, .STATUS);
            IF MEMORY(0) = 'Y' OR MEMORY(0) = 'Y' + 20H THEN DO;
                CALL DELETE(BUFPTR, .STATUS);
                CALL FILEERROR(STATUS, BUFPTR, TRUE);
                CALL RENAME(.BUFFER, BUFPTR, .STATUS);
            END;
            ELSE
                CALL EXIT;
        END;
        IF STATUS <> 0 THEN
            CALL FILEERROR(STATUS, BUFPTR, TRUE);
    END;
    ELSE
            CALL REPORTERROR(0CBH);
    CALL EXIT;
END;
EOF
