1C00H:
    DECLARE LIT LITERALLY 'LITERALLY',
            CR  LIT '0DH',
            LF  LIT '0AH',
            FF  LIT '0CH',
            TAB LIT '9',
            TRUE    LIT '0FFH',
            FALSE   LIT '0';

    DECLARE VER DATA(1, 3),
            COPYRIGHT DATA('(C) 1975,1976 INTEL CORP');

    DECLARE ASMCOMPLETE DATA(CR, LF, LF, 'ASSEMBLY COMPLETE, NO PROGRAM ERRORS',
                             CR, LF, '0 BLOCK');
    DECLARE PAGEHEADER DATA(0, LF, '16K ISIS 8080 ASSEMBLER, V1.0',
                            TAB, TAB, TAB, 'PAGE ', CR, LF, LF, LF, TAB, TAB, 0);
    DECLARE VALUE1(0) ADDRESS, VAL1B(0) BYTE, (VAL1LOW, VAL1HIGH) BYTE,
            VALUE2(0) ADDRESS, (VAL2LOW, VAL2HIGH) BYTE, PAD3760 BYTE;
    DECLARE BUFFER(80) BYTE,
            ERRCNT BYTE,
            STATUS ADDRESS,
            ENDBUF$PTR ADDRESS,
            (IN$NAME, LST$NAME) ADDRESS,
            (AFTIN, AFTHEX, AFTLST) ADDRESS,
            (BUFFER$PTR, MEMORY$P, ITABLE$P) ADDRESS;
    DECLARE (B37C6, B37C7, B37C8, B37C9, B37CA, B37CB) BYTE,
            (B37CC, B37D4)(8) BYTE,
            (SYMTAB$END, SYMTAB)(2) ADDRESS,
            (W37E4, W37E6) ADDRESS,
            (PASS, B37E9) BYTE,
            (RECLEN, CHECKSUM, B37EC) BYTE,
            RECBUF(17) BYTE,
            RECADDR ADDRESS;
    DECLARE (REF$P, MID$P, HIGH$P, LOW$P) ADDRESS,
            REFCH BASED REF$P BYTE,
            MIDCH BASED MID$P BYTE,
            MIDSYM BASED MID$P (8) BYTE,
            LOWWD BASED LOW$P ADDRESS,
            HIGHWD BASED HIGH$P ADDRESS;
    DECLARE (B3808, B3809) BYTE, B380A BYTE, B380B(7) BYTE;
    DECLARE (W3812, W3814) ADDRESS, PAD3816 BYTE;
    DECLARE (B3817, ACTION, B3819) BYTE,
            (TOKID, B381B, RADIX, B381D) BYTE,
            (LINECOL, LINEEND, PAGEWIDTH, ROWCNT) BYTE,
            PAGENO ADDRESS,
            LINEBUF(120) BYTE, TITLE(66) BYTE,  TITLELEN BYTE;
    DECLARE (B38DF, ERRORCH, TOKENCNT) BYTE,
            (TOKEN$P, SYM$P)(8) ADDRESS,
            TOKEN BASED TOKEN$P (8) BYTE,
            SYM BASED SYM$P (8) BYTE,
            SYMWD BASED SYM$P (4) ADDRESS,
            (TOKEN$TYPE, TOKEN$LEN)(8) BYTE,
            W3912 ADDRESS;


    ISIS: PROCEDURE(CMD, PARAM$P);
        DECLARE CMD BYTE, PARAM$P ADDRESS;
        GOTO 40H;
    END ISIS;

    OPEN: PROCEDURE(CONN$P, PATH$P, ACCESS, ECHO, STATUS$P);
        DECLARE (CONN$P, PATH$P, ACCESS, ECHO, STATUS$P) ADDRESS;

        CALL ISIS(0, .CONN$P);
    END;

    CLOSE: PROCEDURE(CONN, STATUS$P);
        DECLARE (CONN, STATUS$P) ADDRESS;

        CALL ISIS(1, .CONN);
    END;

    READ: PROCEDURE(CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P) ADDRESS;

        CALL ISIS(3, .CONN);
    END;

    WRITE: PROCEDURE(CONN, BUFF$P, COUNT, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, STATUS$P) ADDRESS;

        CALL ISIS(4, .CONN);
    END;

    EXIT: PROCEDURE;
        DECLARE STATUS ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(9, .STATUS);
    END;

    ERROR: PROCEDURE(ERROR$NUM);
        DECLARE (ERROR$NUM, STATUS) ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(12, .ERROR$NUM);
    END;

    CHECKSTATUS: PROCEDURE;
        IF STATUS = 0 THEN
            RETURN;
        CALL ERROR(STATUS);
        CALL EXIT;
    END;

    BUFSKIPSPC: PROCEDURE;
        DECLARE CH BASED BUFFER$PTR BYTE;

        DO WHILE CH = ' ' AND BUFFER$PTR <> ENDBUF$PTR;
            BUFFER$PTR = BUFFER$PTR + 1;
        END;
    END;

    OPENFILE: PROCEDURE(ACCESS) ADDRESS;
        DECLARE ACCESS ADDRESS;
        DECLARE AFTN ADDRESS, PAD BYTE;
        DECLARE CH BASED BUFFER$PTR BYTE;

        CALL BUFSKIPSPC;
        CALL OPEN(.AFTN, BUFFER$PTR, ACCESS, 0, .STATUS);    
        CALL CHECKSTATUS;
        DO WHILE CH <> ' ' AND BUFFER$PTR <> ENDBUF$PTR;
            BUFFER$PTR = BUFFER$PTR + 1;
        END;
        CALL BUFSKIPSPC;
        RETURN AFTN;
    END;

    /* CHECK FOR TO (N = 1) OR LIST (N = 2) */
    CHK$TO$LIST: PROCEDURE(N);
        DECLARE N BYTE,  OFFSET BYTE;
        DECLARE KEYWORDS DATA ('TOLIST');
        DECLARE BUF BASED BUFFER$PTR (1) BYTE;

        OFFSET = 0;
        IF N = 4 THEN
            OFFSET = 2;
        DO B3808 = 0 TO N - 1;
            IF BUF(B3808) <> KEYWORDS(B3808 + OFFSET) THEN DO;
                STATUS = 0CBH;
                CALL CHECKSTATUS;
            END;
        END;
        BUFFER$PTR = BUFFER$PTR + N;
    END;

    READCH: PROCEDURE BYTE;
        DECLARE CH BYTE, ACTUAL ADDRESS, PAD BYTE;
        CALL READ(AFTIN, .CH, 1, .ACTUAL, .STATUS);
        IF ACTUAL = 0 THEN
            STATUS = 0CFH;
        CALL CHECKSTATUS;
        RETURN CH AND 7FH;
    END;

    WRITECH$CO: PROCEDURE(CH);
        DECLARE CH BYTE;
        CALL WRITE(0, .CH, 1, .STATUS);
        CALL CHECKSTATUS;
    END;

    WRITECH$HEX: PROCEDURE(CH);
        DECLARE CH BYTE;
        CALL WRITE(AFTHEX, .CH, 1, .STATUS);
        CALL CHECKSTATUS;
    END;

    WRITECH$LST: PROCEDURE(CH);
        DECLARE CH BYTE;
        CALL WRITE(AFTLST, .CH, 1, .STATUS);
        CALL CHECKSTATUS;
    END;

    MEMCHK: PROCEDURE ADDRESS;
        GOTO 0F81BH;
    END;


    HEX1: PROCEDURE(CH) BYTE;
        DECLARE CH BYTE;
        IF (CH := (CH AND 0FH) + '0') > '9' THEN
            CH = CH + 7;
        RETURN CH;
    END;

    WRITEHEX2$CO: PROCEDURE(N);
        DECLARE N BYTE;
        CALL WRITECH$CO(HEX1(ROR(N, 4)));
        CALL WRITECH$CO(HEX1(N));
    END;


    BUFCH$LST: PROCEDURE(CH);
        DECLARE CH BYTE;
        IF CH = LF THEN DO;
            CH = 0;
            DO WHILE CH < LINEEND;
                CH = CH + 1;
                CALL WRITECH$LST(LINEBUF(CH));
            END;
            LINEEND = 0;
            CALL WRITECH$LST(CR);
            CALL WRITECH$LST(LF);
        END;
        ELSE DO;
            IF CH >= ' ' THEN
                LINEBUF(LINECOL) = CH;
            IF LINECOL > LINEEND THEN
                LINEEND = LINECOL;
        END;
    END;

    ADDCH$LST: PROCEDURE(CH);
        DECLARE CH BYTE;
        DECLARE (SPACES, I) BYTE;

        IF CH = FF THEN DO;
            DO WHILE ROWCNT <> 0;
                IF (ROWCNT := ROWCNT + 1) = 66 THEN
                    ROWCNT = 0;
                CALL BUFCH$LST(LF);
            END;
            RETURN;
        END;   
        IF CH = CR THEN
            LINECOL = 0;
        IF CH = LF THEN
            ROWCNT = ROWCNT + 1;
        SPACES = CH = TAB AND (7 - (LINECOL AND 7));
        IF CH = TAB THEN
            CH = ' ';
        DO I = 0 TO SPACES;
            IF LINECOL < PAGEWIDTH THEN DO;
                LINECOL = LINECOL + (CH >= ' ' AND 1);
                CALL BUFCH$LST(CH);
            END;
        END;
    END;

    PUTCH$LST: PROCEDURE(CH);
        DECLARE CH BYTE;
        DECLARE (I, HDRCH, J) BYTE;
        DECLARE DIV ADDRESS, PAD BYTE;

        IF CH = FF OR NOT ROWCNT < 60 THEN DO;
            CALL ADDCH$LST(CR);
            CALL ADDCH$LST(FF);
            I = 0;
            DO WHILE (HDRCH := PAGEHEADER(I := I + 1)) <> 0;
                IF HDRCH = CR THEN DO;
                    DIV = 10000;
                    DO WHILE DIV > 0;
                        IF PAGENO >= DIV THEN
                            CALL ADDCH$LST(LOW(PAGENO / DIV MOD 10) + '0');
                        DIV = DIV / 10;
                    END;
                    CALL ADDCH$LST(CR);
                    CALL ADDCH$LST(LF);

                    DO J = 1 TO TITLELEN;
                        CALL ADDCH$LST(TITLE(J));
                    END;
                END;
                CALL ADDCH$LST(HDRCH);
            END;
                PAGENO = PAGENO + 1;
        END;
        IF CH <> FF THEN
            CALL ADDCH$LST(CH);
    END;


    SUB2115: PROCEDURE;
        RECORDERROR: PROCEDURE(CH);
            DECLARE CH BYTE;
            IF NOT ROR(B37D4,1) AND ERRORCH = ' ' THEN DO;
                ERRORCH = CH;
                IF PASS = 3 OR PASS = 2 THEN
                    ERRCNT = ERRCNT + 1;
            END;
        END;

        /* TREAT PTR AS POINTER TO AN ARRAY OF NIBBLES */
        /* INDEX INTO THIS ARRAY TO RETRIEVE THE NIBBLE */
        GETNIBBLEAT: PROCEDURE(PTR, N) BYTE;
            DECLARE PTR ADDRESS, N BYTE;
            DECLARE BA BASED PTR (1) BYTE;
            DECLARE TMP BYTE;
            TMP = BA(SHR(N, 1));
            IF N THEN
                TMP = ROR(TMP, 4);
            RETURN TMP AND 0FH;
        END;

        WRITEHEX2$HEX: PROCEDURE(N);
            DECLARE N BYTE;
            CALL WRITECH$HEX(HEX1(ROR(N, 4)));
            CALL WRITECH$HEX(HEX1(N));
        END;

        PUTHEX2$LST: PROCEDURE(N);
            DECLARE N BYTE;
            CALL PUTCH$LST(HEX1(ROR(N, 4)));
            CALL PUTCH$LST(HEX1(N));
        END;

        WRITEHEXREC$HEX: PROCEDURE(RECTYPE);
            DECLARE RECTYPE BYTE, I BYTE;

            CALL WRITECH$HEX(':');
            CALL WRITEHEX2$HEX(RECLEN);
            CALL WRITEHEX2$HEX(HIGH(RECADDR));
            CALL WRITEHEX2$HEX(LOW(RECADDR));
            CALL WRITEHEX2$HEX(RECTYPE);
            DO I = 1 TO RECLEN;
                CALL WRITEHEX2$HEX(RECBUF(I));
            END;
            CHECKSUM = CHECKSUM - HIGH(RECADDR) - LOW(RECADDR) - RECTYPE - RECLEN;
            CALL WRITEHEX2$HEX(CHECKSUM);
            CALL WRITECH$HEX(CR);
            CALL WRITECH$HEX(LF);
            CHECKSUM = 0;
            RECLEN = 0;
            B37E9 = 16;
        END; 
                

        SUB2233: PROCEDURE(CODE);
            DECLARE CODE BYTE;
            
            IF (CODE AND 3) <> 0 THEN DO;
                IF VAL2HIGH <> 0 OR VAL2LOW > 7 OR (CODE AND VAL2LOW)
                   OR ((CODE AND 3) = 3 AND VAL2LOW > 2) THEN DO;
                    VAL2LOW = 0;
                    CALL RECORDERROR('R');
                END;

                IF ROR(CODE, 2) THEN
                    VAL2LOW = ROL(VAL2LOW, 3);

                VAL1LOW = VAL1LOW OR VAL2LOW;
            END;
            IF SHR(CODE, 3) THEN
                IF VAL2HIGH + 1 > 1 THEN
                    CALL RECORDERROR('V');

            IF (ACTION := SHR(CODE, 4) + 22H) = 22H THEN DO;
                IF VAL1HIGH > 0 THEN
                    CALL RECORDERROR('V');
                B3819 = 6;
            END;
        END;

        /* PUSH / POP ROUTINES */
        /* LOCATION 0 HOLDS THE CURRENT VALUE1(0) */
        /* PUSH COPIES CURRENT TO END OF LIST */
        /* POP COPIES END OF LIST TO CURRENT */
        POPCODE: PROCEDURE(CODE);
            DECLARE CODE BYTE;

            IF CODE <> B37CC THEN DO;
                CALL RECORDERROR((CODE = 0FFH AND 5) + 'N');
                IF B37CB > 1 THEN
                    B37CB = 2;
            END;
            IF B37CB > 1 THEN DO;
                B37D4(0) = B37D4(B37CB);
                B37CC(0) = B37CC(B37CB);
                B37CB = B37CB - 1;
            END;
        END;


        PUSHCODE: PROCEDURE(CODE);
            DECLARE CODE BYTE;
            IF B37EC THEN
                RETURN;
            IF (B37CB := B37CB + 1) >= 8 THEN
                CALL POPCODE(0FFH);
            ELSE DO;
                B37D4(B37CB) = B37D4(0);
                B37CC(B37CB) = B37CC(0);
                B37CC(0) = CODE;
            END;
        END;


        WRITESYM$HEX: PROCEDURE;
            IF PASS = 3 THEN
                CALL PUTCH$LST(FF);

            MID$P = SYMTAB(1);
            DO WHILE MID$P < SYMTAB$END(1);
                IF PASS = 3 THEN DO;
                    IF (B3808 := (B3808 + 1) AND 3) = 1 THEN DO;
                        CALL PUTCH$LST(CR);
                        CALL PUTCH$LST(LF);
                    END;
                    DO B3809 = 0 TO 4;
                        CALL PUTCH$LST(MIDSYM(B3809));
                    END;

                    CALL PUTCH$LST(' ');
                    CALL PUTHEX2$LST(MIDSYM(7));
                    CALL PUTHEX2$LST(MIDSYM(6));
                    IF MIDSYM(5) = 3 THEN
                        CALL PUTCH$LST('M');
                    CALL PUTCH$LST(TAB);
                END;
                ELSE DO;
                    CALL WRITECH$HEX('0');
                    CALL WRITECH$HEX(' ');
                    DO B3809 = 0 TO 4;
                        CALL WRITECH$HEX(MIDSYM(B3809));
                    END;
                    CALL WRITECH$HEX(' ');
                    CALL WRITECH$HEX('0');
                    CALL WRITEHEX2$HEX(MIDSYM(7));
                    CALL WRITEHEX2$HEX(MIDSYM(6));
                    CALL WRITECH$HEX('H');
                    CALL WRITECH$HEX(CR);
                    CALL WRITECH$HEX(LF);
                END;
                MID$P = MID$P + 8;
            END;
            IF PASS = 3 THEN
                CALL ADDCH$LST(FF);
            ELSE DO;
                CALL WRITECH$HEX(' ');
                CALL WRITECH$HEX('$');
                CALL WRITECH$HEX(CR);
                CALL WRITECH$HEX(LF);
            END;
        END;

        SUB24A2:  PROCEDURE BYTE;
            IF B38DF <> 0 THEN DO;
                DO WHILE (B381B := READCH) = 0 OR B381B = 07FH;
                END;
                IF PASS = 3 THEN
                    CALL PUTCH$LST(B381B);
            END;
            B38DF = 1;
            RETURN TOKID := B381B;
        END; 

        /* CLASSIFY CHARACTER READ */
        /* 0 ILLEGAL */
        /* 1 WHITE SPACE TAB, LF, FF, SPACE */
        /* 2 SEMICOLON */
        /* 3 COLON */
        /* 4 CR */
        /* 5 ( ) * , -  / */
        /* 6 $ */
        /* 7 quote */
        /* 8 NUMERIC */
        /* 9 LETTER */

        CLASSIFY: PROCEDURE BYTE;
            DECLARE TABLE DATA(  0,   0,   0,   0, 10h,   1, 41h,   0,
                                 0,   0,   0,   0,   0,   0,   0,   0,
                                 1,   0,   6, 70h, 55h, 55h, 55h, 50h,
                               88h, 88h, 88h, 88h, 88h, 23h,   0,   0);
            IF SUB24A2 > 7AH THEN
                RETURN 0;
            IF TOKID > 60H THEN
                RETURN 9;
            IF TOKID > 5AH THEN
                RETURN 0;
            IF TOKID > 3EH THEN
                RETURN 9;
            RETURN GETNIBBLEAT(.TABLE, TOKID);
        END; 

        PUSH$TOKEN: PROCEDURE(NEW$TOKEN$TYPE);
            DECLARE NEW$TOKEN$TYPE BYTE;
            IF (TOKENCNT := TOKENCNT + 1) >= 8 THEN DO;
                TOKENCNT = 2;
                CALL RECORDERROR('S');
            END;
            /* PUSH PREVIOUS TOKEN */
            TOKEN$P(TOKENCNT) = TOKEN$P(0);
            SYM$P(TOKENCNT) = SYM$P(0);
            TOKEN$TYPE(TOKENCNT) = TOKEN$TYPE(0);
            TOKEN$LEN(TOKENCNT) = TOKEN$LEN(0);
            /* NEW TOKEN STARTS JUST AFTER PREVIOUS ONE */
            TOKEN$P(0) = TOKEN$P(0) + TOKEN$LEN(0);
            SYM$P(0) = 0;
            TOKEN$TYPE(0) = NEW$TOKEN$TYPE;
            TOKEN$LEN(0) = 0;
        END;

        ADDCH$TOKEN: PROCEDURE(CH);
            DECLARE CH BYTE;
            IF TOKEN$P(0) + TOKEN$LEN(0) < W3912 THEN DO;
                TOKEN(TOKEN$LEN) = CH;
                TOKEN$LEN = TOKEN$LEN + 1;
            END;
            ELSE
                CALL RECORDERROR('T');
        END;
                

        POP$TOKEN: PROCEDURE;
            TOKEN$P(0) = TOKEN$P(TOKENCNT);
            SYM$P(0) = SYM$P(TOKENCNT);
            TOKEN$TYPE(0) = TOKEN$TYPE(TOKENCNT);
            TOKEN$LEN(0) = TOKEN$LEN(TOKENCNT);
            TOKENCNT = TOKENCNT - 1;
        END;


        SUB262A: PROCEDURE(NEW$TOKEN$TYPE);
            DECLARE NEW$TOKEN$TYPE BYTE;

            CALL PUSH$TOKEN(NEW$TOKEN$TYPE);
            B38DF = B38DF - 1;

            DO WHILE CLASSIFY > 7;
                IF TOKID > 40H THEN
                    TOKID = TOKID AND 0DFH;
                CALL ADDCH$TOKEN(TOKID);
            END;
            B38DF = B38DF - 1;
        END;

        PRECEDENCE: PROCEDURE(N) BYTE;
            DECLARE N BYTE, PAD BYTE;
            DECLARE TABLE DATA(  0,   0, 67h, 61h, 76h, 56h, 34h, 73h,
                               77h, 11h, 11h, 11h, 11h,   0, 11h, 11h,
                               11h, 11h, 11h, 11h, 11h, 11h, 11h);

            RETURN GETNIBBLEAT(.TABLE, N);
        END;

        /* LOOK UP TOKEN IN ONE OF THE TWO SYMBOL TABLES */ /* USING A BINARY SEARCH */
        /* SYMBOLS ARE STORED AS 8 BYTE ENTRIES
           NAME(5) BYTE,
           TYPE BYTE,
           VALUE1(0) ADDRESS
        */
        LOOKUP: PROCEDURE(TABLEID) BYTE;
            DECLARE TABLEID BYTE;
            DECLARE CMP BYTE;

            LOW$P = SYMTAB(TABLEID);
            HIGH$P, MID$P = SYMTAB$END(TABLEID);
            DECLARE MIDCH BASED MID$P BYTE,
                    REFCH BASED REF$P BYTE,
                    SYM BASED SYM$P(0) BYTE;

            DO WHILE (REF$P := LOW$P + SHR((HIGH$P - LOW$P) AND 0FFF0H, 1)) <> MID$P;
                MID$P = REF$P;
                REF$P = TOKEN$P(0);
                DO WHILE (CMP := MIDCH - REFCH) = 0;
                    MID$P = MID$P + 1;
                    IF (REF$P := REF$P + 1) = TOKEN$P(0) + TOKEN$LEN THEN DO;
                        IF TOKEN$LEN = 5 OR MIDCH = ' ' THEN DO;
                            SYM$P(0) = MID$P - TOKEN$LEN;
                            TOKEN$TYPE = SYM(5);
                            IF TOKEN$TYPE = 2AH OR TOKEN$TYPE = 22H OR
                               TOKEN$TYPE = 13H OR TOKEN$TYPE = 14H OR
                               TOKEN$TYPE = 18H OR TOKEN$TYPE = 1DH OR
                               TOKEN$TYPE = 1EH THEN
                                B37C7 = 1;
                            RETURN TOKEN$TYPE;
                        END;
                        ELSE GOTO BREAK;
                    END;
                END;
            BREAK:
                MID$P = (MID$P - REF$P) + TOKEN$P(0);
                IF ROL(CMP, 1) THEN   /* SIGN TEST */
                    LOW$P = MID$P;
                ELSE
                    HIGH$P = MID$P;
                
            END;
            SYM$P(0) = HIGH$P;
            RETURN 0;
        END;

        DECLARE W396C ADDRESS;

        SUB27EE: PROCEDURE(NEWTYPE, N);
            DECLARE (NEWTYPE, N) BYTE, I BYTE;
            IF TOKENCNT <> 1 THEN
                CALL RECORDERROR('F');
            ELSE DO;
                IF TOKEN$TYPE = 0 THEN DO;
                    IF (HIGH$P := (LOW$P := W37E6) + 8) >= W37E4 THEN DO;
                        CALL RECORDERROR('T'); 
                        GOTO DONE;
                    END;
                    ELSE DO;
                        W37E6 = HIGH$P;
                        SYMTAB$END(N) = SYMTAB$END(N) + 8;
                        DO WHILE LOW$P >= SYM$P;
                            HIGHWD = LOWWD;
                            HIGH$P = HIGH$P - 2;
                            LOW$P = LOW$P - 2;
                        END;
                        DO I = 0 TO 4;                        
                            N = ' ';
                            IF TOKEN$LEN > I THEN
                                N = TOKEN(I);
                            SYM(I) = N;
                        END;
                        TOKEN$TYPE = NEWTYPE;
                    END;
                END;
                ELSE IF (TOKEN$TYPE <> 4 OR TOKEN$TYPE <> NEWTYPE) AND PASS = 1 THEN
                    TOKEN$TYPE = 3;
                ELSE IF TOKEN$TYPE <> 4 THEN
                    IF SYMWD(3) <> W396C THEN
                        CALL RECORDERROR(((TOKEN$TYPE <> 3) AND 3) + 'M' + ((SYM$P(0) = 0) AND 1));
                IF SYM$P <> 0 THEN DO;
                    SYM(5) = TOKEN$TYPE;
                    IF TOKEN$TYPE = NEWTYPE THEN
                        SYMWD(3) = W396C;
                END;
        DONE:
                CALL POP$TOKEN;
            END;
        END;

        SUB2992: PROCEDURE ADDRESS;
            VALUE1 = 0;
            IF TOKENCNT < 1 THEN
                CALL RECORDERROR('F');
            ELSE DO;
                IF TOKEN$TYPE <> 0 THEN
                    ;
                ELSE
                    TOKEN$TYPE = LOOKUP(1);
                IF TOKEN$TYPE = 0 THEN
                    CALL RECORDERROR('U');
                ELSE DO;
                    IF TOKEN$TYPE <= 4 THEN DO;
                        TOKEN$P(0) = SYM$P +  6;
                        TOKEN$LEN = 2;
                    END;
                    ELSE IF TOKEN$LEN > 2 THEN
                        CALL RECORDERROR('V');
                    VAL1LOW = TOKEN(0);
                    IF TOKEN$LEN > 1 THEN
                        VAL1HIGH = TOKEN(1);
                    /* SEE IF NEED TO SWAP HIGH AND LOW BYTES */
                    IF TOKEN$TYPE = 5 AND B37C7 AND TOKEN$LEN = 2 THEN DO;
                        B37C6 = VAL1LOW;
                        VAL1LOW = VAL1HIGH;
                        VAL1HIGH = B37C6;
                    END;
                END;
            CALL POP$TOKEN;
            END;
            RETURN VALUE1(0);
        END;

        DECLARE B3972(66) BYTE;
                

        IF PASS = 2 THEN
            CALL WRITESYM$HEX;
        B37C7 = 0;
        B37C9 = 0;
        B37D4 = 0;
        W3814 = 0;
        B381D = 0;
        ERRCNT = 0;
        SYMTAB(0) = ITABLE$P;
        SYMTAB$END(0) = MEMORY$P;
        IF PASS = 1 THEN DO;
            W37E4 = MEMCHK + 250;
            SYMTAB(1), SYMTAB$END(1) = MEMORY$P + 2;
            W37E6 = SYMTAB$END(0);
            TITLELEN = 0;
        END;
        IF PASS = 3 THEN DO;
            ROWCNT = 0;
            LINECOL = 0;
            LINEEND = 0;
            PAGENO = 1;
            PAGEWIDTH = 120;
            CALL WRITECH$LST(0Ch);
            CALL PUTCH$LST(0Ch);
        END;
        ERRORCH = ' ';
        RECLEN = 0;
        CHECKSUM = 0;
        B37EC = 0;
        B38DF = 0;
        TOKENCNT = 0;
        B37CB = 0;
        TOKEN$LEN = 0;
        TOKEN$TYPE = 0;
        B380A = 0;
        B380B(0) = 0;
        W3812 = 0;
        RECADDR = 0;
        B381B = CR;
        B37E9 = 16;
        CALL PUSHCODE(2);
        W3812 = 0;
        RECADDR = 0;
        w3912 = (TOKEN$P(0) := .B3972) + 66;
        B3817 = 1;


COLLECTLOOP:
        IF B3817 = 0 THEN
            CALL RECORDERROR('E');

        B3817 = 0;
LOOP:
        DO CASE CLASSIFY;
            DO;                         /* CASE 0 ILLEGAL */
                CALL RECORDERROR('I');
                GOTO LOOP;
            END;
            GOTO LOOP;                  /* CASE 1 WHITESPACE */
            DO;                         /* CASE 2 SEMICOLON  */
                DO WHILE CLASSIFY <> 4;
                END;
                TOKID = 1;
            END;
            DO;                         /* CASE 3 COLON */
                B3817 = 1;
                IF B37D4 THEN DO;
                    IF NOT B37C8 THEN
                        CALL POP$TOKEN;
                END;
                ELSE DO;
                    W396C = W3812;
                    CALL SUB27EE(2, 1);
                END;
                GOTO LOOP;
            END;
            DO;                         /* CASE 4 CR */
                TOKID = 1;
            END;
            DO;                         /* CASE 5 ( ) *, - / */
                IF (TOKID = '+' OR TOKID = '-') AND B3817 <> 0 AND B3817 <> 3 THEN
                    TOKID = TOKID + 3;
                TOKID = TOKID - '(' + 2;
            END;
            DO;                         /* CASE 6 $ */
                CALL PUSH$TOKEN(7);
                CALL ADDCH$TOKEN(LOW(W3812));
                CALL ADDCH$TOKEN(HIGH(W3812));
                GOTO COLLECTLOOP;
            END;
            DO;                         /* CASE 7 QUOTE */
                CALL PUSH$TOKEN(5);
                DO WHILE SUB24A2 <> CR;
                    IF TOKID = '''' THEN
                        IF SUB24A2 <> '''' THEN
                            GOTO GOTSTRING;
                    CALL ADDCH$TOKEN(TOKID);
                END;
                CALL RECORDERROR('B');
    GOTSTRING:
                B38DF = B38DF - 1; 
                GOTO COLLECTLOOP;
            END;
            DO;                         /* CASE 8 NUMBER */
                CALL SUB262A(7); 
                IF (RADIX := TOKEN(TOKEN$LEN := TOKEN$LEN - 1)) = 'H' THEN
                    RADIX = 16;
                IF RADIX = 'O' THEN
                    RADIX = 8;
                IF RADIX = 'Q' THEN
                    RADIX = 8;
                IF RADIX = 'B' THEN
                    RADIX = 2;
                IF RADIX = 'D' THEN
                    RADIX = 10;
                IF RADIX > 16 THEN
                    RADIX = 10;
                ELSE
                    TOKEN$LEN = TOKEN$LEN - 1;
                VALUE1(0) = 0;
                DO B3808 = 0 TO TOKEN$LEN;
                    IF (TOKID := TOKEN(B3808) - '0') > 9 THEN
                        TOKID = TOKID - 7;
                    IF TOKID >= RADIX THEN DO;
                        TOKID = 0;
                        CALL RECORDERROR('I');
                    END;
                    VALUE1(0) = VALUE1(0) * RADIX + TOKID;
                END;
                TOKEN$LEN = 0;
                CALL ADDCH$TOKEN(LOW(VALUE1(0)));
                CALL ADDCH$TOKEN(HIGH(VALUE1(0)));
                GOTO COLLECTLOOP;
            END;
            DO;                     /* CASE 9 LETTER */
                CALL SUB262A(0);
                IF TOKEN$LEN > 5 THEN
                    TOKEN$LEN = 5;
                IF  LOOKUP(0) = 0 THEN
                    TOKEN$TYPE = LOOKUP(1);
                IF (TOKID := TOKEN$TYPE) >= 31 THEN
                    TOKEN$TYPE = 2;
                IF TOKEN$TYPE > 10 THEN
                    CALL POP$TOKEN;
                IF TOKID > 4 THEN
                    GOTO DOLINE;
                GOTO COLLECTLOOP;
            END;
        END;    /* OF CASE */

                
DECLARE BA2DA2 DATA(  0, 80h,   0,   0, 0Fh, 0Fh,   0, 0Fh,
                    0Dh, 0Fh, 0Dh, 0Dh, 0Fh, 0Fh, 0Fh, 0Fh,
                    0Fh, 0Fh, 40h,   1, 4Dh, 80h, 80h, 80h,
                      1, 81h, 80h, 40h, 40h,   1,   1, 40h,
                    40h, 40h, 47h,   7,   7,   7, 17h, 47h,
                      7, 47h, 37h,   5);

DOLINE:
        IF BA2DA2(TOKID) < 80H AND B37D4 THEN
            GOTO LOOP;
        IF PRECEDENCE(B3817 := TOKID) > PRECEDENCE(ACTION := B380B(B380A)) OR B3817 = 2 THEN DO;
            B380B(B380A := B380A + 1) = B3817;
            GOTO LOOP;
        END;
        IF ACTION = 0 THEN
            ACTION = B3817;
        ELSE
            B380A = B380A - 1;
        IF (B37CA := BA2DA2(ACTION)) THEN
            VALUE2(0) = SUB2992;
        IF (B37CA := ROR(B37CA, 1)) THEN
            VALUE1(0) = SUB2992;
        B3819 = 7;
        DO CASE ACTION;
        ;               /* CASE 0 */
        DO;             /* CASE 1 */
            REF$P = TOKEN$P(0) + TOKEN$LEN;
            IF B37D4 THEN
                REF$P = .B3972;
            DO WHILE TOKENCNT > 0;
                IF TOKEN$TYPE <> 6 THEN
                    CALL RECORDERROR('Q');
                CALL POP$TOKEN;
            END;
            MID$P = .B3972;
            B3808 = 1;
            IF PASS = 3 THEN DO;
                DO WHILE B3808;
                    CALL PUTCH$LST(0Dh);
                    CALL PUTCH$LST(0);
                    CALL PUTCH$LST(ERRORCH); 
                    CALL PUTCH$LST(20h);
                    IF (B381D := MID$P <> REF$P OR B381D) THEN DO;
                        CALL PUTHEX2$LST(HIGH(W3814));
                        CALL PUTHEX2$LST(LOW(W3814));
                    END;
                    B381D = SHL(NOT B381D AND 1, 2);
                    DO B3809 = 0 TO B381D;
                        CALL PUTCH$LST(' ');
                    END;
                    DO B3809 = 1 TO 4;
                        IF MID$P < REF$P THEN
                            CALL PUTHEX2$LST(MIDCH);
                        ELSE DO;
                            CALL PUTCH$LST(' ');
                            CALL PUTCH$LST(' ');
                        END;
                        B3808 = (MID$P := MID$P + 1) < REF$P;
                    END;
                    IF B3808 THEN
                        CALL PUTCH$LST(LF);
                    W3814 = W3814 + 4;
                END;
            END;    /* PASS 3 */
            IF PASS = 2 THEN DO;
                MID$P = .B3972;
                IF RECADDR + RECLEN <> W3812 OR B37EC THEN DO;
                    IF RECLEN > 0 THEN
                        CALL WRITEHEXREC$HEX(0);
                    RECADDR = W3812;
                END;
                DO WHILE MID$P < REF$P; 
                    IF RECLEN = B37E9 THEN DO;
                        CALL WRITEHEXREC$HEX(0);
                        RECADDR = RECADDR + 16;
                    END;
                    CHECKSUM = CHECKSUM - (RECBUF(RECLEN := RECLEN + 1) := MIDCH);
                    MID$P = MID$P + 1;
                END; 
                IF B37EC THEN
                    CALL WRITEHEXREC$HEX(1);
            END;     /* PASS 2 */
            W3814, W3812 = W3812 + REF$P - .B3972;
            B381D = 0;
            B37C7 = 0;
            ERRORCH = ' ';
            B380A = 0;
            B37D4 = B37D4 > 0;
            IF B37EC THEN DO;
                B37EC = 0;
                IF PASS = 3 THEN
                    CALL WRITESYM$HEX;
                RETURN;
            END; 
            GOTO LOOP;
        END;
        GOTO CASE$3;            /* CASE 2 */
CASE$3: DO;                     /* CASE 3 */
            IF NOT (ACTION = 2 AND B3817 = 3) THEN
                CALL RECORDERROR('B');
            IF TOKEN$TYPE  = 6 THEN
                TOKEN$LEN = 1;
            IF B3817 = 3 THEN
                GOTO LOOP; 
        END;
        VALUE1(0) = VALUE1(0) * VALUE2(0);   /* CASE 4 */
        VALUE1(0) = VALUE1(0) + VALUE2(0);   /* CASE 5 */
        CALL RECORDERROR('F');      /* CASE 6 */
        VALUE1(0) = VALUE1(0) - VALUE2(0);   /* CASE 7 */
        ;
        VALUE1(0) = VALUE1(0) / VALUE2(0);   /* CASE 9 */
        VALUE1(0) = -VALUE1(0);           /* CASE 10 */
        VALUE1(0) = NOT VALUE1(0);        /* CASE 11 */
        VALUE1(0) = VALUE1(0) AND VALUE2(0); /* CASE 12 */
        VALUE1(0) = VALUE1(0) OR VALUE2(0);  /* CASE 13 */
        VALUE1(0) = VALUE1(0) XOR VALUE2(0); /* CASE 14 */
        VALUE1(0) = VALUE1(0) MOD VALUE2(0); /* CASE 15 */
        DO;                                  /* CASE 16 */
            IF VAL2LOW <> 0 THEN
            VALUE1(0) = SHL(VALUE1(0), VAL2LOW);
        END;
        DO;                                  /* CASE 17 */
            IF VAL2LOW <> 0 THEN
            VALUE1(0) = SHR(VALUE1(0), VAL2LOW);
        END;
        DO;                         /* CASE 18 */
            IF TOKEN$TYPE <> 5 AND TOKEN$TYPE <> 6 THEN DO;
                VALUE1(0) = SUB2992;
                IF VAL1HIGH -1  < 0FEH THEN 
                    CALL RECORDERROR('V');
                B37CA = 22H;
            END;
            TOKEN$TYPE = 6;
            B3819 = 6;
        END;
        DO;                         /* CASE 19 */
            B381D = 1;
            W3812 = W3812 + VALUE2(0);
            GOTO DOLINE;
        END;
        B3819 = 6;                  /* CASE 20 */
        DO;                         /* CASE 21 */
            W3812 = 0;
            VALUE1(0) = 0;
            IF TOKENCNT > 0 THEN
                W3812 = SUB2992;
            B381D = 1;
            B37EC = 1;
            B37D4 = 0;
            CALL POPCODE(2);
        END;
        CALL POPCODE(0);            /* CASE 22 */
        ;                           /* CASE 23 */
        DO;                         /* CASE 24 */
            B381D = 1;
            W396C = VALUE1(0);
            CALL SUB27EE(2, 1);
        END;
        DO;                         /* CASE 25 */
            CALL PUSHCODE(0);
            B37D4 = B37CB > 1 AND (((VALUE1(0) = 0) AND 1) OR B37D4);
        END;
        ;                           /* CASE 26 */
        ;                           /* CASE 27 */
        ;                           /* CASE 28 */
        DO;                         /* CASE 29 */
            B381D = 1;
            W3812 = VALUE1(0);
        END;
        DO;                         /* CASE 30 */
            IF LOOKUP(1) <> 4 AND TOKEN$TYPE <> 0 THEN
                CALL RECORDERROR('M');
            B381D = 1;
            W396C = VALUE1(0);
            CALL SUB27EE(4, 1);
        END;
        DO;                         /* CASE 31 */
            IF B3817 = 1 THEN DO;
                IF PASS <> 1 OR NOT B37C9 THEN DO;
                    REF$P = .B3972 + 5;
                    TITLELEN = 0;
                    DO WHILE TOKEN$P(0) + TOKEN$LEN > REF$P;
                        IF TITLELEN < 66 AND (B3808 := REFCH) <> FF THEN
                            TITLE(TITLELEN := TITLELEN + 1) = B3808;
                        REF$P = REF$P + 1;
                    END;
                END; 
                DO WHILE TOKENCNT > 0;
                    CALL POP$TOKEN;
                END;
                IF PASS = 1 THEN
                    B37C9 = 1;
            END;
        END;
        ;                           /* CASE 32 */
        ;                           /* CASE 33 */
        CALL SUB2233(85h);          /* CASE 34 */
        CALL SUB2233(5);            /* CASE 35 */
        CALL SUB2233(7);            /* CASE 36 */
        CALL SUB2233(2);            /* CASE 37 */
        CALL SUB2233(8);            /* CASE 38 */
        CALL SUB2233(46h);          /* CASE 39 */
        CALL SUB2233(6);            /* CASE 40 */
        CALL SUB2233(36h);          /* CASE 41 */
        CALL SUB2233(0);            /* CASE 42 */
        CALL SUB2233(0);            /* CASE 43 */
        END; /* END OF CASE */
        IF B381D THEN
            W3814 = VALUE1(0);
        IF (B37CA AND 1EH) <> 0 THEN
            CALL PUSH$TOKEN(B3819);
        DO B3808 = 0 TO 3;
            IF (B37CA := ROR(B37CA, 1)) THEN
                CALL ADDCH$TOKEN(VAL1B(B3808));
        END;
        IF ROR(B37CA, 1) THEN
            IF B3817 = 6 THEN
                TOKID = ACTION;
        GOTO DOLINE;
    END;
    

        DECLARE ITABLE(840) BYTE INITIAL(
                'A    ',     3,     7,     0,
                'ACI  ',   26h,  0CEh,     0,
                'ADC  ',   25h,   88h,     0,
                'ADD  ',   25h,   80h,     0,
                'ADI  ',   26h,  0C6h,     0,
                'ANA  ',   25h,  0A0h,     0,
                'AND  ',   0Ch,     0,     0,
                'ANI  ',   26h,  0E6h,     0,
                'B    ',     3,     0,     0,
                'C    ',     3,     1,     0,
                'CALL ',   2Ah,  0CDh,     0,
                'CC   ',   2Ah,  0DCh,     0,
                'CM   ',   2Ah,  0FCh,     0,
                'CMA  ',   2Bh,   2Fh,     0,
                'CMC  ',   2Bh,   3Fh,     0,
                'CMP  ',   25h,  0B8h,     0,
                'CNC  ',   2Ah,  0D4h,     0,
                'CNZ  ',   2Ah,  0C4h,     0,
                'CP   ',   2Ah,  0F4h,     0,
                'CPE  ',   2Ah,  0ECh,     0,
                'CPI  ',   26h,  0FEh,     0,
                'CPO  ',   2Ah,  0E4h,     0,
                'CZ   ',   2Ah,  0CCh,     0,
                'D    ',     3,     2,     0,
                'DAA  ',   2Bh,   27h,     0,
                'DAD  ',   23h,     9,     0,
                'DB   ',   12h,     0,     0,
                'DCR  ',   28h,     5,     0,
                'DCX  ',   23h,   0Bh,     0,
                'DI   ',   2Bh,  0F3h,     0,
                'DS   ',   13h,     0,     0,
                'DW   ',   14h,     0,     0,
                'E    ',     3,     3,     0,
                'EI   ',   2Bh,  0FBh,     0,
                'END  ',   15h,     0,     0,
                'ENDIF',   16h,     0,     0,
                'EQU  ',   18h,     0,     0,
                'H    ',     3,     4,     0,
                'HLT  ',   2Bh,   76h,     0,
                'IF   ',   19h,     0,     0,
                'IN   ',   26h,  0DBh,     0,
                'INR  ',   28h,     4,     0,
                'INX  ',   23h,     3,     0,
                'JC   ',   2Ah,  0DAh,     0,
                'JM   ',   2Ah,  0FAh,     0,
                'JMP  ',   2Ah,  0C3h,     0,
                'JNC  ',   2Ah,  0D2h,     0,
                'JNZ  ',   2Ah,  0C2h,     0,
                'JP   ',   2Ah,  0F2h,     0,
                'JPE  ',   2Ah,  0EAh,     0,
                'JPO  ',   2Ah,  0E2h,     0,
                'JZ   ',   2Ah,  0CAh,     0,
                'L    ',     3,     5,     0,
                'LDA  ',   2Ah,   3Ah,     0,
                'LDAX ',   24h,   0Ah,     0,
                'LHLD ',   2Ah,   2Ah,     0,
                'LXI  ',   22h,     1,     0,
                'M    ',     3,     6,     0,
                'MOD  ',   0Fh,     0,     0,
                'MOV  ',   29h,   40h,     0,
                'MVI  ',   27h,     6,     0,
                'NOP  ',   2Bh,     0,     0,
                'NOT  ',   0Bh,     0,     0,
                'OR   ',   0Dh,     0,     0,
                'ORA  ',   25h,  0B0h,     0,
                'ORG  ',   1Dh,     0,     0,
                'ORI  ',   26h,  0F6h,     0,
                'OUT  ',   26h,  0D3h,     0,
                'PCHL ',   2Bh,  0E9h,     0,
                'POP  ',   23h,  0C1h,     0,
                'PSW  ',     3,     6,     0,
                'PUSH ',   23h,  0C5h,     0,
                'RAL  ',   2Bh,   17h,     0,
                'RAR  ',   2Bh,   1Fh,     0,
                'RC   ',   2Bh,  0D8h,     0,
                'RET  ',   2Bh,  0C9h,     0,
                'RLC  ',   2Bh,     7,     0,
                'RM   ',   2Bh,  0F8h,     0,
                'RNC  ',   2Bh,  0D0h,     0,
                'RNZ  ',   2Bh,  0C0h,     0,
                'RP   ',   2Bh,  0F0h,     0,
                'RPE  ',   2Bh,  0E8h,     0,
                'RPO  ',   2Bh,  0E0h,     0,
                'RRC  ',   2Bh,   0Fh,     0,
                'RST  ',   28h,  0C7h,     0,
                'RZ   ',   2Bh,  0C8h,     0,
                'SBB  ',   25h,   98h,     0,
                'SBI  ',   26h,  0DEh,     0,
                'SET  ',   1Eh,     0,     0,
                'SHL  ',   10h,     0,     0,
                'SHLD ',   2Ah,   22h,     0,
                'SHR  ',   11h,     0,     0,
                'SP   ',     3,     6,     0,
                'SPHL ',   2Bh,  0F9h,     0,
                'STA  ',   2Ah,   32h,     0,
                'STAX ',   24h,     2,     0,
                'STC  ',   2Bh,   37h,     0,
                'SUB  ',   25h,   90h,     0,
                'SUI  ',   26h,  0D6h,     0,
                'TITLE',   1Fh,     0,     0,
                'XCHG ',   2Bh,  0EBh,     0,
                'XOR  ',   0Eh,     0,     0,
                'XRA  ',   25h,  0A8h,     0,
                'XRI  ',   26h,  0EEh,     0,
                'XTHL ',   2Bh,  0E3h,     0);
        DECLARE PAD3CFC ADDRESS, LASTADDRESS ADDRESS;

MAIN:
    CALL READ(1, .BUFFER, 80, .ENDBUF$PTR, .STATUS);
    BUFFER$PTR = .BUFFER;
    CALL CHECKSTATUS;
    ENDBUF$PTR = ENDBUF$PTR + .BUFFER;
    ITABLE$P = .ITABLE;
    MEMORY$P = .LASTADDRESS;
    CALL WRITECH$CO(CR);
    B3808 = 0;
    DO WHILE (B3809 := PAGEHEADER(B3808 := B3808 + 1)) <> TAB;
        CALL WRITECH$CO(B3809);
    END; 
    DO PASS = 1 TO 3;
        DO CASE PASS; 
        ;                /* CASE 0 */
        DO;              /* CASE 1 */
            IN$NAME = BUFFER$PTR;
            AFTIN = OPENFILE(1);
            CALL CHK$TO$LIST(2);   /* CHECK FOR TO */
        END;
        DO;              /* CASE 2 */
            AFTHEX = OPENFILE(2);
            CALL CHK$TO$LIST(4);    /* CHECK FOR LIST */
            LST$NAME = BUFFER$PTR;
            IF AFTHEX = 0FFH THEN
                GOTO CONTINUE;
        END;
        DO;
            CALL CLOSE(AFTHEX, .STATUS);
            CALL CHECKSTATUS;
            IF (AFTLST := OPENFILE(2)) = 0FFH THEN
                GOTO CONTINUE;
        END;
        END; /* OF CASE */
        IF PASS > 1 THEN DO;
            CALL CLOSE(AFTIN, .STATUS);
            CALL CHECKSTATUS;
            BUFFER$PTR = IN$NAME;
            AFTIN = OPENFILE(1);
            BUFFER$PTR = LST$NAME;
        END;
        CALL SUB2115;
CONTINUE:
    END;

    IF ERRCNT = 0 THEN
        CALL WRITE(0, .ASMCOMPLETE, 41, .STATUS);
    ELSE DO;
        CALL WRITE(0, .ASMCOMPLETE, 22, .STATUS);
        CALL WRITEHEX2$CO(ERRCNT);
        CALL WRITECH$CO('H');
        CALL WRITE(0, .ASMCOMPLETE + 24, 17, .STATUS);
    END;
    CALL EXIT;
EOF
