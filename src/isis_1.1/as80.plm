1C00H:
    DECLARE LIT LITERALLY 'LITERALLY',
            CR  LIT '0DH',
            LF  LIT '0AH',
            FF  LIT '0CH',
            TAB LIT '9',
            TRUE    LIT '0FFH',
            FALSE   LIT '0';

    DECLARE VER DATA(1, 3),
            COPYRIGHT DATA('(C) 1975,1976 INTEL CORP');

    DECLARE ASMCOMPLETE DATA(CR, LF, LF, 'ASSEMBLY COMPLETE, NO PROGRAM ERRORS',
                             CR, LF, '0 BLOCK');
    DECLARE PAGEHEADER DATA(0, LF, '16K ISIS 8080 ASSEMBLER, V1.0',
                            TAB, TAB, TAB, 'PAGE ', CR, LF, LF, LF, TAB, TAB, 0);
    DECLARE ACCUM1(0) ADDRESS, ACC1B(0) BYTE, (ACC1LOW, ACC1HIGH) BYTE,
            ACCUM2(0) ADDRESS, (ACC2LOW, ACC2HIGH) BYTE, PAD3760 BYTE;
    DECLARE BUFFER(80) BYTE,
            ERRCNT BYTE,
            STATUS ADDRESS,
            ENDBUF$PTR ADDRESS,
            (IN$NAME, LST$NAME) ADDRESS,
            (AFTIN, AFTHEX, AFTLST) ADDRESS,
            (BUFFER$PTR, MEMORY$P, ITABLE$P) ADDRESS;
            /* B37C8 IS REFERENCED BUT NOT SET - TREAT AS ZERO */
    DECLARE (NUMTMP, WORDOPERAND, B37C8, HAVETITLE, CUR$OP$FLAGS, IFDEPTH) BYTE,
            (IFSTATE, SKIPIF)(8) BYTE,
            (SYMTAB$END, SYMTAB)(2) ADDRESS,
            (ENDRAM, SYMHIGHMARK) ADDRESS,
            (PASS, MAXRECLEN) BYTE,
            (RECLEN, CHECKSUM, ENDSEEN) BYTE,
            RECBUF(17) BYTE,
            RECADDR ADDRESS;
    DECLARE (REF$P, MID$P, HIGH$P, LOW$P) ADDRESS,
            REFCH BASED REF$P BYTE,
            MIDCH BASED MID$P BYTE,
            MIDSYM BASED MID$P (8) BYTE,
            LOWWD BASED LOW$P ADDRESS,
            HIGHWD BASED HIGH$P ADDRESS;
    DECLARE (II, JJ) BYTE, OPSP BYTE, OPSTACK(7) BYTE;
    DECLARE (PC, ADDR) ADDRESS, PAD3816 BYTE;
    DECLARE (NEWACTION, ACTION, NEXT$TOK$TYPE) BYTE,
            (TOKID, LASTCHREAD, RADIX, SHOWADDR) BYTE,
            (LINECOL, LINEEND, PAGEWIDTH, ROWCNT) BYTE,
            PAGENO ADDRESS,
            LINEBUF(120) BYTE, TITLE(66) BYTE,  TITLELEN BYTE;
    DECLARE (GETNEW, ERRORCH, TOKENCNT) BYTE,
            (TOKEN$P, SYM$P)(8) ADDRESS,
            TOKEN BASED TOKEN$P (8) BYTE,
            SYM BASED SYM$P (8) BYTE,
            SYMWD BASED SYM$P (4) ADDRESS,
            (TOKEN$TYPE, TOKEN$LEN)(8) BYTE,
            END$WORKBUF$P ADDRESS;


    ISIS: PROCEDURE(CMD, PARAM$P);
        DECLARE CMD BYTE, PARAM$P ADDRESS;
        GOTO 40H;
    END ISIS;

    OPEN: PROCEDURE(CONN$P, PATH$P, ACCESS, ECHO, STATUS$P);
        DECLARE (CONN$P, PATH$P, ACCESS, ECHO, STATUS$P) ADDRESS;

        CALL ISIS(0, .CONN$P);
    END;

    CLOSE: PROCEDURE(CONN, STATUS$P);
        DECLARE (CONN, STATUS$P) ADDRESS;

        CALL ISIS(1, .CONN);
    END;

    READ: PROCEDURE(CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P) ADDRESS;

        CALL ISIS(3, .CONN);
    END;

    WRITE: PROCEDURE(CONN, BUFF$P, COUNT, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, STATUS$P) ADDRESS;

        CALL ISIS(4, .CONN);
    END;

    EXIT: PROCEDURE;
        DECLARE STATUS ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(9, .STATUS);
    END;

    ERROR: PROCEDURE(ERROR$NUM);
        DECLARE (ERROR$NUM, STATUS) ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(12, .ERROR$NUM);
    END;

    CHECKSTATUS: PROCEDURE;
        IF STATUS = 0 THEN
            RETURN;
        CALL ERROR(STATUS);
        CALL EXIT;
    END;

    BUFSKIPSPC: PROCEDURE;
        DECLARE CH BASED BUFFER$PTR BYTE;

        DO WHILE CH = ' ' AND BUFFER$PTR <> ENDBUF$PTR;
            BUFFER$PTR = BUFFER$PTR + 1;
        END;
    END;

    OPENFILE: PROCEDURE(ACCESS) ADDRESS;
        DECLARE ACCESS ADDRESS;
        DECLARE AFTN ADDRESS, PAD BYTE;
        DECLARE CH BASED BUFFER$PTR BYTE;

        CALL BUFSKIPSPC;
        CALL OPEN(.AFTN, BUFFER$PTR, ACCESS, 0, .STATUS);    
        CALL CHECKSTATUS;
        DO WHILE CH <> ' ' AND BUFFER$PTR <> ENDBUF$PTR;
            BUFFER$PTR = BUFFER$PTR + 1;
        END;
        CALL BUFSKIPSPC;
        RETURN AFTN;
    END;

    /* CHECK FOR TO (N = 1) OR LIST (N = 2) */
    CHK$TO$LIST: PROCEDURE(N);
        DECLARE N BYTE,  OFFSET BYTE;
        DECLARE KEYWORDS DATA ('TOLIST');
        DECLARE BUF BASED BUFFER$PTR (1) BYTE;

        OFFSET = 0;
        IF N = 4 THEN
            OFFSET = 2;
        DO II = 0 TO N - 1;
            IF BUF(II) <> KEYWORDS(II + OFFSET) THEN DO;
                STATUS = 0CBH;
                CALL CHECKSTATUS;
            END;
        END;
        BUFFER$PTR = BUFFER$PTR + N;
    END;

    READCH: PROCEDURE BYTE;
        DECLARE CH BYTE, ACTUAL ADDRESS, PAD BYTE;
        CALL READ(AFTIN, .CH, 1, .ACTUAL, .STATUS);
        IF ACTUAL = 0 THEN
            STATUS = 0CFH;
        CALL CHECKSTATUS;
        RETURN CH AND 7FH;
    END;

    WRITECH$CO: PROCEDURE(CH);
        DECLARE CH BYTE;
        CALL WRITE(0, .CH, 1, .STATUS);
        CALL CHECKSTATUS;
    END;

    WRITECH$HEX: PROCEDURE(CH);
        DECLARE CH BYTE;
        CALL WRITE(AFTHEX, .CH, 1, .STATUS);
        CALL CHECKSTATUS;
    END;

    WRITECH$LST: PROCEDURE(CH);
        DECLARE CH BYTE;
        CALL WRITE(AFTLST, .CH, 1, .STATUS);
        CALL CHECKSTATUS;
    END;

    MEMCHK: PROCEDURE ADDRESS;
        GOTO 0F81BH;
    END;


    HEX1: PROCEDURE(CH) BYTE;
        DECLARE CH BYTE;
        IF (CH := (CH AND 0FH) + '0') > '9' THEN
            CH = CH + 7;
        RETURN CH;
    END;

    WRITEHEX2$CO: PROCEDURE(N);
        DECLARE N BYTE;
        CALL WRITECH$CO(HEX1(ROR(N, 4)));
        CALL WRITECH$CO(HEX1(N));
    END;


    BUFCH$LST: PROCEDURE(CH);
        DECLARE CH BYTE;
        IF CH = LF THEN DO;
            CH = 0;
            DO WHILE CH < LINEEND;
                CH = CH + 1;
                CALL WRITECH$LST(LINEBUF(CH));
            END;
            LINEEND = 0;
            CALL WRITECH$LST(CR);
            CALL WRITECH$LST(LF);
        END;
        ELSE DO;
            IF CH >= ' ' THEN
                LINEBUF(LINECOL) = CH;
            IF LINECOL > LINEEND THEN
                LINEEND = LINECOL;
        END;
    END;

    ADDCH$LST: PROCEDURE(CH);
        DECLARE CH BYTE;
        DECLARE (SPACES, I) BYTE;

        IF CH = FF THEN DO;
            DO WHILE ROWCNT <> 0;
                IF (ROWCNT := ROWCNT + 1) = 66 THEN
                    ROWCNT = 0;
                CALL BUFCH$LST(LF);
            END;
            RETURN;
        END;   
        IF CH = CR THEN
            LINECOL = 0;
        IF CH = LF THEN
            ROWCNT = ROWCNT + 1;
        SPACES = CH = TAB AND (7 - (LINECOL AND 7));
        IF CH = TAB THEN
            CH = ' ';
        DO I = 0 TO SPACES;
            IF LINECOL < PAGEWIDTH THEN DO;
                LINECOL = LINECOL + (CH >= ' ' AND 1);
                CALL BUFCH$LST(CH);
            END;
        END;
    END;

    PUTCH$LST: PROCEDURE(CH);
        DECLARE CH BYTE;
        DECLARE (I, HDRCH, J) BYTE;
        DECLARE DIV ADDRESS, PAD BYTE;

        IF CH = FF OR NOT ROWCNT < 60 THEN DO;
            CALL ADDCH$LST(CR);
            CALL ADDCH$LST(FF);
            I = 0;
            DO WHILE (HDRCH := PAGEHEADER(I := I + 1)) <> 0;
                IF HDRCH = CR THEN DO;
                    DIV = 10000;
                    DO WHILE DIV > 0;
                        IF PAGENO >= DIV THEN
                            CALL ADDCH$LST(LOW(PAGENO / DIV MOD 10) + '0');
                        DIV = DIV / 10;
                    END;
                    CALL ADDCH$LST(CR);
                    CALL ADDCH$LST(LF);

                    DO J = 1 TO TITLELEN;
                        CALL ADDCH$LST(TITLE(J));
                    END;
                END;
                CALL ADDCH$LST(HDRCH);
            END;
                PAGENO = PAGENO + 1;
        END;
        IF CH <> FF THEN
            CALL ADDCH$LST(CH);
    END;


    DOPASS: PROCEDURE;
        RECORDERROR: PROCEDURE(CH);
            DECLARE CH BYTE;
            IF NOT ROR(SKIPIF(0),1) AND ERRORCH = ' ' THEN DO;
                ERRORCH = CH;
                IF PASS = 3 OR PASS = 2 THEN
                    ERRCNT = ERRCNT + 1;
            END;
        END;

        /* TREAT PTR AS POINTER TO AN ARRAY OF NIBBLES */
        /* INDEX INTO THIS ARRAY TO RETRIEVE THE NIBBLE */
        GETNIBBLEAT: PROCEDURE(PTR, N) BYTE;
            DECLARE PTR ADDRESS, N BYTE;
            DECLARE BA BASED PTR (1) BYTE;
            DECLARE TMP BYTE;
            TMP = BA(SHR(N, 1));
            IF N THEN
                TMP = ROR(TMP, 4);
            RETURN TMP AND 0FH;
        END;

        WRITEHEX2$HEX: PROCEDURE(N);
            DECLARE N BYTE;
            CALL WRITECH$HEX(HEX1(ROR(N, 4)));
            CALL WRITECH$HEX(HEX1(N));
        END;

        PUTHEX2$LST: PROCEDURE(N);
            DECLARE N BYTE;
            CALL PUTCH$LST(HEX1(ROR(N, 4)));
            CALL PUTCH$LST(HEX1(N));
        END;

        WRITEHEXREC$HEX: PROCEDURE(RECTYPE);
            DECLARE RECTYPE BYTE, I BYTE;

            CALL WRITECH$HEX(':');
            CALL WRITEHEX2$HEX(RECLEN);
            CALL WRITEHEX2$HEX(HIGH(RECADDR));
            CALL WRITEHEX2$HEX(LOW(RECADDR));
            CALL WRITEHEX2$HEX(RECTYPE);
            DO I = 1 TO RECLEN;
                CALL WRITEHEX2$HEX(RECBUF(I));
            END;
            CHECKSUM = CHECKSUM - HIGH(RECADDR) - LOW(RECADDR) - RECTYPE - RECLEN;
            CALL WRITEHEX2$HEX(CHECKSUM);
            CALL WRITECH$HEX(CR);
            CALL WRITECH$HEX(LF);
            CHECKSUM = 0;
            RECLEN = 0;
            MAXRECLEN = 16;
        END; 
                

        MKCODE: PROCEDURE(CODE);
            DECLARE CODE BYTE;
            
            IF (CODE AND 3) <> 0 THEN DO;
                IF ACC2HIGH <> 0 OR ACC2LOW > 7 OR (CODE AND ACC2LOW)
                   OR ((CODE AND 3) = 3 AND ACC2LOW > 2) THEN DO;
                    ACC2LOW = 0;
                    CALL RECORDERROR('R');
                END;

                IF ROR(CODE, 2) THEN
                    ACC2LOW = ROL(ACC2LOW, 3);

                ACC1LOW = ACC1LOW OR ACC2LOW;
            END;
            IF SHR(CODE, 3) THEN
                IF ACC2HIGH + 1 > 1 THEN
                    CALL RECORDERROR('V');

            IF (ACTION := SHR(CODE, 4) + 22H) = 22H THEN DO;
                IF ACC1HIGH > 0 THEN
                    CALL RECORDERROR('V');
                NEXT$TOK$TYPE = 6;
            END;
        END;

        /* NESTIF / UNNESTIF ROUTINES */
        /* LOCATION 0 HOLDS THE CURRENT ACCUM1(0) */
        /* PUSH COPIES CURRENT TO END OF LIST */
        /* POP COPIES END OF LIST TO CURRENT */
        UNNESTIF: PROCEDURE(STATE);
            DECLARE STATE BYTE;

            IF STATE <> IFSTATE(0) THEN DO;
                CALL RECORDERROR((STATE = 0FFH AND 5) + 'N');
                IF IFDEPTH > 1 THEN
                    IFDEPTH = 2;
            END;
            IF IFDEPTH > 1 THEN DO;
                SKIPIF(0) = SKIPIF(IFDEPTH);
                IFSTATE(0) = IFSTATE(IFDEPTH);
                IFDEPTH = IFDEPTH - 1;
            END;
        END;


        NESTIF: PROCEDURE(STATE);
            DECLARE STATE BYTE;
            IF ENDSEEN THEN
                RETURN;
            IF (IFDEPTH := IFDEPTH + 1) >= 8 THEN
                CALL UNNESTIF(0FFH);
            ELSE DO;
                SKIPIF(IFDEPTH) = SKIPIF(0);
                IFSTATE(IFDEPTH) = IFSTATE(0);
                IFSTATE(0) = STATE;
            END;
        END;


        WRITESYM$HEX: PROCEDURE;
            IF PASS = 3 THEN
                CALL PUTCH$LST(FF);

            MID$P = SYMTAB(1);
            DO WHILE MID$P < SYMTAB$END(1);
                IF PASS = 3 THEN DO;
                    IF (II := (II + 1) AND 3) = 1 THEN DO;
                        CALL PUTCH$LST(CR);
                        CALL PUTCH$LST(LF);
                    END;
                    DO JJ = 0 TO 4;
                        CALL PUTCH$LST(MIDSYM(JJ));
                    END;

                    CALL PUTCH$LST(' ');
                    CALL PUTHEX2$LST(MIDSYM(7));
                    CALL PUTHEX2$LST(MIDSYM(6));
                    IF MIDSYM(5) = 3 THEN
                        CALL PUTCH$LST('M');
                    CALL PUTCH$LST(TAB);
                END;
                ELSE DO;
                    CALL WRITECH$HEX('0');
                    CALL WRITECH$HEX(' ');
                    DO JJ = 0 TO 4;
                        CALL WRITECH$HEX(MIDSYM(JJ));
                    END;
                    CALL WRITECH$HEX(' ');
                    CALL WRITECH$HEX('0');
                    CALL WRITEHEX2$HEX(MIDSYM(7));
                    CALL WRITEHEX2$HEX(MIDSYM(6));
                    CALL WRITECH$HEX('H');
                    CALL WRITECH$HEX(CR);
                    CALL WRITECH$HEX(LF);
                END;
                MID$P = MID$P + 8;
            END;
            IF PASS = 3 THEN
                CALL ADDCH$LST(FF);
            ELSE DO;
                CALL WRITECH$HEX(' ');
                CALL WRITECH$HEX('$');
                CALL WRITECH$HEX(CR);
                CALL WRITECH$HEX(LF);
            END;
        END;

        GETCH:  PROCEDURE BYTE;
            IF GETNEW <> 0 THEN DO;
                DO WHILE (LASTCHREAD := READCH) = 0 OR LASTCHREAD = 07FH;
                END;
                IF PASS = 3 THEN
                    CALL PUTCH$LST(LASTCHREAD);
            END;
            GETNEW = 1;
            RETURN TOKID := LASTCHREAD;
        END; 

        /* CLASSIFY CHARACTER READ */
        /* 0 ILLEGAL */
        /* 1 WHITE SPACE TAB, LF, FF, SPACE */
        /* 2 SEMICOLON */
        /* 3 COLON */
        /* 4 CR */
        /* 5 ( ) * , -  / */
        /* 6 $ */
        /* 7 quote */
        /* 8 NUMERIC */
        /* 9 LETTER */

        CLASSIFY: PROCEDURE BYTE;
            DECLARE TABLE DATA(  0,   0,   0,   0, 10h,   1, 41h,   0,
                                 0,   0,   0,   0,   0,   0,   0,   0,
                                 1,   0,   6, 70h, 55h, 55h, 55h, 50h,
                               88h, 88h, 88h, 88h, 88h, 23h,   0,   0);
            IF GETCH > 7AH THEN       /* LOWER Z */
                RETURN 0;
            IF TOKID > 60H THEN         /* LOWER A - Z */
                RETURN 9;
            IF TOKID > 5AH THEN         /* > Z */
                RETURN 0;
            IF TOKID > 3EH THEN         /* @ - Z */
                RETURN 9;
            RETURN GETNIBBLEAT(.TABLE, TOKID);
        END; 

        PUSH$TOKEN: PROCEDURE(NEW$TOKEN$TYPE);
            DECLARE NEW$TOKEN$TYPE BYTE;
            IF (TOKENCNT := TOKENCNT + 1) >= 8 THEN DO;
                TOKENCNT = 2;
                CALL RECORDERROR('S');
            END;
            /* PUSH PREVIOUS TOKEN */
            TOKEN$P(TOKENCNT) = TOKEN$P(0);
            SYM$P(TOKENCNT) = SYM$P(0);
            TOKEN$TYPE(TOKENCNT) = TOKEN$TYPE(0);
            TOKEN$LEN(TOKENCNT) = TOKEN$LEN(0);
            /* NEW TOKEN STARTS JUST AFTER PREVIOUS ONE */
            TOKEN$P(0) = TOKEN$P(0) + TOKEN$LEN(0);
            SYM$P(0) = 0;
            TOKEN$TYPE(0) = NEW$TOKEN$TYPE;
            TOKEN$LEN(0) = 0;
        END;

        ADDCH$TOKEN: PROCEDURE(CH);
            DECLARE CH BYTE;
            IF TOKEN$P(0) + TOKEN$LEN(0) < END$WORKBUF$P THEN DO;
                TOKEN(TOKEN$LEN) = CH;
                TOKEN$LEN = TOKEN$LEN + 1;
            END;
            ELSE
                CALL RECORDERROR('T');
        END;
                

        POP$TOKEN: PROCEDURE;
            TOKEN$P(0) = TOKEN$P(TOKENCNT);
            SYM$P(0) = SYM$P(TOKENCNT);
            TOKEN$TYPE(0) = TOKEN$TYPE(TOKENCNT);
            TOKEN$LEN(0) = TOKEN$LEN(TOKENCNT);
            TOKENCNT = TOKENCNT - 1;
        END;


        GETID: PROCEDURE(NEW$TOKEN$TYPE);
            DECLARE NEW$TOKEN$TYPE BYTE;

            CALL PUSH$TOKEN(NEW$TOKEN$TYPE);
            GETNEW = GETNEW - 1;

            DO WHILE CLASSIFY > 7;
                IF TOKID > 40H THEN
                    TOKID = TOKID AND 0DFH;
                CALL ADDCH$TOKEN(TOKID);
            END;
            GETNEW = GETNEW - 1;
        END;

        PRECEDENCE: PROCEDURE(N) BYTE;
            DECLARE N BYTE, PAD BYTE;
            DECLARE TABLE DATA(  0,   0, 67h, 61h, 76h, 56h, 34h, 73h,
                               77h, 11h, 11h, 11h, 11h,   0, 11h, 11h,
                               11h, 11h, 11h, 11h, 11h, 11h, 11h);

            RETURN GETNIBBLEAT(.TABLE, N);
        END;

        /* LOOK UP TOKEN IN ONE OF THE TWO SYMBOL TABLES */ /* USING A BINARY SEARCH */
        /* SYMBOLS ARE STORED AS 8 BYTE ENTRIES
           NAME(5) BYTE,
           TYPE BYTE,
           ACCUM1(0) ADDRESS
        */
        LOOKUP: PROCEDURE(TABLEID) BYTE;
            DECLARE TABLEID BYTE;
            DECLARE CMP BYTE;

            LOW$P = SYMTAB(TABLEID);
            HIGH$P, MID$P = SYMTAB$END(TABLEID);
            DECLARE MIDCH BASED MID$P BYTE,
                    REFCH BASED REF$P BYTE,
                    SYM BASED SYM$P(0) BYTE;

            DO WHILE (REF$P := LOW$P + SHR((HIGH$P - LOW$P) AND 0FFF0H, 1)) <> MID$P;
                MID$P = REF$P;
                REF$P = TOKEN$P(0);
                DO WHILE (CMP := MIDCH - REFCH) = 0;
                    MID$P = MID$P + 1;
                    IF (REF$P := REF$P + 1) = TOKEN$P(0) + TOKEN$LEN THEN DO;
                        IF TOKEN$LEN = 5 OR MIDCH = ' ' THEN DO;
                            SYM$P(0) = MID$P - TOKEN$LEN;
                            TOKEN$TYPE = SYM(5);
                            IF TOKEN$TYPE = 2AH OR TOKEN$TYPE = 22H OR  /* IMM16, LXI */
                               TOKEN$TYPE = 13H OR TOKEN$TYPE = 14H OR  /* DS DW */
                               TOKEN$TYPE = 18H OR TOKEN$TYPE = 1DH OR  /* EQU ORT */
                               TOKEN$TYPE = 1EH THEN                    /* SET */
                                WORDOPERAND = 1;
                            RETURN TOKEN$TYPE;
                        END;
                        ELSE GOTO BREAK;
                    END;
                END;
            BREAK:
                MID$P = (MID$P - REF$P) + TOKEN$P(0);
                IF ROL(CMP, 1) THEN   /* SIGN TEST */
                    LOW$P = MID$P;
                ELSE
                    HIGH$P = MID$P;
                
            END;
            SYM$P(0) = HIGH$P;
            RETURN 0;
        END;

        DECLARE W396C ADDRESS;

        INSERTSYM: PROCEDURE(NEWTYPE, N);
            DECLARE (NEWTYPE, N) BYTE, I BYTE;
            IF TOKENCNT <> 1 THEN
                CALL RECORDERROR('F');
            ELSE DO;
                IF TOKEN$TYPE = 0 THEN DO;
                    IF (HIGH$P := (LOW$P := SYMHIGHMARK) + 8) >= ENDRAM THEN DO;
                        CALL RECORDERROR('T'); 
                        GOTO DONE;
                    END;
                    ELSE DO;
                        SYMHIGHMARK = HIGH$P;
                        SYMTAB$END(N) = SYMTAB$END(N) + 8;
                        DO WHILE LOW$P >= SYM$P;
                            HIGHWD = LOWWD;
                            HIGH$P = HIGH$P - 2;
                            LOW$P = LOW$P - 2;
                        END;
                        DO I = 0 TO 4;                        
                            N = ' ';
                            IF TOKEN$LEN > I THEN
                                N = TOKEN(I);
                            SYM(I) = N;
                        END;
                        TOKEN$TYPE = NEWTYPE;
                    END;
                END;
                ELSE IF (TOKEN$TYPE <> 4 OR TOKEN$TYPE <> NEWTYPE) AND PASS = 1 THEN
                    TOKEN$TYPE = 3;
                ELSE IF TOKEN$TYPE <> 4 THEN
                    IF SYMWD(3) <> W396C THEN
                        CALL RECORDERROR(((TOKEN$TYPE <> 3) AND 3) + 'M' + ((SYM$P(0) = 0) AND 1));
                IF SYM$P <> 0 THEN DO;
                    SYM(5) = TOKEN$TYPE;
                    IF TOKEN$TYPE = NEWTYPE THEN
                        SYMWD(3) = W396C;
                END;
        DONE:
                CALL POP$TOKEN;
            END;
        END;

        GETNUMVAL: PROCEDURE ADDRESS;
            ACCUM1 = 0;
            IF TOKENCNT < 1 THEN
                CALL RECORDERROR('F');
            ELSE DO;
                IF TOKEN$TYPE <> 0 THEN
                    ;
                ELSE
                    TOKEN$TYPE = LOOKUP(1);
                IF TOKEN$TYPE = 0 THEN
                    CALL RECORDERROR('U');
                ELSE DO;
                    IF TOKEN$TYPE <= 4 THEN DO;
                        TOKEN$P(0) = SYM$P +  6;
                        TOKEN$LEN = 2;
                    END;
                    ELSE IF TOKEN$LEN > 2 THEN
                        CALL RECORDERROR('V');
                    ACC1LOW = TOKEN(0);
                    IF TOKEN$LEN > 1 THEN
                        ACC1HIGH = TOKEN(1);
                    /* SEE IF NEED TO SWAP HIGH AND LOW BYTES */
                    IF TOKEN$TYPE = 5 AND WORDOPERAND AND TOKEN$LEN = 2 THEN DO;
                        NUMTMP = ACC1LOW;
                        ACC1LOW = ACC1HIGH;
                        ACC1HIGH = NUMTMP;
                    END;
                END;
            CALL POP$TOKEN;
            END;
            RETURN ACCUM1(0);
        END;

        DECLARE WORKBUF(66) BYTE;
                

        IF PASS = 2 THEN
            CALL WRITESYM$HEX;
        WORDOPERAND = 0;
        HAVETITLE = 0;
        SKIPIF(0) = 0;
        ADDR = 0;
        SHOWADDR = 0;
        ERRCNT = 0;
        SYMTAB(0) = ITABLE$P;
        SYMTAB$END(0) = MEMORY$P;
        IF PASS = 1 THEN DO;
            ENDRAM = MEMCHK + 250;          /* USE THE MONITOR RAM ASWELL */
            SYMTAB(1), SYMTAB$END(1) = MEMORY$P + 2;
            SYMHIGHMARK = SYMTAB$END(0);    /* NO SYMBOLS YET */
            TITLELEN = 0;
        END;
        IF PASS = 3 THEN DO;
            ROWCNT = 0;
            LINECOL = 0;
            LINEEND = 0;
            PAGENO = 1;
            PAGEWIDTH = 120;
            CALL WRITECH$LST(0Ch);
            CALL PUTCH$LST(0Ch);
        END;
        ERRORCH = ' ';
        RECLEN = 0;
        CHECKSUM = 0;
        ENDSEEN = 0;
        GETNEW = 0;
        TOKENCNT = 0;
        IFDEPTH = 0;
        TOKEN$LEN = 0;
        TOKEN$TYPE = 0;
        OPSP = 0;
        OPSTACK(0) = 0;
        PC = 0;
        RECADDR = 0;
        LASTCHREAD = CR;
        MAXRECLEN = 16;
        CALL NESTIF(2);
        PC = 0;
        RECADDR = 0;
        END$WORKBUF$P = (TOKEN$P(0) := .WORKBUF) + 66;
        NEWACTION = 1;


COLLECTLOOP:
        IF NEWACTION = 0 THEN
            CALL RECORDERROR('E');

        NEWACTION = 0;
LOOP:
        DO CASE CLASSIFY;
            DO;                         /* CASE 0 ILLEGAL */
                CALL RECORDERROR('I');
                GOTO LOOP;
            END;
            GOTO LOOP;                  /* CASE 1 WHITESPACE */
            DO;                         /* CASE 2 SEMICOLON  */
                DO WHILE CLASSIFY <> 4;
                END;
                TOKID = 1;
            END;
            DO;                         /* CASE 3 COLON */
                NEWACTION = 1;
                IF SKIPIF(0) THEN DO;
                    IF NOT B37C8 THEN
                        CALL POP$TOKEN;
                END;
                ELSE DO;
                    W396C = PC;
                    CALL INSERTSYM(2, 1);
                END;
                GOTO LOOP;
            END;
            DO;                         /* CASE 4 CR */
                TOKID = 1;
            END;
            DO;                         /* CASE 5 ( ) *, - / */
                IF (TOKID = '+' OR TOKID = '-') AND NEWACTION <> 0 AND NEWACTION <> 3 THEN
                    TOKID = TOKID + 3;
                TOKID = TOKID - '(' + 2;
            END;
            DO;                         /* CASE 6 $ */
                CALL PUSH$TOKEN(7);
                CALL ADDCH$TOKEN(LOW(PC));
                CALL ADDCH$TOKEN(HIGH(PC));
                GOTO COLLECTLOOP;
            END;
            DO;                         /* CASE 7 QUOTE */
                CALL PUSH$TOKEN(5);
                DO WHILE GETCH <> CR;
                    IF TOKID = '''' THEN
                        IF GETCH <> '''' THEN
                            GOTO GOTSTRING;
                    CALL ADDCH$TOKEN(TOKID);
                END;
                CALL RECORDERROR('B');
    GOTSTRING:
                GETNEW = GETNEW - 1; 
                GOTO COLLECTLOOP;
            END;
            DO;                         /* CASE 8 NUMBER */
                CALL GETID(7); 
                IF (RADIX := TOKEN(TOKEN$LEN := TOKEN$LEN - 1)) = 'H' THEN
                    RADIX = 16;
                IF RADIX = 'O' THEN
                    RADIX = 8;
                IF RADIX = 'Q' THEN
                    RADIX = 8;
                IF RADIX = 'B' THEN
                    RADIX = 2;
                IF RADIX = 'D' THEN
                    RADIX = 10;
                IF RADIX > 16 THEN
                    RADIX = 10;
                ELSE
                    TOKEN$LEN = TOKEN$LEN - 1;
                ACCUM1(0) = 0;
                DO II = 0 TO TOKEN$LEN;
                    IF (TOKID := TOKEN(II) - '0') > 9 THEN
                        TOKID = TOKID - 7;
                    IF TOKID >= RADIX THEN DO;
                        TOKID = 0;
                        CALL RECORDERROR('I');
                    END;
                    ACCUM1(0) = ACCUM1(0) * RADIX + TOKID;
                END;
                TOKEN$LEN = 0;
                CALL ADDCH$TOKEN(LOW(ACCUM1(0)));
                CALL ADDCH$TOKEN(HIGH(ACCUM1(0)));
                GOTO COLLECTLOOP;
            END;
            DO;                     /* CASE 9 LETTER */
                CALL GETID(0);
                IF TOKEN$LEN > 5 THEN
                    TOKEN$LEN = 5;
                IF  LOOKUP(0) = 0 THEN
                    TOKEN$TYPE = LOOKUP(1);
                IF (TOKID := TOKEN$TYPE) >= 31 THEN
                    TOKEN$TYPE = 2;
                IF TOKEN$TYPE > 10 THEN
                    CALL POP$TOKEN;
                IF TOKID > 4 THEN
                    GOTO HANDLEOP;
                GOTO COLLECTLOOP;
            END;
        END;    /* OF CASE */

                
DECLARE BA2DA2 DATA(  0, 80h,   0,   0, 0Fh, 0Fh,   0, 0Fh,
                    0Dh, 0Fh, 0Dh, 0Dh, 0Fh, 0Fh, 0Fh, 0Fh,
                    0Fh, 0Fh, 40h,   1, 4Dh, 80h, 80h, 80h,
                      1, 81h, 80h, 40h, 40h,   1,   1, 40h,
                    40h, 40h, 47h,   7,   7,   7, 17h, 47h,
                      7, 47h, 37h,   5);

HANDLEOP:
        IF BA2DA2(TOKID) < 80H AND SKIPIF(0) THEN
            GOTO LOOP;
        IF PRECEDENCE(NEWACTION := TOKID) > PRECEDENCE(ACTION := OPSTACK(OPSP)) OR NEWACTION = 2 THEN DO;
            OPSTACK(OPSP := OPSP + 1) = NEWACTION;
            GOTO LOOP;
        END;
        IF ACTION = 0 THEN
            ACTION = NEWACTION;
        ELSE
            OPSP = OPSP - 1;
        IF (CUR$OP$FLAGS := BA2DA2(ACTION)) THEN
            ACCUM2(0) = GETNUMVAL;
        IF (CUR$OP$FLAGS := ROR(CUR$OP$FLAGS, 1)) THEN
            ACCUM1(0) = GETNUMVAL;
        NEXT$TOK$TYPE = 7;
        DO CASE ACTION;
        ;               /* CASE 0 */
        DO;             /* CASE 1 */
            REF$P = TOKEN$P(0) + TOKEN$LEN;
            IF SKIPIF(0) THEN
                REF$P = .WORKBUF;
            DO WHILE TOKENCNT > 0;
                IF TOKEN$TYPE <> 6 THEN
                    CALL RECORDERROR('Q');
                CALL POP$TOKEN;
            END;
            MID$P = .WORKBUF;
            II = 1;
            IF PASS = 3 THEN DO;
                DO WHILE II;
                    CALL PUTCH$LST(0Dh);
                    CALL PUTCH$LST(0);
                    CALL PUTCH$LST(ERRORCH); 
                    CALL PUTCH$LST(20h);
                    IF (SHOWADDR := MID$P <> REF$P OR SHOWADDR) THEN DO;
                        CALL PUTHEX2$LST(HIGH(ADDR));
                        CALL PUTHEX2$LST(LOW(ADDR));
                    END;
                    SHOWADDR = SHL(NOT SHOWADDR AND 1, 2);
                    DO JJ = 0 TO SHOWADDR;
                        CALL PUTCH$LST(' ');
                    END;
                    DO JJ = 1 TO 4;
                        IF MID$P < REF$P THEN
                            CALL PUTHEX2$LST(MIDCH);
                        ELSE DO;
                            CALL PUTCH$LST(' ');
                            CALL PUTCH$LST(' ');
                        END;
                        II = (MID$P := MID$P + 1) < REF$P;
                    END;
                    IF II THEN
                        CALL PUTCH$LST(LF);
                    ADDR = ADDR + 4;
                END;
            END;    /* PASS 3 */
            IF PASS = 2 THEN DO;
                MID$P = .WORKBUF;
                IF RECADDR + RECLEN <> PC OR ENDSEEN THEN DO;
                    IF RECLEN > 0 THEN
                        CALL WRITEHEXREC$HEX(0);
                    RECADDR = PC;
                END;
                DO WHILE MID$P < REF$P; 
                    IF RECLEN = MAXRECLEN THEN DO;
                        CALL WRITEHEXREC$HEX(0);
                        RECADDR = RECADDR + 16;
                    END;
                    CHECKSUM = CHECKSUM - (RECBUF(RECLEN := RECLEN + 1) := MIDCH);
                    MID$P = MID$P + 1;
                END; 
                IF ENDSEEN THEN
                    CALL WRITEHEXREC$HEX(1);
            END;     /* PASS 2 */
            ADDR, PC = PC + REF$P - .WORKBUF;
            SHOWADDR = 0;
            WORDOPERAND = 0;
            ERRORCH = ' ';
            OPSP = 0;
            SKIPIF(0) = SKIPIF(0) > 0;
            IF ENDSEEN THEN DO;
                ENDSEEN = 0;
                IF PASS = 3 THEN
                    CALL WRITESYM$HEX;
                RETURN;
            END; 
            GOTO LOOP;
        END;
        GOTO CASE$3;            /* CASE 2 ) */
CASE$3: DO;                     /* CASE 3 ( */
            IF NOT (ACTION = 2 AND NEWACTION = 3) THEN
                CALL RECORDERROR('B');
            IF TOKEN$TYPE  = 6 THEN
                TOKEN$LEN = 1;
            IF NEWACTION = 3 THEN
                GOTO LOOP; 
        END;
        ACCUM1(0) = ACCUM1(0) * ACCUM2(0);  /* CASE 4 * */
        ACCUM1(0) = ACCUM1(0) + ACCUM2(0);  /* CASE 5 + */ 
        CALL RECORDERROR('F');              /* CASE 6 , */
        ACCUM1(0) = ACCUM1(0) - ACCUM2(0);  /* CASE 7 - */
        ;                                   /* CASE 8 UNARY + */
        ACCUM1(0) = ACCUM1(0) / ACCUM2(0);  /* CASE 9  / */
        ACCUM1(0) = -ACCUM1(0);             /* CASE 10 UNARY - */
        ACCUM1(0) = NOT ACCUM1(0);          /* CASE 11 NOT */
        ACCUM1(0) = ACCUM1(0) AND ACCUM2(0); /* CASE 12 AND */
        ACCUM1(0) = ACCUM1(0) OR ACCUM2(0);  /* CASE 13 OR */
        ACCUM1(0) = ACCUM1(0) XOR ACCUM2(0); /* CASE 14 XOR */
        ACCUM1(0) = ACCUM1(0) MOD ACCUM2(0); /* CASE 15 MOD */
        DO;                                  /* CASE 16 SHL */
            IF ACC2LOW <> 0 THEN
            ACCUM1(0) = SHL(ACCUM1(0), ACC2LOW);
        END;
        DO;                                  /* CASE 17 SHR */
            IF ACC2LOW <> 0 THEN
            ACCUM1(0) = SHR(ACCUM1(0), ACC2LOW);
        END;
        DO;                                 /* CASE 18 DB */
            IF TOKEN$TYPE <> 5 AND TOKEN$TYPE <> 6 THEN DO;
                ACCUM1(0) = GETNUMVAL;
                IF ACC1HIGH -1  < 0FEH THEN 
                    CALL RECORDERROR('V');
                CUR$OP$FLAGS = 22H;
            END;
            TOKEN$TYPE = 6;
            NEXT$TOK$TYPE = 6;
        END;
        DO;                                 /* CASE 19 DS */
            SHOWADDR = 1;
            PC = PC + ACCUM2(0);            /* EXPECTED ACCUM1 */
            GOTO HANDLEOP;
        END;
        NEXT$TOK$TYPE = 6;                          /* CASE 20 DW */
        DO;                                 /* CASE 21 END */
            PC = 0;
            ACCUM1(0) = 0;
            IF TOKENCNT > 0 THEN
                PC = GETNUMVAL;
            SHOWADDR = 1;
            ENDSEEN = 1;
            SKIPIF(0) = 0;
            CALL UNNESTIF(2);
        END;
        CALL UNNESTIF(0);                   /* CASE 22 ENDIF */
        ;                                   /* CASE 23 */
        DO;                                 /* CASE 24 EQU */
            SHOWADDR = 1;
            W396C = ACCUM1(0);
            CALL INSERTSYM(2, 1);
        END;
        DO;                                 /* CASE 25 IF */
            CALL NESTIF(0);
            SKIPIF(0) = IFDEPTH > 1 AND (((ACCUM1(0) = 0) AND 1) OR SKIPIF(0));
        END;
        ;                           /* CASE 26 */
        ;                           /* CASE 27 */
        ;                           /* CASE 28 */
        DO;                         /* CASE 29 ORG */
            SHOWADDR = 1;
            PC = ACCUM1(0);
        END;
        DO;                         /* CASE 30 SET */
            IF LOOKUP(1) <> 4 AND TOKEN$TYPE <> 0 THEN
                CALL RECORDERROR('M');
            SHOWADDR = 1;
            W396C = ACCUM1(0);
            CALL INSERTSYM(4, 1);
        END;
        DO;                         /* CASE 31 TITLE */
            IF NEWACTION = 1 THEN DO;
                IF PASS <> 1 OR NOT HAVETITLE THEN DO;
                    REF$P = .WORKBUF + 5;
                    TITLELEN = 0;
                    DO WHILE TOKEN$P(0) + TOKEN$LEN > REF$P;
                        IF TITLELEN < 66 AND (II := REFCH) <> FF THEN
                            TITLE(TITLELEN := TITLELEN + 1) = II;
                        REF$P = REF$P + 1;
                    END;
                END; 
                DO WHILE TOKENCNT > 0;
                    CALL POP$TOKEN;
                END;
                IF PASS = 1 THEN
                    HAVETITLE = 1;
            END;
        END;
        ;                          /* CASE 32 */
        ;                          /* CASE 33 */
        CALL MKCODE(85h);          /* CASE 34 */
        CALL MKCODE(5);            /* CASE 35 */
        CALL MKCODE(7);            /* CASE 36 */
        CALL MKCODE(2);            /* CASE 37 */
        CALL MKCODE(8);            /* CASE 38 */
        CALL MKCODE(46h);          /* CASE 39 */
        CALL MKCODE(6);            /* CASE 40 */
        CALL MKCODE(36h);          /* CASE 41 */
        CALL MKCODE(0);            /* CASE 42 */
        CALL MKCODE(0);            /* CASE 43 */
        END; /* END OF CASE */
        IF SHOWADDR THEN
            ADDR = ACCUM1(0);
        IF (CUR$OP$FLAGS AND 1EH) <> 0 THEN
            CALL PUSH$TOKEN(NEXT$TOK$TYPE);
        DO II = 0 TO 3;
            IF (CUR$OP$FLAGS := ROR(CUR$OP$FLAGS, 1)) THEN
                CALL ADDCH$TOKEN(ACC1B(II));
        END;
        IF ROR(CUR$OP$FLAGS, 1) THEN
            IF NEWACTION = 6 THEN
                TOKID = ACTION;
        GOTO HANDLEOP;
    END;
    

        DECLARE ITABLE(840) BYTE INITIAL(
                'A    ',     3,     7,     0,
                'ACI  ',   26h,  0CEh,     0,
                'ADC  ',   25h,   88h,     0,
                'ADD  ',   25h,   80h,     0,
                'ADI  ',   26h,  0C6h,     0,
                'ANA  ',   25h,  0A0h,     0,
                'AND  ',   0Ch,     0,     0,
                'ANI  ',   26h,  0E6h,     0,
                'B    ',     3,     0,     0,
                'C    ',     3,     1,     0,
                'CALL ',   2Ah,  0CDh,     0,
                'CC   ',   2Ah,  0DCh,     0,
                'CM   ',   2Ah,  0FCh,     0,
                'CMA  ',   2Bh,   2Fh,     0,
                'CMC  ',   2Bh,   3Fh,     0,
                'CMP  ',   25h,  0B8h,     0,
                'CNC  ',   2Ah,  0D4h,     0,
                'CNZ  ',   2Ah,  0C4h,     0,
                'CP   ',   2Ah,  0F4h,     0,
                'CPE  ',   2Ah,  0ECh,     0,
                'CPI  ',   26h,  0FEh,     0,
                'CPO  ',   2Ah,  0E4h,     0,
                'CZ   ',   2Ah,  0CCh,     0,
                'D    ',     3,     2,     0,
                'DAA  ',   2Bh,   27h,     0,
                'DAD  ',   23h,     9,     0,
                'DB   ',   12h,     0,     0,
                'DCR  ',   28h,     5,     0,
                'DCX  ',   23h,   0Bh,     0,
                'DI   ',   2Bh,  0F3h,     0,
                'DS   ',   13h,     0,     0,
                'DW   ',   14h,     0,     0,
                'E    ',     3,     3,     0,
                'EI   ',   2Bh,  0FBh,     0,
                'END  ',   15h,     0,     0,
                'ENDIF',   16h,     0,     0,
                'EQU  ',   18h,     0,     0,
                'H    ',     3,     4,     0,
                'HLT  ',   2Bh,   76h,     0,
                'IF   ',   19h,     0,     0,
                'IN   ',   26h,  0DBh,     0,
                'INR  ',   28h,     4,     0,
                'INX  ',   23h,     3,     0,
                'JC   ',   2Ah,  0DAh,     0,
                'JM   ',   2Ah,  0FAh,     0,
                'JMP  ',   2Ah,  0C3h,     0,
                'JNC  ',   2Ah,  0D2h,     0,
                'JNZ  ',   2Ah,  0C2h,     0,
                'JP   ',   2Ah,  0F2h,     0,
                'JPE  ',   2Ah,  0EAh,     0,
                'JPO  ',   2Ah,  0E2h,     0,
                'JZ   ',   2Ah,  0CAh,     0,
                'L    ',     3,     5,     0,
                'LDA  ',   2Ah,   3Ah,     0,
                'LDAX ',   24h,   0Ah,     0,
                'LHLD ',   2Ah,   2Ah,     0,
                'LXI  ',   22h,     1,     0,
                'M    ',     3,     6,     0,
                'MOD  ',   0Fh,     0,     0,
                'MOV  ',   29h,   40h,     0,
                'MVI  ',   27h,     6,     0,
                'NOP  ',   2Bh,     0,     0,
                'NOT  ',   0Bh,     0,     0,
                'OR   ',   0Dh,     0,     0,
                'ORA  ',   25h,  0B0h,     0,
                'ORG  ',   1Dh,     0,     0,
                'ORI  ',   26h,  0F6h,     0,
                'OUT  ',   26h,  0D3h,     0,
                'PCHL ',   2Bh,  0E9h,     0,
                'POP  ',   23h,  0C1h,     0,
                'PSW  ',     3,     6,     0,
                'PUSH ',   23h,  0C5h,     0,
                'RAL  ',   2Bh,   17h,     0,
                'RAR  ',   2Bh,   1Fh,     0,
                'RC   ',   2Bh,  0D8h,     0,
                'RET  ',   2Bh,  0C9h,     0,
                'RLC  ',   2Bh,     7,     0,
                'RM   ',   2Bh,  0F8h,     0,
                'RNC  ',   2Bh,  0D0h,     0,
                'RNZ  ',   2Bh,  0C0h,     0,
                'RP   ',   2Bh,  0F0h,     0,
                'RPE  ',   2Bh,  0E8h,     0,
                'RPO  ',   2Bh,  0E0h,     0,
                'RRC  ',   2Bh,   0Fh,     0,
                'RST  ',   28h,  0C7h,     0,
                'RZ   ',   2Bh,  0C8h,     0,
                'SBB  ',   25h,   98h,     0,
                'SBI  ',   26h,  0DEh,     0,
                'SET  ',   1Eh,     0,     0,
                'SHL  ',   10h,     0,     0,
                'SHLD ',   2Ah,   22h,     0,
                'SHR  ',   11h,     0,     0,
                'SP   ',     3,     6,     0,
                'SPHL ',   2Bh,  0F9h,     0,
                'STA  ',   2Ah,   32h,     0,
                'STAX ',   24h,     2,     0,
                'STC  ',   2Bh,   37h,     0,
                'SUB  ',   25h,   90h,     0,
                'SUI  ',   26h,  0D6h,     0,
                'TITLE',   1Fh,     0,     0,
                'XCHG ',   2Bh,  0EBh,     0,
                'XOR  ',   0Eh,     0,     0,
                'XRA  ',   25h,  0A8h,     0,
                'XRI  ',   26h,  0EEh,     0,
                'XTHL ',   2Bh,  0E3h,     0);
        DECLARE PAD3CFC ADDRESS, LASTADDRESS ADDRESS;

MAIN:
    CALL READ(1, .BUFFER, 80, .ENDBUF$PTR, .STATUS);
    BUFFER$PTR = .BUFFER;
    CALL CHECKSTATUS;
    ENDBUF$PTR = ENDBUF$PTR + .BUFFER;
    ITABLE$P = .ITABLE;
    MEMORY$P = .LASTADDRESS;
    CALL WRITECH$CO(CR);
    II = 0;
    DO WHILE (JJ := PAGEHEADER(II := II + 1)) <> TAB;
        CALL WRITECH$CO(JJ);
    END; 
    DO PASS = 1 TO 3;
        DO CASE PASS; 
        ;                /* CASE 0 */
        DO;              /* CASE 1 */
            IN$NAME = BUFFER$PTR;
            AFTIN = OPENFILE(1);
            CALL CHK$TO$LIST(2);   /* CHECK FOR TO */
        END;
        DO;              /* CASE 2 */
            AFTHEX = OPENFILE(2);
            CALL CHK$TO$LIST(4);    /* CHECK FOR LIST */
            LST$NAME = BUFFER$PTR;
            IF AFTHEX = 0FFH THEN
                GOTO CONTINUE;
        END;
        DO;
            CALL CLOSE(AFTHEX, .STATUS);
            CALL CHECKSTATUS;
            IF (AFTLST := OPENFILE(2)) = 0FFH THEN
                GOTO CONTINUE;
        END;
        END; /* OF CASE */
        IF PASS > 1 THEN DO;
            CALL CLOSE(AFTIN, .STATUS);
            CALL CHECKSTATUS;
            BUFFER$PTR = IN$NAME;
            AFTIN = OPENFILE(1);
            BUFFER$PTR = LST$NAME;
        END;
        CALL DOPASS;
CONTINUE:
    END;

    IF ERRCNT = 0 THEN
        CALL WRITE(0, .ASMCOMPLETE, 41, .STATUS);
    ELSE DO;
        CALL WRITE(0, .ASMCOMPLETE, 22, .STATUS);
        CALL WRITEHEX2$CO(ERRCNT);
        CALL WRITECH$CO('H');
        CALL WRITE(0, .ASMCOMPLETE + 24, 17, .STATUS);
    END;
    CALL EXIT;
EOF
