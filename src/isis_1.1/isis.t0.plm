/*
    THE SOURCE BELOW NEEDS TO BE COMPILED WITH THE FORTRAN CROSS COMPILER
    UNFORTUNATELY INTEL SEEM TO HAVE USED A LATER VERSION THAT SUPPORTED
    'AT' AND DID NOT FILL UNINITIALISED DATA WITH ZEROS

    THE PERL ROUTINE LOADANDFIX.PL LOADS THE HEX FILE CREATED, 
    AND REPLACES UNITIALISED AND DATA PAST MEMORY WITH THE
    BYTES IN THE ORIGINAL ISIS.T0 FILE
*/
3000H: DO; 

    DECLARE BOOLEAN LITERALLY 'BYTE';
    DECLARE TRUE    LITERALLY '0FFH';
    DECLARE CMSK    LITERALLY '0FCH';
    DECLARE CR  LITERALLY '0DH',
            LF  LITERALLY '0AH';

    DECLARE T0VER DATA(1, 19H);     /* ISIS.T0 VERSION ? */
    DECLARE COPYRIGHT DATA('COPYRIGHT (C) INTEL 1975,1976');

    DECLARE VERSION$LEVEL   LITERALLY   'BYTE$AT(3EH)',
            EDIT$LEVEL      LITERALLY   'BYTE$AT(3FH)';

    DECLARE (USER$STATUS, USER$STACKPTR, START$ADDR) ADDRESS;
    DECLARE A$DEVICE BYTE;
    DECLARE MEMBASE ADDRESS INITIAL(0);
    DECLARE BYTE$AT BASED MEMBASE (1) BYTE;

    DECLARE TEMP BYTE;
    DECLARE ISIS$SIGNON(13) BYTE INITIAL(CR, LF, '16K ISIS, V'),
            SIGN$V(2) BYTE INITIAL(0, 0), /* VERSION NUMBER */
            SIGN$DOT(1) BYTE INITIAL('.'),
            SIGN$E(2) BYTE INITIAL(0, 0),  /* EDIT NUMBER */
            SIGN$CRLF(2) BYTE INITIAL (CR, LF);


    ISIS: PROCEDURE(CMD, PARAM$P);
        DECLARE CMD BYTE, PARAM$P ADDRESS;
        GOTO 40H;
    END ISIS;

    READ: PROCEDURE(CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, ACTUAL$P, STATUS$P) ADDRESS;

        CALL ISIS(3, .CONN);
    END;

    WRITE: PROCEDURE(CONN, BUFF$P, COUNT, STATUS$P);
        DECLARE (CONN, BUFF$P, COUNT, STATUS$P) ADDRESS;

        CALL ISIS(4, .CONN);
    END;

    EXIT: PROCEDURE;
        DECLARE STATUS ADDRESS;

        STATUS = .STATUS;
        CALL ISIS(9, .STATUS);
    END;

    NUMOUT: PROCEDURE(VALUE, BASE, LC, BUFADR, WIDTH);
        DECLARE (VALUE, BUFADR) ADDRESS, (BASE, LC, WIDTH) BYTE; 
        DECLARE DIGITS DATA('0123456789ABCDEF');
        DECLARE I BYTE;
        DECLARE BUF BASED BUFADR (1) BYTE;

        DO I = 1 TO WIDTH;
            BUF(WIDTH - I) = DIGITS(VALUE MOD BASE);
            VALUE = VALUE / BASE;   
        END;

        I = 0;
        DO WHILE BUF(I) = '0' AND I < WIDTH - 1;
            BUF(I) = LC;
            I = I + 1;
        END;
    END;



    /* THE FOLLOWING VARIABLES ARE USED IN THE ERR PROCEDURE */
    DECLARE FDCC$ERROR$TYPE(0) ADDRESS, (FDCC$ERROR$LOW, FDCC$ERROR$HIGH) BYTE;
                                    /* HAS DATA ON DISK I/O ERRORS */
    DECLARE JUNK ADDRESS INITIAL(0);
    DECLARE ABORT BYTE INITIAL(0FFH);   /* TRUE IF ABORT ON ERR */
    DECLARE DEBUG$TOGGLE BOOLEAN;   /* GOVERNES ACTION WHEN ERROR OCCURS */

    /* USEFUL LITERALS */
    DECLARE WARNING LITERALLY '0',
            MESSAGE LITERALLY '1';

    DECLARE DISK$IO$ERROR   LITERALLY   '18H',
            DRIVE$NOT$READY LITERALLY   '1EH';

    DECLARE ISIS$HDR$BLK LITERALLY   '204H';


    DECLARE RTC LITERALLY '0FFH';   /* REAL TIME CLOCK */
    DECLARE BOOT LITERALLY '2';
    /* INPUT FROM RTC IS A BYTE. THE SECOND BIT FROM THE RIGHT
       CORRESPONDS TO THE BOOT SWITCH. IF THIS BIT IS 1 THE SWITCH IS
       ON, AND IF IT IS 0 THE  SWITCH IS OFF.
    */

    DECLARE MDSMON  LITERALLY   '0',
            BTSTRP  LITERALLY   '8';


    CI: PROCEDURE BYTE;
        GOTO 0F803H;
    END;

    RI: PROCEDURE BYTE;
        GOTO 0F806H;
    END;

    CO: PROCEDURE(C);
        DECLARE C BYTE;
        GOTO 0F809H;
    END;

    PO: PROCEDURE(C);
        DECLARE C BYTE;
        GOTO 0F80CH;
    END;

    LO: PROCEDURE(C);
        DECLARE C BYTE;
        GOTO 0F80FH;
    END;

    IOCHK: PROCEDURE BYTE;
        GOTO 0F815H;
    END;

    IOSET: PROCEDURE(C);
        DECLARE C BYTE;
        GOTO 0F818H;
    END;


    
    DECLARE INITIO$BASE ADDRESS INITIAL(6), INITIO BASED INITIO$BASE BYTE;

    HEXOUT: PROCEDURE(VALUE, BUFADR, WIDTH);
        DECLARE (VALUE, BUFADR) ADDRESS, WIDTH BYTE;
        DECLARE CH BASED BUFADR BYTE;
        DECLARE DIGITS(16) BYTE INITIAL('0123456789ABCDEF');

        BUFADR = BUFADR + WIDTH;
        DO WHILE WIDTH <> 0;
            WIDTH = WIDTH - 1;
            BUFADR = BUFADR - 1;
            CH = DIGITS(VALUE AND 0FH);
            VALUE = SHR(VALUE, 4); 
        END;
    END;

    SETDEV: PROCEDURE;
        CALL IOSET((IOCHK AND CMSK) OR (INITIO AND 3));
    END;

    /*
       THE ERR PROCEDURE IS USED TO HANDLE ERROR CONDIITONS.
           AN ERROR MESSAGE IS ISSUED TO THE CONSOLE, WHICH FOR
           DISK ERRORS HAS EXTENDED CONTENT
       CONTROL THEN PASSES TO THE MDS MONITOR

       ERROR$TYPE IS THE ERROR NUMBER WHICH IDENTIFIES THE PARTICUALAR
              TYPE OF ERROR, SUCH AS DISK I/O ERROR
    */

    ERR: PROCEDURE(ERROR$TYPE);
        DECLARE ERROR$TYPE BYTE;
        DECLARE PC BASED USER$STACK$PTR ADDRESS;
        DECLARE I BYTE INITIAL(0);
        DECLARE IMAX BYTE INITIAL(25);
        DECLARE MSG1(8) BYTE INITIAL(CR, LF, 'ERROR '),
                MSG2(3) BYTE INITIAL(0, 0, 0),     /* ERROR NUMBER GOES HERE */
                MSG3(9) BYTE INITIAL(' USER PC '),
                MSG4(4) BYTE INITIAL(0, 0, 0, 0),  /* USER PC IN HEX GOES HERE */
                MSG5(2) BYTE INITIAL(CR, LF),
                MSG6(5) BYTE INITIAL('FDCC='),
                MSG7(4) BYTE INITIAL(0, 0, 0, 0), /* FDCC ERROR DATA GOES HERE */
                MSG8(2) BYTE INITIAL(CR, LF);

        CALL HEXOUT(ERROR$TYPE, .MSG2, 3);
        CALL HEXOUT(PC,.MSG4,4);
        CALL SETDEV;

        IF ERROR$TYPE = DISK$IO$ERROR THEN DO;
            IMAX = 36;
            CALL HEXOUT(FDCC$ERROR$TYPE, .MSG7, 4);
        END;

        DO I = 0 TO IMAX;
            CALL CO(MSG1(I));
        END;
        
        IF NOT ABORT THEN
            RETURN;
        IF DEBUG$TOGGLE THEN
            GOTO MDSMON;    /* EXIT VIA MONITOR */
        GOTO BTSTRP;        /* EXIT VIA SOFTWARE BOOTSTRAP */
    END;

    RETUSER: PROCEDURE(ERROR$TYPE);     /* NOT CALLED */
        DECLARE ERROR$TYPE BYTE;

        USER$STATUS = ERROR$TYPE;
        STACKPTR = USER$STACK$PTR;
    END;

    /*
       DISKIO PROVIDES ACCESS TO THE FDCC
       CONTROLLER 1 = BASE ADDRESS 78H (DRIVES 0, 1 FOR SD)
       CONTROLLER 2 = BASE ADDRESS 88H (DRIVES 2, 3 FOR SD)

       DRIVE: AN INTEGER 0-3, SPECIFYING THE DISK TO BE ACCESSED
       IOPB:  THE ADDRESS OF A PARAMETER BLOCK TO BE SENT TO THE
          FDCC CONTROLLER. THIS PARAMETER MUST BE SET UP
          AS IF IT WERE FOR DRIVE 0; IF 'DRIVE' SELECTS
          ANOTHER DRIVE, 'DISKIO' WILL SET ALL THE NECESSARY
          BITS

       THE CALLER PROVIDES A PARAMETER BLOCK SPECIFYING SOME
       VALID DISK OPERATION ON DRIVE 0 AND AN INTEGER DRIVE SELECT VALUE
       IN THIS BOOT CODE ONLY READ AND RECAL ARE USED
       THE PROCEDURE WAITS FOR THE CONTROLLER TO GO UNBUSY, THEN
       PERFORMS THE DESIRED ACTION. IN CASE OF A CONTROLLER ERROR,
       THE DISK DRIVE IS RECALIBRATED AND THE ACTION IS TRIED AGAIN.
       IF SUCCESSFUL COMPLETION CANNOT BE OBTAINED AFTER 'MAX$RETRIES'
       ATTEMPTS, A FATAL ERROR OCCURS, OTHERWISE A NORMAL RETURN IS MADE

    */
        DECLARE FDCC$STATUS   LITERALLY   '78H',
                RESULT$TYPE   LITERALLY   '79H',
                RESULT$BYTE   LITERALLY   '7BH',
                LOW$ADDRESS   LITERALLY   '79H',
                HIGH$ADDRESS  LITERALLY   '7AH';

        DECLARE MAX$RETRIES     LITERALLY   '10',
                DISK$DONE       LITERALLY   '4',
                READ$COMMAND    LITERALLY   '4',
                WRITE$COMMAND   LITERALLY   '6',
                RECALIBRATE     LITERALLY   '3';

        DECLARE IOCW    LITERALLY '0',
                IOINS   LITERALLY '1',
                NSEC    LITERALLY '2',
                TADR    LITERALLY '3',
                SADR    LITERALLY '4',
                BUFLO   LITERALLY '5',
                BUFHI   LITERALLY '6';


    DISKIO: PROCEDURE(DRIVE, IOPB);
        /* THIS PROCEDURE ISSUES THE IOPB TO THE DISK CONTROLLER, IN THE */
        /* CASE OF THE 8271 IT ALSO TRANSFERS THE DATA ON A BYTE BY BYTE BASIS */
        DECLARE DRIVE BYTE; /* DRIVE NUMBER: ASSUMES VALUE 0,1 */
        DECLARE IOPB ADDRESS;   /* POINTER TO THE PARAMATER BLOCK NAMED DCB */
        DECLARE DCB BASED IOPB (7) BYTE; 


        /* RECALIBRATE COMMAND */
        DECLARE RECAL$PB(5) BYTE INITIAL(80H, RECALIBRATE, 0, 0, 0);
        DECLARE I BYTE;     /* RETRY COUNTER */

        DISABLE;
        RECAL$PB(IOINS) = RECALIBRATE;
        RECAL$PB(SADR) = 0;
        IF DRIVE THEN
        DO;
            RECAL$PB(IOINS) = RECALIBRATE OR 30H; 
            RECAL$PB(SADR) = 20H;
            DCB(IOINS) = DCB(IOINS) OR 30H;
            DCB(SADR) = DCB(SADR) OR 20H;
        END;
        
        I = MAX$RETRIES;
        DO WHILE I <> 0;
            I = I - 1;
        
            DO WHILE (INPUT(FDCC$STATUS) AND DISK$DONE) <> 0;
                FDCC$ERROR$HIGH = INPUT(RESULT$TYPE);
                FDCC$ERROR$LOW = INPUT(RESULT$BYTE);
            END;
            /* IF DISK DRIVE NOT READY, GIVE FATAL ERROR */
            IF (INPUT(FDCC$STATUS) AND (DRIVE + 1)) = 0 THEN
                CALL ERR(DRIVE$NOT$READY);

            /* START THE IO OPERATION */
            OUTPUT(LOW$ADDRESS) = LOW(IOPB);
            OUTPUT(HIGH$ADDRESS) = HIGH(IOPB);

            DO WHILE (INPUT(FDCC$STATUS) AND DISK$DONE) = 0; 
                ;
            END;
            FDCC$ERROR$HIGH = INPUT(RESULT$TYPE);

            IF (FDCC$ERROR$LOW := INPUT(RESULT$BYTE)) = 0 THEN
            DO;
                ENABLE;
                RETURN;
            END;
            /* DO A RECALIBRATION */
            OUTPUT(LOW$ADDRESS) = LOW(.RECAL$PB);
            OUTPUT(HIGH$ADDRESS) = HIGH(.RECAL$PB);

            DO WHILE (INPUT(FDCC$STATUS) AND DISK$DONE) = 0; 
                ;
            END;
        END;
        CALL ERR(DISK$IO$ERROR);
        
    END;


    /*
     ASBIO: ACCOMPLISHES THE TRANSFER OF 128 BYTES OF DATA FROM THE DISK 
       COMMAND  MUST BE THE NUMERIC VALUE OF THE FDCC COMMAND
                DESIRED. (LITERALS 'READ$COMMAND' AND 'WRITE$COMMAND'
                EXIST FOR THE COMMON OPERATIONS.)
       DISK     THE DRIVE FROM WHICH TO READ
       BLOCK    DISKETTE BLOCK NUMBER, A TRACK NUMBER (0-76)
                IN THE HIGH ORDER 8 BITS AND A SECTORE NUMBER (1-26)
                IN THE LOW ORDER 8 BITS
       BUFFER$PTR   THE ADDRESS OF A 128 BYTE BUFFER IN RAM
    */
    ABSIO: PROCEDURE (COMMAND, DISK, BLOCK, BUFFER$PTR);
        DECLARE (COMMAND, DISK) BYTE, (BLOCK, BUFFER$PTR) ADDRESS;
        /* VALUE OF 'DISK'  MUST BE 0 - 1 */
        DECLARE DCB BYTE INITIAL(80H);
        DECLARE DCBINST(9) BYTE;
        DECLARE IOPTR ADDRESS;
        DECLARE IOBYTE BASED IOPTR BYTE, IOWORD BASED IOPTR ADDRESS;

        IOPTR = .DCBINST;

        IOBYTE = COMMAND;
        IOPTR = IOPTR + 1;
        IOBYTE = 1;     /* IF THIS VALUE CHANGES IN THE FUTURE, */
                        /* THE 8271 DRIVER MUST BE CHANGED */
        IOPTR = IOPTR + 1;
        IOBYTE = HIGH(BLOCK);
        IOPTR = IOPTR + 1;
        IOBYTE = LOW(BLOCK);
        IOPTR = IOPTR + 1;
        IOWORD = BUFFER$PTR;
        CALL DISKIO(DISK, .DCB);
    END;

    ABS$READ: PROCEDURE(BLOCK, BUFFER);
        DECLARE (BLOCK, BUFFER) ADDRESS;

        CALL ABSIO(READ$COMMAND, A$DEVICE, BLOCK, BUFFER);
    END;

    ABS$WRITE: PROCEDURE(BLOCK, BUFFER);
        DECLARE (BLOCK, BUFFER) ADDRESS;

       CALL ABSIO(WRITE$COMMAND, A$DEVICE, BLOCK, BUFFER);
    END;

    /*

        ALDADR LOADS THE ABSOLUTE ISIS FILE INTO MEMORY
        HDRBLK - LOCATION OF ISIS FILE

        RETURNS - ADDRESS WHERE FILE IS LOADED
        THE FORMAT OF THE FILE IS BASICALLY THE CONTENT RECORDS
        FROM AN NORMAL ISIS EXECUTABLE WITH THE RECORD TYPE, SEGMENT ID AND CRC REMOVED
    */

    ALDADR: PROCEDURE(HDRBLK) ADDRESS;
        /* LOAD INTO MEMORY THE ABS LOAD FILE AT 'HDRBLK' */
        DECLARE HDRBLK ADDRESS;
        DECLARE BUF(128) BYTE, BUFPTR BYTE;
        DECLARE POINTERS(64) ADDRESS, PTRPTR BYTE;
        DECLARE LOADADR ADDRESS, TARGET BASED LOADADR BYTE;
        DECLARE LENGTH ADDRESS;

        DECLARE FLINK   LITERALLY   '1';    /* INDEXES INTO THE POINTERS ARRAY */

        L1B: PROCEDURE; /* LOAD 1 BYTE FROM BUFFER INTO MEMORY */
            TARGET = BUF(BUFPTR);   
            BUFPTR = BUFPTR + 1;
            LENGTH = LENGTH - 1;
            LOADADR = LOADADR + 1;
        END;

        G128B: PROCEDURE(BUFADR); /* GET 128 BYTES INTO BUFFER AT BUFADR */
            DECLARE BUFADR ADDRESS;

            IF (PTRPTR := PTRPTR + 1) = 64 THEN
            DO;
                IF POINTERS(FLINK) = 0 THEN
                    GOTO MDSMON;
                CALL ABSIO(READ$COMMAND, 0, POINTERS(FLINK), .POINTERS);
                PTRPTR = 2;
            END;
            IF POINTERS(PTRPTR) = 0 THEN
                GOTO MDSMON;
            CALL ABSIO(READ$COMMAND, 0, POINTERS(PTRPTR), BUFADR);
        END;

        G1B: PROCEDURE BYTE;    /* GET 1 BYTE */
            IF (BUFPTR AND 7FH) = 0 THEN
            DO;
                CALL G128B(.BUF);
                BUFPTR = 0;
            END;    
            BUFPTR = BUFPTR + 1;
            RETURN BUF(BUFPTR - 1);
        END;

        G2B: PROCEDURE ADDRESS; /* GET 2 BYTES */
            RETURN G1B + (256 * G1B);
        END;




        POINTERS(FLINK) = HDRBLK;   /* INITIALISZE G128B */
        PTRPTR = 63;
        BUFPTR = 0;

    START$LOADING$NEXT$RECORD:
        DO WHILE TRUE;
            LENGTH = G2B;
            LOADADR = G2B;
            IF LENGTH = 0 THEN
                RETURN LOADADR;
            DO WHILE BUFPTR <> 128;
                IF LENGTH > 0 THEN
                    CALL L1B;
                ELSE
                    GOTO START$LOADING$NEXT$RECORD;
            END;
            DO WHILE LENGTH >= 128;
                CALL G128B(LOADADR);
                LOADADR = LOADADR + 128;
                LENGTH = LENGTH - 128;
            END;
            
            BUFPTR = 0;
            IF LENGTH <> 0 THEN DO;
                CALL G128B(.BUF);
                DO WHILE LENGTH > 0;
                    CALL L1B;
                END;
            END;
        END;
        /* CANNOT REACH HERE !! */
    END; 


    T0BOOT:
    TEMP = INPUT(RESULT$TYPE);
    TEMP = INPUT(RESULT$BYTE);
    ENABLE;
    DO WHILE (INPUT(RTC) AND BOOT) <> 0;
        ;
    END;
    DEBUG$TOGGLE = TRUE;
    START$ADDR = ALDADR(ISIS$HDR$BLK);
    IF START$ADDR <> 0 THEN
        GOTO START$ADDR;

    CALL NUMOUT(VERSION$LEVEL, 16, 0, .SIGN$V, 2);
    CALL NUMOUT(EDIT$LEVEL, 16, 0, .SIGN$E, 2);
    CALL WRITE(0, .ISIS$SIGNON, 20, .USERSTATUS);
    CALL EXIT;


END;
EOF;
