src/asm80.pex
# vim:ts=4:expandtab:shiftwidth=4:
/* assembler routines & linkage */
Isis            P(B syscall,A param$p)
PckTok          P
EDATA        B

packToken       'PckTok'
tokenSize       'toksiz'
tokStart        'tokst'


lit             'literally'
TRUE            '0FFh'
FALSE           '0'
CR              '0Dh'
FF              '0Ch'
LF              '0Ah'
ESC     '1Bh'
TAB             '9'
MACROEOB    '0FEh'

MAXSYMSIZE  '6'

# primiative types
bool             'byte'
word             'address'
pointer          'address'
apointer         'address'

/* character classes */
CC$BAD          '0'
CC$WS           '1'
CC$SEMI         '2'
CC$COLON        '3'
CC$CR           '4'
CC$PUN        '5'
CC$DOLLAR       '6'
CC$QUOTE        '7'
CC$DIG        '8'
CC$LET          '9'
CC$MAC      '10'
CC$ESC          '11'

TT$ID           '0'
TT$NUM          '2'
TT$STR          '4'

/* Isis syscall ids */
IOPEN           '0'
ICLOSE          '1'
IDELETE         '2'
IREAD           '3'
IWRITE          '4'
ISEEK           '5'
ILOAD           '6'
IEXIT           '9'
IRESCAN         '11'
IERROR          '12'
/* Seek operations */
SEEKTELL        '0'
SEEKBACK        '1'
SEEKABS         '2'
SEEKFWD         '3'
SEEKEND         '4'
/* segments */
SEG$ABS         '0'
SEG$CODE        '1'
SEG$DATA        '2'
SEG$STACK       '3'
SEG$MEMORY      '4'
/* open modes */
READ$MODE       '1'        /* Open mode */
WRITE$MODE      '2'
UPDATE$MODE     '3'

/* runtime error codes */
RTE$STACK       '0'
RTE$TABLE       '1'
RTE$CMDLINE     '2'
RTE$EOF         '3'
RTE$FILE        '4'
RTE$MEMORY      '5'

/* relocatable record types */
OMF$MODHDR      '2'
OMF$MODEND      '4'
OMF$CONTENT     '6'
OMF$LINENO      '8'
OMF$EOF            '0EH'
OMF$ANCESTOR    '10H'
OMF$LOCALS      '12H'
OMF$PUBLICS     '16H'
OMF$EXTNAMES    '18H'
OMF$EXTREF      '20H'
OMF$RELOC       '22H'
OMF$INTERSEG    '24H'
OMF$LIBLOCS     '26H'
OMF$LIBNAMES    '28H'
OMF$LIBDICT     '2AH'
OMF$LIBHDR      '2CH'
OMF$COMDEF      '2EH'

/* Op types */
T$BEGIN         '0'
T$CR            '1'
T$LPAREN        '2'
T$RPAREN        '3'
T$STAR          '4'
T$PLUS          '5'
T$COMMA         '6'
T$MINUS         '7'
T$UPLUS         '8'
T$SLASH         '9'
T$UMINUS        '0Ah'
O$ID            '1'
O$TARGET        '2'
O$LABEL         '3'
O$SET           '4'
O$EQU           '5'
O$REF           '6'
O$NAME          '9'
O$STRING        '0Ah'
O$DATA          '0Bh'
O$NUMBER        '0Ch'
K$SPECIAL       '5'
K$REGNAME       '7'
K$SP            '8'
K$EQ            '0Bh'
K$LT            '0Ch'
K$LE            '0Dh'
K$GT            '0Eh'
K$GE            '0Fh'
K$NE            '10h'
K$NOT           '11h'
K$AND           '12h'
K$OR            '13h'
K$XOR           '14h'
K$MOD           '15h'
K$SHL           '16h'
K$SHR           '17h'
K$HIGH          '18h'
K$LOW           '19h'
K$DB            '1Ah'
K$DW            '1Bh'
K$DS            '1Ch'
K$EQU           '1Dh'
K$SET           '1Eh'
K$ORG           '1Fh'
K$END           '20h'
K$IF            '21h'
K$ELSE          '22h'
K$ENDIF         '23h'
K$LXI           '24h'
K$REG16         '25h'
K$LDSTAX        '26h'
K$ARITH         '27h'
K$IMM8          '28h'
K$MVI           '29h'
K$INRDCR        '2Ah'
K$MOV           '2Bh'
K$IMM16         '2Ch'
K$SINGLE        '2Dh'
K$RST           '2Eh'
K$ASEG          '2Fh'
K$CSEG          '30h'
K$DSEG          '31h'
K$PUBLIC        '32h'
K$EXTRN         '33h'
K$NAME          '34h'
K$STKLN         '35h'
K$MACRO         '36h'
O$37            '37h'
K$ENDM          '38h'
K$EXITM         '39h'
T$MACRONAME            '3Ah'
K$IRP           '3Bh'
K$IRPC          '3Ch'
O$3D            '3Dh'
K$REPT          '3Eh'
K$LOCAL         '3Fh'
O$OPTVAL        '40h'
K$NUL           '41h'
O$MACROID       '64h'

/* sym flags */
UF$SEGMASK    '7'
UF$LOW          '8'
UF$HIGH         '10h'
UF$BOTH         '18h'
UF$PUBLIC       '20h'
UF$EXTRN        '40h'

/* xref types */
XREF$DEF    '0'
XREF$REF    '1'
XREF$FIN    '2'

/* symbol table ids */
TID$KEYWORD    '0'
TID$SYMBOL    '1'
TID$MACRO    '2'

/* macro types */
M$MACRO     '0'
M$IRP       '1'
M$IRPC      '2'
M$REPT      '3'
M$INVOKE    '4'
M$BODY      '5'

/* user defined types */
TOKENSYM$T      'structure(tok(2) word, value word, type byte, flags byte)'
FILE$T          'structure(name(15) byte, blk word, byt word, b19 byte)'
MACRO$T1    'macroCondSP byte, ifDepth byte, mtype byte, localsCnt byte, localIdBase word'
MACRO$T2        'buf$p pointer, blk word, savedBlk word, pCurArg pointer, cnt word'
MACRO$T         'structure(MACRO$T1,MACRO$T2)'
CONTENT$T       'structure(type byte, len word, segid byte, offset word, dta(121) byte, crc byte)'
EOF$T           'structure(type byte, len word, crc byte)'
EXTNAMES$T    'structure(type byte, len word, dta(124) byte, crc byte)'
EXTREF$T        'structure(type byte, len word, hilo byte, dta(30) word, crc byte)'
INTERSEG$T      'structure(type byte, len word, segid byte, hilo byte, dta(29) word, crc byte)'
MODEND$T        'structure(type byte, len word, modtyp byte, segid byte, offset word, crc byte)'
MODHDR$T    'structure(type byte, len word, dta(26) byte)'
PUBLICS$T       'structure(type byte, len word, segid byte, dta(124) byte, crc byte)'
RELOC$T         'structure(type byte, len word, hilo byte, dta(62) word)'
KEYWORD$T    'structure(tok(2) word, base byte, delta byte, type byte, flags byte)'

/* common based variables */
curTokenSym     "TOKENSYM$T"..tokenSymCurP

$file(startm.plm)
b3782          BS
seekMZero          "word"
IsGT            P"bool"
IsLT            P"bool"
InsertByteInMacroTbl        P(B c)
InsertCharInMacroTbl        P(B c)

$file(startm.plm,startb.plm,starts.plm)
aBadSyntax      BS
aCommand        BS
aEof            BS
aError          BS
aError$0        BS
aFile           BS
asmHeader BS
aMemory         BS
aModulePage     BS
ascCRLF         BS
aStack          BS
aTable          BS
bTRUE           B
bZERO           B
aErrStrs         AS
aErrStrsLen      BS
signonMsg       BS
spaces15        BS
spaces2         BS
spaces24        BS
spaces4         BS
spaces5         BS
spaces6         BS
BlankAsmErrCode P"bool"
MPorNoErrCode PB
ChkGenObj       P"bool"
CloseF          P(A conn)
Flushout        P
GetNibble       P(A bp,B idx)B
InitialControls P
SafeOpen          P(A path$p,A access)"word"
IoErrChk        P
IoError         P("pointer" path)
IsComma         P"bool"
IsCR            P"bool"
IsPhase1        P"bool"
IsPhase2Print   P"bool"
IsRParen        P"bool"
IsSpace         P"bool"
IsTab           P"bool"
IsWhite         P"bool"
Nibble2Ascii    P(B n)B
GetCmdCh        PB
Outch           P(B c)
OutStrN         P(A s,B n)
Physmem         P"pointer"
ParseControlLines P
Put2Hex         P(pointer pfunc,B val)
RuntimeError    P(B errCode)
Skip2EOL        P
SourceError     P(B errCh)
InitLine        P
WrConsole       P(A buf$p,A count)


$file(asm1m.plm)
ReadM           P(A blk)
nonHiddenSymbol        PB
FlushM        P
WriteM          P

$file(asm1m.plm,asm1n.plm)
Skip2NextLine   P
SkipWhite       P
SkipWhite$2     P
Tokenise        P

/* $file(asm2m.plm) */

$file(asm2m.plm,asm2n.plm)
opFlags           BS
GetPrec         P(B topOp)B
IsReg        P(B topOp)"bool"
ChkInvalidRegOperand        P
Sub4291        P
SetExpectOperands        P
GetNumVal        P"word"
MkCode        P(B arg1b)
NxtTokI        PB
ShowLine        P"bool"
EmitXref        P(B xrefMode,A name)
SwapAccBytes    P
TestBit         P(B bitIdx,"pointer" bitVector)"bool"

/* $file(asm4m.plm) */

$file(asm4m.plm,asm8m.plm,asm4s.plm)
IsSkipping      P"bool"
StrUcEqu        P("pointer" s,"pointer" t)"bool"
FinishLine    P
Sub546F        P

$file(rdsrc.plm)
pendingInclude   "bool"
includeOnCmdLine "bool"
missingEnd      "bool"
lineChCnt           B
fileIdx         B
files           "FILE$T"S
srcfd           "word"
endInBuf$p     "pointer"
inCh$p         "pointer"
startLine$p    "pointer"
rootfd         "word"
CloseSrc          P
ReadF           P(B conn,A buff$p,A count)
ReadSrc           P(A bufLoc)
SeekI           P(B seekOP)
GetSrcCh        PB
OpenSrc        P

/* $file(asm3m.plm) */

$file(asm3m.plm,asm3s.plm)
Cond2Acc        P(B cond)
ChkSegAlignment        P(B seg)
UpdateHiLo        P(B hilo)
DoPass        P

$file(asm5m.plm)
InsertMacroSym        P(A val,B type)
Sub65D9        P

$file(asm5m.plm,asm5n.plm)
labelUse          B
GetCh           PB
GetChClass      PB
Lookup          P(B tableId)B
UpdateSymbolEntry        P(A val,B type)
UnpackToken     P("apointer" src,"pointer" dst)

/* $file(asm6m.plm) */

$file(asm6m.plm,asm6n.plm)
BalanceError    P
CollectByte     P(B rc)
CommandError    P
DoubleDefError  P
ExpressionError P
FileError       P
GetId           P(B type)
GetNum          P
GetStr          P
HaveTokens      PB
IllegalCharError P
LocationError   P
MultipleDefError P
NameError       P
Nest         P(B arg1b)
NestingError    P
OPcodeOperandError P
OperandError    P
PhaseError      P
PopToken        P
PushToken       P(B type)
StackError      P
SyntaxError     P
UndefinedSymbolError P
UnNest        P(B arg1b)
ValueError      P

/* $file(cntrlm.plm) */
$file(cntrlm.plm,cntrln.plm)
ParseControls   P

$file(asm8m.plm)
b9C77          B
DoIrpX        P(B arg1b)
Sub7327        P
GetMacroToken        P
DoMacro        P
DoMacroBody        P
DoEndm        P
DoExitm        P
Sub770B        P
DoRept        P
Sub787A        P
Sub78CE        P

/* $file(emitm.plm) */

$file(emitm.plm,emitn.plm)
Ovl11           P
Ovl8            P
ReinitFixupRecs        P
WriteExtName    P
WriteModend     P
WriteModhdr     P
WriteRec        P(A rec$p)

/* $file(listm.plm) */

$file(listm.plm,listn.plm)
AsmComplete     P
NewPage         P
OutStr          P(A s)
PrintLine            P
FinishPrint            P
FinishAssembly           P
PrintCmdLine    P
PrintDecimal    P(A n)
SkipToEOP       P
DoEject        P
Sub7041$8447    P

/* $file(initm.plm) */

$file(initm.plm,initb.plm,inits.plm)
aDebug          BS
aExtents        BS
AddExtents      P
CmdSkipWhite    P
GetAsmFile      P
GetDrive        PB
ResetData       P
InitRecTypes        P



/* $file(startb.plm) */

/* $file(asm52.plm) */

/* $file(asm8m.plm) */

/* $file(asm3b.plm) */
$file(asm3b.plm,asm3s.plm)
HandleOp        P
Parse        P

/* $file(initb.plm) */


$file(starts.plm)
ovlFile         BS
OvlMgr          P(B ovl)

/* $file(asm1n.plm) */
/* $file(asm2n.plm) */
/* $file(asm3s.plm) */
/* $file(asm4s.plm) */

$file(asm5n.plm)
ChkLF           P
InsertSym       P

/* $file(asm6n.plm) */

/* $file(cntrln.plm) */

/* $file(listn.plm) */

/* $file(emitn.plm) */

/* $file(inits.plm) */

$file(close.plm)
Close           P(A conn,A status$p)

$file(Delete.plm)
Delete          P(A path$p,A status$p)

$file(Error.plm)
Error           P(A Error$num)

$file(Exit.plm)
Exit            P

/* these share a common file with build controlled by $IF statements */
$file(globls.plm,globlm.plm,globlb.plm)
accum1          "word"
accum1$hb       B
accum1$lb       B
accum2          "word"
accum2$hb       B
accum2$lb       B
activeSeg       B
actRead         A
asmac$ref    BS
asxref       BS
asxref$tmp   BS
alignTypes      BS
argNestCnt      B        /* globlm */
asciiLineNo     BS
asmErrCode      B
azero           "word"
fixupSeg        B
curFixupHiLoSegId B
curFixupType    B
fixIdxs         BS
initFixupReq    "bool"S
firstContent    "bool"
inComment           "bool"
noOpsYet           "bool"
nameLen         B
inPublic        "bool"
inExtrn         "bool" 
segHasData      "bool"S
badExtrn        "bool"
acc1Flags           B
acc2Flags           B
hasVarRef        "bool"
acc1ValType           B
acc2ValType           B
gotLabel           B
name         BS
savName           BS
lhsUserSymbol           "bool"
rhsUserSymbol  "bool"
xRefPending           "bool"
passCnt           B
createdUsrSym           "bool"
usrLookupIsID           "bool"
needsAbsValue           "bool"
b6897           "bool"
tokI           B
errorOnLine    "bool"
atStartLine    "bool"
showAddr        "bool"
lineNumberEmitted           "bool"
b68AE           "bool"
inBuf           BS
spIdx           B
lastErrorLine           BS
ctlLISTChanged           "bool"
isControlLine  "bool"
inDB           "bool"
inDW           "bool"
inExpression           "bool"
curOpFlags           B
yyType           B
topOp              B
b6B2C           "bool"
nextTokType           B
inNestedParen   "bool"
expectingOperands     "bool"
expectingOpcode       "bool"
condAsmSeen           "bool"
b6B33           "bool"
isInstr           "bool"
expectOp           "bool"
b6B36           "bool"
skipRuntimeError           "bool"
nestedMacroSeen           "bool"
jj           B
macroLine          BS        /* globlm */
inQuotes          "bool"        /* globlm */
excludeCommentInExpansion          "bool"        /* globlm */
inAngleBrackets          "bool"        /* globlm */
expandingMacro B        /* globlm */
macroDivert          "bool"        /* globlm */
inMacroBody          "bool"        /* globlm */
mSpoolMode          B        /* globlm */
b9060          "bool"        /* globlm */
nestMacro          "bool"        /* globlm */
savedMtype          B        /* globlm */
macroDepth          B        /* globlm */
macroSpoolNestDepth          B        /* globlm */
paramCnt          B        /* globlm */
startNestCnt          B        /* globlm */
irpcChr          BS        /* globlm */
localVarName          BS        /* globlm */
accFixFlags          BS
cmdch$p         "pointer"
cmdLineBuf      BS
controlId       B
controls        B(20)
controlSeen     "bool"S
controls$p      "pointer"
ctlCOND         "bool"
ctlDEBUG        "bool"
ctlEJECT        B
ctlGEN          "bool"
ctlLIST         "bool"
ctlMACRODEBUG   "bool"
ctlMACROFILE    "bool"
ctlMOD85        "bool"
ctlOBJECT       "bool"
ctlPAGELENGTH   B
ctlPAGEWIDTH    B
ctlPAGING       "bool"
ctlPRINT        "bool"
ctlSYMBOLS      "bool"
ctlTITLE        "bool"
titleStr     BS
ctlTTY          "bool"
ctlXREF         "bool"
curChar         B
curCol          B
curFileName$p   "pointer"
curMacroBlk     "word"        /* globlm */
tokenSymCurP   "pointer"
tokPtr          "pointer"
endLineBuf      "pointer"
endOutBuf       "pointer"
endSymTab       "pointer"S
errCnt          "word"
extNamIdx       B
finished        "bool"
fix20Idx        B
fix22Idx        B
fix24Idx        B
fix6Idx         B
has16bitOperand "bool"
ifDepth         B
ii              B
inElse          "bool"S
infd            "word"
kk              B
lineBuf         BS
pageLineCnt     "word"
lookAhead       B
lstFile         BS
macroBuf        BS        /* globlm */
macroCondSP     B        /* globlm */
macroCondStk    BS        /* globlm */
MacroDebugOrGen B        /* globls & globlb */
macrofd         "word"
macroStk        "MACRO$T"S    /* globlm */
maxMacroBlk     "word"        /* globlm */
maxSegSize      "word"S
byteAt          BS        /* globlm */
moduleNameLen   B
nxtMacroBlk     "word"        /* globlm */
objfd           "word"
objFile         BS
macro$p         "pointer"    /* globlm */
openStatus      A
opSP            B
opStack         BS
newOp          B
outbuf          BS
b6A00           B
outfd           "word"
out$p           "pointer"
pageCnt         "word"
phase           B
primaryValid    "bool"
r$content       "CONTENT$T"
reget           B
r$eof           "EOF$T"
r$extnames     "EXTNAMES$T"
r$extref        "EXTREF$T"
r$interseg      "INTERSEG$T"
r$modend        "MODEND$T"
r$publics       "PUBLICS$T"
r$reloc         "RELOC$T"
saveIdx         B
saveStack       BS
scanCmdLine     "bool"
segSize         "word"S
skipIf        "bool"S
startDefined    B
startOffset     "word"
startSeg        B
statusIO        A
symTab          "pointer"S
titleLen        B
tmac            "MACRO$T"
tokBuf          BS
tokBufIdx       B
tokBufLen       B
tokenAttr       BS
tokenIdx         B
tokStr          BS
tokenSym        AS
tokenSymId      "word"S
tokenType       BS
toksiz          BS
tokst           AS
tokType         B
contentBytePtr  "pointer"
fixOffset           "word"
externId        "word"
itemOffset      "word"
acc1NumVal      "word"
acc2NumVal      "word"
symHighMark     "pointer"
baseMacroTbl           "pointer"
endItem         "pointer"
startItem       "pointer"
effectiveAddr           A
sizeInBuf      "word"
srcLineCnt     "word"
tokNumVal      "word"
w6BCE          "pointer"
aVar          A
controlFileType "word"	/* not used */
pMacro          "pointer"    /* globlm */
macroInPtr     "pointer"    /* globlm */
macroBlkCnt    "word"        /* globlm */
savedMacroBufP          "pointer"        /* globlm */
pNextArg          "pointer"        /* globlm */
localIdCnt          "word"        /* globlm */
startMacroLine          "pointer"        /* globlm */
startMacroToken          "pointer"        /* globlm */
wZERO           "word"
xreffd          "word"

$file(keym.plm)
extKeywords     AS

$file(keyn.plm)
stdKeywords     AS

$file(Load.plm)
Load            P(A path$p,A Load$offset,A switch,A entry$p,A status$p)

$file(Open.plm)
Open            P(A conn$p,A path$p,A access,A echo,A status$p)

$file(Read.plm)
Read            P(A conn,A buff$p,A count,A actual$p,A status$p)

$file(Rescan.plm)
Rescan          P(A conn,A status$p)

$file(Seek.plm)
Seek            P(A conn,A mode,A block$p,A byte$p,A status$p)

$file(Write.plm)
Write           P(A conn,A buff$p,A count,A status$p)

notes.txt
symbol table format
tok(2) word - packed symbol 3 chars per word field
val word - keywords - high byte is link to next entry
          user - offset of symbol
          macro - 
type byte
flags byte keywords xxxxxxrx    r = rim/sim
       user - xeph lsss    e = external p = public h = high l = low sss = seg
       macro table


src/globl.plx
$IF SMALL
globls: do;
$include(:f3:globls.ipx)
$ELSEIF MACRO
globlm: do;
$include(:f3:globlm.ipx)
$ELSE
globlb: do;
$include(:f3:globlb.ipx)
$ENDIF

/* force rescan to be included from system.lib */
rescan: procedure (conn, status$p) external;
    declare conn word, status$p apointer;
end rescan;

$IF MACRO
declare IN$BUF$SIZE lit '512',
        OUT$BUF$SIZE lit '512';
$ELSEIF BIG
declare IN$BUF$SIZE lit '2048',
        OUT$BUF$SIZE lit '2048';
$ELSE
declare IN$BUF$SIZE lit '200',
        OUT$BUF$SIZE lit '128';
$ENDIF

$IF MACRO
declare    byteAt(1) byte public at(0),
    macroLine(129) byte public,
    macro$p pointer public initial(.macroLine),
    inQuotes bool public initial(FALSE),
    excludeCommentInExpansion bool public,
    inAngleBrackets bool public,
    expandingMacro byte public,
    macroDivert bool public,
    inMacroBody bool public initial(FALSE),
    mSpoolMode byte public,
    b905F byte,             /* unused */
    b9060 bool public,
    nestMacro bool public,
    savedMtype byte public,
    macroDepth byte public,
    macroSpoolNestDepth byte public,
    paramCnt byte public,
    startNestCnt byte public,
    argNestCnt byte public initial(0),
    pMacro pointer public,
    macroInPtr pointer public,
    /*
        mtype has the following values
        1 -> IRP
        2 -> IRPC
        3 -> REPT
        4 -> INVOKE
        5 -> ???
    */
        
    macroStk(10) MACRO$T public,
    tmac MACRO$T public at (.macroStk(0)),
    /* initialise the blk value for macro spooling */
    tmac$blk word at(.tmac.blk) initial(0FFFFh),
    w910C word,     /* unused */
    curMacroBlk word public initial(0FFFFh),
    nxtMacroBlk word public initial(0),
    maxMacroBlk word public initial(0),
    macroBlkCnt word public,
    macroBuf(129) byte public,
    savedMacroBufP pointer public,
    pNextArg pointer public,
    localIdCnt word public,
    startMacroLine pointer public,
    startMacroToken pointer public,
    irpcChr(3) byte public initial(0, 0, 81h),
    localVarName(*) byte public initial(3Fh, 3Fh, 0, 0, 0, 0, 80h);
$ENDIF
/* ov4 compat 2C8C */
declare    contentBytePtr pointer public,
    fixupSeg byte public,
    fixOffset word public,
    curFixupHiLoSegId byte public,
    curFixupType byte public,
    fixIdxs(4) byte public initial(0, 0, 0, 0),
    (fix22Idx, fix24Idx, fix20Idx, fix6Idx) byte public at (.fixIdxs),
    extNamIdx byte public initial(0),
    initFixupReq(4) bool public initial(TRUE, TRUE, TRUE, TRUE),
    firstContent byte public initial(TRUE),
    r$eof EOF$T public initial(0Eh, 0),
    r$extnames EXTNAMES$T public initial(18h, 0, 0),
    moduleNameLen byte public initial(6),
    r$content CONTENT$T public initial(18h, 0, 0),  /* seems odd would expect 6 not 18h */
    r$publics PUBLICS$T public initial (16h, 1, 0, 0, 0),
    r$reloc RELOC$T public at(.r$publics),
    r$interseg INTERSEG$T public,
    r$extref EXTREF$T public,
    r$modend MODEND$T public initial( 4, 4, 0),
    wZERO word public initial(0),
    pad6741 byte initial(0ah),
    inComment bool public initial(FALSE),
    noOpsYet bool public initial(FALSE),
    nameLen byte public,
    startSeg byte public initial(1),
    padb6746 byte,
    activeSeg byte public,
    inPublic bool public initial(FALSE),
    inExtrn bool public initial(FALSE),
    segHasData(2) bool public,
    alignTypes(4) byte public initial(3, 3, 3, 3),
    externId word public,
    itemOffset word public,
    badExtrn bool public initial(FALSE),
    startDefined byte public initial(0),
    startOffset word public initial(0),
    tokenIdx byte public initial(0),
    lineBuf(128) byte public,
    tokStart(9) pointer public initial(.lineBuf),
    tokPtr pointer public at(.tokStart),
    tokenSym(9) pointer public initial(0),
    tokenSymCurP pointer public at(.tokenSym(0)),
    tokenType(9) byte public,
    tokenSize(9) byte public initial(0),
    tokenAttr(9) byte public,
    tokenSymId(9) word public,
/* end */
    endLineBuf pointer public initial(.lineBuf + 128),
    ifDepth byte public initial(0),
    skipIf(9) bool public,
    inElse(9) bool public;
$IF MACRO
declare    macroCondSP byte public initial(0),
    macroCondStk(17) byte public,
    b94DD(2) byte;      /* unused */
$ENDIF
declare    opSP byte public,
    opStack(17) byte public,
/* ov4 compat 2CA0 */
    (accum1, accum2) word public,
    (accum1$lb, accum1$hb, accum2$lb, accum2$hb) byte public at(.accum1),
    acc1Flags byte public,
    acc2Flags byte public,
    hasVarRef bool public,
    acc1ValType byte public,
    acc2ValType byte public,
    acc1NumVal word public,
    acc2NumVal word public,
    curChar byte public initial(0),
    reget byte public initial(0),
    lookAhead byte public,
    pad6861 byte initial(0),        /* unused */
    symTab(3) pointer public,
    endSymTab(3) pointer public,
    symHighMark pointer public,
    baseMacroTbl pointer public,
    gotLabel byte public initial(0),
    name(6) byte public,
    savName(6) byte public,
    lhsUserSymbol bool public,
    rhsUserSymbol bool public,
    xRefPending bool public initial(FALSE),
    passCnt byte public initial(0),
    createdUsrSym bool public initial(FALSE),
    usrLookupIsID bool public initial(FALSE),
    needsAbsValue bool public initial(FALSE),
    objfd word public,
    xreffd word public,
    infd word public,
    outfd word public,
    macrofd word public,
    statusIO word public,
    openStatus word public,  /* status of last open for Read */
    pad6894 word initial(0FFFFh),       /* unused */
    asmErrCode byte public initial(' '), 
    b6897 bool public initial(FALSE),
    primaryValid bool public initial(TRUE);
/* end */
$IF SMALL
declare    pad6899 byte initial(0);
$ENDIF
/* ov4 compat 2C9F */
declare    tokI byte public,
    errorOnLine bool public,
    atStartLine bool public,
    pad689D(2) byte,
    curCol byte public initial(1),
    endItem pointer public,
    startItem pointer public,
    pageLineCnt word public,
    effectiveAddr address public,
    pageCnt word public,
    pad68AA byte,       /* unused */
    showAddr bool public,
    pad68AC byte,       /* unused */
    lineNumberEmitted bool public initial(FALSE),
    b68AE bool public initial(FALSE),
    tokStr(7) byte public initial(0, 0, 0, 0, 0, 0, 0),
    sizeInBuf word public initial(IN$BUF$SIZE),
    inBuf(IN$BUF$SIZE) byte public,
    outbuf(OUT$BUF$SIZE) byte public,
    b6A00 byte public,      /* guard byte */
/* end */
/* ov4 compat 2F57 */
    out$p pointer public initial(.outbuf),
    endOutBuf pointer public,
    pad6A05 pointer initial(.outbuf),   /* unused */
    pad6A07 byte initial(0),            /* unused */
    objFile(15) byte public initial('               '), /* 15 spaces */
    lstFile(15) byte public initial('               '), /* 15 spaces */
    asxref$tmp(*) byte public initial(':F0:ASXREF.TMP '),
    asxref(*) byte public initial(':F0:ASXREF '),
    asmac$ref(*) byte public initial(':F0:ASMAC.TMP '),
    srcLineCnt word public initial(1),
    pad6A50(2) byte initial('  '),        /* protects for very big files */
    asciiLineNo(4) byte public initial('   0'),
    spIdx byte public,
    lastErrorLine(4) byte public initial('   0'),
    controls(20) byte public,
    ctlDEBUG       bool public at(.controls(0))  initial(FALSE),  /* DEBUG */
    ctlMACRODEBUG  bool public at(.controls(1))  initial(FALSE),  /* MACRODEBUG */
    ctlXREF        bool public at(.controls(2))  initial(FALSE),  /* XREF */
    ctlSYMBOLS     bool public at(.controls(3))  initial(TRUE),   /* SYMBOLS */
    ctlPAGING      bool public at(.controls(4))  initial(TRUE),   /* PAGING */
    ctlTTY         bool public at(.controls(5))  initial(FALSE),  /* TTY */
    ctlMOD85       bool public at(.controls(6))  initial(FALSE),  /* MOD85 */
    ctlPRINT       bool public at(.controls(7))  initial(TRUE),   /* PRINT */
    ctlOBJECT      bool public at(.controls(8))  initial(TRUE),   /* OBJECT */
    ctlMACROFILE   bool public at(.controls(9))  initial(FALSE),  /* MACROFILE */
    ctlPAGEWIDTH   byte public at(.controls(10)) initial(120),    /* PAGEWIDTH */
    ctlPAGELENGTH  byte public at(.controls(11)) initial(66),     /* PAGELENGTH */
    ctlINLCUDE     byte        at(.controls(12)) initial(0),      /* INCLUDE */
    ctlTITLE       bool public at(.controls(13)) initial(FALSE),  /* TITLE */
    ctlSAVE        byte        at(.controls(14)),                 /* SAVE */
    ctlRESTORE     byte        at(.controls(15)),                 /* RESTORE */
    ctlEJECT       byte public at(.controls(16)) initial(0),      /* EJECT */
            /* SAVE/RESTORE act on next 3 opts */
    ctlLIST        bool public at(.controls(17)) initial(TRUE),   /* LIST */
    ctlGEN         bool public at(.controls(18)) initial(TRUE),   /* GEN */
    ctlCOND        bool public at(.controls(19)) initial(TRUE),   /* COND */
    ctlLISTChanged bool public initial(TRUE),
    titleLen byte public initial(0),
    pad6A71 byte,       /* unused */
    pad6A72(3) byte initial(120, TRUE), /* unused */
    controlSeen(12) bool public initial(false,false,false,false,false,false,
                                        false,false,false,false,false,false),
    saveStack(24) byte public,
    saveIdx byte public initial(0),
    titleStr(64) byte public,
    tokBufLen byte public,
    tokType byte public,
    controlId byte public,
    tokBuf(64) byte public,
    tokBufIdx byte public initial(0),
    tokNumVal word public,
/* end */
    isControlLine bool public initial(FALSE);
$IF NOT MACRO
declare    MacroDebugOrGen byte public initial(0);
$ENDIF
/* ov4 compat 2F56 */
declare    scanCmdLine bool public,
    inDB bool public,
    inDW bool public,
    inExpression bool public,
    has16bitOperand bool public,
    phase byte public,
    curOpFlags byte public,
    yyType byte public,
    newOp byte public,
    topOp byte public,
    b6B2C bool public,
    nextTokType byte public,
    finished bool public,
    inNestedParen bool public,
    expectingOperands bool public,
    expectingOpcode bool public,
    condAsmSeen bool public,    /* true when IF, ELSE, ENDIF seen (also macro to check) */
    b6B33 bool public,
    isInstr bool public initial(TRUE),
    expectOp bool public initial(TRUE),
    b6B36 bool public initial(FALSE),
    segSize(5) word public initial(0, 0, 0, 0, 0),    /* ABS, CODE, DATA, STACK, MEMORY */
    maxSegSize(3) word public initial(0, 0, 0),        /* seg is only ABS, CODE or DATA */
    cmdLineBuf(129) byte public,
    actRead address public,
    errCnt word public,
    padw6BCB word,    /* not used */
    w6BCE pointer public,
    pad6BD0(3) byte initial(0), /* unused */
    azero word public initial(0),
    cmdch$p pointer public initial(.cmdLineBuf),
    controls$p pointer public,
    skipRuntimeError bool public initial(FALSE),
    nestedMacroSeen bool public,
    ii byte public,     /* warning global variable misused see note in init.plx */
    jj byte public,
    kk byte public;
/* end */
$IF MACRO
declare    b9B34 byte initial(0);
$ENDIF
/* ov4 compat 2F57 */
declare    curFileName$p pointer public,
    aVar address public,
    accFixFlags(2) byte public at(.aVar),
    controlFileType word public;     /* 1->INCLUDE 2->PRINT, 3->OBJECT or MACROFILE */	/* not used */
/* end */
end;
src/asm3.plx
$IF MACRO
asm3m: do;
$include(:f3:asm3m.ipx)
$ELSEIF BIG
asm3b: do;
$include(:f3:asm3b.ipx)
$ELSE
asm3s: do;
$include(:f3:asm3s.ipx)
$ENDIF

$IF SMALL
declare    CHKOVL$2 lit    'call OvlMgr(2)';
$ELSE
declare    CHKOVL$2 lit    ' ';
$ENDIF

            /*   0     1     2     3     4     5     6     7     8     9     A     B     C     D     E     F */
declare isExprOrMacroMap(*) bool data(
                true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true,
                true, true, true, true, true, true, true, true, true, true,false,false,false,false,false,false,
               false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,
               false,false,false,false,false,false, true, true, true, true, true, true, true, true,false, true,
                true, true),
   isInstrMap(*) bool data(
               false, true, true, true,false,false,false,false,false,false,false,false,false,false,false,false,
               false,false,false,false,false,false,false,false,false,false, true, true,false,false,false,false,
               false,false,false,false, true, true, true, true, true, true, true, true, true, true, true,false,
               false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,
                true, true);

declare pad byte;

declare    accum(4) byte at(.accum1);


ChkSegAlignment: procedure(seg) public;    /* seg = 0 => CSEG, seg = 1 => DSEG */
    declare seg byte;

    if segHasData(seg) then
    do;
        if HaveTokens then
        do;
            accum1 = GetNumVal;
            if alignTypes(seg) <> accum1$lb then
                call ExpressionError;
        end;
        else if alignTypes(seg) <> 3 then    /* no speficier - check byte algined */
            call ExpressionError;
    end;
    else
    do;
        segHasData(seg) = TRUE;
        if HaveTokens then
        do;
            accum1 = GetNumVal;
            if accum1 = 1 or accum1 = 2 then    /* only allow inPage and Page */
                alignTypes(seg) = low(accum1);
            else
                call ExpressionError;
        end;
    end;
end;


Cond2Acc: procedure(cond) public;    /* convert conditional result to accum1 */
    declare cond byte;        /* 0 or 0ffffh */

    accum1 = cond;
    if accum1 then
        accum1 = 0FFFFh;
end;

UpdateHiLo: procedure(hilo) public;
    declare hilo byte;

    if (acc1Flags and (UF$EXTRN + UF$SEGMASK)) <> 0 then
        acc1Flags = (acc1Flags and not UF$BOTH) or hilo;
end;

HandleOp: procedure public;
    do case topOp;
/* 0 */        ;
/* 1 */        call FinishLine;        /* CR */
/* 2 */        goto case3;            /* ( */
/* 3 */ case3:    do;                /* ) */
            if not (topOp = T$LPAREN and newOp = T$RPAREN) then
                call BalanceError;

            if tokenType(0) = O$DATA then
            do;
                tokenSize(0) = 1;
                tokenAttr(0) = 0;
                b6B36 = TRUE;
            end;

            expectOp = inNestedParen;
            if newOp = T$RPAREN then
                b6B2C = TRUE;
        end;
/* 4 */        accum1 = accum1 * accum2;    /* * */
/* 5 */        accum1 = accum1 + accum2;    /* + */
/* 6 */        do;                /* , */
            call SyntaxError;
            call PopToken;
        end;
/* 7 */        accum1 = accum1 - accum2;    /* - */
/* 8 */        ;                /* unary + */
/* 9 */        do;                /* / */
            if accum2 = 0 then
                call ValueError;

            accum1 = accum1 / accum2;
        end;
/* 10 */    accum1 = -accum1;            /* unary - */
/* 11 */    call Cond2Acc(accum1 = accum2);        /* EQ */
/* 12 */    call Cond2Acc(accum1 < accum2);        /* LT */
/* 13 */    call Cond2Acc(accum1 <= accum2);    /* LE */
/* 14 */    call Cond2Acc(accum1 > accum2);        /* GT */
/* 15 */    call Cond2Acc(accum1 >= accum2);    /* GE */
/* 16 */    call Cond2Acc(accum1 <> accum2);    /* NE */
/* 17 */    accum1 = not accum1;            /* NOT */
/* 18 */    accum1 = accum1 and accum2;        /* AND */
/* 19 */    accum1 = accum1 or accum2;        /* OR */
/* 20 */    accum1 = accum1 xor accum2;        /* XOR */
/* 21 */    do;                    /* MOD */
            if accum2 = 0 then
                call ValueError;
            accum1 = accum1 mod accum2;
        end;
/* 22 */    do;                    /* SHL */
            if accum2$lb <> 0 then
                accum1 = shl(accum1, accum2);
        end;
/* 23 */    do;                    /* SHR */
            if accum2$lb <> 0 then
                accum1 = shr(accum1, accum2);
        end;
/* 24 */    do;                    /* HIGH */
            accum1 = high(accum1);
            call UpdateHiLo(UF$HIGH);
        end;
/* 25 */    do;                    /* LOW */
            accum1 = low(accum1);
            call UpdateHiLo(UF$LOW);
        end;
/* 26 */    do;                    /* DB ? */
            if tokenType(0) <> O$STRING then
            do;
                accum1 = GetNumVal;
                if accum1$hb - 1 < 0FEh then    /* not 0 or FF */
                    call ValueError;
                curOpFlags = 22h;   /* never used -- getnum to acc1 & collect high(acc2) */
                if (acc1Flags and UF$BOTH) = UF$BOTH then
                do;
                    call ValueError;
                    acc1Flags = (acc1Flags and not UF$BOTH) or UF$LOW;
                end;
            end;
            else
            do;
                acc1Flags = 0;
                tokenType(0) = O$DATA;
            end;

            if IsReg(acc1ValType) then
                call OperandError;
            nextTokType = O$DATA;
            inDB = TRUE;
        end;
/* 27 */    do;                    /* DW ? */
            nextTokType = O$DATA;
            inDW = TRUE;
        end;
/* 28 */    do;                    /* DS ? */
            segSize(activeSeg) = segSize(activeSeg) + accum1;
            showAddr = TRUE;
        end;
/* 29 */ case29:                    /* EQU ? */
        do;
            showAddr = TRUE;
            if (acc1Flags and UF$EXTRN) = UF$EXTRN then    /* cannot SET or EQU to external */
            do;
                call ExpressionError;
                acc1Flags = 0;
            end;
            labelUse = 1;
            call UpdateSymbolEntry(accum1, (K$SET + 4) - topOp);    /* 4 for set, 5 for equ */
            expectingOperands = FALSE;
        end;
/* 30 */    goto case29;                /* SET ? */
/* 31 */    do;                    /* ORG ? */
            showAddr = TRUE;
            if (acc1Flags and UF$EXTRN) <> UF$EXTRN then
            do;
                if (acc1Flags and UF$BOTH) <> 0 then
                    if (acc1Flags and UF$SEGMASK) <> activeSeg
                        or (acc1Flags and UF$BOTH) <> UF$BOTH then
                        call ExpressionError;
            end;
            else
                call ExpressionError;

            if ctlOBJECT then
                if segSize(activeSeg) > maxSegSize(activeSeg) then
                    maxSegSize(activeSeg) = segSize(activeSeg);
            segSize(activeSeg) = accum1;
        end;
/* 32 */    do;                    /* END ? */
            if tokenIdx > 0 then
            do;
                startOffset = GetNumVal;
                startDefined = 1;
                startSeg = acc1Flags and 7;
                if (acc1Flags and UF$EXTRN) = UF$EXTRN then
                    call ExpressionError;
                if IsReg(acc1ValType) then
                    call OperandError;

                showAddr = TRUE;
            end;
$IF MACRO
            kk = mSpoolMode;
            mSpoolMode = 0;

            if macroCondSP > 0 or kk then
$ELSE
            if ifDepth > 0 then
$ENDIF
                call NestingError;
            if newOp <> T$CR then
                call SyntaxError;
            if expectOp then
                b6B33 = TRUE;
            else
                call SyntaxError;

        end;
/* 33 */    do;                    /* IF ? */
            if expectOp then
            do;
                condAsmSeen = TRUE;
                call Nest(2);        /* push current skip/else status */
                xRefPending = TRUE;        /* push current skip/else status */
                if skipIf(0) = FALSE then    /* if not skipping set new status */
                    skipIf(0) = not ((low(accum1) and 1) = 1);
                inElse(0) = FALSE;        /* not in else at this nesting level */
            end;
        end;
/* 34 */    do;                    /* ELSE ? */
            condAsmSeen = TRUE;
$IF MACRO
            if macroCondStk(0) <> 2 then    /* check not mid macro nest */
$ELSE
            if ifDepth = 0 then         /* invalid if not in if */
$ENDIF
                call NestingError;
            else if not inElse(0) then    /* shouldn't be in else at this level */
            do;
                if not skipIf(0) then    /* IF was active so ELSE forces skip */
                    skipIf(0) = TRUE;
                else            /* IF inactive so revert to previous skipping status */
                    skipIf(0) = skipIf(ifDepth);
                inElse(0) = TRUE;    /* in else at this nesting level */
            end;
            else
                call NestingError;    /* multiple else !! */
        end;
/* 35 */    do;                    /* ENDIF ? */
            if expectOp then
            do;
                condAsmSeen = TRUE;
                call UnNest(2);    /* revert to previous status */
            end;
        end;
        /* in the following topOp = 36 and nextTokType = O$DATA
           except where noted on return from MkCode */
/* 36 */    do;                    /* LXI ? */
            if nameLen = 1 then
                if name(0) = 'M' then
                    call SyntaxError;
            call MkCode(85h);    /* topOp = 2Ch on return */
        end;
/* 37 */    do;                /* POP DAD PUSH INX DCX ? */
            if nameLen = 1 then
                if name(0) = 'M' then
                    call SyntaxError;
            call MkCode(5);
        end;
/* 38 */    call MkCode(7);        /* LDAX STAX ? */
/* 39 */    call MkCode(2);        /* ADC ADD SUB ORA SBB XRA ANA CMP ? */
/* 40 */    call MkCode(8);        /* ADI OUT SBI ORI IN CPI SUI XRI ANI ACI ? */
/* 41 */    call MkCode(46h);    /* MVI ?  topOp = 40 on return */
/* 42 */    call MkCode(6);        /* INR DCR ? */
/* 43 */    call MkCode(36h);    /* MOV   topOp = 39 on return*/
/* 44 */    call MkCode(0);        /* CZ CNZ JZ STA JNZ JNC LHLD */
                        /* CP JC SHLD CPE CPO CM LDA JP JM JPE */
                        /* CALL JPO CC CNC JMP */
/* 45 */    call MkCode(0);        /* RNZ STC DAA DI SIM SPHL RLC */
                        /* RP RAL HLT RM RAR RPE RET RIM */
                        /* PCHL CMA CNC RPO EI XTHL NOP */
                        /* RC RNX XCHG RZ RRC */
/* 46 */    call MkCode(6);        /* RST */
/* 47 */    activeSeg = 0;            /* ASEG ? */
/* 48 */    do;                /* CSEG ? */
            activeSeg = 1;
            call ChkSegAlignment(0);
        end;
/* 49 */    do;                /* DSEG ? */
            activeSeg = 2;
            call ChkSegAlignment(1);
        end;

/* 50 */    do;                /* PUBLIC */
            inPublic = TRUE;
            labelUse = 0;
            call UpdateSymbolEntry(0, O$REF);
        end;
/* 51 */    do;                /* EXTRN ? */
            inExtrn = TRUE;
            if externId = 0 and IsPhase1 and ctlOBJECT then
            do;
                CHKOVL$2;
                call WriteModhdr;
            end;
            labelUse = 0;
            call UpdateSymbolEntry(externId, O$TARGET);
            if IsPhase1 and ctlOBJECT and not badExtrn then
            do;
                CHKOVL$2;
                call WriteExtName;
            end;
            if not badExtrn then
                externId = externId + 1;
            badExtrn = FALSE;
        end;
/* 52 */    do;                /* NAME */
            if tokenIdx <> 0 and noOpsYet then
            do;
                /* set the module name in the header - padded to 6 chars */
                call move(6, .spaces6, .aModulePage);
                call move(moduleNameLen := nameLen, .name, .aModulePage);
            end;
            else
                call SourceError('R');

            call PopToken;
        end;
/* 53 */    segSize(SEG$STACK) = accum1;    /* STKLN ? */
$IF MACRO
/* 54 */    call DoMacro;            /* MACRO ? */
/* 55 */    call DoMacroBody;
/* 56 */    call DoEndm;            /* ENDM */
/* 57 */    call DoExitm;            /* EXITM */
/* 58 */    do;
            tmac.mtype = M$INVOKE;
            call Sub7327;
        end;
/* 59 */    call DoIrpX(1);        /* IRP ? */
/* 60 */    call DoIrpX(2);        /* IRPC */
/* 61 */    call Sub770B;
/* 62 */    call DoRept;            /* REPT ? */
/* 63 */    call Sub787A;            /* LOCAL */
/* 64 */    call Sub78CE;
/* 65 */    do;                /* NUL */
            call Cond2Acc(tokenType(0) = K$NUL);
            call PopToken;
            acc1Flags = 0;
        end;
$ENDIF
    end;

    if topOp <> T$CR then
        noOpsYet = FALSE;
end;

Parse: procedure public;

    IsExpressionOp: procedure bool;
        if yyType > T$RPAREN then
            if yyType <> T$COMMA then
                if yyType < K$DB then
                    return TRUE;
        return FALSE;
    end;

    IsVar: procedure(type) bool;
        declare type byte;
        return type = O$NAME or type = O$MACROID;
    end;


    UpdateIsInstr: procedure;
        if not isInstrMap(topOp) then
            isInstr = FALSE;
    end;



    do while 1;
        if not (yyType = T$CR or yyType >= K$END and yyType <= K$ENDIF)
           and skipIf(0)
$IF MACRO
               or (opFlags(yyType) < 128 or inQuotes) and mSpoolMode

$ENDIF
            then
        do;
            needsAbsValue = FALSE;
            call PopToken;
            return;
        end;
        
        if phase <> 1 then
            if inExpression then
                if IsExpressionOp then
                    if GetPrec(yyType) <= GetPrec(opStack(opSP)) then
                        call ExpressionError;

        if GetPrec(newOp := yyType) > GetPrec(topOp := opStack(opSP)) or newOp = T$LPAREN then
        do;    /* SHIFT */
            if opSP >= 16 then
            do;
                opSP = 0;
                call StackError;
            end;
            else
                opStack(opSP := opSP + 1) = newOp;
            if newOp = T$LPAREN then
            do;
                inNestedParen = expectOp;
                expectOp = TRUE;
            end;
            if phase > 1 then
                inExpression = IsExpressionOp;
            return;
        end;

    /* REDUCE */
        inExpression = 0;
        if not expectOp and topOp > T$RPAREN then
            call SyntaxError;

        if topOp = T$BEGIN then /* topOp used so set to newOp */
            topOp = newOp;
        else
            opSP = opSP - 1;    /* pop Op */
        

        if (curOpFlags := opFlags(topOp)) then      /* -------x -> getnum to acc1 & copy to acc2 */
        do;
            accum2 = GetNumVal;
            acc2Flags = acc1Flags;
            acc2NumVal = acc1NumVal;
            acc2ValType = acc1ValType;
        end;

        if (curOpFlags := ror(curOpFlags, 1)) then  /* ------x- -> getnum to acc1 */
            accum1 = GetNumVal;

        if not hasVarRef then
            hasVarRef = IsVar(acc1ValType) or IsVar(acc2ValType);

        nextTokType = O$NUMBER;
        if topOp > T$RPAREN and topOp < K$DB then    /* expression topOp */
            call Sub4291;
        else
        do;
            call UpdateIsInstr;
            call ChkInvalidRegOperand;
        end;

        call HandleOp;
        if not isExprOrMacroMap(topOp) then
            expectOp = FALSE;

        if b6B2C then
        do;
            b6B2C = FALSE;
            return;
        end;

        if topOp <> K$DS and showAddr then
            effectiveAddr = accum1;

        if (curOpFlags and 1Eh) <> 0 then       /* --xxxx-- -> collect bytes */
            call PushToken(nextTokType);

        do ii = 0 to 3;
            if (curOpFlags := ror(curOpFlags, 1)) then  /* --xxxx-- -> collect high/low acc1/acc2 */
                call CollectByte(accum(ii));
        end;

        tokenAttr(0) = acc1Flags;
        tokenSymId(0) = acc1NumVal;
        if ror(curOpFlags, 1) then          /* -x------ -> list */
            if newOp = T$COMMA then
            do;
                yyType = topOp;
                expectOp = TRUE;
            end;
    end;
end;



DoPass: procedure public;
    do while finished = FALSE;
        call Tokenise;
        call Parse;
    end;
end;

end;
src/emit.plx
$IF MACRO
emitm: do;
$include(:f3:emitm.ipx)
$ELSE
emitn: do;
$include(:f3:emitn.ipx)
$ENDIF

declare    fixupInitialLen(*) byte data(1, 2, 1, 3),
    fixupRecLenPtrs(*) apointer data(.r$publics.len, .r$interseg.len, .r$extref.len, .r$content.len),
    fixupRecLenChks(*) byte data(123, 58, 57, 124),
    b6D7E(*) byte data(10, 12h, 40h); /* 11 bits 00010010010 index left to right */
                                      /* O_LABEL, O_REF, O_NAME */


declare    r$modhdr MODHDR$T initial(2),
    (dta$p, recSym$p) pointer;



WriteRec: procedure(rec$p) public;
    declare rec$p pointer,
        len$p pointer, recLen word,
        i byte, crc byte;
    declare len based len$p word;
    declare ch based len$p byte;

    len$p = rec$p + 1;
    recLen = (len := len + 1) + 3;    /* include crc byte + type + len word */
    crc = 0;            /* crc */
    len$p = len$p - 1;
    do i = 2 to recLen;
        crc = crc - ch;
        len$p = len$p + 1;
    end;
    ch = crc;            /* insert crc byte */
    call Write(objfd, rec$p, recLen, .statusIO);
    call IoErrChk;
end;


GetFixupType: procedure byte;
    declare attr byte;
    if ((attr := tokenAttr(spIdx)) and 5Fh) = 0 then
        return 3;
    if (attr and UF$EXTRN) <> 0 then    /* external */
        return 2;
    if (fixupSeg := attr and UF$SEGMASK) = 0 then    /* absolute */
        return 3;
    return (fixupSeg <> activeSeg) and 1;
end;


ReinitFixupRecs: procedure public;
    declare i byte;
    declare wrd based dta$p word;
    do i = 0 to 3;
        ii = (i - 1) and 3; /* order as content, publics, interseg, externals */
        dta$p = fixupRecLenPtrs(ii);
        if wrd > fixupInitialLen(ii) then
            call WriteRec(dta$p - 1);

        wrd = fixupInitialLen(ii);
        fixIdxs(ii) = 0;
        if curFixupType <>  ii then
            initFixupReq(ii) = TRUE;
    end;
    r$content.offset = itemOffset + segSize(r$content.segid := activeSeg);
    r$publics.segid = curFixupHiLoSegId;
    r$interseg.segid = tokenAttr(spIdx) and 7;
    r$interseg.hilo, r$extref.hilo = curFixupHiLoSegId;
end;



AddFixupRec: procedure;
    declare effectiveOffset word;

    declare wrd based dta$p word;

    dta$p = fixupRecLenPtrs(curFixupType := GetFixupType);
    if wrd > fixupRecLenChks(curFixupType) or r$content.len + tokenSize(spIdx) > 124 then
        call ReinitFixupRecs;

    if firstContent then
    do;
        firstContent = FALSE;
        r$content.offset = segSize(r$content.segid := activeSeg) + itemOffset;
    end;
    else if r$content.segid <> activeSeg
          or (effectiveOffset := r$content.offset + fix6Idx) <> segSize(activeSeg) + itemOffset
          or effectiveOffset < r$content.offset then
        call ReinitFixupRecs;


    do case curFixupType;
/* 0 */        do;
            if initFixupReq(0) then
            do;
                initFixupReq(0) = FALSE;
                r$publics.segid = curFixupHiLoSegId;
            end;
            else if r$publics.segid <> curFixupHiLoSegId then
                call ReinitFixupRecs;
        end;
/* 1 */        do;
            if initFixupReq(1) then
            do;
                initFixupReq(1) = FALSE;
                r$interseg.segid = tokenAttr(spIdx) and 7;
                r$interseg.hilo = curFixupHiLoSegId;
            end;
            else if r$interseg.hilo <> curFixupHiLoSegId or (tokenAttr(spIdx) and 7) <> r$interseg.segid then
                call ReinitFixupRecs;
        end;
/* 2 */        do;
            if initFixupReq(2) then
            do;
                initFixupReq(2) = FALSE;
                r$extref.hilo = curFixupHiLoSegId;
            end;
            else if r$extref.hilo <> curFixupHiLoSegId then
                call ReinitFixupRecs;

        end;
/* 3 */        ;        /* abs no fixup */
    end;
end;


RecAddContentBytes: procedure;
    declare i byte;

    declare ch based contentBytePtr byte;

    do i = 1 to tokenSize(spIdx);
        r$content.dta(fix6Idx) = ch;
        fix6Idx = fix6Idx + 1;
        contentBytePtr = contentBytePtr + 1;
    end;
    r$content.len = r$content.len + tokenSize(spIdx);
end;



IntraSegFix: procedure;
    r$reloc.len = r$reloc.len + 2;
    r$reloc.dta(fix22Idx) = fixOffset;
    fix22Idx = fix22Idx + 1;
end;


InterSegFix: procedure;
    r$interseg.len = r$interseg.len + 2;
    r$interseg.dta(fix24Idx) = fixOffset;
    fix24Idx = fix24Idx + 1;
end;

ExternalFix: procedure;
    r$extref.dta(fix20Idx) = tokenSymId(spIdx);
    r$extref.dta(fix20Idx + 1) = fixOffset;
    r$extref.len = r$extref.len + 4;
    fix20Idx = fix20Idx + 2;
end;

Sub7131: procedure;
    curFixupHiLoSegId = shr(tokenAttr(spIdx) and 18h, 3);
    fixOffset = segSize(activeSeg) + itemOffset;
    if not (inDB or inDW) and (tokenSize(spIdx) = 2 or tokenSize(spIdx) = 3) then
        fixOffset = fixOffset + 1;
    call AddFixupRec;
    contentBytePtr = startItem;
    call RecAddContentBytes;
    do case GetFixupType;
/* 0 */     call IntraSegFix;
/* 1 */        call InterSegFix;
/* 2 */        call ExternalFix;
/* 3 */        ;            /* no fixup as absolute */
    end;
end;


WriteExtName: procedure public;
    declare i byte;

    if r$extnames.len + 9 > 125 then    /* check room for name */
    do;
        call WriteRec(.r$extnames);    /* flush existing extNam Record */
        r$extnames.type = OMF$EXTNAMES;
        r$extnames.len = 0;
        extNamIdx = 0;
    end;
    r$extnames.len = r$extnames.len + nameLen + 2;    /* update length for this ref */
    r$extnames.dta(extNamIdx) = nameLen;        /* Write len */
    extNamIdx = extNamIdx + 1;
    do i = 0 to nameLen;            /* and name */
        r$extnames.dta(extNamIdx + i) = name(i);
    end;

    r$extnames.dta(extNamIdx + nameLen) = 0;    /* and terminating 0 */
    extNamIdx = extNamIdx + nameLen + 1;    /* update where next ref writes */
end;

WriteSymbols: procedure(publics);            /* publics= TRUE -> PUBLICs else LOCALs */
    declare publics byte;
    declare segId byte;
    declare tf based tokenSymCurP structure(type byte, flags byte);

    AddSymbol: procedure;
        declare offsetP apointer;
        declare symNam based dta$p (1) byte;
        declare len based recSym$p byte;
        declare symOffset based recSym$p word;
        declare offsetInSeg based offsetP word;

        if (tf.flags and UF$EXTRN) <> 0 then
            return;
        offsetP = tokenSymCurP - 2;   /* tokenSymCurP -> type so back off to offset info */
        symOffset = offsetInSeg;            /* pick up the offset */
                                            /* packed name is at tokenSymCurP - 6 */
        call UnpackToken(tokenSymCurP - 6, (dta$p := (recSym$p := recSym$p + 2) + 1));
        symNam(6) = ' ';    /* trailing space to ensure end */
        len = 0;

        do while symNam(0) <> ' ';    /* find length of name */
            len = len + 1;
            dta$p = dta$p + 1;
        end;
        symNam(0) = 0;            /* terminate name with 0 */
        recSym$p = dta$p + 1;
    end;

    flushSymRec: procedure;
        if (r$publics.len := recSym$p - .r$publics.segid) > 1 then    /* something to Write */
            call WriteRec(.r$publics);
        r$publics.type = (publics and 4) or OMF$LOCALS;        /* PUBLIC or LOCAL */
        r$publics.segid = segId;
        recSym$p = .r$publics.dta;
    end;

    recSym$p = .r$publics.dta;
    do segId = 0 to 4;
        call FlushSymRec;    /* also sets up segid for new record */
        tokenSymCurP = symTab(TID$SYMBOL) - 2;        /* point to type byte of user symbol (-1) */

        do while (tokenSymCurP := tokenSymCurP + 8) < endSymTab(TID$SYMBOL);
            if recSym$p > .r$publics.crc - (MAXSYMSIZE + 4) then        /* make sure there is room */
                call FlushSymRec;

            if (tf.flags and UF$SEGMASK) = segId     /* seg id matches */
$IF MACRO
               and tf.type <> T$MACRONAME and nonHiddenSymbol  /* not macro name or hidden symbol */
$ENDIF
               and not TestBit(tf.type, .b6D7E) and     /* not O_LABEL, O_REF or O_NAME */
               (not publics or (tf.flags and UF$PUBLIC) <> 0) then
                   call AddSymbol;
        end;
        call FlushSymRec;
    end;
end;



WriteModhdr: procedure public;
    declare w based dta$p word;
    declare b based dta$p byte;
    declare i byte;

    /* fill the module name */
    call move((r$modhdr.dta(0) := moduleNameLen), .aModulePage, .r$modhdr.dta(1));
    dta$p = .r$modhdr + moduleNameLen + 4;
    w = 0;    /* the trnId & trnVn bytes */
    dta$p = dta$p + 1;    /* past trnId byte */

    if segSize(SEG$CODE) < maxSegSize(SEG$CODE) then    /* code segment */
        segSize(SEG$CODE) = maxSegSize(SEG$CODE);
    if segSize(SEG$DATA) < maxSegSize(SEG$DATA) then    /* data segment */
        segSize(SEG$DATA) = maxSegSize(SEG$DATA);

    do i = 1 to 4;
        dta$p = dta$p + 1;
        b = i;        /* seg id */
        dta$p = dta$p + 1;
        w = segSize(i);    /* seg size */
        dta$p = dta$p + 2;
        b = alignTypes(i - 1);    /* aln typ */
    end;
    r$modhdr.len = moduleNameLen + 19;    /* set record length (trnId/Vn, 4 * (segid, segsize, align), crc) */
    call WriteRec(.r$modhdr);
end;

WriteModend: procedure public;
    declare lenb byte at (.r$eof.len);
    r$modend.modtyp = startDefined;
    r$modend.segid = startSeg;
    r$modend.offset = startOffset;
    call WriteRec(.r$modend);
    lenb = 0;
    call WriteRec(.r$eof);
end;

Ovl8: procedure public;
    itemOffset = 0;
    tokI = 1;
    spIdx = 1;
    if b6B33 then
        ;
    else
    do while spIdx <> 0;
        spIdx = NxtTokI;
        endItem = tokStart(spIdx) + tokenSize(spIdx);
        startItem = tokStart(spIdx);
        if IsSkipping or not isInstr then
            endItem = startItem;
        if endItem > startItem then
        do;
            call Sub7131;
            itemOffset = itemOffset + tokenSize(spIdx);
        end;
        if not(inDB or inDW) then
            spIdx = 0;
    end;
end;


Ovl11: procedure public;
    if externId <> 0 then
    do;
        call Seek(objfd, SEEKABS, .azero, .azero, .statusIO);    /* rewind */
        call WriteModhdr;
        call Seek(objfd, SEEKEND, .azero, .azero, .statusIO);    /* back to end */
    end;
    r$publics.type = OMF$PUBLICS;          /* public declarations record */
    r$publics.len = 1;
    r$publics.segid = SEG$ABS;
    r$publics.dta(0) = 0;
    call WriteSymbols(TRUE);      /* EMIT PUBLICS */
    if ctlDEBUG then
        call WriteSymbols(FALSE); /* EMIT LOCALS */
end;
end;
src/keyn.plm
keyn: do;
$include(:f3:keyn.ipx)

declare copyright(*) byte data('(C) 1976,1977,1979,1980 INTEL CORP');
declare stdKeywords(151) KEYWORD$T public initial(
/*
    4 byte packed keyword
    byte opcode base
    byte offset to next entry or 0 if end
    byte type
    byte flags
*/
 /* [    token    ] opBase offset  type        flags */
    0A528h,      0,    0,    0,      K$NE,   0,  /* NE */
     63B0h,      0, 0CCh,    0,   K$IMM16,   0,  /* CZ */
         0,      0,    0,    0,         0,   0,
    0BFB6h,      0, 0C0h,    0,  K$SINGLE,   0,  /* RNZ */
    0B354h,      0, 0C1h,    0,   K$REG16,   0,  /* POP */
     6EE9h,      0,    0,    0,     K$EQU,   0,  /* EQU */
    0AD70h,      0,    0, 0E8h,      K$OR,   0,  /* OR */
    0A1A5h,      0,    6, 0E8h,     K$MVI,   0,  /* MVI */
    0C6CFh,      0,  37h,    0,  K$SINGLE,   0,  /* STC */
    0C6CDh,  6158h,    0,    0, K$SPECIAL, 1Bh,  /* STACK */
     6615h,      0,  27h,    0,  K$SINGLE,   0,  /* DAA */
     988Dh, 0E100h,  0Ah,    0,  K$LDSTAX,   0,  /* LDAX */
     61F6h,      0, 0C4h,    0,   K$IMM16,   0,  /* CNZ */
     53CFh,      0,  88h, 0D8h,   K$ARITH,   0,  /* ADC */
     53D0h,      0,  80h,    0,   K$ARITH,   0,  /* ADD */
     6748h,      0, 0F3h, 0D0h,  K$SINGLE,   0,  /* DI */
         0,      0,    0,    0,         0,   0,
         0,      0,    0,    0,         0,   0,
         0,      0,    0,    0,         0,   0,
     53D5h,      0, 0C6h, 0C8h,    K$IMM8,   0,  /* ADI */
     6A40h,      0,    3, 0F0h, K$REGNAME,   0,  /* E */
         0,      0,    0,    0,         0,   0,
         0,      0,    0,    0,         0,   0,
         0,      0,    0,    0,         0,   0,
    0A088h,      0,    0,    0,     K$MOD,   0,  /* MOD */
    0AD83h,      0,    0,    0,     K$ORG,   0,  /* ORG */
         0,      0,    0,    0,         0,   0,
     8F70h,      0, 0CAh, 0E8h,   K$IMM16,   0,  /* JZ */
     68E9h,  76C0h,    0,    0,    K$DSEG,   0,  /* DSEG */
    0C488h,      0,    0,    0,     K$SET,   0,  /* SET */
         0,      0,    0,    0,         0,   0,
    0C521h,      0,  30h,    0,  K$SINGLE,   2,  /* SIM */
         0,      0,    0,    0,         0,   0,
         0,      0,    0,    0,         0,   0,
    0A4A1h,  6A40h,    0,    0,    K$NAME,   0,  /* NAME */
    0C6CDh,      0,  32h,    0,   K$IMM16,   0,  /* STA */
    0AE08h,      0, 0D3h,    0,    K$IMM8,   0,  /* OUT */
     6630h,      0,    0,    0,      K$DB,   0,  /* DB */
     8DB6h,      0, 0C2h,    0,   K$IMM16,   0,  /* JNZ */
         0,      0,    0,    0,         0,   0,
     6618h,      0,    9, 0C0h,   K$REG16,   0,  /* DAD */
     8D9Fh,      0, 0D2h,    0,   K$IMM16,   0,  /* JNC */
    0A09Ah,      0,  40h, 0C0h,     K$MOV,   0,  /* MOV */
     8610h,      0,    0, 0C0h,      K$IF,   0,  /* IF */
     6E60h,      0,    0, 0A8h,     K$END,   0,  /* END */
     9938h,  6400h,  2Ah, 0B8h,   K$IMM16,   0,  /* LHLD */
     9600h,      0,    5, 0C0h, K$REGNAME,   0,  /* L */
    0C6F6h,      0,  90h,    0,   K$ARITH,   0,  /* SUB */
    0C634h,  9600h, 0F9h,    0,  K$SINGLE,   0,  /* SPHL */
    0C405h,      0, 0DEh,    0,    K$IMM8,   0,  /* SBI */
    0B3FBh,      0,    6,    0, K$REGNAME,   0,  /* PSW */
    0BF4Fh,      0,    7,    0,  K$SINGLE,   0,  /* RLC */
     5780h,      0,    0,    0, K$REGNAME,   0,  /* B */
         0,      0,    0,    0,         0,   0,
     6220h,      0, 0F4h, 0F0h,   K$IMM16,   0,  /* CP */
         0,      0,    0,    0,         0,   0,
    0AD85h,      0, 0F6h,    0,    K$IMM8,   0,  /* ORI */
    0B11Bh,  6A40h,    2,    0, K$SPECIAL,   0,  /* PAGE */
         0,      0,    0,    0,         0,   0,
         0,      0,    0,    0,         0,   0,
     5629h,  76C0h,    0,    0,    K$ASEG,   0,  /* ASEG */
     8750h,      0, 0DBh,    0,    K$IMM8,   0,  /* IN */
     6E60h,  8610h,    0, 0D0h,   K$ENDIF,   0,  /* ENDIF */
         0,      0,    0,    0,         0,   0,
     8BD8h,      0, 0DAh, 0F0h,   K$IMM16,   0,  /* JC */
    0AD7Dh,      0, 0B0h,    0,   K$ARITH,   0,  /* ORA */
    0C3FEh,      0,  98h,    0,   K$ARITH,   0,  /* SBB */
    0C6D7h,  9A10h,    0,    0,   K$STKLN,   0,  /* STKLN */
    0BFE0h,      0, 0F0h,    0,  K$SINGLE,   0,  /* RP */
    0C4F8h,  6400h,  22h,    0,   K$IMM16,   0,  /* SHLD */
    0C078h,      0, 0C7h,    0,     K$RST,   0,  /* RST */
     6231h,      0, 0ECh,    0,   K$IMM16,   0,  /* CPE */
    0B436h,  9957h,    0, 0E8h,  K$PUBLIC,   0,  /* PUBLIC */
    0BDA0h,      0,  17h, 0E8h,  K$SINGLE,   0,  /* RAL */
     80E0h,      0,  76h, 0E8h,  K$SINGLE,   0,  /* HLT */
     6235h,      0, 0FEh,    0,    K$IMM8,   0,  /* CPI */
    0BF68h,      0, 0F8h,    0,  K$SINGLE,   0,  /* RM */
         0,      0,    0,    0,         0,   0,
         0,      0,    0,    0,         0,   0,
    0BDA6h,      0,  1Fh,    0,  K$SINGLE,   0,  /* RAR */
     805Bh,  7D00h,    0, 0D0h,    K$HIGH,   0,  /* HIGH */
     623Bh,      0, 0E4h, 0D8h,   K$IMM16,   0,  /* CPO */
    0B447h,  7D00h, 0C5h, 0E0h,   K$REG16,   0,  /* PUSH */
         0,      0,    0,    0,         0,   0,
    0C6FDh,      0, 0D6h, 0F0h,    K$IMM8,   0,  /* SUI */
     61A8h,      0, 0FCh,    0,   K$IMM16,   0,  /* CM */
         0,      0,    0,    0,         0,   0,
         0,      0,    0,    0,         0,   0,
    0BFF1h,      0, 0E8h,    0,  K$SINGLE,   0,  /* RPE */
     62A9h,  76C0h,    0,    0,    K$CSEG,   0,  /* CSEG */
    0BE48h,      0, 0C9h,    0,  K$SINGLE,   0,  /* RET */
     876Eh,      0,    4,    0,  K$INRDCR,   0,  /* INR */
    0BEE1h,      0,  20h,    0,  K$SINGLE,   2,  /* RIM */
         0,      0,    0,    0,         0,   0,
    0B16Ch,  9600h, 0E9h,    0,  K$SINGLE,   0,  /* PCHL */
     988Dh,      0,  3Ah,    0,   K$IMM16,   0,  /* LDA */
     7000h, 0BF90h,    0,    0,   K$EXTRN,   0,  /* EXTRN */
     8774h,      0,    3, 0B0h,   K$REG16,   0,  /* INX */
     61B5h,      0,  2Fh,    0,  K$SINGLE,   0,  /* CMA */
         0,      0,    0,    0,         0,   0,
     61B7h,      0,  3Fh,    0,  K$SINGLE,   0,  /* CNC */
    0BFFBh,      0, 0E0h,    0,  K$SINGLE,   0,  /* RPO */
    0C6CDh, 0E100h,    2,  70h,  K$LDSTAX,   0,  /* STAX */
    0E5BDh,      0, 0A8h,    0,   K$ARITH,   0,  /* XRA */
     9A5Bh,      0,    0,    0,     K$LOW,   0,  /* LOW */
     6D88h,      0, 0FBh,    0,  K$SINGLE,   0,  /* EI */
     8DE0h,      0, 0F2h,    0,   K$IMM16,   0,  /* JP */
     6676h,      0,    5, 0D0h,  K$INRDCR,   0,  /* DCR */
     6400h,      0,    2,    0, K$REGNAME,   0,  /* D */
     555Dh,      0, 0A0h,    0,   K$ARITH,   0,  /* ANA */
    0E5C5h,      0, 0EEh,    0,    K$IMM8,   0,  /* XRI */
     8D68h,      0, 0FAh,    0,   K$IMM16,   0,  /* JM */
     5560h,      0,    0,    0,     K$AND,   0,  /* AND */
     5140h,      0,    7,  38h, K$REGNAME,   0,  /* A */
    0E614h,  9600h, 0E3h,    0,  K$SINGLE,   0,  /* XTHL */
         0,      0,    0,    0,         0,   0,
     876Ch,  5449h,    1,    0, K$SPECIAL,   0,  /* INPAGE */
     5565h,      0, 0E6h,    0,    K$IMM8,   0,  /* ANI */
     9B00h,      0,    0,    0,      K$LT,   0,  /* LT */
     8DF1h,      0, 0EAh,    0,   K$IMM16,   0,  /* JPE */
     61C4h,      0, 0B8h,  20h,   K$ARITH,   0,  /* CMP */
     7BC0h,      0,    0,    0,      K$GT,   0,  /* GT */
     6978h,      0,    0,  78h,      K$DW,   0,  /* DW */
     6EC8h,      0,    0,    0,      K$EQ,   0,  /* EQ */
     667Ch,      0,  0Bh,  50h,   K$REG16,   0,  /* DCX */
     6E1Fh,  6A40h,    0, 0A0h,    K$ELSE,   0,  /* ELSE */
    0A6D4h,      0,    0,    0,  K$SINGLE,   0,  /* NOP */
     9F01h, 0AD95h,    0,    0, K$SPECIAL, 1Ch,  /* MEMORY */
     5FE0h,  9600h, 0CDh,    0,   K$IMM16,   0,  /* CALL */
    0BDD8h,      0, 0D8h,    0,  K$SINGLE,   0,  /* RC */
     53ADh,      0, 0CEh,  80h,    K$IMM8,   0,  /* ACI */
    0BF9Fh,      0, 0D0h,    0,  K$SINGLE,   0,  /* RNC */
    0E36Ch,  76C0h, 0EBh,    0,  K$SINGLE,   0,  /* XCHG */
     8DFBh,      0, 0E2h,    0,   K$IMM16,   0,  /* JPO */
     68D8h,      0,    0,    0,      K$DS,   0,  /* DS */
    0C620h,      0,    6,    0,      K$SP,   0,  /* SP */
     9C40h,      0,    6,    0, K$REGNAME,   0,  /* M */
     98A8h,      0,    0,  38h,      K$LE,   0,  /* LE */
     6018h,      0, 0DCh,    0,   K$IMM16,   0,  /* CC */
     7D00h,      0,    4,  50h, K$REGNAME,   0,  /* H */
     61DFh,      0, 0D4h,  50h,   K$IMM16,   0,  /* CNC */
    0C4F8h,      0,    0,    0,     K$SHL,   0,  /* SHL */
     5DC0h,      0,    1,    0, K$REGNAME,   0,  /* C */
    0C170h,      0, 0C8h,    0,  K$SINGLE,   0,  /* RZ */
    0E556h,      0,    0,    0,     K$XOR,   0,  /* XOR */
     7968h,      0,    0,    0,      K$GE,   0,  /* GE */
    0A6D8h,      0,    0,    0,     K$NOT,   0,  /* NOT */
    0C4FEh,      0,    0,    0,     K$SHR,   0,  /* SHR */
     9BB5h,      0,    1,    0,     K$LXI,   0,  /* LXI */
     8D84h,      0, 0C3h,    0,   K$IMM16,   0,  /* JMP */
    0C03Fh,      0,  0Fh,    0,  K$SINGLE,   0   /* RRC */
);


end;
src/start.plx
$IF SMALL
starts: do;
$include(:f3:starts.ipx)
$ELSEIF MACRO
startm: do;
$include(:f3:startm.ipx)
$ELSE
startb: do;
$include(:f3:startb.ipx)
$ENDIF

$IF SMALL
declare CHKOVL$0 lit    'call OvlMgr(0)',
    CHKOVL$1 lit    'call OvlMgr(1)',
    CHKOVL$2 lit    'call OvlMgr(2)',
    CHKOVL$3 lit    'call OvlMgr(3)';
$ELSE
declare CHKOVL$0 lit    ' ',
    CHKOVL$1 lit    ' ',
    CHKOVL$2 lit    ' ',
    CHKOVL$3 lit    ' ';
$ENDIF

$IF MACRO
declare seekMZero word public data(0),
    b3782(2) byte public data(80h, 81h);
$ENDIF

declare    spaces24(*) byte public data('         '),
    spaces15(*) byte public data('         '),
    spaces6(*) byte public data(' '),
    spaces5(*) byte public data(' '),
    spaces4(*) byte public data('  '),
    spaces2(*) byte public data('  ', 0),
    ascCRLF(*) byte public data(CR, LF, 0),
    signonMsg(*) byte public data(CR, LF),
    asmHeader(*) byte public data('ISIS-II 8080/8085 MACRO ASSEMBLER, V4.1', TAB, TAB),
    aModulePage(*) byte public data('MODULE ', TAB, ' PAGE ', 0),
    bZERO byte public data(0),
    bTRUE byte public data(TRUE),
    copyright(*) byte data('(C) 1976,1977,1979,1980 INTEL CORP'),
    aStack(*) byte public data(CR, LF, 'STACK', 0),
    aTable(*) byte public data(CR, LF, 'TABLE', 0),
    aCommand(*) byte public data(CR, LF, 'COMMAND', 0),
    aEof(*) byte public data(CR, LF, 'EOF', 0),
    aFile(*) byte public data(CR, LF, 'FILE', 0),
    aMemory(*) byte public data(CR, LF, 'MEMORY', 0),
    aError(*) byte public data(' ERROR', CR, LF, 0),
    aError$0(*) byte public data(' ERROR, ', CR,LF, 0),
    aErrStrs(*) pointer public data(.aStack, .aTable, .aCommand, .aEof, .aFile, .aMemory),
    aErrStrsLen(*) byte public data(7, 7, 9, 5, 6, 8),
    aBadSyntax(*) byte public data('BAD SYNTAX', CR, LF),
    aCo(*) byte data(':CO:', 0);

$IF SMALL
declare    loadedOvl byte initial(4),
    ovlFile(*) byte public initial(':F0:ASM80.OV0 ');
$ENDIF

Physmem: procedure pointer public;
    declare top pointer at(4);

    return (top - 100h) and 0FF00h;
end;


GetCmdCh: procedure byte public;
    declare cmdch based cmdch$p byte;
    declare ch byte;

    ch = cmdch;
    cmdch$p = cmdch$p + 1;
    if 'a' <= ch and ch <= 'z' then
        ch = ch and 5Fh;
    return ch;
end;    


IoErrChk: procedure public;
    if statusIO = 0 then
        return;
    call Error(statusIO);
    call Exit;
end;


Flushout: procedure public;
    call Write(outfd, .outbuf, out$p - .outbuf, .statusIO);
    out$p = .outbuf;
end;

Outch: procedure(c) public;
    declare c byte;
    declare outc based out$p byte;

    if out$p = endOutBuf then
        call Flushout;
    outc = c;
    out$p = out$p + 1;
end;

OutStrN: procedure(s, n) public;
    declare s pointer, n byte;
    declare ch based s byte;

    do while n > 0;
        call Outch(ch);
        s = s + 1;
        n = n - 1;
    end;
end;

$IF SMALL
OvlMgr: procedure(ovl) public;
    declare ovl byte;
    declare entry$p pointer;

    if ovl > 4 then
    do;
        statusIO = 0Dh;
        call IoErrChk;
    end;
    if ovl <> loadedOvl then
    do;
        ovlFile(12) = ovl + '0';
        call Load(.ovlFile, 0, 0, .entry$p, .statusIO);
        call IoErrChk;
        loadedOvl = ovl;
    end;
end;
$ENDIF

CloseF: procedure(conn) public;
    declare conn word;

    call Close(conn, .statusIO);
end;

IsSpace: procedure bool public;
    return curChar = ' ';
end;

IsTab: procedure bool public;
    return curChar = TAB;
end;

IsWhite: procedure bool public;
    return IsSpace or IsTab;
end;

IsRParen: procedure bool public;
    return curChar = ')';
end;

IsCR: procedure bool public;
    return curChar = CR;
end;

IsComma: procedure bool public;
    return curChar = ',';
end;

$IF MACRO
IsLT: procedure bool public;
    return curChar = '<';
end;


IsGT: procedure bool public;
    return curChar = '>';
end;

$ENDIF

IsPhase1: procedure bool public;
    return phase = 1;
end;

Skip2EOL: procedure public;
    if not IsCR then
        do while GetCh <> 0Dh;
        end;
end;


ChkGenObj: procedure bool public;
$IF SMALL
    return (phase > 2) and ctlOBJECT;
$ELSE
    return (phase = 2) and ctlOBJECT;
$ENDIF
end;


IsPhase2Print: procedure bool public;
    return phase = 2 and ctlPRINT;
end;


WrConsole: procedure(buf$p, count) public;
    declare buf$p pointer, count word;

    call Write(0, buf$p, count, .statusIO);
    call IoErrChk;
end;


RuntimeError: procedure(errCode) public;
    declare errCode byte;

    if skipRuntimeError then
        return;

    if IsPhase1 and errCode = RTE$STACK then
    do;
        b6B33 = TRUE;
        return;
    end;

    aVar = .aError;        /* assume " ERROR\r\n" */
    if errCode = RTE$FILE then        /* file Error */
        aVar = .aError$0;    /* replace with " ERROR, " */

    call WrConsole(aErrStrs(errCode), aErrStrsLen(errCode));    /* Write the ERROR type */
    call WrConsole(aVar, 8);    /* Write the ERROR string */
    if IsPhase2Print then        /* repeat to the print file if required */
    do;
        call OutStrN(aErrStrs(errCode), aErrStrsLen(errCode));
        call OutStrN(aVar, 8);
    end;

    if errCode = RTE$FILE or errCode = RTE$EOF then    /* file or EOF Error */
    do;
        if tokBufIdx = 0 then
        do;
            call WrConsole(.aBadSyntax, 12);
            if not scanCmdLine then
            do;
                call Skip2NextLine;
                outfd = 0;
                CHKOVL$1;
                call PrintDecimal(srcLineCnt);    /* overlay 1 */
                call Outch(LF);
            end;
        end;
        else
        do;
            call WrConsole(curFileName$p, tokBufIdx);
            call WrConsole(.ascCRLF, 2);
        end;
    end;

    if errCode = 0 then    /* stack Error */
    do;
        skipRuntimeError = TRUE;
        return;
    end;

    call Exit;
end;

IoError: procedure(path) public;
    declare path pointer;
    declare ch based path byte;

    tokBufIdx = 0;
    curFileName$p = path;

    do while ch <> ' ' and ch <> CR and ch <> TAB;
        tokBufIdx = tokBufIdx + 1;
        path = path + 1;
    end;
    if missingEnd then
        call RuntimeError(RTE$EOF);    /* EOF Error*/
    call RuntimeError(RTE$FILE);        /* file Error */
end;

/* open file for read with status check */
SafeOpen: procedure(path$p, access) word public;
    declare path$p pointer, access word;
    declare conn word;

    call Open(.conn, path$p, access, 0, .openStatus);
    if openStatus <> 0 then
        call IoError(path$p);
    return conn;
end;


Nibble2Ascii: procedure(n) byte public;
    declare n byte;
    n = (n and 0Fh) + '0';
    if n > '9' then
        n = n + 7;
    return n;
end;

Put2Hex: procedure(pfunc, val) public;
    declare pfunc pointer, val byte;

    call pfunc(Nibble2Ascii(ror(val, 4)));
    call pfunc(Nibble2Ascii(val));
end;

BlankAsmErrCode: procedure bool public;
    return asmErrCode = ' ';
end;

MPorNoErrCode: procedure bool public;
    return BlankAsmErrCode or asmErrCode = 'M' or asmErrCode = 'P';
end;


GetNibble: procedure(bp, idx) byte public;  /* not used */
    declare bp pointer, idx byte;
    declare b based bp byte;
    declare n byte;

    bp = bp + shr(idx, 1);    /* index into buffer the number of nibbles */
    n = b;            /* pick up the byte there */
    if not idx then        /* pick up the right nibble */
        n = ror(n, 4);
    return n and 0Fh;    /* mask to leave just the nibble */
end;

SourceError: procedure(errCh) public;
    declare errCh byte;

    if not IsSkipping or topOp = K$ELSE then    /* ELSE */
    do;
        if inExtrn then
            badExtrn = TRUE;
        if BlankAsmErrCode then
            errCnt = errCnt + 1;

        if MPorNoErrCode or errCh = 'L' or errCh = 'U' then    /* no Error or M, P L or U */
            if asmErrCode <> 'L' then    /* override unless already location counter Error */
                asmErrCode = errCh;

    end;
end;

$IF MACRO

InsertByteInMacroTbl: procedure(c) public;
    declare c byte;
    declare ch based macroInPtr byte;

    ch = c;
    if (macroInPtr := macroInPtr + 1) > baseMacroTbl then
        call RuntimeError(RTE$TABLE);    /* table Error */
end;


InsertCharInMacroTbl: procedure(c) public;
    declare c byte;

    call InsertByteInMacroTbl(c);
    if c = CR then
        call InsertByteInMacroTbl(LF);
end;

$ENDIF


ParseControlLines: procedure public;

    do while GetCh = '$';
        if IsSkipping then
        do;
            call Skip2NextLine;
            isControlLine = TRUE;
$IF MACRO
            if mSpoolMode = 1 then
                b6897 = TRUE;
$ENDIF
        end;
        else
        do;
            CHKOVL$0;
            call ParseControls;
        end;
        call FinishLine;
    end;
    reget = 1;    /* push back character */
end;


InitialControls: procedure public;
    cmdch$p = controls$p;
    scanCmdLine = TRUE;
    CHKOVL$0;
    call ParseControls;
    if IsPhase2Print then
    do;
        CHKOVL$1;
        call PrintCmdLine;
    end;
    if pendingInclude then
        call OpenSrc;

    pendingInclude, isControlLine, scanCmdLine = bZERO;
    call ParseControlLines;            /* initial control lines allow primary controls */
    primaryValid = FALSE;            /* not allowed from now on */
    ctlDEBUG = ctlDEBUG and ctlOBJECT;    /* debug doesn't make sense if no object code */
    ctlXREF = ctlXREF and ctlPRINT;        /* disable controls if not printing */
    ctlSYMBOLS = ctlSYMBOLS and ctlPRINT;
    ctlPAGING = ctlPAGING and ctlPRINT;
end;


InitLine: procedure public;
    startLine$p = inCh$p + 1;    
    lineChCnt = 0;
    if pendingInclude then
        call OpenSrc;

    lineNumberEmitted, has16bitOperand, isControlLine, errorOnLine, lhsUserSymbol,
    inExpression, expectingOperands, xRefPending, gotLabel, rhsUserSymbol,
    inDB, inDW, condAsmSeen, showAddr, usrLookupIsID,
$IF MACRO
    excludeCommentInExpansion, b9060, 
$ENDIF
    needsAbsValue = bZERO;

    atStartLine, expectingOpcode, isInstr, expectOp = bTRUE;
    ctlEJECT, hasVarRef, tokenIdx,
$IF MACRO
    inQuotes, argNestCnt,
$ENDIF
    tokenSize(0), tokenType(0), acc1ValType, acc2ValType, inComment, acc1Flags = bZERO;

    asmErrCode = ' ';
$IF MACRO
    macro$p = .macroLine;
    startMacroLine = macroInPtr;
    expandingMacro = expandingMacro > 0;
$ENDIF
    tokI = 1;
    srcLineCnt = srcLineCnt + 1;
$IF MACRO
    macro$p = .macroLine;
$ENDIF
    skipIf(0) = skipIf(0) > 0;
end;


start:
    call GetAsmFile;
    phase = 1;
    call ResetData;
    call InitialControls;
$IF SMALL
    if ctlMACROFILE then
    do;
        if Physmem < 8001h then        /* need > 32k memory */
            call RuntimeError(RTE$MEMORY);     /* memory Error */
        if srcfd <> rootfd then       /* had include file before end of initial controls */
            call CloseF(srcfd);       /* close it */
        call CloseF(infd);            /* close initial file */
        ovlFile(12) = '4';        /* use macro asm version */
        call Load(.ovlFile, 0, 1, 0, .statusIO);
        call IoErrChk;
    end;
    if Physmem > 8001h then
    do;
        if srcfd <> rootfd then     /* had include file before end of initial controls */
            call CloseF(srcfd);     /* close it */
        call CloseF(infd);          /* close initial file */
        ovlFile(12) = '5';        /* use big edata.asm version */
        call Load(.ovlFile, 0, 1, 0, .statusIO);
        call IoErrChk;
    end;

    if MacroDebugOrGen then            /* attempt to use macro features */
        call RuntimeError(RTE$CMDLINE);        /* command Error */
$ELSEIF MACRO
    macrofd = SafeOpen(.asmac$ref, UPDATE$MODE);
$ENDIF

    if ctlOBJECT then
    do;
        call Delete(.objFile, .statusIO);
        objfd = SafeOpen(.objFile, UPDATE$MODE);
    end;

    if ctlXREF then
    do;
        xreffd = SafeOpen(.asxref$tmp, WRITE$MODE);
        outfd = xreffd;
    end;

    call DoPass;
    phase = 2;
    if ctlOBJECT then
    do;
        CHKOVL$2;    /* for small version Load in overlay 2 for writeRec & WriteModhdr */
        if r$extnames.len > 0 then
            call WriteRec(.r$extnames);    /* in overlay 2 */

        if externId = 0 then
            call WriteModhdr;        /* in overlay 2 */
$IF NOT SMALL
        call InitRecTypes;
$ENDIF
    end;
$IF SMALL
    if not ctlOBJECT or ctlPRINT then
$ENDIF
    do;
        if ctlPRINT then
            outfd = SafeOpen(.lstFile, WRITE$MODE);
        CHKOVL$3;
        call ResetData;
        call InitialControls;
        call DoPass;
    end;
    if ctlPRINT then
    do;
        CHKOVL$1;
        call AsmComplete;
        call Flushout;
    end;

    if ctlOBJECT then
    do;
$IF SMALL
        phase = 3;
        CHKOVL3;
        call ResetData;
        call InitRecTypes;
        call InitialControls;
        call DoPass;
        CHKOVL2;
$ENDIF
        call Ovl11;
        call WriteModend;
    end;

    if not StrUcEqu(.aCo, .lstFile) then
    do;
        CHKOVL$1;
        call FinishPrint;
    end;
    CHKOVL$1;
    call FinishAssembly;
end;

src/asm1.plx
$IF MACRO
asm1m: do;
$include(:f3:asm1m.ipx)
$ELSE
asm1n: do;
$include(:f3:asm1n.ipx)
$ENDIF

declare tokReq(*) byte data(
            /* 0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
               0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,
               0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
               0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,
               0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
               0, 0),
    b3EA0(*) byte data(36h, 0, 0, 0, 6, 0, 0, 2),
        /* bit vector 55 -> 0 x 24 00000110 0 x 16 0000001 */
        /* 29, 30, 55 */
    absValueReq(*) bool data(
        /* 0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F */
           0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
           0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0FFh,0,   0,   0FFh,
           0,   0FFh,0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
           0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0FFh,0FFh,0FFh,0,   0FFh,0,
           0,   0);
    /* true for DS, ORG, IF, 3A?, IRP, IRPC REPT */ 
$IF MACRO
declare    b3F88(*) byte data(41h, 90h, 0, 0, 0, 0, 0, 0, 0, 40h);
    /* bit vector 66 -> 10010000 0 x 56 01 */

SkipWhite$2: procedure public;
    do while GetCh = ' ' or IsTab;
    end;
end;


nonHiddenSymbol: procedure byte public;
    declare name$p pointer,
        name based name$p word;

    name$p = tokenSymCurP - 6;
    /* check name < '??0' or '??9' < name */
    return (name < 4679h) or ctlMACRODEBUG or (4682h < name);
end;



SeekM: procedure(blk);
    declare blk word;

    if (aVar := blk - nxtMacroBlk) <> 0 then   /* is seek needed */
    do;
        kk = SEEKFWD;
        if blk < nxtMacroBlk then       /* -ve so seek backwards */
        do;
            aVar = - aVar;
            kk = SEEKBACK;
        end;

        call Seek(macrofd, kk, .aVar, .seekMZero, .statusIO);
        call IoErrChk;
    end;
    nxtMacroBlk = blk + 1;
end;



/* read in macro from disk - located at given block */
ReadM: procedure(blk) public;
    declare blk word;
    declare actual word;

    if blk >= maxMacroBlk then      /* does not exist */
        actual = 0;
    else if blk = curMacroBlk then  /* already loaded */
        return;
    else                            /* load the buffer */
    do;
        call SeekM(blk);
        call Read(macrofd, .macroBuf, 128, .actual, .statusIO);
        call IoErrChk;
    end;

    tmac.blk, curMacroBlk = blk;    /* set relevant trackers */
    macroBuf(actual) = MACROEOB;    /* flag end of macro buffer */
end;

/* write the macro to disk */
WriteM: procedure public;
    if phase = 1 then               /* only needs writing on pass 1 */
    do;
        call SeekM(maxMacroBlk);    /* seek to end of spooled disk */
        maxMacroBlk = maxMacroBlk + 1;  /* account for this block */
        call Write(macrofd, symHighMark, 128, .statusIO);
        call IoErrChk;
    end;
    macroBlkCnt = macroBlkCnt + 1;  /* increase this macro's buffer cnt */
end;



FlushM: procedure public;
    declare bytesLeft word;

    if mSpoolMode then
    do; /* spool macros to disk in 128 byte blocks */
        do while (bytesLeft := macroInPtr - symHighMark) >= 128;
            call WriteM;
            symHighMark = symHighMark + 128;
        end;
    /* move the remaining bytes to start of macro buffer */
        if bytesLeft <> 0 then
            call move(bytesLeft, symHighMark, endSymTab(TID$MACRO));
        macroInPtr = (symHighMark := endSymTab(TID$MACRO)) + bytesLeft;
    end;
end;

$ENDIF

SkipWhite: procedure public;
    do while IsWhite;
        curChar = GetCh;
    end;
end;


$IF NOT MACRO
SkipWhite$2: procedure public;
    do while GetCh = ' ' or IsTab;
    end;
end;
$ENDIF

Skip2NextLine: procedure public;
    call Skip2EOL;
    call ChkLF;
end;



Tokenise: procedure public;

    Sub416B: procedure;
        if newOp = T$BEGIN then
            call ExpressionError;
        inExpression = 0;
        newOp = T$BEGIN;
    end;


    do while 1;
        if atStartLine then
        do;
            call ParseControlLines;
            atStartLine = FALSE;
        end;

        do case GetChClass;
            case0:    call IllegalCharError;        /* CC$BAD */
            ;                /* CC$WS */
            do;                /* CC$SEMI */
$IF MACRO
                if not inQuotes then
$ENDIF
                do;
                    inComment = TRUE;
$IF MACRO
                    if GetChClass = CC$SEMI and mSpoolMode then
                    do;
                        excludeCommentInExpansion = TRUE;
                        macroInPtr = macroInPtr - 2;
                    end;
$ENDIF
                    call Skip2NextLine;
                    yyType = T$CR;
                    return;
                end;
            end;
            do;                /* CC$COLON */
                if not gotLabel then
                do;
                    if skipIf(0)
$IF MACRO
                       or mSpoolMode
$ENDIF
                    then
                        call PopToken;
                    else
                    do;
                        labelUse = 2;
                        call UpdateSymbolEntry(segSize(activeSeg), O$TARGET);
                    end;

                    expectingOperands = FALSE;
                    gotLabel, expectingOpcode = bTRUE;
                end;
                else
                do;
                    call SyntaxError;
                    call PopToken;
                end;

                call EmitXref(XREF$DEF, .name);
                rhsUserSymbol = FALSE;
                newOp = O$LABEL;
            end;
            do;                /* CC$CR */
                call ChkLF;
                yyType = T$CR;
$IF MACRO
                inQuotes = FALSE;
$ENDIF
                return;
            end;
            do;                /* CC$PUN */
                if curChar = '+' or curChar = '-' then
$IF MACRO
                    if not TestBit(newOp, .b3F88) then /* not T$BEGIN, T$RPAREN or K$NUL */
$ELSE
                    if newOp <> T$BEGIN and newOp <> T$RPAREN then
$ENDIF
                        curChar = curChar + (T$UPLUS - T$PLUS);    /* make unary versions */
                yyType = curChar - '(' + T$LPAREN;
                return;
            end;
            do;                /* CC$DOLLAR */
                call PushToken(O$NUMBER);
                call CollectByte(low(segSize(activeSeg)));
                call CollectByte(high(segSize(activeSeg)));
                if activeSeg <> SEG$ABS then
                    tokenAttr(0) = tokenAttr(0) or activeSeg or 18h;
                call Sub416B;
            end;
            do;                /* CC$QUOTE */
$IF MACRO
                if yyType = 37h then
                do;
                    call IllegalCharError;
                    return;
                end;
                if mSpoolMode then
                    inQuotes = not inQuotes;
                else
$ENDIF
                do;
                    call GetStr;
                    if expectingOpcode then
                        call SetExpectOperands;
                    call Sub416B;
                end;
            end;
            do;                /* CC$DIG */
                call GetNum;
                if expectingOpcode then
                    call SetExpectOperands;
                call Sub416B;
            end;
            do;                /* CC$LET */
$IF MACRO
                startMacroToken = macroInPtr - 1;
$ENDIF
                call GetId(O$NAME);    /* assume it's a name */
                if tokenSize(0) > MAXSYMSIZE then    /* cap length */
                    tokenSize(0) = MAXSYMSIZE;

                if ctlXREF then
                do;
                    call move(MAXSYMSIZE, .name, .savName);
                    call move(MAXSYMSIZE, .spaces6, .name);
                end;
                /* copy the token to name */
                call move(tokenSize(0), tokPtr, .name);
                nameLen = tokenSize(0);
                call PackToken;        /* make into 4 byte name */
                if rhsUserSymbol then
                do;
                    lhsUserSymbol = TRUE;
                    rhsUserSymbol = FALSE;
                end;


$IF MACRO
                if Lookup(TID$MACRO) <> O$NAME and mSpoolMode then
                do;
                    if not inQuotes or (kk := tokenType(0) = 0) and (curChar = '&' or byteAt(startMacroToken-1) = '&') then
                    do;
                        macroInPtr = startMacroToken;
                        call InsertCharInMacroTbl(kk + 81h);
                        call InsertByteInMacroTbl(GetNumVal);
                        call InsertCharInMacroTbl(curChar);
                        yyType = O$NAME;
                    end;
                end;
                else if yyType <> O$37 and not mSpoolMode = 2 then
$ENDIF
                do;
                    if Lookup(TID$KEYWORD) = O$NAME then        /* not a key word */
                    do;
                        tokenType(0) = Lookup(TID$SYMBOL);    /* look up in symbol space */
                        rhsUserSymbol = TRUE;        /* note we have a used symbol */
                    end;

                    yyType = tokenType(0);
                    needsAbsValue = absValueReq(tokenType(0)); /* DS, ORG, IF, T$MACRONAME, IRP, IRPC REPT */
                    if not tokReq(tokenType(0)) then /* i.e. not instruction, reg or T$MACRONAME or 1->A */
                        call PopToken;

                    if lhsUserSymbol then
                    do;               /* EQU, SET or O$37 */
                        call EmitXref((not TestBit(yyType, .b3EA0)) and 1, .savName);
                        lhsUserSymbol = FALSE;
                    end;
                end;
$IF MACRO
                if mSpoolMode = 1 then
                do;
                    if yyType = K$LOCAL then
                    do;
                        mSpoolMode = 2;
                        if b6897 then
                            call SyntaxError;
                        b6897 = FALSE;
                    end;
                    else
                    do;
                        b6897 = FALSE;
                        mSpoolMode = 0FFh;
                    end;
                end;

                if yyType = K$NUL then
                    call PushToken(O$OPTVAL);
$ENDIF
                if yyType < 10 or yyType = 9 or 80h then /* !! only first term contributes */
                do;
                    call Sub416B;
                    if expectingOpcode then
                        call SetExpectOperands;
                end;
                else
                do;
                    expectingOpcode = FALSE;
                    return;
                end;
            end;
$IF MACRO
            do;                /* 10? */
                nestedMacroSeen = FALSE;
                call GetMacroToken;
                if nestedMacroSeen then
                    return;
            end;
            do;                /* CC$ESC */
                if expandingMacro then
                do;
                    skipIf(0) = FALSE;
                    yyType = 40h;
                    return;
                end;
                else
                    goto case0;
            end;
$ENDIF
        end;
    end;
end;

end;
src/asm2.plx
$IF MACRO
asm2m: do;
/* force the non standard code generation of outStrN and put2Hex */
declare pointer literally 'address',
        word    literally 'address';
OutStrN: procedure(s, n) external; declare s pointer, n word; end;
Put2Hex: procedure(arg1w, arg2w) external; declare arg1w pointer, arg2w word; end;
$include(:f3:asm2m.ipx)
$ELSE
asm2n: do;
declare pointer literally 'address',
        word    literally 'address';
OutStrN: procedure(s, n) external; declare s pointer, n word; end;
$include(:f3:asm2n.ipx)
$ENDIF
/* 
    0    -> ?
    1    -> start single word expression
    5    -> single byte opcode no operand
    7    -> reg operand
    0Fh    -> binary topOp
    0Dh    -> unary topOp
    17h    -> IMM8 operand
    37h    -> imm16 operand
    40h    -> list
    47h    -> 2 operand topOp
    4Dh    -> start word list
    80h    -> end expression
    81h    -> rept operand
    0C0h    -> local operand

    -------x    -> getnum to acc1 & copy to acc2
    ------x-    -> getnum to acc1
    -----x--    -> collect low(acc1)
    ----x---    -> collect high(acc1)
    ---x----    -> collect low(acc2)
    --x-----    -> collect high(acc2)
    -x------    -> list
*/

declare opFlags(*) byte public data(
       /* 0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F */
          0, 80h,   0,   0, 0Fh, 0Fh, 80h, 0Fh, 0Dh, 0Fh, 0Dh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh,
        0Fh, 0Dh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Fh, 0Dh, 0Dh, 40h, 4Dh,   1,   1,   1,   1,
        80h,   1,   0,   0, 47h,   7,   7,   7, 17h, 47h,   7, 47h, 37h,   5,   7,   0,
          0,   0, 40h, 40h,   0,   1
$IF MACRO
                                    , 80h, 40h, 80h,   0, 40h, 80h, 80h, 40h, 81h,0C0h,
        80h, 0Dh
$ENDIF
       ),

    noRegOperand(*) byte data(41h, 0, 0, 0, 19h, 40h, 0, 1Ch, 0, 0),
    /* bit vector 66 -> 0 x 24 00011001 01000000 00000000 00011100 00000000 00 */
    b41C1(*) byte data(1Ah, 5, 80h, 0, 0C0h),
    /* bit vector 27 -> 00000101 10000000 00000000 110 */
    opCompat(*) byte data(57h, 71h, 0F4h, 57h, 76h, 66h, 66h, 67h, 77h, 77h, 77h, 55h),
    /* bit vector 88 -> 01110001 11110100 01010111 01110110
                        01100110 01100110 01100111 01110111
                        01110111 01110111 01010101 */
    propagateFlags(*) byte data(57h, 6, 2, 20h, 0, 0, 0, 0, 0, 0, 0, 22h),
    /* bit vector 88 -> 00000110 00000010 00100000 00000000
                    00000000 00000000 00000000 00000000
                    00000000 00000000 00100010 */ 
    typeHasValue(*) byte data(3Ah, 0FFh, 80h, 0, 0, 0Fh, 0FEh, 0, 20h),
    /* bit vector 59 -> 11111111 10000000 00000000 00000000
                        00001111 11111110 00000000 001 */
    /* T$BEGIN, T$CR, T$LPAREN, T$RPAREN/O$LABEL, T$STAR, T$PLUS/K$SPECIAL, T$COMMA, */
    /* T$MINUS/K$REGNAME, T$UPLUS/K$SP */
    /* K$LXI, K$REG16, K$LDSTAX, K$ARITH, K$IMM8, K$MVI, K$INRDCR. K$MOV, K$IMM16, K$SINGLE */
    /* K$RST
/* precedence table */
/*
   10 - NULL
    9 - HIGH, LOW
    8 - *, /, MOD, SHL, SHR
    7 - +, -, UPLUS, UMINUS
    6 - =, <, <=, >, >=, <>
    5 - NOT
    4 - AND
    3 - OR, XOR,
    2 - not used
    1 - COMMA, DB - STKLEN, O$37, ENDM, EXITM, O$3D, REPT, LOCAL
    0 - T$BEGIN,T$CR,T$LPAREN,T$RPAREN,K$MACRO,T$MACRONAME,K$IRP,K$IRPC
*/
    precedence(*) byte data(
     /* 0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
        0, 0, 0, 0, 8, 7, 1, 7, 7, 8, 7, 6, 6, 6, 6, 6,
        6, 5, 4, 3, 3, 8, 8, 8, 9, 9, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1
$IF MACRO 
/* for macro ver */     , 0, 1, 1, 1, 0, 0, 0, 1, 1, 1,
        0, 0Ah
$ENDIF
     );


TestBit: procedure(bitIdx, bitVector) bool public;
    declare bitIdx byte, bitVector pointer;
    declare ch based bitVector byte;

    if ch < bitIdx then
        return FALSE;
    
    bitVector = bitVector + shr(bitIdx, 3) + 1;
    return (ch and ROR(1, (bitIdx and 7) + 1)) <> 0;
end;

IsReg: procedure(topOp) bool public;
    declare topOp byte;

    return topOp = K$REGNAME or topOp = K$SP;
end;

ChkInvalidRegOperand: procedure public;
    if TestBit(topOp, .noRegOperand) then
        if IsReg(acc1ValType) then
            call OperandError;
end;

Sub4291: procedure public;
    if IsReg(acc1ValType) then
        call OperandError;
    if (opFlags(topOp) and 2) = 0 then
        acc2Flags = 0;
    else if IsReg(acc2ValType) then
        call OperandError;

    acc1ValType = O$NUMBER;
    accFixFlags(0) = (acc1Flags and UF$BOTH) <> 0;
    accFixFlags(1) = (acc2Flags and UF$BOTH) <> 0;
    if (acc1Flags and UF$SEGMASK) <> SEG$ABS then
        if (acc2Flags and UF$SEGMASK) <> SEG$ABS then
            if ((acc1Flags xor acc2Flags) and 1Fh) <> 0 then
                call ExpressionError;
    if (ii := (acc1Flags and UF$EXTRN) <> 0) or (jj := (acc2Flags and UF$EXTRN) <> 0) then
    do;
        if topOp = K$SPECIAL then    /* +? (PAGE INPAGE)? */
            if not (ii or accFixFlags(0)) then
            do;
                acc1NumVal = acc2NumVal;
                acc1Flags = acc2Flags;
                return;
            end;
        if jj or accFixFlags(1) or not TestBit(topOp, .b41C1) then
            goto L4394;
        else
            return;
    end;
    kk = shl(topOp - 4, 2) or (accFixFlags(0) and 2) or (accFixFlags(1) and 1);
    if TestBit(kk, .opCompat) then
L4394:    do;
        call ExpressionError;
        acc1Flags = 0;
        return;
    end;
    if TestBit(kk, .propagateFlags) then
    do;
        if not accFixFlags(0) then
            acc1Flags = acc2Flags;
        return;
    end;
    acc1Flags = 0;
end;


SwapAccBytes: procedure public;
    declare tmp byte;
    tmp = accum1$lb;
    accum1$lb = accum1$hb;
    accum1$hb = tmp;
end;



SetExpectOperands: procedure public;
    expectingOperands = TRUE;
    expectingOpcode = FALSE;
end;



GetNumVal: procedure word public;
    declare tokByte based tokPtr (1) byte,    /* ptr into token info */
        val$p apointer,
        val based val$p word;
$IF MACRO
    LogError: procedure(ch);
        declare ch byte;

        if tokenType(tokenIdx) <> O$OPTVAL then
        do;
            call SourceError(ch);
            return;
        end;
        if tokenSize(0) = 0 then
            tokenType(tokenIdx) = K$NUL;
    end;
$ENDIF

    acc1Flags = 0;
    accum1 = 0;
    acc1ValType = O$NAME;
$IF MACRO
    if tokenType(0) = O$OPTVAL then
        call PushToken(CR);
$ENDIF
    if tokenIdx = 0 or tokenType(0) = O$DATA and not b6B36 then
$IF MACRO
        call LogError('Q');
$ELSE
        call SyntaxError;
$ENDIF
    else
    do;
        if tokenType(0) = O$NAME or tokenType(0) = T$COMMA then
$IF MACRO
            call LogError('U');
$ELSE
            call UndefinedSymbolError;
$ENDIF
        else
        do;
            acc1ValType = tokenType(0);
            if TestBit(acc1ValType, .typeHasValue) then
            do;
                tokPtr = tokenSymCurP + 7;    /* point to flags */
                acc1Flags = tokByte(0) and not UF$PUBLIC; /* remove public attribute */
                tokPtr, val$p = tokenSymCurP + 4;    /* point to value */
                acc1NumVal = val;            /* pick up value */
                tokenSize(0) = 2;        /* word value */

            end;
            else if tokenSize(0) = 0 then
$IF MACRO
                call LogError('V');
$ELSE
                call ValueError;
$ENDIF
            else
            do;
                if tokenSize(0) > 2 then
$IF MACRO
                    call LogError('V');
$ELSE
                    call ValueError;
$ENDIF
                acc1Flags = tokenAttr(0) and not UF$PUBLIC;    /* remove public attribute */
                acc1NumVal = tokenSymId(0);        /* use the symbol Id */
            end;

            if tokenSize(0) > 0 then    /* get low byte */
                accum1$lb = tokByte(0);
            if tokenSize(0) > 1 then    /* and high byte if not a register */
                accum1$hb = tokByte(1) and tokenType(0) <> 7;
        end;    

        if has16bitOperand then
            if tokenSize(0) = 2 then
                if tokenType(0) = O$STRING then
                    call SwapAccBytes;

        if (acc1Flags and UF$EXTRN) <> 0 then
            if tokenType(0) < 9 then
                accum1 = 0;

        call PopToken;
    end;

    b6B36 = FALSE;
    return accum1;
end;


GetPrec: procedure(topOp) byte public;
    declare topOp byte;
    return precedence(topOp);
end;

/*
   arg1b
   xxxxxxx1    acc2 -> 16 bit reg
   xxxxxx1x    acc1 = acc1 | acc2
   xxxxx1xx    acc2 <<= 3
   xxxx1xxx    acc2 -> 8 bit value
   nnnnxxxx    topOp = 24h + nnnn
   
*/   
MkCode: procedure(arg1b) public;
    declare arg1b byte;

    if (arg1b and 3) <> 0 then    /* lxi, ldax, stax, regarith, mvi, mov, rst */
    do;
        if accum2$hb <> 0    /* reg or rst num <= 7 */
           or accum2$lb > 7     
           or arg1b and accum2$lb    /* only B D H SP if lxi, ldax or stax */
           or (arg1b and 3) = 3 and accum2$lb > 2    /* B or D if ldax or stax */
           or (not IsReg(acc2ValType) and topOp <> K$RST) then    /* reg unless rst */
            call OperandError;
        else if IsReg(acc2ValType) and topOp = K$RST then         /* cannot be reg for rst */
            call OperandError;
        if ror(arg1b, 2) then
            accum2$lb = rol(accum2$lb, 3);
        accum1$lb = accum1$lb or accum2$lb;
    end;
    else if topOp <> K$SINGLE then        /* single byte topOp */
        if IsReg(acc2ValType) then
            call OperandError;

    if shr(arg1b, 3) then
    do;
        if (acc2Flags and UF$BOTH) = UF$BOTH then
        do;
            call ValueError;
            acc2Flags = (acc2Flags and not UF$BOTH)  or UF$LOW;
        end;
        if accum2$hb + 1 > 1 then    /* Error if not FF or 00 */
            call ValueError;
    end;
    if topOp = K$IMM8 or topOp = K$IMM16 then    /* Imm8 or imm16 */
    do;
        acc1Flags = acc2Flags;
        acc1NumVal = acc2NumVal;
    end;
    else
        acc1Flags = 0;

    if topOp <> K$SINGLE then             /* single byte topOp */
        if accum1$lb = 76h then         /* mov m,m is actually Halt */
            call OperandError;
    if (topOp := shr(arg1b, 4) + 24h) = 24h then
        nextTokType = O$DATA;
end;

NxtTokI: procedure byte public;
    if tokI >= tokenIdx then
        return 0;
    return (tokI := tokI + 1);
end;



ShowLine: procedure bool public;
    return ((not isControlLine) and ctlLIST or ctlLISTChanged and isControlLine)
$IF MACRO
            and (not (expandingMacro > 1) or ctlGEN)
$ENDIF
        and (not(condAsmSeen or skipIf(0)) or ctlCOND);
end;

/*
    xrefMode= 0 -> defined
        = 1 -> used
        = 2 -> finalise
*/
EmitXref: procedure(xrefMode, name) public;
    declare xrefMode byte, name pointer;
    declare (i, byteval) byte;
    declare (srcLineLow, srcLineHigh) byte at(.srcLineCnt);

    if not IsPhase1 or not ctlXREF or IsSkipping and not xRefPending then
        return;

    call Outch(xrefMode + '0');    /* convert to hex char */
    if xrefMode <> XREF$FIN then    /* not finalise */
    do;
        call OutStrN(name, 6);        /* label ref */
        xRefPending = FALSE;
        byteval = srcLineHigh;    /* line number in hex - high byte first */
        i = 0;
        do while i < 4;
            i = i + 1;
            if i then    /* high nibble ? */
            do;
                if i = 3 then    /* get low byte */
                    byteval = srcLineLow;
                /* emit high nibble */
                call Outch(Nibble2Ascii(shr(byteval, 4)));      /* warning global variable misused see notes in */
            end;
            else    /* emit low nibble */
                call Outch(Nibble2Ascii(byteval));
        end;
    end;
    else    /* finalise */
    do;
        call OutStrN(.lstFile, 15);    /* listing file name */
        if ctlPAGING then        /* whether paging '1' or '0' */
            call Outch('1');
        else
            call Outch('0');
        /* page length and page width as 2 hex chars */
        call Outch(Nibble2Ascii(ror(ctlPAGELENGTH, 4)));
        call Outch(Nibble2Ascii(ctlPAGELENGTH));
        call Outch(Nibble2Ascii(ror(ctlPAGEWIDTH, 4)));
        call Outch(Nibble2Ascii(ctlPAGEWIDTH));
        call Outch('3');    /* end of file */
        call Flushout;
        call CloseF(xreffd);
    end;
end;
end;
src/asm4.plx
$IF MACRO
asm4m: do;
$include(:f3:asm4m.ipx)
$ELSEIF BIG
asm4b: do;
$include(:f3:asm4b.ipx)
$ELSE
asm4s: do;
$include(:f3:asm4s.ipx)
$ENDIF

$IF SMALL
declare CHKOVL$1 lit    'call OvlMgr(1)',
    CHKOVL$2 lit    'call OvlMgr(2)';
$ELSE
declare CHKOVL$1 lit    ' ',
    CHKOVL$2 lit    ' ';
$ENDIF

declare pad1 word data(40h),
    pad2 word;


StrUcEqu: procedure(s, t) bool public;
    declare (s, t) pointer;
    declare sCh based s byte,
        tCh based t byte;

    do while sCh <> 0;
        if sCh <> tCh and sCh <> (tCh and 5Fh) then
            return FALSE;
        s = s + 1;
        t = t + 1;
    end;
    return TRUE;
end;


IsSkipping: procedure byte public;
    return 
$IF MACRO
        mSpoolMode or
$ENDIF
        skipIf(0);
end;

Sub546F: procedure public;
    spIdx = NxtTokI;
    if expectingOperands then
        call SyntaxError;
    if HaveTokens then
        if not(tokenType(spIdx) = O$DATA or lineNumberEmitted) then
            call SyntaxError;
    if inDB or inDW then
    do;
        if tokenIdx = 1 and not BlankAsmErrCode and tokenSize(0) <> 1 then
            tokenSize(0) = 2;
    end;
    else if not BlankAsmErrCode and HaveTokens then
        if tokenSize(spIdx) > 3 then
            tokenSize(spIdx) = 3;
end;


FinishLine: procedure public;
    declare lineno$p pointer,
        updating byte,
        ch based lineno$p byte;

    call Sub546F;
    if IsPhase2Print then
    do;    /* update the ascii line number */
        lineno$p = .asciiLineNo(3);    /* point to last digit */
        updating = TRUE;

        do while updating;        /* adjust the line number */
            if ch = '9' then    /* if 9 then roll over to 0 */
                ch = '0';
            else
            do;
                if ch = ' ' then    /* new digit */
                    ch = '1';
                else            /* just increment */
                    ch = ch + 1;
                updating = FALSE;
            end;
            lineno$p = lineno$p - 1;
        end;

        if ShowLine or not BlankAsmErrCode then
        do;
            CHKOVL$1;
            call PrintLine;
        end;
    end;

    if skipRuntimeError then
    do;
        out$p = out$p + 1;
        call Flushout;
        call Exit;
    end;

    if not isControlLine then
    do;
        ii = 2;
        if tokenIdx < 2 or inDB or inDW then
            ii = 0;

        w6BCE = tokStart(ii) + tokenSize(ii);
        if IsSkipping or not isInstr then
            w6BCE = .lineBuf;

        if ChkGenObj then
        do;
            CHKOVL$2;
            call Ovl8;
        end;
        b6B2C = TRUE;
        segSize(activeSeg), effectiveAddr = segSize(activeSeg) + (w6BCE - .lineBuf);
    end;

    if ctlXREF and rhsUserSymbol then
        if phase = 1 then
            call EmitXref(XREF$REF, .name);

$IF MACRO
    call FlushM;
$ENDIF

    do while tokenIdx > 0;
        call PopToken;
    end;

    call InitLine;
    if b6B33 then
    do;
        finished = TRUE;
        if IsPhase2Print and ctlSYMBOLS then
        do;
            CHKOVL$1;
            call Sub7041$8447;
        end;

        call EmitXref(XREF$FIN, .name);    /* finalise xref file */
        if ChkGenObj then
        do;
            CHKOVL$2;
            call ReinitFixupRecs;
        end;
    end;
end;

end;
src/rdsrc.plm
rdsrc: do;
$include(:f3:rdsrc.ipx)

declare    pendingInclude bool public initial(FALSE),
    includeOnCmdLine bool public initial(FALSE),
    padb6C23 byte,
    fileIdx byte public initial(0),
    endInBuf$p pointer public initial(.inBuf),
    missingEnd bool public initial(FALSE),
    srcfd word public,
    rootfd word public,
    inCh$p pointer public initial(.inBuf - 1),
    startLine$p pointer public initial(.inBuf),
    lineChCnt byte public initial(0), 
    files(6) FILE$T public,
    seekIBlk word,
    seekIByte word,
    pad6CAD byte,  
    savInBuf$p pointer,
    savEndInBuf$p pointer,
    pad6CB2(4) word,
    readFActual word,
    pad6CBC word;


ReadF: procedure(conn, buff$p, count) public;
    declare conn byte, buff$p pointer, count word;
    call Read(conn, buff$p, count, .readFActual, .statusIO);
    call IoErrChk;
end;

SeekI: procedure(seekOp) public;
    declare seekOP byte;
    call Seek(srcfd, seekOp, .seekIBlk, .seekIByte, .statusIO);
    call IoErrChk;
end;


ReadSrc: procedure(bufLoc) public;
    declare bufLoc pointer;
    declare pad byte;

    call ReadF(srcfd, bufLoc, .inBuf(sizeInBuf) - bufLoc);
    endInBuf$p = bufLoc + readFActual;
end;



CloseSrc: procedure public;
    call Close(srcfd, .statusIO);
    call IoErrChk;
    if fileIdx = 0 then
    do;
        missingEnd = TRUE;
        call IoError(.files(0).name);
        return;
    end;
    fileIdx = fileIdx - 1;
    /* Open the previous file */
    if fileIdx = 0 then
        srcfd = rootfd;
    else
        srcfd = SafeOpen(.files(fileIdx).name, READ$MODE);

    seekIByte = files(fileIdx).byt;    /* move to saved location */
    seekIBlk = files(fileIdx).blk;
    call SeekI(SEEKABS);
    endInBuf$p = .inBuf;        /* force Read */
    inCh$p = .inBuf - 1;
end;


GetSrcCh: procedure byte public;
    declare ch based inCh$p byte;
    declare insertPt pointer;
    loop:
    inCh$p = inCh$p + 1;

    if inCh$p = endInBuf$p then    /* buffer all used */
    do;
        savInBuf$p = startLine$p;
        savEndInBuf$p = endInBuf$p;
        /* copy the current line down to start of buffer */
        if savEndInBuf$p - savInBuf$p > 0 then
            call move(savEndInBuf$p - savInBuf$p, startLine$p, .inBuf);
        startLine$p = .inBuf;
        /* Read in  characters to rest of inBuf */
        call ReadSrc(insertPt := startLine$p + (savEndInBuf$p - savInBuf$p));
        inCh$p = insertPt;
    end;

    if readFActual = 0 then
    do;
        call CloseSrc;
        goto loop;
    end;

    lineChCnt = lineChCnt + 1;
    return ch and 7Fh;
end;


OpenSrc: procedure public;
    declare curByteLoc byte, curBlkLoc word;

    pendingInclude = FALSE;
    call SeekI(SEEKTELL);
    if seekIByte = 128 then        /* adjust for 128 boundary */
    do;
        seekIBlk = seekIBlk + 1;
        seekIByte = 0;
    end;

    curBlkLoc = endInBuf$p - startLine$p;    /* un-used characters */
x:                        /* forces code alignment */
    if (curByteLoc := curBlkLoc mod 128) > seekIByte then
    do;
        seekIByte = seekIByte + 128;    /* adjust to allow for un-used chars */
        seekIBlk = seekIBlk - 1;
    end;
    /* save the current file location */
    files(fileIdx - 1).byt = seekIByte - curByteLoc;
    files(fileIdx - 1).blk = seekIBlk - curBlkLoc / 128;
    if srcfd <> rootfd then        /* close if include file */
    do;
        call Close(srcfd, .statusIO);
        call IoErrChk;
    end;

    endInBuf$p = .inBuf;            /* force Read */
    inCh$p = endInBuf$p - 1;
    startLine$p = .inBuf;
    files(fileIdx).blk = 0;            /* record at start of file */
    files(fileIdx).byt = 0;    
    srcfd = SafeOpen(.files(fileIdx).name, READ$MODE);    /* Open the file */
end;
end;
src/asm5.plx
$IF MACRO
asm5m: do;
$include(:f3:asm5m.ipx)
$ELSE
asm5n: do;
$include(:f3:asm5n.ipx)
$ENDIF
declare    b5666(*) byte data(9, 2Dh, 80h), /* bit vector 10 -> 00101101 10 */
    b5669(*) byte data(3Ah, 8, 80h, 0, 0, 0, 0, 0, 20h),
        /* bit vector 59 -> 00001000 1000000 00000000 0000000
                            00000000 0000000 00000000 001 */
    op16(*) byte data(
       /* 0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, /* DW,DW,EQU,SET,ORG */
          0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1),         /* LXI,IMM16 */
    chClass(*) byte data(
     /*  0/8     1/9     2/A     3/B     4/C     5/D     6/E     7/F */
/*00*/ CC$BAD, CC$BAD, CC$BAD, CC$BAD, CC$BAD, CC$BAD, CC$BAD, CC$BAD,
/*08*/ CC$BAD,  CC$WS, CC$BAD, CC$BAD,  CC$WS,  CC$CR, CC$BAD, CC$BAD,
/*10*/ CC$BAD, CC$BAD, CC$BAD, CC$BAD, CC$BAD, CC$BAD, CC$BAD, CC$BAD,
$IF MACRO
/*18*/ CC$BAD, CC$BAD, CC$BAD, CC$ESC, CC$BAD, CC$BAD, CC$BAD, CC$BAD,
$ELSE
/*18*/ CC$BAD, CC$BAD, CC$BAD, CC$BAD, CC$BAD, CC$BAD, CC$BAD, CC$BAD,
$ENDIF
/*20*/ CC$WS, CC$BAD, CC$BAD, CC$BAD, CC$DOLLAR, CC$BAD, CC$BAD, CC$QUOTE,
/*28*/ CC$PUN, CC$PUN, CC$PUN, CC$PUN, CC$PUN, CC$PUN, CC$BAD, CC$PUN,
/*30*/ CC$DIG, CC$DIG, CC$DIG, CC$DIG, CC$DIG, CC$DIG, CC$DIG, CC$DIG,
/*38*/ CC$DIG, CC$DIG, CC$COLON, CC$SEMI, CC$BAD, CC$BAD, CC$BAD, CC$LET,
/*40*/ CC$LET, CC$LET, CC$LET, CC$LET, CC$LET, CC$LET, CC$LET, CC$LET,
/*48*/ CC$LET, CC$LET, CC$LET, CC$LET, CC$LET, CC$LET, CC$LET, CC$LET, 
/*50*/ CC$LET, CC$LET, CC$LET, CC$LET, CC$LET, CC$LET, CC$LET, CC$LET,
/*58*/ CC$LET, CC$LET, CC$LET, CC$BAD, CC$BAD, CC$BAD, CC$BAD, CC$BAD,
/*60*/ CC$BAD, CC$LET, CC$LET, CC$LET, CC$LET, CC$LET, CC$LET, CC$LET,
/*68*/ CC$LET, CC$LET, CC$LET, CC$LET, CC$LET, CC$LET, CC$LET, CC$LET,
/*70*/ CC$LET, CC$LET, CC$LET, CC$LET, CC$LET, CC$LET, CC$LET, CC$LET,
/*78*/ CC$LET, CC$LET, CC$LET, CC$BAD, CC$BAD, CC$BAD, CC$BAD, CC$BAD);

UnpackToken: procedure(src, dst) public;
    declare src apointer, dst pointer;
    declare wrd based src word;
    declare ch based dst byte;
    declare packedword word;

    Unpack1: procedure;
        ch = packedword mod 40;    
        if ch = 0 then
            ch = ' ';
        else if ch <= 10 then
            ch = ch + 2Fh;    /* digit */
        else 
            ch = ch + 34h;    /* ? @ and letters */
        packedword = packedword / 40;
        dst = dst - 1;
    end;


    src = src + 2;
    dst = dst + 5;
    packedword = wrd;
    call Unpack1;
    call Unpack1;
    call Unpack1;
    src = src - 2;
    packedword = wrd;
    call Unpack1;
    call Unpack1;
    call Unpack1;
end;


InsertSym: procedure public;
    declare (p, q) pointer;
    declare pCh based p byte;
    declare qCh based q byte;

    /* move up the top block of the symbol tables to make room */
    symHighMark, p = (q := symHighMark) + 8;
    if baseMacroTbl < p then
        call RuntimeError(RTE$TABLE);    /* table Error */

    do while q > tokenSymCurP;    /* byte coqy */
        p = p - 1;
        q = q - 1;
        pCh = qCh;
    end;
    /* insert the new symbol name */
    call move(4, tokPtr, tokenSymCurP);
$IF MACRO
    endSymTab(TID$MACRO) = endSymTab(TID$MACRO) + 8;    /* mark new top of macro table */
$ENDIF
    curTokenSym.type = 0;            /* clear the type */
end;

$IF MACRO
OutSideTable: procedure(tableId) bool;        /* check if tokenSymCurP is outside table bounds */
    declare tableId byte;

    if endSymTab(tableId) >= tokenSymCurP and tokenSymCurP >= symTab(tableId) then
        return FALSE;

    call SyntaxError;
    return TRUE;
end;


InsertMacroSym: procedure(paramId, type) public;
    declare paramId word, type byte;

    if OutSideTable(TID$MACRO) then
        return;
    call InsertSym;
    curTokenSym.value = paramId;        /* fill in the rest of the new entry */
    curTokenSym.type = type;
    curTokenSym.flags = 0;
    call PopToken;
end;
$ENDIF

declare labelUse byte public;

UpdateSymbolEntry: procedure(line, type) public;
    declare line word, type byte;
    declare (flags, absFlag) byte,
        (lineSet, isSetOrEqu) bool,
        origType byte;

    /* type = 2 -> target
          4 -> set
          5 -> equ
          6 -> public
          9 -> address ref
         3ah-> ??
             8xh-> needs absolute value
    */

    SetTokenType: procedure;
        tokenType(0) = type;
        if (acc1ValType = K$REGNAME or acc1ValType = K$SP) and isSetOrEqu then
            tokenType(0) = 12 - type;    /* set-> K$SP, equ->K$REGNAME */
    end;

    origType = tokenType(0);
    isSetOrEqu = type = O$EQU or type = O$SET;
    absFlag = 0;
    flags = curTokenSym.flags;
    lineSet = FALSE;
$IF MACRO
    if OutSideTable(TID$SYMBOL) then        /* oops if outside normal symbol table */
    do;
$ELSE                    /* same for non macro version */
    if tokenSymCurP > endSymTab(TID$SYMBOL) or tokenSymCurP < symTab(TID$SYMBOL) then
    do;
        call SyntaxError;
$ENDIF
        return;
    end;

    if tokenIdx > 1 then
        call SyntaxError;

    if IsPhase1 then
        if tokenType(0) = O$NAME then
        do;
            if createdUsrSym then
            do;
                if curTokenSym.type >= 80h
$IF MACRO
                     or type = T$MACRONAME and curTokenSym.value <> srcLineCnt
$ENDIF
                then
                do;
                    call LocationError;
                    absFlag = 80h;
                end;
            end;
            else
            do;
                call InsertSym;
$IF MACRO
                symTab(TID$MACRO) = symTab(TID$MACRO) + 8;        /* adjust the base of the macro table */
$ENDIF
                endSymTab(TID$SYMBOL) = endSymTab(TID$SYMBOL) + 8;    /* adjust the end of the user symbol table */
                flags = 0;
            end;

            flags = (activeSeg <> SEG$ABS and UF$BOTH)
                or (inPublic and UF$PUBLIC)
                or (inExtrn and (UF$EXTRN + UF$BOTH));
            if labelUse = 1 then    /* set or equ */
                flags = acc1Flags;

            if labelUse = 2 then    /* label: */
                flags = flags or activeSeg;

            if hasVarRef and isSetOrEqu then
                tokenType(0) = O$MACROID;
            else
                call SetTokenType;

            goto endUpdateSymbol;
        end;

    if passCnt = 2 then
        if tokenType(0) = O$NAME then
            if acc1ValType <> O$NAME then
                if isSetOrEqu then
                do;
                    call SetTokenType;
                    if curTokenSym.type < 128 then
                    do;
                        curTokenSym.type = tokenType(0);
                        curTokenSym.value = line;
                        flags = acc1Flags;
                        lineSet = TRUE;
                    end;
                    goto endUpdateSymbol;
                end;

    if IsPhase1 then
        if tokenType(0) = O$REF then
            if TestBit(type, .b5666) then
            do;
                if inExtrn then
                    tokenType(0) = O$LABEL;
                else
                do;
                    tokenType(0) = type;
                    flags = flags and 0E0h;    /* mask off seg, low, high */
                    if labelUse = 1 then /* set or equ */
                        flags = acc1Flags or UF$PUBLIC;

                    if labelUse = 2 then /* label: */
                        if activeSeg <> 0 then
                            flags = flags or activeSeg or (UF$PUBLIC + UF$BOTH);
                end;
                goto endUpdateSymbol;
            end;

    if IsPhase1 then
        if type = O$REF then
            if TestBit(tokenType(0), .b5666) then
            do;
                if (flags and 60h) <> 0 then
                    tokenType(0) = O$LABEL;
                else
                    flags = flags or UF$PUBLIC;
                goto endUpdateSymbol;
            end;

    if IsPhase1 then
        if tokenType(0) <> type and tokenType(0) <> 8 or type = O$EQU then
            tokenType(0) = O$LABEL;

    if not inPublic and TestBit(tokenType(0), .b5669) then
        flags = (flags and UF$PUBLIC) and tokenType(0) <> T$MACRONAME or acc1Flags;
    else
    do;
        if IsPhase1 then
            tokenType(0) = O$LABEL;

        if not (inPublic or inExtrn) then
            if curTokenSym.value <> line then
                call PhaseError;
    end;

endUpdateSymbol:
    absFlag = absFlag or (curTokenSym.type and 80h);

    if IsPhase1 and (type = 9 or type = 6 or origType <> tokenType(0)) then
        curTokenSym.type = tokenType(0) or absFlag;

    kk = curTokenSym.type;
    if tokenType(0) = O$LABEL or kk = O$LABEL then
        call MultipleDefError;

    if kk >= 80h then
        call LocationError;

    if IsPhase1 and (tokenType(0) = type or type = O$EQU and tokenType(0) = 7)
       or type = O$SET and BlankAsmErrCode or lineSet
$IF MACRO
       or type = T$MACRONAME
$ENDIF
    then
        curTokenSym.value = line;

    curTokenSym.flags = flags;
    inPublic = FALSE;
    inExtrn = FALSE;
    if curTokenSym.type = O$REF then
        call UndefinedSymbolError;

    hasVarRef = FALSE;
    if createdUsrSym then
        call PopToken;

end;

/*
    two different tables are used in lookup
    table 0: static keyword lookup the individual entries are coded as
        packed keyword - byte * 4 - 3 chars per word
        opcode base - byte
        offset to next entry or 0 if end - byte
        type - byte (add 80h if abs value)
        flags - byte
    initial entry is determined by hashing the name

    table 1: is a dynamic symbol table 8 bytes per entry kept sorted to allow binary chop search
    individual entries encoded as
        

    table 2: is a dynamic macro table 8 bytes per entry kept sorted to allow binary chop search

*/    

Lookup: procedure(tableId) byte public;
    declare tableId byte;
    declare (lowOffset, highOffset, midOffset) pointer, deltaToNext word,
        entryOffset pointer, packedTok$p apointer,
        (i, gt) byte;
    declare symEntry based entryOffset KEYWORD$T,
        packedTok based packedTok$p (2) word;
    declare addr based aVar word;

    packedTok$p = tokPtr;
    /* Keyword lookup */
    if tableId = TID$KEYWORD then        /* hash chain look up key word */
    do;
        entryOffset = 0;    /* offset to current symbol to compare */
                    /* offset of first to use - hashes packed symbol name */
        deltaToNext = symTab(TID$KEYWORD) + ((packedTok(0) + packedTok(1)) mod 151) * 8;

        do while deltaToNext <> 0;    /* while not end of chain */
            entryOffset = entryOffset + deltaToNext;    /* point to the next in chain */
            if symEntry.tok(0) = packedTok(0) then        /* check for exact match */
                if symEntry.tok(1) = packedTok(1) then
                do;
                    tokenSymCurP = entryOffset;
                    tokenType(0) = curTokenSym.type;
                    if tokenType(0) < K$SINGLE then    /* instruction with arg */
                        if op16(tokenType(0)) then
                            has16bitOperand = TRUE;

                    if curTokenSym.flags = 2 and not ctlMOD85 then    /* RIM/SIM only valid on 8085 */
                        call SourceError('O');

                    if tokenType(0) = K$SP then        /* SP */
                    do;
                        if not(newOp = K$LXI or newOp = K$REG16) then 
                            call SourceError('X');
                        tokenType(0) = K$REGNAME;    /* reg */
                    end;
                    return tokenType(0) and 7Fh;
                end;
            deltaToNext = symEntry.delta;
        end;
        return O$NAME;
    end;

    /* MACRO and User tables are stored sorted 8 bytes per entry */
    /* use binary chop to find entry */
    lowOffset = symTab(tableId);
    highOffset, entryOffset = endSymTab(tableId);

    /* binary chop search for id */

    do while (midOffset := lowOffset + shr((highOffset - lowOffset) and 0FFF0h, 1)) <> entryOffset;
        entryOffset = midOffset;
        if packedTok(0) = symEntry.tok(0) then
        do;
            if packedTok(1) = symEntry.tok(1) then
            do;
                tokenSymCurP = entryOffset;
                tokenType(0) = curTokenSym.type;
                if tokenType(0) = O$MACROID then
                    tokenType(0) = O$NAME;

                if (usrLookupIsID := (kk := (tokenType(0) and 7Fh)) = O$NAME) then
                    if needsAbsValue then
                        curTokenSym.type = 80h + O$NAME;    /* update ABSVALUE flag */
                return kk;
            end;
            else
                gt = symEntry.tok(1) > packedTok(1);
        end;
        else
            gt = symEntry.tok(0) > packedTok(0);

        entryOffset = midOffset;
        if gt then
            highOffset = entryOffset;
        else
            lowOffset = entryOffset;
    end;

    tokenSymCurP = highOffset;
    if tableId = TID$SYMBOL and not IsSkipping then
    do;
        createdUsrSym = FALSE;
        labelUse = 0;
        call UpdateSymbolEntry(srcLineCnt, (needsAbsValue and 80h) or O$NAME);
        /* update symbol stack to adjust pointers for entries above insert point */
        aVar = .tokenSym;
        do i = 1 to tokenIdx;
            aVar = aVar + 2;
            if addr >= tokenSymCurP then
                addr = addr + 8;
        end;

        createdUsrSym = TRUE;
    end;
    return O$NAME;
end;



GetCh: procedure byte public;
    declare (curCH, prevCH) byte;
$IF MACRO
    declare ch based tmac.buf$p byte;
    declare ch1 based macro$p byte;
$ENDIF

reGetCh:
    if not reget then
    do;
        prevCH = curCH;

    nextCh:
        curCH = lookAhead;
$IF MACRO
        if expandingMacro then
        do;
            do while (lookAhead := ch) = MACROEOB;
                call ReadM(curMacroBlk + 1);
                tmac.buf$p = .macroBuf;
            end;

            tmac.buf$p = tmac.buf$p + 1;
        end;
        else
$ENDIF
            if scanCmdLine then
            lookAhead = GetCmdCh;
        else
            lookAhead = GetSrcCh;

        if chClass(curCH) = CC$BAD then
            if curCH = 0 or curCH = 7Fh or curCH = FF then
                goto nextCh;
$IF MACRO
        if expandingMacro then
        do;
            if curCH = ESC then
            do;
                goto doneGetCh;
            end;
            else if curCH = '&' then
            do;
                if not prevCH < 80h or lookAhead = 80h then
                    goto reGetCh;
            end;
            else if curCH = '!' and prevCH <> 0 then
            do;
                if not (inMacroBody or mSpoolMode) and macroDivert then
                do;
                    curCH = 0;
                    goto reGetCh;
                end;
            end;
            else if curCH >= 128 then
            do;
                if not (macroDivert := not macroDivert) then
                    tmac.buf$p = savedMacroBufP;
                else
                do;
                    savedMacroBufP = tmac.buf$p;
                    if curCH = 80h then
                    do;
                        tmac.buf$p = tmac.pCurArg;
                        if savedMtype = 2 then
                        do;
                            irpcChr(1) = ch;
                            tmac.buf$p = .irpcChr + 1;
                            if ch = '!' then
                            do;
                                irpcChr(0) = '!';
                                irpcChr(1) = byteAt(tmac.pCurArg + 1);
                                tmac.buf$p = tmac.buf$p - 1;
                            end;
                        end;
                        else
                        do;
                            do while (lookAhead := lookAhead - 1) <> 0FFh;
                                tmac.buf$p = tmac.buf$p - (ch and 7Fh);
                            end;

                            tmac.buf$p = tmac.buf$p + 1;
                        end;
                    end;
                    else
                    do;
                        tmac.buf$p = .localVarName;
                        aVar = lookAhead + tmac.localIdBase;
                        /* generate local var name */
                        do ii = 1 to 4;
                            localVarName(6 - ii) = aVar mod 10 + '0';
                            aVar = aVar / 10;
                        end;
                    end;
                end;

                lookAhead = 0;
                goto reGetCh;
            end;
        end;

        if expandingMacro > 1 then
            if IsPhase2Print then
                if macro$p < .macroLine(127) then    /* append character */
                do;
                    ch1 = curCH;    
                    macro$p = macro$p + 1;
                end;

        if mSpoolMode then
            if startMacroLine <> macroInPtr and curCH = CR or not excludeCommentInExpansion then
            call InsertCharInMacroTbl(curCH);

        if not(prevCH = '!' or inComment) then
        do;
            if curCH = '>' then
                argNestCnt = argNestCnt - 1;

            if curCH = '<' then
                argNestCnt = argNestCnt + 1;
        end;
$ENDIF
    end;
doneGetCh:
    reget = 0;
    return (curChar := curCH);
end;

GetChClass: procedure byte public;
    curChar = GetCh;
$IF MACRO
    if inMacroBody then
        return CC$MAC;
$ENDIF

    return chClass(curChar);
end;



ChkLF: procedure public;
    if lookAhead = LF then
        lookAhead = 0;
    else
    do;
$IF MACRO 
        mSpoolMode = mSpoolMode and 0FEh;
$ENDIF
        call IllegalCharError;
$IF MACRO
        mSpoolMode = mSpoolMode > 0;
$ENDIF
    end;
end;

end;

src/asm6.plx
$IF MACRO
asm6m: do;
$include(:f3:asm6m.ipx)
$ELSE
asm6n: do;
$include(:f3:asm6n.ipx)
$ENDIF

SyntaxError: procedure public;
    call SourceError('Q');
end;

DoubleDefError: procedure public;
    call SourceError('D');
end;

ExpressionError: procedure public;
    call SourceError('E');
end;

CommandError: procedure public;
    call SourceError('C');
end;

OpcodeOperandError: procedure public;
    call SourceError('O');
end;

NameError: procedure public;
    call SourceError('R');
end;

MultipleDefError: procedure public;
    call SourceError('M');
end;

ValueError: procedure public;
    call SourceError('V');
end;

NestingError: procedure public;
    call SourceError('N');
end;

PhaseError: procedure public;
    call SourceError('P');
end;

StackError: procedure public;
    call RuntimeError(RTE$STACK);
end;

FileError: procedure public;
    call RuntimeError(RTE$FILE);
end;

IllegalCharError: procedure public;
    call SourceError('I');
end;

BalanceError: procedure public;
    call SourceError('B');
end;

UndefinedSymbolError: procedure public;
    call SourceError('U');
end;

LocationError: procedure public;
    call SourceError('L');
end;

OperandError: procedure public;
    call SourceError('X');
end;

HaveTokens: procedure byte public;
    return tokenIdx <> 0;
end;


PopToken: procedure public;
    tokStart(0) = tokStart(tokenIdx);
    tokenSym(0) = tokenSym(tokenIdx);
    tokenType(0) = tokenType(tokenIdx);
    tokenAttr(0) = tokenAttr(tokenIdx);
    tokenSize(0) = tokenSize(tokenIdx);
    tokenSymId(0) = tokenSymId(tokenIdx);
    if HaveTokens then
        tokenIdx = tokenIdx - 1;
end;



/* nest - sw = 1 -> nest macro sw = 2 -> nest if */
Nest: procedure(sw) public;
    declare sw byte;
$IF MACRO
    macroCondStk(macroCondSP := macroCondSP + 1) = macroCondStk(0);
    /* record whether current nest is macro of if */
    if (macroCondStk(0) := sw) = 1 then
    do;
        if (macroDepth := macroDepth + 1) > 9 then
        do;
            call StackError;
            macroDepth = 0;
        end;
        else
        do;
            call move(16, .macroStk(0), .macroStk(macroDepth));
            tmac.macroCondSP = macroCondSP;
            tmac.ifDepth = ifDepth;
            nestMacro = TRUE;
        end;
    end;
    else
$ENDIF
    do;
        if (ifDepth := ifDepth + 1) > 8 then
        do;
            call StackError;
            ifDepth = 0;
        end;
        else
        do;
            skipIf(ifDepth) = skipIf(0);
            inElse(ifDepth) = inElse(0);
        end;
    end;
end;


UnNest: procedure(sw) public;
    declare sw byte;

$IF MACRO
    if sw <> macroCondStk(0) then   /* check for unbalanced unnest */
    do;
        call NestingError;
        if sw = 2 then          /* not macro unnest */
            return;
        macroCondSP = tmac.macroCondSP;
        ifDepth = tmac.ifDepth;
    end;

    macroCondStk(0) = macroCondStk(macroCondSP);    /* restore macro stack */
    macroCondSP = macroCondSP - 1;
    if sw = 1 then          /* is unnest macro */
    do;
        call move(16, .macroStk(macroDepth), .macroStk(0));
        call ReadM(tmac.blk);
        savedMtype = tmac.mtype;
        if (macroDepth := macroDepth - 1) = 0 then  /* end of macro nest */
        do;
            expandingMacro = 0;     /* not expanding */
            baseMacroTbl = Physmem + 0BFh;
        end;
    end;
$ELSE
    if ifDepth = 0 then         /* nothing to unnest */
        call NestingError;
$ENDIF
    else
    do;
        skipIf(0) = skipIf(ifDepth);    /* pop skipIf and inElse status */
        inElse(0) = inElse(ifDepth);
        ifDepth = ifDepth - 1;
    end;
end;

PushToken: procedure(type) public;
    declare type byte;

    if tokenIdx >= 8 then
        call StackError;
    else
    do;
        tokenIdx = tokenIdx + 1;
        tokStart(tokenIdx) = tokStart(0);
        tokenSym(tokenIdx) = tokenSym(0);
        tokenType(tokenIdx) = tokenType(0);
        tokenAttr(tokenIdx) = tokenAttr(0);
        tokenSize(tokenIdx) = tokenSize(0);
        tokenSymId(tokenIdx) = tokenSymId(0);    
        tokStart(0) = tokStart(0) + tokenSize(0);    /* advance for next token */
        tokenType(0) = type;
        tokenAttr(0), tokenSize(0) = bZERO;
        tokenSym(0) = wZERO;
$IF MACRO
        tokenSymId(0) = wZERO;
$ELSE
        tokenSymId(0) = tokenSym(0);
$ENDIF
    end;
end;

CollectByte: procedure(c) public;
    declare c byte;
    declare s pointer;
    declare ch based s byte;


    if (s := tokPtr + tokenSize(0)) < endLineBuf then    /* check for lineBuf overrun */
    do;
        ch = c;
        tokenSize(0) = tokenSize(0) + 1;
    end;
    else
        call StackError;
end;

GetId: procedure(type) public;
    declare type byte;

    call PushToken(type);    /* save any previous token and initialise this one */
    reget = 1;        /* force re get of first character */

    do while (type := GetChClass) = CC$DIG or type = CC$LET;    /* digit or letter */
        if curChar > 60h then    /* make sure upper case */
            curChar = curChar and 0DFh;
        call CollectByte(curChar);
    end;
    reget = 1;        /* force re get of Exit char */
end;


GetNum: procedure public;
    declare accum word,
        (radix, digit, i) byte;
    declare chrs based tokPtr (1) byte;

    call GetId(O$NUMBER);
    radix = chrs(tokenSize(0):= tokenSize(0) - 1);
    if radix = 'H' then
        radix = 16;

    if radix = 'D' then
        radix = 10;

    if radix = 'O' or radix = 'Q' then
        radix = 8;

    if radix = 'B' then
        radix = 2;

    if radix > 16 then
        radix = 10;
    else
        tokenSize(0)= tokenSize(0) - 1;

    accum = 0;
    do i = 0 to tokenSize(0);
        if chrs(i) = '?' or chrs(i) = '@' then
        do;
            call IllegalCharError;
            digit = 0;
        end;
        else
        do;
            if (digit := chrs(i) - '0') > 9 then
                digit = digit - 7;
            if digit >= radix then
                if not (tokenType(2) = 40h) then /* bug? risk that may be uninitialised */
                do;
                    call IllegalCharError;
                    digit = 0;
                end;
        end;

        accum = accum * radix + digit;
    end;
    /* replace with packed number */
    tokenSize(0) = 0;
    call CollectByte(low(accum));
    call CollectByte(high(accum));
end;

GetStr: procedure public;
    call PushToken(O$STRING);

    do while GetCh <> CR;
        if curChar = '''' then
            if GetCh <> '''' then
                goto L6268;
        call CollectByte(curChar);
    end;

    call BalanceError;

L6268:
    reget = 1;
end;

end;
src/cntrl.plx
$IF MACRO
cntrlm: do;
$include(:f3:cntrlm.ipx)
$ELSE
cntrln: do;
$include(:f3:cntrln.ipx)
$ENDIF

declare controlTable(*) byte data(
/* format of entries
    byte -> 00PNxxxx where
        P -> 0 general control 1 -> primary control
        N -> 0 NO prefix not supported 1-> NO prefix supported
        xxxx -> number of chars in name string
    name string
*/
            35h, 'DEBUG',     3Ah, 'MACRODEBUG',
            34h, 'XREF',      37h, 'SYMBOLS',
            36h, 'PAGING',    33h, 'TTY',
            25h, 'MOD85',     35h, 'PRINT',
            36h, 'OBJECT',    39h, 'MACROFILE',
            29h, 'PAGEWIDTH', 2Ah, 'PAGELENGTH',
              7, 'INCLUDE',     5, 'TITLE',
              4, 'SAVE',        7, 'RESTORE',
              5, 'EJECT',     14h, 'LIST',
            13h, 'GEN',       14h, 'COND');

declare (tokVal, savedCtlLIST, savedCtlGEN) byte,
    controlError bool;


ChkParen: procedure(arg1b) bool;
    declare arg1b byte;
    call SkipWhite;
    reget = 0;
    return arg1b + '(' = curChar;
end;



GetTok: procedure byte;
    tokBufLen = 0;
    tokType = TT$ID;
    if IsCR then
        return curChar;

    call SkipWhite$2;
    if curChar > 'A'-1 and 'Z'+1 > curChar or curChar > 'a'-1 and 'z'+1 > curChar then
    do;                            /* letter */
        call GetId(O$ID);
        if BlankAsmErrCode and tokenSize(0) < 14 then
            call move(tokBufLen := tokenSize(0), .lineBuf, .tokBuf);
    end;
    else if curChar > '0'-1  and  '9'+1 > curChar then    /* digit ? */
    do;
        call GetNum;
        if BlankAsmErrCode then
        do;
            tokNumVal = GetNumVal;
            tokType = TT$NUM;
            tokBuf(0) = ' ';
        end;
    end;
    else if curChar = '''' then    /* string ? */
    do;
        call GetStr;
        if BlankAsmErrCode then
        do;
            tokBufLen = 64;         /* cap at 64 chars */
            if tokenSize(0) < 64 then
                tokBufLen = tokenSize(0);
            tokType = TT$STR;
            if tokBufLen > 0 then
                call move(tokBufLen, .lineBuf, .tokBuf);
        end;
    end;
    else
    do;
        tokBufLen = 1;
        tokBuf(0) = curChar;
        return curChar;
    end;

    call PopToken;      /* restore the stack from GetId/GetNum/GetStr calls */
    return tokBuf(0);
end;



FinaliseFileNameOpt: procedure(arg1w) bool;
    declare arg1w word;
    declare pad word;

    if tokBufIdx = 0 then
        return FALSE;

    tokBuf(tokBufIdx) = ' ';
    tokBufLen = tokBufIdx;
    if IsWhite then
        return ChkParen(1);
    return TRUE;
end;

GetFileNameOpt: procedure;
    call SkipWhite$2;

    do while 1;
        if IsRParen or IsWhite then
        do;
            if FinaliseFileNameOpt(.tokBuf(0)) then
                return;
            goto done;
        end;

        tokBuf(tokBufIdx) = curChar;
        tokBufIdx = tokBufIdx + 1;
        if tokBufIdx > 14 then
            goto done;
        curChar = GetCh;
    end;
done:
    curFileName$p = .tokBuf;
    call FileError;
end;


GetFileParam: procedure;
    tokBufIdx = 0;
    if not ChkParen(0) then    /* ( */
        call FileError;
    else
    do;
        call GetFileNameOpt;
        call move(tokBufIdx + 1, .tokBuf, curFileName$p);
        if not ChkParen(1) then    /* ) */
            call FileError;
    end;
end;


GetMacroFileDrive: procedure;
    call SkipWhite$2;
    tokBufIdx = 13;     /* leave room for max file name */
    ii = 0;

    do while not IsRParen and ii < 4;
        asmac$ref(ii) = curChar;
        ii = ii + 1;
        curChar = GetCh;
    end;

    if IsRParen or IsWhite then
        if FinaliseFileNameOpt(.asmac$ref) then
            return;
    curFileName$p = .asmac$ref;
    tokBufIdx = 0;
    call FileError;
end;




GetControlNumArg: procedure bool;
    if ChkParen(0) then    /* ( */
    do;
        tokVal = GetTok;
        if tokType = TT$NUM then
            return ChkParen(1);    /* ) */
    end;
    return FALSE;
end;


LookupControl: procedure byte;
    declare (cmdIdx, cmdStartIdx) byte, 
        ctlVal bool,
        (cmdLen, ctlFlags, noInvalid) byte,
        (control$p, nextControl$p, ctlSeen$p) pointer;
    declare twoch word at(.tokBuf);
    declare ch based control$p byte;
    declare ctlSeen based ctlSeen$p byte;

    SetControl: procedure;
        if not noInvalid then
        do;
            controls(controlId) = ctlVal;
            if not ctlVal then
                controlId = 17;    /* no action needed */
        end;
    end;


    cmdLen = tokBufLen;
    cmdStartIdx = 0;
    ctlVal = TRUE;
    if twoch = 'ON' then    /* NO stored with bytes swapped */
    do;
        cmdStartIdx = 2;    /* don't match the NO in the table */
        ctlVal = FALSE;        /* control will be set as false */
        cmdLen = tokBufLen - 2;    /* length of string to match excludes the NO */
    end;

    control$p = .controlTable;
    controlId = 0;
    cmdIdx = cmdStartIdx;

    do while controlId < length(controls);
        nextControl$p = control$p + (ch and 0Fh) + 1;
        if (ch and 0Fh) = cmdLen then
        do;
            ctlFlags = ch;
            do while cmdIdx < tokBufLen;
                control$p = control$p + 1;
                if ch <> tokBuf(cmdIdx) then
                    cmdIdx = tokBufLen + 1;    /* cause early Exit */
                else
                    cmdIdx = cmdIdx + 1;    /* check next character */
            end;

            if cmdIdx = tokBufLen then        /* found it */
                goto found;
        end;
        control$p = nextControl$p;
        controlId = controlId + 1;
        cmdIdx = cmdStartIdx;
    end;
    return 255;                        /* not found */

found:
$IF NOT MACRO 
    if controlId = 1 or controlId = 12h then    /* MACRODEBUG or GEN */
    do;
        if scanCmdLine then            /* only valid on command line not $ line */
            MacroDebugOrGen = TRUE;
        else
            return 255;            /* Error otherwise */
    end;
$ENDIF
    if (noInvalid := (ctlFlags and 10h) <> 10h) and not ctlVal then
        return 255;    /* NO not supported */

    if (ctlFlags and 20h) <> 20h then        /* general control */
    do;
        call SetControl;
        return controlId;
    end;

    if not primaryValid then            /* is a PRIMARY control */
        return 255;

    ctlSeen$p = .controlSeen(controlId);        /* make sure we only see a primary once */
    if ctlSeen then
        return 255;
    ctlSeen = TRUE;
    call SetControl;
    return controlId;
end;

ProcessControl: procedure;
    /* simple controls already processed */
    if controlId >= 17 or controlId < 5 then
        return;

    do case controlId - 5;
/* 0 */ do;            /* TTY */
            ctlTTY = TRUE;
            return;
        end;
/* 1 */ do;            /* MOD85 */
            ctlMOD85 = TRUE;
            return;
        end;
/* 2 */ do;            /* PRINT */
            controlFileType = 2;	/* not used */
            curFileName$p = .lstFile;
            call GetFileParam;
            return;
        end;
/* 3 */ do;            /* OBJECT */
            controlFileType = 3;	/* not used */
            curFileName$p = .objFile;
            call GetFileParam;
            return;
        end;
/* 4 */ do;            /* MACROFILE */
            controlFileType = 3;	/* not used */
            if ChkParen(0) then    /* optional drive for tmp file */
                call GetMacroFileDrive;
            else
                reget = 1;
            ctlMACROFILE = TRUE;
            return;
        end;
/* 5 */ do;            /* PAGEWIDTH */
            if GetControlNumArg then
            do;
                ctlPAGEWIDTH = tokNumVal;
                if ctlPAGEWIDTH > 132 then
                    ctlPAGEWIDTH = 132;
                if ctlPAGEWIDTH < 72 then
                    ctlPAGEWIDTH = 72;
                return;
            end;
        end;
/* 6 */ do;            /* PAGELENGTH */
            if GetControlNumArg then
            do;
                ctlPAGELENGTH = tokNumVal;
                if ctlPAGELENGTH < 15 then
                    ctlPAGELENGTH = 15;
                return;
            end;
        end;
/* 7 */ do;            /* INCLUDE */
            if not pendingInclude then
            do;
                controlFileType = 1;	/* not used */
                if fileIdx = 5 then
                    call StackError;
                else
                do;
                    fileIdx = fileIdx + 1;
                    curFileName$p = .files(fileIdx);
                    call GetFileParam;
                    pendingInclude = TRUE;
                    if scanCmdLine then
                        includeOnCmdLine = TRUE;
                    return;
                end;
            end;
        end;
/* 8 */ do;            /* TITLE */
            if ChkParen(0) then
            do;
                tokVal = GetTok;
                if tokType = TT$STR and tokBufLen <> 0 then
                do;
                    if phase <> 1 or IsPhase1 and primaryValid then
                    do;
                        call move(tokBufLen, .tokBuf, .titleStr);
                        titleStr(titleLen := tokBufLen) = 0;
                        if ChkParen(1) then
                        do;
                            ctlTITLE = TRUE;
                            return;
                        end;
                    end;
                end;
            end;
        end;
/* 9 */ do;            /* SAVE */
            if saveIdx > 7 then
                call StackError;
            else
            do;
                call move(3, .ctlLIST, .saveStack + saveIdx * 3);
                saveIdx = saveIdx + 1;
                return;
            end;
        end;
/* 10 */do;            /* RESTORE */
            if saveIdx > 0 then
            do;
                call move(3, .saveStack + (saveIdx := saveIdx - 1) * 3, .ctlLIST);
                return;
            end;
        end;
/* 11 */do;            /* EJECT */
            ctlEJECT = ctlEJECT + 1;
            return;
        end;
    end;
    controlError = TRUE;
end;

ParseControls: procedure public;
    isControlLine = TRUE;
    ctlLISTChanged, savedCtlLIST = ctlLIST;
$IF MACRO
    savedCtlGEN = ctlGEN;
$ENDIF
    controlError = FALSE;

    do while GetTok <> CR and not controlError;
        if tokBuf(0) = ';' then        /* skip comments */
            call Skip2EOL;
        else if LookupControl = 255 then    /* Error ? */
            controlError = TRUE;
        else
            call ProcessControl;
    end;

    if controlError then
    do;
        if tokBuf(0) <> CR then
        do;
            reget = 0;
            call Skip2EOL;
        end;

        if scanCmdLine then
            call RuntimeError(RTE$CMDLINE);    /* command Error */
        else
            call CommandError;
    end;

    call ChkLF;            /* eat the LF */
    if ctlLIST <> savedCtlLIST then
        ctlLISTChanged = TRUE;
$IF MACRO
    else if ctlGEN <> savedCtlGEN and expandingMacro then
        ctlLISTChanged = FALSE;
$ENDIF

    reget = 0;
end;

end;
src/asm8m.plm
asm8m: do;
$include(:f3:asm8m.ipx)

declare b7183(*) byte data(3Fh, 0, 4, 0, 0, 0, 8, 0, 10h);
    /* bit vector 64 - 00000000 00000100 00000000 00000000 00000000 00001000 00000000 00010000 */
    /*                 CR, COMMA, SEMI */                                  

declare baseMacroBlk word,
    b9C77 byte public;


IsEndParam: procedure bool;
    if IsCR then
    do;
        inAngleBrackets = FALSE;
        return TRUE;
    end;

    if inAngleBrackets then
        return argNestCnt = startNestCnt;

    if IsLT or (not (tmac.mtype = M$IRP) and IsGT) then
    do;
        call IllegalCharError;
        return TRUE;
    end;

    return IsWhite or IsComma or IsGT or curChar = ';';
end;



InitParamCollect: procedure;
    symTab(TID$MACRO), endSymTab(TID$MACRO) = symHighMark;
    paramCnt, tmac.localsCnt = bZERO;
    yyType = 37h;
end;


Sub720A: procedure;

    savedMtype = tmac.mtype;
    if not expandingMacro then
        expandingMacro = 1;

    if macroDepth = 0 then
        expandingMacro = 0FFh;

    if nestMacro then
        call move(4, .macroStk(0).buf$p, .macroStk(macroDepth).buf$p);

    nestMacro = FALSE;
    tmac.pCurArg = pNextArg;
    tmac.localIdBase = localIdCnt;
    localIdCnt = localIdCnt + tmac.localsCnt;
    call ReadM(tmac.savedBlk);
    tmac.buf$p = .macroBuf;
end;


Sub727F: procedure bool;
    if not mSpoolMode then
        return TRUE;
    macroSpoolNestDepth = macroSpoolNestDepth + 1;
    b6B2C = topOp <> K$REPT;
    yyType = 37h;
    return FALSE;
end;


DoIrpX: procedure(arg1b) public;    /* 1 -> IRP, 2 -> IRPC */
    declare arg1b byte;

    if Sub727F then
    do;
        call InitParamCollect;
        call Nest(1);
        tmac.cnt = 0;
        tmac.mtype = arg1b;
    end;
end;

Acc1ToDecimal: procedure;
    declare buf(6) byte;

    call PushToken(CR);
    kk = 0;
    /* build number in reverse digit order */
loop:
    buf(kk := kk + 1) = accum1 mod 10 + '0';
    if (accum1 := accum1 / 10) > 0 then
        goto loop;

    /* insert in collect buffer in order */
    do while kk > 0;
        call CollectByte(buf(kk));
        kk = kk - 1;
    end;
end;


Sub7327: procedure public;
    pNextArg = baseMacroTbl;
    yyType = 3Dh;
    inMacroBody = TRUE;
    b9060 = FALSE;
end;


AddMacroText: procedure(lowAddr, highAddr) pointer;
    declare (lowAddr, highAddr) pointer;
    declare ch1 based baseMacroTbl byte,
        ch2 based highAddr byte;

    do while lowAddr <= highAddr;
        if baseMacroTbl <= symHighMark then
            call RuntimeError(RTE$TABLE);    /* table Error */
        ch1 = ch2;
        baseMacroTbl = baseMacroTbl - 1;
        highAddr = highAddr - 1;
    end;
    return baseMacroTbl;
end;


InitSpoolMode: procedure;
    macroSpoolNestDepth = 1;
    macroInPtr = symHighMark;
    mSpoolMode = 1;
    baseMacroBlk = macroBlkCnt;
end;



ChkForLocationError: procedure;
    if usrLookupIsID then
        if asmErrCode <> 'U' then
            call LocationError;
end;


GetMacroToken: procedure public;
    declare isPercent byte;

    b9C77 = tokenIdx;
    call SkipWhite;
    if not (isPercent := curChar = '%') then
    do;
        startNestCnt = argNestCnt - 1;
        if (inAngleBrackets := IsLT) then
            curChar = GetCh;

        call PushToken(CR);

    L73E2:    do while not IsEndParam;
            if curChar = '''' then
            do;
                if (curChar := GetCh) = '''' then
                do;
                    curChar = GetCh;
                    call SkipWhite;
                    if IsEndParam then
                        goto L7463;
                    else
                    do;
                        call CollectByte('''');
                        call CollectByte('''');
                    end;
                end;
                else
                do;
                    call CollectByte('''');
                    goto L73E2;
                end;
            end;
            call CollectByte(curChar);
            if tmac.mtype = M$IRPC then
                tmac.cnt = tmac.cnt + 1;

            if curChar = '!' and GetCh <> CR then
            do;
                call CollectByte(curChar);
                curChar = GetCh;
            end;
        end;

    L7463:    if inAngleBrackets then
            curChar = GetCh;

        call SkipWhite;
        if IsGT then
        do;
            curChar = GetCh;
            call SkipWhite;
        end;

        reget = 1;
    end;

    inMacroBody = FALSE;
    if tmac.mtype = M$INVOKE then
    do;
        if not inAngleBrackets and tokenSize(0) = 5 then
            if StrUcEqu(.('MACRO', 0), tokPtr) then
            do;
                yyType = K$MACRO;
                call PopToken;
                pNextArg = tmac.pCurArg;
                opSP = opSP - 1;
                reget = 1;
                call EmitXref(XREF$DEF, .name);
                rhsUserSymbol = FALSE;
                nestedMacroSeen = TRUE;
                return;
            end;
        tmac.mtype = savedMtype;
        call Nest(1);
        tmac.mtype = M$MACRO;
    end;

    if not isPercent then
        if not TestBit(curChar, .b7183) then    /* not CR, COMMA or SEMI */
        do;
            call Skip2EOL;
            call SyntaxError;
            reget = 1;
        end;
end;



DoMacro: procedure public;
    if Sub727F then
    do;
        expectingOperands = FALSE;
        pMacro = tokenSymCurP + 4;      /* pMacro points to blk */
        call UpdateSymbolEntry(0, T$MACRONAME);
        tmac.mtype = M$MACRO;
        call InitParamCollect;
    end;
end;

DoMacroBody: procedure public;
    declare ch based pMacro byte;

    if HaveTokens then
    do;
        if tokenType(0) = 0 then
            call MultipleDefError;

        call InsertMacroSym((paramCnt := paramCnt + 1), 0);
    end;
    else if not (tmac.mtype = M$MACRO) then
        call SyntaxError;

    if not tmac.mtype = M$MACRO then
    do;
        call SkipWhite;
        if IsComma then
        do;
            reget = 0;
            newOp = T$BEGIN;
            call Sub7327;
            if tmac.mtype = M$IRP then
            do;
                curChar = GetCh;
                call SkipWhite;
                if not IsLT then
                do;
                    call SyntaxError;
                    reget = 1;
                end;
            end;
        end;
        else
        do;
            call SyntaxError;
            call InitSpoolMode;
        end;
    end;
    else if newOp = T$CR then
    do;
        if not MPorNoErrCode then
        do;
            tmac.mtype = M$BODY;
            pMacro = pMacro + 2;
            if (ch and 7Fh) = 3Ah then
                ch = (asmErrCode = 'L') and 80h or 9;
        end;
        call InitSpoolMode;
    end;
end;

DoEndm: procedure public;
    declare ch based macroInPtr byte;
    declare ch2 based pMacro byte;
    declare wrd based pMacro word;

    if mSpoolMode then
    do; /* check for end of spool */
        if (macroSpoolNestDepth := macroSpoolNestDepth - 1) = 0 then
        do;
            mSpoolMode = 0;
            if not (tmac.mtype = M$BODY) then
            do;
                if tmac.mtype = M$IRPC then
                    pNextArg = baseMacroTbl + 3;

                /* endm cannot have a label */
                do aVar = startMacroLine to startMacroToken - 1;
                    curChar = byteAt(aVar);
                    if not IsWhite then
                        call SyntaxError;
                end;

                /* replace line with ESC to mark end of spool */
                macroInPtr = startMacroLine;
                ch = ESC;
                call FlushM;    /* force spool to disk */
                call WriteM;
                /* reset the macro parmater symbol table */
                symHighMark, endSymTab(TID$MACRO) = symTab(TID$MACRO);
                if tmac.mtype = M$MACRO then
                do;
                    wrd = baseMacroBlk;
                    pMacro = pMacro + 3;    /* now points to flags */
                    ch2 = tmac.localsCnt;   /* save the number of locals */
                end;
                else
                do;
                    tmac.savedBlk = baseMacroBlk;
                    call Sub720A;
                    if tmac.cnt = 0 then
                        call UnNest(1);
                end;
            end;
        end;
    end;
    else
        call NestingError;
end;


DoExitm: procedure public;
    if expandingMacro then
    do;
        if newOp = T$CR then        /* check exitm on its own */
        do;
            condAsmSeen = TRUE;
            macroCondSP = tmac.macroCondSP;
            ifDepth = tmac.ifDepth;
            tmac.cnt = 1;           /* force apparent endmi - last repetition */
            lookAhead = ESC;        /* synthetic endm */
            macroCondStk(0) = 1;    /* and out of any if else */
        end;
        else
            call SyntaxError;
    end;
    else
        call NestingError;
end;


Sub770B: procedure public;
    if b9C77 + 1 <> tokenIdx then
        call SyntaxError;
    else if not b9060 then
    do;
        if tokenType(0) <> 0Dh then
        do;
            accum1 = GetNumVal;
            call Acc1ToDecimal;
        end;

        if tmac.mtype = M$IRPC then
            tmac.cnt = tokenSize(0) - (tokenSize(0) = 0);

        call CollectByte((tokenSize(0) + 1) or 80h);
        baseMacroTbl = AddMacroText(tokPtr, tokPtr + tokenSize(0) - 1);
        call PopToken;

        if tmac.mtype = M$MACRO or tmac.mtype = M$IRP and argNestCnt > 0 then
            inMacroBody = TRUE;
        else
            b9060 = TRUE;

        if tmac.mtype = M$IRP then
            tmac.cnt = tmac.cnt + 1;
    end;
    else
        call SyntaxError;

    if newOp = T$CR then
    do;
        inMacroBody = FALSE;
        if argNestCnt > 0 then
            call BalanceError;

        if not MPorNoErrCode then
        do;
            call ChkForLocationError;
            if tmac.mtype = M$MACRO then
            do;
                call Sub720A;
                call UnNest(1);
                return;
            end;
            else
                tmac.cnt = 0;
        end;
        else
        do;
            baseMacroTbl = AddMacroText(.b3782, .b3782 + 1);
            if tmac.mtype = M$MACRO then
            do;
                tmac.localsCnt = curTokenSym.flags;
                tmac.savedBlk = GetNumVal;
                call Sub720A;
            end;
            else if tmac.cnt = 0 then
                call SyntaxError;
        end;

        if not (tmac.mtype = M$MACRO) then
            call InitSpoolMode;
    end;
end;



DoRept: procedure public;
    call DoIrpX(M$REPT);
    if (yyType := newOp) <> T$CR then
        call SyntaxError;

    if not mSpoolMode then
    do;
        tmac.cnt = accum1;          /* get the repeat count */
        if not MPorNoErrCode then   /* skip processing if error other than M or P */
        do;
            call ChkForLocationError;
            tmac.cnt = 0;           /* reset repeat count */
        end;

        call InitSpoolMode;
    end;
end;


Sub787A: procedure public;
    if mSpoolMode = 2 then
    do;
        if HaveTokens then
        do;
            if (tmac.localsCnt := tmac.localsCnt + 1) = 0 then
                call StackError;

            if tokenType(0) <> 9 then
                call MultipleDefError;

            call InsertMacroSym(tmac.localsCnt, 1);
            macroInPtr = symHighMark;
        end;
        if newOp = T$CR then
        do;
            mSpoolMode = 1;
            macroInPtr = symHighMark;
        end;
    end;
    else
        call SyntaxError;
end;



Sub78CE: procedure public;
    kk = byteAt(tmac.pCurArg);
    accFixFlags(0) = 1 - (kk = 21h and savedMtype = 2);
    if savedMtype = 0 or (tmac.cnt := tmac.cnt - accFixFlags(0)) = 0 then
        call UnNest(1);
    else
    do;
        if savedMtype = 1 then
            pNextArg = tmac.pCurArg - (kk and 7Fh);
        else
            pNextArg = tmac.pCurArg + accFixFlags(0);

        tmac.mtype = savedMtype;
        call Sub720A;
    end;
    lookAhead = 0;
    b6B2C, atStartLine = bTRUE;
end;

end;
src/list.plx
$IF MACRO
listm: do;
declare pointer literally 'address',
        word    literally 'address';
/* to force the code generation this needs a non-standard definition of put2Hex */
Put2Hex: procedure(arg1w, arg2w) external; declare arg1w pointer, arg2w word; end;
$include(:f3:listm.ipx)
$ELSE
listn: do;
declare pointer literally 'address',
        word    literally 'address';
Put2Hex: procedure(arg1w, arg2w) external; declare arg1w pointer, arg2w word; end;
$include(:f3:listn.ipx)
$ENDIF

declare aAssemblyComple(*) byte initial(CR, LF, 'ASSEMBLY COMPLETE,'),
    aNoErrors(*) byte initial('   NO ERRORS'),
    spaceLP(*) byte initial(' ('),
    space5RP(*) byte initial('     )'),
    aPublicSymbols(*) byte initial(CR, LF, 'PUBLIC SYMBOLS', CR, LF, 0),
    aExternalSymbol(*) byte initial(CR, LF, 'EXTERNAL SYMBOLS', CR, LF, 0),
    pad754E word,

    aUserSymbols(*) byte data(CR, LF, 'USER SYMBOLS', CR, LF, 0),
    lstHeader(*) byte data('  LOC  OBJ         LINE        SOURCE STATEMENT', CR, LF, LF, 0),
    symbolMsgTable(*) pointer data(.aPublicSymbols, .aExternalSymbol, .aUserSymbols);


Out2Hex: procedure(n);
    declare n byte;
    call Put2Hex(.outch, n);
end;


Print2Hex: procedure(n);
    declare n byte;
    call Put2Hex(.printChar, n);
end;



PrintStr: procedure(str) reentrant;
    declare str pointer;
    declare ch based str byte;

    do while ch <> 0;
        call PrintChar(ch);
        str = str + 1;
    end;
end;

PrintNStr: procedure(cnt, str) reentrant;
    declare cnt byte, str pointer;
    declare ch based str byte;

    do while cnt > 0;
        call PrintChar(ch);
        str = str + 1;
        cnt = cnt - 1;
    end;
end;


PrintCRLF: procedure reentrant;
    call PrintChar(CR);
    call PrintChar(LF);
end;

declare aNumStr(*) byte initial('     ', 0);


Itoa: procedure(n, buf);
    declare n word, buf pointer;
    declare ch based buf byte;

    call move(5, .spaces5, buf);
    buf = buf + 4;

    do while 1;
        ch = n mod 10 + '0';
        buf = buf - 1;
        if (n := n /10) = 0 then
            return;
    end;
end;


PrintDecimal: procedure(n) reentrant public;
    declare n word;
    call Itoa(n, .aNumStr);
    call PrintStr(.aNumStr(1));
end;

SkipToEOP: procedure public;
    do while pageLineCnt <= ctlPAGELENGTH;
        call Outch(LF);
        pageLineCnt = pageLineCnt + 1;
    end;
end;


NewPageHeader: procedure;
    declare twoLF(*) byte data(CR, LF, LF, 0);          /* Not used */
    declare threeLF(*) byte data(CR, LF, LF, LF, 0);    /* CR not used */

    call PrintStr(.threeLF + 1);
    call PrintStr(.asmHeader);
    call PrintDecimal(pageCnt);
    call PrintCRLF;
    if ctlTITLE then
        call PrintNStr(titleLen, .titleStr);

    call PrintCRLF;
    call PrintCRLF;
    if not b68AE then
        call PrintStr(.lstHeader);
    pageCnt = pageCnt + 1;
end;


NewPage: procedure public;
    if ctlTTY then
        call SkipToEOP;
    else
        call Outch(FF);

    pageLineCnt = 1;
    if not scanCmdLine then
        call NewPageHeader;
end;


DoEject: procedure public;
    if ShowLine then
    do while ctlEJECT > 0;
        call NewPage;
        ctlEJECT = ctlEJECT - 1;
    end;
end;




PrintChar: procedure(c) reentrant;
    declare c byte;
    declare cnt byte;

    if c = FF then
    do;
        call NewPage;
        return;
    end;

    if c = LF then
        if ctlPAGING then
        do;
            if (pageLineCnt := pageLineCnt + 1) >= ctlPAGELENGTH - 2 then
            do;
                if ctlTTY then
                    call Outch(LF);
                if ctlEJECT > 0 then
                    ctlEJECT = ctlEJECT - 1;
                call NewPage;
                return;
            end;
        end;

    if c = CR then
        curCol = 0;

    cnt = 1;
    if c = TAB then
    do;
        cnt = 8 - (curCol and 7);
        c = ' ';
    end;

    do while cnt <> 0;
        if curCol < 132 then
        do;
            if c >= ' ' then
                curCol = curCol + 1;
            if curCol > ctlPAGEWIDTH then
            do;
                call PrintCRLF;
                call PrintStr(.spaces24);
                curCol = curCol + 1;
            end;
            call Outch(c);
        end;
        cnt = cnt - 1;
    end;
end;

declare segChar(*) byte initial(' CDSME');    /* seg id char */

Sub7041$8447: procedure public;
    declare symGrp byte,
        flagsAndType word,
        (type, flags) byte at(.flagsAndType),
        zeroAddr byte;
    declare tokBytePair based tokenSymCurP word;

    PrintAddr2: procedure(printFunc);
        declare printFunc address;
        declare ch based tokenSymCurP byte;

        tokenSymCurP = tokenSymCurP - 1;    /* backup into value */
        call printFunc(ch and not zeroAddr);    /* print address or 0 */
    end;


    b68AE = TRUE;
    if not ctlSYMBOLS then
        return;

    segChar(0) = 'A';        /* show A instead of space for absolute */
    do symGrp = 0 to 2;
        kk = IsPhase2Print and ctlSYMBOLS;
$IF MACRO
        ctlDEBUG = ctlDEBUG or ctlMACRODEBUG;
$ENDIF
        tokenSymCurP = symTab(TID$SYMBOL) - 2;        /* address user sym(-1).type */
        call PrintCRLF;
        call PrintStr(symbolMsgTable(symGrp));

        do while (tokenSymCurP := tokenSymCurP + 8) < endSymTab(TID$SYMBOL);
            flagsAndType = tokBytePair;
            if type <> 9 then
                if type <> 6 then
$IF MACRO
                    if nonHiddenSymbol then
$ENDIF
                    do;
                        declare symGrpFLags(2) byte data(UF$PUBLIC, UF$EXTRN);

                        if symGrp <> 0 or type <> 3 then
                            if symGrp = 2 or (flags and symGrpFlags(symGrp)) <> 0 then
                            do;
                                call UnpackToken(tokenSymCurP - 6, .tokStr);
                                if kk then
                                do;
                                    if (ctlPAGEWIDTH - curCol) < 17 then
                                        call PrintCRLF;

                                    call PrintStr(.tokStr);
                                    call PrintChar(' ');
$IF MACRO
                                    if type = T$MACRONAME then
                                        call PrintChar('+');
                                    else
$ENDIF
                                    if (zeroAddr := (flags and UF$EXTRN) <> 0) then
                                        call PrintChar('E');
                                    else
                                        call PrintChar(segChar(flags and UF$SEGMASK));

                                    call PrintChar(' ');
                                    call PrintAddr2(.print2Hex);    /* print value/line */
                                    call PrintAddr2(.print2Hex);
                                    tokenSymCurP = tokenSymCurP + 2;  /* compensate for -2 due to PrintAddr2 */
                                    call PrintStr(.spaces4);
                                end;
                            end;
                    end;
        end;
    end;

    if ctlDEBUG then
        b68AE = FALSE;

    if kk then
        call PrintCRLF;
end;

PrintCmdLine: procedure public;
    declare ch based actRead byte;

    call Outch(FF);
    call DoEject;
    ch = 0;
    call PrintStr(.cmdLineBuf);
    call NewPageHeader;
end;


OutStr: procedure(s) reentrant public;
    declare s pointer;
    declare ch based s byte;

    do while ch <> 0;
        call Outch(ch);
        s = s + 1;
    end;
end;

OutNStr: procedure(cnt, s) reentrant;
    declare cnt byte, s address,
        ch based s byte;

    do while cnt > 0;
        call Outch(ch);
        s = s + 1;
        cnt = cnt - 1;
    end;
end;


MoreBytes: procedure byte;
    return startItem < endItem;
end;



PrintCodeBytes: procedure;
    declare ch based startItem byte;
    declare i byte;

    if (showAddr := MoreBytes or showAddr) then
    do;    /* print the address */
        call Out2Hex(high(effectiveAddr));
        call Out2Hex(low(effectiveAddr));
    end;
    else
        call OutStr(.spaces4);

    call Outch(' ');
    do  i = 1 to 4;
        if MoreBytes and isInstr then
        do;
            effectiveAddr = effectiveAddr + 1;
            call Out2Hex(ch);
        end;
        else
            call OutStr(.spaces2);

        startItem = startItem + 1;
    end;

    call Outch(' ');
    if shr(kk := tokenAttr(spIdx), 6) then    /* UF$EXTRN */
        call Outch('E');
    else if not showAddr then
        call Outch(' ');
    else
        call Outch(segChar(kk and 7));
end;


PrintErrorLineChain: procedure;
    declare LP(*) byte data(' (', 0),
            RP(*) byte data(')', 0);

    if not errorOnLine then
        return;

    call PrintStr(.LP); 
    call PrintNStr(4, .lastErrorLine);
    call PrintStr(.RP);
    call PrintCRLF;
    call move(4, .asciiLineNo, .lastErrorLine);
end;



PrintLine: procedure public;
    declare ch based inCh$p byte;
$IF MACRO
    declare ch1 based macro$p byte;
$ENDIF
loop:
    endItem = (startItem := tokStart(spIdx)) + tokenSize(spIdx);
    if IsSkipping then
        endItem = startItem;

    call Outch(asmErrCode);
$IF MACRO
    if mSpoolMode = 0FFh then
        call Outch('-');
    else
$ENDIF
        call Outch(' ');

    if not BlankAsmErrCode then
    do;
        asmErrCode = ' ';
        errorOnLine = TRUE;
    end;
    if isControlLine then
        call OutStr(.spaces15);
    else
        call PrintCodeBytes;

    if fileIdx > 0 then
    do;
        declare nestLevel(*) byte data('  1234');
    /* note byte arith used so pendingInclude = TRUE(255) treated as -1 */
        call Outch(nestLevel(ii := pendingInclude + fileIdx));
        if ii > 0 then    
            call Outch('=');
        else
            call Outch(' ');
    end;
    else
        call OutStr(.spaces2);

    if lineNumberEmitted then
    do;
        call OutStr(.spaces4);
        call PrintCRLF;
    end;
    else
    do;
        lineNumberEmitted = TRUE;
        call OutNStr(4, .asciiLineNo);
$IF MACRO
        if expandingMacro > 1 then
            call Outch('+');
        else
$ENDIF
            call Outch(' ');
$IF MACRO
        if expandingMacro > 1 then
        do;
            curCol = 24;
            ch1 = 0;
            call PrintStr(.macroLine);
            call PrintChar(LF);
        end;
        else
        do;
$ENDIF
            curCol = 24;
            call PrintNStr(lineChCnt, startLine$p);
        if ch <> LF then
                 call PrintChar(LF);
$IF MACRO
        end;
$ENDIF
    end;

    if isControlLine then
    do;
        if ctlPAGING then
            call DoEject;
    end;
    else
    do;
        do while MoreBytes;
            call OutStr(.spaces2);
            call PrintCodeBytes;
            call PrintCRLF;
        end;

        if spIdx > 0 and (inDB or inDW) then
        do;
            call Sub546F;
            goto loop;
        end;
    end;

    call PrintErrorLineChain;
end;

AsmComplete: procedure public;
    if errCnt > 0 then
        call Itoa(errCnt, .aNoErrors);
    call PrintNStr((errCnt = 1) + 32, .aAssemblyComple);
    if errCnt > 0 then
    do;
        call move(4, .lastErrorLine, .space5RP);
        call PrintNStr(8, .spaceLP);
    end;
    call Outch(CR);
    call Outch(LF);
end;

FinishPrint: procedure public;
    if ctlPRINT then
        call CloseF(outfd);
    outfd = 0;
    pageLineCnt = 1;
    call AsmComplete;
    call Flushout;
end;

FinishAssembly: procedure public;
    declare drive based effectiveAddr byte;

    call CloseF(infd);
$IF MACRO
    call CloseF(macrofd);
    call Delete(.asmac$ref, .statusIO);
    if ctlOBJECT then   /* ?? why only for MACRO version */
        call CloseF(objfd);
$ENDIF
    if ctlXREF then /* invoke asxref ?? */
    do;
        effectiveAddr = Physmem - 1;
        drive = '0';    /* put drive in a known location */
        if asxref$tmp(0) = ':' then
            drive = asxref$tmp(2);
    
        call Load(.asxref, 0, 1, 0, .statusIO);
        call IoErrChk;
    end;

    call Exit;
end;
end;
src/init.plx
$IF MACRO
initm: do;
$include(:f3:initm.ipx)
$ELSEIF BIG
initb: do;
$include(:f3:initb.ipx)
$ELSE
inits: do;
$include(:f3:inits.ipx)
$ENDIF

declare aExtents(*) byte public initial(' LSTOBJ'),
    aDebug(*) byte initial('DEBUG');


/* skip white space in command line */
CmdSkipWhite: procedure public;
    declare cmdch based cmdch$p byte;
    
    do while (cmdch = ' ' or cmdch = TAB) and cmdch$p <> actRead;
        cmdch$p = cmdch$p + 1;
    end;
end;

/*
    return drive ('0'-'9') of current program.
    skips DEBUG if present
    returns '0' if no drive specified
*/
GetDrive: procedure byte public;
    declare cmdch based cmdch$p byte;

    if cmdch = ':' then
    do;
        cmdch$p = cmdch$p + 2;
        return cmdch;
    end;
    else
        do ii = 0 to 4;        /* case insensitive compare to DEBUG */
        if cmdch <> aDebug(ii) and aDebug(ii) + 20h <> cmdch then
                return '0';    /* must be a file name so drive 0 */
            cmdch$p = cmdch$p + 1;
        end;
    call CmdSkipWhite;
    if cmdch <> ':' then
        return '0';
    cmdch$p = cmdch$p + 2;
    return cmdch;
end;

AddExtents: procedure public;
    do ii = 1 to 3;
        lstFile(kk + ii) = aExtents(ii);
        objFile(kk + ii) = aExtents(ii+3);
    end;
end;


/* inits usage include overlay file initiatisation */

GetAsmFile: procedure public;
    declare cmdch based cmdch$p byte;

    CmdIsWhite: procedure byte;
        declare cmdch based cmdch$p byte;
        return cmdch = ' ' or cmdch = TAB or cmdch = CR;
    end;

    /* select key words depending on whether macro version or not */
$IF MACRO
    symTab(TID$KEYWORD) = .extKeywords;    /* extended key words */
$ELSE
    symTab(TID$KEYWORD) = .stdKeywords;    /* no extended key words */
$ENDIF
    /* set location of symbol table */
    symHighMark, endSymTab(TID$KEYWORD), symTab(TID$SYMBOL), endSymTab(TID$SYMBOL) =
$IF NOT SMALL
                         .MEMORY;
$ELSE
                         .EDATA;
$ENDIF
    call Rescan(1, .statusIO);    /* get the command line */
    call IoErrChk;
    call Read(1, .cmdLineBuf, 128, .actRead, .statusIO);
    call IoErrChk;
    actRead = actRead + .cmdLineBuf;    /* convert to pointer */
    scanCmdLine = TRUE;        /* scanning command line */
$IF SMALL
    /* asm80 only, shows signon msg */
    call Write(0, .signonMsg, 29h, .statusIO);
    call Write(0, .signonMsg, 2, .statusIO);
    call IoErrChk;
$ENDIF
    call CmdSkipWhite;
$IF SMALL
    ovlFile(2),               /* ovl 1,2,3 are assumed on current drive */
$ENDIF
    asxref(2) = GetDrive;     /* asxref tmp file defaults to current drive */

    do while not CmdIsWhite;    /* skip to end of program name */
        cmdch$p = cmdch$p + 1;
    end;

    call CmdSkipWhite;
    if cmdch = CR then        /* no args !! */
        call RuntimeError(RTE$FILE);

    infd = SafeOpen(cmdch$p, READ$MODE);    /* Open file for reading */
    rootfd, srcfd = infd;
    ii = TRUE;      /* copying name */

    kk = 0;     /* length of file name */
    do while not CmdIsWhite;    /* copy file name over to the files list */
        files(0).name(kk) = cmdch;
        if ii then        /* and the name for the lst and obj files */
            lstFile(kk), objFile(kk) = cmdch;
        if cmdch = '.' then
        do;
            /* WARNING: global var ii is set to false here but used as an
               index in AddExtents leaving value of 4 which in plm is also false */ 
            ii = FALSE; /* don't copy extent for lst & obj files */
            call AddExtents;    /* add lst and obj file extents */
        end;
        kk = kk + 1;
        cmdch$p = cmdch$p + 1;
    end;
    controls$p = cmdch$p;        /* controls start after file name */
    if ii then            /* no extent in source file */
    do;
        lstFile(kk) = '.';    /* add the . and the extents */
        objFile(kk) = '.';
        call AddExtents;
    end;

    files(0).name(kk) = ' ';    /* append trailing space */
    /* set drive for macro and asxref tmp files if specified in source file */
    if lstFile(0) = ':' and lstFile(2) <> '0' then
$IF MACRO
        asmac$ref(2),
$ENDIF
        asxref$tmp(2) = lstFile(2);
end;


ResetData: procedure public;    /* extended initialisation */

    call InitLine;

    b6B33, scanCmdLine, skipIf(0), b6B2C, inElse(0), finished, segHasData(0), segHasData(1), inComment,
$IF MACRO
    expandingMacro, macroDivert, mSpoolMode,
$ENDIF
    hasVarRef, pendingInclude = bZERO;
    noOpsYet, primaryValid, ctlLIST, ctlLISTChanged = bTRUE;
$IF MACRO
    ctlGEN = bTRUE;
$ENDIF
    ctlCOND = bTRUE;
$IF MACRO
    macroDepth, macroSpoolNestDepth, macroCondStk(0), macroCondSP = bZERO; 
$ENDIF
    saveIdx, lookAhead, activeSeg, ifDepth, opSP, opStack(0) = bZERO;
$IF MACRO
    macroBlkCnt = wZERO;
$ENDIF
    segSize(SEG$ABS), segSize(SEG$CODE), segSize(SEG$DATA),
    maxSegSize(SEG$ABS), maxSegSize(SEG$CODE), maxSegSize(SEG$DATA), effectiveAddr,
$IF MACRO
    localIdCnt,
$ENDIF
    externId, errCnt = wZERO;
    passCnt = passCnt + 1;
    srcLineCnt, newOp, pageCnt, pageLineCnt = 1;
    b68AE = FALSE;
    curChar = ' ';
    do ii = 0 to 11;        /* reset all the control seen flags */
        controlSeen(ii) = false;
    end;
$IF MACRO
    curMacroBlk = 0FFFFH;
$ENDIF
    if not IsPhase1 then    /* close any Open include file */
    do;
        if fileIdx <> 0 then
        do;
            call CloseF(srcfd);
            call IoErrChk;
            srcfd = rootfd;
        end;

        fileIdx = bZERO;    /* reset files for another pass */
        endInBuf$p = .inBuf;
        inCh$p = endInBuf$p - 1;
        startLine$p = .inBuf;
        call Seek(infd, SEEKABS, .azero, .azero, .statusIO);    /* rewind */
        call IoErrChk;
    end;

    baseMacroTbl = Physmem + 0BFh;
    endOutBuf = .b6A00;
end;

InitRecTypes: procedure public;
    r$content.type = OMF$CONTENT;
    r$content.len = 3;
    r$publics.type = OMF$RELOC;
    r$publics.len = 1;
    r$interseg.type = OMF$INTERSEG;
    r$interseg.len = 2;
    r$extref.type = OMF$EXTREF;
    r$extref.len = 1;
end;
end;
src/keym.plm
keym: do;
$include(:f3:keym.ipx)

declare copyright(*) byte data('(C) 1976,1977,1979,1980 INTEL CORP');
declare extKeywords(151) KEYWORD$T public initial(
/*
    4 byte packed keyword
    byte opcode base
    byte offset to next entry or 0 if end
    byte type
    byte flags
*/
 /* [   token     ] opBase offset type        flags */
    0A528h,      0,    0,    0,      K$NE,   0,      /* NE */
     63B0h,      0, 0CCh,    0,   K$IMM16,   0,      /* CZ */
     6E60h,  9C40h,    0,    0,    K$ENDM,   0,      /* ENDM */
    0BFB6h,      0, 0C0h,    0,  K$SINGLE,   0,      /* RNZ */
    0B354h,      0, 0C1h,    0,   K$REG16,   0,      /* POP */
     6EE9h,      0,    0,    0,     K$EQU,   0,      /* EQU */
    0C6CDh,      0,  32h,  80h,   K$IMM16,   0,      /* STA */
    0A1A5h,      0,    6,  80h,     K$MVI,   0,      /* MVI */
    0C6CFh,      0,  37h,    0,  K$SINGLE,   0,      /* STC */
    0C6CDh,  6158h,    0,    0, K$SPECIAL, 1Bh,      /* STACK */
     6615h,      0,  27h,    0,  K$SINGLE,   0,      /* DAA */
     988Dh, 0E100h,  0Ah,    0,  K$LDSTAX,   0,      /* LDAX */
     61F6h,      0, 0C4h,    0,   K$IMM16,   0,      /* CNZ */
     53CFh,      0,  88h,  88h,   K$ARITH,   0,      /* ADC */
     53D0h,      0,  80h,    0,   K$ARITH,   0,      /* ADD */
     8D9Fh,      0, 0D2h, 0A0h,   K$IMM16,   0,      /* JNC */
         0,      0,    0,    0,         0,   0,
         0,      0,    0,    0,         0,   0,
         0,      0,    0,    0,         0,   0,
     6E60h,      0,    0,  88h,     K$END,   0,      /* END */
     6A40h,      0,    3, 0A0h, K$REGNAME,   0,      /* E */
         0,      0,    0,    0,         0,   0,
    0AD70h,      0,    0,    0,      K$OR,   0,      /* OR */
    0AE08h,      0, 0D3h,    0,    K$IMM8,   0,      /* OUT */
    0A088h,      0,    0,    0,     K$MOD,   0,      /* MOD */
    0AD83h,      0,    0,    0,     K$ORG,   0,      /* ORG */
         0,      0,    0,    0,         0,   0,
     8F70h,      0, 0CAh,  70h,   K$IMM16,   0,      /* JZ */
     68E9h,  76C0h,    0,    0,    K$DSEG,   0,      /* DSEG */
    0C488h,      0,    0,    0,     K$SET,   0,      /* SET */
     8BD8h,      0, 0DAh,  10h,   K$IMM16,   0,      /* JC */
    0C521h,      0,  30h,    0,  K$SINGLE,   2,      /* SIM */
     6618h,      0,    9,    8,   K$REG16,   0,      /* DAD */
    0B16Ch,  9600h, 0E9h,    0,  K$SINGLE,   0,      /* PCHL */
    0A4A1h,  6A40h,    0,    0,    K$NAME,   0,      /* NAME */
     6748h,      0, 0F3h,    0,  K$SINGLE,   0,      /* DI */
     53D5h,      0, 0C6h,  18h,    K$IMM8,   0,      /* ADI */
     6630h,      0,    0,    0,      K$DB,   0,      /* DB */
     8DB6h,      0, 0C2h,    0,   K$IMM16,   0,      /* JNZ */
    0AD7Dh,      0, 0B0h,    0,   K$ARITH,   0,      /* ORA */
    0B3FBh,      0,    6,    0, K$REGNAME,   0,      /* PSW */
    0AD85h,      0, 0F6h,    0,    K$IMM8,   0,      /* ORI */
    0A09Ah,      0,  40h, 0B8h,     K$MOV,   0,      /* MOV */
     8610h,      0,    0, 0B8h,      K$IF,   0,      /* IF */
         0,      0,    0,    0,         0,   0,
     9938h,  6400h,  2Ah, 0B0h,   K$IMM16,   0,      /* LHLD */
     9600h,      0,    5, 0B0h, K$REGNAME,   0,      /* L */
    0C6F6h,      0,  90h,    0,   K$ARITH,   0,      /* SUB */
    0C634h,  9600h, 0F9h,    0,  K$SINGLE,   0,      /* SPHL */
    0C405h,      0, 0DEh,    0,    K$IMM8,   0,      /* SBI */
         0,      0,    0,    0,         0,   0,
    0BF4Fh,      0,    7,    0,  K$SINGLE,   0,      /* RLC */
     5780h,      0,    0,    0, K$REGNAME,   0,      /* B */
         0,      0,    0,    0,         0,   0,
    0E614h,  9600h, 0E3h, 0E8h,  K$SINGLE,   0,      /* XTHL */
         0,      0,    0,    0,         0,   0,
         0,      0,    0,    0,         0,   0,
    0B11Bh,  6A40h,    2,    0, K$SPECIAL,   0,      /* PAGE */
         0,      0,    0,    0,         0,   0,
         0,      0,    0,    0,         0,   0,
    0A7C0h,      0,    0, 0D8h,     K$NUL,   0,      /* NUL */
     8750h,      0, 0DBh,    0,    K$IMM8,   0,      /* IN */
     6E60h,  8610h,    0, 0D0h,   K$ENDIF,   0,      /* ENDIF */
         0,      0,    0,    0,         0,   0,
         0,      0,    0,    0,         0,   0,
    0C3FEh,      0,  98h,    0,   K$ARITH,   0,      /* SBB */
    0C6D7h,  9A10h,    0,    0,   K$STKLN,   0,      /* STKLN */
    0BFE0h,      0, 0F0h,    0,  K$SINGLE,   0,      /* RP */
    0C078h,      0, 0C7h,    0,     K$RST,   0,      /* RST */
    0C4F8h,  6400h,  22h,    0,   K$IMM16,   0,      /* SHLD */
     9E57h, 0BFB8h,    0,    0,   K$MACRO,   0,      /* MACRO */
     6231h,      0, 0ECh,    0,   K$IMM16,   0,      /* CPE */
    0B436h,  9957h,    0, 0A8h,  K$PUBLIC,   0,      /* PUBLIC */
    0BDA0h,      0,  17h, 0A8h,  K$SINGLE,   0,      /* RAL */
     6FF5h, 0CBE8h,    0, 0D8h,   K$EXITM,   0,      /* EXITM */
     6235h,      0, 0FEh,    0,    K$IMM8,   0,      /* CPI */
    0BF68h,      0, 0F8h,    0,  K$SINGLE,   0,      /* RM */
         0,      0,    0,    0,         0,   0,
         0,      0,    0,    0,         0,   0,
    0BDA6h,      0,  1Fh,    0,  K$SINGLE,   0,      /* RAR */
     805Bh,  7D00h,    0, 0B8h,    K$HIGH,   0,      /* HIGH */
     6400h,      0,    2, 0C8h, K$REGNAME,   0,      /* D */
    0B447h,  7D00h, 0C5h, 0D0h,   K$REG16,   0,      /* PUSH */
    0C6FDh,      0, 0D6h,    8,    K$IMM8,   0,      /* SUI */
     6220h,      0, 0F4h,    0,   K$IMM16,   0,      /* CP */
     61A8h,      0, 0FCh,    0,   K$IMM16,   0,      /* CM */
         0,      0,    0,    0,         0,   0,
     5629h,  76C0h,    0,    0,    K$ASEG,   0,      /* ASEG */
    0BFF1h,      0, 0E8h,    0,  K$SINGLE,   0,      /* RPE */
     880Ch,  5DC0h,    0, 0A8h,    K$IRPC,   0,      /* IRPC */
    0BE48h,      0, 0C9h,    0,  K$SINGLE,   0,      /* RET */
     876Eh,      0,    4,    0,  K$INRDCR,   0,      /* INR */
    0BEE1h,      0,  20h,    0,  K$SINGLE,   2,      /* RIM */
    0BFFBh,      0, 0E0h,    0,  K$SINGLE,   0,      /* RPO */
    0C6CDh, 0E100h,    2,  28h,  K$LDSTAX,   0,      /* STAX */
     988Dh,      0,  3Ah,  98h,   K$IMM16,   0,      /* LDA */
     7000h, 0BF90h,    0,    0,   K$EXTRN,   0,      /* EXTRN */
     8774h,      0,    3,  90h,   K$REG16,   0,      /* INX */
     61B5h,      0,  2Fh,  90h,  K$SINGLE,   0,      /* CMA */
     876Ch,  5449h,    1,    0, K$SPECIAL,   0,      /* INPAGE */
     9A47h,  5500h,    0,  98h,   K$LOCAL,   0,      /* LOCAL */
    0E5BDh,      0, 0A8h,    8,   K$ARITH,   0,      /* XRA */
     80E0h,      0,  76h,    0,  K$SINGLE,   0,      /* HLT */
     8DE0h,      0, 0F2h,    0,   K$IMM16,   0,      /* JP */
     9A5Bh,      0,    0,    0,     K$LOW,   0,      /* LOW */
     6D88h,      0, 0FBh,    0,  K$SINGLE,   0,      /* EI */
     623Bh,      0, 0E4h,    0,   K$IMM16,   0,      /* CPO */
     6676h,      0,    5,  68h,  K$INRDCR,   0,      /* DCR */
    0E5C5h,      0, 0EEh,    0,    K$IMM8,   0,      /* XRI */
     555Dh,      0, 0A0h,    0,   K$ARITH,   0,      /* ANA */
     62A9h,  76C0h,    0,    0,    K$CSEG,   0,      /* CSEG */
     8D68h,      0, 0FAh,    0,   K$IMM16,   0,      /* JM */
     5560h,      0,    0,    0,     K$AND,   0,      /* AND */
     5140h,      0,    7,  58h, K$REGNAME,   0,      /* A */
    0BE44h, 0C800h,    0,    0,    K$REPT,   0,      /* REPT */
     8DF1h,      0, 0EAh,    0,   K$IMM16,   0,      /* JPE */
     880Ch,      0,    0,    0,     K$IRP,   0,      /* IRP */
     5565h,      0, 0E6h,    0,    K$IMM8,   0,      /* ANI */
     9B00h,      0,    0,    0,      K$LT,   0,      /* LT */
     61B7h,      0,  3Fh,    0,  K$SINGLE,   0,      /* CMC */
     8DFBh,      0, 0E2h,    0,   K$IMM16,   0,      /* JPO */
     7BC0h,      0,    0,    0,      K$GT,   0,      /* GT */
     6978h,      0,    0,  78h,      K$DW,   0,      /* DW */
     6EC8h,      0,    0,    0,      K$EQ,   0,      /* EQ */
     68D8h,      0,    0,  48h,      K$DS,   0,      /* DS */
     7968h,      0,    0, 0A0h,      K$GE,   0,      /* GE */
    0A6D4h,      0,    0,    0,  K$SINGLE,   0,      /* NOP */
     9F01h, 0AD95h,    0,    0, K$SPECIAL, 1Ch,      /* MEMORY */
     5FE0h,  9600h, 0CDh,    0,   K$IMM16,   0,      /* CALL */
    0BDD8h,      0, 0D8h,    0,  K$SINGLE,   0,      /* RC */
     53ADh,      0, 0CEh,  80h,    K$IMM8,   0,      /* ACI */
    0BF9Fh,      0, 0D0h,    0,  K$SINGLE,   0,      /* RNC */
    0E36Ch,  76C0h, 0EBh,    0,  K$SINGLE,   0,      /* XCHG */
     61C4h,      0, 0B8h,    8,   K$ARITH,   0,      /* CMP */
     667Ch,      0,  0BH,    0,   K$REG16,   0,      /* DCX */
    0C620h,      0,    6,    0,      K$SP,   0,      /* SP */
     9C40h,      0,    6,    0, K$REGNAME,   0,      /* M */
     98A8h,      0,    0,  38h,      K$LE,   0,      /* LE */
     6018h,      0, 0DCh,    0,   K$IMM16,   0,      /* CC */
     7D00h,      0,    4,  50h, K$REGNAME,   0,      /* H */
    0C03Fh,      0,  0Fh,  50h,  K$SINGLE,   0,      /* RRC */
    0C4F8h,      0,    0,    0,     K$SHL,   0,      /* SHL */
     5DC0h,      0,    1,    0, K$REGNAME,   0,      /* C */
    0C170h,      0, 0C8h,    0,  K$SINGLE,   0,      /* RZ */
    0E556h,      0,    0,    0,     K$XOR,   0,      /* XOR */
     6E1Fh,  6A40h,    0,    0,    K$ELSE,   0,      /* ELSE */
    0A6D8h,      0,    0,    0,     K$NOT,   0,      /* NOT */
    0C4FEh,      0,    0,    0,     K$SHR,   0,      /* SHR */
     9BB5h,      0,    1,    0,     K$LXI,   0,      /* LXI */
     8D84h,      0, 0C3h,    0,   K$IMM16,   0,      /* JMP */
     61DFh,      0, 0D4h,    0,   K$IMM16,   0       /* CNC */
);


end;
src/pcktok.asm
    public PckTok
    public Isis
    extrn toksiz
    extrn tokst;

    aseg
Isis    equ    40h    ; definition of Isis entry, here to avoid another asm file

; pckTkn - packs the token pointed by tokst, with length toksiz into 4 bytes
; packed version replaces original and toksize set to 4 bytes

    CSEG
PckTok: lhld    tokst    ; pointer to the token to pack
    xchg
    lxi    h, toksiz
    mov    c, m    ; unpacked length
    mvi    m, 4    ; new packed length is 4 bytes
    call pack3    ; pack 3 chars into hl
    push    h
    call pack3
    pop    b
    xchg        ; put the packed data into the first 4 bytes
    dcx    h
    dcx    h
    dcx    h
    mov    m, d
    dcx    h
    mov    m, e
    dcx    h
    mov    m, b
    dcx    h
    mov    m, c
    ret
pack3:
    lxi    h, 0    ; get 3 chars packed into 2 bytes
    mvi    b, 3

L6291:
    push    d    ; pointer to next char
    mov    d, h    ; hl x 40
    mov    e, l
    dad    h
    dad    h
    dad    d
    dad    h
    dad    h
    dad    h
    pop    d    
    call pack1    ; add in next char
    add    l
    mov    l, a
    mvi    a, 0
    adc    h
    mov    h, a
    dcr    b    ; get the 3 chars
    jnz    L6291
    ret

pack1:    ldax    d        ; pick up next character
    inx    d        ; advance for next time
    dcr    c        ; check it is valid
    jm    L62B7
    sui    2Fh        ; /012345678  (0-9)
                ; 9?@ABCDEFG  (10-19)
                ; HIJKLMNOPQ  (20-29)
                ; RSTUVWXYZ[  (30-39)
    cpi    10h        ; digit so return
    rc
    sui    5        ; exclude : ; < = >
    ret

L62B7:
    sub    a        ; 0 no char
    ret

    end
src/cprite.asm
    cseg
cprite:
    db '(C) 1976,1977,1979,1980 INTEL CORP'
    end
src/edata.asm
    public EDATA
    DSEG
EDATA    equ    $
    end

src/asxref.plm
asxref: do;

declare    CR literally '0Dh',
    LF literally '0Ah',
    FF literally '0Ch',
    TRUE literally '0ffh',
    FALSE literally '0',
    bool literally 'byte',
    READ$MODE literally '1',        /* Open mode */
    WRITE$MODE literally '2',
    UPDATE$MODE literally '3',
    SEEKEND literally '4',        /* seek mode */
    TYPEREF literally '1',    /* tmp file types */
    TYPEDEF literally '0',
    TYPEFILE literally '2',
    TYPEEOF literally '3';

declare cpyrite(*) byte data('(C) 1976, 1977,1979 INTEL CORP', 2, 1);
declare xrefComplete(*) byte data('CROSS REFERENCE COMPLETE');
declare headerMsg(*) byte data(CR, LF,
        'ISIS-II ASSEMBLER SYMBOL CROSS REFERENCE, V2.1                     PAGE ');
declare inputError(*) byte data('INPUT FILE FORMAT ERROR');
declare noMemory(*) byte data('NOT ENOUGH MEMORY');
declare isis address data(40h);
declare maxMem address at(4);

declare errStrs(*) byte data(
        0, 0,
        2, 'ILLEGAL AFTN ARGUMENT', 0,
        4, 'INCORRECTLY SPECIFIED FILE', 0,
        5, 'UNRECOGNIZED DEVICE NAME', 0,
        6, 'ATTEMPT TO WRITE TO INPUT DEVICE', 0,
        8, 'ATTEMPT TO READ FROM OUTPUT DEVICE', 0,
        0Ah, 'NOT ON SAME DISK', 0,
        0Bh, 'FILE ALREADY EXISTS', 0,
        0Ch, 'FILE IS ALREADY OPEN', 0,
        0Dh, 'NO SUCH FILE', 0,
        0Eh, 'WRITE PROTECTED', 0,
        11h, 'NOT A DISK FILE', 0,
        12h, 'ILLEGAL ISIS COMMAND', 0,
        13h, 'ATTEMPTED SEEK ON NON-DISK FILE', 0,
        14h, 'ATTEMPTED BACK SEEK TOO FAR', 0,
        15h, 'CAN''T RESCAN', 0,
        16h, 'ILLEGAL ACCESS MODE TO OPEN', 0,
        17h, 'MISSING FILENAME', 0,
        19h, 'ILLEGAL ECHO FILE', 0,
        1Ah, 'ILLEGAL ATTRIBUTE IDENTIFIER', 0,
        1Bh, 'ILLEGAL SEEK COMMAND', 0,
        1Ch, 'MISSING EXTENSION', 0,
        1Fh, 'CAN''T SEEK ON WRITE ONLY FILE', 0,
        20h, 'CAN''T DELETE OPEN FILE', 0,
        23h, 'SEEK PAST EOF', 0,
        0C9h, 'UNRECOGNIZED SWITCH', 0,
        0CAh, 'UNRECOGNIZED DELIMITER', 0,
        0CBh, 'INVALID SYNTAX', 0,
        0CCh, 'PREMATURE EOF', 0,
        0CEh, 'ILLEGAL DISKETTE LABEL', 0,
        0D0h, 'CHECKSUM ERROR', 0,
        0D1h, 'RELO FILE SEQUENCE ERROR', 0,
        0D2h, 'INSUFFICIENT MEMORY', 0,
        0D3h, 'RECORD TOO LONG', 0,
        0D4h, 'ILLEGAL RELO RECORD', 0,
        0D5h, 'FIXUP BOUNDS ERROR', 0,
        0D6h, 'ILLEGAL SUBMIT PARAMETER', 0,
        0D7h, 'ARGUMENT TOO LONG', 0,
        0D8h, 'TOO MANY PARAMETERS', 0,
        0D9h, 'OBJECT RECORD TOO SHORT', 0,
        0DAh, 'ILLEGAL RECORD FORMAT', 0,
        0DBh, 'PHASE ERROR', 0);





declare    
    topLowHeap address,
    startMarker address,
    tmpAFTN address,
    topHighHeap address, drive based topHighHeap byte,
    conn$p address,
    itemCount address,
    botHighHeap address,
    status address,
    outputLine(256) byte,
    col byte,
    path(15) byte,
    row byte,
    pageLength byte,
    pageWidth byte,
    recordType byte,
    haveFileInfo bool,
    paging bool,
    aF0AsxrefTmp(*) byte initial(':F0:ASXREF.TMP ');


declare    ISIS$OPEN    literally    '0',
    ISIS$CLOSE    literally    '1',
    ISIS$DELETE    literally    '2',
    ISIS$READ    literally    '3',
    ISIS$WRITE    literally    '4',
    ISIS$SEEK    literally    '5',
    ISIS$EXIT    literally    '9',
    ISIS$ERROR    literally    '12';

Open: procedure (conn$p, path, access, echo, status$p);
    declare (conn$p, path, access, echo, status$p) address;
    call isis(ISIS$OPEN, .conn$p);
end Open;

Read: procedure (conn, buff$p, count, actual$p, status$p);
    declare (conn, buff$p, count, actual$p, status$p) address;
    call isis(ISIS$READ, .conn);
end Read;

Seek: procedure (conn, mode, block$p, byte$p, status$p);
    declare (conn, mode, block$p, byte$p, status$p) address;
    call isis(ISIS$SEEK, .conn);
end Seek;

Write: procedure (conn, buff$p, count, status$p);
    declare (conn, buff$p, count, status$p) address;
    call isis(ISIS$WRITE, .conn);
end Write;

Close: procedure (conn, status$p);
    declare (conn, status$p) address;
    call isis(ISIS$CLOSE, .conn);
end Close;

Error: procedure (error$num);
    declare (error$num, status$p) address;
    status$p = .status$p;
    call isis(ISIS$ERROR, .error$num);
end Error;

Exit: procedure;
    declare status$p address;
    status$p = .status$p;
    call isis(ISIS$EXIT, .status$p);
end Exit;

Delete: procedure (path, status$p);
    declare (path, status$p) address;
    call isis(ISIS$DELETE, .path);
end Delete;

AvailMem: procedure address;
    return (maxMem - 100h) and 0ff00h;
end;


ReportError: procedure(scode);
    declare scode address;
    declare unknown(3) byte;
    declare i address, wstatus address;

    if scode <> 0 then
    do;
        i = 0;
        do while i < 38Fh;
            if scode = errStrs(i) and errStrs(i + 1) <> 0 then
            do;
                i = i + 1;
                call Write(0, .(' '), 1, .wstatus);    
                do while errStrs(i) <> 0;
                    call Write(0, .errStrs(i), 1, .wstatus);
                    i = i + 1;
                end;
                call Write(0, .(CR, LF), 2, .wstatus);
                return;
            end;
            else
            do;
                do while errStrs(i) <> 0;
                    i = i + 1;
                end;
                i = i + 1;
            end;
        end;
        call Error(scode);
    end;
end;

StatusChk: procedure(scode);
    declare scode address;

    if scode <> 0 then
    do;
        call ReportError(scode);
        call Close(tmpAFTN, .status);
        call Close(conn$p, .status);
        call Exit;
    end;
end;

OpenTmp: procedure;
    declare tstatus byte;    /* benign bug should be address but next data byte is dummy */

    call Open(.tmpAFTN, .aF0AsxrefTmp, READ$MODE, 0, .tstatus);
    call StatusChk(tstatus);    
end;


OpenListFile: procedure;
    declare dummy byte;

    if path(0) = ':' and (path(1) and 0dfh) <> 'F' then    /* test as UCase */
        call Open(.conn$p, .path, WRITE$MODE, 0, .status);    /* device */
    else
        call Open(.conn$p, .path, UPDATE$MODE, 0, .status);    /* file */

    call StatusChk(status);
    call Seek(conn$p, SEEKEND, .dummy, .dummy, .status);    /* seek end */
    if status = 13h then    /* bad seek on non file is ok */
        return;
    call StatusChk(status);
end;

ReadTmp: procedure(buf, cnt) bool;
    declare buf address, cnt byte;
    declare actual address;

    call Read(tmpAFTN, buf, cnt, .actual, .status);
    call StatusChk(status);
    return actual = cnt;
end;


WriteStr: procedure(str, len);
    declare str address, len byte;
    call Write(conn$p, str, len, .status);
    call StatusChk(status);
end;

WriteCRLF: procedure;
    call WriteStr(.(CR, LF), 2);
end;


ToNextPage: procedure;
    call WriteStr(.(FF), 1);
    call WriteCRLF;
    call WriteCRLF;
    call WriteCRLF;
end;


OutStrCRLF: procedure(str, len);
    declare str address, len byte;
    call Write(0, str, len, .status);
    call Write(0, .(CR, LF), 2, .status);
end;


FatalError: procedure(err);
    declare err byte;

    if err = 0 then
        call OutStrCRLF(.inputError, 23);
    else
        call OutStrCRLF(.noMemory, 17);
    call Close(tmpAFTN, .status);
    call Exit;
end;


AllocLineRef: procedure address;
    topLowHeap = topLowHeap + 4;
    if  topLowHeap <= botHighHeap then
        return topLowHeap - 4;
    call FatalError(1);
end;

AllocXref: procedure address;
    botHighHeap = botHighHeap - 8;
    if botHighHeap >= topLowHeap then
        return botHighHeap + 1;
    call FatalError(1);
end;

FirstXref: procedure address;
    return (topHighHeap - 8) + 1;
end;


TestMoreXrefs: procedure(arg1w) byte;
    declare arg1w address;

    return arg1w > botHighHeap;
end;

NextXref: procedure(arg1w) address;
    declare arg1w address;
    return (arg1w - 8);
end;

CmpXrefNames: procedure(pstr1, pstr2) bool;
    declare (pstr1, pstr2) address;
    declare str1 based pstr1 (6) byte,
        str2 based pstr2 (6) byte;
    declare i byte;

    do i = 0 to 5;
        if str1(i) <> str2(i) then
            return FALSE;
    end;
    return TRUE;
end;
        
FindXref: procedure(pXref, pFound) address;
    declare (pXref, pFound) address;
    declare found based pFound bool;
    declare (pNewXref, pTestXref) address,
        i byte;
    declare item based pXref (8) byte,
        newXref based pNewXref (8) byte;

    found = FALSE;
    pTestXref = FirstXref;
    do while not found and TestMoreXrefs(pTestXref);
        if CmpXrefNames(pXref, pTestXref) then
            found = TRUE;
        else
            pTestXref = nextXref(pTestXref);
    end;

    if found then
        return pTestXref;
    else
    do;
        pNewXref = AllocXref;
        do i = 0 to 5;
            newXref(i) = item(i);
        end;
        itemCount = itemCount + 1;
        return pNewXref;
    end;
end;


InsertXref: procedure(isDef, pInRef, lineNum);
    declare isDef byte, (pInRef, lineNum) address,
        (pHeadLineRef, pPtr, pLineRef, qPtr, pXref) address,
        found byte;
    declare lineNumRef based pLineRef structure(lineNum address, next address),
        q based    qPtr address, p based pPtr address,
        headLineRef based pHeadLineRef address;

    pXref = FindXref(pInRef, .found);
    pHeadLineRef = pXref + 6;
    pLineRef = AllocLineRef;
    if isDef then
        lineNum = lineNum or 8000h;
    lineNumRef.lineNum = lineNum;
    qPtr = .lineNumRef.next;
    if found then
    do;
        pPtr = headLineRef + 2;
        q = p;
        p = pLineRef;
    end;
    else
        q = pLineRef;

    headLineRef = pLineRef;
end;

GetPLineRef: procedure(from, ptr, pMoreLineRefs) address;
    declare from byte, (ptr, pMoreLineRefs) address;
    declare (ppHead, pNext) address;
    declare pHead based ppHead address;
    declare next based pNext address;
    declare moreLineRefs based pMoreLineRefs bool;

    if from = 0 then    /* ptr -> Xref */
    do;
        ppHead = ptr + 6;
        pNext = pHead + 2;
        moreLineRefs = TRUE;
        return startMarker := next;
    end;
    else
    do;            /* ptr -> LineRef */
        pNext = ptr + 2;
        moreLineRefs = startMarker <> next;
        return next;
    end;
end;

GetLineNum: procedure(pLineRef, pIsDef) address;
    declare (pLineRef, pIsDef) address;
    declare isDef based pIsDef byte;
    declare lineNum based pLineRef address;

    isDef = ROL(high(lineNum), 1);
    return 7fffh and lineNum;
end;


CopyXref: procedure(pStr1, pStr2);
    declare (pStr1, pStr2) address;
    declare str1 based pStr1 (8) byte,
        str2 based pStr2 (8) byte;
    declare i byte;

    do i = 0 to 7;
        str2(i) = str1(i);    
    end;
end;


GetPXref: procedure(n) address;    /* get address of Xref(n) */
    declare n address;
    return topHighHeap - n * 8 + 1;
end;


GetTmpRecord: procedure byte;
    if not ReadTmp(.outputLine, 1) then
        return 3;
    if outputLine(0) = '0' or outputLine(0) = '1' then
    do;
        if not ReadTmp(.outputLine(1), 10) then
            call FatalError(0);
    end;
    else if outputLine(0) = '2' then
    do;
        if not ReadTmp(.outputLine(1), 20) then
            call FatalError(0);
    end;
    else
    do;
         if outputLine(0) = '3' then
            return TYPEEOF;
         call FatalError(0);
    end;
    return outputLine(0) - '0';
end;


Htoi: procedure(buf, n) address;
    declare buf address, n byte;
    declare (val, pCh) address;
    declare ch based pCh byte;

    val = 0;

    do pCh = buf to  buf + n - 1;
        if ch <= '9' then
            val = val * 16 + (ch - '0');
        else
            val = val * 16 + (ch - ('A' - 10));
    end;
    return val;
end;


GetPSymbol: procedure address;
    return .outputLine(1);
end;

GetLineNumber: procedure address;
    return Htoi(.outputLine(7), 4);
end;

ProcXrefRecord: procedure(isDef);
    declare isDef byte;
    call InsertXref(isDef, GetPSymbol, GetLineNumber);
end;

CopyFileName: procedure;
    declare (i, j) byte;

    j = 0;
    do i = 0 to 14;
        path(i) = outputLine(j := j + 1);
    end;
end;



ProcFileRecord: procedure;
    call CopyFileName;
    paging = outputLine(16);
    pageLength = htoi(.outputLine(17), 2);
    pageWidth = htoi(.outputLine(19), 2);
    haveFileInfo = TRUE;
end;

SortXrefs: procedure;
    declare (i, j, k, m, n) address,
        tmpXref(8) byte;

    IsLessThan: procedure byte;
        declare pstr address, i byte;
        declare str based pstr (6) byte;

        pstr = GetPXref(m);
        do i = 0 to 5;
            if tmpXref(i) <> str(i) then
                return tmpXref(i) < str(i);
        end;
        return 0;
    end;

    i, j, k = 1;

    do while k < itemCount;
        i = j;
        j = k;
        k = k * 3 + 1;
    end;

    k = i;

    do while k <> 0;
        n = k + 1;
        do while n <= itemCount;
            m = n - k;
            call CopyXref(GetPXref(n), .tmpXref);
            do while m > 0 and m < 8000h and IsLessThan;
                call CopyXref(GetPXref(m), GetPXref(m + k));
                m = m - k;
            end;
            call CopyXref(.tmpXref, GetPXref(m + k));
            n = n + 1;
        end;
        k = (k - 1) / 3;
    end;
end;


Num2Ascii: procedure(val, buf, len);
    declare (val, buf) address, len byte;
    declare pc address, c based pc byte;

    pc = buf + len - 1;
    do while pc >= buf;
        c = val mod 10 + '0';
        val = val / 10;
        pc = pc - 1;
    end;    
    pc = buf;
    do while c = '0' and pc < buf + len - 1;
        c = ' ';
        pc = pc + 1;
    end;
end;

BlankOutputLine: procedure;
    declare i byte;
    do i = 0 to 255;
        outputLine(i) = ' ';
    end;
end;

PageHeader: procedure(pageNum);
    declare pageNum byte, asciiPageNum(3) byte;

    call Num2Ascii(pageNum, .asciiPageNum, 3);
    call ToNextPage;
    call WriteStr(.headerMsg+2, 72);
    call WriteStr(.asciiPageNum, 3);
    call writeCRLF;
    call writeCRLF;
    row = 7;
end;



NameToOutputLine: procedure(pName);
    declare pName address, i byte;
    declare name based pName (6) byte;

    do i = 0 to 5;
        outputLine(col) = name(i);
        col = col + 1;
    end;
end;

OutputLineRef: procedure(pLineRef);
    declare pLineRef address;
    declare lineNum address, isDefinition byte;

    lineNum = GetLineNum(pLineRef, .isDefinition);
    call Num2Ascii(lineNum, .outputLine(col), 4);
    col = col + 4;
    if isDefinition then
        outputLine(col) = '#';
    col = col + 3;
end;

OutputXref: procedure;
    declare (refsPerLine, refsCnt, pageNum) byte,
        (pLineRef, pXref) address, moreLineRefs byte;

    refsPerLine = (pageWidth - 6) / 7;
    pageNum = 1;
    call PageHeader(1);
    pXref = FirstXref;
    
    do while TestMoreXrefs(pXref);
        call blankOutputLine;
        col = 0;
        call NameToOutputLine(pXref);
        pLineRef = GetPLineRef(0, pXref, .moreLineRefs);
        do while moreLineRefs;
            col = 7;
            refsCnt = 0;
            do while (refsCnt := refsCnt + 1) <= refsPerLine and moreLineRefs;
                call OutputLineRef(pLineRef);
                pLineRef = GetPLineRef(1, pLineRef, .moreLineRefs);
            end;
            call WriteStr(.outputLine, col - 1);
            call writeCRLF;
            if paging then
                if (row := row + 1) = pageLength - 2 then
                    call PageHeader(pageNum := pageNum + 1);
            if moreLineRefs then
                call blankOutputLine;
        end;
        pXref = NextXref(pXref);
    end;
end;

main:
    itemCount = 0;
    topLowHeap = .Memory;
    botHighHeap, topHighHeap = AvailMem - 1;
    if drive <> '0' then
        aF0AsxrefTmp(2) = drive;
    haveFileInfo = FALSE;
    call OpenTmp;
    call outStrCRLF(.headerMsg, 51);

    do while 1 ;
        recordType = GetTmpRecord;
        if recordType = TYPEDEF or recordType = TYPEREF then
            call ProcXrefRecord(recordType = TYPEDEF);
        else if recordType = TYPEFILE then
            call ProcFileRecord;
        else
        do;
            if not haveFileInfo then        
                call FatalError(0);
            call SortXrefs;
            call OpenListFile;
            call OutputXref;
            call WriteCRLF;
            call WriteStr(.xrefComplete, 24);
            call WriteCRLF;
            call Close(tmpAFTN, .status);
            call Close(conn$p, .status);
            call Delete(.aF0AsxrefTmp, .status);
            call Exit;
        end;
    end;
end;
