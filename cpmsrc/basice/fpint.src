	NAME	FPINT	;FLOATING POINT INTERFACE PACKAGE
	CSEG		;CODE SEGMENT
;
;	NOTE: THE JMP 0000 TO BUILD MUST BE PATCHED
;		  JMP 0000 TO INTERP MUST BE PATCHED
;
;
;	EQUATES FOR CP/M SYSTEM
BDOS	EQU	0005H	;PRIMARY ENTRY POINT TO CP/M
BOOT	EQU	0000H	;REBOOT ENTRY POINT
;
;	PUBLIC SYMBOLS FOR MAIN PROGRAM
;
	PUBLIC	BEGIN,START	;BEGINNING OF BUILD, START OF INTERP
	PUBLIC	MON1		;FUNC,PARM INPUT, NO OUTPUT
	PUBLIC	MON2		;FUNC,PARM INPUT, BYTE OUTPUT
	PUBLIC	MON3		;SYSTEM REBOOT
;
	PUBLIC	MOVEA		;.SOURCE,DEST,N, MOVES BYTES
	PUBLIC	MOVE4		;SOURCE,DEST, MOVES 4 BYTES
;
	PUBLIC	CBIN		;CONVERT TO BINARY
	PUBLIC	CFLT		;CONVERT TO FLOAT
	PUBLIC	FLTINP		;FLOATING POINT INPUT
	PUBLIC	FLTOUT		;FLOATING POINT OUTPUT
	PUBLIC	FPOUT		;EQUIVALENT TO FLTOUT
	PUBLIC	FLTRET		;FLOATING POINT OPERATOR RETURN
	PUBLIC	FLTOP		;FLOATING POINT OPERATOR
;
;	SPECIAL PURPOSE SUBROUTINES
	PUBLIC	INPUT	;PORT, RETURNS BYTE
	PUBLIC	OUTPUT	;PORT, BYTE
	PUBLIC	RANDOM
;
;	EXTERNAL SYMBOLS
	EXTRN	FSTOR,FLOAD,FADD,FSUB,FMUL,FDIV,FABS,FZERO,FTEST,FCHS
	EXTRN	OVER
	EXTRN	FINP,FOUT,FFLOAT,FFIX
	EXTRN	FSQRT,FCOS,FSIN,FATAN,FCOSH,FSINH,FEXP,FLOG
	EXTRN	RAND
	EXTRN	ACCUM

    extrn   mainln      ; label entry point for INTERP
    extrn   build       ; label entry point for BUILD
    extrn   bbase       ; base of build module

; the version of this used in BASICE has a different precision
BASICE  equ 1

    if BASICE EQ 1
EOFF    equ 8           ; offset of 'E' in ACCUM
    else
EOFF    equ 9
    endif

;
;	SUBROUTINES FOR MONITOR INTERFACE
;	START OF BASIC COMPILER
	JMP build - 3      	;PATCHED TO BUILD ENTRY POINT
START:
	JMP	mainln - 3	;GO TO THE INTERPRETER
; modified to use BUIID location, assumes module is located on a page boundary
; and BUILD entry point is on first page.
BEGIN:	DW  bbase	;FILLED IN WHEN WE FIGURE OUT MEMORY MAP
;
MON1:	JMP	BDOS
MON2:	JMP	BDOS
MON3:	JMP	BOOT
;
;	SPECIAL PURPOSE SUBROUTINE ENTRY POINTS
;
;	SUBROUTINES FOR STORAGE MOVE OPERATIONS
MOVEA:	;.SOURCE,DESTINATION,COUNT ADDRESSED BY B,C
	MOV	H,B
	MOV	L,C
	MOV	C,M	;LS SOURCE
	INX	H
	MOV	B,M	;MS SOURCE
	INX	H
	MOV	E,M	;LS DEST
	INX	H
	MOV	D,M	;MS DEST
	INX	H
	MOV	A,M	;LS COUNT
	INX	H
	MOV	H,M	;MS COUNT
	MOV	L,A	;LS COUNT
;	SOURCE IN B,C  DEST IN D,E  COUNT IN H,L
MOVER:	MOV	A,L	;CHECK FOR ZERO COUNT
	ORA	H	;BOTH ZERO?
	RZ
;	MOVE NEXT BYTE FROM SOURCE TO DESTINATION
	DCX	H	;COUNT = COUNT - 1
	LDAX	B	;BYTE TO REGISTER A
	STAX	D	;TO DESTINATION
	INX	B	;SOURCE = SOURCE + 1
	INX	D	;DEST = DEST + 1
	JMP	MOVER	;FOR THE NEXT BYTE
;
MOVE4:	;SOURCE IN B,C  DEST IN D,E
	LXI	H,4
	JMP	MOVER
;
;  FPINT IS AN INTERFACE PROGRAM BETWEEN THE
;  INTERPRETER AND THE FLOATING POINT PACKAGE
;      THE FLOATING POINT PACKAGE IS LOCATED AT
;
;  THERE ARE SIX ENTRY POINTS INTO FPINT:
;
;      (1) FLTINP - CONVERTS ASCII NUMERIC
;      STRING TO FLOATING POINT
;
;      (2) FLTOUT - CONVERTS FLOATING POINT
;      NUMBER TO AN ASCII STRING
;
;      (3) CBIN - CONVERTS FLOATING POINT
;      NUMBER TO A BINARY NUMBER
;
;      (4) CFLT - CONVERST BINARY NUMBER
;      TO A FLOATING POINT NUMBER
;
;      (5) FLTRET - PERFORMS FP ARITHMETIC
;      OPERATION AND STORES RESULT BACK INTO
;      AREA SPECIFIED BY THE INTERPRETER
;
;      (6) FLTOP - PERFORMS FP ARITHMETIC
;      OPERATION BUT DOES NOT STORE RESULT
;      BACK INTO INTERPRETER
;
;
;
;
;	ENTRY POINT FOR INP CALL (FUNCTION)
;	REG C CONTAINS NUMBER OF CHARACTERS TO CONVERT
;	REG D,E POINT TO CHAR STRING TO BE CONVERTED
;	TO FLOATING POINT REPRESENTATION. FIRST IT IS
;	MOVED TO ACCUM AND THEN CONVERTED.	THIS IS DONE
;	BECAUSE FP PKG REQUIRES ALL ADDRESSES BE ON ONE PAGE
;
FLTINP:
	MOV	A,C
	ORA	A
	JNZ	FLTI1
	MVI	C,8
	JMP	FLTOP
FLTI1:	LXI	H,ACCUM	;POINTER TO ACCUM
INP1:	LDAX	D	;LOAD A CHAR
	SUI	30H	;CONVERT TO INTERFACE CODE
	MOV	M,A	;STORE CHAR INTO ACCUM
	INX	D	;POINT TO NEXT CHAR
	INX	H	;POINT TO NEXT ACCUM LOC
	DCR	C	;DECREMENT COUNTER
	JNZ	INP1	;LOOP
	MVI	A,011H	;END OF STRING INDICATOR	
	MOV	M,A
	LXI	H,ACCUM	;THIS IS WHERE STRING IS NOW
	CALL	FINP	;CALL FP PKG
	RET		;RETURN TO INTERP
;
;	ENTRY POINT FOR OUT CALL (FUNCTION 12)
;	CONVERT NUMBER IN FP ACCUM TO STRING AND PLACE IT
;	IN THE ADDRESS IN REG B,C. ACCUM USED AS INTERM.
;	STORAGE OF STRING.
;
FPOUT:
FLTOUT:
	PUSH	B
	LXI	H,ACCUM	;TEMP STORE STRING HERE
	CALL	FOUT	;CONVERT TO ASCII
	LXI	D,ACCUM+EOFF	;IS IT IN EXP FORM?
	LDAX	D	;IF SO THIS IS LETTER E
	LXI	D,ACCUM+EOFF+4	;SETUP REG D,E
	CPI	'E' - 30H	;IS IT AN E?
	JZ	FP2	;YES LEAVE STRING AS IS
FP1:
;	OTHERWISE REMOVE TRAILING BLANKS, ZEROS
	DCX	D	;NEXT LOCATION
	LDAX	D	;GET CHAR
	CPI	0	;A ZERO?
	JZ	FP1	;YES, SKIP IT
	CPI	0F0H	;A BLANK?
	JZ	FP1	;YES, SKIP IT
;	FOUND NON BLANK, NON ZERO CHAR
	CPI	0FEH	;IS IT TRAILING .
	JNZ	FP3	;IF SO ELIM 
FP2:
	DCX	D	;IT WAS . SO ELIM
FP3:
	POP	H	;ADDRESS TO STORE STRING
	MOV	B,E	;SAVE RIGHT END OF STRING
	LXI	D,ACCUM	;BEGINNING
FP4:
	LDAX	D	;GET CHAR
	ADI	30H	;CONV TO ASCII
	CPI	' '	;IF A BLANK DO NOT PASS 
	JZ	FP5	;TO MAIN PROGRAM IE SKIP IT
	MOV	M,A	;NOT BLANK MOVE IT
	INX	H	;NEXT LOCATION
FP5:
	MOV	A,E	;CURRENT POS
	INX	D	;SETUP FOR NEXT CHAR
	CMP	B	;COMPLETE?
	JNZ	FP4	;NO	- CONTINUE
	MVI	M,' '	;LEAVE TRAILING BLANK
	RET
;
;	ENTRY POINT FOR CONVERSION FROM F/P TO BINARY
;	REG B,C CONTAINS ADDRESS OF F/P NUMBER
;	BINARY NUMBER IS MOVED BACK TO REPLACE F/P NUMBER
;
CBIN:	PUSH	B	;SAVE ADDRESS
	POP	D	;NOW ADDRESS IN D,E
	PUSH	D	;SAVE AGAIN
	MVI	C,2	;LOAD FUNCTION NUMBER
	CALL	FLTOP	;GET F/P NUMBER INTO REG A-D
	MVI	E,32	;SET SCALING FACTOR
	CALL	FFIX	;CALL CONV ROUTINE
	JMP EMPTY	;MOVE BACK AND RETURN
;
;	ENTRY POINT FOR CONVERSION FROM BINARY TO F/P
;	REG B,C CONTAIN ADDRESS OF NUMBER TO CONV
;
CFLT:	PUSH	B
	POP	H	;NOW ADDR IN H,L
	PUSH	H	;ALSO SAVE IT
	CALL	FETCH	;GET NUMBER TO REG A - D
	MVI	E,32
	CALL	FFLOAT	;CALL CONV TO BINARY ROUTINE
	JMP	EMPTY	;MOVE BACK AND RET
;
;	BUILD JUMP TABLE FOR USE BY STORE AND ENTER
;
JUMPT:
	DW	INITP	;FUNC = 0 INITIALIZE
	DW	FSTOR	;FUNC = 1 STORE ACCUM
	DW	FLOAD	;FUNC = 2 LOAD ACCUM
	DW	FADD	;FUNC = 3 ADD TO ACCUM
	DW	FSUB	;FUNC = 4 SUB FROM ACCUM
	DW	FMUL	;FUNC = 5 MULT ACCUM
	DW	FDIV	;FUNC = 6 DIV ACCUM
	DW	FABS	;FUNC = 7 ABSOLUTE VALUE
	DW	FZERO	;FUNC = 8 ZERO ACCUM
	DW	FTEST	;FUNC = 9 TEST FOR ZERO
	DW	FCHS	;FUNC = 10 COMPLEMENT ACCUM
	DW	FSQRT	;FUNC = 11 SQUARE ROOT
	DW	FCOS	;FUNC = 12 COSINE
	DW	FSIN	;FUNC = 13 SINE
	DW	FATAN	;FUNC = 14 ARCTAN
	DW	FCOSH	;FUNC = 15 COSH
	DW	FSINH	;FUNC = 16
	DW	FEXP	;FUNC = 17
	DW	FLOG	;FUNC = 18
;
;	ENTRY POINT WHEN RESULT IE FP ACCUM IS STORED
;		BACK INTO ADDRESS PASSED IN D,E.
;		REG C IS A FUNCTION
;		REG D,E IS ADDRESS OF PARAMETER
;
FLTRET:	;PERFORM OPERATION AND RETURN RESULT
	PUSH	D	;SAVE RETURN PARAMETER ADDRESS
	CALL	FLTOP	;RETURNS TO THIS ADDRESS
EMPTY:	POP	H	;RETURN PARAMETER ADDRESS
	MOV	M,A
	INX	H
	MOV	M,B
	INX	H
	MOV	M,C
	INX	H
	MOV	M,D
	RET
;
;
;	ENTRY POINT WHEN NO STORE BACK IS DESIRED
;		REG C IS FUNCTION
;		REG D,E IS A PARAMETER
;
;	GET PROPER FUNCTION BY ADDIING FUNCTION NUMBER IN B
;	REGISTER TO THE FIRST FUNCTION ADDRESS SETUP AS A DW
;
FLTOP:
	LXI	 H,JUMPT
	MVI	B,0
	DAD	 B
	DAD	 B
;
	MOV	C,M
	INX	H
	MOV	B,M
	LXI	H,JMPIN+1	;CHANGE ADDRESS FIELD
	MOV	M,C
	INX	H
	MOV	M,B
;	JMP INSTRUCTION CHANGED (CANNOT USE PCHL BECAUSE OF H,L PARAMETER)
	XCHG	;PARM TO H,L READY FOR CALL
JMPIN:	JMP	0000	;ADDRESS FIELD ALTERED ABOVE
;
;
INITP:	XRA	A
	STA	OVER
	RET
;
;
INPUT:	;PORT NUMBER, RETURN VALUE IN A
	LXI	H,INP+1
	MOV	M,C	;IN XX CHANGED
INP:	IN	00	;CHANGED ABOVE
	RET
;
OUTPUT:	;PORT NUMBER, VALUE
	LXI	H,OUTP+1
	MOV	M,C	;OUT INSTRUCTION CHANGED
	MOV	A,E	;VALUE TO SEND
OUTP:	OUT	00	;CHANGED ABOVE
	RET
;
RANDOM:	JMP	RAND
;
;	THE FOLLOWING SUBROUTINE MOVES A FOUR BYTE
;	QUANTITY FROM MEMORY TO REG A - D
;
FETCH:
	MOV	A,M
	INX	H
	MOV	B,M
	INX	H
	MOV	C,M
	INX	H
	MOV	D,M
	RET
;
	END
