link.pex
AddFixup        P("word" fixupAddr,"word" fixupRef,B fixupSeg,"bool" isExt,B targetSeg,"bool" hasOffset,"word" offset,"bool" calcChain)
AddOverlayThunks    P
ClearTmpBuf     P
CloseF          P("pointer" fcbP)
ClrBuf          P("pointer" bufP,"word" len)
CmdLineError    P
CRdStr          P("pointer" strP)
CreatF          P("pointer" fcbP)
CWrite          P(B ch)
Delete          P("pointer" fcbP)
DoLibRequests   P
EndFileProcessing   P
ExistF          P("pointer" fcbP)"bool"
Fatal           P("pointer" str)
FinalseImage    P
FindChainHead   P("word" addr,B mode)"bool"
FindLibRequest  P("pointer" nameP,B nameLen)"bool"
FixupLocation   P
GenerateImage   P
GetChain        P"pointer"
GetCommonSize   P"word"
GetFixed        PB
GetFixupAddr    P"word"
GetFixupOff     P"word"
GetFixupRef     P"word"
GetFixupSeg     PB
GetFixupStatus  PB
GetHasOffset    PB
GetItemLength   PB
GetLibRequest   P"bool"
GetNextNonBlankChar P
GetResolved     PB
GetSegLink      P"pointer"
GetSegment      PB
GetSerial       P
GetSymbolBase   P"pointer"
GetSymLength    PB
GetVal          P"word"
GetVer          P"word"
InsertSymbol    P("pointer" nameP,B nameLen,"word" val,B seg,B isResolved,"bool" isCommon,"word" sizeCommon)
IOErr           P("pointer" msg,"pointer" fname)
LinkSetEntry    P
LoadByteFromSeg P("word" addr)B
LoadFile        P
LoadIrlLib      P
LoadOneModule   P
LWrite          P(B ch)
MakeF           P("pointer" fcbP)
MPMSys          P"pointer"
NewLn           P
Open            P("pointer" fcbP)B
OpenF           P("pointer" fcbP)
OS              P
OverflowFixups  P
ParseFileAndOptions P
Process$FPBNX   P
PutCh           P(B ch)
PutFn           P("pointer" fcbP)
PutStr          P("pointer" str)
RdBits          P(B cnt)B
RdBuf           P
ReadF           P("pointer" bufP, "word" len, "pointer" fcbP)
ReadFR          P("pointer" bufP, "word" len, "pointer" fcbP)"word"
ReadYBlk        P
ReadYByte       PB
ReadYWord       P"word"
RequireOvlayHandler P
ReverseChain    P
RwInWindow      P("word" addr, "bool" wr)
SaveConstByte   P(B n)
SearchSymbol    P("pointer" nameP,B nameLen, "bool" includeCommon)B
SeekXTmpFile    P
SelectSegment   P(B n)
SelectXFile     P("pointer" fileP)
SelectYFile     P("pointer" fileP)
SetFixed        P
SetFixupAddr    P("word" addr)
SetFixupRef     P("word" ref)
SetFixupSeg     P(B seg)
SetIsChainExt   P("bool" isExt)
SetLibRequest   P
SetResolved     P("bool" state)
SetSegLink      P("pointer" link)
SetSegment      P(B n)
SetVal          P("word" val)
StoreByteInSeg  P("word" addr,B Val)
StrEqu          P("pointer" str1,"pointer" str2,B len)"bool"
TellTopModule   P
TestValidSymbol P"bool"
WriteF          P("pointer" bufP, "word" len, "pointer" fcbP)
WriteSymFile    P
WriteXBlk       P
YRewind         P

additionalMem   "bool"
aFieldAddr      "word"
aFieldSeg       B
aIndexError     B(12)
aMemoryOverflow B(32)
aNoFil          B(10)
aOverlappingSeg B(21)
baseCr          B
baseEx          B
baseOutType     B
bField          B(9)
bFieldLen       B
bFieldName      B(8)
biosLink        "bool"
bitCnt          B
botFixup        "pointer"
bufP            "pointer"
charOutDev      B
cmdLineBuffer   B(128)
cmdLineP        "pointer"
curAddr         "word"
curBase         "word"(4)
curCommonBase   "word"
curCommonIsFixed    B
curFileLoadAddress  "word"
curLoc          "word"(4)
curSeg          B
dataOrgRequest  "bool"
dataOrigin      "word"
dMemry          B(6)
dstDrive        B
endMem          "word"
fcb1            BS
fixupP          "pointer"
freeMem         "word"
hashTable       "pointer"(128)
haveOverlays    "bool"
haveSpecialSym  "bool"
highAbs         "word"
imageBase       "word"
imgBufSize      "word"
imgIdx          "word"
indexBuf        B(512)
indexFcb        B(33)
indexIdx        "word"
indexLen        "word"
initialJmp      B
insertP         "pointer"
intermediateDrive   B
isIRL           B
isMinus         "bool"
libDrive        B
librarySearch   "bool"
loading         "bool"
lowAbs          "word"
lowMarkFixup    "pointer"
modLengths      "word"(4)
modName         B(8)
MPMMemSize      "word"
noLeadingQ      "bool"
numSegs         B
objFName        B(12)
outType         B
progOrgRequest  "bool"
progOrigin      "word"
qMark           B
qMemry          B
relBuf          B(512)
relEndRec       "word"
relIdx          "word"
relLen          "word"
relStartRec     "word"
rootDstDrive    B
segOrder        B(4)
signature       B(3)
startLabelRequest   B
starts          "word"(4)
startSym        B(7)
startSymAddr    "word"
startSymLen     B
symDrive        B
fixupHeadP        "pointer"(4)
symP            "pointer"
symTableP       "pointer"
targetFile      B(12)
topMemory       "pointer"
topSymTable     "pointer"
transferAddr    "word"
transferFlag    "bool"
transferSeg     B
wordP           "wpointer"
xFileP          "pointer"
xFileTable      "pointer"(4)
xxabs           "XFILE$T"
xxcomm          "XFILE$T"
xxdata          "XFILE$T"
xxprog          "XFILE$T"
yFileP          "pointer"
yFileTable      "pointer"(4)
yyabs           "YFILE$T"
yycomm          "YFILE$T"
yydata          "YFILE$T"
yyprog          "YFILE$T"

/* fcb offsets */
FCB$DR      '0'
FCB$NAME    '1'
FCB$EXT     '9'
FCB$EX      '12'
FCB$S1      '13'
FCB$S2      '14'
FCB$RC      '15'
FCB$REC     '16'
FCB$CR      '32'

/* code types */
ASEG        '0'
CSEG        '1'
DSEG        '2'
COMMON      '3'
EXTFIXUP    '0'

/* key REL record types */
ENTRYSYM    '0'
SELCOMM     '1'
PROGNAM     '2'
REQUEST     '3'
UNUSED4     '4'
SIZCOMM     '5'
EXTCHAIN    '6'
ENTRYPT     '7'
EXTMINUS    '8'
EXTPLUS     '9'
SIZDATA     '10'
SETLOC      '11'
ADDRCHAIN   '12'
SIZPROG     '13'
ENDMOD      '14'
ENDFILE     '15'
STDLINK     '16'


/* non printable chars */
CR          '0dh'
LF          '0ah'
TAB         '9'

/* extension types */
COM$EXT     '0'
PRL$EXT     '1'
RSP$EXT     '2'
SPR$EXT     '3'
OVL$EXT     '4'

/* my types */
bool        'byte'
word        'address'
pointer     'address'
wpointer    'address'

/* link's version of TRUE/FALSE */
TRUE        '1'
FALSE       '0'

/* common structures */
XFILE$T1    'startAddr word, endAddr word, len word, buf address'
XFILE$T2    'curBlk word, lastDiskBlk word, dirty bool, onDisk bool, fcb(33) byte'
XFILE$T     'structure(XFILE$T1,XFILE$T2)' 
YFILE$T     'structure(buffer word, bufIdx word, len word, onDIsk bool, fcb(33) byte)'
FIXUP$T     'structure(control byte, addr word, ref word, link pointer, offset word)'
SYM$T       'structure(chain pointer, iInfo byte, val word, sInfo byte, sName(1) byte)'
PSTR$T      'structure(len byte, str(1) byte)'
LOC$T       'structure(ex byte, rec byte, off byte)'

/*  based variables */
wordVal     "word"..wordP
cmdCh       B..cmdLineP
sym         "SYM$T"..symP
fixup       "FIXUP$T"..fixupP
yFile       "YFILE$T"..yFileP
xFile       "XFILE$T"..xFileP



link.plm
link: do;

$include(link.ipx)
/* jmp to main. The -3 forces the sp load to be the target */
declare enter structure(jmp byte, target address) data(0c3h, .main - 3);

declare cpyRight(*) byte data('COPYRIGHT (C) 1980 DIGITAL RESEARCH ');
declare patch(90) byte data(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                            0, 0, 0, 0, 0);

declare serial(*) byte data(7Fh, 0, 3, 0, 0, 1);
declare qMark byte public data('?');
declare additionalMem bool public data(0);
declare bufSizes(4) word data(400h, 2000h, 1800h, 200h);
declare wBufSizes(4) word at(.bufSizes);    /* trick to allow write to data values */

declare cmdLin(128) byte public at(80h);
declare fcb1(32) byte public at(05ch);


declare banner(*) byte initial(0Ch, 'LINK 1.31', LF, CR, '$', '01/04/83');

declare qMemry(*) byte public initial('?MEMRY');
declare dMemry(*) byte public initial('$MEMRY');
declare MPMMemSize word public initial(0);
declare outType byte public initial(COM$EXT);
declare curFileLoadAddress word public initial(100h);
declare biosLink bool public initial(0);
declare needBanner bool initial(TRUE);
declare charOutDev byte public initial('X');
declare intermediateDrive byte public initial(0);
declare libDrive byte public initial(0);
declare dstDrive byte public initial(0);
declare symDrive byte public initial(0);
declare rootDstDrive byte public initial(0);
declare noLeadingQ bool public initial(TRUE);
declare haveSpecialSym bool public initial(FALSE);
declare endMem word public initial(0);
declare objFName(*) byte public initial(0, '           ');
declare baseOutType byte public initial(COM$EXT);
declare imageBase word public initial(0);
declare haveOverlays bool public initial(FALSE);
declare build bool initial(FALSE);
declare overlayCnt byte initial(   0);
declare overlayTable(5) structure(curFileLoadAddress word, symP pointer);
declare wordP wpointer public initial(0);
declare wordVal based wordP word;     /* need to define after wordP to avoid PLM error */
declare topMemory pointer public initial(0);
declare freeMem word public initial(0);
declare aMemoryOverflow(*) byte public initial('MEMORY OVERFLOW, USE [A] SWITCH$');
declare aInsufficientMemory(*) byte initial('INSUFFICIENT MEMORY$');
declare aOverlappingSeg(*) byte public initial('OVERLAPPING SEGMENTS$');
/*
   signature is only used for special common area processing
   exact usage unknown
*/
declare signature(3) byte public initial(0, 0, 0);
declare relStartRec word public initial(0);
declare relEndRec word public initial(0);
declare baseEx byte public initial(0);
declare baseCr byte public initial(0);
declare indexFcb(33) byte public;
declare indexIdx word public initial(0);
declare indexLen word public initial(200h);
declare isIRL byte public initial(0);
declare targetFile(*) byte public initial('            ');
declare cmdLineP pointer public initial(0);
declare cmdCh based cmdLineP byte;        /* need to define after cmdLineP */
declare bitCnt byte public initial(0);
declare relIdx word public initial(0);
declare imgBufSize word public initial(400h);
declare imgIdx word public initial(0);
declare relLen word public initial(400h);
/* modName is only written to */
declare modName(8) byte public initial(0, 0, 0, 0, 0, 0, 0, 0);
declare curAddr word public initial(0);
declare progOrgRequest bool public initial(FALSE);
declare dataOrgRequest bool public initial(FALSE);
declare startLabelRequest bool public initial(FALSE);
declare progOrigin word public initial(0);
declare dataOrigin word public initial(0);
declare startSym(*) byte public initial(0, 0, 0, 0, 0, 0, 0);
declare startSymLen byte public initial(0);
declare transferFlag bool public initial(0);
declare transferAddr word public initial(0);
declare transferSeg byte public initial(0);
declare startSymAddr word public initial(0);
declare lowAbs word public initial(0FFFFh);
declare highAbs word public initial(0);
declare initialJmp byte public initial(0);
declare curSeg byte public initial(0);
declare loading bool public initial(FALSE);
declare librarySearch bool public initial(0);
declare topSymTable pointer public initial(0);
declare symTableP pointer public initial(0);
declare symP pointer public initial(0);
declare curCommonIsFixed bool public initial(FALSE);
declare curCommonBase word public initial(0);
declare fixupHeadP(4) word public initial(0, 0, 0, 0);
declare botFixup pointer public initial(0);
declare lowMarkFixup pointer public initial(0FFFFh);
declare fixupP pointer public initial(0);
declare insertP pointer public initial(0);
declare curLoc(4) word public initial(0, 0, 0, 0);
declare curBase(4) word public initial(0, 0, 0, 0);
declare modLengths(4) word public initial(0, 0, 0, 0);
declare starts(4) word public initial(0, 0, 0, 0);
declare segOrder(4) byte public initial(0, 1, 2, 3);
declare numSegs byte public initial(0);
declare aFieldSeg byte public initial(0);
declare aFieldAddr word public initial(0);
declare bField(9) byte public initial(0, 0, 0, 0, 0, 0, 0, 0, 0);
declare bFieldLen byte public at(.bField);
declare bFieldName byte public at(.bField + 1);
declare xxabs XFILE$T public initial(0, 0, 0, 0, 1, 0, 0, 0, 0,  'XXABS   $$$', 0, 0, 0, 0, 0, 0);
declare xxprog XFILE$T public initial(0, 0, 0, 0, 1, 0, 0, 0, 0, 'XXPROG  $$$', 0, 0, 0, 0, 0, 0);
declare xxdata XFILE$T public initial(0, 0, 0, 0, 1, 0, 0, 0, 0, 'XXDATA  $$$', 0, 0, 0, 0, 0, 0);
declare xxcomm XFILE$T public initial(0, 0, 0, 0, 1, 0, 0, 0, 0, 'XXCOMM  $$$', 0, 0, 0, 0, 0, 0);
declare xFileTable(4) pointer public initial(.xxabs, .xxprog, .xxdata, .xxcomm);
declare yyabs YFILE$T public initial(0, 0, 100h, 0, 0,  'YYABS   $$$', 0, 0, 0, 0, 0, 0);
declare yyprog YFILE$T public initial(0, 0, 400h, 0, 0, 'YYPROG  $$$', 0, 0, 0, 0, 0, 0);
declare yydata YFILE$T public initial(0, 0, 400h, 0, 0, 'YYDATA  $$$', 0, 0, 0, 0, 0, 0);
declare yycomm YFILE$T public initial(0, 0, 100h, 0, 0, 'YYCOMM  $$$', 0, 0, 0, 0, 0, 0);
declare yFileTable(4) pointer public initial(.yyabs, .yyprog, .yydata, .yycomm);



/* print char to console / printer determined by charOutDev */
OutCh: procedure (ch);
    declare ch byte;

    if charOutDev = 'X' then
        call CWrite(ch);
    else if charOutDev = 'Y' then
        call LWrite(ch);
end;


/* print string to console / printer */
OutStr: procedure(str);
    declare str pointer;
    declare ch based str byte;

    do while ch <> '$';
        call OutCh(ch);
        str = str + 1;
    end;
end;

/* if printer then print banner once */
PrinterBanner: procedure;
    if charOutDev = 'Y' then
    do;
        needBanner = FALSE;
        call OutStr(.banner);
    end;
end;

/* print char, if printer make sure banner has printed */
PutCh: procedure(ch) public;
    declare ch byte;

    if needBanner then
        call PrinterBanner;
    call OutCh(ch);
end;

/* print string, if printer make sure banner has printed */
PutStr: procedure(str) public;
    declare str pointer;

    if needBanner then          /* see if banner printed */
        call PrinterBanner;     /* print full banner if list device */
    call OutStr(str);           /* print user's string */
end;


/* allocate xFile and possibly yFile, buffer information */
SetMemorySpace: procedure;
    if additionalMem then       /* do we need to spool the fixups */
    do;
        yyabs.buffer = cmdLineP + 1;                /* allocate the yFile buffers */
        yyprog.buffer = yyabs.buffer + yyabs.len;
        yydata.buffer = yyprog.buffer + yyprog.len;
        yycomm.buffer = yydata.buffer + yydata.len;
    end;
    xxabs.endAddr = bufSizes(ASEG) - 1;             /* set the xFile lengths and and endAddr */
    xxabs.len = bufSizes(ASEG);
    if additionalMem then                           /* check where buffer is */
        xxabs.buf = yycomm.buffer + yycomm.len;     /* follows on from yycomm.buffer if yFiles used */
    else
        xxabs.buf = cmdLineP + 1;                   /* else uses space after cmdLine */

    xxprog.endAddr = bufSizes(CSEG) - 1;            /* set the buf, len and endAddr info for rest of xFiles */
    xxprog.len = bufSizes(CSEG);
    xxprog.buf = xxabs.buf + bufSizes(ASEG);
    xxdata.endAddr = bufSizes(DSEG) - 1;
    xxdata.len = bufSizes(DSEG);
    xxdata.buf = xxprog.buf + bufSizes(CSEG);
    xxcomm.endAddr = bufSizes(COMMON) - 1;
    xxcomm.len = bufSizes(COMMON);
    xxcomm.buf = xxdata.buf + bufSizes(DSEG);
end;

/* clear the all the xFile buffers */
ClrXFileBuffers: procedure;
    do curSeg = ASEG to COMMON;
        call SelectXFile(xFileTable(curSeg));
        call ClearTmpBuf;
    end;
end;

/* intialise the drive for all scratch files */
SetDrives: procedure;
    xxabs.fcb(FCB$DR), xxprog.fcb(FCB$DR), xxdata.fcb(FCB$DR), xxcomm.fcb(FCB$DR),
    yyabs.fcb(FCB$DR), yyprog.fcb(FCB$DR), yydata.fcb(FCB$DR), yycomm.fcb(FCB$DR) = intermediateDrive;
end;

/* setup up the linker defaults */
InitLinker: procedure;
    dataOrgRequest = FALSE;                 /* data and prog orgs at 0 */
    progOrgRequest = FALSE;
    startLabelRequest = FALSE;              /* no start address */
    curFileLoadAddress = 100h;              /* CPM .COM files start at 100h */
    MPMMemSize = 0;                         /* no MPM memory */
    outType = COM$EXT;                      /* creating .COM */
    noLeadingQ = TRUE;                      /* ?labels not allowed */
    libDrive, symDrive, dstDrive = 0;       /* default drive */
    charOutDev = 'X';                       /* to console */
end;



InitOverlay: procedure;

    /* reset all tracking data */
    curLoc(ASEG), curLoc(CSEG), curLoc(DSEG), curLoc(COMMON) = 0;                   /* current location */
    curBase(ASEG), curBase(CSEG), curBase(DSEG), curBase(COMMON) = 0;               /* base offset of this module */
    modLengths(ASEG), modLengths(CSEG), modLengths(DSEG), modLengths(COMMON) = 0;   /* length of this module*/
    starts(ASEG), starts(CSEG), starts(DSEG), starts(COMMON) = 0;                   /* start of segment */
    fixupHeadP(ASEG), fixupHeadP(CSEG), fixupHeadP(DSEG), fixupHeadP(COMMON) = 0;           /* symbols for this seg */

    segOrder(ASEG) = 0;             /* normal segment order */
    segOrder(CSEG) = CSEG;
    segOrder(DSEG) = DSEG;
    segOrder(COMMON) = COMMON;

    botFixup = topMemory;           /* base of fixup locations */
    progOrgRequest, dataOrgRequest, startLabelRequest, transferFlag = FALSE;
    lowAbs = 0ffffh;                /* no ABS data yet */
    highAbs  = 0;
    call ClrXFileBuffers;           /* no loaded data yet */
    lowMarkFixup = 0ffffh;          /* reset the low point of memory used for fixups */
    yyabs.bufIdx, yyprog.bufIdx, yydata.bufIdx, yycomm.bufIdx = 0;                  /* reset yFiles */
    xxabs.startAddr, xxprog.startAddr, xxdata.startAddr, xxcomm.startAddr = 0;      /* reset xFiles */
    xxabs.endAddr = bufSizes(ASEG) - 1;
    xxprog.endAddr = bufSizes(CSEG) - 1;
    xxdata.endAddr = bufSizes(DSEG) - 1;
    xxcomm.endAddr = bufSizes(COMMON) - 1;
    xxabs.curBlk, xxprog.curBlk, xxdata.curBlk, xxcomm.curBlk = 1;
    xxabs.lastDiskBlk, xxprog.lastDiskBlk, xxdata.lastDiskBlk, xxcomm.lastDiskBlk = 0;
end;


/* get the base of current symbol table */
GetSymbolBase: procedure pointer public;
    if overlayCnt = 0 then
        return symTableP;
    return overlayTable(overlayCnt - 1).symP;
end;

/* remove all symbols added for the just released overlay */
RemoveOverlaySymbols: procedure(ptr);
    declare ptr pointer;
    declare i byte;

    do i = 0 to 127;
        do while hashTable(i) >= ptr;
            symP = hashTable(i);
            hashTable(i) = GetChain;
        end;
    end;
end;



/* mark where this overlay symbol table and load address are */
SetOverlayBase: procedure;
    overlayTable(overlayCnt).symP = topSymTable;
    curFileLoadAddress, overlayTable(overlayCnt).curFileLoadAddress = (curAddr + 127) and 0ff80h;
end;

/* allocate next overlay */
EnterOverlay: procedure;
    if (overlayCnt := overlayCnt + 1) > 5 then
        call CmdLineError;
end;

/* remove the top overlay and restore environment to previous overlay */
LeaveOverlay: procedure;
    if (overlayCnt := overlayCnt - 1) = 255 then
        call CmdLineError;
    if not build then
        return;
    curFileLoadAddress = overlayTable(overlayCnt).curFileLoadAddress;     /* restore the previous overlay */
    topSymTable = overlayTable(overlayCnt).symP;
    call RemoveOverlaySymbols(topSymTable);                 /* and remove all those defined later */
end;


SetupOverlay: procedure;

    haveOverlays = TRUE;                                /* record we have overlays */
    if build then                                       /* initialise if building */
       call InitOverlay; 

    call ParseFileAndOptions;                           /* get the file to load */
    call move(12, .fcb1, .targetFile);                  /* save as the image file name */
    if targetFile(FCB$EXT) = ' ' then                   /* target has default .OVL extent */ 
        call move(3, .('OVL'), .targetFile(FCB$EXT));
    if build then                                       /* report progress */
    do;
        call PutStr(.(CR,LF,CR,LF,'LINKING $'));
        call PutFn(.targetFile);
        call PutStr(.(CR,LF,'$'));
    end;
    if cmdCh = '=' then                                 /* if = then get first file */
        call ParseFileAndOptions;
    if build then                                       /* load it if build */
        call LoadFile;

    do while cmdCh <> '(' and cmdCh <> ')';             /* while not ) or nested (..) */
        if cmdCh <> ',' then                            /* files are separated by , */
            call CmdLineError;
        call ParseFileAndOptions;                       /* get next file */
        if build then
            call LoadFile;
    end;
    if build then
    do;
        call DoLibRequests;                             /* resolve outstanding lib requests */
        call AddOverlayThunks;
        outType = OVL$EXT;                              /* set output to .OVL */
        call FinalseImage;                              /* create the file */
        call SetOverlayBase;                            /* mark where next overlay begins */
    end;
end;

ParseCmdLine: procedure;

    cmdLineP = .cmdLineBuffer;          /* reset to start of cmdline */
    call ParseFileAndOptions;           /* get the target file */
    call move(12, .fcb1, .targetFile);  /* save in targetFile */
    if cmdCh = '=' then                 /* did we have = */
        call ParseFileAndOptions;       /* get first file, target may have explicit extent */
    else
        call move(3, .('   '), .targetFile(FCB$EXT));   /* options decide ext later */

    if build then                       /* process the file */
        call LoadFile;

    do while cmdCh <> 0 and cmdCh <> '('; /* handle additional files */
        if cmdCh <> ',' then            /* files must be , separated */
            call CmdLineError;
        call ParseFileAndOptions;       /* get the next file */
        if build then                   /* process if build */
            call LoadFile;
    end;

    rootDstDrive = dstDrive;
    if build then
    do;
        if haveOverlays then        
            call RequireOvlayHandler;
        call DoLibRequests;             /* process all of the lib requests */
        call Process$FPBNX;
        if haveOverlays then
            call AddOverlayThunks;

        if outType = RSP$EXT or outType = SPR$EXT then /* RSP & SPR have 0 load address */
            curFileLoadAddress = 0;

        call FinalseImage;              /* finish off */
        baseOutType = outType;
        imageBase = curFileLoadAddress; /* set where overlays can start */
        call SetOverlayBase;            /* record symbol & overlay base info */
    end;

    if cmdCh = '(' then                 /* overlays ? */
        do while cmdCh <> 0;            /* continue to end of cmd line */
            call EnterOverlay;          /* start the overlay */
            call SetupOverlay;
            do while cmdCh = ')';       /* end of this overlay ? */
                call LeaveOverlay;
                call GetNextNonBlankChar;   /* allow blanks between */
            end;
            if cmdCh <> 0 and cmdCh <> '(' then /* only another overlay or eol here */
                call CmdLineError;
        end;
    if overlayCnt <> 0 then             /* error unbalanced overlay definition */
        call CmdLineError;
end;


/* prompt for and collect another line of the cmdline */
GetExtraCmdLine: procedure;
    
    call PutCh('*');
    cmdLin(0) = 126;                    /* init for 126 chars */
    call CRdStr(.cmdLin);               /* using the CPM read str call */
    cmdLin(cmdLin(1) + 2) = 0;          /* flag end with a null */
x:                                      /* force specific code generation */
                                        /* append to existing cmdline buffer */
    call move(cmdLin(1) + 1, .cmdLin(2), cmdLineP + 1);
    call PutCh(CR);                     /* echo CR LF to the user */
    call PutCh(LF);
end;

/* build the full command line */
BuildCmdLine: procedure;

    cmdLineP = .cmdLineBuffer + 1;      /* set start pointer (1 after the length byte) */
    call move(128, .cmdLin, .cmdLineBuffer);    /* init with the invocation line */

    do while cmdCh <> 0;                /* scan looking for & or end (0) */
        if cmdCh = '&' then
            call GetExtraCmdLine;       /* & so user needs to enter rest of cmdline */
        cmdLineP = cmdLineP + 1;
    end;
end;


main:
    call PutStr(.banner(1));        /* simple banner to the console */ 
    call BuildCmdLine;              /* collect the extended command line */
    build = FALSE;                  /* initial pass to check cmdline syntax */
    call ParseCmdLine;
    /* overlays only supported for .COM files */
    if outType <> COM$EXT and haveOverlays then
        call CmdLineError;

    call InitLinker;
    if additionalMem then           /* additional mem requested so allocate overflow buffers */
    do;
        wbufSizes(CSEG), wbufSizes(DSEG) = 1024;
        wbufSizes(ASEG), wbufSizes(COMMON) = 256;
    end;

    call SetMemorySpace;
    wordP = 6;                      /* point to location with base of CPM */
    topMemory, botFixup = wordVal;  /* and use all memory up to it */

    if intermediateDrive <> 0 then  /* drive specified so apply */
        call SetDrives;

    call GetSerial;                 /* guess but seems to pick up OS serial number */
    topSymTable, symTableP = xxcomm.buf + bufSizes(COMMON);  /* set start of symbol table */
    if symTableP >= botFixup then   /* oops not enough memory */
        call Fatal(.aInsufficientMemory);

    freeMem = botFixup - topSymTable;   /* determine how much memory we have */
    call ClrXFileBuffers;           /* clear the output files */
    build = TRUE;
    call ParseCmdLine;              /* process the files */
    call EndFileProcessing;         /* finalise files and cleanup */
    if haveOverlays then
        call TellTopModule;

    call OS;
end;

link0.plm
link0: do;
$include(link0.ipx)

declare delims(*) byte data(CR, ' =.:<>[],()');
declare curChar byte;

ToUpper: procedure(ch) byte;        /* make char upper case */
    declare ch byte;

    if ch < ' ' then
        return CR;
    if (ch - 'a') <= 19h then
        ch = ch and 5fh;
    return ch;
end;

CmdLineError: procedure public;     /* print the command line */
    declare chP pointer;
    declare ch based chP byte;

    chP = .cmdLineBuffer + 2;       /* skip buf size / line length bytes */

    do while chP <= cmdLineP;
        call PutCh(ToUpper(ch));
        if ch = '&' then            /* & has cr/lf * */
        do;
            call PutCh(CR);
            call PutCh(LF);
            call PutCh('*');
        end;
        chP = chP + 1;
    end;
    call Fatal(.('?$'));            /* exit */
end;

/* return if curChar is a delimiter */
CheckDelim: procedure bool;
    declare i byte;

    do i = 0 to last(delims);
        if curChar = delims(i) then
            return TRUE;
    end;
    return FALSE;
end;

GetNextChar: procedure;             /* pick next char from cmdline, slip &s */
    do while (1);    
        cmdLineP = cmdLineP + 1;
        if (curChar := ToUpper(cmdCh)) <> '&' then
            return;
    end; 
end; 

GetNextNonBlankChar: procedure public;

    call GetNextChar;
    do while curChar = ' ';
        call GetNextChar;
    end;
end;

/* parse file from command line */
ParseFile: procedure word;
    declare (junk, i) byte;

    SaveFCBCh: procedure;           /* copy the char into the fcb */
        fcb1(i := i + 1) = curChar;
    end;

    curChar = ' ';
    i = 0;
    junk = 0ffh;

    do while i < 15;
        if i = 11 then              /* blank name and clear ex etc. */
            curChar = 0;
        call SaveFCBCh;
    end;

    fcb1(FCB$DR) = 0;               /* assume default drive */
    
    do while (TRUE);
        call GetNextNonBlankChar;
        if CheckDelim then          /* no name */
            return 0ffffh;
        i = 0;
        do while not CheckDelim;    /* at most 8 chars for name */
            if i >= 8 then
                return 0ffffh;
            call SaveFCBCh;
            call GetNextChar;
        end;
        if curChar = ':' then       /* was it a : */
        do;
            if not (fcb1(FCB$DR) = 0 and i = 1) then
                return 0ffffh;      /* ok if no previous drive and only 1 char */

            if (fcb1(FCB$DR) := (fcb1(FCB$NAME) - 'A') + 1) > 26 then   /* A-Z only */
                return 0ffffh;
            else
                fcb1(i) = ' ';      /* blank out the stored char */
        end;
        else
        do;
            i = 8;                  /* get the ext */
            if curChar = '.' then
            do;
                call GetNextChar;
                do while not CheckDelim;
                    if i >= 11 then /* more than 3 char ext */
                        return 0ffffh;
                    call SaveFCBCh;
                    call GetNextChar;
                end;
            end;
            return 0;               /* return 0 */
        end;
    end;
end;


/* returns TRUE if curChar is hex char. Also converts curChar to hex value */
IsHexChar: procedure bool;
    if (curChar - '0') <= 9 then
    do;
        curChar = curChar - '0';
        return TRUE;
    end;
    else if (curChar - 'A') <= 5 then
    do;
        curChar = (curChar - 'A') + 10;  
        return TRUE;
    end;
    return FALSE;
end;

/* parses a hex value from teh command line. Returns the value */
ParseHex: procedure word;
    declare result word;

    result = 0;
    call GetNextChar;

    do while not CheckDelim;
        if IsHexChar then
            result = result * 16 + curChar;
        else
            call CmdLineError;
        call GetNextChar;
    end;
    return result;
end;

/* returns TRUE curChar is A-P i.e. valid drive letter */
IsValidDrive: procedure bool;
    return (curChar - 'A') <= 15;
end;

/* checks for valid drive */
/* returns drive 1-16 or errors */
GetDrive: procedure byte;
    call GetNextChar;
    if IsValidDrive then
        return (curChar - 'A') + 1;
    call CmdLineError;
end;

/* checks for valid drive or Z (NULL) */
/* returns drive mapped to 1-16, Z unchanged or errors */
GetDriveOrZ: procedure byte;
    call GetNextChar;
    if IsValidDrive then
        return (curChar - 'A') + 1; 
    if curChar = 'Z' then
        return 'Z';
    call CmdLineError;
end;

/* checks for X, Y or Z drive */
/* returns the letter or errors */
GetXYZ: procedure byte;
    call GetNextChar;
    if curChar - 'X' <= 2 then
        return curChar;
    call CmdLineError;
end;

/* parse simple option list. finish on ] or cr */
ParseOption: procedure;
    do while curChar  <> ']' and curChar <> CR;
        call GetNextNonBlankChar;
        if curChar = 'S' then
        do;
            librarySearch = TRUE;
            call GetNextChar;
        end;
        else if curChar = 'B' then
        do;
            biosLink = TRUE;
            outType = SPR$EXT;
            call GetNextChar;
        end;
        else if curChar = 'P' then
        do;
            progOrgRequest = TRUE;
            progOrigin = ParseHex;
        end;
        else if curChar = 'D' then
        do;
            dataOrgRequest = TRUE;
            dataOrigin = ParseHex;
        end;
        else if curChar = 'L' then
            curFileLoadAddress = ParseHex;
        else if curChar = 'M' then
            MPMMemSize = ParseHex;
        else if curChar = 'O' then
        do;
            call GetNextChar;
            if curChar = 'P' then
                outType = PRL$EXT;    /* .PRL */
            else if curChar = 'C' then
                outType = COM$EXT;    /* .COM */
            else if curChar = 'R' then
                outType = RSP$EXT;    /* .RSP */
            else if curChar = 'S' then
                outType = SPR$EXT;    /* .SPR */
            else
                call CmdLineError;
            call GetNextChar;
        end;
        else if curChar = 'A' then
        do;
            additionalMem = TRUE;
            call GetNextChar;
        end;
        else if curChar = 'Q' then
        do;
            noLeadingQ = FALSE;
            call GetNextChar;
        end;
        else if curChar = 'G' then
        do;
            startLabelRequest = TRUE;
            call GetNextChar;
            startSymLen = 0;
            do while not CheckDelim;
                if startSymLen > 5 then
                    call CmdLineError;
                startSym(startSymLen) = curChar;
                startSymLen = startSymLen + 1;
                call GetNextChar;
            end;
        end;
        else if curChar = '$' then
        do;
            call GetNextNonBlankChar;
            do while curChar <> ',' and curChar <> ']';
                if curChar = 'C' then
                    charOutDev = GetXYZ;
                else if curChar  = 'I' then
                    intermediateDrive = GetDrive;
                else if curChar = 'L' then
                    libDrive = GetDrive;
                else if curChar = 'O' then
                    dstDrive = GetDriveOrZ;
                else if curChar = 'S' then
                    symDrive = GetDriveOrZ;
                else
                    call CmdLineError;
                Call GetNextNonBlankChar;
            end;
        end;
        else if curChar = 'N' then
        do;
            call GetNextChar;
            if curChar = 'L' then
                charOutDev = 'Z';
            else if curChar = 'R' then
                symDrive = 'Z';
            else
                call CmdLineError;
            call GetNextChar;
        end;
        else
            call CmdLineError;
    end;
    if curChar <> CR then
        call GetNextChar;
end;


ParseFileAndOptions: procedure public;
    librarySearch = FALSE;
    if ParseFile = 0FFFFh then
        call CmdLineError;
    if curChar = ' ' then
        call GetNextNonBlankChar;
    if curChar = '[' then
        call ParseOption;
    if curChar = ' ' then
        call GetNextNonBlankChar;
end;


RdIndexByte: procedure byte;
    /* load the buffer with the index data if required */
    if (indexIdx := indexIdx + 1) >= indexLen then
    do;
        indexIdx = 0;
        call ReadF(.indexBuf, indexLen, .indexFcb);
    end;
    return indexBuf(indexIdx);          /* return the next index byte */
end;

declare realLoc LOC$T;
declare irlRec word public;
declare rByte byte;

GetModuleLocation: procedure;
    realLoc.ex = baseEx + RdIndexByte;  /* adjust ex to account for where rel starts */
    if (realLoc.rec := baseCr + RdIndexByte) >= 128 then   /* adjust if adjusted cr >= 128 */
    do;
        realLoc.rec = realLoc.rec - 128;
        realLoc.ex = realLoc.ex + 1;
    end;
    realLoc.off = RdIndexByte;          /* offset will be ok as rel located at 128 byte boundary */
end;

/* read symbol from the IRL index */
GetIrlSymbol: procedure;
    call GetModuleLocation;             /* the location where this symbol is */
    bFieldLen = 0;                      /* symbol ends with 0feh */
    do while (rByte := RdIndexByte) < 0feh;
        bFieldName(bFieldLen) = rByte;
x:
        if (bFieldLen := bFieldLen + 1) >= 8 then
            call Fatal(.aIndexError);
    end;
end;

/* seek to where the module starts in the IRL file */
SeekIRL: procedure;
    irlRec = realLoc.ex * 128 + realLoc.rec;
    if relStartRec <= irlRec and irlRec <= relEndRec then   /* already in buffer */
        relIdx = (irlRec - relStartRec) * 128 + realLoc.off - 1;
    else
    do;
        if realLoc.ex <> fcb1(FCB$EX) then  /* different ex so reopen */
        do;    
            fcb1(FCB$EX) = realLoc.ex;
            if Open(.fcb1) = 255 then
                call Fatal(.aIndexError);

            fcb1(FCB$CR) = 0ffh;
        end;
        fcb1(FCB$CR) = realLoc.rec;         /* update the record */
        call RdBuf;                         /* fill the buffer */
        relIdx = double(realLoc.off) - 1;   /* and adjust to start pos in buffer */
    end;
end;

LoadIrlLib: procedure public;
    indexIdx = indexLen;                /* force reload of buffer */
    call GetIrlSymbol;                  /* get a symbol */

    do while bFieldLen > 0;             /* end of list has 0 length */
        loading = FALSE;                /* assume not loading */
        call LinkSetEntry;              /* see if still required */
        if loading then                 /* if so loading is now set */
        do;
            call SeekIRL;               /* seek to the module where the symbol is */
            call LoadOneModule;         /* and load the whole module */
        end;
        call GetIrlSymbol;              /* carry one with the next symbol */
    end;
end;

declare yBufP pointer initial(0);
declare yBuffer based yBufP (1) byte;
declare yFileP pointer public initial(0);
/* yFile needs to be defined here explicitly as PLM complains if defined earlier via include file */
declare yFile based yFileP structure(buffer word, bufIdx word, len word, onDisk bool, fcb(32) byte);

/* write the yFile buffer, create file if needed */
WriteYBlk: procedure;
    if not yFile.onDisk then
    do;
        call CreatF(.yFile.fcb);
        yFile.onDisk = TRUE;
    end;
    call WriteF(yFile.buffer,  yFile.len, .yFile.fcb);
end;

/* write byte to yFile */
WriteYByte: procedure(n);
    declare n byte; 
    
    yBuffer(yFile.bufIdx) = n;
    if (yFile.bufIdx := yFile.bufIdx + 1) >= yFile.len then
    do;
        call WriteYBlk;
        yFile.bufIdx = 0;
    end;  
end;

/* write word to yFile */
WriteYWord: procedure(w);
    declare w word;
    
    call WriteYByte(low(w));
    call WriteYByte(high(w));
end;



/* reload the yFile buffer */
ReadYBlk: procedure;
    call ReadF(yFile.buffer, yFile.len, .yFile.fcb(FCB$DR));
end;


/* read a byte from the current yFile, reload buffer if necessary */

ReadYByte: procedure byte public;

    if (yFile.bufIdx := yFile.bufIdx + 1) >= yFile.len then
    do;
        call ReadYBlk;
        yFile.bufIdx = 0;
    end;
    return yBuffer(yFile.bufIdx);
end;


/* read a word from the current yFile */
ReadYWord: procedure word public;
    return ReadYByte or shl(double(ReadYByte), 8);
end;


/* select the current yFile to use and buffer */
SelectYFile: procedure(fileP) public;
    declare fileP pointer;

    yFileP = fileP;
    yBufP = yFile.buffer;
end;

/* write the end marker to the yFile and rewind */
YRewind: procedure public;
    call WriteYByte(0ffh);          /* write the end marker */
    if yFile.onDisk then            /* check if on disk vs. all in memory */
    do;
        do while yFile.bufIdx <> 0; /* force buffer to write by padding with ^Z */
            call WriteYByte(1ah);
        end;
        call CloseF(.yFile.fcb);    /* close and reopen file */
        call OpenF(.yFile.fcb);
        yFile.bufIdx = yFile.len;   /* force buffer reload */
    end;
    else
        yFile.bufIdx = 0FFFFh;      /* cause ReadYByte to restart the in memory buffer */
end;

/* accessor functions for fixup entry */

GetFixupAddr: procedure word public;
    return fixup.addr;
end;

GetFixupRef: procedure word public;
    return fixup.ref;
end;

GetSegLink: procedure word public;
    return fixup.link;
end;

GetIsChainExt: procedure byte;
    return shr(fixup.control, 2) and 1;
end;

GetHasOffset: procedure byte public;
    return shr(fixup.control, 3) and 1;
end;

GetFixupSeg: procedure byte public;
    return fixup.control and 3;
end;

GetFixupStatus: procedure byte public;
    return fixup.control;
end;

GetFixupOff: procedure word public;
    return fixup.offset;
end;

GetBaseLink: procedure pointer;
    declare insert based insertP FIXUP$T;
    return insert.link; 
end;

SetFixupAddr: procedure(addr);
    declare addr word;
    fixup.addr = addr;
end;

SetFixupRef: procedure(ref) public;
    declare ref word;
    fixup.ref = ref;
end;

SetSegLink: procedure(link);
    declare link pointer;
    fixup.link = link;
end;

SetIsChainExt: procedure(isExt) public;
    declare isExt bool;
    
    fixup.control = (fixup.control and 0fBh) or shl(isExt and 1, 2);
end;

SetHasOffset: procedure(n);
    declare n byte;
    
    fixup.control = (fixup.control and 0f7h) or shl(n and 1, 3);
end;

SetIsMinus: procedure(n);
    declare n byte;

    fixup.control = (fixup.control and 0efh) or shl(n and 1, 4);
end;

SetFixupSeg: procedure(n) public;
    declare n byte;

    fixup.control = (fixup.control and 0fch) or (n and 3);
end;

SetFixupOff: procedure(offset);
    declare offset word;
    fixup.offset = offset;
end;


/* insert the current item at insertP */
InsertInChain: procedure(link);
    declare link word;
    declare insert based insertP FIXUP$T;
    insert.link = link;
end;

declare ChainsAbove word;

/* see if addr is head of a chain. returns TRUE if so */
/* by product sets insertP to where to insert a new chain if not found
   and sets the ChainsAbove */
FindChainHead: procedure(addr, seg) bool public;
    declare addr word, seg byte;
    ChainsAbove = 0;
    if (fixupP := fixupHeadP(seg)) = 0 then /* no chain */
        return FALSE;

    do while GetFixupAddr > addr;            /* loop till found or insert point reached */
        insertP = fixupP;                   
        ChainsAbove = ChainsAbove + 1;            /* count number above */
        if (fixupP := GetSegLink) = 0 then  /* end of segment chain */
            return FALSE;
    end;
    return GetFixupAddr = addr;              /* TRUE if found */
end;


/* create a new fixup record */
AddFixup: procedure(fixupAddr, fixupRef, fixupSeg, isExt, targetSeg, hasOffset, offset, calcChain) public;
    declare (fixupAddr, fixupRef) word;
    declare offset word;
    declare (fixupSeg, targetSeg) byte;
    declare (hasOffset, isExt, calcChain) bool;
    declare itemSize byte;

    if fixupAddr = 0 and targetSeg = 0 then     /* ignore */
        return;

    if hasOffset then
        itemSize = 9;                           /* fixup size with extra word for the +/- offset */
    else
        itemSize = 7;                           /* standard fixup size */

    /* allocate the memory & check for overflow */
    if (botFixup := botFixup - itemSize) < topSymTable then
        call Fatal(.aMemoryOverflow);

    if calcChain then                           /* ext +/- does not do it's own chain length */
        if FindChainHead(fixupAddr, targetSeg) then   /* simple check for items on chain */
            ;
    fixupP = botFixup;                          /* point to new fixup entry */
    fixup.control = 0;                          /* init the control flags */
    call SetFixupAddr(fixupAddr);
    if ChainsAbove = 0 then                     /* no chain or address greater */
        call SetSegLink(fixupHeadP(targetSeg));   /* make this one point to the existing chain */
    else
        call SetSegLink(GetBaseLink);           /* else point to what insertP points to */

    call SetFixupRef(fixupRef);
    if hasOffset then
        call SetFixupOff(offset);

    call SetIsChainExt(isExt);                  /* record the isExt flag (not used) */
    call SetFixupSeg(fixupSeg);                 /* set the fixup segment */
    call SetHasOffset(hasOffset);               /* record the hasOffset and isMinus flags */
    call SetIsMinus(isMinus);
    if ChainsAbove = 0 then                     /* no chain for this segment */
        fixupHeadP(targetSeg) = botFixup;         /* make this the head of the chain */
    else
        call InsertInChain(botFixup);           /* entry at insertP points to this one */
end;


/* reverse the fixup records to allow processing later in address order */
ReverseChain: procedure public;
    declare i byte, (link, head) pointer;
    do i = ASEG to COMMON;                      /* process the 4 segments */
        head = 0;
        fixupP = fixupHeadP(i);                   /* current last record for this segment */

        do while fixupP <> 0;                   /* reverse the chain linkage */
            link = GetSegLink;
            call SetSegLink(head);
            head = fixupP;
            fixupP = link;
        end;
        fixupHeadP(i) = head;                     /* now head is lowest address */
    end;
end;

/* overflow the fixup information to disk (Y files) */
OverflowFixups: procedure public;
    declare i byte;

    call ReverseChain;                          /* put the fixups in address order */
    do i = ASEG to COMMON;
        fixupP = fixupHeadP(i);                   /* get the lowest addressed item */
        call SelectYFile(yFileTable(i));        /* select the overflow file */
        do while fixupP <> 0;                   /* write all fixup records */
            call WriteYByte(GetFixupStatus);    /* status - 1 byte */
            call WriteYWord(GetFixupAddr);      /* fix up address & value */
            call WriteYWord(GetFixupRef);
            if GetHasOffset then                /* if we have an offet */
                call WriteYWord(GetFixupOff);   /* save it as well */
            fixupP = GetSegLink;                /* get next item */
        end;
    end;
    /* all written to overflow files so reset */
    fixupHeadP(ASEG), fixupHeadP(CSEG), fixupHeadP(DSEG), fixupHeadP(COMMON) = 0;
end;
end;
link1.plm
link1: do;
$include(link1.ipx)

declare commLenP pointer;
declare commLen based commLenP word;
declare hashTable(128) pointer public;
declare hashIdx byte;

/*
    symbol information is accessed via sym based symP
    the data for each symbol is
    chain       - address of next entry with this same hash
    iInfo       - RFllllll - R -> Lib request, F -> fixed, llllll length of entry
    val         - value of the symbol or offset into seg
    sInfo       - PSSlllll - E -> public, SS -> segment, lllll length of symbol
    sName(n)    - symbol name, length from sInfo
    [commSize]  - common size optional - located at offset (iInfo llllll field) - 2
*/

/* reset the information fields for the symbol */
ClrInfo: procedure;
    sym.iInfo = 0;
    sym.sInfo = 0;
end;

/* get the chain address for the next symbol */
GetChain: procedure pointer public;
    return sym.chain;
end;

/* set the chain address for the next symbol */
SetChain: procedure(chain);
    declare chain pointer;

    sym.chain = chain;
end;

/* get the symbol's length */
GetSymLength: procedure byte public;
    return sym.sInfo and 1fh;
end;

/* set the symbol's length */
SetSymLength: procedure(len);
    declare len byte;

    sym.sInfo = sym.sInfo or len;
end;

/* get the item length */
GetItemLength: procedure byte public;
    return sym.iInfo and 3fh;
end;

/* record the length of this item */
SetItemLength: procedure(len);
    declare len byte;

    sym.iInfo = sym.iInfo or len;
end;

/* test is symbol is fixed */
GetFixed: procedure byte public;
    return shr(sym.iInfo, 6) and 1;
end;

/* set symbol as fixed */
SetFixed: procedure public;
    sym.iInfo = sym.iInfo or shl(1, 6);
end;

/* test if symbol is a lib request */
GetLibRequest: procedure bool public;
    return shr(sym.iInfo, 7) and 1;
end;

/* mark the symbol as a lib request */
SetLibRequest: procedure public;
    sym.iInfo = sym.iInfo or shl(1, 7);
end;


/* test if symbol is resolved */
GetResolved: procedure byte public;
    return rol(sym.sInfo, 1) and 1;
end;

/* mark the symbol as resolved */
SetResolved: procedure(state) public;
    declare state byte;

    sym.sInfo = (sym.sInfo and 7fh) or shl(state, 7);
end;

/* get the symbol common size */
GetCommonSize: procedure word public;
    commLenP = symP + GetItemLength - 2;  /* last word of item */
    return commLen;
end;

/* set the symbol common size */
SetCommonSize: procedure(len);
    declare len word;

    commLenP = symP + GetItemLength - 2;  /* last word of item */
    commLen = len;
end;

/* get symbol value */
GetVal: procedure word public;
    return sym.val;
end;

/* set symbol value */
SetVal: procedure(val) public;
    declare val word;
    sym.val = val;
end;

/* get the current symbol's segment */
GetSegment: procedure byte public;
    return shr(sym.sInfo, 5) and 3;
end;

/* set the segment for the current symbol */
SetSegment: procedure(seg) public;
    declare seg byte;

    sym.sInfo = (sym.sInfo and 9Fh) or shl(seg and 3, 5);
end;

/* calc the hash of the symbol */
Hash: procedure(nameP, nameLen);
    declare nameP pointer, nameLen byte;
    declare ch based nameP byte;

    hashIdx = 0;
    do while (nameLen := nameLen - 1) <> 0ffh;
        hashIdx = hashIdx + ch;
        nameP = nameP + 1;
    end;
    hashIdx = hashIdx and 7fh;
end;

/* see if lib has been requested */
FindLibRequest: procedure(nameP, nameLen) bool public;
    declare nameP pointer, nameLen byte;

    symP = GetSymbolBase;

    do while symP < topSymTable;
        if GetLibRequest then
            if GetSymLength = nameLen then
                if Strequ(nameP, .sym.sName, nameLen) then
                    return TRUE;
        symP = symP + GetItemLength;    /* next item */
    end;
    /* missing return - likely to return FALSE in a */
end;

/* search for symbol on the chain */
/* the names of COMMON segments are not valid for public/extrn so set includeCommon to FALSE */
SearchSymbol: procedure(nameP, nameLen, includeCommon) bool public;
    declare nameP pointer, nameLen byte, includeCommon bool;

    call Hash(nameP, nameLen);
    symP = hashTable(hashIdx);

    do while symP <> 0;         /* till end of chain */
        if GetSymLength = nameLen then
            if Strequ(nameP, .sym.sName, nameLen) then    /* found */
                /* ignore if COMMON and  not includeCommon */
                if not (GetSegment = COMMON xor includeCommon) then
                    return TRUE;
            symP = GetChain;    /* next item on chain */
    end;
    return FALSE;
end;

/* insert a new symbol */
InsertSymbol: procedure(nameP, nameLen, val, seg, isResolved, isCommon, sizeCommon) public;
    declare nameP pointer, nameLen byte, val word,
            seg byte, isResolved bool, isCommon bool, sizeCommon word;
    declare len byte;

    len = nameLen + 6;                      /* 6 bytes + symbol itself */
    if isCommon then                        /* common has an extra word */
        len = len + 2;
    symP = topSymTable;                     /* add to the top of the symbol fixup */

    topSymTable = topSymTable + len;        /* reserve the space */
    if topSymTable > botFixup then          /* check we are ok */
        call Fatal(.aMemoryOverflow);

    call ClrInfo;                           /* reset the info fields */
    call Hash(nameP, nameLen);              /* hash the symbol */
    call SetChain(hashTable(hashIdx));      /* add to the front of the chain */
    hashTable(hashIdx) = symP;
    call SetItemLength(len);                /* mark the length */
    call SetVal(val);                       /* save the value */
    call SetResolved(isResolved);           /* record whether resolved */
    call SetSymLength(nameLen);             /* now the symbol length */
    call SetSegment(seg);                   /* segment */
    call move(nameLen, nameP, .sym.sName);  /* the name itself */
    if isCommon then                        /* add commonSize if valid */
        call SetCommonSize(sizeCommon);
    if sym.sName(0) = '#' then              /* note if we have special symbol */
        haveSpecialSym = TRUE;
end;
end;
link2.plm
link2: do;
$include(link2.ipx)
declare curCol byte initial(0);
declare fileP word;

declare aModuleTop(*) byte public data(CR, LF, 'MODULE TOP   $');
declare aUndefinedStart(*) byte public data('UNDEFINED START SYMBOL: $');

/* print the char and keep a record of the current column */
PrintChWithCnt: procedure(ch);
    declare ch byte;
    call PutCh(ch);
    curCol = curCol + 1;
end;


/* print hex nibble */
PutHexNibble: procedure(n);
    declare n byte;
    if n <= 9 then
        call PutCh(n + '0');
    else
        call PutCh((n - 10) + 'A');
end;

/* print hex byte */
PutHexByte: procedure(n);
    declare n byte;
    call PutHexNibble(shr(n, 4));
    call PutHexNibble(n and 0fh);
end;

/* print hex word */
PutHexWord: procedure(n);
    declare n word;
    call PutHexByte(shr(n, 8));
    call PutHexByte(n and 0ffh);
end;

/* delete any extension files */
DeleteYFiles: procedure;
    if yyabs.onDisk or yyprog.onDisk or yydata.onDisk or yycomm.onDisk then
    do;
        fcb1(FCB$DR) = yyabs.fcb(FCB$DR);
        call move(11, .('YY????  $$$'), .fcb1(FCB$NAME));
        call Delete(.fcb1);
        yyabs.onDisk = FALSE;
        yyprog.onDisk = FALSE;
        yydata.onDisk = FALSE;
        yycomm.onDisk = FALSE;
    end;
end;

/* delete any temp files */
DeleteXFiles: procedure;
    declare i byte, haveFiles bool;

    declare file based fileP XFILE$T;
    haveFiles = FALSE;
    do i = ASEG to COMMON;
        fileP = xFileTable(i);
        if file.onDisk then                 /* is file written */
        do;
            call CloseF(.file.fcb);         /* close the file */
            file.onDisk = FALSE;
            haveFiles =  TRUE;              /* will need to delete */
        end;
    end;
    if haveFiles then
    do;
        fcb1(FCB$DR) = xxabs.fcb(FCB$DR);   /* get the drive */
        call move(11, .('XX????  $$$'), .fcb1(FCB$NAME));   /* copy wildcard for delete */
        call Delete(.fcb1);
    end;
end;

/* see if we need a jmp to start at the beginning of the image */
CheckLoadAddresses: procedure;
    /* see if we need jmp to start at the beginning */
    if curFileLoadAddress + 3 > dataOrigin and dataOrgRequest then
        initialJmp = FALSE;                 /* no could clash with data */
    else if curFileLoadAddress + 3 > progOrigin and progOrgRequest then
        initialJmp = FALSE;                 /* no could clash with prog */
    else if curFileLoadAddress + 3 > lowAbs then
        initialJmp = FALSE;                 /* no could clash with abs data */
    else if transferFlag then               /* no need if start at beginning of CSEG */
        if transferAddr = 0 and transferSeg = CSEG and not progOrgRequest then
            initialJmp = FALSE;
        else
            initialJmp = TRUE;  /* yes we need a jump */
    else  if progOrgRequest or startLabelRequest  then
        initialJmp = TRUE;      /* yes jmp to progOrg or label */
    else
        initialJmp = FALSE;
end;

/* locate the segments */
SetupSegments: procedure;
    if progOrgRequest then                  /* explicit CSEG */
        starts(CSEG) = progOrigin;
    else if initialJmp then                 /* initial jmp needed */
        starts(CSEG) = curFileLoadAddress + 3;
    else
        starts(CSEG) = curFileLoadAddress;  /* else at the given load address */

    if dataOrgRequest then                  /* common stats at data org */
        starts(COMMON) = dataOrigin;
    else
    do;                                     /* else after CSEG */
        starts(COMMON) = starts(CSEG) + curBase(CSEG);
        if biosLink then                    /* if biosLink then align to page */
            starts(COMMON) = (starts(COMMON) + 0ffh) and 0ff00h;
    end;

    starts(DSEG) =  starts(COMMON) + curBase(COMMON);   /* DSEG after COMMON */
    if lowAbs < highAbs then                /* we have ASEG set curLoc end of mem needed */
        curLoc(ASEG) = highAbs - lowAbs + 1;
    else
        curLoc(ASEG) =  0;                  /* ASEG size = 0 */
end;


/* order the segments to reflect the image order */
OrderSegments: procedure;
    declare i byte;

    /* swap the current segment to be in the right
       order vs. all those processed before */
    OrderSegment:  procedure;
        declare (j, k, m, n) byte;
        j = numSegs;
        k = 0;
        m = i;

        do while (j := j - 1) <> 0ffh;
            if starts(m) < starts(segOrder(k)) then
            do;
                n = segOrder(k);
                segOrder(k) = m;
                m = n;
            end;
            k = k + 1;
        end;
        segOrder(k) = m;
        numSegs = numSegs + 1; 
    end;

    numSegs = 0;
    starts(ASEG) = lowAbs;                  /* ASEG buffer starts at lowAbs */
    do i = ASEG to COMMON;
        if curLoc(i) > 0 then               /* sort if seg exists */
            call OrderSegment;
    end;
    starts(ASEG) =  0;
end;




declare fixupTarget word, fixupSeg byte;
declare fixupStatus byte, (fixupAddr, fixupRef, fixupOff) word;

/* finalise the symbol values if not already done */
FixSymbolValues: procedure;

    symP = symTableP;                       /* scan the whole symbol table */
    do while symP < topSymTable;
        if not GetFixed and (GetResolved or haveOverlays) then
        do;
            call SetVal(GetVal + starts(GetSegment));   /* fix the location */
            call SetFixed;
        end;
        symP = symP + GetItemLength;        /* next item */
    end;
end;


/* process all of the fixups on the final segments with known addresses */
FixupImage: procedure;
    StoreFixup: procedure(fixup, target);   /* store the fixuped with absolute value */
        declare (fixup, target) word;

        call StoreByteInSeg(fixup, low(target));
        call StoreByteInSeg(fixup + 1, high(target));
    end;

    /* set the symbol address based at ptr */
    GetRefVal: procedure(ptr) word;
        declare ptr pointer;
        symP = ptr;
        return GetVal;
    end;

    FixupLocation: procedure;
        fixupSeg = fixupStatus and 3;
        if (fixupStatus and 4) > 0 then         /* is external */
            fixupTarget = GetRefVal(fixupRef);  /* look up symbol */
        else
            fixupTarget = starts(fixupSeg) + fixupRef;  /* is rel to start of seg */

        if (fixupStatus and 8) > 0 then         /* has offset */
            if (fixupStatus and 10h) > 0 then   /* is minus so can be another segment */
                fixupTarget = (fixupTarget - fixupOff) - starts(GetSegment);
            else
                fixupTarget = fixupTarget + fixupOff;   /* plus must be same segment */
        call StoreFixup(fixupAddr, fixupTarget);
    end;

    /* fixup the image */
    do curSeg = ASEG to COMMON;
        call SelectXFile(xFileTable(curSeg));   /* select the segment */
        if additionalMem then                   /* load in the fixups if spooled */
        do;
            call SelectYFile(yFileTable(curSeg));   /* rewind the Y file */
            call YRewind;
            fixupStatus = ReadYByte;
            do while fixupStatus <> 0ffh;

                fixupAddr = ReadYWord;
                fixupRef = ReadYWord;
                if (fixupStatus and 8) > 0 then /* has offset */
                    fixupOff = ReadYWord;
                call FixupLocation;
                fixupStatus = ReadYByte;        /* next item */
            end;
        end;
        else
        do;
            fixupP = fixupHeadP(curSeg);          /* chase down the linked symbols */

            do while fixupP <> 0;
                fixupStatus = GetFixupStatus;
                fixupAddr = GetFixupAddr;
                fixupRef = GetFixupRef;
                if GetHasOffset then
                    fixupOff = GetFixupOff;
                call FixupLocation;
                fixupP = GetSegLink;            /* get the next one */
            end;
        end;
    end;
end;




/* check if symbol has an valid name and if local i.e. starts with ? then this is to be included */
TestValidSymbol: procedure byte public;
    return sym.sName(0) <> 0 and not (sym.sName(0) = qMark and noLeadingQ);
end;

/* print the symbols to the user */
PrintSymbols: procedure;
    declare i byte, showUndefMsg bool, cnt word;

    TabTo: procedure(col);                  /* tab to specific column to allow multiple columns */
        declare col byte;

        do while curCol < col;
            call PrintChWithCnt(' ');
        end;
    end;

    PrintCurSymbol: procedure;              /* print the symbol name */
        do i = 1 to GetSymLength;
            call PrintChWithCnt(sym.sName(i - 1));
        end;
    end;

    cnt =  0;                               /* count of symbols to identify column */
    symP = GetSymbolBase;
    do while symP < topSymTable;
        if GetResolved and TestValidSymbol then /* resolved symbol and vaild */
        do;
            if (cnt and 3) = 0 then         /* 4 symbols per line */
            do;
                call NewLn;
                curCol = 0;
            end;
            if GetSegment = COMMON then     /* if common then surround in // */
                call PrintChWithCnt('/');

            call PrintCurSymbol;
            if GetSegment = COMMON then
                call PrintChWithCnt('/');

            call TabTo((cnt and 3) * 12 + 9);   /* next column position of value */
            if GetLibRequest then           /* if libRequest use RQST */
                call PutStr(.('RQST$'));
            else
                call PutHexWord(GetVal);    /* else print address */

            call PrintChWithCnt(' ');
            call PrintChWithCnt(' ');
            call PrintChWithCnt(' ');
            cnt = cnt + 1;
        end;
        symP = symP + GetItemLength;        /* next item */
    end;

    if cnt > 0 then                         /* finish off line if needed */
        call NewLn;

    /* now check for undefined symbols */
    showUndefMsg = TRUE;
    cnt, curCol = 0;
    symP = GetSymbolBase;

    /* now print out the undefined symbols */
    do while symP < topSymTable;
        if not GetResolved then
        do;                                 /* we have an undefined symbol */
            if showUndefMsg then            /* show the undefined symbols message once */
            do;
                showUndefMsg = FALSE;
                call PutStr(.(CR, LF, 'UNDEFINED SYMBOLS:', CR, LF, '$'));
            end;

            if (cnt and 7) = 0 then         /* 8 symbols per line */
            do;
                call NewLn;                 /* new line and reset curCol */
                curCol = 0;
            end;

            call PrintCurSymbol;            /* print symbol */
            call TabTo(((cnt := cnt + 1) and 7) * 8);
        end;
        symP = symP + GetItemLength;        /* next item */
    end;

    if cnt >  0 then                        /* finish off line if needed */
        call NewLn;
    call NewLn;
end;



/* determine the best start address */
CalcStartAddr: procedure;
    declare i byte;
    if startLabelRequest then               /* we have a label in the rel file */
    do;
        if SearchSymbol(.startSym, startSymLen, FALSE) then
            startSymAddr = GetVal;
        else
        do;
            startSymAddr =  0;
            call PutStr(.aUndefinedStart);
            do i = 1 to startSymLen;
                call PutCh(startSym(i - 1));
            end;
            call NewLn;
        end;
    end;
    else if transferFlag then               /* we had a user specified transfer address */
        startSymAddr = starts(transferSeg) + transferAddr;
    else if curLoc(CSEG) > 0 then           /* we have CSEG so use start of if */
        startSymAddr = starts(CSEG);
    else if lowAbs <> 0ffffh then           /* we have a low ASEG address so use it */
        startSymAddr = lowAbs;
end;

/* print a usage summary for the user */
PrintStats: procedure;

    /* print len (start-end) information */
    PrintHexValues: procedure(len, start);
        declare (len, start) word;

        call PutHexWord(len);
        if  len = 0 then                    /* no start */
            return;
        call PutCh(' ');
        call PutCh('(');
        call PutHexWord(start);             /* show address range */
        call PutCh('-');
        call PutHexWord(start + len - 1);
        call PutCh(')');
    end;


    /* absolute - may be empty */
    call PutStr(.('ABSOLUTE     $'));
    if lowAbs <= highAbs then
        call PrintHexValues(highAbs - lowAbs + 1, lowAbs);
    else
        call PrintHexValues(0, 0);

    call NewLn;
    call PutStr(.('CODE SIZE    $'));
    call PrintHexValues(curBase(CSEG), starts(CSEG));
    call NewLn;
    call PutStr(.('DATA SIZE    $'));
    call PrintHexValues(curBase(DSEG), starts(DSEG));
    call NewLn;
    call PutStr(.('COMMON SIZE  $'));
    call PrintHexValues(curBase(COMMON), starts(COMMON));
    call NewLn;
    call PutStr(.('USE FACTOR     $'));
    /* indicator of memory usage */
    call PutHexByte((freeMem - (lowMarkFixup - topSymTable)) / (high(freeMem) + 1));
    call NewLn;
end;




/* print out the module top information for the user */
TellTopModule: procedure public;
    call PutStr(.aModuleTop);
    call PutHexWord(endMem);
    call NewLn;
end;



/* all the files are loaded so now finish off the link and write the image / sym files */
FinalseImage: procedure public;

    call CheckLoadAddresses;    /* check if we need jmp start */
    call SetupSegments;         /* initialise segment base addresses */
    call OrderSegments;         /* set order of segments to write */
    call FixSymbolValues;       /* fix symbol locations */
    call CalcStartAddr;         /* determine start address */
    call ReverseChain;          /* put fixups in address order */
    call FixupImage;            /* write segments to disk */
    if charOutDev <> 'Z' then   /* skip if null output */
        call PrintSymbols;

    call PrintStats;            /* give a stats summary */
    call GenerateImage;         /* close file */
    if additionalMem then       /* delete any overflow files */
        call DeleteYFiles;

    if symDrive <> 'Z' then     /* write symbols if not null output */
        call WriteSymFile;
    call DeleteXFiles;          /* delete any segment temp files */
end;
end;
link3.plm
link3: do;
$include(link3.ipx)

declare hasAseg byte initial(0);
declare isMinus bool public initial(FALSE);
declare aIndexError(*) byte public initial('INDEX ERROR$');
declare aMultipleDefinition(*) byte initial('MULTIPLE DEFINITION: $');
declare aMainModuleError(*) byte initial('MAIN MODULE ERROR$');
declare aFirstCommonNot(*) byte initial('FIRST COMMON NOT LARGEST$');
declare aCommonError(*) byte initial('COMMON ERROR$');
declare aUnrecognizedIt(*) byte initial('UNRECOGNIZED ITEM', CR, LF,'$');

/* read 16 bits from the rel file */
Read16bit: procedure word;
    return RdBits(8) or shl(double(RdBits(8)), 8);
end;


/* print symbol */
PrintSymbol: procedure;
    declare i byte;
 
    if bFieldLen > 0 then
        do i = 1 to bFieldLen;
            call PutCh(bField((i-1) + 1));
        end;
end;


/* read A field */
ReadAField: procedure;
    aFieldSeg = RdBits(2);      /* 2 bit segment */
    aFieldAddr = Read16bit;     /* read the address */
end;

/* read B field */
ReadBField: procedure;
    declare i byte;
    bFieldLen = RdBits(3);      /* get length */
    if bFieldLen = 0 then       /* 0 maps to 8 */
        bFieldLen = 8;

    do i = 1 to bFieldLen;      /* get the name */
        bFieldName(i-1) = RdBits(8) and 7fh;
    end;
end;


/* refill the rel input buffer */
RdBuf: procedure public;
    relStartRec = fcb1(FCB$EX) * 128 + fcb1(FCB$CR);
    relEndRec = relStartRec + ReadFR(.relBuf, relLen, .fcb1) - 1;
end;

/* make sure the correct file and seg are selected */
SelectSegment: procedure(seg) public;
    declare seg byte;
    curSeg = seg;
    call SelectXfile(xFileTable(curSeg));
end;

/* save a const byte in the current segment */
SaveConstByte: procedure(n) public;
    declare n byte;

    if curSeg = COMMON and curCommonIsFixed then    /* already done */
        return;
    call StoreByteInSeg(curLoc(curSeg), n); /* save the byte */
    if curSeg = ASEG then                   /* update bounds for ASEG data */
    do;
        if curLoc(ASEG) > highAbs then
            highAbs = curLoc(ASEG);
        if curLoc(ASEG) < lowAbs then
            lowAbs = curLoc(ASEG);
    end;
    curLoc(curSeg) = curLoc(curSeg) + 1;    /* update the location counter */
end;

/* look for any chain refering to this address and adjust the addreses to refer to it */
AdjustChain: procedure(ref, isExt);
    declare ref word, isExt bool;
    declare seg byte, (addr, chainRef) word;

    LoadWordFromSegment: procedure word;    /* pick up address from seg */
        declare val16 word, tmpSeg byte;

        tmpSeg = curSeg;                    /* save the current seg */
        call Selectsegment(seg);            /* get the word at the fixup location */
        val16 = LoadByteFromSeg(addr) or shl(double(LoadByteFromSeg(addr + 1)), 8);
        call Selectsegment(tmpSeg);         /* back to current seg */
        return val16;                       /* return the contents of the fixup location */
    end;

    addr = aFieldAddr + curBase(seg := aFieldSeg);  /* adjusted addr to take account of base */

    do while true;
        do while FindChainHead(addr, seg);  /* see if there is chain for this location */
            chainRef = GetFixupRef;         /* find the location and seg */
            seg = GetFixupSeg;
            if seg = ASEG and chainRef = 0 then   /* this is a fixup in ASEG */
                addr = LoadWordFromSegment; /* pick up the address */
            else
                addr = chainRef;            /* else use the ref */
            
            call SetFixupRef(ref);          /* update the ref to point here */
            call SetIsChainExt(isExt);      /* set whether still external ref */
            if isExt = FALSE then
                call SetFixupSeg(curSeg);   /* update seg if not ext ref */
        end;
        call AddFixup(addr, ref, curSeg, isExt, seg, FALSE, 0, FALSE);
        if hasAseg then
        do;
            if (chainRef := LoadWordFromSegment) = 0 then    /* 0 is end of list */
                return;
            else
            do;                             /* check for fixup in ASEG */
                addr = chainRef;
                seg = ASEG;
            end;
        end;
        else                                /* no ASEG so all done */
            return;
    end;
end;


/* remove # symbols from the symbol table */
ClearSpecialSymbols: procedure;
    symP = symTableP;
    do while symP < topSymTable;
        if sym.sName(0) = '#' then      /* special symbols start with # */
            sym.sName(0) = 0;           /* zero out the name */
        symP = symP + GetItemLength;    /* next item */
    end;
    haveSpecialSym = FALSE;
end;

/* process the PUBLIC declaration - i.e. include module if it resolves an extrn ref */
LinkSetEntry: procedure public;
    if SearchSymbol(.bFieldName, bFieldLen, FALSE) then
        if not GetResolved then         /* was previously unresolved so load the module */
            loading = TRUE;
end;

/* switch to the named / blank common */
LinkSelCommon: procedure;
    if SearchSymbol(.bFieldName , bFieldLen, TRUE) then
    do;
        curCommonBase = GetVal;
        curCommonIsFixed = GetFixed;
    end;
    else
        call Fatal(.aCommonError);
end;

/* set the module name */
LinkModuleName: procedure;
    call move(bFieldLen, .bFieldName, .modName(1));
    modName(0) = bFieldLen;
end;

/* add the lib request if not already present */
LinkLibRequest: procedure;
    if not FindLibRequest(.bFieldName, bFieldLen) then
    do;
        call InsertSymbol(.bFieldName, bFieldLen, 0, ASEG, TRUE, FALSE, 0);
        call SetLibRequest;
    end;
end;

/* set common size. If already set check new size is not bigger */
/* if new common add to end of common segment */
LinkCommonSize: procedure;
    if SearchSymbol(.bFieldName, bFieldLen, TRUE) then
    do;
        if GetCommonSize < aFieldAddr then
        do;
            call PutCh('/');                /* print a warning */
            call PrintSymbol;
            call PutCh('/');
            call PutCh(' ');
            call PutStr(.aFirstCommonNot);
            call NewLn;                     /* size does not change */
        end;
    end;
    else
    do;                                     /* new so insert */
       call InsertSymbol(.bFieldName, bFieldLen, curBase(COMMON) + modLengths(COMMON), COMMON, TRUE, TRUE, aFieldAddr);
       modLengths(COMMON) = modLengths(COMMON) + aFieldAddr;   /* add to the common area */
    end;
end;

/* update the chain of addresses linked to the given external symbol */
LinkChainExternal: procedure;
    /* add the external reference if not currently there */
    if not SearchSymbol(.bFieldName, bFieldLen, FALSE) then
        call InsertSymbol(.bFieldName, bFieldLen, 0, ASEG, FALSE, FALSE, 0);
    call AdjustChain(symP, TRUE);
end;


/* process the PUBLIC definition */
LinkEntryPoint: procedure;
    if SearchSymbol(.bFieldName, bFieldLen, FALSE) then /* has been seen before */
    do;
        if GetResolved then                 /* oops it was previously defined */
        do;
            call PutStr(.aMultipleDefinition);
            call PrintSymbol;
            call NewLn;
        end;
        else
        do;                                 /* adjust address by current base */
            call SetVal(curBase(aFieldSeg) + aFieldAddr);
            call SetResolved(TRUE);         /* mark as resolved */
            call SetSegment(aFieldSeg);     /* update the segment */
        end;
    end;
    else                                    /* first time so insert as new symbol */
        call InsertSymbol(.bFieldName, bFieldLen, aFieldAddr + curBase(aFieldSeg), aFieldSeg, TRUE, FALSE, 0);
end;

/* add ext + offset fixup */
LinkExternalPlus: procedure;
    call AddFixup(curLoc(curSeg), 0, 0, 0, curSeg, TRUE, aFieldAddr, TRUE);
end;

/* add ext - offset fixup */
LinkExternalMinus: procedure;
    isMinus = TRUE;
    call LinkExternalPlus;
    isMinus = FALSE;
end;

/* set the explicit size for the current DSEG */
LinkDSegSize: procedure;
    modLengths(DSEG) = aFieldAddr;
end;


/* change the location counter, adjust using base of current load */
LinkSetLocationCounter: procedure;
    call SelectSegment(aFieldSeg);          /* make current set */
    if curSeg = COMMON then                 /* common is relative to selected common block */
        curLoc(COMMON) = aFieldAddr + curCommonBase;
    else                                    /* rest are adjusted by current base of this load */
        curLoc(curSeg)  = aFieldAddr + curBase(curSeg);
    if curSeg = ASEG then
        hasAseg = TRUE;
end;

/* resolve chain for this address */
LinkChainAddress: procedure;
    call AdjustChain(curLoc(curSeg), FALSE);
end;


/* set the explicit size for the current CSEG */
LinkCSegSize: procedure;
    modLengths(CSEG) = aFieldAddr;
end;

/* finalise processinf of the module */
LinkEndModule: procedure;
    declare i byte;

    /* check for start pointer */
    if aFieldAddr > 0 or aFieldSeg <> ASEG then
        if transferFlag then            /* more than one transfer address */
            call Fatal(.aMainModuleError);
        else
        do;
            transferAddr = curBase(aFieldSeg) + aFieldAddr;
            transferSeg = aFieldSeg;
            transferFlag = TRUE;
        end;

    do while bitCnt <> 8;               /* skip to byte boundary */
        if RdBits(1) then
            ;
    end;

    /* advance the segment bases for the next module */
    do i = CSEG to COMMON;
        curBase(i), curLoc(i) = curBase(i) + modLengths(i);
        modLengths(i) = 0;
    end;

    /* mark lower limit of memory usage by fixups */
    if botFixup < lowMarkFixup then
        lowMarkFixup = botFixup;

    if additionalMem then               /* if A flag then spool fixups to disk */
    do;
        call OverflowFixups;
        botFixup = topMemory;
    end;

    call SelectSegment(CSEG);           /* next module starts in CSEG */
    loading = not librarySearch;        /* reset loading mode */
    if haveSpecialSym then              /* clear any special # symbols */
        call ClearSpecialSymbols;
end;

Store16BitLength: procedure(addr, mode);
    declare addr word, mode byte;

    if mode = COMMON then
    do;
        addr = addr + curCommonBase;
        if curCommonIsFixed then
            mode = ASEG;
    end;
    else
        addr = addr + curBase(mode);    /* adjust to address in current seg */

    if FindChainHead(curLoc(curSeg), curSeg) then   /* This loc is already on a chain */
    do;
        call SetFixupRef(addr);         /* fixup the reference location information */
        call SetFixupSeg(mode);
    end;
    else                                /* add new fixup */
        call AddFixup(curLoc(curSeg), addr, mode, FALSE, curSeg, FALSE, 0, FALSE);

    call SaveConstByte(0);              /* fill the image with 0 0 */
    call SaveConstByte(0);
end;


/* handle the special link items */
ReadLinkItem: procedure(item);
    declare item byte;

    if item >= SIZCOMM then             /* get the A and B fields are required */
        call ReadAField;
    if item <= ENTRYPT then
        call ReadBField;
    if item = ENTRYSYM then             /* we have an entry symbol */
        call LinkSetEntry;
    else if item = PROGNAM then         /* we got the module name */
        call LinkModuleName;
    else if item = ENDMOD then          /* we have read the whole module */
        call LinkEndModule;
    else if loading then                /* if we are loading the file process the link items */
        do case item - 1;
        call LinkSelCommon;             /* SELECOMM */
        ;                               /* PROGNAM */
        call LinkLibRequest;            /* REQUEST */
        call PutStr(.aUnrecognizedIt);  /* UNUSED4 */
        call LinkCommonSize;            /* SIZCOMM */
        call LinkChainExternal;         /* EXTCHAIN */
        call LinkEntryPoint;            /* ENTRYPT */
        call LinkExternalMinus;         /* EXTMINUS */
        call LinkExternalPlus;          /* EXTPLUS */
        call LinkDSegSize;              /* SIZDATA */
        call LinkSetLocationCounter;    /* SETLOC */
        call LinkChainAddress;          /* ADDRCHAIN */
        call LinkCSegSize;              /* SIZPROG */
        end;
end;

/* read the next item */
ReadItem: procedure byte;
    declare (special, rel, val8) byte, val16 word;

    special = STDLINK;
    if RdBits(1) = 0 then               /* abs value */
    do;
        val8 = RdBits(8);               /* get the byte */
        if loading then
            call SaveConstByte(val8);
    end;
    else if (rel := RdBits(2)) = 0 then /* get mode & check special link */
    do;
        special = RdBits(4);            /* get the special link and process it */
        if special < ENDFILE then
            call ReadLinkItem(special); 
    end;
    else
    do;                                 /* simple 16 bit rel */
        val16 = Read16bit;
        if loading then
            call Store16BitLength(val16, rel);
    end;
    return special; 
end;

/* read the rel file in full */
LoadRelFile: procedure;
   do while ReadItem <> ENDFILE;
   end;
end;


LoadOneModule: procedure public;
    bitCnt = 8;                         /* start with new byte */
    do while ReadItem <> ENDMOD;
    end;
end;

ReadFile: procedure;
    bitCnt = 8;                         /* force load of 1st byte */
    relIdx, relLen =  400h;             /* input buffer is 1024 bytes */
    if isIRL then
    do;
        relIdx, relLen = 400h - indexLen;   /* split relBuf up to have rel and index file */

        call move(32, .fcb1, .indexFcb);    /* copy name to index file */
        if (baseEx := RdBits(8)) <> fcb1(FCB$EX) then   /* get Ex of Rel file part and check if already there */
        do;
            fcb1(FCB$EX) = baseEx;      /* open to the right Ex */
            if Open(.fcb1) = 255 then
                call IOErr(.aIndexError, .fcb1);
        end;

        fcb1(FCB$CR), baseCr = RdBits(8);   /* set the CR from the index File */
        indexFcb(FCB$CR) = 1;               /* index starts in record 1 (0 based) */
        relIdx = relLen;                    /* reset to force reload */
        relStartRec, relEndRec =  0;
    end;

    call SelectSegment(CSEG);           /* start in the CSEG */
    loading = not librarySearch;        /* see if we start loading */
    if librarySearch and isIRL then     /* do efficient library scan */
        call LoadIrlLib;
    else
        call LoadRelFile;               /* else process normally */
end;


LoadFile: procedure public;
    if (fcb1(FCB$EXT) and 7fh) = ' ' then   /* if no extent use .REL */
        call move(3, .('REL'), .fcb1(FCB$EXT));
    isIRL = Strequ(.('IRL'), .fcb1(FCB$EXT), 3);    /* note if IRL */
    call OpenF(.fcb1);                  /* open the file */
    call ReadFile;                      /* and read it */
end;



declare aOvlay(*) byte data('?OVLAY');
declare aOvla0(*) byte data('?OVLA0');


RequireOvlayHandler: procedure  public;
    /* make sure ?OVLAY symbol is present to make sure loader is included */
    if not SearchSymbol(.aOvlay, length(aOvlay), FALSE) then
        call InsertSymbol(.aOvlay, length(aOvlay), 0, CSEG, FALSE, FALSE, 0);
end;

DoLibRequests: procedure public;
    declare i byte, tmpP pointer;

    symP = GetSymbolBase;                   /* get start of symbols for this overlay/root */

    do while symP < topSymTable;
        if GetLibRequest then               /* symbol is a library request */
        do;
            fcb1(FCB$DR) = libDrive;        /* build fcb1 to reflect library name */
            do i = 1 to 8;
                if i > GetSymLength then
                    fcb1(i) = ' ';
                else
                    fcb1(i) = sym.sName(i - 1);
            end;

            isIRL = TRUE;                   /* use .IRL if it exists */
            call move(3, .('IRL'), .fcb1(FCB$EXT));
            if not ExistF(.fcb1) then
            do;                             /* revert to use .REL */
                isIRL = FALSE;
                call move(3, .('REL'), .fcb1(FCB$EXT));
                call OpenF(.fcb1);
            end;
            tmpP = symP;                    /* save where we are */
            librarySearch = TRUE;           /* note we are doing library search */
            call ReadFile;                  /* process the file */
            symP = tmpP;                    /* restore where we were */
        end;
        symP = symP + GetItemLength;        /* next item */
    end;
end;



/*
    foreach undefined symbol add a thunk assuming it is an overlay. The thunks are

    lxi b,$+6       ; pointer to the symbol name
    jmp ?OVLA0      ; chained as an external
    db  'xxxxxxxx'  ; 8 char symbol name padded with spaces
*/
AddOverlayThunks: procedure public;
    declare i byte, tmpP pointer;

    call move(6, .aOvla0, .bFieldName);
    bFieldLen = 6;
    aFieldSeg = CSEG;
    call SelectSegment(CSEG);
    symP = GetSymbolBase;               /* for overlays this gets the current overlay symbols */

    do while symP < topSymTable;        /* look at all symbols */
        if not GetResolved then
        do;
            call SetVal(curLoc(CSEG));  /* resolve to current end of CSEG */
            call SetSegment(CSEG);
            call SaveConstByte(1);      /* lxi b, $+6 */
            call Store16BitLength(6, CSEG);
            call SaveConstByte(0c3h);   /* jmp ?OVLA0 */
            aFieldAddr = 4;             /* offset of 0 0 below */
            call SaveConstByte(0);      /* 0 0 */
            call SaveConstByte(0);
            tmpP = symP;                /* preserve current symP over next call */
            call LinkChainExternal;     /* ?OVLA0 */
            symP = tmpP;

            do i = 1 to 8;              /* write the overlay name */
                if GetSymLength >= i then
                    call SaveConstByte(sym.sName(i - 1));
                else 
                    call SaveConstByte(' ');    /* pad with space */
            end;

            curBase(CSEG) = curBase(CSEG) + 14; /* advance for next undefined */
            if additionalMem then       /* free up space */
            do;
                call OverflowFixups;    /* write to disk */
                botFixup = topMemory;   /* reclaim space */
            end;
        end;
        symP = symP + GetItemLength;    /* next item */
    end;
end;
end;

relasm.asm
    name    relasm
    public  RdBits, StrEqu, ClrBuf
    extrn   bitCnt, RdBuf, relBuf, relIdx, relLen

TRUE    equ 1
FALSE   equ 0

    DSEG
relByt:  db  0              ; current byte being processed
    CSEG

; RdBits(cnt) byte;
; reaturn cnt bits from current input stream

RdBits:
    mvi     b, 0            ; result in b

nbit1:
    lxi     h, bitCnt       ; do we need a new byte ?
    inr     m
    mov     a, m
    cpi     9
    jc      nbit3           ; jmp if still processing current byte for bit stream
    mvi     m, 1            ; reset
    lhld    relIdx          ; advance to next byte
    inx     h
    shld    relIdx
    xchg
    lhld    relLen
    mov     a, e
    sub     l
    mov     a, d
    sbb     h
    jc      nbit2           ; jmp if still in buffer
    lxi     h, 0
    shld    relIdx          ; reset to start of buffer
    push    b
    call    RdBuf           ; get next butter
    pop     b

nbit2:
    lhld    relIdx          ; get next byte to process
    xchg
    lxi     h, relBuf
    dad     d
    mov     a, m
    sta     relByt

nbit3:
    mov     a, b
    rlc                     ; shr current value
    ani     0feh
    mov     b, a
    lda     relByt          ; get next bit
    rlc
    sta     relByt
    ani     1               ; mask off
    ora     b               ; and add to current value
    mov     b, a
    dcr     c
    jnz     nbit1
    mov     a, b            ; return result
    ret

; StrEqu(str1, str2, len) bool public
; asm version of StrEqu - returns TRUE if str1 & str2 are same for len chars
StrEqu:
    mov     a, e        ; a= length, bc = str2
    pop     h           ; hl = str1
    xthl
    mov     e, a

str1:
    ldax    b
    cmp     m
    jnz     str2
    inx     b
    inx     h
    dcr     e
    jnz     str1
    mvi     a, TRUE
    ret

str2:
    xra     a
    ret

; ClrBuf(bufP, len) public
; zero out the buffer pointed to by bufP for len bytes
ClrBuf:
    mov     h, b        ; hl = bufP
    mov     l, c
    mvi     c, 0        ; fill value

clr1:
    mov     m, c
    dcx     d
    inx     h
    mov     a, d        ; check if done
    ora     e
    jnz     clr1
    ret

    end

link4.plm
link4: do;
$include(link4.ipx)

declare wrBitCnt byte initial(0);
declare wrRelocByt byte initial(0);
declare locMEMRY word initial(0);

declare extents(5) structure(ext(3) byte) data('COM', 'PRL', 'RSP', 'SPR', 'OVL');

WriteByte: procedure(ch);
    declare ch byte;

    relBuf(imgIdx) = ch;

    if (imgIdx := imgIdx + 1) >= imgBufSize then
    do;
        call WriteF(.relBuf, imgBufSize, .fcb1);
        imgIdx = 0;
    end;
end;

WrRelocBit: procedure(bit);
    declare bit bool;

    wrRelocByt = rol(wrRelocByt, 1) or bit;
    if (wrBitCnt := wrBitCnt + 1) = 8 then
    do;
        wrBitCnt = 0;
        call WriteByte(wrRelocByt);
        wrRelocByt = 0;
    end;
end;

WriteByteToImage: procedure(n);
    declare n byte;
    call WriteByte(n); 
    curAddr = curAddr + 1;
end;

WriteWordToImage: procedure(n);
    declare n word;
    call WriteByteToImage(low(n));
    call WriteByteToImage(high(n));
end;


BuildImageFile: procedure;
    declare i byte;

    declare imgSize word;

    /* write the requested segment, checking for overlaps and padding with 0 to seg base address */
    WriteSeg: procedure(seg);
        declare seg byte;
        declare addr word;

        WriteSegData: procedure(base);      /* write the seg data */
            declare base word;
            declare i word;

            do i = base to curLoc(seg) + base - 1;  /* curLoc(seg) -> length of seg */
                call WriteByteToImage(LoadByteFromSeg(i));
            end;
        end;

        if seg = ASEG then                  /* get the start address */
            addr = lowAbs;
        else
            addr = starts(seg);

        if curAddr > addr then              /* if addr is below current then overlap */
            call Fatal(.aOverlappingSeg);

        do while curAddr < addr;            /* pad with 0 to get to addr */
            call WriteByteToImage(0);
        end;

        call SelectXFile(xFileTable(seg));  /* select the segment data */
        if curLoc(seg) > 0 then             /* if there is data */
            if seg = ASEG then              /* for ABS write with implied base of lowAbs */
                call WriteSegData(lowAbs);
            else
                call WriteSegData(0);       /* else from 0 base */
        if curAddr > endMem then            /* update endMem */
            endMem = curAddr;
    end;


    /* write the PRL header page */
    BuildPrefixPage: procedure;
        declare i byte;

        /* calc size of image for this file */
        imgSize = starts(segOrder(numSegs - 1)) + curLoc(segOrder(numSegs - 1)) - curFileLoadAddress;
        /* write 0, size, 0 */
        call WriteByteToImage(0);           /* always 0 */
        call WriteWordToImage(imgSize);     /* program image size */
        call WriteByteToImage(0);           /* always 0 */

        if outType = OVL$EXT then           /* overlay */
        do;                                 /* write 00, 0, curFileLoadAddress */
            call WriteWordToImage(0);       /* bss size - 0 for ovl */
            call WriteByteToImage(0);       /* always 0 */
            call WriteWordToImage(curFileLoadAddress); /* load address of OVL */
        end;
        else
        do;
            call WriteWordToImage(MPMMemSize);  /* bss size */
            call WriteByteToImage(0);       /* always 0  */
            call WriteWordToImage(0);       /* always 0 for relocatable */
        end;

        call WriteByteToImage(0);           /* 0 */
        if biosLink then
            call WriteWordToImage(curBase(CSEG)); /* start of CSEG */
        else
            call WriteWordToImage(0);       /* 0 */

        do i = 1 to 244;                    /* pad with 0 to end of 256 byte header */
            call WriteByteToImage(0);
        end;

    end;


    /* build the IPR/RSP/SPR/PRL relocation bit map */
    BuildRelocMap: procedure;
        declare (seg, i) byte, addr word;

        /* add the reloc bit and advance the address */
        AddRelocBit: procedure(reloc);
            declare reloc bool;

            call WrRelocBit(reloc);
            curAddr = curAddr + 1;
        end;


        /* mark as non relocatable until next fix up */
        AddNextReloc: procedure;
            do while curAddr <= addr;       /* first byte of fixup is also no relocatable */
                call AddRelocBit(FALSE);
            end;
            call AddRelocBit(TRUE);         /* set the high byte as relocatable */
        end;


        /* build the relocation map by scanning the fixup table */
        BuildSimpleBitMap: procedure;
            fixupP = fixupHeadP(seg);

            do while fixupP <> 0;
                addr = GetFixupAddr + starts(seg);  /* adjust to reflect real location of fixup */
                call AddNextReloc;                  /* add reloc for this fixup, padding with no reloc */
                fixupP = GetSegLink;                /* get next fixup */
            end;
        end;

        /* we have spooled the fixups to disk so get them from disk */
        BuildExtendedBitMap: procedure;
            declare yByte byte;

            call SelectYFile(yFileTable(seg));      /* get the right file */
            if yFile.onDisk then                    /* is on  disk so open file */
            do;
                call OpenF(.yFile.fcb);
                yFile.bufIdx = yFile.Len;           /* set to cause load */
            end;
            else
                yFile.bufIdx = 0ffffh;              /* in memory so cause to reuse */

            yByte = ReadYByte;                      /* get the state byte */

            do while ybyte <> 255;                  /* do all of the fixups */
                addr = ReadYWord + starts(seg);     /* fixup address */
                wordP = ReadYWord;                  /* fixup target */
                if (ybyte and 8) > 0 then           /* has offset so read it */
                    wordP = ReadYWord;
                call AddNextReloc;                  /* address is location of fixup so mark it */
                yByte = ReadYByte;                  /* continue to next item */
            end;
        end;

        /* start oF BuildRelocMap */
        curAddr = curFileLoadAddress;       /* load point for this file */
        if initialJmp then                  /* do we need initial jmp */
        do;
            call AddRelocBit(0);            /* 3rd byte is relocatable */
            call AddRelocBit(0);
            call AddRelocBit(1);
        end;
        do i = 0 to numSegs - 1;            /* process the segments */
            if (seg := segOrder(i)) <> ASEG then   /* ASEG is skipped */
            do;
                do while starts(seg) > curAddr;     /* non relocatable pad to start of this seg */
                    call AddRelocBit(0);
                end;
            if additionalMem then           /* see if spooling required */
                call BuildExtendedBitMap;
            else
                call BuildSimpleBitMap;
            end;

        end;

        do while curAddr < imgSize + curFileLoadAddress;    /* pad to end of image  with absolute */
            call AddRelocBit(0);
        end;
        do while wrBitCnt <> 0;             /* pad to byte boundary */
            call AddRelocBit(FALSE);
        end;
    end;

    /* start of BuildImageFile */
    if numSegs = 0 then                     /* nothing to do */
        return;

    if outType <> COM$EXT then              /* build prefix page unless .COM */
        call BuildPrefixPage;

    curAddr = curFileLoadAddress;           /* set load address */
    if initialJmp then                      /* emit any initial jmp */
    do;
        call WriteByteToImage(0c3h);
        call WriteWordToImage(startSymAddr);
    end;

    starts(ASEG) = lowAbs;                     
    do i = 0 to numSegs - 1;
        if starts(segOrder(i)) >= curFileLoadAddress then   /* write data from curFileLoadAddress onwards */
            call WriteSeg(segOrder(i));
    end;

    if outType <> COM$EXT and outType <> OVL$EXT then       /* if not .COM or .OVL then build the relocation map */
        call BuildRelocMap;
end;


/* close the image or symbol file */
CloseOutputFile: procedure;
    do while (imgIdx and 7fh) <> 0;         /* pad to 128 byte boundary with ^z */
        call WriteByte(1Ah);
    end;
    call WriteF(.relBuf, imgIdx, .fcb1);    /* write the file */
    call CloseF(.fcb1);
end;


GenerateImage: procedure public;
    if dstDrive = 'Z' then      /* nothing to generate */
        return;

    call move(12, .targetFile, .fcb1);      /* set the target file */
    if fcb1(FCB$EXT) = ' ' then             /* if no extent set an appropriate one */
        call move(3, .extents + 3 * outType, .fcb1(FCB$EXT));
    if dstDrive <> 0 then                   /* set dstDrive if given */
        fcb1(FCB$DR) = dstDrive;

    call CreatF(.fcb1);                     /* create the file */
    if objFName(FCB$NAME) = ' ' then        /* copy name to objfile if not specified */
        call move(12, .fcb1, .objFName);

    imgIdx, wrRelocByt, wrBitCnt =  0;      /* init for new write */
    call BuildImageFile;                    /* create the file */
    call CloseOutputFile;                   /* close the file */
end;

WriteSymFile: procedure public;
    declare (i, cnt) byte;


    /* utility functions to write hex words / bytes as ascii to the file */
    WriteHexNibbleToSymFile: procedure(n);
        declare n byte;
        if n <= 9 then
            call WriteByte(n + '0');
        else
            call WriteByte((n - 10) + 'A');
    end;

    WriteHexByteToSymFile: procedure(n);
        declare n byte;
        call WriteHexNibbleToSymFile(shr(n, 4));
        call WriteHexNibbleToSymFile(n and 0fh);
    end;
        
    WriteHexWordToSymFile: procedure(n);
        declare n word;
        
        call WriteHexByteToSymFile(high(n));    /* make byte order natural for humans */
        call WriteHexByteToSymFile(low(n));
    end;


    if symDrive = 'Z' then                  /* no output */
        return;
    call move(9, .targetFile, .fcb1);       /* init the sym file name */
    call move(3, .('SYM'), .fcb1(FCB$EXT)); /* add the .SYM and set drive */
    if symDrive <> 0 then
        fcb1(FCB$DR) = symDrive;

    call CreatF(.fcb1);                     /* create and initialise the file */
    imgIdx, cnt = 0;
    symP = GetSymbolBase;                   /* start at the first symbol */

    do while symP < topSymTable;            /* go until the last */
        if not GetLibRequest and TestValidSymbol then   /* lib requests and invalid symbols are skipped */
        do;
            call WriteHexWordToSymFile(GetVal); /* write the value ' ' name */
            call WriteByte(' ');
            do i = 1 to GetSymLength;
                call WriteByte(sym.sName(i - 1));
            end;
            if ((cnt := cnt + 1) and 3) = 0 then    /* do 4 per line */
            do;
                call WriteByte(CR);
                call WriteByte(LF);
            end;
            else
                call WriteByte(TAB);        /* tab to next column */
        end;
        symP = symP + GetItemLength;        /* next item */
    end;
    call WriteByte(CR);                     /* end last line & close */
    call WriteByte(LF);
    call CloseOutputFile;
end;


/* seek to the end of the image file */
SeekMEMRYSector: procedure;
    declare recCnt word, extent byte;

    recCnt =  locMEMRY / 128;
    extent = recCnt / 128;
    if extent <> fcb1(FCB$EX) then          /* make sure we have the right extent */
    do;
        fcb1(FCB$EX) = extent;
        if Open(.fcb1) = 255 then
            call IOErr(.aNoFil, .fcb1);
    end; 
    fcb1(FCB$CR) = recCnt mod 128;          /* and the right record */
end;

/* called if we have ?MEMRY or $MEMRY defined */
/* writes endMem value to the location */
SetMEMRY: procedure;
    declare recCnt byte;

    locMEMRY = GetVal - imageBase;          /* find out where $MEMRY is in the image */
    call move(12, .objFName, .fcb1);
    if baseOutType <> COM$EXT then
        locMEMRY = locMEMRY + 256;          /* non .COM files have 256 byte header */

    call OpenF(.fcb1);
    call SeekMEMRYSector;                   /* seek to sector containing $MEMRY */
    recCnt = ReadFR(.MEMORY, 256, .fcb1);   /* read the buffer containing $MEMRY - might straddle sector */
                                            /* if in last sector only 128 will be read */
    wordP = .MEMORY + locMEMRY mod 128;     /* record the endMem at the end of the file */
    wordVal = endMem;    
    call SeekMEMRYSector;                    /* reposition to sector containing $MEMRY */
    call WriteF(.MEMORY, recCnt * 128, .fcb1);  /* and write new information */
    fcb1(FCB$S2) = fcb1(FCB$S2) and 7fh;    /* clear the S2 top bit */
    call CloseF(.fcb1);                     /* all done */
end;


/* record endMem at the end of the image */
EndFileProcessing: procedure public;
    if haveOverlays then
        endMem = (endMem + 7fh) and 0ff80h; /* round up to 128 byte boundary */
    if rootDstDrive = 'Z' then              /* no output */
        return;
    if SearchSymbol(.qMemry, 6, FALSE) then /* see if we have $MEMRY or ?MEMRY */
        call SetMEMRY;
    else if SearchSymbol(.dMemry, 6, FALSE) then
        call SetMEMRY;
end;
end;
link5.plm
link5: do;
$include(link5.ipx)

declare xFileP pointer public;
declare xFile based xFileP XFILE$T;  /* explicit declare to prevent plm error */

declare bufP pointer public;

/* accessor functions to set/get the ex and cr files from the current xFile */
SetXCr: procedure(rec);
    declare rec byte;
    xFile.fcb(FCB$CR) = rec;
end;

GetXEx: procedure byte;
    return xFile.fcb(FCB$EX);
end;

SetXEx: procedure(ex);
    declare ex byte;
    xFile.fcb(FCB$EX) = ex;
end;

/* clear the current xFile buffer */
ClearTmpBuf: procedure public;
    call ClrBuf(xFile.buf, xFile.len);
    xFile.dirty = FALSE;
end;


/* seek to start xFile.startAddr in the disk file */
SeekXTmpFile: procedure public;
    declare ex byte, recCnt word;

    recCnt = xFile.startAddr / 128;     /* convert start to sector cnt */
    ex = recCnt / 128;                  /* calculate ex from sector cnt */

    if ex <> GetXEx then                /* does it match the current one */
    do;
        call CloseF(.xFile.fcb);        /* no so do seek */
        call SetXEx(ex);
        if Open(.xFile.fcb) = 0ffh then /* make the new extent if it does not exist */
            call MakeF(.xFile.fcb); /* doesn't exist */
    end;
    call SetXCr(recCnt mod 128);        /* set the cr from the sector cnt */
end;


/* write current xFile buffer to disk */
WriteXBlk: procedure public;
    if xFile.curBlk > xFile.lastDiskBlk then    /* make sure lastDiskBlock is maintained */
        xFile.lastDiskBlk = xFile.curBlk;

    if not xFile.onDisk then            /* create disk file if not already done */
    do;
        call CreatF(.xFile.fcb);
        xFile.onDisk = TRUE;
    end;
    call SeekXTmpFile;                  /* move to correct location on disk */
    call WriteF(xFile.buf, xFile.len, .xFile.fcb);  /* and write the buffer */
    call ClearTmpBuf;                   /* clear the buffer for next use */
end;
end;
link6.plm
link6: do;
$include(link6.ipx)

/* calculate the buffer bounds and buffer number */
SetXBufferBounds: procedure(addr);  /* checked */
    declare addr word;

    xFile.startAddr = (addr / xFile.len) * xFile.len;
    xFile.endAddr = xFile.startAddr + xFile.len - 1;
    xFile.curBlk = (xFile.startAddr / xFile.len) + 1;
end;


/* write blocks to disk if necessary to make new curBlk next to write */
/* done when there are holes in the address range */
/*
   to check - if previous buffer was read but not changed then the first
              buffer here will contain random data. All other buffers will be zero
              Need to check if this will ever happen
*/
WriteXPad: procedure;
    declare (i, lo, hi) word;
 
    lo = xFile.lastDiskBlk + 1;         /* next new disk block */
    hi = xFile.curBlk - 1;              /* last is just before this */
    do i = lo to hi;
        call SetXBufferBounds((i - 1) * xFile.len);     /* set the address bounds */
        call WriteXBlk;                                 /* and write a block */
    end;
    call SetXBufferBounds(xFile.len * hi);  /* set up new buffer note hi is 1 based */
end;

/* read the next xFile block into memory */
ReadXBlk: procedure;
    if xFile.curBlk > xFile.lastDiskBlk then     /* high is above max on disk so all done */
        return;
    call SeekXTmpFile;                  /* seek the startAddr */
    call ReadF(xFile.buf, xFile.len, .xFile.fcb);   /* and fill the buffer */
end;

/* make sure requested address is in the buffer window. wr is TRUE if writing */
RwInWindow: procedure(addr, wr) public;
    declare addr word, wr bool;

    if addr < xFile.startAddr then      /* below startAddr of buffer */
    do;
        if xFile.dirty then             /* save current buffer if written to */
            call WriteXBlk;
        call SetXBufferBounds(addr);
        call ReadXBlk;                  /* load the new buffer */
    end;
    else
    do;
        if xFile.endAddr < addr then    /* addr is after current end */
        do;
            if xFile.dirty then         /* save current buffer if written to */
                call WriteXBlk;

            call SetXBufferBounds(addr);    /* set new  target buf */
            if wr then
            do;
                if xFile.curBlk > xFile.lastDiskBlk + 1 then
                    call WriteXPad;     /* pad out file */
                else
                    call ReadXBlk;      /* read existing data */
            end;
            else
            do;
                if xFile.curBlk > xFile.lastDiskBlk then
                    call ClearTmpBuf;   /* new buffer */
                else
                    call ReadXBlk;      /* read existing data */
            end;
        end;
    end;
end;

/* utility to select new xFile */
SelectXFile: procedure(fileP) public;
    declare fileP pointer;
    xFileP = fileP;                     /* make xFile structure based on this */
end;

/* store a byte (val) in current segment at location (addr) */
StoreByteInSeg: procedure(addr, val) public;
    declare addr word, val byte;
    declare buf based bufP (1) byte;

    call RwInWindow(addr, TRUE);        /* position to write */
    bufP = xFile.buf;
    buf(addr mod xFile.len) = val;      /* offet into active buffer */
    xFile.dirty = TRUE;
end;

/* load a byte in current segment at location (addr) */
LoadByteFromSeg: procedure(addr) byte public;
    declare addr word;
    declare buf based bufP (1) byte;

    call RwInWindow(addr, FALSE);       /* position to read */
    bufP = xFile.buf;
    return buf(addr mod xFile.len);
end;
end;

file.asm
    name file

    public Close, CloseF, ClrFCB, CRdStr, CreatF, CStat
    public CWrite, Delete, ExistF, Fatal, getVer, IOErr
    public LWrite, Make, MakeF, MPMSys, NewLn, Open
    public OpenF, PutFn, Read, ReadF, ReadFR, Rename
    public SetDMA, Write, WriteF
    public OS, cpm, aNoFil

    extrn  PutCh, PutStr, cmdLin

    ASEG
    org 0
OS:
    org 5
cpm:

    CSEG
TRUE equ 1
FALSE equ 0
RD  equ FALSE
WR  equ TRUE
CR  equ 0dh
LF  equ 0ah

; PutFn(fcbP) public
; print the file.ext information from the fcb
PutFn: 
    mvi     e, 8+3      ; file + ext name length
    inx     b
putfn1:
    ldax    b
    ani     7fh
    cpi     ' '
    cnz     putchA
    dcr     e
    rz
    inx     b
    mov     a, e
    cpi     3
    mvi     a, '.'
    cz      putchA      ; put . at extent
    jmp     putfn1


putchA:                 ; put char preserving registers
    push    b
    push    d
    mov     c, a
    call    PutCh
    pop     d
    pop     b
    ret


; IOErr(msg, fname) public
; print msg filename and exit
IOErr: 
    push    d
    call    PutStr      ; putStr(msg)
    pop     b
    call    PutFn       ; putFn(fname)
    lxi     b, aNull
    call Fatal          ; exit without additional msg


; CreatF(fcbP) public
; create fcb file, replacing any existing. Fatal error if no space
CreatF:
    push    b
    call Delete
    pop     b
    push    b
    call ClrFCB
    pop     b           ; fall through to make new file

; MakeF(fcbP) public;
; create new fcb file, fatal error if no space
MakeF:
    call Make
    inr     a
    rnz
    lxi     b, aFull    ; "NO SPACE$"
    call Fatal

; ExistF(fcbP) bool public;
; returns TRUE if fcb file exists
ExistF:
    push    b
    call ClrFCB
    pop     b
    call Open
    inr     a
    rz
    mvi     a, 1
    ret

; OpenF(fcbP) public
; open the fcb with fatal error if it fails
OpenF:
    push    b
    call ClrFCB         ; clear non name parts of FCB
    pop     b
    push    b
    call Open           ; get CPM to open it
    inr     a
    pop     d
    rnz                 ; error if cannot be opened
    lxi     b, aNoFil   ; "NO FILE: $"
    call IOErr          ; show file name and exit


; CloseF(fcbP) public
; close the fcb with fatal error if it fails
CloseF:
    call Close
    inr     a
    rnz
    lxi     b, aNoCls
    call Fatal


; ClrFCB(fcbP) public
; clear out the fcb post the name.ext
ClrFCB:
    lxi     h, 0Ch      ; past name & drive
    dad     b
    xra     a
    mvi     c, 21       ; clear remaining 21 bytes

clr1:
    mov     m, a
    dcr     c
    inx     h
    jnz     clr1
    ret


; ReadF(byte *buf, word len, byte *fcb) public
; ReadFR(byte *buf, word len, byte *fcb) word public

ReadF:
ReadFR:
    mvi     a, RD
    jmp     rwFile


; WriteF(byte *buf, word len, byte *fcb) word public

WriteF:
    mvi     a, WR

rwFile:
    sta     ioMode      ; direction of transfer TRUE -> write
    pop     h
    xthl
    shld    bufP        ; current transfer address
    xchg
    shld    fcbP        ; the fcb
    mov     a, c        ; calc whole number of sectors to transfer
    ani     80h
    mov     l, a
    mov     h, b
    shld    rwBlks      ; len / 128 * 128
    lxi     h,0
    shld    rwCnt       ; running count of sectors transferred
    call    CStat       ; see if user abort
    rar
    lxi     b, aAbort   ; "ABORTED$"
    cc      Fatal

rw1:
    lhld    rwBlks      ; last block ?
    mov     a, h
    ora     l
    jz      rw4
    lxi     b, -128     ; account for this block
    dad     b
    shld    rwBlks
    lhld    bufP        ; set transfer address
    mov     c, l
    mov     b, h
    call SetDMA
    lhld    fcbP
    mov     b, h
    mov     c, l
    lda     ioMode      ; read or write?
    cpi     0
    jz      rw2
    call Write
    ora     a
    lxi     b, aWrErr   ; "DISK WRITE ERROR"
    cnz     Fatal
    jmp     rw3

rw2:
    call    Read
    ora     a
    jz      rw3         ; ok so transfer next block
    lhld    rwCnt       ; run out file?
    mov     a, h
    ora     l
    jnz     rw4         ; done if so
    lxi     b, aRdErr   ; "DISK READ ERROR: "
    lhld    fcbP
    xchg
    call IOErr

rw3:
    lhld    bufP        ; update transfer address
    lxi     d, 128
    dad     d
    shld    bufP
    lhld    rwCnt
    inx     h
    shld    rwCnt
    jmp     rw1

rw4:
    lxi     b, cmdLin   ; reset to default transfer address
    call SetDMA
    lhld    rwCnt       ; return blocks transferred
    ret

; inline data
    
bufP:   dw  0           ; the current transfer address
fcbP:   dw  0           ; the fcb
rwBlks: dw  0           ; count of sectors to transfer
        dw  0           ; unused
rwCnt:  dw  0           ; actual sectors transferred
ioMode: db  0           ; TRUE for write FALSE for read

; common error messages
aAbort: db  'ABORTED$'
aFull:  db  'NO SPACE$'
aNoFil: db  'NO FILE: $'
aNoCls: db  'CANNOT CLOSE$'
aRdErr: db  'DISK READ ERROR: $'
aWrErr: db  'DISK WRITE ERROR'
aNull:  db  '$'

; CP/M interface
; simple interfaces to CPM system calls

CONWR  equ 2
LISTWR  equ 5
CREADS  equ 10
COSTAT   equ 11
SVER    equ 12
FOPEN   equ 15
FCLOSE  equ 16
FDEL    equ 19
FREAD   equ 20
FWRITE  equ 21
FMAKE   equ 22
FREN    equ 23
FDMA    equ 26
MPMDAT  equ 154

; CWrite(ch) public
CWrite:
    mov     e, c
    mvi     c, CONWR
    jmp     cpm

; LWrite(ch) public
LWrite:
    mov     e, c
    mvi     c, LISTWR
    jmp     cpm

; CRdStr(buf) public
CRdStr:
    mov     e, c
    mov     d, b
    mvi     c, CREADS
    jmp     cpm

; CStat byte public
CStat:
    mvi     c, COSTAT
    jmp     cpm

; getVer byte public
GetVer:
    mvi     c, SVER
    jmp     cpm

; Open(fcbP) byte public
Open:
    mov     e, c
    mov     d, b
    mvi     c, FOPEN
    jmp     cpm

; Close(fcbP) byte public
Close:
    push    b
    lxi     b, cmdLin      ; set to default dma
    call    SetDMA
    pop     d
    mvi     c, FCLOSE
    jmp     cpm

; Delete(fcbP) byte public (return ignored)
Delete:
    mov     e, c
    mov     d, b
    mvi     c, FDEL
    jmp     cpm

; Read(fcbP) byte public
Read:
    mov     e, c
    mov     d, b
    mvi     c, FREAD
    jmp     cpm

; Write(fcbP) byte public
Write:
    mov     e, c
    mov     d, b
    mvi     c, FWRITE
    jmp     cpm

; Make(fcbP) byte public
Make:
    mov     e, c
    mov     d, b
    mvi     c, FMAKE
    jmp     cpm

; Rename(fcbP) byte public (not used)
Rename:
    mov     e, c
    mov     d, b
    mvi     c, FREN
    jmp     cpm

; SetDMA(buf) public
SetDMA:
    mov     e, c
    mov     d, b
    mvi     c, FDMA
    jmp     cpm

; MPMSys address public - get MPM  system data pointer
MPMSys:
    mvi     c,  MPMDAT
    jmp     cpm


; NewLn procedure public
; write a cr lf
NewLn:
    mvi     c, CR
    call    PutCh
    mvi     c, LF
    jmp     PutCh

; Fatal: procedure(str) public;
; print the user msg and reboot
Fatal:
    call    PutStr ; bc implicit
    jmp     OS

    end;

os.plm
os: do;
$include(os.ipx)

declare invName(6) byte initial(0c0h, 0b9h, 0afh, 0bdh, 0b1h, 0a7h); /* inverted chars ?FPBNX */
declare bPtr address initial(1a1ah);    /* initialised to EOF padding */
                                        /* Note bPtr declared address as used for pointer & word */
declare mfgCode byte initial(1ah);
declare serial2 byte initial(1ah);
declare serial3 byte;
declare cpmVersion word;

/*
   this appears to extract serial number information for use in the
   special common area ?FPBNX
   only works sensibly for cp/m 3.x or later and mp/m
   see https://www.retrotechnology.com/dri/cpm_serial.html for details
*/
GetSerial: procedure public;
    declare (noSerial, isMPM) byte;
    declare serialNum based bPtr (1) byte;

    noSerial = FALSE;                   /* assume serial  number is valid */
    isMPM = FALSE;
    cpmVersion =  GetVer;
    if high(cpmVersion) = 0 then        /* point to serial number */
    do;
        bPtr = topMemory - 6;           /* cpm's is located just below cpm entry point for cp/m 3 */
        /* before cp/m 3.x bPtr will point to other information. Check here detects it's not pointing
           to a serial number, assumes all cp/m 3 serial numbers are of the form
           mfg code, cpm ver, 0, 0, serial, serial
        */
        if (serialNum(2) or serialNum(3)) <> 0 then   /* mfg code high byte, 1st byte of serial number */
            noSerial = TRUE;
    end;
    else if high(cpmVersion) = 1 then
    do;
        isMPM = TRUE;
        bPtr = MPMSys + 181;            /* mpm's is at systemDataArea(181) */
    end;
    else                                /* CP/Net */
        noSerial = TRUE;
    if noSerial then
    do;
        mfgCode = 0ffh;
        serial2 = 0ffh;
        serial3 = 0ffh;
    end;
    else
    do;
        mfgCode = serialNum(0);         /* mfg code */
        serial2 = serialNum(4);         /* 2nd byte of serial number */
        if isMPM then
            serial2 = serial2 or 80h;
        serial3 = serialNum(5);         /* 3rd byte of serial number */
    end;
end;

/*
   not sure what this is actually for. It appears to write serial number information
   into locaitons 9-15 of common area named ?FPBNX
   for some reason the common name is stored as inverted chars
   I suspect it is to track which machine the code was written on possibly to track
   illegal copies of compilers etc.
*/
Process$FPBNX: procedure public;
    declare i byte;

    do i = 0 to last(invName);
        bFieldName(i) = not invName(i);
    end;
    if not SearchSymbol(.bFieldName, size(invName), TRUE) then
        return;

    curCommonBase = GetVal;
    call SelectSegment(COMMON);
    bPtr = curLoc(COMMON);              /* save current common loc */
    curLoc(COMMON) = curCommonBase + 9; /* set to the desired address for these bytes */
    call SaveConstByte(signature(0));   /* 0 */
    call SaveConstByte(signature(1));   /* 0 */
    call SaveConstByte(signature(2));   /* 0 */
    call SaveConstByte(mfgCode);        /* mfg code */
    call SaveConstByte(serial2);        /* 2nd byte of serial number (| 80h for mpm) */
    call SaveConstByte(serial3);        /* 3rd byte of serial number */
    curLoc(COMMON) = bPtr;              /* restore common loc */
end;

declare relBuf(512) byte public;
declare indexBuf(512) byte public;
declare cmdLineBuffer(128) byte public;
end;
