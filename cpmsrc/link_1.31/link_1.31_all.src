link.pex
ClearTmpBuf		P
CloseF          P("pointer" fcbPtr)
CloseLoadSession	P
CloseObjFile    P
ClrBuf          P("pointer" ptr,"word" len)
CmdLineError	P
CntChainLen     P(A addr,B mode)"bool"
CRdStr		    P("pointer" ptr)
CreatF          P("pointer" fcbPtr)
CWrite		    P(B ch)
Delete          P("pointer" fcbPtr)
EndFileProcessing	P
ExistF          P("pointer" fcbPtr)"bool"
Fatal		    P("pointer" str)
FindSymbol      P("pointer" namePtr,B nameLen)B
FixupChainPath  P
FixLinkageWriteRecord P
FixTLinkage     P
GetChain        PA
GetCommonLength P"word"
GetCurSymValue 	P"word"
GetEntryState   PB
GetFixed        PB
GetItemLength   PB
GetNextNonBlankChar	P
GetSymbolBase   P"pointer"
GetSymbolControlBits PB
GetSymLength    PB
GetTAddress     PA
GetTB1B0        PB
GetTB3          PB
GetTLink        P"word"
GetTOffset      P"word"
GetTStatus      PB
GetTValue       P"word"
GetVer          P"word"
IOErr           P("pointer" msg,"pointer" fname)
#InsertSymbol    P(A namePtr,B nameLen,"word" nameValue,B controlBits,B entryBit,"bool" isCommon,"word" sizeCommon)
InsertSymbol     P(ABABBBA)
IsLibRequest    P"bool"
LinkSetEntry	P
LoadByteFromSeg P("word" addr)B
LoadIRL         P
LoadOneModule	P
LWrite		    P(B ch)
#MkTRecord      P(A addrOrChn,A ChnOrValue,B mode,B solveChn,B index,B offBit,A offset,B offFlg)
MkTRecord       P(AABBBBAB)
MakeF           P("pointer" fcbPtr)
MPMSys          PA
NewLn           P
Open            P("pointer" fcbPtr)B
OpenF           P("pointer" fcbPtr)
OS		        P
OsSetup	    	P
ParseCmdLine	P
Process$FPBNX	P
PutCh		    P(B ch)
PutFn		    P("pointer" fcbPtr)
PutStr          P("pointer" str)
RdBits          P(B cnt)B
RdBuf		    P
ReadF		    P("pointer" buf, "word" len, "pointer" fcbPtr)
ReadFR		    P("pointer" buf, "word" len, "pointer" fcbPtr)"word"
ReadRelocatable	P
ReadYByte       PB
ReadYRecord     P
ReadYWord       P"word"
RwInWindow      P("word" addr, "bool" wr)
SaveConstByte	P(B n)
SearchSymbol	P("pointer" namePtr,B nameLen, "bool" includeCommon)B
SeekXTmpFile    P
SelectTmpFile	P(B n)
SelectXFile		P("pointer" fPtr)
SetCurSymValue  P("word" val)
SetEntryState   P(B state)
SetExt$OVLA0	P
SetExt$OVLAY	P
SetFixed        P
SetLibRequest   P
SetSymbolControlBits P(B n)
SetTAddress     P(A addr)
SetTB1B0        P(B n)
SetTB2          P(B n)
SetTLink        P(A link)
SetTValue       P("word" val)
SetYFile        P("pointer" ptr)
SolveLibRequest	P
StoreByteInSeg  P("word" addr,B Val)
StrEqu          P("pointer" str1,"pointer" str2,B len)"bool"
TellTopModule	P
TestValidSymbol P"bool"
WriteF		    P("pointer" buf, "word" len, "pointer" fcbPtr)
WriteRecordsXTmp P
WriteSymFile    P
YRewind         P

additionalMem   "bool"
aField          "word"
aIndexError		B(12)
aMemoryOverflow B(32)
aNoFil          B(10)
aOverlappingSeg B(21)
b3979           B
modName         B(8)
b3A55           B
b3A5C           B
b3A5E		    B
b3A66           B
b3A9D           B
b3A9E           B
isMinus		    B
baseCr		    B
baseEx		    B
baseOutType     B
biosLink        "bool"
bitCnt          B
chains  		"word"(4)
charOutDev		B
cmdLineBuffer	B(128)
cmdLinePtr		"word"
curSymValue		"word"
dataOrgRequest  "bool"
dataOrigin		"word"
dMemry          B(6)
dstDrive		B
fcb1            BS
objFName       B(12)
hashTable		A(128)
haveOverlays    B
haveSpecialSym  B
i3A51		    B
i3A5D           B
indexBuf		B(512)
indexFCB		B(33)
indexLen		"word"
indexPtr		"word"
inFile          B(12)
intermediateDrive	B
IRLBuf          B(512)
IRLLen          "word"
IRLPtr		    "word"
IRLWinHigh		"word"
IRLWinLow		"word"
isIRL           B
labelStartAddress	B
labLen          B
labName         b(8)
lengths         "word"(4)
libDrive		B
librarySearch   "bool"
lname   		B(9)
loadAddress		"word"
modLengths      "word"(4)
MPMMemSize		"word"
noLeadingQ      "bool"
objTable        B(4)
oldbase		    A
outType		    B
progOrgRequest  "bool"
progOrigin		"word"
qMark           B
qMemry          B
signature    	B(3)
starts          "word"(4)
startSym		B(7)
symDrive		B
symPtr		    "word"
symTable        A
symTables   	A(4)
topHeap         A
topMemory		A
topSymTable		"word"
tPtr	    	"word"
transferFlag    "bool"
w397C           "word"
w398B           "word"
w39A8           "word"
w3A33           "word"
w3A35           "word"
curAddr           "word"
w3A53           "word"
w3A56           "word"
w3A58           "word"
w3A5A           "word"
w3A71		    "word"
w3E5D           A
wordPtr         A
xFileTable      A(4)
xFPtr           A
xxabs           "XFILE$T"
xxcomm          "XFILE$T"
xxdata          "XFILE$T"
xxprog          "XFILE$T"
yFileTable	    A(4)
yFPtr           A
yyabs           "YFILE$T"
yycomm          "YFILE$T"
yydata          "YFILE$T"
yyprog          "YFILE$T"

/* fcb offsets */
FCB$DR      '0'
FCB$NAME    '1'
FCB$EXT     '9'
FCB$EX      '12'
FCB$S1      '13'
FCB$S2      '14'
FCB$RC      '15'
FCB$REC     '16'
FCB$CR      '32'

/* code types */
ABSOLUTE    '0'
CODEREL     '1'
DATAREL     '2'
COMMREL     '3'

/* non printable chars */
CR          '0dh'
LF          '0ah'
TAB         '9'

/* extension types */
COM$EXT     '0'
PRL$EXT     '1'
RSP$EXT     '2'
SPR$EXT     '3'
OVL$EXT     '4'

/* my types */
bool        'byte'
word        'address'
pointer     'address'
wpointer    'address'

/* link's version of TRUE/FALSE */
TRUE        '1'
FALSE       '0'

/* common structures */
XFILE$T 'structure(startAddr word, endAddr word, len word, buf address, hi word, lo word, rd bool, wr bool, fcb(33) byte)' 
YFILE$T 'structure(buffer word, bufIdx word, len word, wr byte, fcb(33) byte)'
TABLE$T 'structure(control byte, addr word, value word, link address, offset word)'
SYM$T   'structure(chain address, item byte, offset word, lenFlags byte, lname(1) byte)'
PSTR$T  'structure(len byte, str(1) byte)'

/*  based variables */
wordVal     "word"..wordPtr
cmdCh       B..cmdLinePtr
sym         "SYM$T"..symPtr
table       "TABLE$T"..tPtr
yBuffer     BS..yBufPtr
yFile       "YFILE$T"..yFPtr
xFile       "XFILE$T"..xFPtr



link.plm
link: do;

$include(link.ipx)
/* jmp to main. The -3 forces the sp load to be the target */
declare enter structure(jmp byte, target address) data(0c3h, .main - 3);

declare cpyRight(*) byte data('COPYRIGHT (C) 1980 DIGITAL RESEARCH ');
declare patch(90) byte data(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                            0, 0, 0, 0, 0);

declare serial(*) byte data(7Fh, 0, 3, 0, 0, 1);
declare qMark byte public data('?');
declare additionalMem bool public data(0);
declare bufSizes(4) word data(400h, 2000h, 1800h, 200h);
declare wBufSizes(4) word at(.bufSizes);    /* trick to allow write to data values */

declare cmdLin(128) byte public at(80h);
declare fcb1(32) byte public at(05ch);


declare banner(*) byte initial(0Ch, 'LINK 1.31', LF, CR, '$01/04/83');

declare qMemry(*) byte public initial('?MEMRY');
declare dMemry(*) byte public initial('$MEMRY');
declare MPMMemSize word public initial(0);
declare outType byte public initial(COM$EXT);
declare loadAddress word public initial(100h);
declare biosLink bool public initial(0);
declare needBanner bool initial(TRUE);
declare charOutDev byte public initial('X');
declare intermediateDrive byte public initial(0);
declare libDrive byte public initial(0);
declare dstDrive byte public initial(0);
declare symDrive byte public initial(0);
declare b3979 byte public initial(0);
declare noLeadingQ bool public initial(TRUE);
declare haveSpecialSym bool public initial(0);
declare w397C word public initial(0);
declare objFName(*) byte public initial(0, '           ');
declare baseOutType byte public initial(COM$EXT);
declare w398B word public initial(0);
declare haveOverlays byte public initial(FALSE);
declare syntaxOnly byte initial(0);
declare overlayCnt byte initial(   0);
declare overlayTable(5) structure(loadAddress word, symPtr address);
declare wordPtr word public initial(0);
declare wordVal based wordPtr word;     /* needw to define after wordPtr */
declare topMemory word public initial(0);
declare w39A8 word public initial(0);
declare aMemoryOverflow(*) byte public initial('MEMORY OVERFLOW, USE [A] SWITCH$');
declare aInsufficientMemory(*) byte initial('INSUFFICIENT MEMORY$');
declare aOverlappingSeg(*) byte public initial('OVERLAPPING SEGMENTS$');
/* only used for special symbol processing
   exact usage unknown
*/
declare signature(3) byte public initial(0, 0, 0);
declare IRLWinLow word public initial(0);
declare IRLWinHigh word public initial(0);
declare baseEx byte public initial(0);
declare baseCr byte public initial(0);
declare indexFCB(33) byte public;
declare indexPtr word public initial(0);
declare indexLen word public initial(200h);
declare isIRL byte public initial(0);
declare inFile(*) byte public initial('            ');
declare cmdLinePtr word public initial(0);
declare cmdCh based cmdLinePtr byte;        /* need to define after cmdLinePtr */
declare bitCnt byte public initial(0);
declare IRLPtr word public initial(0);
declare w3A33 word public initial(400h);
declare w3A35 word public initial(0);
declare IRLLen word public initial(400h);
/* modName is only written to */
declare modName(8) byte public initial(0, 0, 0, 0, 0, 0, 0, 0);
declare curAddr word public initial(0);
declare progOrgRequest byte public initial(0);
declare dataOrgRequest byte public initial(0);
declare labelStartAddress byte public initial(0);
declare progOrigin word public initial(0);
declare dataOrigin word public initial(0);
declare startSym(*) byte public initial(0, 0, 0, 0, 0, 0, 0);
declare i3A51 byte public initial(0);
declare transferFlag bool public initial(0);
declare w3A53 word public initial(0);
declare b3A55 byte public initial(0);
declare w3A56 word public initial(0);
declare w3A58 word public initial(0FFFFh);
declare w3A5A word public initial(0);
declare b3A5C byte public initial(0);
declare i3A5D byte public initial(0);
declare b3A5E byte public initial(0);
declare librarySearch bool public initial(0);
declare topSymTable word public initial(0);
declare symTable address public initial(0);
declare symPtr word public initial(0);
declare b3A66 byte public initial(0);
declare curSymValue word public initial(0);
declare symTables(4) word public initial(0, 0, 0, 0);
declare w3A71 word public initial(0);
declare topHeap address public initial(0FFFFh);
declare tPtr word public initial(0);
declare oldBase address public initial(0);
declare chains(4) word public initial(0, 0, 0, 0);
declare lengths(4) word public initial(0, 0, 0, 0);
declare modLengths(4) word public initial(0, 0, 0, 0);
declare starts(4) word public initial(0, 0, 0, 0);
declare objTable(4) byte public initial(0, 1, 2, 3);
declare b3A9D byte public initial(0);
declare b3A9E byte public initial(0);
declare aField word public initial(0);
declare lname(9) byte public initial(0, 0, 0, 0, 0, 0, 0, 0, 0);
declare labLen byte public at(.lname);
declare labName byte public at(.lname + 1);
declare xxabs XFILE$T public initial(0, 0, 0, 0, 1, 0, 0, 0, 0,  'XXABS   $$$', 0, 0, 0, 0, 0, 0);
declare xxprog XFILE$T public initial(0, 0, 0, 0, 1, 0, 0, 0, 0, 'XXPROG  $$$', 0, 0, 0, 0, 0, 0);
declare xxdata XFILE$T public initial(0, 0, 0, 0, 1, 0, 0, 0, 0, 'XXDATA  $$$', 0, 0, 0, 0, 0, 0);
declare xxcomm XFILE$T public initial(0, 0, 0, 0, 1, 0, 0, 0, 0, 'XXCOMM  $$$', 0, 0, 0, 0, 0, 0);
declare xFileTable(4) address public initial(.xxabs, .xxprog, .xxdata, .xxcomm);
declare yyabs YFILE$T public initial(0, 0, 100h, 0, 0,  'YYABS   $$$', 0, 0, 0, 0, 0, 0);
declare yyprog YFILE$T public initial(0, 0, 400h, 0, 0, 'YYPROG  $$$', 0, 0, 0, 0, 0, 0);
declare yydata YFILE$T public initial(0, 0, 400h, 0, 0, 'YYDATA  $$$', 0, 0, 0, 0, 0, 0);
declare yycomm YFILE$T public initial(0, 0, 100h, 0, 0, 'YYCOMM  $$$', 0, 0, 0, 0, 0, 0);
declare yFileTable(4) address public initial(.yyabs, .yyprog, .yydata, .yycomm);




OutCh: procedure (ch);
    declare ch byte;

    if charOutDev = 'X' then
        call CWrite(ch);
    else if charOutDev = 'Y' then
        call LWrite(ch);
end;

OutStr: procedure(str);
    declare str address;
    declare ch based str byte;

    do while ch <> '$';
        call OutCh(ch);
        str = str + 1;
    end;
end;

PrinterBanner: procedure;
    if charOutDev = 'Y' then
    do;
        needBanner = FALSE;
        call OutStr(.banner);
    end;
end;

PutCh: procedure(ch) public;
    declare ch byte;

    if needBanner then
        call PrinterBanner;
    call OutCh(ch);
end;


PutStr: procedure(str) public;
    declare str address;

    if needBanner then
        call PrinterBanner;
    call OutStr(str);
end;


SetMemorySpace: procedure;
    if additionalMem then
    do;
        yyabs.buffer = cmdLinePtr + 1;
        yyprog.buffer = yyabs.buffer + yyabs.len;
        yydata.buffer = yyprog.buffer + yyprog.len;
        yycomm.buffer = yydata.buffer + yydata.len;
    end;
    xxabs.endAddr = bufSizes(ABSOLUTE) - 1;
    xxabs.len = bufSizes(ABSOLUTE);
    if additionalMem then
        xxabs.buf = yycomm.buffer + yycomm.len;
    else
        xxabs.buf = cmdLinePtr + 1;

    xxprog.endAddr = bufSizes(CODEREL) - 1;
    xxprog.len = bufSizes(CODEREL);
    xxprog.buf = xxabs.buf + bufSizes(ABSOLUTE);
    xxdata.endAddr = bufSizes(DATAREL) - 1;
    xxdata.len = bufSizes(DATAREL);
    xxdata.buf = xxprog.buf + bufSizes(CODEREL);
    xxcomm.endAddr = bufSizes(COMMREL) - 1;
    xxcomm.len = bufSizes(COMMREL);
    xxcomm.buf = xxdata.buf + bufSizes(DATAREL);
end;


InitIntermediateTables: procedure;
    do i3A5D = 0 to 3;
        call SelectXFile(xFileTable(i3A5D));
        call ClearTmpBuf;
    end;
end;


SetDrives: procedure;
    xxabs.fcb(FCB$DR), xxprog.fcb(FCB$DR), xxdata.fcb(FCB$DR), xxcomm.fcb(FCB$DR),
    yyabs.fcb(FCB$DR), yyprog.fcb(FCB$DR), yydata.fcb(FCB$DR), yycomm.fcb(FCB$DR) = intermediateDrive;
end;

InitLinker: procedure;
    dataOrgRequest = 0;
    progOrgRequest = 0;
    labelStartAddress = 0;
    loadAddress = 100h;
    MPMMemSize = 0;
    outType = COM$EXT;
    noLeadingQ = TRUE;
    libDrive, symDrive, dstDrive = 0;
    charOutDev = 'X';
end;

InitOverlayFields: procedure;

    chains(ABSOLUTE), chains(CODEREL), chains(DATAREL), chains(COMMREL), lengths(ABSOLUTE),
    lengths(CODEREL), lengths(DATAREL), lengths(COMMREL), modLengths(ABSOLUTE), modLengths(CODEREL),
    modLengths(DATAREL), modLengths(COMMREL), starts(ABSOLUTE), starts(CODEREL), starts(DATAREL),
    starts(COMMREL), symTables(ABSOLUTE), symTables(CODEREL), symTables(DATAREL), symTables(COMMREL),
    objTable(ABSOLUTE) = 0;
    
    objTable(CODEREL) = CODEREL;
    objTable(DATAREL) = DATAREL;
    objTable(COMMREL) = COMMREL;
    w3A71 = topMemory;
    progOrgRequest, dataOrgRequest, labelStartAddress, transferFlag = 0;
    w3A58 = 0ffffh;
    w3A5A  = 0;
    call InitIntermediateTables;
    topHeap = 0ffffh;
    yyabs.bufIdx, yyprog.bufIdx, yydata.bufIdx, yycomm.bufIdx,
    xxabs.startAddr, xxprog.startAddr, xxdata.startAddr, xxcomm.startAddr = 0;
    xxabs.endAddr = bufSizes(ABSOLUTE) - 1;
    xxprog.endAddr = bufSizes(CODEREL) - 1;
    xxdata.endAddr = bufSizes(DATAREL) - 1;
    xxcomm.endAddr = bufSizes(COMMREL) - 1;
    xxabs.hi, xxprog.hi, xxdata.hi, xxcomm.hi = 1;
    xxabs.lo, xxprog.lo, xxdata.lo, xxcomm.lo = 0;
end;


GetSymbolBase: procedure pointer public;
    if overlayCnt = 0 then
        return symTable;
    return overlayTable(overlayCnt - 1).symPtr;
end;

FixOverlayTable: procedure(ptr);
    declare ptr address;
    declare i byte;

    do i = 0 to 127;
        do while hashTable(i) >= ptr;
            symPtr = hashTable(i);
            hashTable(i) = GetChain;
        end;
    end;
end;



PutOverlay: procedure;
    overlayTable(overlayCnt).symPtr = topSymTable;
    loadAddress, overlayTable(overlayCnt).loadAddress = (curAddr + 127) and 0ff80h;
end;

IncOverlayCount: procedure;
    if (overlayCnt := overlayCnt + 1) > 5 then
        call CmdLineError;
end;

GetOverlay: procedure;
    if (overlayCnt := overlayCnt - 1) = 255 then
        call CmdLineError;
    if not syntaxOnly then
        return;
    loadAddress = overlayTable(overlayCnt).loadAddress;
    topSymTable = overlayTable(overlayCnt).symPtr;
    call FixOverlayTable(topSymTable);
end;


SetupOverlay: procedure;

    haveOverlays = TRUE;
    if syntaxOnly then
       call InitOverlayFields; 

    call ParseCmdLine;
    call move(12, .fcb1, .inFile); 
    if inFile(FCB$EXT) = ' ' then
        call move(3, .('OVL'), .infile(FCB$EXT));
    if syntaxOnly then
    do;
        call PutStr(.(CR,LF,CR,LF,'LINKING $'));
        call PutFn(.inFile);
        call PutStr(.(CR,LF,'$'));
    end;
    if cmdCh = '=' then
        call ParseCmdLine;
    if syntaxOnly then
        call ReadRelocatable;

    do while cmdCh <> '(' and cmdCh <> ')';
        if cmdCh <> ',' then
            call CmdLineError;
        call ParseCmdLine;
        if syntaxOnly then
            call ReadRelocatable;
    end;
    if syntaxOnly then
    do;
        call SolveLibRequest;
        call SetExt$OVLA0;
        outType = OVL$EXT;
        call CloseLoadSession;
        call PutOverlay;
    end;
end;

SampleFiles: procedure;

    cmdLinePtr = .cmdLineBuffer; 
    call ParseCmdLine;
    call move(12, .fcb1, .infile);
    if cmdCh = '=' then
        call ParseCmdLine;
    else
        call move(3, .('   '), .infile(FCB$EXT));

    if syntaxOnly then
        call ReadRelocatable;

    do while cmdCh <> 0 and cmdCh <> '(';
        if cmdCh <> ',' then
            call CmdLineError;
        call ParseCmdLine;
        if syntaxOnly then
            call ReadRelocatable;
    end;

    b3979 = dstDrive;
    if syntaxOnly then
    do;
        if haveOverlays then
            call SetExt$OVLAY;
        call SolveLibRequest;
        call Process$FPBNX;
        if haveOverlays then
            call SetExt$OVLA0;

        if outType = RSP$EXT or outType = SPR$EXT then
            loadAddress = 0;

        call CloseLoadSession;
        baseOutType = outType;
        w398B = loadAddress;
        call PutOverlay;
    end;

    if cmdCh = '(' then
        do while cmdCh <> 0;
            call IncOverlayCount;
            call SetupOverlay;
            do while cmdCh = ')';
                call GetOverlay;
                call GetNextNonBlankChar;
            end;
            if cmdCh <> 0 and cmdCh <> '(' then
                call CmdLineError;
        end;
    if overlayCnt <> 0 then
        call CmdLineError;
end;


GetExtraCmdLine: procedure;
    
    call PutCh('*');
    cmdLin(0) = 126;
    call CRdStr(.cmdLin);
    cmdLin(cmdLin(1) + 2) = 0;
x:
    call move(cmdLin(1) + 1, .cmdLin(2), cmdLinePtr + 1);
    call PutCh(CR);
    call PutCh(LF);
end;

BuildCmdLine: procedure;

    cmdLinePtr = .cmdLineBuffer + 1;
    call move(128, .cmdLin, .cmdLineBuffer);

    do while cmdCh <> 0;
        if cmdCh = '&' then
            call GetExtraCmdLine;
        cmdLinePtr = cmdLinePtr + 1;
    end;
end;


main:
    call PutStr(.banner(1));
    call BuildCmdLine;
    syntaxOnly = FALSE;
    call SampleFiles;
    if outType <> COM$EXT and haveOverlays then
        call CmdLineError;

    call InitLinker;
    if additionalMem then
    do;
        wbufSizes(CODEREL), wbufSizes(DATAREL) = 1024;
        wbufSizes(ABSOLUTE), wbufSizes(COMMREL) = 256;
    end;

    call SetMemorySpace;
    wordPtr = 6;
    topMemory, w3A71 = wordVal;

    if intermediateDrive <> 0 then
        call SetDrives;

    call OsSetup;
    topSymTable, symTable = xxcomm.buf + bufSizes(COMMREL);
    if symTable >= w3A71 then
        call Fatal(.aInsufficientMemory);

    w39A8 = w3A71 - topSymTable;
    call InitIntermediateTables;
    syntaxOnly = TRUE;
    call SampleFiles;
    call EndFileProcessing;
    if haveOverlays then
        call TellTopModule;

    call OS;
end;

link0.plm
link0: do;
$include(link0.ipx)

declare delims(*) byte data(CR, ' =.:<>[],()');
declare curChar byte;

ToUpper: procedure(ch) byte;
    declare ch byte;

    if ch < ' ' then
        return CR;
    if (ch - 'a') <= 19h then
        ch = ch and 5fh;
    return ch;
end;

CmdLineError: procedure public;
    declare ptr address;
    declare ch based ptr byte;

    ptr = .cmdLineBuffer + 2;

    do while ptr <= cmdLinePtr;
        call PutCh(ToUpper(ch));
        if ch = '&' then
        do;
            call PutCh(CR);
            call PutCh(LF);
            call PutCh('*');
        end;
        ptr = ptr + 1;
    end;
    call Fatal(.('?$'));
end;

CheckDelim: procedure bool;
    declare i byte;

    do i = 0 to last(delims);
        if curChar = delims(i) then
            return TRUE;
    end;
    return FALSE;
end;

GetNextChar: procedure;
    do while (1);    
        cmdLinePtr = cmdLinePtr + 1;
        if (curChar := ToUpper(cmdCh)) <> '&' then
            return;
    end; 
end; 

GetNextNonBlankChar: procedure public;

    call GetNextChar;
    do while curChar = ' ';
        call GetNextChar;
    end;
end;

ParseFile: procedure word;
    declare (junk, i) byte;

    SaveFCBCh: procedure;
        fcb1(i := i + 1) = curChar;
    end;

    curChar = ' ';
    i = 0;
    junk = 0ffh;

    do while i < 15;
        if i = 11 then
            curChar = 0;
        call SaveFCBCh;
    end;

    fcb1(FCB$DR) = 0;
    
    do while (TRUE);
        call GetNextNonBlankChar;
        if CheckDelim then
            return 0ffffh;
        i = 0;
        do while not CheckDelim;
            if i >= 8 then
                return 0ffffh;
            call SaveFCBCh;
            call GetNextChar;
        end;
        if curChar = ':' then
        do;
            if not (fcb1(FCB$DR) = 0 and i = 1) then
                return 0ffffh;

            if (fcb1(FCB$DR) := (fcb1(FCB$NAME) - 'A') + 1) > 26 then
                return 0ffffh;
            else
                fcb1(i) = ' ';
        end;
        else
        do;
            i = 8;
            if curChar = '.' then
            do;
                call GetNextChar;
                do while not CheckDelim;
                    if i >= 11 then
                        return 0ffffh;
                    call SaveFCBCh;
                    call GetNextChar;
                end;
            end;
            return 0;
        end;
    end;
end;



IsHexChar: procedure bool;
    if (curChar - '0') <= 9 then
    do;
        curChar = curChar - '0';
        return TRUE;
    end;
    else if (curChar - 'A') <= 5 then
    do;
        curChar = (curChar - 'A') + 10;  
        return TRUE;
    end;
    return FALSE;
end;


ParseHex: procedure word;
    declare result word;

    result = 0;
    call GetNextChar;

    do while not CheckDelim;
        if IsHexChar then
            result = result * 16 + curChar;
        else
            call CmdLineError;
        call GetNextChar;
    end;
    return result;
end;

IsValidDrive: procedure bool;
    return (curChar - 'A') <= 15;
end;

GetDrive: procedure byte;
    call GetNextChar;
    if IsValidDrive then
        return (curChar - 'A') + 1;
    call CmdLineError;
end;

GetDriveOrZ: procedure byte;
    call GetNextChar;
    if IsValidDrive then
        return (curChar - 'A') + 1; 
    if curChar = 'Z' then
        return 'Z';
    call CmdLineError;
end;

GetXYZ: procedure byte;
    call GetNextChar;
    if curChar - 'X' <= 2 then
        return curChar;
    call CmdLineError;
end;

ParseOption: procedure;
    do while curChar  <> ']' and curChar <> CR;
        call GetNextNonBlankChar;
        if curChar = 'S' then
        do;
            librarySearch = TRUE;
            call GetNextChar;
        end;
        else if curChar = 'B' then
        do;
            biosLink = TRUE;
            outType = SPR$EXT;
            call GetNextChar;
        end;
        else if curChar = 'P' then
        do;
            progOrgRequest = TRUE;
            progOrigin = ParseHex;
        end;
        else if curChar = 'D' then
        do;
            dataOrgRequest = TRUE;
            dataOrigin = ParseHex;
        end;
        else if curChar = 'L' then
            loadAddress = ParseHex;
        else if curChar = 'M' then
            MPMMemSize = ParseHex;
        else if curChar = 'O' then
        do;
            call GetNextChar;
            if curChar = 'P' then
                outType = PRL$EXT;    /* .PRL */
            else if curChar = 'C' then
                outType = COM$EXT;    /* .COM */
            else if curChar = 'R' then
                outType = RSP$EXT;    /* .RSP */
            else if curChar = 'S' then
                outType = SPR$EXT;    /* .SPR */
            else
                call CmdLineError;
            call GetNextChar;
        end;
        else if curChar = 'A' then
        do;
            additionalMem = TRUE;
            call GetNextChar;
        end;
        else if curChar = 'Q' then
        do;
            noLeadingQ = FALSE;
            call GetNextChar;
        end;
        else if curChar = 'G' then
        do;
            labelStartAddress = TRUE;
            call GetNextChar;
            i3A51 = 0;
            do while not CheckDelim;
                if i3A51 > 5 then
                    call CmdLineError;
                startSym(i3A51) = curChar;
                i3A51 = i3A51 + 1;
                call GetNextChar;
            end;
        end;
        else if curChar = '$' then
        do;
            call GetNextNonBlankChar;
            do while curChar <> ',' and curChar <> ']';
                if curChar = 'C' then
                    charOutDev = GetXYZ;
                else if curChar  = 'I' then
                    intermediateDrive = GetDrive;
                else if curChar = 'L' then
                    libDrive = GetDrive;
                else if curChar = 'O' then
                    dstDrive = GetDriveOrZ;
                else if curChar = 'S' then
                    symDrive = GetDriveOrZ;
                else
                    call CmdLineError;
                Call GetNextNonBlankChar;
            end;
        end;
        else if curChar = 'N' then
        do;
            call GetNextChar;
            if curChar = 'L' then
                charOutDev = 'Z';
            else if curChar = 'R' then
                symDrive = 'Z';
            else
                call CmdLineError;
            call GetNextChar;
        end;
        else
            call CmdLineError;
    end;
    if curChar <> CR then
        call GetNextChar;
end;


ParseCmdLine: procedure public;
    librarySearch = FALSE;
    if ParseFile = 0FFFFh then
        call CmdLineError;
    if curChar = ' ' then
        call GetNextNonBlankChar;
    if curChar = '[' then
        call ParseOption;
    if curChar = ' ' then
        call GetNextNonBlankChar;
end;


RdIndexByte: procedure byte;
    if (indexPtr := indexPtr + 1) >= indexLen then
    do;
        indexPtr = 0;
        call ReadF(.indexBuf, indexLen, .indexFCB);
    end;
    return indexBuf(indexPtr);
end;

declare (fvEx, fvCr, fvOffset) byte;
declare IRLLoc word public;
declare rByte byte;

RdIndexFileValues: procedure;
    fvEx = baseEx + RdIndexByte;
    if (fvCr := baseCr + RdIndexByte) >= 128 then
    do;
        fVCr = fVCr - 128;
        fvEx = fvEX + 1;
    end;
    fvOffset = RdIndexByte;
end;

RdIndexEntry: procedure;
    call RdIndexFileValues;
    lname(0) = 0;
    do while (rByte := RdIndexByte) < 254;
        lname(lname(0) + 1) = rByte;
x:
        if (lname(0) := lname(0) + 1) >= 8 then
            call Fatal(.aIndexError);
    end;
end;

SeekIRL: procedure;
    IRLLoc = fvEx * 128 + fvCr;
    if IRLWinLow <= IRLLoc and IRLLoc <= IRLWinHigh then
        IRLPtr = (IRLLoc - IRLWinLow) * 128 + fvOffset - 1;
    else
    do;
        if fvEx <> fcb1(FCB$EX) then
        do;    
            fcb1(FCB$EX) = fvEx;
            if Open(.fcb1) = 255 then
                call Fatal(.aIndexError);

            fcb1(FCB$CR) = 0ffh;
        end;
        fcb1(FCB$CR) = fvCr;
        call RdBuf;
        IRLPtr = double(fvOffset) - 1;
    end;
end;

LoadIRL: procedure public;
    indexPtr = indexLen;
    call RdIndexEntry;

    do while lname(0) > 0;
        b3A5E = 0;
        call LinkSetEntry;
        if b3A5E then
        do;
            call SeekIRL;
            call LoadOneModule;
        end;
        call RdIndexEntry;
    end;
end;

declare yBufPtr address initial(0);
declare yBuffer based yBufPtr (1) byte;
declare yFPtr address public initial(0);
declare yFile based yFPtr structure(buffer word, bufIdx word, len word, wr byte, fcb(32) byte);

WriteYRecord: procedure;
    if not yFile.wr then
    do;
        call CreatF(.yFile.fcb);
        yFile.wr = TRUE;
    end;
    call WriteF(yFile.buffer,  yFile.len, .yFile.fcb);
end;

WriteYByte: procedure(n);
    declare n byte; 
    
    yBuffer(yFile.bufIdx) = n;
    if (yFile.bufIdx := yFile.bufIdx + 1) >= yFile.len then
    do;
        call WriteYRecord;
        yFile.bufIdx = 0;
    end;  
end;

WriteYWord: procedure(w);
    declare w word;
    
    call WriteYByte(low(w));
    call WriteYByte(high(w));
end;



ReadYRecord: procedure;
    call ReadF(yFile.buffer, yFile.len, .yFile.fcb(FCB$DR));
end;


ReadYByte: procedure byte public;

    if (yFile.bufIdx := yFile.bufIdx + 1) >= yFile.len then
    do;
        call ReadYRecord;
        yFile.bufIdx = 0;
    end;
    return yBuffer(yFile.bufIdx);
end;


ReadYWord: procedure word public;
    return ReadYByte or shl(double(ReadYByte), 8);
end;

SetYFile: procedure(ptr) public;
    declare ptr address;

    yFPtr = ptr;
    yBufPtr = yFile.buffer;
end;

YRewind: procedure public;
    call WriteYByte(0ffh);
    if yFile.wr then
    do;
        do while yFile.bufIdx <> 0;
            call WriteYByte(1ah);
        end;
        call CloseF(.yFile.fcb);
        call OpenF(.yFile.fcb);
        yFile.bufIdx = yFile.len;
    end;
    else
        yFile.bufIdx = 0FFFFh;
end;

GetTAddress: procedure address public;
    return table.addr;
end;

GetTValue: procedure word public;
    return table.value;
end;

GetTLink: procedure word public;
    return table.link;
end;

GetTB2: procedure byte;
    return shr(table.control, 2) and 1;
end;

GetTB3: procedure byte public;
    return shr(table.control, 3) and 1;
end;

GetTB1B0: procedure byte public;
    return table.control and 3;
end;

GetTStatus: procedure byte public;
    return table.control;
end;

GetTOffset: procedure word public;
    return table.offset;
end;

GetBaseLink: procedure address;
    declare t based oldBase TABLE$T;
    return t.link; 
end;

SetTAddress: procedure(addr);
    declare addr address;
    table.addr = addr;
end;

SetTValue: procedure(val) public;
    declare val word;
    table.value = val;
end;

SetTLink: procedure(link);
    declare link address;
    table.link = link;
end;

SetTB2: procedure(n) public;
    declare n byte;
    
    table.control = (table.control and 0fBh) or shl(n and 1, 2);
end;

SetTB3: procedure(n);
    declare n byte;
    
    table.control = (table.control and 0f7h) or shl(n and 1, 3);
end;

SetTB4: procedure(n);
    declare n byte;

    table.control = (table.control and 0efh) or shl(n and 1, 4);
end;

SetTB1B0: procedure(n) public;
    declare n byte;

    table.control = (table.control and 0fch) or (n and 3);
end;

SetTOffset: procedure(offset);
    declare offset word;
    table.offset = offset;
end;


SetBaseLink: procedure(link);
    declare link word;
    declare t based oldBase TABLE$T;
    t.link = link;
end;

declare ii3C45 word;

CntChainLen: procedure(addr, mode) bool public;
    declare addr address, mode byte;
    ii3C45 = 0;
    if (tPtr := symTables(mode)) = 0 then
        return 0;

    do while GetTAddress > addr;
        oldBase = tPtr;
        ii3C45 = ii3C45 + 1;
        if (tPtr := GetTLink) = 0 then
            return 0;
    end;
    return GetTAddress = addr;
end;


MkTRecord: procedure(addrOrChn, ChnOrValue, mode, solveChn, index, offBit, offset, offFlg) public;
    declare (addrOrChn, ChnOrValue, offset) address;
    declare (mode, solveChn, index, offBit, offFlg) byte;
    declare itemSize byte;

    if addrOrChn = 0 and index = 0 then
        return;

    if offBit then
        itemSize = 9; /* size(table_t) */
    else
        itemSize = 7; /* size(sym_t) */

    if (w3A71 := w3A71 - itemSize) < topSymTable then
        call Fatal(.aMemoryOverflow);

    if offFlg then
        if CntChainLen(addrOrChn, index) then
            ;
    tPtr = w3A71;
    table.control = 0;   
    call SetTAddress(addrOrChn);
    if ii3C45 = 0 then
        call SetTLink(symTables(index));
    else
        call SetTLink(GetBaseLink);

    call SetTValue(ChnOrValue);
    if offBit then
        call SetTOffset(offset);

    call SetTB2(solveChn);
    call SetTB1B0(mode);
    call SetTB3(offBit);
    call SetTB4(isMinus);
    if ii3C45 = 0 then
        symTables(index) = w3A71;
    else
        call SetBaseLink(w3A71);
end;


FixTLinkage: procedure public;
    declare i byte, (link, head) address;
    do i = 0 to 3;
        head = 0;
        tPtr = symTables(i);

        do while tPtr <> 0;
            link = GetTLink;
            call SetTLink(head);
            head = tPtr;
            tPtr = link;
        end;
        symTables(i) = head;
    end;
end;

FixLinkageWriteRecord: procedure public;
    declare i byte;

    call FixTLinkage;
    do i = 0 to 3;
        tPtr = symTables(i); 
        call SetYFile(yFileTable(i));
        do while tPtr <> 0;
            call WriteYByte(GetTStatus);
            call WriteYWord(GetTAddress);
            call WriteYWord(GetTValue);
            if GetTB3 then
                call WriteYWord(GetTOffset);
            tPtr = GetTLink;
        end;
    end;
    symTables(ABSOLUTE), symTables(CODEREL), symTables(DATAREL), symTables(COMMREL) = 0;
end;
end;
link1.plm
link1: do;
$include(link1.ipx)

MkTRecord: procedure(addrOrChn, ChnOrValue, mode, solveChn, index, offBit, offset, offFlg) external;
    declare (addrOrChn, ChnOrValue, offset) address;
    declare (mode, solveChn, index, offBit, offFlg) byte;
end;

declare commLenPtr address;
declare commLen based commLenPtr word;
declare hashTable(128) address public;
declare hashIndex byte;

ClrItemLen: procedure;
    sym.item = 0;
    sym.lenFlags = 0;
end;

GetChain: procedure address public;
    return sym.chain;
end;

SetChain: procedure(chain);
    declare chain address;

    sym.chain = chain;
end;

GetSymLength: procedure byte public;
    return sym.lenFlags and 1fh;
end;

SetSymLength: procedure(len);
    declare len byte;

    sym.lenFlags = sym.lenFlags or len;
end;

GetItemLength: procedure byte public;
    return sym.item and 3fh;
end;

SetItemLength: procedure(len);
    declare len byte;

    sym.item = sym.item or len;
end;

GetFixed: procedure byte public;
    return shr(sym.item, 6) and 1;
end;

SetFixed: procedure public;
    sym.item = sym.item or shl(1, 6);
end;

IsLibRequest: procedure bool public;
    return shr(sym.item, 7) and 1;
end;

SetLibRequest: procedure public;
    sym.item = sym.item or shl(1, 7);
end;


GetEntryState: procedure byte public;

    return rol(sym.lenFlags, 1) and 1;
end;

SetEntryState: procedure(state) public;
    declare state byte;

    sym.lenFlags = (sym.lenFlags and 7fh) or shl(state, 7);
end;

GetCommonLength: procedure word public;

    commLenPtr = symPtr + GetItemLength - 2;
    return commLen;
end;

SetCommonLength: procedure(len);
    declare len word;

    commLenPtr = symPtr + GetItemLength - 2;
    commLen = len;
end;


GetCurSymValue: procedure word public;
    return sym.offset;
end;


SetCurSymValue: procedure(value) public;
    declare value word;
    sym.offset = value;
end;


GetSymbolControlBits: procedure byte public;
    return shr(sym.lenFlags, 5) and 3;
end;

SetSymbolControlBits: procedure(n) public;
    declare n byte;

    sym.lenFlags = (sym.lenFlags and 9Fh) or shl(n and 3, 5);
end;

GetHashTableIndex: procedure(namePtr, nameLen);
    declare namePtr address, nameLen byte;
    declare ch based namePtr byte;

    hashIndex = 0;
    do while (nameLen := nameLen - 1) <> 0ffh;
        hashIndex = hashIndex + ch;
        namePtr = namePtr + 1;
    end;
    hashIndex = hashIndex and 7fh;
end;

FindSymbol: procedure(namePtr, nameLen) byte public;
    declare namePtr address, nameLen byte;

    symPtr = GetSymbolBase;

    do while symPtr < topSymTable;
        if IsLibRequest then
            if GetSymLength = nameLen then
                if Strequ(namePtr, .sym.lname, nameLen) then
                    return 1;
        symPtr = symPtr + GetItemLength;
    end;
    /* missing return - likely to return 0 in a */
end;

SearchSymbol: procedure(namePtr, nameLen, includeCommon) bool public;
    declare namePtr address, nameLen byte, includeCommon bool;

    call GetHashTableIndex(namePtr, nameLen);
    symPtr = hashTable(hashIndex);

    do while symPtr <> 0;
        if GetSymLength = nameLen then
            if Strequ(namePtr, .sym.lname, nameLen) then
                if not (GetSymbolCOntroLBits = 3 xor includeCommon) then
                    return TRUE;
            symPtr = GetChain;
    end;
    return FALSE;
end;

InsertSymbol: procedure(namePtr, nameLen, nameValue, controlBits, entryBit, isCommon, sizeCommon) public;
    declare namePtr address, nameLen byte, nameValue word,
            (controlBits, entryBit) byte, isCommon bool, sizeCommon word;
    declare itemLen byte;

    itemLen = nameLen + 6;
    if isCommon then
        itemLen = itemLen + 2;
    symPtr = topSymTable;
    topSymTable = topSymTable + itemLen;
    if topSymTable > w3A71 then
        call Fatal(.aMemoryOverflow);

    call ClrItemLen;
    call GetHashTableIndex(namePtr, nameLen);
    call SetChain(hashTable(hashIndex));
    hashTable(hashIndex) = symPtr;
    call SetItemLength(itemLen); 
    call SetCurSymValue(nameValue);
    call SetEntryState(entryBit);
    call SetSymLength(nameLen);
    call SetSymbolControlBits(controlBits);
    call move(nameLen, namePtr, .sym.lname);
    if isCommon then
        call SetCommonLength(sizeCommon);
    if sym.lname(0) = '#' then
        haveSpecialSym = TRUE;
end;
end;
link2.plm
link2: do;
$include(link2.ipx)
declare curCol byte initial(0);
declare w3D7F word;

declare aModuleTop(*) byte public data(CR, LF, 'MODULE TOP   $');
declare aUndefinedStart(*) byte public data('UNDEFINED START SYMBOL: $');


PrintChWithCnt: procedure(ch);
    declare ch byte;
    call PutCh(ch);
    curCol = curCol + 1;
end;

PutHexNibble: procedure(n);
    declare n byte;
    if n <= 9 then
        call PutCh(n + '0');
    else
        call PutCh((n - 10) + 'A');
end;

PutHexByte: procedure(n);
    declare n byte;
    call PutHexNibble(shr(n, 4));
    call PutHexNibble(n and 0fh);
end;

PutHexWord: procedure(n);
    declare n word;
    call PutHexByte(shr(n, 8));
    call PutHexByte(n and 0ffh);
end;

DeleteYFiles: procedure;
    if yyabs.wr or yyprog.wr or yydata.wr or yycomm.wr then
    do;
        fcb1(FCB$DR) = yyabs.fcb(FCB$DR);
        call move(11, .('YY????  $$$'), .fcb1(FCB$NAME));
        call Delete(.fcb1);
        yyabs.wr = FALSE;
        yyprog.wr = FALSE;
        yydata.wr = FALSE;
        yycomm.wr = FALSE;
    end;
end;


DeleteXFiles: procedure;
    declare i byte, haveFiles bool;

    declare file based w3D7F XFILE$T;
    haveFiles = FALSE;
    do i = 0 to 3;
        w3D7F = xFileTable(i);
        if file.wr then
        do;
            call CloseF(.file.fcb);
            file.wr = FALSE;
            haveFiles =  TRUE;
        end;
    end;
    if haveFiles then
    do;
        fcb1(FCB$DR) = xxabs.fcb(FCB$DR);
        call move(11, .('XX????  $$$'), .fcb1(FCB$NAME));
        call Delete(.fcb1);
    end;
end;

CheckLoadAddresses: procedure;
    if loadAddress + 3 > dataOrigin and dataOrgRequest then
        b3A5C = FALSE;
    else if loadAddress + 3 > progOrigin and progOrgRequest then
        b3A5C = FALSE;
    else if loadAddress + 3 > w3A58 then
        b3A5C = FALSE;
    else if transferFlag then
        if w3A53 = 0 and b3A55 = 1 and not progOrgRequest then
            b3A5C = FALSE;
        else
            b3A5C = TRUE;
    else  if progOrgRequest or labelStartAddress  then
        b3A5C = TRUE;
    else
        b3A5C = FALSE;
end;

SetupSegments: procedure;
    if progOrgRequest then
        starts(CODEREL) = progOrigin;
    else if b3A5C then
        starts(CODEREL) = loadAddress + 3;
    else
        starts(CODEREL) = loadAddress;

    if dataOrgRequest then
        starts(COMMREL) = dataOrigin;
    else
    do;
        starts(COMMREL) = starts(CODEREL) + lengths(CODEREL);
        if biosLink then
            starts(COMMREL) = (starts(COMMREL) + 0ffh) and 0ff00h;
    end;
    starts(DATAREL) =  starts(COMMREL) + lengths(COMMREL);
    if w3A58 < w3A5A then
        chains(ABSOLUTE) = w3A5A - w3A58 + 1;
    else
        chains(ABSOLUTE) =  0;
end;


FixAllObjectTables: procedure;
    declare i byte;

    FixObjectTable:  procedure;
        declare (j, k, m, n) byte;
        j = b3A9D;
        k = 0;
        m = i;

        do while (j := j - 1) <> 0ffh;
            if starts(m) < starts(objTable(k)) then
            do;
                n = objTable(k);
                objTable(k) = m;
                m = n;
            end;
            k = k + 1;
        end;
        objTable(k) = m;
        b3A9D = b3A9D + 1; 
    end;

    b3A9D = 0;
    starts(ABSOLUTE) = w3A58;
    do i = 0 to 3;
        if chains(i) > 0 then
            call FixObjectTable;
    end;
    starts(ABSOLUTE) =  0;
end;




declare w3D8D word, b3D8F byte;
declare b3D90 byte, (w3D91, w3D93, w3D95) word;

FixSymbolValues: procedure;
    symPtr = symTable;

    do while symPtr < topSymTable;
        if not GetFixed and (GetEntryState or haveOverlays) then
        do;
            call SetCurSymValue(GetCurSymValue + starts(GetSymbolControlBits));
            call SetFixed;
        end;
        symPtr = symPtr + GetItemLength;
    end;
end;


CleanYFile: procedure;
    StorePath: procedure(fixup, target);
        declare (fixup, target) word;

        call StoreByteInSeg(fixup, low(target));
        call StoreByteInSeg(fixup + 1, high(target));
    end;

    GetValueFromTable: procedure(ptr) word;
        declare ptr address;
        symPtr = ptr;
        return GetCurSymValue;
    end;




    FixupChainPath: procedure;
        b3D8F = b3D90 and 3;
        if (b3D90 and 4) > 0 then
            w3D8D = GetValueFromTable(w3D93);
        else
            w3D8D = starts(b3D8F) + w3D93;

        if (b3D90 and 8) > 0 then
            if (b3D90 and 10h) > 0 then
                w3D8D = (w3D8D - w3D95) - starts(GetSymbolControlBits);
            else
                w3D8D = w3D8D + w3D95;
        call StorePath(w3D91, w3D8D);
    end;

    do i3A5D = 0 to 3;
        call SelectXFile(xFileTable(i3A5D));
        if additionalMem then
        do;
            call SetYFile(yFileTable(i3A5D));
            call YRewind;
            b3D90 = ReadYByte;
            do while b3D90 <> 0ffh;

                w3D91 = ReadYWord;
                w3D93 = ReadYWord;
                if (b3D90 and 8) > 0 then
                    w3D95 = ReadYWord;
                call FixupChainPath;
                b3D90 = ReadYByte;
            end;
        end;
        else
        do;
            tPtr = symTables(i3A5D);

            do while tPtr <> 0;
                b3D90 = GetTStatus;
                w3D91 = GetTAddress;
                w3D93 = GetTValue;
                if GetTB3 then
                    w3D95 = GetTOffset;
                call FixupChainPath;
                tPtr = GetTLink;
            end;
        end;
    end;
end;




TestValidSymbol: procedure byte public;
    return sym.lname(0) <> 0 and not (sym.lname(0) = qMark and noLeadingQ);
end;

ScanAllLabels: procedure;
    declare b3D9D byte, undefMsg bool, cnt word;

    PositionCursor: procedure(col);
        declare col byte;

        do while curCol < col;
            call PrintChWithCnt(' ');
        end;
    end;

    PrintCurSymbol: procedure;
        do b3D9D = 1 to GetSymLength;
            call PrintChWithCnt(sym.lname(b3D9D - 1));
        end;
    end;

    cnt =  0;
    symPtr = GetSymbolBase;
    do while symPtr < topSymTable;
        if GetEntryState and TestValidSymbol then
        do;
            if (cnt and 3) = 0 then
            do;
                call NewLn;
                curCol = 0;
            end;
            if GetSymbolControlBits = 3 then
                call PrintChWithCnt('/');

            call PrintCurSymbol;
            if GetSymbolControlBits = 3 then
                call PrintChWithCnt('/');

            call PositionCursor((cnt and 3) * 12 + 9);
            if IsLibRequest then
                call PutStr(.('RQST$'));
            else
                call PutHexWord(GetCurSymValue);

            call PrintChWithCnt(' ');
            call PrintChWithCnt(' ');
            call PrintChWithCnt(' ');
            cnt = cnt + 1;
        end;
        symPtr = symPtr + GetItemLength;
    end;

    if cnt > 0 then
        call NewLn;

    undefMsg = TRUE;
    cnt, curCol = 0;
    symPtr = GetSymbolBase;

    do while symPtr < topSymTable;
        if not GetEntryState then
        do;
            if undefMsg then
            do;
                undefMsg = FALSE;
                call PutStr(.(CR, LF, 'UNDEFINED SYMBOLS:', CR, LF, '$'));
            end;

            if (cnt and 7) = 0 then
            do;
                call NewLn;
                curCol = 0;
            end;

            call PrintCurSymbol;
            call PositionCursor(((cnt := cnt + 1) and 7) * 8);
        end;
        symPtr = symPtr + GetItemLength;
    end;

    if cnt >  0 then
        call NewLn;
    call NewLn;
end;



CalcTransferAddress: procedure;
    declare i byte;
    if labelStartAddress then
    do;
        if SearchSymbol(.startSym, i3A51, FALSE) then
            w3A56 = GetCurSymValue;
        else
        do;
            w3A56 =  0;
            call PutStr(.aUndefinedStart);
            do i = 1 to i3A51;
                call PutCh(startSym(i - 1));
            end;
            call NewLn;
        end;
    end;
    else if transferFlag then
        w3A56 = starts(b3A55) + w3A53;
    else if chains(CODEREL) > 0 then
        w3A56 = starts(CODEREL);
    else if w3A58 <> 0ffffh then
        w3A56 = w3A58;
end;

PrintStats: procedure;

    PrintHexValues: procedure(len, start);
        declare (len, start) word;

        call PutHexWord(len);
        if  len = 0 then
            return;
        call PutCh(' ');
        call PutCh('(');
        call PutHexWord(start);
        call PutCh('-');
        call PutHexWord(start + len - 1);
        call PutCh(')');
    end;


    call PutStr(.('ABSOLUTE     $'));
    if w3A58 <= w3A5A then
        call PrintHexValues(w3A5A - w3A58 + 1, w3A58);
    else
        call PrintHexValues(0, 0);

    call NewLn;
    call PutStr(.('CODE SIZE    $'));
    call PrintHexValues(lengths(CODEREL), starts(CODEREL));
    call NewLn;
    call PutStr(.('DATA SIZE    $'));
    call PrintHexValues(lengths(DATAREL), starts(DATAREL));
    call NewLn;
    call PutStr(.('COMMON SIZE  $'));
    call PrintHexValues(lengths(COMMREL), starts(COMMREL));
    call NewLn;
    call PutStr(.('USE FACTOR     $'));
    call PutHexByte((w39A8 - (topHeap - topSymTable)) / (high(w39A8) + 1));
    call NewLn;
end;




TellTopModule: procedure public;
    call PutStr(.aModuleTop);
    call PutHexWord(w397C);
    call NewLn;
end;



CloseLoadSession: procedure public;

    call CheckLoadAddresses;
    call SetupSegments;
    call FixAllObjectTables;
    call FixSymbolValues;
    call CalcTransferAddress;
    call FixTLinkage;
    call CleanYFile;
    if charOutDev <> 'Z' then
        call ScanAllLabels;

    call PrintStats;
    call CloseObjFile;
    if additionalMem then
        call DeleteYFiles;

    if symDrive <> 'Z' then
        call WriteSymFile;
    call DeleteXFiles;
end;
end;
link3.plm
link3: do;
$include(link3.ipx)

declare b3DA7 byte initial(0);
declare isMinus byte public initial(false);
declare aIndexError(*) byte public initial('INDEX ERROR$');
declare aMultipleDefinition(*) byte initial('MULTIPLE DEFINITION: $');
declare aMainModuleError(*) byte initial('MAIN MODULE ERROR$');
declare aFirstCommonNot(*) byte initial('FIRST COMMON NOT LARGEST$');
declare aCommonError(*) byte initial('COMMON ERROR$');
declare aUnrecognizedIt(*) byte initial('UNRECOGNIZED ITEM', CR, LF,'$');

Read16bit: procedure word;
    return RdBits(8) or shl(double(RdBits(8)), 8);
end;


PrintSymbol: procedure;
    declare i byte;
 
    if lname(0) > 0 then
        do i = 1 to lname(0);
            call PutCh(lname((i-1) + 1));
        end;
end;



ReadAField: procedure;
    b3A9E = RdBits(2);
    aField = Read16bit;
end;


ReadBField: procedure;
    declare i byte;
    lname(0) = RdBits(3);
    if lname(0) = 0 then
        lname(0) = 8;

    do i = 1 to lname(0);
        lname((i-1) + 1) = RdBits(8) and 7fh;
    end;
end;


RdBuf: procedure public;
    IRLWinLow = fcb1(FCB$EX) * 128 + fcb1(FCB$CR);
    IRLWinHigh = IRLWinLow + ReadFR(.IRLBuf, IRLLen, .fcb1) - 1;
end;

SelectTmpFile: procedure(n) public;
    declare n byte;
    i3A5D = n;
    call SelectXfile(xFileTable(i3A5D));
end;

SaveConstByte: procedure(n) public;
    declare n byte;

    if i3A5D = 3 and b3A66 then
        return;
    call StoreByteInSeg(chains(i3A5D), n);
    if i3A5D = 0 then
    do;
        if chains(ABSOLUTE) > w3A5A then
            w3A5A = chains(ABSOLUTE);
        if chains(ABSOLUTE) < w3A58 then
            w3A58 = chains(ABSOLUTE);
    end;
    chains(i3A5D) = chains(i3A5D) + 1;
end;

SolveChain: procedure(ptr, chainExt);
    declare ptr address, chainExt bool;
    declare tSeg byte, (tLocation, tValue) word;

    LoadWordFromSegment: procedure word;
        declare w3E23 word, b3E25 byte;

        b3E25 = i3A5D;
        call SelectTmpFile(tSeg);
        w3E23 = LoadByteFromSeg(tLocation) or shl(double(LoadByteFromSeg(tLocation + 1)), 8);
        call SelectTmpFile(b3E25); 
        return w3E23;
    end;

    tLocation = aField + lengths(tSeg := b3A9E);

    do while true;
        do while CntChainLen(tLocation, tSeg); 
            tValue = GetTValue;
            tSeg = GetTB1B0;
            if tSeg = 0 and tValue = 0 then
                tLocation = LoadWordFromSegment;
            else
                tLocation = tValue;
            
            call SetTValue(ptr);
            call SetTB2(chainExt);
            if chainExt = 0 then
                call SetTB1B0(i3A5D);
        end;
        call MkTRecord(tLocation, ptr, i3A5D, chainExt, tSeg, 0, 0, 0);
        if b3DA7 then
        do;
            if (tValue :=  LoadWordFromSegment) = 0 then
                return;
            else
            do;
                tLocation = tValue;
                tSeg = 0;
            end;
        end;
        else
            return;
    end;
end;



ClearSpecialSymbols: procedure;

    symPtr = symTable;
    do while symPtr < topSymTable;
        if sym.lname(0) = '#' then
            sym.lname(0) = 0;
        symPtr = symPtr + GetItemLength;
    end;
    haveSpecialSym = FALSE;
end;

declare sName(8) byte at(.lname + 1);
declare sLen byte at(.lname);

LinkSetEntry: procedure public;
    if SearchSymbol(.labName, LabLen, FALSE) then
        if not GetEntryState then
            b3A5E = TRUE;
end;

LinkSetCommon: procedure;
    if SearchSymbol(.labName , labLen, TRUE) then
    do;
        curSymValue = GetCurSymValue;
        b3A66 = GetFixed;
    end;
    else
        call Fatal(.aCommonError);
end;

LinkModuleName: procedure;
    call move(lname(0), .lname(1), .modName(1));
    modName(0) = lname(0);
end;

LinkLibRequest: procedure;
    if not FindSymbol(.labName, labLen) then
    do;
        call InsertSymbol(.labName, labLen, 0, 0, 1, 0, 0);
    call SetLibRequest;
    end;
end;

LinkCommonSize: procedure;
    if SearchSymbol(.labName, labLen, TRUE) then
    do;
        if GetCommonLength < aField then
        do;
            call PutCh('/');
            call PrintSymbol;
            call PutCh('/');
            call PutCh(' ');
            call PutStr(.aFirstCommonNot);
            call NewLn;
        end;
    end;
    else
    do;
        call InsertSymbol(.labName, labLen, lengths(COMMREL) + modLengths(COMMREL), 3, 1, 1, aField);
        modLengths(COMMREL) = modLengths(COMMREL) + aField;
    end;
end;

LinkChainExternal: procedure;
    if not SearchSymbol(.labName, labLen, FALSE) then
        call InsertSymbol(.labName, labLen, 0, 0, 0, 0, 0);
    call SolveChain(symPtr, TRUE);
end;


LinkEntryPoint: procedure;
    if SearchSymbol(.labName, labLen, FALSE) then
    do;
        if GetEntryState then
        do;
            call PutStr(.aMultipleDefinition);
            call PrintSymbol;
            call NewLn;
        end;
        else
        do;
            call SetCurSymValue(lengths(b3A9E) + aField);
            call SetEntryState(1);
            call SetSymbolControlBits(b3A9E);
        end;
    end;
    else
        call InsertSymbol(.labName, labLen, aField + lengths(b3A9E), b3A9E, 1, 0, 0);
end;

LinkExternalPlus: procedure;
    call MkTRecord(chains(i3A5D), 0, 0, 0, i3A5D, 1, aField, 1);
end;

LinkExternalMinus: procedure;
    isMinus = TRUE;
    call LinkExternalPlus;
    isMinus = FALSE;
end;

LinkDsegSize: procedure;
    modLengths(DATAREL) = aField;
end;


LinkSetLocationCounter: procedure;
    call SelectTmpFile(b3A9E);
    if i3A5D = 3 then
        chains(COMMREL) = aField + curSymValue;
    else
        chains(i3A5D)  = aField + lengths(i3A5D);
    if i3A5D = 0 then
        b3DA7 = 1;
end;

LinkChainAddress: procedure;
    call SolveChain(chains(i3A5D), FALSE);
end;


LinkCsegSize: procedure;
    modLengths(CODEREL) = aField;
end;

LinkEndModule: procedure;
    declare i byte;

    if aField > 0 or b3A9E <> 0 then
        if transferFlag then
            call Fatal(.aMainModuleError);
        else
        do;
            w3A53 = lengths(b3A9E) + aField;
            b3A55 = b3A9E;
            transferFlag = 1;
        end;

    do while bitCnt <> 8;
        if RdBits(1) then
            ;
    end;

    do i = 1 to 3;
        lengths(i), chains(i) = lengths(i) + modLengths(i);
        modLengths(i) = 0;
    end;

    if w3A71 < topHeap then
        topHeap = w3A71;

    if additionalMem then
    do;
        call FixLinkageWriteRecord;
        w3A71 = topMemory;
    end;

    call SelectTmpFile(1);
    b3A5E = not librarySearch;
    if haveSpecialSym then
        call ClearSpecialSymbols;
end;

Store16BitLength: procedure(val, mode);
    declare val word, mode byte;

    if mode = 3 then
    do;
        val = val + curSymValue;
        if b3A66 then
            mode = 0;
    end;
    else
        val = val + lengths(mode);

    if CntChainLen(chains(i3A5D), i3A5D) then
    do;
        call SetTValue(val);
        call SetTB1B0(mode);
    end;
    else
        call MkTRecord(chains(i3A5D), val, mode, 0, i3A5D, 0, 0, 0);

    call SaveConstByte(0);
    call SaveConstByte(0);
end;


ReadLinkItem: procedure(item);
    declare item byte;

    if item >= 5 then
        call ReadAField;
    if item <= 7 then
        call ReadBField;
    if item = 0 then
        call LinkSetEntry;
    else if item = 2 then
        call LinkModuleName;
    else if item = 14 then
        call LinkEndModule;
    else if b3A5E then
        do case item - 1;
        call LinkSetCommon;     /* case 0 */
        ;
        call LinkLibRequest;    /* case 2 */
        call PutStr(.aUnrecognizedIt);
        call LinkCommonSize;
        call LinkChainExternal;
        call LinkEntryPoint;
        call LinkExternalMinus;
        call LinkExternalPlus;
        call LinkDsegSize;
        call LinkSetLocationCounter;
        call LinkChainAddress;
        call LinkCsegSize;
        end;
end;


ReadItem: procedure byte;
    declare (special, rel, val8) byte, val16 word;

    special = 16;
    if RdBits(1) = 0 then
    do;
        val8 = RdBits(8);
        if b3A5E then
            call SaveConstByte(val8);
    end;
    else if (rel := RdBits(2)) = 0 then
    do;
        special = RdBits(4);
        if special < 15 then
            call ReadLinkItem(special); 
    end;
    else
    do;
        val16 = Read16bit;
        if b3A5E then
            call Store16BitLength(val16, rel);
    end;
    return special; 
end;

LoadRelFile: procedure;
   do while ReadItem <> 15;
   end;
end;


LoadOneModule: procedure public;
    bitCnt = 8;
    do while ReadItem <> 14;
    end;
end;

ExecRead: procedure;
    bitCnt = 8;
    IRLPtr, IRLLen =  400h;
    if isIRL then
    do;
    IRLPtr, IRLLen = 400h - indexLen;

    call move(32, .fcb1, .indexFCB);
    if (baseEx := RdBits(8)) <> fcb1(FCB$EX) then
    do;
        fcb1(FCB$EX) = baseEx;
        if Open(.fcb1) = 255 then
            call IOErr(.aIndexError, .fcb1);
    end;

    fcb1(FCB$CR), baseCr = RdBits(8);
    indexFCB(FCB$CR) = 1;
    IRLPtr = IRLLen;
    IRLWinLow, IRLWinHigh =  0;
    end;

    call SelectTmpFile(1);
    b3A5E = not librarySearch;
    if librarySearch and isIRL then
        call LoadIRL;
    else
        call LoadRelFile;
end;


ReadRelocatable: procedure public;
    if (fcb1(FCB$EXT) and 7fh) = ' ' then
        call move(3, .('REL'), .fcb1(FCB$EXT));
    isIRL = Strequ(.('IRL'), .fcb1(FCB$EXT), 3);
    call OpenF(.fcb1);
    call ExecRead;
end;



declare aOvlay(*) byte data('?OVLAY');
declare aOvla0(*) byte data('?OVLA0');


SetExt$OVLAY: procedure  public;

    if not SearchSymbol(.aOvlay, 6, 0) then
        call InsertSymbol(.aOvlay, 6, 0, 1, 0, 0, 0);
end;

SolveLibRequest: procedure public;
    declare i byte, tmpPtr address;

    symPtr = getSymbolBase;

    do while symPtr < topSymTable;
        if IsLibRequest then
        do;
            fcb1(FCB$DR) = libDrive;
            do i = 1 to 8;
                if i > GetSymLength then
                    fcb1(i) = ' ';
                else
                    fcb1(i) = sym.lname(i - 1);
            end;

            isIRL = 1;
            call move(3, .('IRL'), .fcb1(FCB$EXT));
            if not ExistF(.fcb1) then
            do;
                isIRL = 0;
                call move(3, .('REL'), .fcb1(FCB$EXT));
                call OpenF(.fcb1);
            end;
            tmpPtr = symPtr;
            librarySearch = TRUE;
            call ExecRead;
            symPtr = tmpPtr;
        end;
        symPtr = symPtr + GetItemLength;
    end;
end;



SetExt$OVLA0: procedure public;
    declare i byte, tmpPtr address;

    call move(6, .aOvla0, .lname(1));
    lname(0) = 6;
    b3A9E = 1;
    call SelectTmpFile(1);
    symPtr = GetSymbolBase;

    do while symPtr < topSymTable;
        if not GetEntryState then
        do;
            call SetCurSymValue(chains(CODEREL));
            call SetSymbolControlBits(1);
            call SaveConstByte(1);
            call Store16BitLength(6, 1);
            call SaveConstByte(0c3h);   /* jmp */
            aField= 4;
            call SaveConstByte(0);
            call SaveConstByte(0);
            tmpPtr = symPtr;
            call LinkChainExternal;
            symPtr = tmpPtr;

            do i = 1 to 8;
                if GetSymLength >= i then
                    call SaveConstByte(sym.lname(i - 1));
                else 
                    call SaveConstByte(' ');
            end;

            lengths(CODEREL) = lengths(CODEREL) + 14;
            if additionalMem then
            do;
                call FixLinkageWriteRecord;
                w3A71 = topMemory;
            end;
        end;
        symPtr = symPtr + GetItemLength;
    end;
end;
end;

relasm.asm
    name    relasm
    public  RdBits, StrEqu, ClrBuf
    extrn   bitCnt, RdBuf, IRLBuf, IRLPtr, IRLLen

    DSEG
IRLByt:  db  0
    CSEG

; RdBits(cnt) byte;

RdBits:
    mvi     b, 0

nbit1:
    lxi     h, bitCnt
    inr     m
    mov     a, m
    cpi     9
    jc      nbit3           ; still processing current byte for bit stream
    mvi     m, 1            ; reset
    lhld    IRLPtr          ; advance to next byte
    inx     h
    shld    IRLPtr
    xchg
    lhld    IRLLen
    mov     a, e
    sub     l
    mov     a, d
    sbb     h
    jc      nbit2           ; jmp if still in buffer
    lxi     h, 0
    shld    IRLPtr          ; reset to start of buffer
    push    b
    call    RdBuf           ; get next butter
    pop     b

nbit2:
    lhld    IRLPtr          ; get next byte to process
    xchg
    lxi     h, IRLBuf
    dad     d
    mov     a, m
    sta     IRLByt

nbit3:
    mov     a, b
    rlc                     ; shr current value
    ani     0feh
    mov     b, a
    lda     IRLByt          ; get next bit
    rlc
    sta     IRLByt
    ani     1               ; mask off
    ora     b               ; and add to current value
    mov     b, a
    dcr     c
    jnz     nbit1
    mov     a, b            ; return result
    ret

; StrEqu(str1, str2, len) bool public
StrEqu:
    mov     a, e        ; a= length, bc = str2
    pop     h           ; hl = str1
    xthl
    mov     e, a

str1:
    ldax    b
    cmp     m
    jnz     str2
    inx     b
    inx     h
    dcr     e
    jnz     str1
    mvi     a, 1
    ret

str2:
    xra     a
    ret

; ClrBuf(ptr, len) public
ClrBuf:
    mov     h, b        ; hl = ptr
    mov     l, c
    mvi     c, 0        ; fill value

clr1:
    mov     m, c
    dcx     d
    inx     h
    mov     a, d        ; check if done
    ora     e
    jnz     clr1
    ret

    end

link4.plm
link4: do;
$include(link4.ipx)

declare b3E37 byte initial(0);
declare b3E38 byte initial(0);
declare w3E39 word initial(0);

declare extents(5) structure(ext(3) byte) data('COM', 'PRL', 'RSP', 'SPR', 'OVL');

WriteChar: procedure(ch);
    declare ch byte;

    IRLBuf(w3A35) = ch;

    if (w3A35 := w3A35 + 1) >= w3A33 then
    do;
        call WriteF(.IRLBuf, w3A33, .fcb1);
        w3A35 = 0;
    end;
end;

WriteToBitMap: procedure(n);
    declare n byte;

    b3E38 = rol(b3E38, 1) or n;
    if (b3E37 := b3E37 + 1) = 8 then
    do;
        b3E37 = 0;
        call WriteChar(b3E38);
        b3E38 = 0;
    end;
end;

WriteByteWithUpdate: procedure(n);
    declare n byte;
    call WriteChar(n); 
    curAddr = curAddr + 1;
end;

WriteWordWithUpdate: procedure(n);
    declare n word;
    call WriteByteWithUpdate(low(n));
    call WriteByteWithUpdate(high(n));
end;


BuildObjectFile: procedure;
    declare i byte;

    declare curOff word;

    WriteCSeg: procedure(seg);
        declare seg byte;
        declare addr word;

        WriteSegment: procedure(n);
            declare n word;
            declare i word;

            do i = n to chains(seg) + n - 1;
                call WriteByteWithUpdate(LoadByteFromSeg(i));
            end;
        end;

        if seg = 0 then
            addr = w3A58;
        else
            addr = starts(seg);
        if curAddr > addr then
            call Fatal(.aOverlappingSeg);

        do while curAddr < addr;
            call WriteByteWithUpdate(0);
        end;

        call SelectXFile(xFileTable(seg));
        if chains(seg) > 0 then
            if seg = 0 then
                call WriteSegment(w3A58);
            else
            call WriteSegment(0);
        if curAddr > w397C then
            w397C = curAddr;
    end;



    BuildPrefixPage: procedure;
        declare i byte;

        curOff = starts(objTable(b3A9D - 1)) + chains(objTable(b3A9D - 1)) - loadAddress;
        call WriteByteWithUpdate(0);
        call WriteWordWithUpdate(curOff);
        call WriteByteWithUpdate(0);
        if outType = OVL$EXT then
        do;
            call WriteWordWithUpdate(0);
            call WriteByteWithUpdate(0);
            call WriteWordWithUpdate(loadAddress);
        end;
        else
        do;
            call WriteWordWithUpdate(MPMMemSize);
            call WriteByteWithUpdate(0);
            call WriteWordWithUpdate(0);
        end;

        call WriteByteWithUpdate(0);
        if biosLink then
            call WriteWordWithUpdate(lengths(CODEREL));
        else
            call WriteWordWithUpdate(0);

        do i = 1 to 244;
            call WriteByteWithUpdate(0);
        end;

    end;


    BuildBitMap: procedure;
        declare (seg, i) byte, addr word;

        WriteBitToBitMap: procedure(n);
            declare n  byte;

            call WriteToBitMap(n);
            curAddr = curAddr + 1;
        end;


        WriteRelocatableBits: procedure;
            do while curAddr <= addr;
                call WriteBitToBitMap(0);
            end;
            call WriteBitToBitMap(1);
        end;


        BuildSimpleBitMap: procedure;
            tPtr = symTables(seg);

            do while tPtr <> 0;
                addr = GetTAddress + starts(seg);
                call WriteRelocatableBits;
                tPtr = GetTLink;
            end;
        end;



        BuildExtendedBitMap: procedure;
            declare yByte byte;

            call SetYFile(yFileTable(seg));
            if yFile.wr then
            do;
                call OpenF(.yFile.fcb);
                yFile.bufIdx = yFile.Len;
            end;
            else
                yFile.bufIdx = 0ffffh;

            yByte = ReadYByte;

            do while ybyte <> 255;
                addr = ReadYWord + starts(seg);
                wordPtr = ReadYWord;
                if (ybyte and 8) > 0 then
                    wordPtr = ReadYWord;
                call WriteRelocatableBits;
                yByte = ReadYByte;
            end;
        end;


        curAddr = loadAddress;
        if b3A5C then
        do;
            call WriteBitToBitMap(0);
            call WriteBitToBitMap(0);
            call WriteBitToBitMap(1);
        end;
        do i = 0 to b3A9D - 1;
            if (seg := objTable(i)) <> 0 then
            do;
                do while starts(seg) > curAddr;
                    call WriteBitToBitMap(0);
                end;
            if additionalMem then
                call BuildExtendedBitMap;
            else
                call BuildSimpleBitMap;
            end;

        end;

        do while curAddr < curOff + loadAddress;
            call WriteBitToBitMap(0);
        end;
        do while b3E37 <> 0;
            call WriteBitToBitMap(0);
        end;
    end;


    if b3A9D = 0 then
        return;

    if outType <> COM$EXT then
        call BuildPrefixPage;

    curAddr = loadAddress;
    if b3A5C then
    do;
        call WriteByteWithUpdate(0c3h);
        call WriteWordWithUpdate(w3A56);
    end;

    starts(ABSOLUTE) = w3A58;
    do i = 0 to b3A9D - 1;
        if starts(objTable(i)) >= loadAddress then
            call WriteCSeg(objTable(i));
    end;

    if outType <> COM$EXT and outType <> OVL$EXT then
        call BuildBitMap;
end;


CloseRelFile: procedure;
    do while (w3A35 and 7fh) <> 0;
        call WriteChar(1Ah);
    end;
    call WriteF(.IRLBuf, w3A35, .fcb1);
    call CloseF(.fcb1);
end;


CloseObjFile: procedure public;
    if dstDrive = 'Z' then
        return;

    call move(12, .inFile, .fcb1);
    if fcb1(FCB$EXT) = ' ' then
        call move(3, .extents + 3 * outType, .fcb1(FCB$EXT));
    if dstDrive <> 0 then
        fcb1(FCB$DR) = dstDrive;

    call CreatF(.fcb1);
    if objFName(FCB$NAME) = ' ' then
        call move(12, .fcb1, .objFName);

    w3A35, b3E38, b3E37 =  0;
    call BuildObjectFile;
    call CloseRelFile;
end;

WriteSymFile: procedure public;
    declare (i, cnt) byte;


    WriteHexNibbleToSymFile: procedure(n);
        declare n byte;
        if n <= 9 then
            call WriteChar(n + '0');
        else
            call WriteChar((n - 10) + 'A');
    end;

    WriteHexByteToSymFile: procedure(n);
        declare n byte;
        call WriteHexNibbleToSymFile(shr(n, 4));
        call WriteHexNibbleToSymFile(n and 0fh);
    end;
        
    WriteHexWordToSymFile: procedure(n);
        declare n word;
        
        call WriteHexByteToSymFile(high(n));
        call WriteHexByteToSymFile(low(n));
    end;

    if symDrive = 'Z' then
        return;
    call move(9, .inFile, .fcb1);
    call move(3, .('SYM'), .fcb1(FCB$EXT));
    if symDrive <> 0 then
        fcb1(FCB$DR) = symDrive;
    call CreatF(.fcb1);
    w3A35, cnt = 0;
    symPtr = GetSymbolBase;

    do while symPtr < topSymTable;
        if not IsLibRequest and TestValidSymbol then
        do;
            call WriteHexWordToSymFile(GetCurSymValue);
            call WriteChar(' ');
            do i = 1 to GetSymLength;
                call WriteChar(sym.lname(i - 1));
            end;
            if ((cnt := cnt + 1) and 3) = 0 then
            do;
                call WriteChar(CR);
                call WriteChar(LF);
            end;
            else
                call WriteChar(TAB);
        end;
        symPtr = symPtr + GetItemLength;
    end;
    call WriteChar(CR);
    call WriteChar(LF);
    call CloseRelFile;
end;


PositionEndMem: procedure;
    declare recCnt word, extent byte;

    recCnt =  w3E39 / 128;
    extent = recCnt / 128;
    if extent <> fcb1(FCB$EX) then
    do;
        fcb1(FCB$EX) = extent;
        if Open(.fcb1) = 255 then
            call IOErr(.aNoFil, .fcb1);
    end; 
    fcb1(FCB$CR) = recCnt mod 128;
end;

ProcessEndMem: procedure;
    declare recCnt byte;


    w3E39 = GetCurSymValue - w398B;
    call move(12, .objFName, .fcb1);
    if baseOutType <> COM$EXT then
        w3E39 = w3E39 + 100h;

    call OpenF(.fcb1);
    call PositionEndMem;
    recCnt = ReadFR(.MEMORY, 256, .fcb1);
    wordPtr = .MEMORY + w3E39 mod 128;
    wordVal = w397C;    
    call PositionEndMem;
    call WriteF(.MEMORY, recCnt * 128, .fcb1);
    fcb1(FCB$S2) = fcb1(FCB$S2) and 7fh;
    call CloseF(.fcb1);
end;



EndFileProcessing: procedure public;
    if haveOverlays then
        w397C = (w397C + 7fh) and 0ff80h;
    if b3979 = 'Z' then
        return;
    if SearchSymbol(.qMemry, 6, 0) then
        call ProcessEndMem;
    else if SearchSymbol(.dMemry, 6, 0) then
        call ProcessEndMem;
end;
end;
link5.plm
link5: do;
$include(link5.ipx)

declare xFPtr address public;
declare xFile based xFPtr structure(startAddr word, endAddr word, len word, buf address,
                                    hi word, lo word, rd bool, wr bool, fcb(32) byte);
declare w3E5D address public;

SetXCr: procedure(n);
    declare n byte;
    xFile.fcb(FCB$CR) = n;
end;

GetXEx: procedure byte;
    return xFile.fcb(FCB$EX);
end;

SetXEx: procedure(ex);
    declare ex byte;
    xFile.fcb(FCB$EX) = ex;
end;

ClearTmpBuf: procedure public;
    call ClrBuf(xFile.buf, xFile.len);
    xFile.rd = 0;
end;


SeekXTmpFile: procedure public;
    declare ex byte, recCnt word;
    recCnt = xFile.startAddr / 128;
    ex = recCnt / 128;

    if ex <> GetXEx then
    do;
        call CloseF(.xFile.fcb);
        call SetXEx(ex);
        if Open(.xfile.fcb) = 0ffh then
            call MakeF(.xfile.fcb); /* doesn't exist */
    end;
    call SetXCr(recCnt mod 128);
end;


WriteRecordsXTmp: procedure public;
    if xFile.hi > xFile.lo then
        xFile.lo = xFile.hi;

    if not xFile.wr then
    do;
        call CreatF(.xFile.fcb);
        xFile.wr = 1;
    end;
    call SeekXTmpFile;
    call WriteF(xFile.buf, xFile.len, .xFile.fcb);
    call ClearTmpBuf;
end;
end;
link6.plm
link6: do;
$include(link6.ipx)

FixXBuffers: procedure(n);  /* checked */
    declare n word;

    xFile.startAddr = (n / xFile.len) * xFile.len;
    xFile.endAddr = xFile.startAddr + xFile.len - 1;
    xFile.hi = (xfile.startAddr / xFile.len) + 1;
end;


WriteXFile: procedure;
    declare (i, lo, hi) word;
 
    lo = xFile.lo + 1;
    hi = xFile.hi - 1;
    do i = lo to hi;
        call FixXBuffers((i - 1) * xFile.len);
        call WriteRecordsXTmp;
    end;
    call FixXBuffers(xFile.len * hi);
end;

ReadXFile: procedure;
    if xFile.hi > xFile.lo then
        return;
    call SeekXTmpFile;
    call ReadF(xFile.buf, xFile.len, .xFile.fcb);
end;


RwInWindow: procedure(addr, wr) public;
    declare addr word, wr bool;

    if addr < xFile.startAddr then 
    do;
        if xFile.rd then
            call WriteRecordsXTmp;
        call FixXBuffers(addr);
        call ReadXFile;
    end;
    else
    do;
        if xFile.endAddr < addr then
        do;
            if xFile.rd then
                call WriteRecordsXTmp;

            call FixXBuffers(addr);
            if wr then
            do;
                if xFile.hi > xFile.lo + 1 then
                    call WriteXFile;
                else
                    call ReadXFile;
            end;
            else
            do;
                if xFile.hi > xFile.lo then
                    call ClearTmpBuf;
                else
                    call ReadXFile;
            end;
        end;
    end;
end;

SelectXFile: procedure(fPtr) public;
    declare fPtr address;
    xFPtr = fPtr;
end;

StoreByteInSeg: procedure(addr, val) public;
    declare addr word, val byte;
    declare ba based w3E5D (1) byte;

    call RwInWindow(addr, TRUE);
    w3E5D = xFile.buf;
    ba(addr mod xFile.len) = val;
    xFile.rd = 1;
end;

LoadByteFromSeg: procedure(addr) byte public;
    declare addr word;
    declare ba based w3E5D (1) byte;

    call RwInWindow(addr, FALSE);
    w3E5D = xFile.buf;
    return ba(addr mod xFile.len);
end;
end;

file.asm
    name util2

    public Close, CloseF, ClrFCB, CRdStr, CreatF, CStat
    public CWrite, Delete, ExistF, Fatal, getVer, IOErr
    public LWrite, Make, MakeF, MPMSys, NewLn, Open
    public OpenF, PutFn, Read, ReadF, ReadFR, Rename
    public SetDMA, Write, WriteF
    public OS, cpm, aNoFil

    extrn  PutCh, PutStr, cmdLin

    ASEG
    org 0
OS:
    org 5
cpm:

    CSEG
RD  equ 0
WR  equ 1
CR  equ 0dh
LF  equ 0ah

; PutFn(fcbPtr) public
PutFn: 
    mvi     e, 8+3          ; file + ext name length
    inx     b
putfn1:
    ldax    b
    ani     7fh
    cpi     ' '
    cnz     putchA
    dcr     e
    rz
    inx     b
    mov     a, e
    cpi     3
    mvi     a, '.'
    cz      putchA          ; put . at extent
    jmp     putfn1


putchA:                     ; put char preserving registers
    push    b
    push    d
    mov     c, a
    call    PutCh
    pop     d
    pop     b
    ret


; IOErr(msg, fname) public
IOErr: 
    push    d
    call    PutStr      ; putStr(msg)
    pop     b
    call    PutFn       ; putFn(fname)
    lxi     b, aNull
    call Fatal        ; exit without additional msg


; CreatF(fcbptr) public
CreatF:
    push    b
    call Delete
    pop     b
    push    b
    call ClrFCB
    pop     b           ; fall through to make new file

; MakeF(fcbptr) public;
MakeF:                                  ; CODE XREF: seekXTmpFile+4F↑p
    call Make
    inr     a
    rnz
    lxi     b, aFull     ; "NO SPACE$"
    call Fatal

; ExistF(fcbptr) bool public;
ExistF:                                ; CODE XREF: solveLibRequest+84↑p
    push    b
    call ClrFCB
    pop     b
    call Open
    inr     a
    rz
    mvi     a, 1
    ret

; OpenF(fcbPtr) public
OpenF:
    push    b
    call ClrFCB             ; clear non name parts of FCB
    pop     b
    push    b
    call Open               ; get CPM to open it
    inr     a
    pop     d
    rnz                     ; error if cannot be opened
    lxi     b, aNoFil      ; "NO FILE: $"
    call IOErr


; CloseF(fcbPtr) public
CloseF:
    call Close
    inr     a
    rnz
    lxi     b, aNoCls
    call Fatal


; ClrFCB(fcbPtr) public
ClrFCB:
    lxi     h, 0Ch      ; past name & drive
    dad     b
    xra     a
    mvi     c, 21       ; clear remaining 21 bytes

clr1:
    mov     m, a
    dcr     c
    inx     h
    jnz     clr1
    ret


; ReadF(byte *buf, word len, byte *fcb) public
; ReadFR(byte *buf, word len, byte *fcb) word public

ReadF:
ReadFR:
    mvi     a, RD
    jmp     rwFile


; WriteF(byte *buf, word len, byte *fcb) word public

WriteF:
    mvi     a, WR

rwFile:
    sta     ioMode
    pop     h
    xthl
    shld    bufPtr
    xchg
    shld    fcbPtr
    mov     a, c
    ani     80h
    mov     l, a
    mov     h, b
    shld    rwBlks           ; len / 128 * 128
    lxi     h,0
    shld    rwCnt
    call    CStat     ; see if user abort
    rar
    lxi     b, aAbort     ; "ABORTED$"
    cc      Fatal

rw1:
    lhld    rwBlks          ; last block ?
    mov     a, h
    ora     l
    jz      rw4
    lxi     b, -128         ; account for this block
    dad     b
    shld    rwBlks
    lhld    bufPtr          ; set transfer address
    mov     c, l
    mov     b, h
    call SetDMA
    lhld    fcbPtr
    mov     b, h
    mov     c, l
    lda     ioMode          ; read or write?
    cpi     0
    jz      rw2
    call Write
    ora     a
    lxi     b, aWrErr ; "DISK WRITE ERROR"
    cnz     Fatal
    jmp     rw3

rw2:
    call    Read
    ora     a
    jz      rw3             ; ok so transfer next block
    lhld    rwCnt           ; run out file?
    mov     a, h
    ora     l
    jnz     rw4             ; done if so
    lxi     b, aRdErr ; "DISK READ ERROR: "
    lhld    fcbPtr
    xchg
    call IOErr

rw3:
    lhld    bufPtr          ; update transfer address
    lxi     d, 128
    dad     d
    shld    bufPtr
    lhld    rwCnt
    inx     h
    shld    rwCnt
    jmp     rw1

rw4:
    lxi     b, cmdLin       ; reset to default transfer address
    call SetDMA
    lhld    rwCnt           ; return blocks transferred
    ret

; inline data
    
bufPtr: dw  0
fcbPtr: dw  0
rwBlks: dw  0
        dw  0               ; unused
rwCnt:  dw  0
ioMode: db  0
aAbort: db  'ABORTED$'
aFull:  db  'NO SPACE$'
aNoFil: db  'NO FILE: $'
aNoCls: db  'CANNOT CLOSE$'
aRdErr: db  'DISK READ ERROR: $'
aWrErr: db  'DISK WRITE ERROR'
aNull:  db  '$'

; CP/M interface

CONWR  equ 2
LISTWR  equ 5
CREADS  equ 10
COSTAT   equ 11
SVER    equ 12
FOPEN   equ 15
FCLOSE  equ 16
FDEL    equ 19
FREAD   equ 20
FWRITE  equ 21
FMAKE   equ 22
FREN    equ 23
FDMA    equ 26
MPMDAT  equ 154

; CWrite(ch) public
CWrite:
    mov     e, c
    mvi     c, CONWR
    jmp     cpm

; LWrite(ch) public
LWrite:
    mov     e, c
    mvi     c, LISTWR
    jmp     cpm

; CRdStr(buf) public
CRdStr:                                ; CODE XREF: getExtraCmdLine+D↑p
    mov     e, c
    mov     d, b
    mvi     c, CREADS
    jmp     cpm

; CStat byte public
CStat:
    mvi     c, COSTAT
    jmp     cpm

; getVer byte public
GetVer:
    mvi     c, SVER
    jmp     cpm

; Open(fcbPtr) byte public
Open:
    mov     e, c
    mov     d, b
    mvi     c, FOPEN
    jmp     cpm

; Close(fcbPtr) byte public
Close:
    push    b
    lxi     b, cmdLin      ; set to default dma
    call    SetDMA
    pop     d
    mvi     c, FCLOSE
    jmp     cpm

; Delete(fcbPtr) byte public (return ignored)
Delete:
    mov     e, c
    mov     d, b
    mvi     c, FDEL
    jmp     cpm

; Read(fcbPtr) byte public
Read:
    mov     e, c
    mov     d, b
    mvi     c, FREAD
    jmp     cpm

; Write(fcbPtr) byte public
Write:
    mov     e, c
    mov     d, b
    mvi     c, FWRITE
    jmp     cpm

; Make(fcbPtr) byte public
Make:
    mov     e, c
    mov     d, b
    mvi     c, FMAKE
    jmp     cpm

; Rename(fcbPtr) byte public (not used)
Rename:
    mov     e, c
    mov     d, b
    mvi     c, FREN
    jmp     cpm

; SetDMA(buf) public
SetDMA:
    mov     e, c
    mov     d, b
    mvi     c, FDMA
    jmp     cpm

; MPMSys address public;
MPMSys:
    mvi     c,  MPMDAT
    jmp     cpm

; NewLn procedure public
NewLn:
    mvi     c, CR
    call    PutCh
    mvi     c, LF
    jmp     PutCh

; Fatal: procedure(str) public;
Fatal:
    call    PutStr ; bc implicit
    jmp     OS

    end;

os.plm
os: do;
$include(os.ipx)

declare invName(6) byte initial(0c0h, 0b9h, 0afh, 0bdh, 0b1h, 0a7h); /* inverted chars ?FPBNX */
declare bPtr word initial(1a1ah);       /* initialised to EOF padding */
declare mfgCode byte initial(1ah);
declare serial2 byte initial(1ah);
declare serial3 byte;
declare cpmVersion word;

OsSetup: procedure public;
    declare (noSerial, isMPM) byte;

    declare ba based bPtr (1) byte;
    noSerial = FALSE;
    isMPM = FALSE;
    cpmVersion =  GetVer;
    if high(cpmVersion) = 0 then    /* point to serial number */
    do;
        bPtr = topMemory - 6;           /* cpm's is located just below cpm entry point */
        if (ba(2) or ba(3)) <> 0 then   /* mfg code high byte, 1st byte of serial number */
            noSerial = TRUE;
    end;
    else if high(cpmVersion) = 1 then
    do;
        isMPM = TRUE;
        bPtr = MPMSys + 181;        /* mpm's is at systemDataArea(181) */
    end;
    else                /* CP/Net */
        noSerial = TRUE;
    if noSerial then
    do;
        mfgCode = 0ffh;
        serial2 = 0ffh;
        serial3 = 0ffh;
    end;
    else
    do;
        mfgCode = ba(0);                  /* mfg code */
        serial2 = ba(4);                  /* 2nd byte of serial number */
        if isMPM then
            serial2 = serial2 or 80h;
        serial3 = ba(5);                  /* 3rd byte of serial number */
    end;
end;

Process$FPBNX: procedure public;
    declare i byte;

    do i = 0 to last(invName);
        lname(i + 1) = not invName(i);
    end;
    if not SearchSymbol(.lname(1), 6, 1) then
        return;

    curSymValue = GetCurSymValue;
    call SelectTmpFile(3);
    bPtr = chains(COMMREL);
    chains(COMMREL) = curSymValue + 9;
    call SaveConstByte(signature(0));    /* 0 */
    call SaveConstByte(signature(1));    /* 0 */
    call SaveConstByte(signature(2));    /* 0 */
    call SaveConstByte(mfgCode);  /* mfg code */
    call SaveConstByte(serial2);  /* 2nd byte of serial number (| 80h for mpm) */
    call SaveConstByte(serial3);  /* 3rd byte of serial number */
    chains(COMMREL) = bPtr;
end;

declare IRLBuf(512) byte public;
declare indexBuf(512) byte public;
declare cmdLineBuffer(128) byte public;
end;
