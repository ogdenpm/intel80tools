/*$A=1 $G=1 $S=2*/
/*
      L81 RECONSTRUCTED FROM BINARY
*/
100H:    /* ORIGIN FOR CPM PROGRAM */
DECLARE 
    FOREVER  LITERALLY 'WHILE 1',
    TABCH    LITERALLY '9',
    CR       LITERALLY '0DH',
    LF       LITERALLY '0AH',
    CONTROLZ LITERALLY '1AH',
    TRUE     LITERALLY '1',             
    FALSE    LITERALLY '0';

DECLARE I ADDRESS, C BYTE INITIAL(TABCH);   /* TEMPORARIES */

/* YACC-ASSIGNED TERMINAL NUMBERS */
DECLARE YERROR  LITERALLY '256',
    IDENTIFIER  LITERALLY '257',
    NUMBER      LITERALLY '258',
    STRING      LITERALLY '259',
    ASL         LITERALLY '260';

/* CP/M SYSTEM CONSTANTS */
DECLARE CPM     LITERALLY '0',   /* CP/M REBOOT ENTRY */
        SFCBA   LITERALLY '5CH', /* INPUT FCB ADDRESS */
        SBUFA   LITERALLY '80H', /* SYSTEM BUFFER ADDRESS */
        BDOS    LITERALLY '5',   /* CPM DOS ENTRY POINT */
	BDOSVEC LITERALLY '6';   /* WHERE BASED OF CPM IS STORED */

/* I/O PRIMATIVES */
DECLARE PRINTCHAR  LITERALLY '2',
        PRINT      LITERALLY '9',
        OPEN       LITERALLY '15',
        CLOSE      LITERALLY '16',
        MAKE       LITERALLY '22',
        DELETE     LITERALLY '19',
        READBF     LITERALLY '20',
        WRITEBF    LITERALLY '21',
        INITDSK    LITERALLY '13',
        SETBUF     LITERALLY '26';



DECLARE ERR$STRTOOLONG LITERALLY '0F3H',
	ERR$TOOMANYMACROS LITERALLY '0F1H',
        ERR$EOF LITERALLY '1',
	ERR$BADNUM LITERALLY '2',
	ERR$TOOBIG LITERALLY '3',
	ERR$SYNTAX LITERALLY '7',
	ERR$TOOMUCHNESTING LITERALLY '0F2H',
	ERR$M81ERROR LITERALLY '0F5H',
	ERR$FATALSYNTAX LITERALLY '0F7H',
	ERR$UNDEF LITERALLY '17',
	ERR$MACROHASPARAMS LITERALLY '18',
	ERR$TOOMANYPARAMS LITERALLY '19',
	ERR$NONNUMASSIGN LITERALLY '20',
	ERR$NONNUMERICEXPR LITERALLY '21';

DECLARE TT$ADC LITERALLY '261',
	TT$SBB LITERALLY '262',
	TT$SWAP LITERALLY '263',
	TT$RRC LITERALLY '264',
	TT$RLC LITERALLY '265',
	TT$CMP LITERALLY '266',
	BSLASH LITERALLY '5CH',
	TT$XOR LITERALLY '267',
        TT$EOF LITERALLY '10CH',
        TT$DECLARE LITERALLY '10DH',
        TT$INITIAL LITERALLY '10EH',
        TT$END LITERALLY '10FH',
        TT$IF LITERALLY '110H',
        TT$THEN LITERALLY '111H',
        TT$ELSE LITERALLY '112H',
        TT$ZERO LITERALLY '113H',
        TT$CY LITERALLY '114H',
        TT$PY LITERALLY '115H',
        TT$ODD LITERALLY '116H',
        TT$EVEN LITERALLY '117H',
        TT$PLUS LITERALLY '118H',
        TT$MINUS LITERALLY '119H',
        TT$DATA LITERALLY '11AH',
        TT$BYTE LITERALLY '11BH',
        TT$LABEL LITERALLY '11CH',
        TT$EXTERNAL LITERALLY '11DH',
        TT$COMMON LITERALLY '11EH',
        TT$DO LITERALLY '11FH',
        TT$BY LITERALLY '120H',
        TT$WHILE LITERALLY '121H',
        TT$CASE LITERALLY '122H',
        TT$PROCEDURE LITERALLY '123H',
        TT$RETURN LITERALLY '124H',
        TT$CALL LITERALLY '125H',
        TT$GOTO LITERALLY '126H',
        TT$HL LITERALLY '127H',
        TT$UNTIL LITERALLY '128H',
        TT$REPEAT LITERALLY '129H',
        TT$HALT LITERALLY '12AH',
        TT$NOP LITERALLY '12BH',
        TT$DISABLE LITERALLY '12CH',
        TT$ENABLE LITERALLY '12DH',
        TT$BC LITERALLY '12EH',
        TT$DE LITERALLY '12FH',
        TT$SP LITERALLY '130H',
        TT$STACK LITERALLY '131H',
        TT$PSW LITERALLY '132H',
        TT$IN LITERALLY '133H',
        TT$OUT LITERALLY '134H';


DECLARE
    FBASE$P ADDRESS INITIAL(BDOSVEC),
    /* FILE CONTROL BLOCKS */
    PAFCB(33) BYTE /* PARSER ACTIONS FILE */
              INITIAL(0, '        ', '80P', 0,0,0,0),
    SLFCB(33) BYTE  /* SYMBOL LIST FILE */
              INITIAL(0, '        ', '80S', 0,0,0,0),
    IFA ADDRESS INITIAL(SFCBA),     /* INPUT FCB ADDRESS */
    IFCB BASED IFA BYTE,            /* INPUT FILE CONTROL BLOCK */

    /* OUTPUT BUFFER */
    OBUFSIZE LITERALLY '768',
    OBUF(OBUFSIZE) BYTE,
    OBP ADDRESS INITIAL(0),     /* OUTPUT BUFFER POINTER */
    OFCBA ADDRESS,              /* ADDRESS OF OUTPUT FCB */

    /* INPUT BUFFER */
    IBUFSIZE LITERALLY '768',
    IBUF(OBUFSIZE) BYTE,
    IBP ADDRESS INITIAL(OBUFSIZE),   /* INPUT BUFFER POINTER */
    IFCBA ADDRESS;                   /* ADDRESS OF INPUT FCB */

    /* PARSER TABLES MASKS */
DECLARE ACTMASK   LITERALLY '0F000H',
        SYMBMASK  LITERALLY '01000H',
        SHIFTMASK LITERALLY '02000H',
        REDMASK   LITERALLY '03000H',
        ERRORMASK LITERALLY '00000H',
        DEFAULT   LITERALLY '0FFFFH';

    /* PARSER ACTIONS OPCODES */
DECLARE XREDUCE   LITERALLY '1',
        XSHIFT    LITERALLY '2',
        XACCEPT   LITERALLY '3',
        XLINE     LITERALLY '4';

    /* PARSER GLOBAL VARIABLES */

DECLARE
    STACKSIZE LITERALLY '50',
    PSTACK(STACKSIZE) ADDRESS INITIAL(0),  /* PARSE STACK */
    PTOP ADDRESS INITIAL(0),               /* PARSE STACK POINTER */
    PARSING BYTE INITIAL(1),
    RECOVERING BYTE INITIAL(0),
    SEARCHING BYTE,
    INPUTSY ADDRESS,
    TAB ADDRESS,
    ACTION ADDRESS,
    IT ADDRESS,
    ERRORCOUNT BYTE INITIAL(0);

    /* PARSER TABLES */
DECLARE
    ACTB  ADDRESS, LRACT  BASED     ACTB(1)  ADDRESS,
    PACTB ADDRESS, LRPACT BASED     PACTB(1) ADDRESS,
    R1B   ADDRESS, LRR1   BASED     R1B(1)   BYTE,
    R2B   ADDRESS, LRR2   BASED     R2B(1)   BYTE,
    GOB   ADDRESS, LRGO   BASED     GOB(1)   BYTE,
    PGOB  ADDRESS, LRPGO  BASED     PGOB(1)  BYTE;

    /* SYMBOL LIST */
DECLARE
    SYMLB ADDRESS, SYMLIST BASED SYMLB BYTE,
    SYMLSIZE ADDRESS,   /* SIZE OF SUMLIST */
    SYMLNNEXT ADDRESS,  /* INDEX OF NEXT AVAILABLE BYTE IN SYMLIST */
    SLFIRST ADDRESS;    /* INDEX OF FIRST BYTE AFTER RESERVED WORDS */

    /* HASH TABLE */
DECLARE
    HASHTAB(128) ADDRESS,
    HASHMASK LITERALLY '07FH',
    HASHCODE BYTE;

    /* LEXICAL ANALYZER GLOBAL VARIABLES */
DECLARE
    TOKBUF(30) BYTE,
    TOKBUFTOP LITERALLY 'LAST(TOKBUF)',
    TOKVAL ADDRESS,
    TOKTYPE ADDRESS,
    TOKCONT BYTE INITIAL(0),
    TOKERROR BYTE,
    TOKTOP LITERALLY 'TOKBUF(0)',
    IC BYTE INITIAL(' '),        /* INPUT CHARACTER */
    NC BYTE INITIAL(' '),        /* NEXT CHARACTER */
    LRLVAL ADDRESS,
    LINE ADDRESS INITIAL(1), 
    SPECIALC LITERALLY '1',
    EOFILE  LITERALLY '0';

    /* SWITCHES FOR BUILT-IN TRACE */
    /* TO INCLUDE TRACE ROUTINES, SET TRACE$ON TO BLANKS */
    /* TO EXCLUDE TRACE ROUTINES, SET TRACE$ON TO SLASH-STAR */
DECLARE TRACE$ON LITERALLY '/*',
    TRACE$OFF LITERALLY ' /* ';

    TRACE$ON
    DECLARE TRACE BYTE;
    TRACE$OFF *** */

VMON: PROCEDURE(FUNC, INFO) BYTE;  /* CPM CALL WITH RETURN VALUE */
    DECLARE FUNC BYTE, INFO ADDRESS;
    GO TO BDOS; 
    END VMON;

CMON: PROCEDURE(FUNC, PARAM); /* CPM CALL WITN NO RETURN VALUE */
    DECLARE FUNC BYTE, PARAM ADDRESS;
    GO TO BDOS; 
    END CMON;

REBOOT: PROCEDURE;
    HALT;
    GO TO CPM;
    END REBOOT;

PRC: PROCEDURE(C);   /* PRINT CHARACTER C ON THE CRT */
    DECLARE C BYTE;
    CALL CMON(PRINTCHAR, C);
END PRC;


CRLF: PROCEDURE;  /* PRINT CR LF TO CRT */
    CALL PRC(CR);
    CALL PRC(LF);
END CRLF;

PRS: PROCEDURE(A);   /* PRINT $ TERMINATED STRING */
    DECLARE A ADDRESS;
    CALL CMON(PRINT, A);
END PRS;

PRL: PROCEDURE(A);
    DECLARE A ADDRESS;
    CALL CRLF;
    CALL PRS(A);
END PRL;

PRINTH: PROCEDURE(H);  /* PRINT HEX CHARACTER */
    DECLARE H BYTE;

    IF H > 9 THEN
        CALL PRC(H - 10 + 'A');
    ELSE
        CALL PRC(H + '0');
END PRINTH;

PRINTHB: PROCEDURE(B);  /* PRINT HEX BYTE */
    DECLARE B BYTE;
    CALL PRINTH(SHR(B, 4));
    CALL PRINTH(B AND 0FH);
END PRINTHB;

PRINTHA: PROCEDURE(A);  /* PRINT HEX ADDRESS */
    DECLARE A ADDRESS;
    CALL PRINTHB(HIGH(A));
    CALL PRINTHB(LOW(A));
END PRINTHA;

EXIT: PROCEDURE;
    CALL PRL(.('END L81$'));
    CALL CRLF;
    CALL REBOOT;
END EXIT;

PRFN: PROCEDURE(F); /* PRETTY PRINT FILE NAME FROM FCB */
    DECLARE F ADDRESS;
    DECLARE FCB BASED F(32) BYTE;
    DECLARE I BYTE;
    DO I = 1 TO 11;
       IF FCB(I) <> ' ' THEN 
           CALL PRC(FCB(I));
       IF I = 8 THEN
           CALL PRC('.');
    END;
END PRFN;

CANTOP: PROCEDURE(F); /* OPEN FILE ERROR */
    DECLARE F ADDRESS;
    CALL PRL(.('CANNOT OPEN $'));
    CALL PRFN(F);
    CALL EXIT;
END CANTOP;


FLUSH: PROCEDURE;  /* FLUCH OUTPUT BUFFER */
    DECLARE FLUSHCNT ADDRESS;

    FLUSHCNT = 0;
    DO WHILE FLUSHCNT < OBP;
    	CALL CMON(SETBUF, .OBUF(FLUSHCNT));  /* SETUP TO WRITE NEXT 128 BYTES */
	IF VMON(WRITEBF, OFCBA) <> 0 THEN    /* WRITE AND CHECK FOR ERROR */
	DO;
	    CALL PRL(.'WRITE ERROR $');
	    CALL PRFN(OFCBA);
	    CALL EXIT;
	END;
        FLUSHCNT = FLUSHCNT + 128;
    END;
    OBP = 0;  /* RESET TO START OF BUFFER */
END FLUSH;


PUTC: PROCEDURE(C);  /* WRITE CHARACTER TO OUTPUT FILE WITH FCB AT OFCBA */
    DECLARE C BYTE;

    IF OBP = OBUFSIZE THEN   /* NO ROOM SO FLUSH */
        CALL FLUSH;
    OBUF(OBP) = C;
    OBP = OBP + 1;
END PUTC;

CLOSEF: PROCEDURE;  /* CLOSE OUTPUT FILE WHOLST FCB STARTS AT OFCBA */
    CALL FLUSH;
    IF VMON(CLOSE, OFCBA) <> 0FFH THEN
        RETURN;
    CALL PRL(.'CANNOT CLOSE $');
    CALL PRFN(OFCBA);
    CALL EXIT;
END CLOSEF;

/* READ NEXT CHARACTER FROM FILE WHOSE FCB IS AT IFCBA */
GETC: PROCEDURE BYTE;
    DECLARE READCNT ADDRESS;
    IF IBP = IBUFSIZE THEN  /* AT END OF BUFFER SO RELOAD */
    DO;
        IBP = 0;
	READCNT = 0;
	DO WHILE READCNT < IBUFSIZE;
	    CALL CMON(SETBUF, .IBUF(READCNT));  /* SETUP TO READ NEXT BLOCK */
            IF (C := VMON(READBF, IFCBA)) = 1 THEN  /* READ + CHECK EOF */
	    DO;
	        IF READCNT = 0 THEN /* NO DATA READ SO RETURN 0 */
		    RETURN 0;
	        IBUF(READCNT) = 0;  /* PUT A ZERO AT END */
	        GOTO BREAK;          /* RETURN CHAR */
            END;
	    ELSE IF C <> 0 THEN     /* ? ERROR */
		DO;
		    CALL PRL(.'READ ERROR $');
		    CALL PRFN(IFCBA);
		    CALL EXIT;
		END;
	    READCNT = READCNT + 128;
	END;
    END;
BREAK:
    C = IBUF(IBP);
    IBP = IBP + 1;
    RETURN C;
END GETC;

INITFILES: PROCEDURE;  /* INITIALIZE FILES */
    CALL CMON(INITDSK, 0);
    IFCBA = SFCBA;     /* INPUT FILE: SOURCE PROGRAM */
    OFCBA = .PAFCB;    /* OUTPUT FILE: PARSER ACTIONS FILE */
    IFCB(9) = 'L';     /* SET TYPE OF INPUT FILE TO 'L80' */
    IFCB(10) = '8';
    IFCB(11) = '0';
    /* OPEN INPUT FILE */
    IF VMON(OPEN, IFCBA) = 255 THEN
        CALL CANTOP(IFCBA);
    /* COPY THE FILE NAME PREFIX TO OUTPUT FILES */
    DO I = 1 TO 8;
        PAFCB(I), SLFCB(I) = IFCB(I);
    END;
    CALL CMON(DELETE, .PAFCB);  /* DELETE ANY OLD OUTPUT FILES */
    CALL CMON(DELETE, .SLFCB);
    IF VMON(MAKE, .PAFCB) = 255 THEN  /* CREATE NEW VERSIONS */
        CALL CANTOP(.PAFCB);
    IF VMON(MAKE, .SLFCB) = 255 THEN
        CALL CANTOP(.SLFCB);
    /* SET NEXT RECORD TO 0 FOR ALL FILES */
    IFCB(32), PAFCB(32), SLFCB(32) = 0; 
END INITFILES;
     
BLANK: PROCEDURE(C) BYTE; /* TRUE IF C IS WHITESPACE CHAR */
    DECLARE C BYTE;
    RETURN C = ' ' OR C = CR OR C = LF OR C = TABCH;
END BLANK;

NUMERIC: PROCEDURE(C) BYTE; /* TRUE IF C IS A DIGIT */
    DECLARE C BYTE;
    RETURN C >= '0' AND C <= '9';
END NUMERIC;

ALPHABETIC: PROCEDURE(C) BYTE; /* TRUE IF C IS A LETTER OR $ */
    DECLARE C BYTE;
    RETURN C >= 'A' AND C <= 'Z' OR C>= 61H AND C <= 7AH OR C = '$';
END ALPHABETIC;

ALPHANUMERIC: PROCEDURE(C) BYTE; /* TRUE IF C IS ALPHANUMERIC */
    DECLARE C BYTE;
    RETURN ALPHABETIC(C) OR NUMERIC(C);
END ALPHANUMERIC;


HEX: PROCEDURE(C) BYTE; /* TRUE IF C IS A HEX CHARACTER */
    DECLARE C BYTE;
    RETURN NUMERIC(C) OR C >= 'A' AND C <= 'F';
END HEX;

HEXVAL: PROCEDURE(C) BYTE; /* RETURN VALUE OF HEX CHARACTER C */
    DECLARE C BYTE;
    IF NUMERIC(C) THEN
        RETURN C - '0';
    RETURN C - 'A' + 10;
END HEXVAL;

KERROR: PROCEDURE(N);
    DECLARE N BYTE;
    /* PRINT N-TH ERROR MESSAGE */
    DECLARE MSG ADDRESS;
    ERRORCOUNT = DEC(ERRORCOUNT + 1);
    CALL PRL(.('LINE $'));
    CALL PRINTHA(LINE);
    CALL PRC(':');
    DO CASE N;
    MSG = .(' SYNTAX ERROR NEAR $');    /* 0 */
    MSG = .(' UNEXPECTED EOF $');       /* 1 */
    MSG = .(' MISPELLED NUMBER: $');    /* 2 */
    MSG = .(' NUMBER TOO LARGE: $');    /* 3 */
    END;
    CALL PRS(MSG);
    DO N = 1 TO TOKTOP;
       CALL PRC(TOKBUF(N));
    END;
END KERROR;

DECLARE WRPA1 LITERALLY 'PUTC';    /* WRITE 1 BYTE ON PARSER ACTIONS FILE */

WRPA2: PROCEDURE(A);
    DECLARE A ADDRESS;
    CALL WRPA1(LOW(A));
    CALL WRPA1(HIGH(A));
END WRPA2;


GETIC: PROCEDURE;
    /* GET ONE CHARACTER FROM SOURCE PROGRAM INTO IC;
       LOOK AHEAD AT NEXT CHARACTER (NC);
       END OF FILE CONDICITONS ARE DENOTED (AT THE EXIT OF GETIC) BY:
       IC=0, NC=0: EOF;
       IC<>0, NC=0: ALMOST EOF;
       IC<>0, NC<>0: NOT EOF */
    IC = NC;
    IF NC <> 0 THEN  /* IF NOT EOF GET the NEW NC */
        NC = GETC;
    IF NC = LF THEN  /* NEW LINE SO BUT LINE COUNTER */
    DO;
        DECLARE (XL, XH) BYTE;
        XL = DEC(LOW(LINE) + 1);
	XH = DEC(HIGH(LINE) PLUS 0);
	LINE = SHL(DOUBLE(XH), 8) OR XL;
        /* TELL LINE NUMBER TO L82 */
	CALL WRPA1(XLINE);
	CALL WRPA2(LINE);
    END;
    IF NC = CONTROLZ THEN  /* CPM EOF */
        NC = 0;
END GETIC;

PUTIC: PROCEDURE;  /* PUT INPUT CHARACTER IC INTO TOKBUF */
   TOKBUF(TOKTOP := TOKTOP + 1) = IC;
END PUTIC;
   
PGIC: PROCEDURE;
   CALL PUTIC;
   CALL GETIC;
END PGIC;

HASHF: PROCEDURE(C);
    /* UPDATE GLOBAL HASHCODE WITH THE INPUT CHARACTER C */
    DECLARE C BYTE;
    HASHCODE = (HASHCODE + C) AND HASHMASK;
END HASHF;

LOADING: PROCEDURE BYTE;
    /* RETURN 1 IF IT IS OK TO KEEP ON LOADING TOKBUF */
    RETURN TOKTOP < TOKBUFTOP AND TOKCONT;
END LOADING;

GETID: PROCEDURE; /* LOAD AN IDENTIFIER INTO THE TOKBUF */
    TOKTYPE = IDENTIFIER;
    DO WHILE LOADING;
        CALL HASHF(IC);
        CALL PGIC;
        TOKCONT = ALPHANUMERIC(IC);
    END;
END GETID;

GETSTRING: PROCEDURE;  /* LOAD A STRING INT TOKBUF */
    TOKTYPE = STRING;
    DO WHILE LOADING;
        IF IC <> '''' THEN
	DO;
	    CALL PGIC;
	    IF IC = 0 THEN /* UNEXPECTED EOF */
	    DO;
	        TOKERROR = 1;
		TOKCONT = 0;
		RETURN;
	    END;
	END;
	ELSE  /* FOUND A QUOTE */
	DO;
	    CALL GETIC;   /* SKIP IT */
	    IF IC <> '''' THEN  /* END OF STRING */
	        TOKCONT = 0;
	    ELSE
	        CALL PGIC;     /* NO SO PUT AS SINGE QUOTE */
	END;
    END;
END GETSTRING;

NHNC: PROCEDURE BYTE;  /* TRUE IF NC IS NEITHER HEX NOR 'H' */
    RETURN (NOT HEX(NC)) AND NC <> 'H';
END NHNC;

GETNUM: PROCEDURE;
    /* LOAD A NUMBER INTO TOKBUF, PUT ITS VALUE INTO TOKVAL */
    DECLARE BASE BYTE;
    DECLARE D BYTE;
    DECLARE MPLIER BYTE, MPLAND ADDRESS;
    BASE = 0;
    TOKTYPE = NUMBER;
    DO WHILE LOADING;
        CALL PGIC;
        IF IC = 'O' OR IC = 'Q' THEN BASE = 8;
        ELSE IF IC = 'H' THEN BASE = 16;
        ELSE IF IC = 'B' AND NHNC THEN BASE = 2;
        ELSE IF IC = 'D' AND NHNC THEN BASE = 10;
        ELSE IF NOT HEX(IC) THEN BASE = 1;
        IF BASE > 1 THEN /* GOBBLE THE CHAR */
            CALL GETIC;
        ELSE IF BASE = 1 THEN
            BASE = 10;
            TOKCONT = BASE = 0; /* CONTINUE UNTIL BASE IS KNOWN */
    END;
    /* COMPUTE THE VALUE */
    DO I = 1 TO TOKTOP;
        D = HEXVAL(TOKBUF(I)); /* CURRENT DIGIT */
    IF D >= BASE THEN
        TOKERROR = ERR$BADNUM;
    MPLIER = BASE;
    MPLAND = TOKVAL;
        TOKVAL = D;
    DO WHILE MPLIER <> 0;
        IF MPLIER THEN
        DO;
            TOKVAL = TOKVAL + MPLAND;
        IF CARRY THEN
            TOKERROR = ERR$TOOBIG;
            END;
        MPLIER = SHR(MPLIER, 1);
        MPLAND = SHL(MPLAND, 1);
    END;
    END;
END GETNUM;

GETSPECIAL: PROCEDURE; /* LOAD A SPECIAL CHARACTER INTO TOKBUF */
    TOKTYPE = SPECIALC;
    TOKVAL = 0;
    IF IC =  NC THEN	/* DOUBLE CHARS */
	IF IC = '+' THEN
	    TOKVAL = TT$ADC;
	ELSE IF IC = '-' THEN
	    TOKVAL = TT$SBB;
	ELSE IF IC = '=' THEN
	    TOKVAL = TT$SWAP;
	ELSE IF IC = '>' THEN
	    TOKVAL = TT$RRC;
	ELSE IF IC = '<' THEN
	    TOKVAL = TT$RLC;
	ELSE IF IC = ':' THEN
	    TOKVAL = TT$CMP;
	ELSE IF IC = BSLASH THEN
	    TOKVAL = TT$XOR;
    IF TOKVAL <> 0 THEN  /* WAS DOUBLE GO SKIP CHAR */
        CALL PGIC;
    ELSE
        TOKVAL = IC;
    CALL PGIC;
    TOKCONT = 0;
END GETSPECIAL;


GETTOKEN: PROCEDURE;
    /* GET A TOKEN AND RETURN THE GLOBAL VARIABLES
       TOKTYPE:  IDENTIFIER, STRING, NUMBER, SPECIALC, EOFILE
       TOKVAL:   VALUE OF NUBMER, ITNERNAL NO. OF SPECIALC
       TOKERROR: 0 IF VALID TOKEN, A MESSAGE NO. OTHERWISE
       TOKBUF:   ARRAY OF CHARACTERS (1 TO TOKTOP) WITH TOKEN NAME
       TOPTOP:   INDEX OF LAST CHARACTER IN TOKBUF
       HASHCODE: HASHCODE OF IDENTIFIERS, STRINGS */
    /* IC: INPUT CHARACTER (ALREADY READ IN, BUT NOT YET USED)
       NC: NEXT CHARACTER (LOOK-AHEAD CHARACTER) */
    DECLARE SOMETHING BYTE;
    TOKTOP, TOKERROR = 0;
    IF TOKCONT = 0 THEN
    DO;
        TOKVAL, HASHCODE, SOMETHING = 0;
	TOKCONT = 1;
	DO WHILE SOMETHING = 0;  /* LOOK FOR SOMETHING */
	    DO WHILE BLANK(IC);  /* SKIP BLANKS */
	        CALL GETIC;
	    END;
	    IF IC = '/' AND NC = '*' THEN  /* A COMMENT */
	    DO;
	        CALL GETIC;
		CALL GETIC;
		DO WHILE IC <> '*' OR NC <> '/';
		    IF IC = 0 THEN        /* EOF - UNFINISHED COMMENT */
		    DO;
		        TOKTYPE = EOFILE;
			RETURN;
		    END;
		    CALL GETIC;
		END;
		CALL GETIC;               /* SKIP THE * / */
		CALL GETIC;
	    END;
	    ELSE
	        SOMETHING = 1;            /* SEEN SOMETHING */
	END;
        IF IC = 0 THEN                    /* EOF */
            TOKTYPE = EOFILE;
        ELSE
        DO;
        IF ALPHABETIC(IC) THEN
    	    CALL GETID;
    	ELSE IF NUMERIC(IC) THEN
    	    CALL GETNUM;
    	ELSE IF IC = '''' THEN
    	DO;
    	    CALL GETIC;
    	    CALL GETSTRING;
    	END;
    	ELSE
    	    CALL GETSPECIAL;
        END;
    END;
    ELSE IF TOKTYPE = IDENTIFIER THEN
        CALL GETID;
    ELSE IF TOKTYPE = STRING THEN
        CALL GETSTRING;
    ELSE IF TOKTYPE = NUMBER THEN
        CALL GETNUM;
    ELSE
        CALL GETSPECIAL;
END GETTOKEN;


SLINK: PROCEDURE(I, L);
    DECLARE (I, L) ADDRESS;
    /* SET THE LINK FIELD OF SYMBOL I OF SYMLIST TO L */
    DECLARE A ADDRESS;
    DECLARE LK BASED A ADDRESS;
    A = .SYMLIST(I - 2);
    LK = L;
END SLINK;

LINK: PROCEDURE(I) ADDRESS;
    DECLARE I ADDRESS;
    /* RETURN LINK FIELD OF SYMBOL I IN SYMLIST */
    DECLARE A ADDRESS;
    DECLARE L BASED A ADDRESS;
    A = .SYMLIST(I - 2);
    RETURN L;
END LINK;


COMPAR: PROCEDURE(A1, A2) BYTE; /* STRING COMPARE, 1 IF SAME */
    DECLARE (A1, A2) ADDRESS;
    DECLARE B1 BASED A1 BYTE;
    DECLARE B2 BASED A2 BYTE;
    DO WHILE B1 = B2;
        IF B1 = 0 THEN
        RETURN 1;
    A1 = A1 + 1;
    A2 = A2 + 1;
    END;
    RETURN 0;
END COMPAR;

LOOKUPSYM: PROCEDURE(K) ADDRESS;
    DECLARE K ADDRESS;
    /* CHECK WHETHER THE TOKEN (IDENTIFIER OR STRING) AT SYMLIST(K)
       IS ALREADY IN SYMLIST, RETURN POINTER TO SYMLIST ENTRY IF
       YES, 0 OTHERWISE */
    DECLARE I ADDRESS;
    I = HASHTAB(HASHCODE);
    DO WHILE I > 0;
        IF COMPAR(.SYMLIST(K), .SYMLIST(I)) THEN
	    RETURN I;
        I = LINK(I);
    END;
    RETURN 0;
END;

SAVETOK: PROCEDURE(I) ADDRESS;
    DECLARE I ADDRESS;
    /* MOVE CURRENT TOKEN TO SYMLIST, STARTING AT LOCATION I OF
       SYMLIST; RETURN POINTER TO NEXT CHARACTER IN SYMLIST */
    DECLARE J BYTE;
    IF TOKTOP + I > SYMLSIZE THEN
    DO;
        CALL PRL(.'SYMBOL LIST OVERFLOW$');
	CALL EXIT;
    END;
    DO J = 1 TO TOKTOP;
        SYMLIST(I) = TOKBUF(J);
	I = I + 1;
    END;
    SYMLIST(I) = 0;  /* END MARKER */
    RETURN I;
END SAVETOK;

LRLEX: PROCEDURE ADDRESS; /* LEXICAL ANALYZER */
    /* RETURN THE INTERNAL NUMBER OF A RESERVED WORD, OR:
       INDENTIFIER: LRLVAL = POINTER TO INDENTIFIER IN SYMLIST
       STRING:      LRLVAL = POINTER TO STRING IN SYMLIST
       NUMBER:      LRLVAL = VALUE OF HTE NUMBER
       0:           EOFILE */
    DECLARE (J, K) ADDRESS;
    CALL GETTOKEN;
    DO WHILE TOKERROR <> 0;
        CALL KERROR(TOKERROR);
	CALL GETTOKEN;
    END;
    IF TOKTYPE = IDENTIFIER AND TOKTOP = 1 THEN
    DO;  /* CHECK IF REGISTER NAME */
        DECLARE X BYTE;
        IF (C := TOKBUF(1)) = 'M' THEN RETURN 'M';
        X = 9;
        IF C = 'A' THEN X = 7;
        ELSE IF C = 'B' THEN X = 0;
        ELSE IF C = 'C' THEN X = 1;
        ELSE IF C = 'D' THEN X = 2;
        ELSE IF C = 'E' THEN X = 3;
        ELSE IF C = 'H' THEN X = 4;
        ELSE IF C = 'L' THEN X = 5;
        LRLVAL = X;
        IF X <> 9 THEN RETURN ASL;
    END;
    IF TOKTYPE = IDENTIFIER OR TOKTYPE = STRING THEN
    DO;
        K = SYMLNNEXT + 2;
        J = SAVETOK(K);   /* MOVE TOKEN TO TOP OF SYMLIST */
        DO WHILE TOKCONT <> 0; /* GET THE REMAINDER OF THE TOKEN */
            CALL GETTOKEN;
    	J = SAVETOK(J);
        END;
        LRLVAL = LOOKUPSYM(K);  /* SEARCH SYMLIST FOR THIS TOKEN */
        IF LRLVAL <> 0 THEN     /* ALREADY THERE */
        DO;  /* CHECK FOR RESERVED WORD */
            IF TOKTYPE = IDENTIFIER AND LRLVAL < SLFIRST THEN
    	    RETURN SYMLIST(LRLVAL - 3) + 256;
    	ELSE
    	    K = LRLVAL;  /* K POINTS TO SYMBOL */
            END;
        ELSE
        DO;   /* NEW IDENTIFIER OR STRING */
            CALL SLINK(K, HASHTAB(HASHCODE));
    	    HASHTAB(HASHCODE) = K;
    	    SYMLNNEXT = J + 1;
        END;
        /* ADJUST LRLVAL SINCE THE SLFIRST BYTES OF
           SYMLIST WON'T BE PASSED TO L82 */
        LRLVAL = K - SLFIRST;
        RETURN TOKTYPE;  /* IDENTIFIER OR STRING */
    END;
    LRLVAL = TOKVAL;
    IF TOKTYPE = NUMBER THEN	/* NUMBER */
        RETURN NUMBER;
    IF TOKTYPE = SPECIALC THEN	/* SPECIAL */
        RETURN TOKVAL;
    RETURN EOFILE;
END LRLEX;


TABLE: PROCEDURE(S, I) ADDRESS;
    /* RETURN ITH ENTRY IN THE ACTION TABLE OF STATE S */
    DECLARE (S, I) ADDRESS;
    RETURN LRACT(LRPACT(S + 1) + I); 
END TABLE;



POP: PROCEDURE(N);
    DECLARE N BYTE;
    /* POP N TOPMOST STATES OF THE PARSE STACK */ 
    PTOP = PTOP - N;
    IF PTOP < 0 THEN
    DO;
        CALL PRL(.'STACK UNDERFLOW$');
	CALL EXIT;
    END;
END POP;

PUSH: PROCEDURE(S);
    DECLARE S ADDRESS;
    /* PUSH STATE S INTO THE PARSE STACK */
    PTOP = PTOP + 1;
    IF PTOP >= STACKSIZE THEN
    DO;
        CALL PRL(.'STACK OVERFLOW$');
	CALL EXIT;
    END;
    PSTACK(PTOP) = S;
END PUSH;

GOTOF: PROCEDURE(STATE, NONTERM) ADDRESS;
    /* RETURN NEXT STATE AFTER A REDUCTION */
    DECLARE (STATE, NONTERM) BYTE;
    DECLARE I BYTE;
    I = LRPGO(NONTERM); /* POINTER TO GOTO TABLE IN LRGO */
    DO FOREVER;  /* TABLE SEARCH */
        IF LRGO(I) = 0 OR LRGO(I) = STATE THEN
        RETURN LRGO(I + 1);
    I = I + 2;
    END;
END GOTOF;


REDUCE: PROCEDURE;
    DECLARE PN ADDRESS;   /* PRODUCTION NUMBER */
    DECLARE NRS BYTE;     /* NO. ELEMENTS RIGHT HAND SIDE */
    DECLARE LS BYTE;      /* ID. NO OF LHS */

    PN = TAB AND 0FFFH;
    /* CLEAR RECOVERY FLAG IF NOT <STMT> ::= <ERROR> */
    IF PN <> 6 THEN RECOVERING = 0;
    NRS = LRR2(PN); 
    LS = LRR1(PN);
    CALL WRPA1(XREDUCE);
    CALL WRPA1(NRS);
    CALL WRPA1(PN);
    TRACE$ON
    IF TRACE='Y' THEN DO;
        CALL CMON(PRINT, .('R: $')); CALL PRINTHA(NRS);
        CALL PRC(','); PRINTHA(PN); C = VMON(1, 0);
    END;
    TRACE$OFF *** */
    /* UPDATE THE PARSE STACK */
    CALL POP(NRS);   /* POP RIGHT HAND SIDE */
    CALL PUSH(GOTOF(PSTACK(PTOP), LS));   /* NEXT STATE */
END REDUCE;

SHIFT: PROCEDURE;   /* EXECUTE A SHIFT ACTION */
    CALL PUSH(TAB AND 0FFFH);   /* PUSH NEXT STATE */
    CALL WRPA1(XSHIFT);
    CALL WRPA2(LRLVAL);
    TRACE$ON
    IF TRACE='Y' THEN DO;
        CALL CMON(PRINT, .('S: $')); CALL PRINTHA(INPUTSY); CALL PRC(',');
        CALL PRINTHA(LRLVAL); C = VMON(1, 0);
    END;
    TRACE$OFF *** */
    INPUTSY = LRLEX;   /* GET ANOTHER INPUT SYMBOL */
END SHIFT;

ACCEPT: PROCEDURE;
    CALL WRPA1(XACCEPT);
    PARSING = 0;       /* BREAK THE PARSER LOOP */
END ACCEPT;

ERROR: PROCEDURE;   /* PARSING ERROR HANDLER */
    TRACE$ON
    IF TRACE = 'Y' THEN DO;
        CALL CMON(PRINT, .('E. $')); C=VMON(1, 0);
    END;
    TRACE$OFF *** */
    IF RECOVERING THEN   /* ALREADY GIVEN AN ERROR MESSAGE */
    DO;
        IF PTOP <= 0 THEN
	DO;
	    CALL KERROR(0);
	    CALL PRL(.'UNRECOVERABLE ERROR$');
	    CALL EXIT;
	END;
	CALL POP(1);
	RETURN;
    END;
    CALL KERROR(0);
    INPUTSY = YERROR;   /* <ERROR> */
    RECOVERING = 1;
END ERROR;

PARSE: PROCEDURE; /* PARSE SOURCE PROGRAM */
    INPUTSY = LRLEX; /* GET FIRST INPUT SYMBOL */
    DO WHILE PARSING;
        IT = 0;  /* INDEX WITHIN ACTION TABLE OF CURRENT STATE */
    SEARCHING = 1;
    DO WHILE SEARCHING; /* IDENTIFY APPLICABLE ACTION */
        SEARCHING = 0;
        TAB = TABLE(PSTACK(PTOP), IT); /* CURRENT TABLE ENTRY */
        ACTION = TAB AND ACTMASK;  /* DECODE THE ACTION */
        IF ACTION = REDMASK THEN
            CALL REDUCE;
        ELSE IF ACTION = ERRORMASK THEN
                CALL ERROR;
        ELSE IF (INPUTSY OR SYMBMASK) = TAB THEN    
        DO;   /* ENTRY FOUND FOR THIS INPUT */
            IT = IT + 1; /* LOOK FOR CORRESPONDING ACTION */
            TAB = TABLE(PSTACK(PTOP), IT);
                ACTION = TAB AND ACTMASK;
                IF ACTION = REDMASK THEN
                    CALL REDUCE;
            ELSE IF ACTION = SHIFTMASK THEN
                CALL SHIFT;
            ELSE
                CALL ACCEPT;
        END;
        ELSE    /* NO MATCH */
        DO;    /* KEEP ON SEARCHING */
            IT = IT + 2;
            SEARCHING = 1;
        END;
    END;
    END;
END PARSE;


SLDUMP: PROCEDURE;   /* DUMP SYMLIST ON THE SL FILE */
    OFCBA = .SLFCB;  /* OUTPUT FILE: SYMBOL LIST FILE */
    OBP = 0;         /* OUTPUT BUFFER IS EMPTY */
    /* THE PORTION OF SYMLIST CONTAINIGN RESERVED WORDS
       (BYTES 0 THROUGH SLFIRST-1) IS NOT PASSED TO L82 */
    I = SLFIRST;
    DO WHILE I < SYMLNNEXT;
        CALL PUTC(0);   /* CLER LINK FIELD FOR L82 */
	CALL PUTC(0);
	I = I + 2;      /* INDEX OF 1st CHAR OF NEXT SYMBOL */
	DO WHILE SYMLIST(I) <> 0;
	    CALL PUTC(SYMLIST(I));
	    I = I + 1;
	END;
	CALL PUTC(0);   /* END OF SYMBOL */
	I = I + 1;
    END;
    CALL PUTC(CONTROLZ); /* END OF SYMBOL LIST */
END SLDUMP;


INITTAB: PROCEDURE;
    DECLARE INITVECPTR ADDRESS;   /* WHERE THE PARSER TABLES ADDRESSES ARE */
    DECLARE VEC BASED INITVECPTR(8) ADDRESS;
    DECLARE FBASE BASED FBASE$P ADDRESS;
    DECLARE J ADDRESS;
    INITVECPTR = 2C00H;

    ACTB = VEC(0);   /* COPY THE TABLE ADDRESS INFORMATION OVER */
    PACTB = VEC(1);
    R1B = VEC(2);
    R2B = VEC(3);
    GOB = VEC(4);
    PGOB = VEC(5);
    SYMLB = VEC(6);
    SYMLNNEXT, SLFIRST = VEC(7);
    /* ALLOCATE REST OF MEMORY TO BASE OF CPM */
    SYMLSIZE = FBASE - SYMLB;
    /* RESET HASH TABLE */
    DO I = 0 TO 127;
        HASHTAB(I) = 0;
    END;
    /* INITIALISE THE SYMBOL LOST */
    J = 3;   /* INDEX OF FIRST RESERVED WORD */
    DO WHILE J < SLFIRST;
        HASHCODE = 0;
	I = J;
	DO WHILE SYMLIST(I) <> 0;
	    CALL HASHF(SYMLIST(I));   /* COMPUTE HASHCODE */
	    I = I + 1;
	END;
	CALL SLINK(J, HASHTAB(HASHCODE));    /* LINK IN PREVIOUS HASH ENTRY */
	HASHTAB(HASHCODE) = J;               /* AND PUT THIS IS HASH TABLE */
	J = I + 4;   /* NEXT RESERVED WORD */
    END;
END;    


    CALL INITTAB;
    CALL INITFILES;
    CALL PARSE;
    CALL CLOSEF;   /* CLOSE PARSER ACTIONS FILE */
    CALL SLDUMP;
    CALL CLOSEF;   /* CLOSE SYMBOL LIST FILE */
    CALL PRL(.'ERRORS: $');
    CALL PRINTHB(ERRORCOUNT);
    CALL EXIT;

    DECLARE
    R$LRACT(1271) ADDRESS INITIAL(
        0, 1100H, 2006H, 1101H, 2024H, 1102H, 2025H, 1104H,
        202AH, 110DH, 2014H, 1110H, 2018H, 1114H, 2032H, 111FH,
        2034H, 1124H, 2017H, 1125H, 2028H, 1126H, 201BH, 104DH,
        2031H, 1127H, 202DH, 1129H, 2029H, 112AH, 201DH, 112BH,
        201EH, 112CH, 201FH, 112DH, 2020H, 112EH, 202BH, 112FH,
        202CH, 1130H, 202EH, 1131H, 202FH, 1132H, 2030H, 1133H,
        2035H, 1134H, 2036H, 0, 1000H, 4000H, 0, 103BH, 2037H,
        0, 3002H, 3004H, 3005H, 3006H, 102CH, 2038H, 3007H,
        3008H, 3009H, 300AH, 300BH, 300CH, 300DH, 300EH, 300FH,
        3010H, 3011H, 1101H, 2024H, 1102H, 2025H, 1104H, 202AH,
        110DH, 2014H, 1110H, 2018H, 1114H, 2032H, 111FH, 2034H,
        1123H, 203BH, 1124H, 2017H, 1125H, 2028H, 1126H, 201BH,
        104DH, 2031H, 1127H, 202DH, 1129H, 2029H, 112AH, 201DH,
        112BH, 201EH, 112CH, 201FH, 112DH, 2020H, 112EH, 202BH,
        112FH, 202CH, 1130H, 202EH, 1131H, 202FH, 1132H, 2030H,
        1133H, 2035H, 1134H, 2036H, 0, 1100H, 2006H, 1101H,
        2024H, 1102H, 2025H, 1104H, 202AH, 110DH, 2014H, 1110H,
        2018H, 1114H, 2032H, 111FH, 2034H, 1124H, 2017H, 1125H,
        2028H, 1126H, 201BH, 104DH, 2031H, 1127H, 202DH, 1129H,
        2029H, 112AH, 201DH, 112BH, 201EH, 112CH, 201FH, 112DH,
        2020H, 112EH, 202BH, 112FH, 202CH, 1130H, 202EH, 1131H,
        202FH, 1132H, 2030H, 1133H, 2035H, 1134H, 2036H, 0,
        1101H, 2042H, 1028H, 2045H, 0, 103BH, 2046H, 0, 1100H,
        2006H, 1101H, 2024H, 1102H, 2025H, 1104H, 202AH, 110DH,
        2014H, 1110H, 2018H, 1114H, 2032H, 111FH, 2034H, 1124H,
        2017H, 1125H, 2028H, 1126H, 201BH, 104DH, 2031H, 1127H,
        202DH, 1129H, 2029H, 112AH, 201DH, 112BH, 201EH, 112CH,
        201FH, 112DH, 2020H, 112EH, 202BH, 112FH, 202CH, 1130H,
        202EH, 1131H, 202FH, 1132H, 2030H, 1133H, 2035H, 1134H,
        2036H, 0, 305AH, 1028H, 204CH, 1021H, 204EH, 1113H,
        204FH, 1114H, 2050H, 1115H, 2051H, 1118H, 2052H, 1119H,
        2053H, 0, 1101H, 2054H, 1102H, 2056H, 0, 1101H, 2058H,
        1102H, 2059H, 0, 104DH, 205AH, 3067H, 306BH, 306CH,
        306DH, 306EH, 1107H, 205DH, 110AH, 205CH, 103DH, 205EH,
        0, 301CH, 102CH, 205FH, 301DH, 1028H, 2061H, 103AH,
        2060H, 309AH, 103AH, 2062H, 0, 1101H, 2069H, 1104H,
        202AH, 103BH, 3049H, 1114H, 2032H, 1122H, 2066H, 104DH,
        2031H, 1127H, 202DH, 112EH, 202BH, 112FH, 202CH, 1130H,
        202EH, 1131H, 202FH, 1132H, 2030H, 1133H, 2035H, 1134H,
        2036H, 301AH, 103BH, 206AH, 1028H, 206DH, 0, 3062H,
        103BH, 206EH, 0, 3082H, 3083H, 3084H, 3085H, 3086H,
        3087H, 3088H, 1028H, 206FH, 0, 308AH, 103DH, 2070H,
        0, 304DH, 1028H, 2071H, 0, 1028H, 2072H, 0, 1100H,
        2006H, 1101H, 2024H, 1102H, 2025H, 1104H, 202AH, 110CH,
        2073H, 110DH, 2014H, 1110H, 2018H, 1114H, 2032H, 111FH,
        2034H, 1124H, 2017H, 1125H, 2028H, 1126H, 201BH, 104DH,
        2031H, 1127H, 202DH, 1129H, 2029H, 112AH, 201DH, 112BH,
        201EH, 112CH, 201FH, 112DH, 2020H, 112EH, 202BH, 112FH,
        202CH, 1130H, 202EH, 1131H, 202FH, 1132H, 2030H, 1133H,
        2035H, 1134H, 2036H, 0, 3012H, 3013H, 3056H, 3020H,
        1100H, 2006H, 1101H, 2024H, 1102H, 2025H, 1104H, 202AH,
        110DH, 2014H, 1110H, 2018H, 1114H, 2032H, 111FH, 2034H,
        1124H, 2017H, 1125H, 2028H, 1126H, 201BH, 104DH, 2031H,
        1127H, 202DH, 1129H, 2029H, 112AH, 201DH, 112BH, 201EH,
        112CH, 201FH, 112DH, 2020H, 112EH, 202BH, 112FH, 202CH,
        1130H, 202EH, 1131H, 202FH, 1132H, 2030H, 1133H, 2035H,
        1134H, 2036H, 0, 1112H, 2077H, 3004H, 3014H, 110EH,
        207AH, 3035H, 1028H, 207DH, 111BH, 207CH, 111CH, 207EH,
        111DH, 207FH, 111EH, 2080H, 0, 111AH, 2083H, 3041H,
        1102H, 2084H, 0, 1101H, 2085H, 0, 3043H, 1100H, 2006H,
        1101H, 2024H, 1102H, 2025H, 1104H, 202AH, 110DH, 2014H,
        110FH, 2088H, 1110H, 2018H, 1114H, 2032H, 111FH, 2034H,
        1124H, 2017H, 1125H, 2028H, 1126H, 201BH, 104DH, 2031H,
        1127H, 202DH, 1129H, 2029H, 112AH, 201DH, 112BH, 201EH,
        112CH, 201FH, 112DH, 2020H, 112EH, 202BH, 112FH, 202CH,
        1130H, 202EH, 1131H, 202FH, 1132H, 2030H, 1133H, 2035H,
        1134H, 2036H, 0, 103BH, 208AH, 0, 1111H, 208BH, 0,
        1026H, 208CH, 105CH, 208DH, 1124H, 208EH, 1125H, 208FH,
        1126H, 2090H, 3026H, 1028H, 204CH, 1021H, 204EH, 1113H,
        204FH, 1114H, 2050H, 1115H, 2051H, 1118H, 2052H, 1119H,
        2053H, 0, 302CH, 1113H, 2094H, 1114H, 2095H, 0, 302EH,
        3030H, 1116H, 2096H, 1117H, 2097H, 0, 3033H, 3034H,
        1028H, 2098H, 305CH, 305DH, 305EH, 1102H, 209BH, 1103H,
        209AH, 102DH, 209CH, 102EH, 209DH, 0, 3064H, 3065H,
        1028H, 209EH, 0, 103BH, 209FH, 0, 1102H, 209BH, 1103H,
        209AH, 1104H, 202AH, 1028H, 20A4H, 1114H, 2032H, 104DH,
        20A5H, 1127H, 202DH, 102DH, 209CH, 102EH, 209DH, 112EH,
        202BH, 112FH, 202CH, 1130H, 202EH, 1131H, 202FH, 1132H,
        2030H, 0, 1104H, 202AH, 1028H, 20A4H, 1114H, 2032H,
        104DH, 20A5H, 1127H, 202DH, 112EH, 202BH, 112FH, 202CH,
        1130H, 202EH, 1131H, 202FH, 1132H, 2030H, 0, 1101H,
        2069H, 1102H, 209BH, 1103H, 209AH, 1104H, 202AH, 1108H,
        20AFH, 1109H, 20B0H, 1028H, 20A4H, 1021H, 20ADH, 1114H,
        2032H, 104DH, 2031H, 1127H, 202DH, 102DH, 209CH, 102EH,
        209DH, 112EH, 202BH, 112FH, 202CH, 1130H, 202EH, 1131H,
        202FH, 1132H, 2030H, 103CH, 20ABH, 103EH, 20ACH, 1023H,
        20AEH, 1133H, 2035H, 1134H, 2036H, 0, 1105H, 20B7H,
        1106H, 20B8H, 110BH, 20B6H, 1026H, 20B4H, 105CH, 20B5H,
        102DH, 20B3H, 102BH, 20B2H, 0, 301EH, 1102H, 20B9H,
        0, 301FH, 304AH, 304BH, 1120H, 20BCH, 1121H, 20BDH,
        0, 1104H, 202AH, 1114H, 2032H, 104DH, 20A5H, 1127H,
        202DH, 112EH, 202BH, 112FH, 202CH, 1130H, 202EH, 1131H,
        202FH, 1132H, 2030H, 0, 301BH, 103DH, 205EH, 0, 1028H,
        2061H, 309AH, 3054H, 103BH, 20BFH, 0, 1101H, 20C0H,
        0, 3058H, 306AH, 1102H, 209BH, 1103H, 209AH, 1127H,
        20C1H, 102DH, 209CH, 102EH, 209DH, 112EH, 20C2H, 112FH,
        20C3H, 0, 1102H, 20C6H, 0, 1102H, 20C7H, 0, 3001H,
        3003H, 3015H, 3021H, 3023H, 303DH, 1028H, 20C9H, 0,
        3036H, 303BH, 3045H, 303EH, 303FH, 3040H, 3037H, 1028H,
        20CBH, 0, 1029H, 20CCH, 0, 102CH, 20CEH, 1029H, 20CDH,
        0, 3048H, 304CH, 1101H, 20CFH, 3017H, 1101H, 2024H,
        1102H, 2025H, 1104H, 202AH, 110DH, 2014H, 110FH, 2088H,
        1110H, 2018H, 1114H, 2032H, 111FH, 2034H, 1123H, 203BH,
        1124H, 2017H, 1125H, 2028H, 1126H, 201BH, 104DH, 2031H,
        1127H, 202DH, 1129H, 2029H, 112AH, 201DH, 112BH, 201EH,
        112CH, 201FH, 112DH, 2020H, 112EH, 202BH, 112FH, 202CH,
        1130H, 202EH, 1131H, 202FH, 1132H, 2030H, 1133H, 2035H,
        1134H, 2036H, 0, 1100H, 2006H, 1101H, 2024H, 1102H,
        2025H, 1104H, 202AH, 110DH, 2014H, 110FH, 2088H, 1110H,
        2018H, 1114H, 2032H, 111FH, 2034H, 1124H, 2017H, 1125H,
        2028H, 1126H, 201BH, 104DH, 2031H, 1127H, 202DH, 1129H,
        2029H, 112AH, 201DH, 112BH, 201EH, 112CH, 201FH, 112DH,
        2020H, 112EH, 202BH, 112FH, 202CH, 1130H, 202EH, 1131H,
        202FH, 1132H, 2030H, 1133H, 2035H, 1134H, 2036H, 0,
        3022H, 3027H, 3029H, 305BH, 3063H, 3068H, 1026H, 20D2H,
        3024H, 105CH, 20D3H, 3025H, 103BH, 20D4H, 1029H, 20D5H,
        0, 302DH, 302FH, 3031H, 3032H, 3060H, 102CH, 20D7H,
        1029H, 20D6H, 0, 307CH, 307DH, 1102H, 20D8H, 0, 1101H,
        20D9H, 1103H, 20DAH, 0, 1127H, 20DBH, 0, 1100H, 2006H,
        1101H, 2024H, 1102H, 2025H, 1104H, 202AH, 110DH, 2014H,
        1110H, 2018H, 1114H, 2032H, 111FH, 2034H, 1124H, 2017H,
        1125H, 2028H, 1126H, 201BH, 104DH, 2031H, 1127H, 202DH,
        1128H, 20DCH, 1129H, 2029H, 112AH, 201DH, 112BH, 201EH,
        112CH, 201FH, 112DH, 2020H, 112EH, 202BH, 112FH, 202CH,
        1130H, 202EH, 1131H, 202FH, 1132H, 2030H, 1133H, 2035H,
        1134H, 2036H, 0, 306FH, 307AH, 307BH, 3072H, 1104H,
        202AH, 1114H, 2032H, 104DH, 20A5H, 1127H, 202DH, 112EH,
        202BH, 112FH, 202CH, 1130H, 202EH, 1131H, 202FH, 1132H,
        2030H, 0, 1028H, 20DEH, 0, 3070H, 1105H, 20B7H, 1106H,
        20B8H, 110BH, 20B6H, 1026H, 20B4H, 105CH, 20B5H, 102DH,
        20B3H, 102BH, 20B2H, 3076H, 1101H, 2069H, 1102H, 209BH,
        1103H, 209AH, 1104H, 202AH, 1028H, 20A4H, 1114H, 2032H,
        104DH, 2031H, 1127H, 202DH, 102DH, 209CH, 102EH, 209DH,
        112EH, 202BH, 112FH, 202CH, 1130H, 202EH, 1131H, 202FH,
        1132H, 2030H, 1133H, 2035H, 1134H, 2036H, 0, 3078H,
        3079H, 3092H, 3093H, 3094H, 3095H, 3096H, 3097H, 308BH,
        308CH, 308DH, 308EH, 308FH, 3090H, 3091H, 1029H, 20E2H,
        0, 1101H, 2069H, 1104H, 202AH, 1114H, 2032H, 104DH,
        2031H, 1127H, 202DH, 112EH, 202BH, 112FH, 202CH, 1130H,
        202EH, 1131H, 202FH, 1132H, 2030H, 1133H, 2035H, 1134H,
        2036H, 0, 1028H, 204CH, 1021H, 204EH, 1113H, 204FH,
        1114H, 2050H, 1115H, 2051H, 1118H, 2052H, 1119H, 2053H,
        0, 3050H, 3051H, 3052H, 3055H, 102CH, 20E7H, 1029H,
        20E6H, 0, 1029H, 20E8H, 0, 1029H, 20E9H, 0, 1029H,
        20EAH, 0, 1029H, 20EBH, 0, 3071H, 1029H, 20ECH, 0,
        1029H, 20EDH, 0, 102CH, 20EFH, 1029H, 20EEH, 0, 3016H,
        102CH, 20F1H, 1029H, 20F0H, 0, 3039H, 111BH, 20F2H,
        0, 3042H, 3044H, 3018H, 3019H, 3053H, 3028H, 302AH,
        1021H, 204EH, 1113H, 204FH, 1114H, 2050H, 1115H, 2051H,
        1118H, 2052H, 1119H, 2053H, 0, 305FH, 3061H, 307EH,
        1028H, 20F4H, 307FH, 3081H, 1029H, 20F5H, 0, 102CH,
        205FH, 1029H, 20F7H, 0, 1127H, 20C1H, 0, 3075H, 3077H,
        309BH, 1121H, 20BDH, 0, 304FH, 1026H, 208CH, 105CH,
        208DH, 3026H, 3057H, 3059H, 3089H, 3098H, 3099H, 309EH,
        309CH, 309DH, 3046H, 3047H, 3038H, 303AH, 303CH, 302BH,
        1102H, 20FAH, 0, 3066H, 3069H, 3073H, 3074H, 1029H,
        20FCH, 0, 304EH, 3080H, 0),

    R$LRPACT(255) ADDRESS INITIAL(
	0, 1, 34H, 37H, 3AH, 3BH, 3CH, 3DH, 3EH, 41H, 42H,
        43H, 44H, 45H, 46H, 47H, 48H, 49H, 4AH, 4BH, 7EH, 0B1H,
        0B6H, 0B9H, 0ECH, 0EDH, 0FCH, 101H, 106H, 0B9H, 109H,
        10AH, 10BH, 10CH, 10DH, 114H, 115H, 118H, 11DH, 120H,
        13DH, 142H, 143H, 146H, 147H, 148H, 149H, 14AH, 14BH,
        14CH, 14DH, 150H, 151H, 154H, 155H, 158H, 15BH, 0B1H,
        190H, 191H, 192H, 193H, 194H, 1C7H, 1CAH, 1CBH, 1CEH,
        1D9H, 1DCH, 1DFH, 1E2H, 1E3H, 218H, 21BH, 21EH, 229H,
        229H, 0B9H, 238H, 239H, 23EH, 23FH, 240H, 245H, 246H,
        247H, 24AH, 24BH, 24CH, 255H, 256H, 257H, 25AH, 25DH,
        27AH, 28FH, 2BEH, 2CDH, 2CEH, 2D1H, 2D2H, 2D3H, 2D4H,
        2D9H, 2ECH, 2EDH, 2F0H, 2F3H, 2F4H, 2F7H, 2FAH, 2FBH,
        2FCH, 27AH, 30BH, 30EH, 311H, 312H, 313H, 314H, 315H,
        316H, 24CH, 317H, 31AH, 31BH, 31CH, 31DH, 31EH, 31FH,
        320H, 24CH, 321H, 324H, 327H, 32CH, 32DH, 32EH, 331H,
        366H, 39BH, 39CH, 39DH, 39EH, 39FH, 3A0H, 3A1H, 3A4H,
        3A7H, 3ACH, 3ADH, 3AEH, 3AFH, 3B0H, 3B1H, 3B6H, 3B7H,
        3B8H, 3BBH, 3C0H, 3C3H, 3F8H, 3F9H, 3FAH, 3FBH, 3FCH,
        40FH, 412H, 413H, 422H, 445H, 446H, 447H, 448H, 449H,
        44AH, 44BH, 44CH, 25DH, 44DH, 44EH, 44FH, 450H, 451H,
        452H, 453H, 454H, 457H, 470H, 47FH, 480H, 481H, 482H,
        483H, 488H, 48BH, 48EH, 491H, 494H, 495H, 498H, 49BH,
        4A0H, 4A1H, 4A6H, 4A7H, 4AAH, 4ABH, 4ACH, 4ADH, 4AEH,
        4AFH, 4B0H, 194H, 4B1H, 4BEH, 4BFH, 4C0H, 4C1H, 4C4H,
        4C5H, 470H, 4C8H, 4CDH, 25DH, 4D0H, 4D1H, 4D2H, 4D3H,
        4D6H, 4D7H, 4DCH, 4DDH, 4DEH, 4DFH, 4E0H, 4E1H, 4E2H,
        4E3H, 4E4H, 4E5H, 4E6H, 4E7H, 4E8H, 4E9H, 4EAH, 4EDH,
        4EEH, 4EFH, 4F0H, 470H, 4F1H, 4F4H, 4F5H, 0),

    R$LRR1(160) BYTE INITIAL(
	0, 1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
        4, 4, 5, 6, 6, 13H, 14H, 14H, 14H, 15H, 15H, 10H, 10H,
        11H, 11H, 5, 5, 18H, 19H, 1AH, 1AH, 1AH, 1BH, 1BH,
        1DH, 1DH, 1CH, 1CH, 1EH, 1EH, 1EH, 1EH, 1EH, 1EH, 1EH,
        1EH, 12H, 12H, 12H, 22H, 23H, 23H, 1FH, 1FH, 1FH, 21H,
        21H, 21H, 20H, 20H, 27H, 27H, 25H, 26H, 13H, 7, 28H,
        28H, 28H, 28H, 29H, 2AH, 2AH, 2CH, 2DH, 2BH, 8, 2FH,
        2FH, 30H, 31H, 32H, 32H, 9, 9, 0AH, 0AH, 0AH, 34H,
        35H, 35H, 33H, 33H, 0BH, 0BH, 0BH, 36H, 36H, 0CH, 37H,
        0DH, 0DH, 0DH, 0DH, 0EH, 0FH, 16H, 39H, 39H, 17H, 17H,
        17H, 17H, 3BH, 3BH, 38H, 38H, 24H, 24H, 24H, 24H, 24H,
        24H, 2EH, 2EH, 2EH, 2EH, 2EH, 2EH, 2EH, 2EH, 2EH, 3CH,
        3CH, 3CH, 3CH, 3CH, 3CH, 3CH, 3DH, 3DH, 3DH, 3DH, 3DH,
        3DH, 3AH, 3AH, 3AH, 3AH, 3AH, 3AH, 3AH, 0),

    R$LRR2(160) BYTE INITIAL(
	0, 3, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 2, 2, 2, 3, 2, 1, 2, 2, 0, 1, 1, 1, 2, 2, 2, 3,
        3, 2, 2, 2, 1, 2, 3, 2, 3, 4, 1, 2, 1, 2, 1, 2, 2,
        1, 1, 1, 2, 2, 3, 2, 3, 2, 4, 2, 1, 1, 1, 1, 3, 1,
        3, 2, 3, 3, 3, 1, 2, 2, 3, 1, 5, 3, 1, 1, 2, 4, 2,
        3, 2, 3, 1, 3, 1, 3, 2, 2, 2, 3, 2, 3, 1, 3, 2, 2,
        5, 1, 3, 5, 2, 1, 1, 1, 1, 3, 3, 3, 1, 3, 5, 4, 3,
        4, 1, 1, 1, 1, 1, 1, 2, 2, 5, 2, 1, 1, 1, 1, 1, 1,
        1, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4,
        4, 1, 4, 4, 4, 4, 0),

    R$LRPGO(63) BYTE INITIAL(
	0, 1, 3, 0BH, 1BH, 23H, 29H, 2BH, 2DH, 2FH, 31H, 33H,
        35H, 37H, 39H, 3BH, 3DH, 43H, 4BH, 4FH, 51H, 57H, 59H,
        5BH, 5FH, 61H, 63H, 6BH, 6DH, 75H, 77H, 7BH, 7DH, 7FH,
        81H, 83H, 85H, 8FH, 91H, 93H, 95H, 97H, 99H, 9BH, 9DH,
        9FH, 0A3H, 0BBH, 0BDH, 0BFH, 0C1H, 0C3H, 0C5H, 0C7H,
        0C9H, 0CBH, 0CDH, 0D5H, 0DBH, 0E1H, 0E5H, 0E9H, 0),

    R$LRGO(236) BYTE INITIAL(
	0, 0, 1, 16H, 47H, 1CH, 5BH, 4CH, 93H, 0, 2, 13H, 3CH,
        37H, 74H, 3DH, 76H, 46H, 87H, 8AH, 74H, 9FH, 74H, 0D4H,
        74H, 0, 3, 12H, 39H, 13H, 3EH, 89H, 39H, 0, 4, 12H,
        3AH, 89H, 3AH, 0, 5, 0, 7, 0, 8, 0, 9, 0, 0AH, 0, 0BH,
        0, 0CH, 0, 0DH, 0, 0EH, 0, 0FH, 0, 10H, 26H, 67H, 0BAH,
        0E3H, 0, 11H, 46H, 89H, 89H, 89H, 8AH, 89H, 0, 12H,
        38H, 75H, 0, 3FH, 0, 79H, 89H, 0D0H, 8AH, 0D1H, 0,
        86H, 0, 65H, 0, 22H, 0A4H, 0DDH, 0, 23H, 0, 13H, 0,
        3DH, 0BBH, 0E4H, 0DCH, 0F6H, 0F9H, 0FBH, 0, 48H, 0,
        4AH, 18H, 49H, 4AH, 91H, 4BH, 92H, 0, 0E5H, 0, 4BH,
        0D5H, 0F3H, 0, 4DH, 0, 40H, 0, 41H, 0, 7BH, 0, 81H,
        0, 82H, 57H, 99H, 6FH, 0C4H, 79H, 0C8H, 82H, 0CAH,
        0, 0A2H, 0, 43H, 0, 78H, 0, 44H, 0, 15H, 0, 26H, 0,
        63H, 0, 64H, 0, 0BAH, 0E3H, 0F9H, 0, 0BBH, 26H, 68H,
        5CH, 0A3H, 5DH, 0A3H, 5EH, 0A3H, 66H, 0BEH, 70H, 0A3H,
        0A4H, 68H, 0A8H, 0A3H, 0B1H, 0A3H, 0BAH, 68H, 0DFH,
        0A3H, 0, 21H, 0, 16H, 0, 27H, 0, 6BH, 0, 6CH, 0, 19H,
        0, 55H, 0, 57H, 0, 1AH, 0, 1CH, 5CH, 0A0H, 0B1H, 0E1H,
        0DFH, 0F8H, 0, 0AAH, 5DH, 0A6H, 70H, 0C5H, 0, 0A1H,
        5EH, 0A9H, 0A8H, 0A9H, 0, 33H, 0A8H, 0E0H, 0, 0A7H,
        0A7H, 0DFH, 0, 0B1H, 0, 0A8H, 0),
	
    RESWORD(333) BYTE INITIAL(
        12, 0, 0, 'EOF', 0,
        13, 0, 0, 'DECLARE', 0,
        14, 0, 0, 'INITIAL', 0,
        15, 0, 0, 'END', 0,
        16, 0, 0, 'IF', 0,
        17, 0, 0, 'THEN', 0,
        18, 0, 0, 'ELSE', 0,
        19, 0, 0, 'ZERO', 0,
        20, 0, 0, 'CY', 0,
        21, 0, 0, 'PY', 0,
        22, 0, 0, 'ODD', 0,
        23, 0, 0, 'EVEN', 0,
        24, 0, 0,'PLUS', 0,
        25, 0, 0,'MINUS', 0,
        26, 0, 0,'DATA', 0,
        27, 0, 0,'BYTE', 0,
        28, 0, 0,'LABEL', 0,
        29, 0, 0,'EXTERNAL', 0,
        30, 0, 0,'COMMON', 0,
        31, 0, 0,'DO', 0,
        32, 0, 0,'BY', 0,
        33, 0, 0,'WHILE', 0,
        34, 0, 0,'CASE', 0,
        35, 0, 0,'PROCEDURE', 0,
        36, 0, 0,'RETURN', 0,
        37, 0, 0,'CALL', 0,
        38, 0, 0,'GOTO', 0,
        39, 0, 0,'HL', 0,
        40, 0, 0,'UNTIL', 0,
        41, 0, 0,'REPEAT', 0,
        42, 0, 0,'HALT', 0,
        43, 0, 0,'NOP', 0,
        44, 0, 0,'DISABLE', 0,
        45, 0, 0,'ENABLE', 0,
        46, 0, 0,'BC', 0,
        47, 0, 0,'DE', 0,
        48, 0, 0,'SP', 0,
        49, 0, 0,'STACK', 0,
        50, 0, 0,'PSW', 0,
        51, 0, 0,'IN', 0,
        52, 0, 0,'OUT', 0);
DECLARE FILLER(92) BYTE;
/*
THE FOLLOWING ARRAY IS PATCHED AT LOCATION 2C00H
SEE INITTAB 
DECLARE VECTAB(8) ADDRESS INITIAL( .R$LRACT, .R$LRPACT, .R$LRR1, .R$LRR2,
				   .R$LRPGO, .R$LRGO, .RESWORD, SIZE(RESWORD));

*/
EOF;
