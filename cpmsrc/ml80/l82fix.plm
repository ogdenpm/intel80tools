
100H:		/* START OF CPM */

DECLARE LIT  LITERALLY 'LITERALLY',
    FOREVER  LIT 'WHILE 1',
    CR       LITERALLY '0DH',
    LF       LITERALLY '0AH';

/* CP/M SYSTEM CONSTANTS */
DECLARE CPM     LITERALLY '0',   /* CP/M CPM ENTRY */
        IFCBA   LITERALLY '5CH', /* INPUT FCB ADDRESS */
        SBUFA   LITERALLY '80H', /* SYSTEM IBUF ADDRESS */
        BDOS    LITERALLY '5',   /* CPM DOS ENTRY POINT */
	P$FBASE LITERALLY '6';   /* WHERE BASED OF CPM IS STORED */

/* I/O PRIMATIVES */
DECLARE READCHAR   LITERALLY '1',
        PRINTCHAR  LITERALLY '2',
        PRINT      LITERALLY '9',
        OPEN       LITERALLY '15',
        CLOSE      LITERALLY '16',
        MAKE       LITERALLY '22',
        DELETE     LITERALLY '19',
        READBF     LITERALLY '20',
        WRITEBF    LITERALLY '21',
        INITDSK    LITERALLY '13',
        SETBUF     LITERALLY '26';


DECLARE 
	TOPMEM LIT '3200H';

DECLARE SRELOC LIT '0';

DECLARE	TREG LIT '0',
	TSTRING	LIT '11H',
	TNUMBER LIT '13H',
	TADDRVAR LIT '15H',
	TADDRSTR LIT '17H',
	TMXX LIT '21H',
	TVAR LIT '23H',
	TIN LIT '25H',
	TOUT LIT '27H',
	TMSTRING LIT '29H',
	TMNUMBER LIT '2BH',
	TMDOTADDRVAR LIT '2DH',
	TMDOTADDRSTR LIT '2FH',
	TMHL LIT '6',
	TA LIT '7',
	TBC LIT '0FH',
	TDE LIT '1FH',
	THL LIT '2FH',
	TSP LIT '3FH',
	TSTACK LIT '2EH',
	TPSW LIT '3EH',
	TCY LIT '1EH';

    DECLARE 	
	CNTOFF LIT '33',		/* OFFSET OF CNT */
	BUFOFF LIT '34';		/* OFFSET OF BUF */
    /* FILE CONTROL BLOCKS AND BUFFERS FOR OUTPUT FILES */
    /* BYTES 0-32: FCB; BYTE 33: BUFFER POINTER; BYTES 34-161: IBUF */
    DECLARE CAFCB(162) BYTE INITIAL
    (0,'        ','80C',0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
    DECLARE IDAFCB(162) BYTE INITIAL
    (0,'        ','80D',0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
    DECLARE RTFCB(162) BYTE INITIAL
    (0,'        ','80R',0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
    /* FILE CONTROL BLOCK AND BUFFER FOR INPUT FILES */
    DECLARE IFA ADDRESS INITIAL(IFCBA),
	    IFCB BASED IFA (33) BYTE,
	    IBUFA ADDRESS INITIAL(SBUFA),
            IBUF BASED IBUFA(128) BYTE,      /* INPUT BUFFER */
	    IBP BYTE INITIAL(128);
    /* PARSE STACKS */
    DECLARE STACKSIZE LIT '30',
	    PSH(STACKSIZE) ADDRESS,              /* HANDLE STACK */
	    PSX(STACKSIZE) BYTE,                 /* Y STACK */
	    PSY(STACKSIZE) ADDRESS,              /* AUXAUX STACK */
	    PTOP BYTE INITIAL(0);                /* TOP OF PARSE STACKS */

    /* VALUES ASSOCIATED WITH THE LEFT HAND SIDE OF PRODUCTIONS */
    DECLARE (HH, YY) ADDRESS,	
	    (LL, XX) BYTE;

    /* VALUES ASSOCIATED WITH HANDLES */
    DECLARE (BASEH, BASEX, BASEY) ADDRESS;       /* BASES FOR A HANDLE */
    DECLARE H BASED BASEH (1) ADDRESS,
	    X BASED BASEX (1) BYTE,
            Y BASED BASEY (1) ADDRESS,
            (H1, H2, H3, H4, H5) ADDRESS,
            (X1, X2, X3, X4) BYTE,
            (Y1, Y2, Y3) ADDRESS,
            L1 LIT 'LOW(H1)',
            L2 LIT 'LOW(H2)',
            L3 LIT 'LOW(H3)',
            L4 LIT 'LOW(H4)',
            L5 LIT 'LOW(H5)';

     /* SYMBOL LIST */
     DECLARE SYMLIST LIT 'MEMORY',
             MEMPTR ADDRESS INITIAL(0);

     /* RELOCATION TABLE */
     DECLARE RELTSIZE LIT '30',
	RLOC(RELTSIZE) ADDRESS,     /* POINTER TO THE ADDRESS TO RELOC */
	RSB(RELTSIZE) BYTE,         /* SEGMENT (4 BITS), BASE (4 BITS) */
	RDISPL(RELTSIZE) ADDRESS,   /* DISPLACEMENT */
	REXT(RELTSIZE) ADDRESS,     /* PTR TO EXTERNAL NAME, 0 IF NOT EXT */
	RTN BYTE,                   /* NO. OCCUPIED ENTRIES IN RELTAB */
	RTT BYTE INITIAL(RELTSIZE); /* CURRENT TOP OF RELTAB */

     /* MNEMONICS FOR 'TYPE' */
     DECLARE KLABEL LIT '1',
             KBYTE  LIT '2',
             PROC   LIT '3',
             EXT    LIT '4',
             GLOB   LIT '5',
             STRING LIT '7',
             UNDECL LIT '6';

     /* MNEMONICS FOR 'BASE' */
     DECLARE CA LIT '1',       /* CODE AREA */
             IDA LIT '2',      /* INITIAL DATA AREA */
	     WA LIT '3',       /* WORK AREA */
	     UNDEF LIT '4',
	     UNUSED LIT '5';

     /* PARSER ACTIONS OPCODES */
     DECLARE XREDUCE LIT '1',
             XSHIFT  LIT '2',
             XACCEPT LIT '3',
             XLINE   LIT '4';

     /* POINTERS TO NEXT AVAILABLE LOCATIONS FOR CODE EMISSION */
     DECLARE CANEXT ADDRESS INITIAL(0),
	     IDANEXT ADDRESS INITIAL(0),
	     WANEXT ADDRESS INITIAL(0);
     DECLARE WASIZE ADDRESS INITIAL(0),    /* MAX VALUE OF WANEXT */
             IIDA ADDRESS;                 /* SAVE VALUE FOR IDANEXT */

     /* SYMBOL TABLE */
     DECLARE SYMTSIZE LIT '254',        /*PMO - BIGGER SIZE */
             STB(SYMTSIZE) BYTE,       /* TYPE(4 BITS), BASE(4 BITS) */
	     SDISPL(SYMTSIZE) ADDRESS, /* DISPLACEMENT */
	     SLINK(SYMTSIZE) BYTE,     /* POINTER TO PREVIOUS ENTRY
                                          WITH SAME NAME */
	     SATR(SYMTSIZE) ADDRESS,   /* ATTRIBUTE */
	     SNAME(SYMTSIZE) ADDRESS,  /* POINTER TO NAME IN SYMLIST */
	     SYMTOP BYTE INITIAL(0); /* POINTER TO SYMTAB TOP*/

     /* BLOCK LEVEL STACK */
     DECLARE BLSTKSIZE LIT '10',
	     BLSTACK(BLSTKSIZE) BYTE,    /* SAVE VALUE FOR BLSTKTOP */
	     WASTACK(BLSTKSIZE) ADDRESS, /* SAVE VALUE FOR WANEXT */
	     BLSTKTOP BYTE INITIAL(0);   /* POINTER TO BLSTACK TOP */

     /* GLOBAL VARIABLES */
     DECLARE COMPILING BYTE INITIAL(1),
	     LINE ADDRESS INITIAL(1),    /* LINE COUNTER */
	     (I, C, TEMP, TEMP1, TEMP2) BYTE,
	     (TEMP3, TEMP4) ADDRESS;


    /* SOME OPCODES */
    DECLARE JMP   LIT '0C3H';
    DECLARE RET   LIT '0C9H';
    DECLARE PCHL  LIT '0E9H';
    DECLARE PUSHH LIT '0E5H';
    DECLARE POPH  LIT '0E1H';
    DECLARE PUSHD LIT '0D5H';
    DECLARE POPD  LIT '0D1H';
    DECLARE SHLD  LIT '022H';
    DECLARE XCHG  LIT '0EBH';
    DECLARE LXIH  LIT '021H';
    DECLARE INXH  LIT '023H';
    DECLARE DADD  LIT '019H';
    DECLARE MOVEM LIT '05EH';
    DECLARE MOVDM LIT '056H';


    /* SWITCHES FOR BUILT-IN TRACE */
    /* TO INCLUDE TRACE ROUTINES, SET TRACE$ON TO BLANKS */
    /* TO EXCLUDE TRACE ROUTINES, SET TRACE$ON TO SLASH-STAR */
DECLARE TRACE$ON LITERALLY '/*',
    TRACE$OFF LITERALLY ' /* ';

VMON: PROCEDURE(FUNC, INFO) BYTE;  /* CPM CALL WITH RETURN VALUE */
    DECLARE FUNC BYTE, INFO ADDRESS;
    GO TO BDOS; 
    END VMON;

CMON: PROCEDURE(FUNC, PARAM); /* CPM CALL WITN NO RETURN VALUE */
    DECLARE FUNC BYTE, PARAM ADDRESS;
    GO TO BDOS; 
    END CMON;

PRC: PROCEDURE(C);   /* PRINT CHARACTER C ON THE CRT */
    DECLARE C BYTE;
    CALL CMON(PRINTCHAR, C);
END PRC;

CRLF: PROCEDURE;  /* PRINT CR LF TO CRT */
    CALL PRC(CR);
    CALL PRC(LF);
END CRLF;

PRL: PROCEDURE(A);  /* PRINT $ TERMINATED STRING */
    DECLARE A ADDRESS;
    CALL CRLF;
    CALL CMON(PRINT, A);
END PRL;


PRINTH: PROCEDURE(H);  /* PRINT HEX CHARACTER */
    DECLARE H BYTE;

    IF H > 9 THEN
        CALL PRC(H - 10 + 'A');
    ELSE
        CALL PRC(H + '0');
END PRINTH;

PRINTHB: PROCEDURE(B);  /* PRINT HEX BYTE */
    DECLARE B BYTE;
    CALL PRINTH(SHR(B, 4));
    CALL PRINTH(B AND 0FH);
END PRINTHB;

PRINTHA: PROCEDURE(A);  /* PRINT HEX ADDRESS */
    DECLARE A ADDRESS;
    CALL PRINTHB(HIGH(A));
    CALL PRINTHB(LOW(A));
END PRINTHA;


RBASE: PROCEDURE(J) BYTE;
    /* RETURN BASE FIELD OF ENTRY J IN RELTAB */
    DECLARE J BYTE;
    RETURN RSB(J) AND 0FH;
END RBASE;

    TRACE$ON
    DECLARE TRACE BYTE;

TRAA: PROCEDURE(A); DECLARE A ADDRESS;
    CALL PRC(':'); PRINTHA(A);
END TRAA;

TRAB: PROCEDURE(B); DECLARE B BYTE;
    CALL PRC(':'); PRINTHB(B);
END TRAB;

TRAC: PROCEDURE(T);
    DECLARE (I,T) BYTE;
    IF TRACE = ' ' THEN RETURN;
    CALL PRC(T);
    T = VMON(1,0);
    DO WHILE T <> ' '; 
        IF T='S' THEN DO I=0 TO SYMTOP;
            CALL TRAB(I);
            CALL TRAB(STB(I));
            CALL TRAA(SDISPL(I));
            CALL TRAB(SLINK(I));
            CALL TRAA(SATR(I));
            CALL TRAA(SNAME(1));
         END;
         IF T= 'R' THEN DO I=0 TO LAST(RSB);
             IF RBASE(I)<> UNUSED THEN DO;
                 CALL TRAB(I);
                 CALL TRAA(RLOC(I));
                 CALL TRAB(RSB(I));
                 CALL TRAA(RDISPL(I));
                 CALL TRAA(REXT(I));
             END;
         END;
         IF T='H' THEN DO I = 0 TO PTOP;
             CALL TRAB(I); CALL TRAA(PSH(I));
         END;
         IF T='A' THEN DO;
             CALL TRAA(HH); CALL TRAB(LL);
             CALL TRAA(YY); CALL TRAB(XX);
         END;
         T=VMON(1,0);
    END;
END TRAC;
    TRACE$OFF *** */


EXIT: PROCEDURE;
    CALL PRL(.('END L82$'));
    CALL CRLF;
    GOTO CPM;
END EXIT;

CANTOP: PROCEDURE(C); /* PRINT OPEN ERROR MESSAGE AND QUIT */
    DECLARE C BYTE;
    CALL PRL(.('CANNOT OPEN $'));
    CALL PRC(C);
    CALL EXIT;
END CANTOP;

CANTCL: PROCEDURE(C); /* PRINT CLOSE ERROR MESSAGE AND QUIT */
    DECLARE C BYTE;
    CALL PRL(.('CANNOT CLOSE $'));
    CALL PRC(C);
    CALL EXIT;
END CANTCL;

CLOSEALL: PROCEDURE; /* CLOSE ALL FILES AND RETURN TO CP/M */
    IF VMON(CLOSE, .CAFCB)  = 255 THEN CALL CANTCL('C');
    IF VMON(CLOSE, .IDAFCB) = 255 THEN CALL CANTCL('D');
    IF VMON(CLOSE, .RTFCB)  = 255 THEN CALL CANTCL('R');
    CALL EXIT;
END CLOSEALL;

OPENF: PROCEDURE(Y); /* OPEN INPUT FILE XXX.80Y */
    DECLARE Y BYTE;
    IFCB(9) = '8';
    IFCB(10) = '0';
    IFCB(11) = Y;
    IF VMON(OPEN, IFCBA) = 255 THEN CALL CANTOP(Y);
    IFCB(32) = 0;	/* SET BUFFER POINTER */
    IBP = 128;		/* BUFFER EMPTY */
END OPENF;


MAKEF: PROCEDURE(F);  /* CREATE OUTPUT FILE WHOSE FCB IS AT F */
    DECLARE F ADDRESS;
    DECLARE FCB BASED F(32) BYTE;
    CALL CMON(DELETE, F);  /* DELETE OLD VERSION OF THE FILE */
    IF VMON(MAKE, F) = 255 THEN CALL CANTOP(FCB(11));
END MAKEF;

KERROR: PROCEDURE(N); /* PRINT ERROR MESSAGE N */
    DECLARE N BYTE;
    CALL PRL(.('LINE $'));
    CALL PRINTHA(LINE);
    CALL CMON(PRINT, .(': ERROR $'));
    CALL PRINTHB(N);
    IF (N AND 0F0H) = 0F0H THEN /* FATAL ERROR */
        CALL CLOSEALL;
    XX = 0EEH;  /* SET HANDLE TYPE TO ERROR */
END KERROR;

DOUBLET: PROCEDURE(L, H) ADDRESS;
    /* RETURN ADDRESS FORMED BY BYTES L, H */
    DECLARE (L, H) BYTE;

    RETURN SHL(DOUBLE(H), 8) OR L;
END DOUBLET;

GET1: PROCEDURE BYTE;
    /* READ NEXT CHARACTER FROM INPUT BUFFER;
       IF BUFFER EMTPY; READ ANOTEHR RECORD FROM INPUT FILE;
       SET BUFFER POINTER TO 0 IF EOF, 1-128 OTHERWISE */
    IF IBP = 128 THEN	 /* BUFFER EMPTY */
    DO;
	IBP = 0;
        CALL CMON(SETBUF, SBUFA);
	IF VMON(READBF, IFCBA) <> 0 THEN /* EOFILE */ RETURN 0;
    END;
    C = IBUF(IBP);  /* NEXT CHARACTER */
    IBP = IBP + 1;
    RETURN C;
END GET1;

GET2: PROCEDURE ADDRESS;
    /* READ A 16 BIT VALUE FROM THE INPUT BUFFER */
    RETURN DOUBLET(GET1, GET1);
END GET2;

FLUSH: PROCEDURE(F); /* FLUSH BUFFER WHOSE FCB IS AT F */
    DECLARE F ADDRESS;
    DECLARE FCB BASED F(142) BYTE;

    IF FCB(CNTOFF) = 0 /* BUFFER EMPTY */ THEN RETURN;
    FCB(CNTOFF) = 0;
    CALL CMON(SETBUF, .FCB(BUFOFF)); /* PASS BUFFER ADDRESS TO CP/M */
    IF VMON(WRITEBF, F) <> 0 THEN  /* UNSUCCESSFUL WRITE */
    DO;
        CALL PRL(.('WRITE ERROR$'));
	CALL CLOSEALL;
    END;
END FLUSH;

WR: PROCEDURE(S, C);
    DECLARE (S, C) BYTE;
    /* WRITE BYTE C on FILE S(CA,IDA,RT) */
    DECLARE F ADDRESS;  /* ADDRESS OF AN FCB */
    DECLARE FCB BASED F (142) BYTE;
    DECLARE X BYTE;

    IF S = IDA THEN	/* DATA */
    DO;
        TRACE$ON
        IF TRACE='D' THEN DO;
            CALL PRINTHA(IDANEXT); CALL TRAB(C); CALL TRAC('.');
        END;
        TRACE$OFF *** */
        IDANEXT = IDANEXT + 1;
	F = .IDAFCB;
    END;
    ELSE IF S = CA THEN /* CODE */
    DO;
        TRACE$ON
        IF TRACE='C' THEN DO;
            CALL PRINTHA(CANEXT); CALL TRAB(C); CALL TRAC('.');
        END;
        TRACE$OFF *** */
        CANEXT = CANEXT + 1;
	F = .CAFCB;
    END;
    ELSE
    	F = .RTFCB;
    IF FCB(CNTOFF) = 128 THEN	/* BUFFER FULL */
	CALL FLUSH(F);
    X = FCB(CNTOFF);            /* BUFFER POINTER */
    FCB(X + BUFOFF) = C;       /* PUT C IN THE BUFFER */
    FCB(CNTOFF) = X + 1;        /* UPDATE BUFFER POINTER */
END WR;

WRR1: PROCEDURE(C);    /* WRITE C ONTO THE RT FILE */
    DECLARE C BYTE;
    CALL WR(SRELOC, C);
END WRR1;


WRR2: PROCEDURE(A);  /* WRITE A ONTO THE RT FILE */
    DECLARE A ADDRESS;
    CALL WRR1(LOW(A));
    CALL WRR1(HIGH(A));
END WRR2;

DUMPRT: PROCEDURE(J);  /* WRITE ONE RELTAB ENTRY ON THE RT FILE */
    DECLARE J BYTE;

    CALL WRR1('R');
    CALL WRR2(RLOC(J));
    CALL WRR2(RDISPL(J));
    CALL WRR2(REXT(J));
    CALL WRR1(RSB(J));
END DUMPRT;

SLLINK: PROCEDURE(L, LK);
    DECLARE L ADDRESS;
    /* SET LINK OF SYMBOL L IN SYMLIST TO LK */
    DECLARE LK BYTE;
    SYMLIST(L - 1) = LK;
END SLLINK;

LLINK: PROCEDURE(L) BYTE;
    DECLARE L ADDRESS;
    /* RETURN LINK FIELD OF ENTRY L IN SYMLIST */
    RETURN SYMLIST(L - 1);
END LLINK;


SRBASE: PROCEDURE(J, B);
    DECLARE (J, B) BYTE;
    /* SET BASE FIELD OF ENTRY J IN RELTAB */
    RSB(J) = (RSB(J) AND 0F0H) OR B;
END SRBASE;

SRSEG: PROCEDURE(J, A);
    DECLARE (J, A) BYTE;
    /* SET SEGMENT OF ENTRY J IN RELTAB */
    RSB(J) = (RSB(J) AND 0FH) OR SHL(A, 4);
END SRSEG;

SRADDR: PROCEDURE(J, B, D);
    DECLARE (J, B) BYTE, D ADDRESS;
    /* SET ADDRESS FIELDS OF ENTRY J IN RELTAB TO (B, D) */
    CALL SRBASE(J, B);
    RDISPL(J) = D;
END SRADDR;


BRADDR: PROCEDURE(J, B, D);
    DECLARE (J, B) BYTE, D ADDRESS;
    /* BACKSTUFF B,D ON CHAIN OF ENTRIES IN RELTAB,
       LINKED BY THE EXT FIELD, STARTING AT J */
    DECLARE NEXT BYTE;
    DO WHILE J > 0;
        NEXT = REXT(J);
	CALL SRADDR(J, B, D);
	REXT(J) = 0;   /* NOT EXTERNAL */
	J = NEXT;
    END;
END BRADDR;

STYPE: PROCEDURE(I) BYTE;
    DECLARE I BYTE;
    /* RETURN TYPE OF SYMBOL I IN SYMTAB */
    RETURN SHR(STB(I), 4);
END STYPE;

SBASE: PROCEDURE(I) BYTE;
    DECLARE I BYTE;
    /* RETURN BASE OF SYMBOL I IN SYMTAB */
    RETURN STB(I) AND 0FH;
END SBASE;

SSTYPE: PROCEDURE(I, T);
    DECLARE (I,T) BYTE;
    /* SET TYPE OF SYMBOL I IN SYMTAB TO T */
    STB(I) = (STB(I) AND 0FH) OR SHL(T, 4);
END SSTYPE;


SSBASE: PROCEDURE(I, B);
    DECLARE (I,B) BYTE;
    /* SET BASE OF SYMBOL I IN SYMTAB TO B */
    STB(I) = (STB(I) AND 0F0H) OR B;
END SSBASE;


SSADDR: PROCEDURE(I, B, D);
    DECLARE (I, B) BYTE;
    DECLARE D ADDRESS;
    /* SET ADDRESS OF SYMBOL I IN SYMTAB TO (B,D) */
    IF SBASE(I) = UNDEF THEN  /* BACKSUFF (B,D) ON CHAIN OF REFERENCES */
    DO;
        CALL BRADDR(SDISPL(I), B, D);
    END;
    CALL SSBASE(I, B);
    SDISPL(I) = D;
END SSADDR;

BSTYPE: PROCEDURE(I, T);
    DECLARE (I, T) BYTE;
    /* BACKSTUFF TYPE T ON CHAIN OF IDENTIFIERS AT SYMTAB(I) */
    DO WHILE I > 0;
        CALL SSTYPE(I, T);   /* SET TYPE */
	IF T = EXT THEN CALL SSBASE(I, CA);
        IF T = GLOB THEN CALL SSBASE(I, IDA);
        I = SATR(I);         /* NEXT */
    END;
END BSTYPE;

BSADATR: PROCEDURE(I, B, D, A);
    DECLARE (I, B) BYTE;
    DECLARE (D, A) ADDRESS;
    /* BACKSTUFF BASE B, DISPLACEMENT D, ATTRIBUTE A ON A CHAIN
       OF IDENTIFIERS IN SYMTAB, LINKED BY THE ATR FIELD */
    DECLARE J BYTE;

    DO WHILE I > 0;
	D = D - A;    /* DISPLACEMENT IS MODIFIED BY A */
	CALL SSADDR(I, B, D);
	J = SATR(I);  /* SAVE ATTRIBUTE=LINK */
	SATR(I) = A;  /* NEW ATTRIBUTE */
        I = J;        /* NEXT */
    END;
END BSADATR;

INCRELT: PROCEDURE(B) BYTE;
    DECLARE B BYTE;
    /* CREATE AN ENTRY IN RELTAB FOR AN ADDRESS TO BE
       RELOCATED IN SEGMENT B (CA OR IDA);
       RETURN POINTER TO THE ENTRY CREATED;
       DUMP RESOLVED ENTRIES ONTO DISK WHILE LOOKING FOR THE VACANCY;
       IF TABLE FULL WITH UNRESOLVED REFERENCES THEN ABEND */
    RTN = 0;    /* NUMBER OF OCCUPIED ENTRIES IN RELTAB */
    DO WHILE RTN < RELTSIZE;    /* LOOK FOR AN EMPTY ENTRY */
        /* RTT: TOP OF RELTAB */
        IF RTT >= RELTSIZE THEN RTT = 1;   /* WRAP AROUND */
        IF RBASE(RTT) = UNUSED THEN  /* FOUND EMPTY ENTRY */
	DO;     /* SET POINTER TO THE ADDRESS TO RELOCATE */
	    IF B = CA THEN RLOC(RTT) = CANEXT;
	    ELSE RLOC(RTT) = IDANEXT;
            CALL SRSEG(RTT, B);
	    RETURN RTT;
	END;	
	IF RBASE(RTT) <> UNDEF THEN    /* AN ADDRESS ALREADY RESOLVED */
	DO;
	    CALL DUMPRT(RTT);     /* WRITE ENTRY ONTO RT FILE */
	    CALL SRBASE(RTT, UNUSED);  /* SET ENTRY FREE */
	END;
	ELSE    /* OCCUPIED */
	DO;
	    RTN = RTN + 1;
	    RTT = RTT + 1;
	END;
    END;
    /* IF GET HERE: RELOCATION TABLE OVERFLOW: QUIT */
    CALL KERROR(0F4H);	/* TOO MANY UNRESOLVED RELOCATIONS */
END INCRELT;

FIRST2: PROCEDURE(L) ADDRESS;
    DECLARE L ADDRESS;
    /* RETURN FIRST 2 CHARATERS OF STRING AT SYMLIST(L) */
    DECLARE (HI, LO) BYTE;

    HI = SYMLIST(L);
    LO = SYMLIST(L + 1);
    IF HI = 0 THEN /* EMPTY STRING */ RETURN 0;
    IF LO = 0 THEN /* 1-CHARACTER STRING */ RETURN HI;
    RETURN DOUBLET(LO, HI);
END FIRST2;

UNDECLARED: PROCEDURE(L) BYTE;
    DECLARE L ADDRESS;
    /* RETURN TRUE IF SYMBOL AT SYMLIST(L) NOT YET DECLARED */
    RETURN LLINK(L) = 0;
END UNDECLARED;

NEWSYMB: PROCEDURE(L) BYTE;
    DECLARE L ADDRESS;
    /* RETURN TRUE IF SYMBOL AT SYMLIST(L) IS NOT IN THE
       CURRENT BLOCK */
    RETURN LLINK(L) <= BLSTACK(BLSTKTOP);
END NEWSYMB;


CREATESYM: PROCEDURE(T, B, D, A, K) BYTE;
    DECLARE (T, B) BYTE;
    DECLARE (D, A) ADDRESS;
    DECLARE K BYTE;
    /* CREATE AN ENTRY IN SYMTAB REFERRING TO SYMBOL AT HANDLE(K);
       RETURN POINTER TO THE ENTRY CREATED */
    DECLARE HK ADDRESS;

    IF (SYMTOP := SYMTOP + 1) >= SYMTSIZE THEN /* SYMBOL TABLE OVFLW */
        CALL KERROR(0F2H);	/* TOO MANY SYMBOLS */
    /* ELSE SET THE SYMBOL */
    CALL SSTYPE(SYMTOP, T);     /* TYPE */
    CALL SSBASE(SYMTOP, B);     /* BASE */
    SDISPL(SYMTOP) = D;         /* DISPL */
    SATR(SYMTOP) = A;           /* ATTRIBUTE */
    HK = H(K);       /* POINTER TO SYMBOL NAME IN SYMLIST */
    SLINK(SYMTOP) = LLINK(HK);  /* PREVIOUS ENTRY */
    SNAME(SYMTOP) = HK;         /* POINTER TO NAME */
    CALL SLLINK(HK, SYMTOP);
    RETURN SYMTOP;
END CREATESYM;


EMITSTR: PROCEDURE(K, S);
    DECLARE (K,S) BYTE;
    /* EMIT IN SEGMENT S (CA, IDA) THE STRING AT HANDLE(K) */
    DECLARE N ADDRESS, C BYTE;

    IF S = CA THEN N = CANEXT; ELSE N = IDANEXT;
    C = CREATESYM(STRING, S, N, 0, K);   /* CREATE AN ENTRY IN SYMTAB */
    N = H(K);   /* POINTER TO SYMLIST */
    DO WHILE (C := SYMLIST(N)) <> 0;     /* (NOT END OF STRING) */
        CALL WR(S, C);
	N = N + 1;
    END;
END EMITSTR;

PUSHBL: PROCEDURE;
    /* ENTER A NEW BLOCK */
    /* PUSH SYMTOP, WANEXT INTO THE BLOCK LEVEL STACK */
    IF (BLSTKTOP := BLSTKTOP + 1) >= BLSTKSIZE THEN
        CALL KERROR(0F3H);	/* BLOCK LEVEL STACK OVFLW */
    BLSTACK(BLSTKTOP) = SYMTOP;
    WASTACK(BLSTKTOP) = WANEXT;
END PUSHBL;

POPBL: PROCEDURE(SHRWA);
    DECLARE SHRWA BYTE;
    /* EXIT FROM A BLOCK: POP SYMTOP, WANEXT FROM THE BLOCK STACK */
    DECLARE I ADDRESS;

    DO WHILE BLSTACK(BLSTKTOP) <> SYMTOP;
        /* WRITE A 'SYMBOL' RECORD ONTO THE RT FILE */
        I = SNAME(SYMTOP);    /* POINTER TO NAME IN SYMLIST */
        CALL WRR1('S');
	CALL WRR2(SDISPL(SYMTOP));
	CALL WRR2(LINE);
        CALL WRR2(I);
	CALL WRR1(STB(SYMTOP));
        CALL SLLINK(I, SLINK(SYMTOP));
        SYMTOP = SYMTOP - 1;
    END;
    IF SHRWA THEN /* SHRINK WA */ WANEXT = WASTACK(BLSTKTOP);
    BLSTKTOP = BLSTKTOP - 1;    /* POP */
END POPBL;

AREG: PROCEDURE(K) BYTE;
    DECLARE K BYTE;
    /* TRUE IF HANDLE(K) IS REGISTER A */
    RETURN LOW(H(K)) = TA;
END AREG;

BCREG: PROCEDURE(K) BYTE;
    DECLARE K BYTE;
    /* TRUE IF HANDLE(K) IS REGISTER BC */
    RETURN LOW(H(K)) = TBC;
END BCREG;

DEREG: PROCEDURE(K) BYTE;
    DECLARE K BYTE;
    /* TRUE IF HANDLE(K) IS REGISTER DE */
    RETURN LOW(H(K)) = TDE;
END DEREG;

HLREG: PROCEDURE(K) BYTE;
    DECLARE K BYTE;
    /* TRUE IF HANDLE(K) IS REGISTER HL */
    RETURN LOW(H(K)) = THL;
END HLREG;

SPREG: PROCEDURE(K) BYTE;
    DECLARE K BYTE;
    /* TRUE IF HANDLE(K) IS REGISTER SP */
    RETURN LOW(H(K)) = TSP;
END SPREG;


CYREG: PROCEDURE(K) BYTE;
    DECLARE K BYTE;
    /* TRUE IF HANDLE(K) IS 'CARRY' */
    RETURN LOW(H(K)) = TCY;
END CYREG;


STACKR: PROCEDURE(K) BYTE;
    DECLARE K BYTE;
    /* TRUE IF HANDLE(K) IS 'STACK' */
    RETURN LOW(H(K)) = TSTACK;
END STACKR;

BDHSP: PROCEDURE(K) BYTE; /* check for BC, DE, HL or SP */
    DECLARE K BYTE;
    /* TRUE IF THE ELEMENT AT HANDLE(K) IS BC,DE,HL,SP */
    RETURN (LOW(H(K)) AND 0FH) = 0FH;
END BDHSP;

BDH: PROCEDURE(K) BYTE;	/* is BC, DE, HL */
    DECLARE K BYTE;
    /* TRUE IF THE ELEMENT AT HANDLE(K) IS BC,DE,HL */
    IF SPREG(K) THEN RETURN 0;
    RETURN BDHSP(K);
END BDH;

BDHPSW: PROCEDURE(K) BYTE;	/* is PSW, BC, DE, HL */
    DECLARE K BYTE;
    /* TRUE IF THE ELEMENT AT HANDLE(K) IS BC,DE,HL OR PSW */
    RETURN BDH(K) OR (LOW(H(K)) = 3EH);
END BDHPSW;

AM: PROCEDURE(K) BYTE;
    DECLARE K BYTE;
    /* TRUE IF THE ELEMENT AT HANDLE(K) IS A,B,C...,M */
    RETURN (LOW(H(K)) AND 0F8H) = 0;
END AM;

MVI: PROCEDURE BYTE;
    /* RETURN MVI OPCODE REFERRING TO REGISTER AT HANDLE(1) */
    RETURN SHL(L1, 3) OR 6;
END MVI;

LXI: PROCEDURE BYTE;
    /* RETURN LXI OPCODE REFERRING TO REGISTER AT HANDLE(1) */
    RETURN L1 AND 0F1H;
END LXI;

INCWA: PROCEDURE(N);
    DECLARE N ADDRESS;
    /* INCREAMENT WA BY N */
    WANEXT = WANEXT + N;
    IF WASIZE < WANEXT THEN WASIZE = WANEXT;
END INCWA;

ZEROXX: PROCEDURE;
    XX = 0;
END ZEROXX;

XMITX2: PROCEDURE;
    XX = X2;
END XMITX2;

XMITH1: PROCEDURE;
    HH = H1;
END XMITH1;

XMIT1: PROCEDURE;
    /* PASS ALONG VALUES OF FIRST ELEMENT OF THE HANDLE */
    CALL XMITH1;
    XX = X1;
    YY = Y1;
END XMIT1;

XMIT2: PROCEDURE;
    HH = H2;
    CALL XMITX2;
    YY = Y2;
END XMIT2;

SETREG: PROCEDURE(B);
    DECLARE B BYTE;
    /* ASSIGN INTERNAL REGISTER NUMBERS TO HANDLE(1) */
    LL = B;
    CALL ZEROXX;
END SETREG;

CANTDO: PROCEDURE;
    /* ISSUE ERROR MESSAGE FOR INVALID REGISTER OPERATIONS */
    CALL KERROR(7);	/* NOT A MACHINE TEMP */
END CANTDO;

EMIT1: PROCEDURE(OP);
    DECLARE OP BYTE;
    /* EMIT A 1-BYTE INSTRUCTION */
    CALL WR(CA, OP);
END EMIT1;

EMIT2: PROCEDURE(OP1, OP2);
    DECLARE (OP1, OP2) BYTE;
    /* EMIT 2 1-BYTE INSTRUCTIONS */
    CALL EMIT1(OP1);
    CALL EMIT1(OP2);
END EMIT2;

EMIT4: PROCEDURE(OP1, OP2, OP3, OP4);
    DECLARE (OP1, OP2, OP3, OP4) BYTE;
    /* EMIT 4 1-BYTE INSTRUCTIONS */
    CALL EMIT2(OP1, OP2);
    CALL EMIT2(OP3, OP4);
END EMIT4;

EMIT2N: PROCEDURE(N, B);
    DECLARE N ADDRESS;
    DECLARE B BYTE;
    /* EMIT 2 BYTES REPRESENTING N IN AREA B (CA, IDA) */
    CALL WR(B, LOW(N));
    CALL WR(B, HIGH(N));
END EMIT2N;

EMITN: PROCEDURE(N, B);
    DECLARE N ADDRESS;
    DECLARE B BYTE;
    /* EMIT 1 OR 2 BYTES REPRESENTING N IN AREA B (CA, IDA */
    IF HIGH(N) = 0 THEN CALL WR(B, LOW(N));
    ELSE CALL EMIT2N(N, B);
END EMITN;

EMIT3D: PROCEDURE(OP, D16);
    DECLARE OP BYTE;
    DECLARE D16 ADDRESS;
    /* EMIT A 3-BYTE NON-RELOCATABLE INSTRUCTION */
    CALL EMIT1(OP);
    CALL EMIT2N(D16, CA);	/* CODE SEGMENT */
END EMIT3D;

EMITL: PROCEDURE(OP, L) BYTE;
    DECLARE (OP, L) BYTE;
    /* EMIT OP 3-BYTE INSTRUCTION, PROVIDING FOR RELOCATION;
       THE ADDRESS WILL BE BACKSTUFFED LATER, SO CREATE AN
       ENTRY IN RELTAB, LINK IT TO THE CHAIN POINTED TO BY L,
       AND RETURN POINTER TO THE ENTRY */
    DECLARE J BYTE;
    CALL EMIT1(OP);
    J = INCRELT(CA);    /* POINTER TO NEXT ENTRY IN RELTAB */
    CALL SRBASE(J, UNDEF);
    RDISPL(J) = 0;
    REXT(J) = L;        /* LINK USING TH EXT FIELD IN RELTAB */
    CALL EMIT2(0, 0);   /* SLOT FOR THE ADDRESS */
    RETURN J;
END EMITL;

/* EMIT2D: PROCEDURE(OP, D8);
    EMIT A 2-BYTE NON-RELOCATABLE INSTRUCTION */
    DECLARE EMIT2D LIT 'EMIT2'; 

EMITA: PROCEDURE(B, D, E);
    DECLARE B BYTE;
    DECLARE (D, E) ADDRESS;
    /* EMIT A RELOCATABLE ADDRESS IN CA */
    DECLARE J BYTE;
    J = INCRELT(CA);    /* POINTER TO NEXT ENTRY IN RELTAB */
    CALL SRBASE(J, B);  /* SET BASE */
    RDISPL(J) = D;      /* SET DISPLACEMENT */
    REXT(J) = E;        /* SET EXTERNAL FIELD */
    CALL EMIT2(0, 0);   /* SLOT FOR THE ADDRESS */
END EMITA;

EMIT3A: PROCEDURE(OP, B, D, E);
    DECLARE (OP, B) BYTE;
    DECLARE (D, E) ADDRESS;
    /* EMIT A 3-BYTE RELOCATABLE INSTRUCTION WITH ADDRESS (B,D,E) */
    CALL EMIT1(OP);
    CALL EMITA(B, D, E);
END EMIT3A;


EMIT2IA: PROCEDURE(L, D, B);
    DECLARE (L, D) ADDRESS;
    DECLARE B BYTE;
    /* EMIT IN AREA B (CA, IDA) A RELOCATABLE ADDRESS EQUAL TO
       THE ADDRESS OF SYMBOL L IN SYMLIST PLUS DISPLACEMENT D */
    DECLARE (I, J, K) BYTE;

    IF UNDECLARED(L) THEN    /* CANNOT REFERENCE */
        CALL KERROR(4);	/* REF TO UNDECLARED IDENTIFIER */
    ELSE
    DO;
        J = INCRELT(B);     /* POINTER TO AN EMPTY ENTRY IN RELTAB */
	I = LLINK(L);       /* POINTER INTO SYMTAB */
	K = SBASE(I);       /* GET BASE OF SYMBOL I */
        CALL SRBASE(J, K);  /* SET BASE OF RELOCATABLE ADDRESS */
        IF K = UNDEF THEN   /* ADDRESS NOT YET DEFINED */
	DO;   /* LINK THE ENTRY IN RELTAB TO A CHAIN OF
                 UNRESOLVED REFERENCES TO THE IDENTIFIER */
	    REXT(J) = SDISPL(I);
	    SDISPL(I) = J;  /* POINTER TO THE CHAIN */
	    RDISPL(J) = D;  /* RELATIVE DISPLACEMENT */
	END;
	ELSE  /* ADDRESS ALREADY KNOWN */
	DO;
	    RDISPL(J) = SDISPL(I) + D;    /* DISPLACEMENT */
	    K = STYPE(I);    /* GET TYPE OF SYMBOL I */
	    IF K = GLOB OR K = EXT THEN REXT(J) = L;
	    ELSE REXT(J) = 0;  /* NOT EXTERNAL */
	END;
	CALL EMIT2N(0, B);     /* SLOT FOR THE ADDRESS */
    END;
END EMIT2IA;

EMIT3IA: PROCEDURE(OP, L, D);
    DECLARE OP BYTE;
    DECLARE (L, D) ADDRESS;
    /* EMIT A 3-BYTE INSTRUCTION WITH RELOCATABLE ADDRESS
       EQUAL TO ADDRESS OF SYMBOL L IN SYMLIST PLUS DISPL D */
    CALL EMIT1(OP);
    CALL EMIT2IA(L, D, CA);    /* EMIT ADDRESS IN CA */
END EMIT3IA;

EMIT2SA: PROCEDURE(K, B);
    DECLARE (K, B) BYTE;
    /* EMIT IN AREA B (CA, IDA) A RELOCATABLE ADDRESS EQUAL TO
       THE ADDRESS OF THE STRING AT HANDLE(K) */
    DECLARE (I, J) BYTE;

    IF UNDECLARED(H(K)) /* STRING NOT YET EMITTED */ THEN
	CALL EMITSTR(K, IDA);   /* EMIT IT IN IDA */
    /* STRING ALREADY EMITTED */
    J = INCRELT(B);     /* POINTER TO AN ENTRY IN RELTAB */
    I = LLINK(H(K));    /* POINTER TO STRING ENTRY IN SYMTAB */
    CALL SRBASE(J, SBASE(I));   /* SET BASE IN RELTAB */
    RDISPL(J) = SDISPL(I);      /* SET DISPLACEMENT */
    REXT(J) = 0;                /* NOT EXTERNAL */
    CALL EMIT2N(0, B);          /* SLOT FOR THE ADDRESS */
END EMIT2SA;

EMIT3SA: PROCEDURE(OP, K);
    DECLARE (OP, K) BYTE;
    /* EMIT A 3-BYTE INSTRUCTION WITH RELOCATABLE ADDRESS
       EQUAL TO THE ADDRESS OF THE STRING AT HANDLE(K) */
    CALL EMIT1(OP);
    CALL EMIT2SA(K, CA);        /* EMIT ADDRESS IN CA */
END EMIT3SA;

EMIT3C: PROCEDURE(OP, K);
    DECLARE (OP, K) BYTE;
    /* EMIT A 3-BYTE INSTRUCTION WITH ADDRESS EQUAL TO THE
       <CONSTANT> AT HANDLE(K) */
    DECLARE HK ADDRESS;
    DECLARE XK BYTE;

    HK = H(K);
    XK = X(K);
    IF XK = TSTRING THEN             /* CONSTANT IS A STRING */
        CALL EMIT3D(OP, FIRST2(HK));
    IF XK = TNUMBER THEN             /* CONSTANT IS A NUMBER */
        CALL EMIT3D(OP, HK);
    IF XK = TADDRVAR THEN            /* CONSTANT IS ADDRESS IF IDENTIFIER */    
	CALL EMIT3IA(OP, HK, Y(K));
    IF XK = TADDRSTR THEN            /* CONSTANT IS ADDRESS OF STRING */
        CALL EMIT3SA(OP, K);
END EMIT3C;

LDAHL: PROCEDURE(OP, K) BYTE;
    DECLARE (OP, K) BYTE;
    /*  EMIT INSTRUCTION OP (LDA,LHLD,STA,SHLD) FOR THE CONSTRUCTS:
        <REG> = <VAR>
        <VAR> = <REG>
        K: POINTER TO <VAR> IN THE HANDLE
        RETURN 1 IF INSTRUCTION IS EMITTED (<VAR> NOT IN ERROR) */
    DECLARE XK BYTE;
    DECLARE HK ADDRESS;

    XK = X(K);
    HK = H(K);
    IF XK = TVAR            /* <VAR> IS <IDENTIFIER(<NUMBER>) */
       OR XK = TMDOTADDRVAR /* <VAR> IS M(.<IDENTIFIER>(<NUMBER>) */
       THEN CALL EMIT3IA(OP, HK, Y(K));
    ELSE IF XK = TMSTRING THEN      /* <VAR> IS M(<STRING>) */
        CALL EMIT3D(OP, FIRST2(HK));
    ELSE IF XK = TMNUMBER THEN      /* <VAR> IS M(<NUMBER>) */
        CALL EMIT3D(OP, HK);
    ELSE IF XK = TMDOTADDRSTR THEN  /* <VAR> IS M(.<STRING>) */
        CALL EMIT3SA(OP, K);
    ELSE
        RETURN 0;   /* DID NOT EMIT INSTRUCTION */
    RETURN 1;
END LDAHL;


LOADPRIM: PROCEDURE(J);
    DECLARE J BYTE;
    /* SYMANTIC ACTIONS FOR THE CONSTRUCT:
       <REG> = ... ... <PRIM>
       J: INDEX OF <PRIM> IN THE HANDLE */
    DECLARE XJ BYTE;
    DECLARE HJ ADDRESS;

    XJ = X(J);
    HJ = H(J);
    C = XJ AND 0F0H;    /* GET THE TYPE OF <PRIM> */
    IF C = 0 THEN       /* <PRIM> IS A REGISTER */
    DO;
        IF L1 = LOW(HJ) THEN  /* SAME AS <REG> */
            RETURN;
        /* DIFFERENT REGISTERS */
        IF AM(1) AND AM(J) THEN	/* EMIT A MOVE INSTRUCTION */
            CALL EMIT1(LOW(SHL(H1, 3)) OR 40H OR LOW(HJ));
	ELSE IF STACKR(1) AND BDHPSW(J) THEN	     /* <REG> IS THE STACK */
	    CALL EMIT1((LOW(HJ) AND 0F0H) OR 0C5H);  /* EMIT A PUSH */
	ELSE IF STACKR(J) AND BDHPSW(1) THEN	     /* <PRIM> IS THE STACK */
	    CALL EMIT1((L1 AND 0F0H) OR 0C1H);  /* EMIT A POP */
	ELSE IF SPREG(1) AND HLREG(J) THEN	     /* SP = HL */
	    CALL EMIT1(0F9H);                        /* EMIT SPHL */
	ELSE IF BDH(1) AND BDH(J) THEN	      /* BC=DE, BC=HL ETC. */
	DO;
	    C = (L1 XOR 4FH) OR SHR(LOW(HJ) AND 0F0H, 3);
	    CALL EMIT2(C, C + 9);             /* B=D, C=E, B=H, C=L ETC. */
	END;
	ELSE    /* ERROR */
	    CALL CANTDO;
	RETURN;
    END;
    IF C = 10H THEN      /* <PRIM> IS A CONSTANT */
    DO;
        IF XJ = TNUMBER THEN    /* <PRIM> IS A NUMBER */
	DO;
	    IF AM(1) THEN               /* EMIT A MOVE IMMEDIATE */
		CALL EMIT2(MVI, LOW(HJ));
	    ELSE IF BDHSP(1) THEN       /* EMIT A LOAD EXTENDED IMMEDIATE */
	        CALL EMIT3D(LXI, HJ);
	    ELSE IF CYREG(1) THEN       /* <REG> IS CY */
	    DO;
	        IF HJ = 1 THEN          /* CY = 1 */
		    CALL EMIT1(37H);		/* EMIT STC */
		ELSE IF HJ = 0 THEN     /* CY = 0 */
		    CALL EMIT2(37H, 3FH);	/* EMIT STC, CMC */
		ELSE  /* ERROR */
		    CALL CANTDO;
	    END;
            ELSE      /* ERROR (BAD REGISTER */
	        CALL CANTDO;
	    RETURN;
	END;
	IF XJ = TSTRING THEN  /* <PRIM> IS A STRING */
	DO;
	   IF AM(1) THEN                 /* EMIT A MOVE IMMEDIATE */
	       CALL EMIT2(MVI, SYMLIST(HJ)); /* 1ST CHAR */
	   ELSE IF BDHSP(1) THEN         /* EMIT A LOAD EXTENDED IMMEDIATE */
	       CALL EMIT3D(LXI, FIRST2(HJ));
	   ELSE       /* ERROR */
	       CALL CANTDO;
	   RETURN;
	END;
	IF BDHSP(1) THEN
	DO;
	    IF XJ = TADDRVAR THEN      /* <PRIM> IS .<IDENTIFIER>(<NUMBER>) */
		CALL EMIT3IA(LXI, HJ, Y(J));
	    ELSE IF XJ = TADDRSTR THEN /* <PRIM> IS .<STRING> */
	        CALL EMIT3SA(LXI, J);
            /* ELSE(ERROR): DO NOTHING - ERROR MSG ALREADY ISSUED */
	END;
	ELSE /* ERROR  (BAD REGISTER) */
	    CALL CANTDO;
	RETURN;
    END;
    IF C = 20H THEN           /* <PRIM> IS A CONSTANT */
    DO;
        IF AREG(1) THEN       /* <REG> IS REGISTER A */
	DO;
	    IF XJ = TMXX THEN                   /* <PRIM> IS M(BC) or M(DE) */
	        CALL EMIT1(LOW(HJ) AND 0FAH);	/* EMIT LDAX B, LDAX D */
	    ELSE IF XJ = TIN THEN               /* <PRIM> IS IN(<NUMBER>) */
	        CALL EMIT2(0DBH, LOW(HJ));	/* EMIT 'IN' INSTRUCTION */
	    ELSE IF LDAHL(3AH, J) THEN	   /* TRY TO EMIT A LDA INSTRUCTION */
	        RETURN;                    /* EMITTED LDA */
	    ELSE    /* ERROR */
	        CALL CANTDO;
	    RETURN;
	END;
	IF HLREG(1) THEN      /* <REG> IS HL */
	DO;
            /* TRY TO EMIT A LHLD INSTRUCTION */
	    IF LDAHL(2AH, J) THEN
	        RETURN;       /* EMITTED LHLD */
            /* ELSE: ERROR */
        END;
    END;
    /* IF NONE OF THE ABOVE: ERROR */
    CALL CANTDO;
END LOADPRIM;

BINOPSEC: PROCEDURE(J, K);
    DECLARE (J, K) BYTE;
    /* CODE GENERATION FOR THE CONSTRUCT:
       <REG> = ... <BINARY.OP> <SEC>
       J,K: POINTERS TO <BINARY.OP>, <SEC> IN THE HANDLE */
    DECLARE (XJ, XK) BYTE;
    DECLARE HK ADDRESS;

    XJ = X(J);
    XK = X(K);
    HK = H(K);
    C = XK AND 0F0H;            /* GET THE TYPE OF <SEC> */
    IF C = 0 THEN               /* <SEC> IS A REGISTER */
    DO;
        IF AREG(1) THEN         /* <REG> IS REG A */
	DO;
	    IF AM(K) THEN	/* <SEC> IS A,B... M */
	    DO;    /* GENERATE 'ACCUMULATOR' INSTRUCTION */
	        CALL EMIT1(XJ OR LOW(HK));
		RETURN;
	    END;
            /* ELSE: ERROR */
	    CALL CANTDO;
	    RETURN;
	END;
        IF HLREG(1) THEN	/* <REG> IS HL */
	DO;
	    IF BDHSP(K) AND XJ = 80H THEN
            /* <SEC> IS BC,DE,HL,SP; <BINARY.OP> IS + */
	    DO;  /* EMIT DAD B, DAD D, DAD H, DAD SP */
	        CALL EMIT1(LOW(HK) AND 0F9H);
		RETURN;
	    END;
            /* ELSE: ERROR */
	    CALL CANTDO;
	    RETURN;
	END;
        /* ELSE (<REG> NEITHER A NOR HL): ERROR */
        CALL CANTDO;
	RETURN;
    END;
    IF C = 10H THEN    /* <SEC> IS A CONSTANT */
    DO;
        IF AM(1) OR BDHSP(1) THEN    /* A,B,...M,BC,DE,HL,SP */
	DO;
	    IF XK = TNUMBER AND HK = 1 THEN	/* +/- 1 */
	    DO;
		IF XJ = 80H THEN		/* <REG> + 1*/
		DO;
		    IF AM(1) THEN	/* A,B,...M */
		        CALL EMIT1(SHL(L1, 3) OR 4);  /* INR OPS */
		    ELSE		/* BC,DE,HL,SP */
		        CALL EMIT1(L1 AND 0F3H);      /* INX OPS */
		    RETURN;
		END;
		IF XJ = 90H THEN		/* <REG> - 1 */
		DO;
		    IF AM(1) THEN	/* A,B,...M */
		        CALL EMIT1(SHL(L1, 3) OR 5);  /* DCR OPS */
		    ELSE		/* BC,DE,HL,SP */
		        CALL EMIT1(L1 AND 0FBH);      /* DCX OPS */
		    RETURN;
		END;
	    END;
	    IF NOT AREG(1) THEN         /* ERROR: <REG> IS NOT A */
	    DO;
	        CALL CANTDO;
	        RETURN;
	    END;
            /* ELSE: <REG> IS REG A */
	    IF XK = TSTRING THEN        /* STRING */
	        C = SYMLIST(HK);        /* GET ITS FIRST CHARACTER */
	    IF XK = TNUMBER THEN        /* NUMBER */
	        C = HK;                 /* GET ITS VALUE */
	    IF XK > TNUMBER THEN        /* ADDRESS: NOT IMPLEMENTED */
	        CALL KERROR(8);	/* FEATURE NOT IMPLEMENTED */
	    ELSE			/* EMIT ACC IMMEDIATE GROUP */
	        CALL EMIT2(XJ OR 46H, C);
	    RETURN;
	END;
        /* ELSE (<REG> IS PSW,STACK,CY): ERROR */
	CALL CANTDO;
    END;
    /* ELSE: <SEC> IS ERROR: DO NOTHING (ERROR ALREADY PROCESSED */
END BINOPSEC;


IDN: PROCEDURE(K, N);
    DECLARE K BYTE;
    DECLARE N ADDRESS;
    /* SYMANTIC ACTIONS FOR THE PRODUCTIONS:
       <VAR> ::= <IDENTIFIER> ( <NUMBER> )
       <CONSTANT> ::= . <IDENTIFIER> ( <NUMBER> )
       K: INDEX OF <IDENTIFIER> IN THE HANDLE
       N: VALUE OF <NUMBER> */
    DECLARE HK ADDRESS;

    HK = H(K);
    IF UNDECLARED(HK) THEN    /* ERROR: CANNOT BE REFERENCED */
        CALL KERROR(4);	/* REFERNENCE TO UNDECLARED IDENTIFIER */
    YY = N;	/* TRANSMIT <NUMBER> */
    HH = HK;    /* TRANSMIT POINTER TO IDENTIFIER */
END IDN;

CHC: PROCEDURE(B);
    DECLARE B BYTE;     /* BASE (CA OR IDA) */
    /* SEMANTIC ACTIONS FOR THE PRODUCTIONS:
       <DATA.LIST> ::= <DATA.HEAD> <CONSTANT> )
       <DATA.HEAD> ::= <DATA.HEAD> <CONSTANT> ,
       <INITIAL.LIST> ::= <INITIAL.HEAD> <CONSTANT> )
       <INITIAL.HEAD> ::= <INITIAL.HEAD> <CONSTANT> ,  */
    IF X2 = TSTRING THEN        /* CONSTANT IS A STRING */
        CALL EMITSTR(2, B);     /* EMIT THE STRING IN CA OR IDA */
    ELSE IF X2 = TNUMBER THEN   /* CONSTANT IS A NUMBER */
        CALL EMITN(H2, B);      /* EMIT THE NUMBER IN CA OR IDA */
    ELSE IF X2 = TADDRVAR THEN  /* CONSTANT IS ADDRESS OF IDENTIFIER */
	CALL EMIT2IA(H2, Y2, B); /* EMIT THE ADDRESS IN CA OR IDA */
    ELSE IF X2 = TADDRSTR THEN  /* CONSTANT IS ADDRESS OF STRING */
        CALL EMIT2SA(2, B);     /* EMIT THE ADDRESS IN CA OR IDA */
    /* ELSE: ERROR - DO NOTHING - ERROR MESSAGE ALREADY ISSUED */
    CALL XMIT1;
END CHC;


FPH: PROCEDURE;
    /* SEMANTIC ACTIONS FOR THE PRODUCTIONS:
       <FORMAL.PARAM.LIST> ::= <FP.HEAD> <IDENTIFIER> )
       <FP.HEAD>           ::= <FP.HEAD> <IDENTIFIER> , */
    IF NEWSYMB(H2) THEN
    /* FIST APPEARANCE OF IDENTIFIER IN CURRENT BLOCK */
    DO;
	C = CREATESYM(KBYTE, WA, WANEXT, 2, 2);
	CALL INCWA(2);        /* ASSIGN 2 BYTES IN WA */
	XX = X1 + 1;          /* NO. FORMAL PARAMETERS */
    END;
    ELSE   /* IDENTIFIER ALREADY DEFINED IN CURRENT BLOCK */
    DO;
        CALL KERROR(2);
	CALL XMIT1;   /* IGNORE THE IDENTIFIER */
    END;
END FPH;

PRH: PROCEDURE(A);
    DECLARE A ADDRESS;
    /* SEMANTIC ACTIONS FOR THE PRODUCTIONS:
       <PROC.HEAD> ::= <PROC.NAME> ;
       <PROC.HEAD> ::= <PROC.NAME> <FORMAL.PARAM.LIST> ; */
    CALL SSTYPE(L1, PROC);
    SATR(L1) = A;     /* ADDRESS OF FORMAL PARAMETERS */
    CALL XMIT1;
END PRH;

SDB: PROCEDURE(J);
    DECLARE J ADDRESS;
    /* SEMANTIC ACTIONS FOR THE PRODUCTIONS:
       <STORAGE.DECLARATION> ::= <IDENT.SPECIFICATION> BYTE
       <STORAGE.DECLARATION> ::= <BOUND.HEAD> <NUMBER> BYTE */
    CALL XMIT1;
    CALL BSTYPE(L1, KBYTE);  /* BACKSTUFF TYPE */
    YY = J;                  /* LENGTH REQUESTED PER IDENTIFIER */
END SDB;

IDL: PROCEDURE;
    /* SEMANTIC ACTIONS FOR THE PRODUCTIONS:
       <IDENT.SPECIFICATION> ::= <IDENT.LIST> <IDENTIFIER> )
       <IDENT.LIST>          ::= <IDENT.LIST> <IDENTIFIER) , */
    IF NEWSYMB(H2) THEN
    DO;   /* FIRST APPEARANCE OF IDENTIFIER IN CURRENT BLOCK */
	LL = CREATESYM(UNDECL, UNDEF, 0, H1, 2);
	XX = X1 + 1;           /* NO. IDENTIFIERS */
    END;
    ELSE  /* IDENTIFIER ALREADY DEFINED IN CURRENT BLOCK */
    DO;
        CALL KERROR(2);
	CALL XMIT1;   /* IGNORE REDECLARAITON */
    END;
END IDL;

CANTCALL: PROCEDURE(J, N) BYTE;
    DECLARE J ADDRESS;   /* POINTER TO IDENTIFIER IN SYMLIST */
    DECLARE N BYTE;      /* NO. PARAMTERS */
    /* RETURN TRUE IF CANNOT CALL IDENTIFIER WITH N PARAMETERS */
    IF UNDECLARED(J) THEN RETURN 1;
    IF (C := STYPE(LLINK(J))) = KLABEL AND N <> 0 THEN RETURN 1;
    IF C = KBYTE OR C = GLOB THEN RETURN 1;
    RETURN 0;
END CANTCALL;


APH: PROCEDURE;
    /* SEMANTIC ACTIOSN FOR THE PRODUCTIONS:
       <ACTUAL.PARAM.LIST> ::= <AP.HEAD> <CONSTANT> )
       <AP.HEAD> ::= <AP.HEAD> <CONSTANT> , */
    CALL EMIT3C(LXIH, 2);    /* LOAD THE CONSTANT INTO HL */
    IF STYPE(L1) = EXT THEN  /* EXTERNAL PROCEDURE */ TEMP3 = SNAME(L1);
    ELSE TEMP3 = 0;   /* TEMP3 WILL BE MOVED TO THE EXT FIELD IN RELTAB */
    CALL EMIT3A(22H, WA, SATR(L1) + SHL(X1,1), TEMP3);  /* STORE PARAMETER */
    /* SATR(H1) + 2*X1 = ADDRESS OF CORRESPONDING FORMAL PARAMETER */
    X1 = X1 + 1;      /* NO. ACTUAL PARAMTERS */
    CALL XMIT1;
END APH;

REDUCE: PROCEDURE(PN);
    DECLARE PN ADDRESS;
    /* PERFORM A REDUCTION USING PRODUCTION PN */
    TRACE$ON
    IF TRACE='P' THEN DO;
       CALL PRC('P'); CALL TRAA(PN) ; CALL TRAC(';');
    END;
    TRACE$OFF *** */

    IF PN < 30 THEN   /* NO ACTION TO BE PERFORMED */
        RETURN;
    DO CASE(PN - 30); 
    /*** <PROGRAM> ::= <STMT.LIST> ; EOF */
    /*** <STMT.LIST> ::= <STMT> */
    /*** <STMT.LIST) ::= <STMT.LIST) ; <STMT> */
    /*** <STMT) ::= <BASIC.STMT) */
    /*** <STMT> ::= <IF.STMT> */
    /*** <STMT) ::= <ERROR) */
    /*** <BASIC.STMT) ::= <DECL.STMT> */
    /*** <BASIC.STMT) ::= <GROUP> */
    /*** <BASIC.STMT> ::= <PROC.DEFINITION> */
    /*** <BASIC.STMT> ::= <RETURN.STMT> */
    /*** <BASIC.STMT) ::= <CALL.STMT> */
    /*** <BASIC.STMT> ::= <GOTO.STMT> */
    /*** <BASIC.STMT) :: = <REPEAT.STMT> */
    /*** <BASIC.STMT> :: = <CONTROL.STMT> */
    /*** <BASIC.STMT) ::= <COMPARE.STMT> */
    /*** <BASIC.STMT> ::= <EXCHANGE.STMT> */
    /*** <BASIC.STMT> ::= <ASSIGN.STMT> */
    /*** <BASIC.STMT> ::= <LABEL.DEFINITION) <BASIC.STMT> */
    /*** <IF.STMT> ::= <LABEL.DEFINITION> <IF.STMT> */
    /*** <DECL.STMT) ::= DECLARE <DECL.ELEMENT> */
    /*** <DECL.STMT> ::= <DECL.STMT> , <DECL.ELEMENT) */
    /*** <INITIAL.HEAD> ::= INITIAL ( */
    /*** <ENDING> ::= END */
    /*** <ENDING> ::= END <IDENTIFIER> */
    /*** <ENDING> ::= <LABEL.DEFINITION) <ENDING> */
    /*** <INITIALIZATION> :: = <EMPTY> */
    /*** <INITIALIZATION> ::= <ASSIGN.STMT> */
    /*** <ASSIGN.STMT> ::= <VAR.ASSIGN> */
    /*** <ASSIGN.STMT> ::= <REG.ASSIGN> */

    /*** <LABEL.DEFINITION> ::= <IDENTIFIER> */
        /* RETURN: LL = POINTER TO IDENTIFIER ENTRY IN SYMTAB
                   XX = 1 TO INDICATE IDENTIFIER LABEL */
        DO;		
	    XX = 1;
	    IF NEWSYMB(H1) THEN
                /* FIRST APPEARANCE OF IDENTIFIER IN CURRENT BLOCK */
		LL = CREATESYM(KLABEL, CA, CANEXT, 0, 1);
	    ELSE
            /* IDENTIFIER ALREADY DEFINED IN CURRENT BLOCK */
	    DO;
		H1  = LLINK(H1);     /* POINTER INT SYMTAB */
		IF STYPE(H1) <> KLABEL THEN
		    CALL KERROR(1);  /* IDENTIFIER REDCLARED IN SAME BLOCK */
		ELSE /* IDENTIFIER ALREADY DECLARED LABEL */
                DO; IF SBASE(H1) <> UNDEF THEN
		        CALL KERROR(2);   /* CONFLICTING DEFINITION */
		    ELSE  /* DEFINE THE LABEL */
		    DO;
		        CALL SSADDR(L1, CA, CANEXT);
		        CALL XMIT1;
		    END;
                END;
	    END;
	END;
    /*** <LABEL.DEFINITION> ::= <NUMBER> */
        DO;
	    CALL ZEROXX;    /* TO INDICATE NUMERIC LABEL */
	    IF H1 < CANEXT THEN    /* CODE OVERLAP */
	        CALL KERROR(3);
	    DO WHILE H1 > CANEXT;
	        CALL WR(CA, 0);    /* FILL WITH 0'S */
	    END;
        END;
    /*** <IF.STMT> ::= <IF.CLAUSE> <STMT> */
        /* H1 POINTS TO F(FALSE) CHAIN IN RELTAB */
            CALL BRADDR(L1, CA, CANEXT);  /* BACKSUFF F ADDRESS */
    /*** <IF.STMT> ::= <IF.CLAUSE> <TRUE.PART> <STMT> */
        DO;
            /* H2 POINTES TO E(EXIT) ENTRY IN RELTAB */
	    CALL BRADDR(L1, CA, RLOC(L2) + 2);   /* BACKSTUFF F */
	    CALL BRADDR(L2, CA, CANEXT);         /* BACKSTUFF E */
	END;
    /*** <IF.CLAUSE> ::= IF <COMPOUND.CONDITION> THEN */
        /* RETURN POINTER TO F CHAIN IN RELTAB */
            LL = L2;
    /*** <TRUE.PART> ::= <BASIC.STMT> ELSE */
        /* RETURN POINTER TO E ENTRY IN RELTAB */
            LL = EMITL(0C3H, 0);  /* EMIT JMP E (EXIT) */
    /*** <COMPOUND.CONDITION> ::= <AND.HEAD> <SIMPLE.CONDIITON> */
        /* RETURN POINTER TO F CHAIN IN RELTAB */
            LL = EMITL(X2 XOR 0AH, L1);  /* EMIT JNCOND F */
    /*** <COMPOUND.CONDITION> ::= <OR.HEAD> <SIMPLE.CONDIITON> */
        DO;
	    LL = EMITL(X2 XOR 0AH, 0);   /* EMIT JNCOND F */
	    CALL BRADDR(L1, CA, CANEXT); /* BACKSTUFF T */
	END;
    /*** <COMPOUND.CONDITION> ::= <SIMPLE.CONDIITON> */
            LL = EMITL(X1 XOR 0AH, 0);    /* EMIT JNCOND F */
    /*** <AND.HEAD> ::= <SIMPLE.CONDIITON> AND */
            LL = EMITL(X1 XOR 0AH, 0);    /* EMIT JNCOND F */
    /*** <AND.HEAD> ::= <AND.HEAD> <SIMPLE.CONDIITON> AND */
            LL = EMITL(X2 XOR 0AH, L1);   /* EMIT JNCOND F */
    /*** <OR.HEAD> ::= <SIMPLE.CONDIITON> OR */
            LL = EMITL(X1 OR 2, 0);       /* EMIT JCOND T */
    /*** <OR.HEAD> ::= <OR.HEAD> <SIMPLE.CONDIITON> OR */
            LL = EMITL(X2 OR 2, L1);      /* EMID JCOND T */
    /*** <SIMPLE.CONDITION> ::= ( <STMT.LIST> ) <CONDIITON> */
        /* RETURN A NUMERIC CODE REPRESENTING THE CONDITION */
            XX = X4;
    /*** <SIMPLE.CONDITION> ::= <CONDITION> */
            CALL XMIT1;
    /*** <CONDITION> ::= NOT ZERO */
            XX = 0C0H;
    /*** <CONDITION> ::= ZERO */
            XX = 0C8H;
    /*** <CONDITION> ::= NOT CY */
            XX = 0D0H;
    /*** <CONDITION> ::= CY */
            XX = 0D8H;
    /*** <CONDITION> ::= PY ODD */
            XX = 0E0H;
    /*** <CONDITION> ::= PY EVEN */
            XX = 0E8H;
    /*** <CONDITION> ::= PLUS */
            XX = 0F0H;
    /*** <CONDITION> ::= MINUS */
            XX = 0F8H;
    /*** <DECL.ELEMENT> ::= <STORAGE.DECLARATION> */
        /* <STORAGE.DECLARATION> RETURNS:
           H1: POINTER TO A CHAIN OF IDENTIFIERS IN SYMTAB,
           X1: NO. IDENTIFIERS DECLARED,
           Y1: LENGTH (BYTES) REQUESTED PER IDENTIFIER;
           IT ALSO SETS THE GLOBAL VARAIABLE
           IIDA: IDANEXT BEFORE <DECL.ELEMENT> WAS PARSED */
        DO;
	    TEMP3 = IDANEXT - IIDA;  /* TOTAL LENGTH INITIALIZED */
	    TEMP4, I= 0;
	    DO I = 1 TO X1;
		TEMP4 = TEMP4 + Y1;  /* TOTAL LENGTH REQUESTED */
	    END;
	    IF TEMP4 < TEMP3 THEN    /* INITIAL DATA TOO LONG */
	    DO;
	        CALL KERROR(0);
		TEMP4 = TEMP3;       /* RIGHT JUSTIFY INSIDE DATA BLOCK */
	    END;
	    IF TEMP3 = 0 THEN        /* NO DATA INITIALIZED */
	    DO;    /* ALLOCATE IN WA */
	       CALL INCWA(TEMP4);
	       CALL BSADATR(L1, WA, WANEXT, Y1);
	    END;
	    ELSE   /* INITIALIZATION REQUESTED (DATA IS IN IDA) */
	    DO;
		IIDA = IIDA + TEMP4;
		DO WHILE IDANEXT < IIDA;
		    CALL WR(IDA, ' ');  /* PAD WITH BLANKS */
		END;
		CALL BSADATR(L1, IDA, IDANEXT, Y1);  /* ALLOCATE IN IDA */
	    END;
	END;
    /*** <DECL.ELEMENT> ::= <IDENT.SPECIFICATION> <TYPE> */
        /* BACK STUFF TYPE X2 INTO IDENTIFIERS IN CHAIN HA */
            CALL BSTYPE(L1, X2);
    /*** <DECL.ELEMENT> ::= <IDENTIFIER> <DATA.LIST> */
        DO;
            /* <DATA.LIST> RETURNS A POINTER TO 'SKIP' ENTRY IN RELTAB */
	    IF NEWSYMB(H1) THEN
                /* FIRST APPEARANCE OF IDENTIFIER IN CURRENT BLOCK */
	        DO; /* SET ENTRY FOR IDENTIFIER IN SYMBAB */
	            TEMP4 = RLOC(L2) + 2;    /* ADDRESS OF 1st BYTE OF DATA */
                    TEMP3 = CANEXT - TEMP4;  /* TOTAL LENGTH INITIALIZED */
                    TEMP = CREATESYM(KBYTE, CA, TEMP4, TEMP3, 1);
                    CALL BRADDR(L2, 1, CANEXT);
	        END;
	   ELSE /* ERROR: IDENTIFIER ALREADY DECLARED IN THIS BLOCK */
	        CALL KERROR(1);
	END;
    /*** <DATA.LIST> ::= <DATA.HEAD> <CONSTANT> ) */
        /* RETURN POINTER TO 'SKIP' ENTRY IN RELTAB */
            CALL CHC(CA);  /* EMIT THE CONSTANT INTO CA */
    /*** <DATA.HEAD> ::= DATA ( */
        /* RETURN POINTER TO 'SKIP' ENTRY IN RELTAB */
            LL = EMITL(JMP, 0);  /* EMIT JMP SKIP */
    /*** <DATA.HEAD> ::= <DATA.HEAD> <CONSTANT> , */
            CALL CHC(CA);  /* EMIT THE CONSTANT INTO CA */
    /*** <STORAGE.DECLARATION> ::= <IDENT.SPECIFICATION> BYTE */
        /* RETURN POINTER TO INDENTIFIER CHAIN IN SYMTAB */
            CALL SDB(1);
    /*** <STORAGE.DECLARATION> ::= <BOUND.HEAD> <NUMBER> ) BYTE */
            CALL SDB(H2);
    /*** <STORAGE.DECLARATION> ::= <STORAGE.DECLARATION> <INITIAL.LIST> */
            CALL XMIT1;    /* <INITIAL.LIST> ALREADY STORED IN IDA */
    /*** <TYPE> :: = LABEL */
            XX = KLABEL;
    /*** <TYPE> :: = EXTERNAL */
            XX = EXT;
    /*** <TYPE> :: = COMMON */
            XX = GLOB;
    /*** <IDENT.SPECIFICATION> ::= <IDENTIFIER> */
        /* RETURN POINTER TO IDENTIFIER CHAIN IN SYMTAB */
        DO;					/* NAME */
	    IF NEWSYMB(H1) THEN
            /* FIRST APPARENCE OF IDENTIFIER IN CURRENT BLOCK */
	    DO;
		LL = CREATESYM(UNDECL, UNDEF, 0, 0, 1);
		XX = 1;     /* NO. ELEMENTS IN <IDENT.SPECIFICATION> */
		IIDA = IDANEXT;  /* SAVED CURRENT VALUE OD IDANEXT */
	    END;
	    ELSE  /* IDENTIFIER ALREADY DEFINED IN CURRENT BLOCK */
	    	CALL KERROR(1);
	END;
    /*** <IDENT.SPECIFICATION> ::= <IDENT.LIST> <IDENTIFIER> ) */
            CALL IDL;
    /*** <IDENT.LIST> ::= ( */
        /* RETURN POINTER TO IDENTIFIER CHAIN IN SYMTAB */
        DO;
	    LL = 0;          /* POINTER */
	    CALL ZEROXX;     /* XX: NO. IDENTIFIERS IN <IDENT.LIST> */
	    IIDA = IDANEXT;  /* SAVE CURRENT VALUE OF IDANEXT */
	END;
    /*** <IDENT.LIST> ::= <IDENT.LIST> <IDENTIFIER> , */
            CALL IDL;
    /*** <BOUND.HEAD> ::= <IDENT.SPECIFICATION> */
        /* RETURN POINTER TO IDENTIFIER CHAIN IN SYMTAB */
            CALL XMIT1;
    /*** <INITIAL.LIST> ::= <INITIAL.HEAD> <CONSTANT> ) */
            CALL CHC(IDA);   /* EMIT THE CONSTANT INTO IDA */
    /*** <INITIAL.HEAD> ::= <INITIAL.HEAD> <CONSTANT> , */
            CALL CHC(IDA);   /* EMIT THE CONSTANT INTO IDA */
    /*** <GROUP> ::= <GROUP.HEAD> ; <ENDING> */
        DO;
	    IF X1 THEN    /* THIS IS A CASE GROUP */
	    DO;   /* H1 POINTS TO 'EXIT' CHAIN IN RELTAB */
	    	TEMP1 = L1;   /* POINTER TO THE CHAIN */
		TEMP2 = 0;    /* POINTER TO AN EMPTY CHAIN */
                /* Y1: NO. STMTS IN THE CASE GROUP */
	        DO WHILE NOT SHR(REXT(TEMP1), 15);   /* POSITIVE */
                    /* INVERT THE CHAIN */
		    TEMP = REXT(TEMP1);    /* NEXT */
		    REXT(TEMP1) = TEMP2;
		    TEMP2 = TEMP1;
		    TEMP1 = TEMP;
		END;
                /* TEMP1 NOW POINTS TO THE JPVEC ENTRY IN RELTAB */
                /* TEMP2 POINTS TO THE 'EXIT' CHAIN IN RELTAB */
		TEMP4 = -REXT(TEMP1);     /* ADDRESS OF LO */
		CALL SRADDR(TEMP1, CA, CANEXT);  /* BACKSUFF JPVEC */
		REXT(TEMP1) = 0;          /* NOT EXTERNAL */
		TEMP3 = CANEXT + SHL(Y1,1);  /* ADDRES OF EXIT */
		DO WHILE TEMP2 <> 0;
                    /* GENERATE JUMP VECTOR, BACKSUFF EXIT */
		    CALL EMITA(CA, TEMP4, 0);  /* EMIT N-TH LABEL (LN) */
		    TEMP1 = REXT(TEMP2);
		    REXT(TEMP2) = 0;      /* NOT EXTERNAL */
		    CALL SRADDR(TEMP2, CA, TEMP3);  /* BACKSUFF EXIT */
		    TEMP4 = RLOC(TEMP2) + 2;   /* COMPUTE NEXT LN */
		    TEMP2 = TEMP1;             /* NEXT ENTRY */
		END;
	    END;
	    ELSE IF X1 = 2 THEN    /* THIS IS AN ITERATIVE GROUP */
	    DO;  /* H1 POINTS TO F CHAIN IN RELTAB */
		CALL EMIT3A(JMP, CA, Y1, 0);    /* EMIT JMP LOOP */
		CALL BRADDR(L1, CA, CANEXT);    /* BACKSTUFF F */
	    END;
	    CALL POPBL(1);   /* EXIT BLOCK, SHRINK WA */
	END;
    /*** <GROUP.HEAD> ::= <DO> */
        /* RETURN XX INDICATING TYPE OF GROUP */
            CALL ZEROXX;
    /*** <GROUP.HEAD> ::= <DO> <ITERATIVE.CLAUSE */
        DO;
	    CALL XMIT2;
	    XX = 2;
	END;
    /*** <GROUP.HEAD> ::= <DO> <CASE.SELECTOR> */
        DO;
	    CALL XMIT2;
	    XX = 3;
	END;
    /*** <GROUP.HEAD> ::= <GROUP.HEAD> ; <STMT> */
        DO;
	   CALL XMIT1;
	   IF X1 THEN    /* CASE GROUP */
	   DO;
	   	HH = EMITL(JMP, L1);    /* EMIT JMP EXIT */
		YY = Y1 + 1;      /* NO. STATEMENTS IN THE CASE GROUP */
	   END;
	END;
    /*** <DO> ::= DO */
            CALL PUSHBL;   /* ENTER A NEW BLOCK */
    /*** <ITERATIVE.CLAUSE> ::= <INITIALIZATION> <BY> <ASSIGN.STMT>
                                <WHILE> <COMPOUND.CONDITION> */
        /* RETURN HH=POINTER TO F CHAIN IN RELTAB, YY=LOOP ADDRESS */
        DO;
	    LL = L5;       /* POINTER */
	    CALL BRADDR(L2, CA, H4);  /* BACKSTUFF SKIP */
	    YY = RLOC(L2) + 2;      /* ADDRESS OF LOOP */
	END;
    /*** <ITERATIVE.CLAUSE> ::= <INITIALIZATION> <WHILE><COMPOUND.CONDITION> */
        DO;
	    YY = H2;      /* ADDRESS OF LOOP */
	    LL = L3;      /* POINTER TO F CHAIN IN RELTAB */
	END;
    /*** <BY> ::= BY */
	/* RETURN POINTER TO SKIP ENTRY IN RELTAB */
	LL = EMITL(JMP, 0);	/* EMIT JMP SKIP */
    /*** <WHILE> ::= WHILE */
	/* RETURN ADDRESS OF NEXT INSTRUCTION (COMPOUND.CONDIITON) */
	HH = CANEXT;
    /*** <CASE.SELECTOR> ::= CASE <REG> */
	/* RETURN HH = POINTER TO A CHAIN IN RELTAB.
		  YY = NO. STATEMENTS IN THE CASE GROUP */
	DO;
	    IF HLREG(2) THEN		/* <REG> IS HL */
	    DO;
	        CALL EMIT2(PUSHD, XCHG);
		LL = EMITL(LXIH, 0);	/* EMIT LXIH JPVEC */
		REXT(LL) = -(CANEXT + 8);  /* SAVE - ADDRESS OF LO */
		CALL EMIT4(DADD, DADD, MOVEM, INXH);
		CALL EMIT4(MOVDM, XCHG, POPD, PCHL);
		YY = 0;	 /* NO. STATEMENTS */
	    END; /* OF <REC> IS HL */
	    ELSE /* NOT IMPLEMENTED */
	    	CALL KERROR(8);
	END;
    /*** <PROC DEFINITION> ::= <PROC.HEAD> <STMT.LIST> ; <ENDING> */
	DO;
	    CALL EMIT1(RET);	/* SUPPLY A RETURN */	
	    CALL BRADDR(Y1, CA, CANEXT); /* BACKSTUFF SKIP */
	    CALL POPBL(0);	/* EXIT BLOCK, DO NOT SHRINK WA */
	END;
    /*** <PROC.HEAD> ::= <PROC.NAME> ; */
	/* RETURN POINTER TO SKIP ENTRY IN RELTAB */
	DO;
		CALL PRH(0FFFFH); /* NO FORMAL PARAMS: SET ATR TO -1 */
	END;
    /*** <PROC.HEAD> ::= <PROC.NAME> <FORMAL.PARAM.LIST */
	CALL PRH(WANEXT - SHL(X2,1));	/* ADDRESS OF FORMAL PARMS */
    /*** <PROC.NAME> :: <LABEL.DEFINITION> PROCEDURE */
	/* RETURN: HH = POINTER TO PROCEDURE ENTRY IN SYMTAB
		   YY = POINTER TO 'SKIP' ENTRY IN RELTAB */
	DO;
	    CALL XMIT1;
	    IF X1 THEN	/* IDENTIFIER LABEL */
	    DO;		/* EMIT CODE TO SKIP THE PROCEDURE */
	    	YY = EMITL(JMP, 0);	/* EMIT JMP SKIP */
			/* RETURN POINTER TO SKIP ENTRY IN RELTAB */
		SDISPL(L1) = CANEXT;	/* PROCEDURE ENTRY IS AFTER
					   THE JMP INSTRUCTION */
		CALL PUSHBL;	/* ENTER A NEW BLOCK */
	    END;
	    ELSE	/* NOT A VALID PROCEDURE */
		CALL KERROR(3);
	END;
    /*** <FORMAL.PARAM.LIST> ::= <FP.HEAD> <IDENTIFIER> ) */
	/* RETURN NUMBER OF FORMAL PARAMETERS */
	CALL FPH;
    /*** <FP.HEAD> ::= ( */
	/* RETURN NO. OF FORMAL PARAMETERS */
	CALL ZEROXX;
    /*** <FP.HEAD> ::= <FP.HEAD> <IDENTIFIER> , */
	CALL FPH;
    /*** <RETURN.STMT> ::= RETURN */
	CALL EMIT1(RET);
    /*** <RETURN.STMT> ::= IF <SIMPLE.CONDITION> RETURN */
	CALL EMIT1(X2);	/* EMIT RNZ, RZ, RNC ... */
    /*** <CALL.STMT> ::= <CALL> <IDENTIFIER> */
	DO;
	    IF CANTCALL(H2, 0) THEN
	        CALL KERROR(6);
	    ELSE
	    DO;
	        CALL EMIT3IA(X1 OR 4, H2, 0);
	    END;
	END;
    /*** <CALL.STMT> ::= <CALL> <ACTUAL.PARAM.LIST> */
	DO;			
	    CALL EMIT1(POPH);
	    CALL EMIT3IA(X1 OR 4, SNAME(L2), 0);
	END;
    /*** <CALL.STMT> ::= <CALL> <NUMBER> */
	DO;
	    IF X1 = 0CDH /* UNCONDITIONAL CALL */
	       AND ((H2 AND 0FFC7H) = 0) /* 0, 8, 16, 24.... 56 */
	       THEN	/* EMIT RST INSTRUCTION */
		CALL EMIT1(L2 OR 0C7H);
	    ELSE	/* EMIT CALL */
	    	CALL EMIT3D(X1 OR 4, H2); /* CALL, CNZ, CZ .... */
	END;
    /*** <ACTUAL.PARAM.LIST> ::= <AP.HEAD> <CONSTANT> ) */
	CALL APH;
    /*** <AP.HEAD> ::= <IDENTIFIER> ( */
	DO;
	    IF CANTCALL(H1, 1) THEN
	        CALL KERROR(6);
	    ELSE
	    DO;
	        LL = LLINK(H1);		/* POINTER TO IDENTIFIER IN SYMTAB */
	        CALL ZEROXX;		/* NO. ACTUAL PARAMETERS */
	        CALL EMIT1(PUSHH);	/* SAVE HL */
	    END;
	END;
    /*** <AP.HEAD> ::= <AP.HEAD> <CONSTANT> , */
	CALL APH;
    /*** <CALL> ::= CALL */
	XX = 0CDH;
    /*** <CALL> ::= IF <SIMPLE.CONDITION> CALL */
	CALL XMITX2;
    /*** <GOTO.STMT> ::= <GOTO> <IDENTIFIER> */
	DO;
	    IF CANTCALL(H2, 0) THEN
	        CALL KERROR(11);
	    ELSE
	    DO;
	        CALL EMIT3IA(X1 OR 2, H2, 0); /* EMIT JMP, JNZ, JZ... */
	    END;
	END;
    /*** <GOTO.STMT> ::= <GOTO> <NUMBER> */
	CALL EMIT3D(X1 OR 2, H2);	/* JMP, JNZ< JZ */
    /*** <GOTO.STMT> ::= <GOTO> M ( HL ) */
	CALL EMIT1(PCHL);
    /*** <GOTO> ::= GOTO */
	XX = 0C3H;
    /*** <GOTO> ::= IF <SIMPLE.CONDITION> GOTO */
	CALL XMITX2;
    /*** <REPEAT.STMT) ::= <REPEAT> <STMT.LIST> ; UNTIL <COMPOUND.CONDIITON */
	CALL BRADDR(L5, CA, H1);	/* BACKSTUFF LOOK ADDRESS */
    /*** <REPEAT> ::= REPEAT */
	HH = CANEXT;	/* SAVE ADDRESS OF NEXT INSTRUCTION */
    /*** <CONTROL.STMT> :: = HALT */
	CALL EMIT1(76H);	/* HLT */
    /*** <CONTROL.STMT> :: = NOP */
	CALL EMIT1(0);		/* NOP */
    /*** <CONTROL.STMT> :: = DISABLE */
	CALL EMIT1(0F3H);	/* DI */
    /*** <CONTROL.STMT> :: = ENABLE */
	CALL EMIT1(0FBH);	/* EI */
    /*** <COMPARE.STMT> ::= <REG> :: <SEC> */
	DO;
	    IF AREG(1) THEN	/* <REG> IS REG A */
	    DO;
	        IF X3 =  TREG		/* <SEC> IS A REGISTER */
		   AND AM(3) THEN  	  /* <SEC> IS A, B, ... M */
		    CALL EMIT1(L3 OR 0B8H);	/* EMIT A CMP */
		ELSE IF X3 = TNUMBER THEN /* <SEC> IS A NUMBER */
	    	    CALL EMIT2(0FEH, L3);	/* EMIT A CPI */
		ELSE			/* ERROR */
	    	    CALL CANTDO;
	    END;
	    ELSE
		CALL CANTDO;
	END;
    /*** <EXCHANGE.STMT> ::= <REG> == <REG.EXPR> */
	DO;
	    IF HLREG(1) THEN	/* <REG> IS HL */
	    DO;
	    	IF DEREG(3) THEN
		    CALL EMIT1(XCHG);
		ELSE IF STACKR(3) THEN
		    CALL EMIT1(0E3H);	/* XTHL */
		ELSE
		    CALL CANTDO;
	    END;
	    ELSE
		CALL CANTDO;
	END;
    /*** <VAR.ASSIGN> ::= <VAR> = <REG.EXPR> */
	DO;
	    IF AREG(3) THEN	/* <REG.EXPR> REFERS TO REG A */
	    DO;
	        IF X1 = TMXX THEN	/* <VAR> IS M(BC) OR M(DE) */
		    CALL EMIT1(L1 AND 0F2H);	/* EMIT STAX B, STAX D */
		ELSE IF X1 = TOUT THEN	/* <VAR> IS OUT(<NUMBER>) */
		    CALL EMIT2(0D3H, L1);	/* EMIT 'OUT' INSTRUCTION */
		/* TRY TO EMIT A STA INSTRUCTION */
		ELSE IF LDAHL(32H, 1) THEN	/* EMITTED STA */
		    ;
		ELSE
		    CALL CANTDO;
	    END;	/* OF <REG.EXPR> REFERS TO REG A */
	    ELSE IF HLREG(3) THEN	/* <REG.EXPR> REFERS TO HL */
	    DO;
		/* TRY TO EMIT A SHLD INSTRUCTION */
	        IF LDAHL(22H, 1) THEN			/* shld */
		    ;
		ELSE
		    CALL CANTDO;
	    END;
	    ELSE  /* NEITHER A NOR HL: ERROR */
	    	CALL CANTDO;
	END;
    /*** <REG.EXPR> ::= <REG> */
	CALL XMIT1;
    /*** <REG.EXPR> ::= ( <REG.ASSIGN> ) */
	CALL XMIT2;
    /*** <REG.ASSIGN> ::= <REG> = <PRIM> <BINARY.OP> <SEC> */
	DO;
	    CALL LOADPRIM(3);		/* LOAD <PRIM> INTO <REG> */
	    CALL BINOPSEC(4, 5);	/* EXECUTE <BINARY.OP> ON <SEC> */
	    CALL XMIT1;
	END;
    /*** <REG.ASSIGN> ::= <REG> = <UNARY.OP> <PRIM> */
	DO;
	    CALL LOADPRIM(4);	/* LOAD <PRIM> INTO <REG> */
	    /* NOW EXECUTE <UNARY.OP> */
	    IF AREG(1) THEN	/* <REG> IS A */
	        CALL EMIT1(X3);	/* EMIT RLC< RRC, RAL, RAR, DAA, CMA */
	    ELSE IF CYREG(1)	/* <REG> IS CARRY */
		 AND X3 = 2FH THEN	/* NOT */
	        CALL EMIT1(3FH);	/* EMIT CMC */
	    ELSE		/* ERROR */
	    	CALL CANTDO;
	    CALL XMIT1;
	END;
    /*** <REG.ASSIGN> ::= <REG> = <PRIM> */
	DO;
	    CALL LOADPRIM(3);	/* LOAD <PRIM> INTO REG */
	    CALL XMIT1;
	END;
    /*** <REG.ASSIGN> ::= <REG.ASSIGN> , <BINARY.OP> <SEC> */
	DO;
	    CALL BINOPSEC(3, 4);	/* EXECUTE <BINARY.OP> ON <SEC> */
	    CALL XMIT1;
	END;
    /*** <PRIM> ::= <VAR> */
	CALL XMIT1;
    /*** <PRIM> ::= <SEC> */
	CALL XMIT1;
    /*** <SEC> ::= <REG.EXPR> */
	CALL XMIT1;
    /*** <SEC> ::= <CONSTANT> */
	CALL XMIT1;
    /*** <CONSTANT> ::= <STRING> */
	DO;
	    XX = TSTRING;
	    CALL XMITH1;	/* POINTER TO STRING IN SYMLIST */
	END;
    /*** <CONSTANT> ::= <NUMBER> */
	DO;
	    XX = TNUMBER;
	    CALL XMITH1;	/* VALUE OF NUMBER */
	END;
    /*** <CONSTANT> ::= - <NUMBER> */
	DO;
	    XX = TNUMBER;
	    HH = -H2;
	END;
    /*** <CONSTANT> ::= . <IDENTIFIER> */
	DO;
	    XX = TADDRVAR;
	    CALL IDN(2, 0);
	END;
    /*** <CONSTANT> ::= . <IDENTIFIER> ( <NUMBER> ) */
	DO;
	    XX = TADDRVAR;
	    CALL IDN(2, H4);
	END;
    /*** <CONSTANT> ::= . <STRING> */
	DO;
	    XX = TADDRSTR;
	    HH = H2;	/* POINTER TO STRING IN SYMLIST */
	END;
    /*** <REG> ::= <A.L> */
	CALL SETREG(H1);	/* A=7, B=0, C=1, D=2, E=3, H=4, L=5 */
    /*** <REG> ::= BC */
	CALL SETREG(TBC);
    /*** <REG> ::= DE */
	CALL SETREG(TDE);
    /*** <REG> ::= HL */
	CALL SETREG(THL);
    /*** <REG> ::= SP */
	CALL SETREG(TSP);
    /*** <REG> ::= STACK */
	CALL SETREG(TSTACK);
    /*** <REG> ::= PSW */
	CALL SETREG(TPSW);
    /*** <REG> ::= M ( HL ) */
	CALL SETREG(TMHL);
    /*** <REG> ::= CY */
	CALL SETREG(TCY);
    /*** <BINARY.OP> ::= + */
	XX = 80H;
    /*** <BINARY.OP> ::= - */
	XX = 90H;
    /*** <BINARY.OP> ::= AND */
	XX = 0A0H;
    /*** <BINARY.OP> ::= OR */
	XX = 0B0H;
    /*** <BINARY.OP> ::= XOR */
	XX = 0A8H;
    /*** <BINARY.OP> ::= ++ */
	XX = 88H;
    /*** <BINARY.OP> ::= -- */
	XX = 98H;
    /*** <BINARY.OP> ::= < */
	XX = 17H;			/* RAL */
    /*** <BINARY.OP> ::= > */
	XX = 1FH;			/* RAR */
    /*** <BINARY.OP> ::= NOT */
	XX = 2FH;			/* CMA */
    /*** <BINARY.OP> ::= DEC */
	XX = 27H;			/* DAA */
    /*** <BINARY.OP> ::= >> */
	XX = 0FH;			/* RRC */
    /*** <BINARY.OP> ::= << */
	XX = 7;				/* RLC */
    /*** <VAR> ::= M ( BC ) */
	DO;
	    XX = TMXX;
	    LL = 0FH;
	END;
    /*** <VAR> ::= M ( DE ) */
	DO;
	    XX = TMXX;
	    LL = 1FH;
	END;
    /*** <VAR> ::= <IDENTIFIER> */
	DO;
	    XX = TVAR;
	    CALL IDN(1, 0);
	END;
    /*** <VAR> ::= <IDENTIFIER> ( NUMBER ) */
	DO;
	    XX = TVAR;
	    CALL IDN(1, H3);
	END;
    /*** <VAR> ::= IN ( NUMBER ) */
	DO;
	    XX = TIN;
	    HH = H3;
	END;
    /*** <VAR> ::= OUT ( NUMBER ) */
	DO;
	    XX = TOUT;
	    HH = H3;
	END;
    /*** <VAR> ::= M ( <CONSTANT> ) */
	DO;
	    XX = (X3 AND 0FH) OR 28H;
		/* STRING	: CHANGES FROM 11H TO 29H
		   NUMBER	: CHANGES FROM 13H TO 2BH
		   .IDENTIFIER	: CHANGES FROM 15H TO 2DH
		   .STRING	: CHANGES FROM 17H TO 2FH */
	    HH = H3;
	    YY = Y3;
	END;
    END;	/* OF CASE PN */
END REDUCE;

MAIN:
    DECLARE ACTION LIT 'TEMP';

/* INITIATE */
    CALL CMON(INITDSK, 0);	/* SELECT DISK */
    TRACE$ON
    CALL PRL(.'TRACE(C,D,P,N):$'); TRACE=VMON(1, 0);
    TRACE$OFF *** */
    /* PEN SYMBOL LIST FILE */
    CALL OPENF('S');
    /* LOAD SYMBOL LIST INTO MEMORY */
    /* MEMPTR ALREADY INITIALISED = 0 */
    DO WHILE IBP <> 0;	/* NOT EOF */
        SYMLIST(MEMPTR) = GET1;	/* READ 1 BYTE INTO MEMORY */
	MEMPTR = MEMPTR + 1;
	IF MEMPTR >= TOPMEM THEN	/* SYMBOL LIST OVFLW */
	    CALL KERROR(0F6H);
    END;
    /* OPEN PARSER ACTIONS FILE */
    CALL OPENF('P');
    /* SET NAMES OF OUTPUT FILES */
    DO I = 1 TO 8;
        CAFCB(I), IDAFCB(I), RTFCB(I) = IFCB(I);
    END;
    /* CREATE NEW VERSIONS OF THE OUTPUT FILES */
    CALL MAKEF(.CAFCB);
    CALL MAKEF(.IDAFCB);
    CALL MAKEF(.RTFCB);
    /* INITIALIZE THE RELOCATION TABLE */
    DO I = 0 TO RELTSIZE;
        CALL SRBASE(I, UNUSED);
    END;
    /* ENTER INITIAL BLOCK AND START COMPILING */
    CALL PUSHBL;

/* MAIN LOOP */
    DO WHILE COMPILING;
        ACTION = GET1;
	IF ACTION = XREDUCE THEN
	DO;
	   DECLARE I BYTE; /* INDEX OF HANDLE(0) */
	   I = PTOP - GET1; /* GET1: NO. ELEMENTS IN THE HANDLE */
	   BASEH = .PSH(I);
	   BASEX = .PSX(I);
	   BASEY = .PSY(I);
	   /* SET NON-INDEXED VARIABLES */
	   H1 = H(1); H2 = H(2); H3 = H(3); H4 = H(4); H5 = H(5);
	   X1 = X(1); X2 = X(2); X3 = X(3); X4 = X(4);
	   Y1 = Y(1); Y2 = Y(2); Y3 = Y(3);
	   HH, LL = 0;
	   CALL REDUCE(DOUBLE(GET1) AND 0FFH);
	   PTOP = I + 1;
	   PSH(PTOP) = HH OR LL;
	   PSX(PTOP) = XX;
	   PSY(PTOP) = YY;
	   TRACE$ON
	   IF TRACE='P' THEN CALL TRAC('Q');
	   TRACE$OFF *** */
	END;
	ELSE IF ACTION = XSHIFT THEN
	DO;
	    IF (PTOP := PTOP + 1) >= STACKSIZE THEN /* PARSE STACK OVFLW */
	        CALL KERROR(0F1H);
	    PSH(PTOP) = GET2;	/* SHIFT VALUE INTO PARSE STACK */
	   TRACE$ON
	   IF TRACE='P' THEN CALL TRAC('X');
	   TRACE$OFF *** */
	END;
	ELSE IF TEMP = XLINE THEN	/* UPDATE LINE COUNTER */
	    LINE = GET2;
	ELSE IF TEMP = XACCEPT THEN
	    COMPILING = 0;
	ELSE
	    CALL KERROR(0F5H);		/* FILE ERROR */
    END;	/* OF WHILE COMPILING */
/* TERMINATE */
    /* FLUSH RELOCATION TABLE */
    DO I = 0 TO LAST(RSB);
        IF RBASE(I) = UNDEF THEN	/* UNRESOLVED REFERENCE */
	    CALL KERROR(0EH);
	IF RBASE(I) <> UNUSED THEN
	    CALL DUMPRT(I);
    END;
    /* DUMP REMAINDER OF SYMBOL TABLE */
    CALL POPBL(0);
    /* WRITE RECORD CONTAINIGN SEGMENT SIZES */
    CALL WRR1('.');
    CALL WRR2(CANEXT);
    CALL WRR2(IDANEXT);
    CALL WRR2(WASIZE);
    /* FLUSH BUFFERS */
    CALL FLUSH(.CAFCB);
    CALL FLUSH(.IDAFCB);
    CALL FLUSH(.RTFCB);
    /* CLOSE FILES AND QUIT */
    CALL CLOSEALL;
EOF;
