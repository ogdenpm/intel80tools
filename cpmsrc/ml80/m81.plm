/* $A=1 $G=1 $S=2 */
/*
      ML81 RECONSTRUCTED FROM BINARY
      REVISED TO UPDATE BASED ON ORIGINAL THESIS SOURCE
      NOTE THERE ARE SOME MINOR CHANGES CF. THESIS
      1) OUTPUT BUFFER IS 512 BYTES AND CPM DEFAULT BUFFER IS
     USED DIRECTLY FOR INPUT 
      2) THE YACC TABLES ARE STATICALLY BOUND
      3) A MINOR OPTIMISATION IS THAT THE STARTUP CODE IS AFTER
     THE RESERVED WORDS SO IS
         OVER WRITTEN ONCE RUN
      4) TAB IS NOW ACCEPTED AS A BLANK
      5) FBASE IS NOW READ FROM LOCATION 6 AND NOT FIXED

*/
DECLARE LIT  LITERALLY 'LITERALLY',
    FOREVER  LITERALLY 'WHILE 1',
    TABCH    LITERALLY '9',
    CR       LITERALLY '0DH',
    LF       LITERALLY '0AH',
    CONTROLZ LITERALLY '1AH',
    TRUE     LITERALLY '1',             
    FALSE    LITERALLY '0';

/* YACC-ASSIGNED TERMINAL NUMBERS */
DECLARE YERROR  LIT '256',
    IDENTIFIER  LIT '257',
    NUMBER      LIT '258',
    STRING      LIT '259';

/* CP/M SYSTEM CONSTANTS */
DECLARE CPM     LIT '0',   /* CP/M REBOOT ENTRY */
        IFCBA   LIT '5CH', /* INPUT FCB ADDRESS */
        SBUFA   LIT '80H', /* SYSTEM BUFFER ADDRESS */
        BDOS     LIT '5';   /* CPM DOS ENTRY POINT */

/* I/O PRIMATIVES */
DECLARE PRINTCHAR  LITERALLY '2',
        PRINT      LITERALLY '9',
        OPEN       LITERALLY '15',
        CLOSE      LITERALLY '16',
        MAKE       LITERALLY '22',
        DELETE     LITERALLY '19',
        READBF     LITERALLY '20',
        WRITEBF    LITERALLY '21',
        INITDSK    LITERALLY '13',
        SETBUF     LITERALLY '26';

DECLARE ERR$STRTOOLONG       LITERALLY '0F3H',
        ERR$TOOMANYMACROS    LITERALLY '0F1H',
        ERR$EOF              LITERALLY '1',
        ERR$BADNUM           LITERALLY '2',
        ERR$TOOBIG           LITERALLY '3',
        ERR$SYNTAX           LITERALLY '7',
        ERR$TOOMUCHPUSHSTING LITERALLY '0F2H',
        ERR$M81ERROR         LITERALLY '0F5H',
        ERR$FATALSYNTAX      LITERALLY '0F7H',
        ERR$UNDEF            LITERALLY '17',
        ERR$MACROHASPARAMS   LITERALLY '18',
        ERR$TOOMANYPARAMS    LITERALLY '19',
        ERR$NONNUMASSIGN     LITERALLY '20',
        ERR$NONNUMERICEXPR   LITERALLY '21';


100H:    /* ORIGIN FOR VMON PROGRAM REMOVE LEADING COMMENT FOR PLM V2*/

DECLARE
    FBASE$P ADDRESS INITIAL(6),
    OUTFCB(33) BYTE INITIAL(0, /* FILE NAME */ '        ',
                               /* FILE TYPE */ 'L80', 0,0,0,0),
    IFA ADDRESS INITIAL(IFCBA),
    IFCB BASED IFA(33) BYTE,

    /* OUTPUT BUFFER */
    OUTBUF(512) BYTE,
    OBP ADDRESS INITIAL(0),

    /* INPUT BUFFER */
    IBUF$P ADDRESS INITIAL(SBUFA),
    IBUF BASED IBUF$P (128) BYTE,
    IBP BYTE INITIAL(128);

    /* PARSER TABLES MASKS */
DECLARE ACTMASK   LIT '0F000H',
        SYMBMASK  LIT '01000H',
        SHIFTMASK LIT '02000H',
        REDMASK   LIT '03000H',
        ERRORMASK LIT '00000H',
        DEFAULT   LIT '0FFFFH';

    /* PARSER GLOBAL VARIABLES */
DECLARE STACKSIZE LITERALLY '30',
    PSTACK(STACKSIZE) ADDRESS INITIAL(0), /* PARSE STACK */
    VSTACK(STACKSIZE) ADDRESS INITIAL(0), /* VALUE STACK */
    PTOP BYTE INITIAL(0),  /* PARSE STACK POINTER */
    PARSING BYTE INITIAL(1),
    RECOVERING BYTE INITIAL(0),
    SEARCHING BYTE,
    (INPUTSY, TAB, ACTION) ADDRESS,
    IT BYTE,
    ERRORCOUNT ADDRESS INITIAL(0);

    /* THE MAIN PARSER TABLES */
DECLARE LRACT(268) ADDRESS INITIAL(
        0, 105BH, 2002H, 0, 1000H, 4000H, 105BH, 2003H,
        0, 1100H, 200BH, 1101H, 200DH, 1108H, 200CH, 1109H,
        2012H, 110AH, 2013H, 110BH, 2014H, 110CH, 2015H, 110DH,
        2016H, 1110H, 2017H, 0, 105DH, 2019H, 0, 1101H,
        201AH, 3003H, 3004H, 3005H, 3006H, 3007H, 3008H, 3009H,
        1101H, 201BH, 0, 105FH, 201CH, 3016H, 1101H, 2025H,
        1102H, 2026H, 1021H, 2021H, 102DH, 2028H, 1028H, 2027H,
        0, 1101H, 202AH, 1103H, 2029H, 0, 1103H, 202BH,
        3015H, 300EH, 300FH, 3010H, 3011H, 1101H, 202DH, 0,
        301AH, 105DH, 202EH, 0, 3001H, 300BH, 300AH, 1104H,
        2031H, 105CH, 2030H, 300DH, 1026H, 2032H, 301BH, 301EH,
        3020H, 1101H, 2025H, 1102H, 2026H, 102DH, 2028H, 1028H,
        2027H, 0, 1105H, 203AH, 1106H, 203BH, 1107H, 203CH,
        103DH, 2037H, 103CH, 2038H, 103EH, 2039H, 102BH, 2035H,
        102DH, 2036H, 3022H, 102AH, 203DH, 102FH, 203EH, 1025H,
        203FH, 302AH, 302DH, 3031H, 3032H, 1101H, 2042H, 1102H,
        2026H, 1021H, 2021H, 102DH, 2028H, 1028H, 2027H, 0,
        1102H, 2043H, 0, 3012H, 3014H, 3017H, 1104H, 2031H,
        110EH, 2044H, 105CH, 2030H, 0, 3013H, 3002H, 1104H,
        2031H, 105CH, 2030H, 300CH, 1101H, 2025H, 1102H, 2026H,
        1021H, 2021H, 102DH, 2028H, 1028H, 2027H, 0, 1101H,
        2025H, 1102H, 2026H, 1021H, 2021H, 102DH, 2028H, 1028H,
        2027H, 0, 3021H, 1101H, 2025H, 1102H, 2026H, 102DH,
        2028H, 1028H, 2027H, 0, 1101H, 2025H, 1102H, 2026H,
        102DH, 2028H, 1028H, 2027H, 0, 3024H, 3025H, 3026H,
        3027H, 3028H, 3029H, 1101H, 2025H, 1102H, 2026H, 102DH,
        2028H, 1028H, 2027H, 0, 1029H, 204EH, 0, 1104H,
        2031H, 105CH, 2030H, 1029H, 204FH, 0, 105FH, 201CH,
        3031H, 3035H, 1103H, 2050H, 0, 1026H, 2032H, 301CH,
        1026H, 2032H, 301DH, 301FH, 102BH, 2035H, 102DH, 2036H,
        3023H, 102AH, 203DH, 102FH, 203EH, 1025H, 203FH, 302BH,
        102AH, 203DH, 102FH, 203EH, 1025H, 203FH, 302CH, 302EH,
        302FH, 3030H, 3033H, 3034H, 110FH, 2051H, 3018H, 1103H,
        2052H, 0, 3019H, 0FFFFH),

    LRPACT(85) ADDRESS INITIAL(
        0, 1, 4, 9, 9, 1CH, 1FH, 22H,
        23H, 24H, 25H, 26H, 27H, 28H, 2BH, 2EH,
        39H, 3EH, 2EH, 41H, 42H, 43H, 44H, 45H,
        48H, 49H, 4CH, 4DH, 4EH, 2EH, 4FH, 54H,
        57H, 58H, 59H, 62H, 73H, 7AH, 7BH, 7CH,
        7DH, 88H, 8BH, 8CH, 8DH, 8EH, 95H, 96H,
        97H, 9CH, 9CH, 0A7H, 0B2H, 0B3H, 0BCH, 0BCH,
        0C5H, 0C6H, 0C7H, 0C8H, 0C9H, 0CAH, 0CBH, 0CBH,
        0CBH, 0D4H, 0D7H, 0DEH, 0E1H, 0E2H, 0E5H, 0E8H,
        0EBH, 0ECH, 0F1H, 0F8H, 0FFH, 100H, 101H, 102H,
        103H, 104H, 107H, 10AH, 0FFFFH),

    LRR1(55) BYTE INITIAL(
        0, 1, 1, 2, 2, 2, 2, 2, 2, 2, 3, 3, 4, 5, 0AH, 0AH,
        0AH, 0AH, 6, 0BH, 0BH, 7, 0CH, 0CH, 8, 8, 0DH, 9, 9,
        9, 0EH, 0EH, 0FH, 0FH, 10H, 10H, 12H, 12H, 12H, 12H,
        12H, 12H, 11H, 11H, 11H, 13H, 13H, 13H, 13H, 14H, 14H,
        14H, 14H, 14H, 0FFH),

    LRR2(55) BYTE INITIAL(
        0, 3, 4, 1, 1, 1, 1, 1, 1, 1, 2, 2, 3, 2, 1, 1, 1,
        1, 2, 2, 2, 1, 1, 2, 4, 6, 1, 1, 3, 3, 1, 3, 1, 2,
        1, 3, 1, 1, 1, 1, 1, 1, 1, 3, 3, 1, 3, 3, 3, 1, 1,
        3, 3, 2, 0FFH),

    LRGO(72) ADDRESS INITIAL(
        0, 0FFFFH, 1, 3, 18H, 0FFFFH, 4, 0FFFFH, 5, 27H, 40H,
        0FFFFH, 6, 0FFFFH, 7, 0FFFFH, 8, 0FFFFH, 9, 0FFFFH,
        0AH, 11H, 2CH, 1CH, 2FH, 27H, 41H, 0FFFFH, 1DH, 0FFFFH,
        0EH, 0FFFFH, 0FH, 0FFFFH, 10H, 0FFFFH, 11H, 30H, 45H,
        31H, 46H, 0FFFFH, 1EH, 32H, 47H, 0FFFFH, 1FH, 21H,
        33H, 0FFFFH, 20H, 34H, 48H, 0FFFFH, 22H, 0FFFFH, 34H,
        35H, 49H, 36H, 4AH, 0FFFFH, 23H, 3DH, 4BH, 3EH, 4CH,
        3FH, 4DH, 0FFFFH, 24H, 0FFFFH),

    LRPGO(22) ADDRESS INITIAL(
        0, 1, 3, 7, 9, 0DH, 0FH, 11H, 13H, 15H, 1DH, 1FH, 21H,
        23H, 25H, 2BH, 2FH, 33H, 37H, 39H, 3FH, 0FFFFH);

    /* HASH TABLE */
DECLARE HASHTAB(128) ADDRESS,
    HASHMASK LITERALLY '7FH',
    HASHCODE BYTE,

    /* LEXICAL ANALYZER GLOBAL VARAIBLES */
    TOKBUF(30) BYTE,
    TOKBUFTOP LITERALLY 'LAST(TOKBUF)',
    TOKTOP LITERALLY 'TOKBUF(0)',  /* CORRECT INDEXING */
    TOKVAL ADDRESS,
    TOKTYPE ADDRESS,
    TOKCONT BYTE INITIAL(0),
    TOKERROR BYTE,
    IC BYTE INITIAL(' '), /* INPUT CHARACTER */
    NC BYTE INITIAL(' '), /* NEXT CHARACTER */
    NCP ADDRESS INITIAL(0), /* POINTER TO NC IN MTS OR INPUT */
    LRLVAL ADDRESS,
    LINE ADDRESS INITIAL(1),
    SPECIALC LIT '1',
    EOFILE  LIT '0',
    OUTSIDE BYTE INITIAL(1), /* 0 WHEN SCANNING INSIDE MACRO CALLS */
    MBEGIN  LIT '05BH',
    MEND  LIT '05DH',
    COUNT BYTE; /* NO. UNMAGED MBEGIN'S INSIDE STRING */

    /* MACRO TEXT STACK */
DECLARE MTSB ADDRESS, MTS BASED MTSB(1) BYTE,
    MTSSIZE ADDRESS, /* SIZE OF MTS */
    TTOP ADDRESS INITIAL(32H),/* JUST PAST RESERVED WORD LIST */

    /* MACRO DESCRIPTOR STACK */
    MDSSIZE LITERALLY '180',
    MDS(MDSSIZE) ADDRESS,
    DTOP ADDRESS INITIAL(0FFFFH), /* TOP OF MDS */
    RTOP ADDRESS, /* POINTER TO TOPMOST RESERVD MACRO IN MDS */

    /* MACRO TYPES */
    MNUM LIT '1',         /* NUMERIC */
    MMAC LIT '2', /* TEXTUAL */

    /* STATUS STACK */
    STSSIZE LIT '50',
    QTSAVE(STSSIZE) ADDRESS, /* TTOP SAVE VALUE */
    QDSAVE(STSSIZE) ADDRESS, /* DTOP SAVE VALUE */
    QCSAVE(STSSIZE) BYTE, /* NC   SAVE VALUE */
    QNSAVE(STSSIZE) ADDRESS, /* NCP  SAVE VALUE */
    QTOP BYTE INITIAL(255), /* SATTUS STACK TOP POINTER */

    /* VARIABLES ASSOCIATED WITH THE LEFT HAND SIDE OF PRODUCTIONS */ 
    HH ADDRESS,
    /* VARIABLES ASSOCIATED WITH HANDLES */
    (H1, H2, H3, H4, H5, H6) ADDRESS,
    L1 LIT 'LOW(H1)',
    L2 LIT 'LOW(H2)',
    L3 LIT 'LOW(H3)',
    L4 LIT 'LOW(H4)',
    L5 LIT 'LOW(H5)',
    L6 LIT 'LOW(H6)',

    /* GLOBAL VARIABLES FOR SEMANTIC ACTIONS */
    HSAVE BYTE,  /* HASHCODE SAVE VALUE */
    DSAVE ADDRESS,  /* SAVE VALUE FOR DTOP */
    TSAVE ADDRESS,  /* SAVE VALUE FOR TTOP */
    TTSAVE ADDRESS,  /* YET ANOTHER SAVE VALUE FOR TTOP */
    NF BYTE,   /* NO. FORMAL PARAMATERS */
    NA BYTE,   /* NO. ACTUAL PARAMATERS */
    H BYTE, (I, J) ADDRESS; /* TEMPORARIES */

    /* MNEMONICS FOR RELATIONS */
DECLARE EQ LIT '1',
    LT LIT '2',
    GT LIT '3',
    NE LIT '4',
    LE LIT '5',
    GE LIT '6';

    /* OUTPUT OPTIONS */
DECLARE CRT LIT '1',
    DISK LIT '2',
    OUTDEV BYTE INITIAL(DISK);

    /* SWITCHES FOR BUILT-IN TRACE */
    /* TO INCLUDE TRACE ROUTINES, SET TRACE$ON TO BLANKS */
    /* TO EXCLUDE TRACE ROUTINES, SET TRACE$ON TO SLASH-STAR */
DECLARE TRACE$ON LIT '/*',
    TRACE$OFF LIT ' /* ';

    TRACE$ON
    DECLARE (TRACING, Z) BYTE;
    TRACE$OFF *** */


NEG: PROCEDURE(A) BYTE; /* TRUE IF A IS NEGATIVE */
    DECLARE A ADDRESS;
    RETURN SHR(A, 15);
    END NEG;


VMON: PROCEDURE(FUNC, INFO) BYTE;  /* CPM CALL WITH RETURN VALUE */
    DECLARE FUNC BYTE, INFO ADDRESS;
    GO TO BDOS; 
    END VMON;

CMON: PROCEDURE(FUNC, PARAM); /* CPM CALL WITN NO RETURN VALUE */
    DECLARE FUNC BYTE, PARAM ADDRESS;
    GO TO BDOS; 
    END CMON;

REBOOT: PROCEDURE;
    HALT;
    GO TO CPM;
    END REBOOT;

/* MOVBUF REMOVED */

FLUSH: PROCEDURE; /* FLUSH OUTPUT BUFFER */
    DECLARE FLUSHCNT ADDRESS;
    FLUSHCNT = 0;
    DO WHILE FLUSHCNT < OBP;
        CALL CMON(SETBUF, .OUTBUF(FLUSHCNT)); /* WRITE 128 BYTES */
    IF VMON(WRITEBF, .OUTFCB) <> 0 THEN /* CHECK FOR ERROR */
    DO;
        CALL CMON(PRINT, .(' WRITE ERROR, ABEND M81.$'));
        CALL REBOOT;
    END;
        FLUSHCNT = FLUSHCNT + 128;
    END;
    OBP = 0;
END FLUSH;

PUTC: PROCEDURE(C); /* WRITE CHARACTER TO OUTPUT FILE */
    DECLARE C BYTE;
    IF OBP = 512 THEN CALL FLUSH;
    OUTBUF(OBP) = C;
    OBP = OBP + 1;
END PUTC;

/* GET CHARACTER FROM INPUT FILE, F IS THE FCB */
GETC: PROCEDURE(F) BYTE;
    DECLARE F ADDRESS, C BYTE;
    IF IBP = 128 THEN
    DO;
 /* SET TO LOAD TO CPM DEFAULT BUFFER */
        CALL CMON(SETBUF, SBUFA);
    IBP = 0;
    IF VMON(READBF, F) <> 0 THEN
        RETURN CONTROLZ; /* EOF */
    END;
    C = IBUF(IBP);
    IBP = IBP + 1;
    IF C = LF THEN   /* TRACK LINE COUNT */
        LINE = LINE + 1;
    RETURN C;
END GETC;

PRC: PROCEDURE(C);  /* PRINT CHARACTER ON CRT OR TO DISK */
    DECLARE C BYTE;
    IF OUTDEV = CRT THEN
        CALL CMON(PRINTCHAR, C);
    ELSE
        CALL PUTC(C);
END PRC;
    
CRLF: PROCEDURE;
    CALL PRC(CR);
    CALL PRC(LF);
END CRLF;

PRS: PROCEDURE(A); /* PRINT $ TERMINATED STRING */
    DECLARE A ADDRESS;
    DECLARE B BASED A BYTE;
    DO WHILE B <> '$';
        CALL PRC(B);
    A = A + 1;
    END;
END PRS;

PRL: PROCEDURE(A); /* PRINT NEW LINE FOLLOWED BY $ TERMINATED STRING */
    DECLARE A ADDRESS;
    CALL CRLF;
    CALL PRS(A);
END PRL;

SETCRT: PROCEDURE; /* SET OUTPUT TO CRT */
    OUTDEV = CRT;
END SETCRT;

EXIT: PROCEDURE; /* ALL DONE */
    CALL SETCRT;
    CALL PRL(.('END M81 $'));
    CALL CRLF;
    CALL REBOOT; /* DIFF */
END EXIT;

PRFN: PROCEDURE(F); /* PRETTY PRINT FILE NAME FROM FCB */
    DECLARE F ADDRESS;
    DECLARE FCB BASED F(32) BYTE;
    DECLARE I BYTE;
    DO I = 1 TO 11;
       IF FCB(I) <> ' ' THEN 
           CALL PRC(FCB(I));
       IF I = 8 THEN
           CALL PRC('.');
    END;
END PRFN;

CANTOP: PROCEDURE(F); /* OPEN FILE ERROR */
    DECLARE F ADDRESS;
    CALL SETCRT;
    CALL PRL(.('CANNOT OPEN $'));
    CALL PRFN(F);
    CALL EXIT;
END CANTOP;

PRINTH: PROCEDURE(H); /* PRINT HEX NIBBLE */
    DECLARE H BYTE;
    IF H > 9 THEN
        CALL PRC(H - 10 + 'A');
    ELSE
        CALL PRC(H + '0');
END PRINTH;

PRINTHB: PROCEDURE(B); /* PRINT HEX BYTE */
    DECLARE B BYTE;
    CALL PRINTH(SHR(B, 4));
    CALL PRINTH(B AND 0FH);
END PRINTHB;
/* MAIN PROGRAM */


PRINTHA: PROCEDURE(A); /* PRINT HEX WORD */
    DECLARE A ADDRESS;
    CALL PRC('0');
    CALL PRINTHB(HIGH(A));
    CALL PRINTHB(LOW(A));
    CALL PRC('H');
END PRINTHA;

PRINTD: PROCEDURE(V); /* PRINT DECIMAL NUMBER WITHOUT LEADING 0S */
    DECLARE V ADDRESS;
    DECLARE Q ADDRESS;
    DECLARE (D, PZ) BYTE;
    IF NEG(V) THEN
        DO;
        CALL PRC('-');
        V = -V;
    END;
    Q = 10000;
    PZ = 0; /* DO NOT PRINT ZEROS */
    DO WHILE Q > 1;
        D = V / Q;
    IF D > 0 OR PZ THEN
        DO;
            CALL PRINTH(D);
        PZ = 1;
        END;
    V = V MOD Q;
    Q = Q / 10;
    END;
    CALL PRINTH(V);
END PRINTD;

PRINTQ: PROCEDURE(V); /* PRINT OCTAL NUMBER */
    DECLARE V ADDRESS;
    DECLARE N BYTE;

    N = 15;
    DO WHILE N <> 0;
        CALL PRINTH(LOW(SHR(V, N) AND 7));
        N = N - 3;
    END;
    CALL PRINTH(LOW(V AND 7));
    CALL PRC('Q');
END PRINTQ;
    
/* OPEN INPUT AND OUTPUT FILES, USING COMMON FILENAME PREFIX */
INITFILES: PROCEDURE;
    DECLARE I BYTE;
    CALL CMON(INITDSK, 0);
    IF IFCB(9) = ' ' THEN /* IF NO EXTENSION GIVE ADD M80 */
    DO;
        IFCB(9) = 'M';
    IFCB(10) = '8';
    IFCB(11) = '0';
    END;
    IF VMON(OPEN, IFCBA) = 0FFH THEN
    CALL CANTOP(IFCBA);
    DO I = 1 TO 8;  /* USE THE FILENAME PREFIX */
        OUTFCB(I) = IFCB(I);
    END;
    CALL CMON(DELETE, .OUTFCB);
    IF VMON(MAKE, .OUTFCB) = 0FFH THEN
        CALL CANTOP(.OUTFCB);
    IFCB(32), OUTFCB(32) = 0;
    LINE = 1;
END INITFILES;

TERMINATE: PROCEDURE;  /* FINALISE OUTPUT FILE */
    CALL PUTC(CONTROLZ);
    CALL FLUSH;
    CALL SETCRT;
    IF VMON(CLOSE, .OUTFCB) = 0FFH THEN
    DO;
        CALL PRL(.('CANNOT CLOSE $'));
    CALL PRFN(.OUTFCB);
    END;
    CALL PRL(.('ERRORS: $')); /* LOG ERROR COUNT */
    CALL PRINTD(ERRORCOUNT);
    CALL EXIT;
END TERMINATE;


ERROR: PROCEDURE(N);  /* LOG ERROR WITH LINE NUMBER */
    DECLARE N BYTE;
    ERRORCOUNT = ERRORCOUNT + 1;
    CALL PRL(.('*** LINE $'));
    CALL PRINTD(LINE);
    CALL PRS(.(': ERROR $'));
    CALL PRINTHB(N);
    IF (N AND 0F0H) = 0F0H THEN /* DONE IF FATAL ERROR */
        CALL TERMINATE;
END ERROR;

BLANK: PROCEDURE(C) BYTE; /* TRUE IF C IS WHITESPACE CHAR */
    DECLARE C BYTE;
    RETURN C = ' ' OR C = CR OR C = LF OR C = TABCH;
END BLANK;

NUMERIC: PROCEDURE(C) BYTE; /* TRUE IF C IS A DIGIT */
    DECLARE C BYTE;
    RETURN C >= '0' AND C <= '9';
END NUMERIC;

ALPHABETIC: PROCEDURE(C) BYTE; /* TRUE IF C IS A LETTER OR $ */
    DECLARE C BYTE;
    RETURN C >= 'A' AND C <= 'Z' OR C>= 61H AND C <= 7AH OR C = '$';
END ALPHABETIC;

ALPHANUMERIC: PROCEDURE(C) BYTE; /* TRUE IF C IS ALPHANUMERIC */
    DECLARE C BYTE;
    RETURN ALPHABETIC(C) OR NUMERIC(C);
END ALPHANUMERIC;

HEX: PROCEDURE(C) BYTE; /* TRUE IF C IS A HEX CHARACTER */
    DECLARE C BYTE;
    RETURN NUMERIC(C) OR C >= 'A' AND C <= 'F';
END HEX;

HEXVAL: PROCEDURE(C) BYTE; /* RETURN VALUE OF HEX CHARACTER C */
    DECLARE C BYTE;
    IF NUMERIC(C) THEN
        RETURN C - '0';
    RETURN C - 'A' + 10;
END HEXVAL;

GETIC: PROCEDURE;
    /* GET ONE CHARACTER FROM SOURCE PROGRAM INTO IC;
       LOOK AHEAD AT NEXT CHARACTER (NC);
       END OF FILE CONDICITONS ARE DENOTED (AT THE EXIT OF GETIC) BY:
       IC=0, NC=0: EOF;
       IC<>0, NC=0: ALMOST EOF;
       IC<>0, NC<>0: NOT EOF */
    IC = NC;
    /* NOW GET THE NEW NC */
    IF NC = 0 THEN
        RETURN;
    IF NCP = 0 THEN /* GET IT FROM SOURCE FILE */
        DO;
        NC = GETC(IFCBA);
        IF NC = CONTROLZ THEN
            NC = 0;
        END;
    ELSE /* GET NC FROM MTS */
        DO;
        IF (NCP := NCP + 1) >= MTSSIZE THEN /* MTS OVERFLOW */
            CALL ERROR(ERR$STRTOOLONG);
        NC = MTS(NCP);
    END;
END GETIC;

PUTIC: PROCEDURE; /* PUT INPUT CHARACTER IC INTO THE TOKBUF */
   TOKBUF(TOKTOP := TOKTOP + 1) = IC;
END PUTIC;
   
PGIC: PROCEDURE;
   CALL PUTIC;
   CALL GETIC;
END PGIC;

HASHF: PROCEDURE(C);
    /* UPDATE GLOBAL HASHCODE WITH THE INPUT CHARACTER C */
    DECLARE C BYTE;
    HASHCODE = (HASHCODE + C) AND HASHMASK;
END HASHF;

LOADING: PROCEDURE BYTE;
    /* RETURN 1 IF IT IS OK TO KEEP ON LOADING TOKBUF */
    RETURN TOKTOP < TOKBUFTOP AND TOKCONT;
END LOADING;


GETID: PROCEDURE; /* LOAD AN IDENTIFIER INTO THE TOKBUF */
    TOKTYPE = 101H;
    DO WHILE LOADING;
        CALL HASHF(IC);
    CALL PGIC;
    TOKCONT = ALPHANUMERIC(IC);
    END;
END GETID;

GETSTR: PROCEDURE; /* LOAD A STRING INTO TOKBUF */
    TOKTYPE = STRING;
    DO WHILE LOADING;
        IF IC <> '''' THEN
    DO;
        IF IC = MBEGIN THEN COUNT = COUNT + 1;
        IF IC = MEND THEN COUNT = COUNT - 1;
        CALL PGIC;
        IF IC = 0 THEN /* UNEXPECTED EOF */
        DO;
            TOKERROR = ERR$EOF;
        TOKCONT = 0;
        RETURN;
        END;
    END;
    ELSE /* FOUND A QUOTE */
    IF COUNT = 0 THEN /* NOT INSIDE A MACROCALL */
    DO;
        CALL GETIC; /* SKIP THE QUOTE */
        IF IC <> '''' THEN 
        TOKCONT = 0; /* END OF STRING */
        ELSE
            CALL PGIC;   /* QUOTED QUOTE */
    END;
    ELSE /* INSIDE MACROCALL */
        CALL PGIC; /* CONTINUE */
    END;
END GETSTR;

NHNC: PROCEDURE BYTE; /* TRUE IF NC IS NEITHER HEX NOR 'H' */
    RETURN (NOT HEX(NC)) AND NC <> 'H';
END NHNC;

GETNUM: PROCEDURE;
    /* LOAD A NUMBER INTO TOKBUF, PUT ITS VALUE INTO TOKVAL */
    DECLARE BASE BYTE;
    DECLARE D BYTE;
    DECLARE MPLIER BYTE, MPLAND ADDRESS;
    BASE = 0;
    TOKTYPE = 102H;
    DO WHILE LOADING;
        CALL PGIC;
    IF IC = 'O' OR IC = 'Q' THEN BASE = 8;
    ELSE IF IC = 'H' THEN BASE = 16;
    ELSE IF IC = 'B' AND NHNC THEN BASE = 2;
    ELSE IF IC = 'D' AND NHNC THEN BASE = 10;
    ELSE IF NOT HEX(IC) THEN BASE = 1;
    IF BASE > 1 THEN /* GOBBLE THE CHAR */
        CALL GETIC;
    ELSE IF BASE = 1 THEN
        BASE = 10;
        TOKCONT = BASE = 0; /* CONTINUE UNTIL BASE IS KNOWN */
    END;
    /* COMPUTE THE VALUE */
    DO I = 1 TO TOKTOP;
        D = HEXVAL(TOKBUF(I)); /* CURRENT DIGIT */
    IF D >= BASE THEN
        TOKERROR = ERR$BADNUM;
    MPLIER = BASE;
    MPLAND = TOKVAL;
        TOKVAL = D;
    DO WHILE MPLIER <> 0;
        IF MPLIER THEN
        DO;
            TOKVAL = TOKVAL + MPLAND;
        IF CARRY THEN
            TOKERROR = ERR$TOOBIG;
            END;
        MPLIER = SHR(MPLIER, 1);
        MPLAND = SHL(MPLAND, 1);
    END;
    END;
END GETNUM;

GETSPECIAL: PROCEDURE;
    TOKTYPE = 1;
    TOKVAL = 0;
    IF IC = 5CH AND NC = 5CH THEN /* XOR */
        TOKVAL = 260;
    ELSE IF IC = '<' AND NC = '>' THEN /* NE */
        TOKVAL = 261;
    ELSE IF IC = '<' AND NC = '=' THEN /* LE */
        TOKVAL = 262;
    ELSE IF IC = ':' AND NC = '=' THEN /* ASSIGN */
        TOKVAL = 5FH;
    ELSE IF IC = '>' AND NC = '=' THEN /* GE */
        TOKVAL = 263;
    IF TOKVAL <> 0 THEN
        CALL PGIC; /* SKIP ONE EXTRA CHARACTER */
    ELSE
        TOKVAL = IC; /* SINGLE SPECIAL CHARACTER */
    IF IC = MEND THEN /* DO NOT READ NEXT CHAR OUTSIDE MACROCALL */
    DO;
        CALL PUTIC;
    OUTSIDE = 1;
    END;
    ELSE
        CALL PGIC; /* READ NEXT CHARACTER */
    TOKCONT = 0;
END GETSPECIAL;


GETTOKEN: PROCEDURE;
    /* GET A TOKEN AND RETURN THE GLOBAL VARIABLES
       TOKTYPE:  IDENTIFIER, STRING, NUMBER, SPECIALC, EOFILE
       TOKVAL:   VALUE OF NUBMER, ITNERNAL NO. OF SPECIALC
       TOKERROR: 0 IF VALID TOKEN, A MESSAGE NO. OTHERWISE
       TOKBUF:   ARRAY OF CHARACTERS (1 TO TOKTOP) WITH TOKEN NAME
       TOPTOP:   INDEX OF LAST CHARACTER IN TOKBUF
       HASHCODE: HASHCODE OF IDENTIFIERS, STRINGS */
    /* IC: INPUT CHARACTER (ALREADY READ IN, BUT NOT YET USED)
       NC: NEXT CHARACTER (LOOK-AHEAD CHARACTER) */
    DECLARE SOMETHING BYTE;
    TOKTOP, TOKERROR = 0;
    IF TOKCONT = 0 THEN
    DO;
        TOKVAL, HASHCODE, SOMETHING = 0;
    COUNT = 0;
    TOKCONT = 1;
    DO WHILE SOMETHING = 0;
        DO WHILE BLANK(IC); /* SKIP BLANKS */
            CALL GETIC;
        END;
        IF IC = '/' AND NC = '*' THEN /* COMMENT */
        DO;
            CALL GETIC;
        CALL GETIC;
        DO WHILE IC <> '*' OR NC <> '/'; /* ENDS WITH * / */
            IF IC = 0 THEN
            DO;
                TOKTYPE = 0;
            RETURN;
            END;
            CALL GETIC;
        END;
        CALL GETIC;
        CALL GETIC;
        END;
        ELSE
            SOMETHING = 1;
    END;
        IF IC = 0 THEN
            TOKTYPE = EOFILE;
        ELSE
        DO;
            IF ALPHABETIC(IC) THEN
            CALL GETID;
        ELSE IF NUMERIC(IC) THEN
            CALL GETNUM;
        ELSE IF IC = '''' THEN
        DO;
            CALL GETIC;
            CALL GETSTR;
        END;
        ELSE
            CALL GETSPECIAL;
        END;
    END;
    ELSE IF TOKTYPE = IDENTIFIER THEN
        CALL GETID;
    ELSE IF TOKTYPE = STRING THEN
        CALL GETSTR;
    ELSE IF TOKTYPE = NUMBER THEN
        CALL GETNUM;
    ELSE
        CALL GETSPECIAL;
END GETTOKEN;


    TRACE$ON 
ESP: PROCEDURE; CALL PRC(' ');
     END ESP;

VG: PROCEDURE; CALL PRC(',');
    END VG;

TRAC: PROCEDURE(I);
    DECLARE I BYTE, K ADDRESS;
    IF TRACING <> 'Y' THEN RETURN;
    CALL SETCRT; CALL PRC( I) ; Z=VMON( 1,0);
    DO WHILE Z <> ' ';
        CALL CRLF;
        IF Z='C' THEN DO;
            CALL PRC( IC); CALL PRC(NC);
            CALL VG; CALL PRINTD(NCP);
        END;
        IF Z='N' THEN DO;
            CALL ESP; CALL PRINTD(H1); CALL VG; CALL PRINTD(H2);
        CALL VG; CALL PRINTD(H3); CALL VG; CALL PRINTD(H4);
        END;
        IF Z='H' THEN
    DO I = 0 TO LAST(HASHTAB);
            IF HASHTAB(I)<>0 THEN DO;
                CALL ESP; CALL PRINTD(I);
                CALL VG; CALL PRINTD(HASHTAB(I));
            END;
        END;
        IF Z='D' THEN DO I=0 TO DTOP;
            CALL ESP; CALL PRINTD(I);
            CALL VG; CALL PRINTD(MDS(I));
        END;
        IF Z='Q' THEN DO I=0 TO QTOP;
            CALL ESP; CALL PRINTD(I); CALL VG; CALL PRINTD(QTSAVE(I));
            CALL ESP; CALL PRINTD(QDSAVE(I)); CALL ESP;
            CALL PRC(QCSAVE(I)); CALL ESP; CALL PRINTD(QNSAVE(I));
        END;
        IF Z='P' THEN DO I = 0 TO PTOP;
            CALL ESP; CALL PRINTD(PSTACK(I));
            CALL VG; CALL PRINTD(VSTACK(I));
        END;
        IF Z='T' THEN DO K=0 TO TTOP;
            CALL ESP; Z=MTS(K);
            IF ALPHANUMERIC(Z) THEN CALL PRC(Z); ELSE CALL PRINTHB(Z);
        END;
        Z=VMON(1, 0);
    END;
    OUTDEV=DISK;
    END TRAC;
    TRACE$OFF *** */
        
COMPAR: PROCEDURE(A1, A2) BYTE; /* STRING COMPARE, 1 IF SAME */
    DECLARE (A1, A2) ADDRESS;
    DECLARE B1 BASED A1 BYTE;
    DECLARE B2 BASED A2 BYTE;
    DO WHILE B1 = B2;
        IF B1 = 0 THEN
        RETURN 1;
    A1 = A1 + 1;
    A2 = A2 + 1;
    END;
    RETURN 0;
END COMPAR;

PUSHD: PROCEDURE(I); /* PUSH I INTO THE MACRO DESCRIPTOR STACK */
    DECLARE I ADDRESS;
    IF (DTOP := DTOP + 1) >= MDSSIZE THEN
        CALL ERROR(ERR$TOOMANYMACROS);
    ELSE
        MDS(DTOP) = I;
END PUSHD;



NTYPE: PROCEDURE(I) BYTE; /* TYPE OF MACRO I */
    DECLARE I ADDRESS;
    RETURN MDS(I) AND 0FFH;
END NTYPE;

NFP: PROCEDURE(I) BYTE; /* NUMBER OF FORMAL PARAMETERS OF MACRO I */
    DECLARE I ADDRESS;
    RETURN SHR(MDS(I), 8);
END NFP;

TNAME: PROCEDURE(I) ADDRESS;
    /* INDEXC IN MDS OF NAME CELL OF TEXTUAL MACRO I */
    DECLARE I ADDRESS;
    RETURN I - NFP(I) - 3;
END TNAME;

IFP: PROCEDURE(N, I) ADDRESS;
    /* INDEX IN MTS OF NTH FORMAL PARAM OF MACRO I */
    DECLARE N BYTE;
    DECLARE I ADDRESS; 
    RETURN MDS(TNAME(I) + N);
END IFP;


MLINK: PROCEDURE(I) ADDRESS; /* LINK FIELD OF MACRO I */
    DECLARE I ADDRESS;
    RETURN MDS(I - 1);
END MLINK;

MNUMERIC: PROCEDURE(I) BYTE;
    /* TRUE IF MACRO I IS OF TYPE NUMERIC */
    DECLARE I ADDRESS;
    RETURN NTYPE(I) = MNUM;
END MNUMERIC;

RESERVED: PROCEDURE(I) BYTE;
    /* TRUE IF MACRO I IS A RESERVED WORD */
    DECLARE I ADDRESS;
    RETURN I <= RTOP;
END RESERVED;


JNAME: PROCEDURE(I) ADDRESS;
    /* INDEX OF CELL IN MDS CONTAINING POINTER TO NAME OF MACRO I */
    DECLARE I ADDRESS;
    IF MNUMERIC(I) THEN
        RETURN I - 3;
    ELSE IF RESERVED(I) THEN
        RETURN I - 2;
    RETURN TNAME(I);
END JNAME;

INAME: PROCEDURE(I) ADDRESS; /* INDEX OF NAME OF MACRO I IN MTS */
    DECLARE I ADDRESS;
   TRACE$ON
    CALL TRAC('M');
   TRACE$OFF *** */
    RETURN MDS(JNAME(I));
END INAME;

PUSHST: PROCEDURE;
    /* PUSH STATUS QUO (NC, NCP, TSAVE, DSAVE) INTO THE STATUS STACK */
    TRACE$ON
    CALL TRAC('+');
    TRACE$OFF *** */
    IF (QTOP := QTOP + 1) >= STSSIZE THEN
        CALL ERROR(ERR$TOOMUCHPUSHSTING);
    QTSAVE(QTOP) = TSAVE;
    QDSAVE(QTOP) = DSAVE;
    QCSAVE(QTOP) = NC;
    QNSAVE(QTOP) = NCP;
    OUTSIDE = 1;  /* BEGIN TO SCAN A MACROBODY IN 'OUTSIDE' MODE */
END PUSHST;

POPST: PROCEDURE;
    /* EXIT FROM SCANNING A MACROBODY: POP PREVIOUS STATUS FROM
       THE STATUS STACK AND SET THINGS FOR THE SCANNER */
    TRACE$ON
    CALL TRAC('-');
    TRACE$OFF *** */
    IF QTOP = 255 THEN /* EMPTY STACK, THE MACROBODY JUST SCANNED
                           WAS THE SOURCE PROGRAM ITSELF */
        CALL TERMINATE;
    /* ELSE: RESTORE PREVIOUS STATUS */
    /* RESTORE THE HASHTABLE */
    DO WHILE DTOP > QDSAVE(QTOP); 
    /* SET HASHTABLE ENTRY POINTING TO NEXT MACRO */
        HASHTAB(MTS(INAME(DTOP) - 1)) =
        MLINK(DTOP);
    DTOP = JNAME(DTOP) - 1; /* INDEX OF NEXT MACRO TO POP */
    END;
    TTOP = QTSAVE(QTOP);
    NCP = QNSAVE(QTOP);
    NC = QCSAVE(QTOP);
    QTOP = QTOP - 1;
    OUTSIDE = 1;  /* GET READY FOR OTHER MACROCALLS */
END POPST;

MIDENT: PROCEDURE(J) ADDRESS;
    /* IDENTIFY MACRO WHOSE NAME IS AT MTS(J) */
    DECLARE J ADDRESS;
    DECLARE H BYTE, (I, K) ADDRESS;

    H = MTS(J - 1); /* HASHCODE */
    K = HASHTAB(H); /* INDEX OF TOPMOST MACRO WITH SAME HASHCODE */

    DO WHILE K <> 0;  /* SEARCH */
        I = INAME(K);  /* INDEX OF MACRONAME IN MTS */
    IF COMPAR(.MTS(J), .MTS(I)) THEN
        RETURN K;  /* FOUND */
    K = MLINK(K);
    END;
    RETURN 0;
END MIDENT;

SAVETOK: PROCEDURE(I) ADDRESS;
    /* MOVE CURRENT TOKEN TO MTS, STARTING AT MTS(I) */
    /* RETURN POINTER TO NEXT CHARACTER IN MTS */
    DECLARE I ADDRESS;
    DECLARE J BYTE;
    IF (I + TOKTOP) > MTSSIZE THEN
        CALL ERROR(ERR$STRTOOLONG);
    DO J = 1 TO TOKTOP;
       MTS(I) = TOKBUF(J);
       I = I + 1;
    END;
    MTS(I) = 0;   /* END MARKER */
    RETURN I;
END SAVETOK;
    
LRLEX: PROCEDURE ADDRESS; /* LEXICAL ANALYZER */
    /* RETURN THE INTERNAL NUMBER OF A RESERVED WORD, OR:
       INDENTIFIER: LRLVAL = INDEX OF MACRO IN MDS, OR
            -POINTER TO NAME IN MTS, IF ID IS NOT A MACRONAME
       STRING:     LRLVAL = POINTER TO STRING IN MTS
       NUMBER:     LRLVAL = VALUE OF HTE NUMBER
       0:     EOFILE */
    DECLARE J ADDRESS;
    DO WHILE OUTSIDE;
        CALL GETIC;
    IF IC = MBEGIN THEN /* BEGIN A MACROCALL */
    DO;
        OUTSIDE = 0; /* ENTER MACROCALL */
        CALL GETIC;  /* SKIP MBEGIN */
        RETURN MBEGIN;
    END;
    IF IC = 0 THEN  /* END OF MACROBODY */
        CALL POPST;  /* POP STATUS, GO ON SCANNING */
    ELSE
        CALL PRC(IC); /* WRITE IC ON OUTPUT FILE */
    END;
    CALL GETTOKEN;
    DO WHILE TOKERROR <> 0;
        CALL ERROR(TOKERROR);
    CALL GETTOKEN;
    END;
    LRLVAL = TOKVAL;
    IF TOKTYPE = SPECIALC THEN /* SPECIAL */
        RETURN TOKVAL;
    IF TOKTYPE = NUMBER THEN /* NUMBER*/
        RETURN NUMBER;
    IF TOKTYPE = EOFILE THEN /* EOF */
        RETURN 0;
    TTSAVE = TTOP; /* SAVE VALUE OF TTOP */
    LRLVAL = TTOP + 2;
    J = SAVETOK(LRLVAL); /* MOVE TOKEN TO MTS */
    DO WHILE TOKCONT <> 0; /* GET REMAINDER OF TOKEN */
        CALL GETTOKEN;
    J = SAVETOK(J);
    END;
    MTS(LRLVAL-1) = HASHCODE; /* STORE HASHCODE */
    TTOP = J;   /* PUSH THE NAME INTO MTS */
    IF TOKTYPE = STRING THEN
        RETURN STRING;
    J = MIDENT(LRLVAL); 
    /* IS IDENTIFIER - CHECK WHETHER RESERVED WORD */
    IF J = 0 THEN  /* NOT THERE */
    DO;
        LRLVAL = -LRLVAL; /* -POINTER TO ID IN MTS */
    RETURN IDENTIFIER; 
    END;
    TTOP = LRLVAL - 2; /* DISCARD THE NAME */
    IF RESERVED(J) THEN /* RESERVED WORD ? */
        RETURN MDS(J); /* RETURN WORD NO. */
    LRLVAL = J;  /* IONDEX OF THE MACRO IN MDS */
    RETURN IDENTIFIER;
END LRLEX;
    
LOOKAT: PROCEDURE(I);
    /* TELL SCANNER TO SCAN TEXT BEGINNING AT MTS(I) */
    DECLARE I ADDRESS;
    NCP = I;
    NC = MTS(I);
END LOOKAT;


PUSHH2: PROCEDURE;
    /* CREATE ENTRY IN MDS FOR MACRONAME AT HANDLE(2) */
    TRACE$ON
    CALL TRAC('X');
    TRACE$OFF *** */
    IF NEG(H2) THEN
        H2 = -H2; /* NEW IDENTIFIER */
    ELSE  /* IDENTIFIER IS A MACRONAME */
        H2 = INAME(H2); /* POINTER TO NAME IN MTS */
    TRACE$ON
    CALL TRAC('Y');
    TRACE$OFF *** */
    CALL PUSHD(H2);
END PUSHH2;

INITDECL: PROCEDURE;
    /* SEMANTIC ACTIONS FOR THE PRODUCTIONS
       <INT.DECL> ::= INT <IDENTIFIER>
       <INT.DECL> ::= <INT.DECL> <INDENTIFIER> */
    DECLARE H BYTE;
    /* CREATE NUMERIC MACRO */
    CALL PUSHH2; /* PUSH POINTER TO MACRONAME INTO MDS */
    CALL PUSHD(0); /* INITIALIZE ITS VALUE TO 0 */
    H = MTS(H2 - 1); /* GET IDENTIFIER'S HASHCODE */
    CALL PUSHD(HASHTAB(H)); /* SET LINK */
    CALL PUSHD(1); /* 0 FORMAL PARAMS, TYPE = NUMERIC MACRO */
    HASHTAB(H) = DTOP; /* POINTER TO THE NEW MACRO */
END INITDECL;

XMIT1: PROCEDURE;
    HH = H1;
END XMIT1;

LRACTION: PROCEDURE(N);
    DECLARE N BYTE;
    /* EXECUTE SEMANTIC ACTION ASSOCIATED WITH PPODUCTION N */
    IF N < 10 THEN /* NO ACTION TO BE PERFORMED */
        RETURN;
    DO CASE N - 10;
    /*** <PROGRAM> ::= <STMT> */
    /*** <PROGRAM> ::= <PROGRAM> <STMT> */
    /*** <STMT> ::= <INT.DECL> */
    /*** <STMT> ::= <ASSIGN.STMT> */
    /*** <STMT> ::= <EVAL.STMT> */
    /*** <STMT> ::= <MACRO.DECL> */
    /*** <STMT> ::= <MACRO.CALL> */
    /*** <STMT> ::= <IF.STMT> */
    /*** <STMT> ::= <ERROR> */
    /*** <INT.DECL> ::= INT <IDENTIFIER> */
    CALL INITDECL;
    /*** <INT.DECL> ::= <INT>DECL> <IDENTIFIER> */
    CALL INITDECL;
    /*** <ASSIGN.STMT> ::= <IDENTIFIER> = <EXPR> */
    DO; 
        IF NEG(H1) THEN /* UNDEFINED MACRO */
        CALL ERROR(ERR$UNDEF);
    ELSE IF MNUMERIC(H1) THEN /* NUMERIC MACRO */
        MDS(H1 - 2) = H3;  /* EXECUTE ASSIGNMENT */
    ELSE
        CALL ERROR(ERR$NONNUMASSIGN); /* CANNOT ASSIGN */
        HH = H3; /* PROPAGATE VALUE OF <EXPR> */
    END;
    /*** <EVAL.STMT> ::= <FORMAT> <EXPR> */
    DO;
        IF L1 = 10 THEN
        CALL PRINTD(H2);
        ELSE IF L1 = 8 THEN
        CALL PRINTQ(H2);
        ELSE IF L1 = 22 THEN
        CALL PRC(H2);
        ELSE
        CALL PRINTHA(H2);
    END;
    /*** <FORMAT> ::= DEC */
    HH = 10;
    /*** <FORMAT> ::= OCT */
    HH = 8;
    /*** <FORMAT> ::= HEX */
    HH = 16;
    /*** <FORMAT> ::= CHAR */
    HH = 22;
    /*** <MACRO.DECL> ::= <MD.HEAD> <STRING> */
    DO; /* CREATE MACROBODY = <STRING>; INSTALL NEW MACRO */
        CALL PUSHD(H2); /* POINTER TO MACROBODY */
    CALL PUSHD(HASHTAB(HSAVE)); /* SET LINK FIELD */
    CALL PUSHD(SHL(DOUBLE(NF), 8) OR MMAC); /* NO. FORMALS, TYPE */
    HASHTAB(HSAVE) = DTOP; /* POINTER TO MACRO DESCRIPTOR */
    END;
    /*** <MD.HEAD> ::= MACRO <IDENTIFIER> */
    DO; /* CREATE MACRO NAME */
        CALL PUSHH2; /* HR=POINTER TO IDENTIFIER IN MTS */
    HSAVE = MTS(H2 - 1); /* SAVE ITS HASHCODE */
    NF = 0;  /* NO. FORMAL PARAMETERS */
    END;
    /*** <MD.HEAD> ::= <MD.HEAD> <IDENTIFIER> */
    DO;
        CALL PUSHH2; /* H2 = POINTER TO IDENTIFIER IN MTS */
    NF = NF + 1; /* ANOTHER FORMAL PARAMETER */
    END;
    /*** <MACRO.CALL> ::= <MD.HEAD> */
    DO;
    /* TEMPORARY MACROS HAVE ALREADY BEEN CREATED
       STATUS HAS BEEN SAVED IN DSAVE, TSAVE */
        IF NOT NEG(H1) THEN /* NO ERRORS */
        DO;
 /* VALUE OF NUMERIC MACROS, POINTER TO BODY OF TEXTUAL MACROS */
            I = MDS(H1 - 2);
            IF MNUMERIC(H1) THEN
                CALL PRINTD(I); /* NUMERIC VALUE */
            ELSE
            DO;   /* TEXTUAL MACRO */
                CALL PUSHST; /* SAVE STATUS QUO */
                CALL LOOKAT(I); /* SCAN MACROBODY */
            END;
        END;
    END;
    /*** <MACRO.HEAD> ::= <IDENTIFIER> */
    DO;
        IF NEG(H1) THEN /* UNDEFINED MACRO */
        CALL ERROR(ERR$UNDEF);
    DSAVE = DTOP; /* SAVE STATUS QUO */
    TSAVE = TTSAVE;
    NA = 0;  /* NO. ACTUAL PARAMATERS */
    CALL XMIT1;
    END;
    /*** <MACRO.HEAD> ::= <MACRO.HEAD> <STRING> */
    DO; /* CREATE TEMPORARY MACRO, WITH
       MACRONAME = FORMAL PARAM, MACROBODY = ACTRUAL PARAM */
        IF NOT NEG(H1) THEN /* NO ERRORS */
        DO;
            HH = 0;
            NA = NA + 1;
            IF MNUMERIC(H1) THEN /* NUMERIC MACRO CANNOT HAVE PARAMETERS */
                CALL ERROR(ERR$MACROHASPARAMS);
            ELSE IF NA > NFP(H1) THEN /* TOO MANY PARAMETERS */
                CALL ERROR(ERR$TOOMANYPARAMS);
            ELSE
                CALL XMIT1;
            IF NOT NEG(HH) THEN
            DO;
     /* J = POINTER TO CORRESPONDING FORMAL PARAMETER IN MTS */
                J = IFP(NA, H1);
                CALL PUSHD(J); /* FORMAL PARAM BECOMES MACRONAME */
                CALL PUSHD(H2);      /* MACROBODY = STRING */
                H = MTS(J - 1);      /* HASHCODE OF NEW MACRONAME */
                CALL PUSHD(HASHTAB(H)); /* SET LINK */
                CALL PUSHD(MMAC);    /* 0 FORMAL PARAMS, TYPE = TEXT */
                HASHTAB(H) = DTOP;   /* POINTER TO NEW MACRO */
            END;
        END;
    END;
    /*** <IF.STMT> ::= <IF> <EXPR> THEN <STRING> */
    DO;
        IF H2 THEN /* <EXPR> IS TRUE */
        DO;
            CALL PUSHST; /* SAVE STATUS QUO */
            CALL LOOKAT(H4); /* TELL SCANNER TO SCAN STRING */
        END;
    END;
    /*** <IF.STMT> ::= <IF> <EXPR> THEN <STRING> ELSE <STRING> */
    DO; 
         CALL PUSHST; /* SAVE STATUS QUO */
     IF H2 THEN /* <EXPR> IS TRUE */
         CALL LOOKAT(H4); /* SCAN 1ST STRING */
     ELSE
         CALL LOOKAT(H6); /* SCAN 2ND STRING */
    END;
    /*** <IF> ::= IF */
    DO;
         DSAVE = DTOP;
     TSAVE = TTOP;
    END;
    /*** <EXPR> ::= <LOG.FACTOR> */
    CALL XMIT1;
    /*** <EXPR> ::= <EXPR> OR <LOG.FACTOR> */
    HH = H1 OR H3;
    /*** <EXPR> ::= <EXPR> XOR <LOG.FACTOR> */
    HH = H1 XOR H3;
    /*** <LOG.FACTOR> ::= <LOG.SEC> */
    CALL XMIT1; 
    /*** <LOG.FACTOR> ::= <LOG.FACTOR> AND <LOG.SEC> */
    HH = H1 AND H3;
    /*** <LOG.SEC> ::= <LOG.PRIM> */
    CALL XMIT1;
    /*** <LOG.SEC> ::= NOT <LOG.PRIM> */
    HH = NOT H2;
    /*** <LOG.PRIM> ::= NOT <ARIT.EXPR> */
    CALL XMIT1;
    /*** <LOG.PRIM> ::= <ARIT.EXPR> <REL> <ARIT.EXPR> */
    DO;
    DECLARE LL BYTE;
        IF L2 = EQ THEN 
            LL = H1 = H3;
        ELSE IF L2 = LT THEN
            LL = NEG(H1 - H3);
        ELSE IF L2 = GT THEN
            LL = NEG(H3 - H1);
        ELSE IF L2 = NE THEN
            LL = H1 <> H3;
        ELSE IF L2 = LE THEN
            LL = (H1 = H3) OR NEG(H1 - H3);
        ELSE
            LL = (H1 = H3) OR NEG(H3 - H1);
        HH = LL;
    END;
    /*** <REL> ::= = */
    HH = EQ;
    /*** <REL> ::= < */
    HH = LT;
    /*** <REL> ::= > */
    HH = GT;
    /*** <REL> ::= <> */
    HH = NE;
    /*** <REL> ::= <= */
    HH = LE;
    /*** <REL> ::= >= */
    HH = GE;
    /*** <ARIT.EXPR> ::= <TERM> */
    CALL XMIT1;
    /*** <ARIT.EXPR> ::= <ARIT.EXPR> + <TERM> */
    HH = H1 + H3;
    /*** <ARIT.EXPR> ::= <ARIT.EXPR> - <TERM> */
    HH = H1 - H3;
    /*** <TERM> ::= <PRIM> */
    CALL XMIT1; 
    /*** <TERM> ::= <TERM> * <PRIM> */
    HH = H1 * H3;
    /*** <TERM> ::= <TERM> / <PRIM> */
    HH = H1 / H3;
    /*** <TERM> ::= <TERM> MOD <PRIM> */
    HH = H1 MOD H3;
    /*** <PRIM> ::= <IDENTIFIER> */
    IF NEG(H1) THEN /* UNDEFINED MACRO */
        CALL ERROR(ERR$UNDEF);
    ELSE IF MNUMERIC(H1) THEN /* NUMERIC MACRO */
        HH = MDS(H1 - 2);
    ELSE
        CALL ERROR(ERR$NONNUMERICEXPR);
    /*** <PRIM> ::= <NUMBER> */
    CALL XMIT1;
    /*** <PRIM> ::= <ASSIGN.STMT> */
    HH = H2;
    /*** <PRIM> ::= ( <EXPR> ) */
    HH = H2;
    /*** <PRIM> ::=  - <NUMBER> */
    HH = -H2;
    END;
END LRACTION;

TABLE: PROCEDURE(S, I) ADDRESS;
    /* RETURN ITH ENTRY IN THE ACTION TABLE OF STATE S */
    DECLARE (S, I) ADDRESS;
    RETURN LRACT(LRPACT(S + 1) + I); 
END TABLE;

POP: PROCEDURE(N); /* POP N TOPMOST STATES OF THE PARSE STACK */
    DECLARE N BYTE;
    PTOP = PTOP - N;
    IF PTOP < 0 THEN
        CALL ERROR(ERR$M81ERROR);
END POP;


PUSH: PROCEDURE(S, V);
    /* PUSH STATE S AND VALUE V INTO THE PARSE STACKS */
    DECLARE (S, V) ADDRESS;
    PTOP = PTOP + 1;
    IF PTOP >= STACKSIZE THEN
        CALL ERROR(0F4H);
    PSTACK(PTOP) = S;
    VSTACK(PTOP) = V;
END PUSH;


GOTOF: PROCEDURE(STATE, NONTERM) ADDRESS;
    /* RETURN NEXT STATE AFTER A REDUCTION */
    DECLARE (STATE, NONTERM) ADDRESS;
    I = LRPGO(NONTERM); /* PINTER TO GOTO TABLE IN LRGO */
    DO FOREVER;  /* TABLE SEARCH */
        IF LRGO(I) = 0FFFFH OR LRGO(I) = STATE THEN
        RETURN LRGO(I + 1);
    I = I + 2;
    END;
END GOTOF;


REDUCE: PROCEDURE; /* EXECUTE A REDUCTION */
    DECLARE PN BYTE; /* PRODUCTION NUMBER */
    DECLARE NRS BYTE; /* NO. ELEMENTS RIGHT HAND SIDE */
    DECLARE LS ADDRESS; /* ID NO. OF LEFT HAND SIDE */
    DECLARE HB ADDRESS; /* HANDLE BASE */
    DECLARE H BASED HB(7) ADDRESS; /* HANDLE */
    PN = TAB AND 0FFFH;
    /* CLEAR RECOVERY FLAG UNLESS <STMD> :: = <ERROR> */
    IF PN <> 9 THEN
        RECOVERING = 0;
    NRS = LRR2(PN);
    LS = LRR1(PN);

    HB = .VSTACK(PTOP - NRS);
    H1 = H(1);
    H2 = H(2);
    H3 = H(3);
    H4 = H(4);
    H5 = H(5);
    H6 = H(6);
    TRACE$ON
    CALL TRAC('R');
    TRACE$OFF *** */
    CALL LRACTION(PN); /* EXCUTE SEMANTIC ACTION */
    /* UPDATE THE PARSE STACK */
    CALL POP(NRS); /* POP RIGHT HAND SIDE */
    CALL PUSH(GOTOF(PSTACK(PTOP), LS), HH); /* NEXT STATE */
    TRACE$ON
    CALL TRAC('A');
    TRACE$OFF *** */
END REDUCE;


SHIFT: PROCEDURE; /* EXCUTE A SHIFT ACTION */
    TRACE$ON
    CALL TRAC('S');
    TRACE$OFF *** */
    CALL PUSH(TAB AND 0FFFH, LRLVAL); /* PUSH NEXT STATE */
    INPUTSY = LRLEX; /* GET ANOTHER INPUT SYMBOL */
END SHIFT;

ACCEPT: PROCEDURE; /* BREAK PARSER LOOP */
    PARSING = 0;
END ACCEPT;

P$ERROR: PROCEDURE; /* PARSING ERROR HANDLER */
    TRACE$ON
    CALL TRAC('E');
    TRACE$OFF *** */
    IF RECOVERING THEN /* ERROR MESSAGE FOR THIS ERROR ALREADY GIVEN */
    DO;  /* SEARCH FOR A STATE WITH SHIFT ON <ERROR> */
        IF PTOP <= 0 THEN
        CALL ERROR(ERR$FATALSYNTAX);
    CALL POP(1);
    RETURN;
    END;
    CALL ERROR(ERR$SYNTAX);
    INPUTSY = YERROR; /* <ERROR> */
    RECOVERING = 1;
END P$ERROR;

PARSE: PROCEDURE; /* PARSE SOURCE PROGRAM */
    INPUTSY = LRLEX; /* GET FIRST INPUT SYMBOL */
    DO WHILE PARSING;
        IT = 0;  /* INDEX WITHIN ACTION TABLE OF CURRENT STATE */
    SEARCHING = 1;
    DO WHILE SEARCHING; /* IDENTIFY APPLICABLE ACTION */
        SEARCHING = 0;
        TAB = TABLE(PSTACK(PTOP), IT); /* CURRENT TABLE ENTRY */
        ACTION = TAB AND ACTMASK;  /* DECODE THE ACTION */
        IF ACTION = REDMASK THEN
            CALL REDUCE;
        ELSE IF ACTION = ERRORMASK THEN
                CALL P$ERROR;
        ELSE IF (INPUTSY OR SYMBMASK) = TAB THEN    
        DO;   /* ENTRY FOUND FOR THIS INPUT */
            IT = IT + 1; /* LOOK FOR CORRESPONDING ACTION */
            TAB = TABLE(PSTACK(PTOP), IT);
                ACTION = TAB AND ACTMASK;
                IF ACTION = REDMASK THEN
                    CALL REDUCE;
            ELSE IF ACTION = SHIFTMASK THEN
                CALL SHIFT;
            ELSE
                CALL ACCEPT;
        END;
        ELSE    /* NO MATCH */
        DO;    /* KEEP ON SEARCHING */
            IT = IT + 2;
            SEARCHING = 1;
        END;
    END;
    END;
END PARSE;

DECLARE RESERVEDWORDS(49) BYTE INITIAL (
    8, 'INT', 0,
    9, 'DEC', 0,
    10, 'OCT', 0,
    11, 'HEX', 0,
    12, 'CHAR', 0,
    13, 'MACRO', 0,
    14, 'THEN', 0,
    15, 'ELSE', 0,
    16, 'IF', 0);
    
INITTAB: PROCEDURE;
    DECLARE FBASE BASED FBASE$P ADDRESS;
    MTSB = .RESERVEDWORDS; /* MTS STARTS AT RESERVEDWORDS */
    MTSSIZE = FBASE - MTSB; /* AND FINISHES AT CPM BAS ADDRESS */
    DO I = 0 TO LAST(HASHTAB); /* RESET HASH TABLE */
        HASHTAB(I) = 0;
    END;
    /* INITIALISE MDS */
    J = 1; /* INDEX OF FIRST RESERVED WORD IN MTS */
    DO WHILE J < TTOP;
        HASHCODE = 0; /* COMPUTE HASH CODE FOR WORD */
        I = J;
        DO WHILE MTS(I) <> 0;
            CALL HASHF(MTS(I));
            I = I + 1;
        END;
        CALL PUSHD(J);  /* POINTER TO MACRONAME */
        CALL PUSHD(HASHTAB(HASHCODE));  /* LINK */
        CALL PUSHD(MTS(J - 1) + 256); /* RESERVED WORD NO. */
        MTS(J - 1) = HASHCODE;      /* STORE HASHCODE IN MTS */
        HASHTAB(HASHCODE) = DTOP;    /* POINTER TO THE MACRO CREATED */
        J = I + 2;       /* NEXT */
    END;
    RTOP = DTOP;     /* SAVE INDEX OF TOPMOST RESERVED MACRO */
END INITTAB;
     
    CALL INITTAB;
    CALL INITFILES;
    CALL PARSE;
EOF
