
100H:           /* START OF CPM */

DECLARE FOREVER         LITERALLY 'WHILE 1',
        LIT             LITERALLY 'LITERALLY',
        LF              LITERALLY '0AH',        /* LINE-FEED */
        CONTROLZ        LITERALLY '1AH',
        CR              LITERALLY '0DH';

/* CP/M SYSTEM CONSTANTS */
DECLARE CPM     LITERALLY '0',   /* CP/M REBOOT ENTRY */
        IFCBA   LITERALLY '5CH', /* INPUT FCB ADDRESS */
        SBUFA   LITERALLY '80H', /* I/O BUFFER ADDRESS */
        FBASE   LITERALLY '3200H',   /* FDOS BASE */
        BDOS    LITERALLY '5';   /* CPM DOS ENTRY POINT */

/* I/O PRIMATIVES */
DECLARE READCHAR   LITERALLY '1',
        PRINTCHAR  LITERALLY '2',
        PRINT      LITERALLY '9',
        OPEN       LITERALLY '15',
        CLOSE      LITERALLY '16',
        MAKE       LITERALLY '22',
        DELETE     LITERALLY '19',
        READBF     LITERALLY '20',
        WRITEBF    LITERALLY '21',
        INITDSK    LITERALLY '13',
        SETBUF     LITERALLY '26';

/* INPUT FILE CONTROL BLOCK */
DECLARE IFA ADDRESS INITIAL(IFCBA),
        IFCB BASED IFA BYTE;            /* FCB ADDRESS */

/* INPUT BUFFER */
DECLARE IBUFA ADDRESS INITIAL(SBUFA),
        IBUF BASED IBUFA(128) BYTE,      /* INPUT BUFFER */
        IBP BYTE;               /* POINTER TO NEXT CHARACTER IN INPUT BUFFER */
        
/* OUTPUT FILE CONTROL BLOCK */
DECLARE OFCB(33) BYTE
        INITIAL(0, '        ', 'COM', 0,0,0,0);

/* OUTPUT BUFFER */
DECLARE OBUF(1024) BYTE;
DECLARE OBP ADDRESS INITIAL(0); /* OUTPUT BUFFER POINTER */


/* MNEMONICS FOR SEGMENTS */
DECLARE CA LIT '1',       /* CODE AREA */
        IDA LIT '2',      /* INITIAL DATA AREA */
        WA LIT '3';       /* WORK AREA */

/* MODULE MAP */
DECLARE MSIZE          LIT '20'; /* MAX NO. MODULES L83 CAN HANDLE */
DECLARE MNAME(MSIZE) ADDRESS,   /* POINTER TO MODULE NAME */
        MCA(MSIZE) ADDRESS,     /* ADDRESS OF CA */
        NCA(MSIZE) ADDRESS,     /* LENGTH OF CA */
        MIDA(MSIZE) ADDRESS,    /* ADDRESS OF IDA */
        NIDA(MSIZE) ADDRESS,    /* LENGTH OF IDA */
        MWA(MSIZE) ADDRESS,     /* ADDRESS OF WA */
        MSYMB(MSIZE) ADDRESS,   /* BASE ADDRESS OF MODULE'S SYMB LIST */
        MHASH(MSIZE) BYTE;      /* HASHCODE OF MODULE'S NAME */
DECLARE MTOP BYTE INITIAL(0);   /* INDEX OF LAST ENTRYIG IN TEH MM */

/* LOGICAL RECORD FROM THE RELOCATION TABLE FILE */

DECLARE REC     BYTE,           /* RECORD TYPE */
        RLOC    ADDRESS,        /* LOCATION OF ADDRESS TO BE RELOCATED */
        RDISPL  ADDRESS,        /* DISPLACEMENT */
        REXT    ADDRESS,        /* POINTER TO EXTERNAL NAMES */
        RSEG    BYTE,           /* SEGMENT OF ADDRESS TO BE RELOCATED */
        RBASE   BYTE,           /* BASE */
        /* (ADDRESS (BASE, DISPL) IS TO BE INSERTED AT (SEG, LOC)) */
        /* REC = 'R' INDICATES 'RELOCATION' RECORD */
        /* REC = 'S' INDICATES 'SYMBOL REF' RECORD */
        /* REC = '.' INDICATES LAST RECORD (COUNTERS) */
        /* FIELD REDEFINITIONS FOR 'S' RECORDS */
        SDISPL  LIT 'RLOC',
        SLINE   LIT 'RDISPL',
        SNAME   LIT 'REXT',
        STYPE   LIT 'RSEG',
        SBASE   LIT 'RBASE',
        /* FIELD REDEFINITIONS FOR '.' RECORD */
        CASIZE  LIT 'RLOC',
        IDASIZE LIT 'RDISPL',
        WASIZE  LIT 'REXT';

/* SYMBOL LIST (FOR EACH MODULE) */
DECLARE SYMBL ADDRESS,          /* BASE OF THE SYMBOL LIST */
        SYMLIST BASED SYMBL BYTE;
/* SEGMENT BEING UPDATED IN MEMORY */
DECLARE SEGB  ADDRESS,          /* BASE OF THE SEGMENT */
        SEG BASED SEGB BYTE;


DECLARE LOADADR ADDRESS INITIAL(0100H); /* LOAD ADDRESS FOR OBJ MODULE */
DECLARE LA      ADDRESS;                /* LOAD ADDRESS FOR EACH SEGMENT */
DECLARE MEMPTR  ADDRESS INITIAL(0);     /* POINTER TO NEXT BYTE IN MEMORY */
DECLARE LSTREQ  BYTE INITIAL(0);        /* 1 TO PRINT SYMBOL LIST */
DECLARE M       BYTE;                   /* INDEX OF MODULE IN THE MODULE MAP */
DECLARE MP      ADDRESS;                /* AUXILIARY MEMORY POINTER */
DECLARE HASHMASK LIT '127';
DECLARE HASHCODE BYTE;
DECLARE TEMP    ADDRESS;

/* OUTPUT DEVICES */
DECLARE CRT     LIT     '2';
DECLARE PRINTER LIT     '5';
DECLARE OUTDEV BYTE INITIAL(CRT);       /* CURRENT OUTPUT DEVICE */
DECLARE PRINTDEV BYTE INITIAL(CRT);     /* DEV FOR SYMB LIST OUTPUT */



/* MNEMONICS FOR 'TYPE' */
DECLARE KLABEL LIT '1',
        KBYTE  LIT '2',
        PROC   LIT '3',
        EXT    LIT '4',
        GLOB   LIT '5',
        STRING LIT '7',
        UNDECL LIT '6';


/* SWITCHES FOR BUILT-IN TRACE */
/* TO INCLUDE TRACE ROUTINES, SET TRACE$ON TO BLANKS */
/* TO EXCLUDE TRACE ROUTINES, SET TRACE$ON TO SLASH-STAR */
DECLARE TRACE$ON  LITERALLY ' /* ',
        TRACE$OFF LITERALLY ' /* ';

TRACE$ON
DECLARE TRACE BYTE INITIAL(0);
DECLARE TRACT ADDRESS;
TRACE$OFF *** */

VMON: PROCEDURE(FUNC, INFO) BYTE;  /* CPM CALL WITH RETURN VALUE */
    DECLARE FUNC BYTE, INFO ADDRESS;
    GO TO BDOS; 
    END VMON;

CMON: PROCEDURE(FUNC, PARAM); /* CPM CALL WITN NO RETURN VALUE */
    DECLARE FUNC BYTE, PARAM ADDRESS;
    GO TO BDOS; 
    END CMON;

DOUBLET: PROCEDURE(L, H) ADDRESS;
    /* RETURN ADDRESS FORMED BY BYTES L, H */
    DECLARE (L, H) BYTE;

    RETURN SHL(DOUBLE(H), 8) OR L;
END DOUBLET;

STORE: PROCEDURE(N, A);
    DECLARE (N, A) ADDRESS;
    /* STORE INTEGER N (2 BYTES) AT ADDRESS A */
    DECLARE V BASED A ADDRESS;
    V = N;
END STORE;

PRC: PROCEDURE(C);   /* PRINT CHARACTER C ON THE CRT OR PRINTER */
    DECLARE C BYTE;
    CALL CMON(OUTDEV, C);
END PRC;

CRLF: PROCEDURE;  /* PRINT CR LF TO CRT */
    CALL PRC(CR);
    CALL PRC(LF);
END CRLF;

PRINTH: PROCEDURE(H);  /* PRINT HEX CHARACTER */
    DECLARE H BYTE;

    IF H > 9 THEN
        CALL PRC(H - 10 + 'A');
    ELSE
        CALL PRC(H + '0');
END PRINTH;

PRINTHB: PROCEDURE(B);  /* PRINT HEX BYTE */
    DECLARE B BYTE;
    CALL PRINTH(SHR(B, 4));
    CALL PRINTH(B AND 0FH);
END PRINTHB;


PRINTHA: PROCEDURE(A);  /* PRINT HEX ADDRESS */
    DECLARE A ADDRESS;
    CALL PRINTHB(HIGH(A));
    CALL PRINTHB(LOW(A));
END PRINTHA;


PRS: PROCEDURE(A);
    DECLARE A ADDRESS;
    /* PRINT STRING BEGINNING AT ADDRESS A UNTIL A $ IS FOUND */
    DECLARE B BASED A BYTE;
    DO WHILE B <> '$';
        CALL PRC(B);
        A = A + 1;
    END;
END PRS;



PRL: PROCEDURE(A);  /* PRINT LINE BEGINNING AT ADDRESS A */
    DECLARE A ADDRESS;
    CALL CRLF;
    CALL PRS(A);
END PRL;

EXIT: PROCEDURE;
    CALL PRL(.('END L83 $'));
    CALL CRLF;
    GOTO CPM;
END EXIT;


PRFN: PROCEDURE(A); /* PRINT NAME OF THE FILE WHOSE FCB IS AT A */
    DECLARE A ADDRESS;
    DECLARE FCB BASED A BYTE, I BYTE;

    CALL PRC(' ');
    DO I = 1 TO 11;
       IF FCB(I) <> ' ' THEN 
           CALL PRC(FCB(I));
       IF I = 8 THEN
           CALL PRC('.');
    END;
END PRFN;


PRNAME: PROCEDURE(A);
    DECLARE A ADDRESS;
    /* PRINT NAME BEGINNING AT ADDRESS A */
    DECLARE B BASED A BYTE;
    DO WHILE B <> 0;
        CALL PRC(B);
        A = A + 1;
    END;
END PRNAME;

PRMN: PROCEDURE(J);
    DECLARE J BYTE;
    /* PRINT NAME OF MODULE J */
    CALL PRNAME(MNAME(J));
END PRMN;



ERROR: PROCEDURE(N);
    DECLARE N BYTE;
    /* EMIT ERROR MESSAGE */
    DO CASE N;
    CALL PRL(.('TOO MANY MODULES$'));
    DO;
        CALL PRL(.('CANNOT CREATE$'));
        CALL PRFN(.OFCB);
    END;
    DO;
        CALL PRL(.('CANNOT CLOSE$'));
        CALL PRFN(.OFCB);
    END;
    DO;
        CALL PRL(.('WRITE ERROR$'));
        CALL PRFN(.OFCB);
    END;
    DO;
        CALL PRL(.('READ ERROR$'));
        CALL PRFN(IFCBA);
    END;
    DO;
        CALL PRL(.('CANNOT OPEN$'));
        CALL PRFN(IFCBA);
    END;
    CALL PRL(.('MEMORY OVERFLOW$'));
    CALL PRL(.('BAD RT FILE$'));
    END;
    CALL EXIT;
END ERROR;


TRACE$ON
TRAA: PROCEDURE(A); DECLARE A ADDRESS;
    CALL PRC(':'); PRINTHA(A);
END TRAA;

TRAB: PROCEDURE(B); DECLARE B BYTE;
    CALL PRC(':'); PRINTHB(B);
END TRAB;

TRAC: PROCEDURE(B);
    DECLARE (B, I) BYTE;
    DECLARE J ADDRESS;
    IF NOT TRACE THEN RETURN;
 
    CALL PRC(B);
    B = VMON(1,0);
    DO WHILE B <> ' '; 
        IF B='M' 1 THEN DO I=0 TO MTOP;
            CALL TRAB(I);
            CALL TRAA(MNAME(I));
            CALL TRAA(NCA(I));
            CALL TRAA(MIDA(I));
            CALL TRAA(MWA(I));
            CALL TRAA(MSYMB(1));
            CALL TRAB(MHASH(I));
         END;
         IF B= 'R' THEN DO
                 CALL TRAB(REC);
                 CALL TRAA(RLOC);
                 CALL TRAA(RDISPL);
                 CALL TRAA(REXT);
                 CALL TRAB(RSEG);
                 CALL TRAB(RBASE);
             END;
         END;
         IF B='S' THEN DO J = 1 TO TRACT;
             CALL TRAB(MEMORY(MEMPTR+J-1));
         END;
         CALL PRC(' '); B=VMON(1,0);
    END;
END TRAC;
    TRACE$OFF *** */


FLUSH: PROCEDURE;       /* WRITE A RECORD ONTO THE OUTPUT FILE */
    DECLARE I ADDRESS;
    I = 0;
    DO WHILE I < OBP;
        CALL CMON(SETBUF, .OBUF(I));
        IF VMON(WRITEBF, .OFCB) <> 0 THEN
            CALL ERROR(3);      /* WRITE ERROR */
        I = I + 128;
    END;
    OBP = 0;                    /* BUFFER IS EMPTY */
END FLUSH;

PUT1: PROCEDURE(B);
    DECLARE B BYTE;
    IF OBP = LENGTH(OBUF) THEN
        CALL FLUSH;
    OBUF(OBP) = B;
    OBP = OBP + 1;
END PUT1;

GET1: PROCEDURE BYTE;   /* READ 1 BYTE FROM INPUT FILE */
    DECLARE C BYTE;
    IF IBP = 128 THEN   /* INPUT BUFFER EMPTY */
    DO;
        CALL CMON(SETBUF, SBUFA);
        IBP = 0;
        IF (C := VMON(READBF, IFCBA)) = 1 THEN
            RETURN 0;   /* EOF */
        IF C <> 0 THEN
            CALL ERROR(4);      /* ERROR - QUIT */
    END;
    C = IBUF(IBP);
    IBP = IBP + 1;
    RETURN C;
END GET1;

GET2: PROCEDURE ADDRESS; /* READ 2 BYTES FROM INPUT FILE */
    RETURN DOUBLET(GET1, GET1);
END GET2;

        
YN: PROCEDURE;          /* ASK OPERATOR IF YES OR NO */
    CALL PRC(3FH);      /* QUESTION MARK */
    CALL CMON(PRINT, .(' (Y/N): $'));
END YN;

YES: PROCEDURE BYTE;    /* TRUE IF ANSWER IS 'Y' */
    DECLARE C BYTE;
    RETURN (C := VMON(READCHAR, 0)) = 'Y' OR C = 79H;
END YES;

PRLA: PROCEDURE(A);     /* PRINT LOAD ADDRESS */
    DECLARE A ADDRESS;
    CALL PRL(.('LOAD ADDRESS = $'));
    CALL PRINTHA(A);
END PRLA;

READCH: PROCEDURE BYTE; /* READ 1 HEX CHAR FROM THE CRT */
    DECLARE C BYTE;

    DO WHILE 1;
	C = VMON(READCHAR, 0);
	IF '0' <= C AND C < 3AH THEN RETURN C - '0';
	IF 'A' <= C AND C < 'G' THEN RETURN C - 'A' + 10;
	CALL PRC(3FH);      /* QUESTION MARK */
    END;
END READCH;

DECLARE FIX DATA(0);    /* FORCE REALIGN SPURIOUS NOP IN ABOVE CODE */

READCB: PROCEDURE BYTE;
    /* READ 2 HEX CHAR FROM THE CRT AND MAKE THEM INTO A BYTE */
    RETURN SHL(READCH, 4) OR READCH;
END READCB;

DUMP: PROCEDURE(N);
    DECLARE N ADDRESS;
    /* DUMP N BYTES OF SEBMENT (CA, IDA) CURRENTLY IN MEMORY INTO THE
       OBJECT MODULE OUTPUT FILE */
    DECLARE I ADDRESS;

    DO I = 1 TO N;
        CALL PUT1(SEG(I - 1));
    END;
END DUMP;

READRR: PROCEDURE; /* READ LOGICAL RECORD FROM RT FILE */
    REC = GET1;
    RLOC = GET2;
    RDISPL = GET2;
    REXT = GET2;
    IF REC <> '.' THEN  /* NOT TRAILER RECORD */
    DO;
        DECLARE C BYTE;
        C = GET1;
        RSEG = SHR(C, 4);       /* 4 MOST SIGNIF BITS */
        RBASE = C AND 0FH;      /* 4 LEAST SIGNIF BITS */
    END;
    TRACE$ON
    CALL TRAC('T');
    TRACE$OFF *** */
END READRR;


SETFCB: PROCEDURE(S);
    DECLARE S BYTE;
    /* SET FCB TO ALLOW OPENFG OF SEGMENT S OF MODULE M */
    DECLARE (I,EONAME) BYTE;
    DECLARE A ADDRESS;
    DECLARE NCHR BASED A BYTE;

    EONAME = 0;                 /* NOT END OF NAME */
    A = MNAME(M);               /* ADDRESS OF MODULE'S NAME */
    DO I = 1 TO 8;              /* SET FILE NAME */
        IF EONAME THEN
            IFCB(I) = ' ';
        ELSE
        DO;
            IFCB(I) = NCHR;     /* MOVE 1 NAME CHARACTER */
            A = A + 1;          /* LOOK AT NEXT CHARACTER */
            IF NCHR = 0 THEN    /* END OF NAME */
                EONAME = 1;
        END;
    END;
    IF NOT EONAME THEN          /* NAME TOO LONG */
    DO;
        CALL PRL(.('NAME TOO LONG (TRUNCATED): $'));
        CALL PRMN(M);
    END;
    IFCB(9) = '8';
    IFCB(10) = '0';
    IFCB(11) = S;       /* 'C':CA, 'D':IDA, 'S':SYMB LIST, 'R' RELOC TBL */
    DO I = 12 TO 15;    /* SET OTHER BYTES */
        IFCB(I) = 0;
    END;
    IFCB(32) = 0;       /* NEXT RECORD */
    IFCB(0) = 0;
    IBP = 128;          /* INPUT BUFFER EMPTY */
END SETFCB;
    
        
OPENF: PROCEDURE;       /* OPEN INPUT FILE (FCB ASSUMED SET UP) */
    IF VMON(OPEN, IFCBA) <> 255 THEN
        RETURN;
    CALL ERROR(5);
END OPENF;

OPENRT: PROCEDURE;      /* OPEN RT FILE OF MODULE M */
    CALL SETFCB('R');   /* SET FILE CONTROL BLOCK */
    CALL OPENF;         /* OPEN THE FILE */
    SYMBL = MSYMB(M);   /* SET BASE OF SYMBOL LIST OF MODULE M */
END OPENRT;

READF: PROCEDURE(S, SAV);
    DECLARE (S, SAV) BYTE;
    /* READ SEGNENT S OF MODULE M INTO MEMORY; IF SAVE = 1 THEN
       (THE FILE BEING READ IS A SYMBOL LIST)
       ADVANCE THE MEMORY PTR (SAVE THE SEGMENT FROM BEING OVERLAYED) */
    DECLARE K BYTE;

    CALL SETFCB(S);     /* SET FILE CONTROL BLOCK */
    CALL OPENF;         /* OPEN THE FILE */
    MP = MEMPTR;        /* INDEX OF NEXT BYTE IN MEMORY */
    CALL CMON(SETBUF, SBUFA);
    DO FOREVER;
        IF (K := VMON(READBF, IFCBA)) = 1 THEN  /* EOF */
            RETURN;
        IF MP + 128 > FBASE THEN        /* MEMORY OVERFLOW */
            CALL ERROR(6);
        IF K = 0 THEN   /* SUCCESSFUL READ */
        DO WHILE K <> 128;
            IF IBUF(K) = CONTROLZ /* EOF */ AND SAV /* SYMBOL LIST */ THEN
            DO;
                MEMPTR = MP;    /* ADVANCE MEMPTR */
                RETURN;
            END;
            MEMORY(MP) = IBUF(K);
            MP = MP + 1;
            K = K + 1;
        END;
        ELSE
            CALL ERROR(4);      /* READ ERROR */
    END; /* OF DO FOREVER */
END READF;
        
        
COMPAR: PROCEDURE(A1, A2) BYTE; /* TRUE IF STRINGS AT A1,A2 ARE EQUAL */
    DECLARE (A1, A2) ADDRESS;
    DECLARE B1 BASED A1 BYTE;
    DECLARE B2 BASED A2 BYTE;
    DO WHILE B1 = B2;
        IF B1 = 0 THEN  /* END OF STRING */
            RETURN 1;
        A1 = A1 + 1;
        A2 = A2 + 1;
    END;
    RETURN 0;
END COMPAR;

HASHF: PROCEDURE(A) BYTE;       /* RETURN HASCODE OF NAME AT ADDRESS A */
    DECLARE A ADDRESS;
    DECLARE H BYTE;
    DECLARE C BASED A BYTE;
    H = 0;
    DO WHILE C <> 0;
        H = (C + H) AND HASHMASK;
        A = A + 1;
    END;
    RETURN H;
END HASHF;

NEW: PROCEDURE(A) BYTE; /* TRUE IF NAME AT A IS NOT IN THE MODULE MAP */
    DECLARE A ADDRESS;
    DECLARE K BYTE;

    HASHCODE = HASHF(A);        /* COMPUTE HASHCODE OF THE NAME */
    DO K = 0 TO MTOP;           /* SEARCH THE MODULE MAP */
        IF MHASH(K) = HASHCODE THEN     /* MAY BE EQUAL */
        DO;
            IF COMPAR(A, MNAME(K)) THEN
                RETURN 0;       /* EQUAL */
        END;
    END;
    RETURN 1;
END NEW;

CONCAT: PROCEDURE(A);
    DECLARE A ADDRESS;
    /* COMPUTE LOAD ADDRESSES OF SEGMENTS INTHE MODULE MAP,
       SO THAT ALL SEGMENTS ARE CONCATENATED IN MEMORY */
    DECLARE SSZ BASED A (1) ADDRESS;    /* SEGMENT SIZE */
    DECLARE J BYTE;

    DO J = 0 TO MTOP;
        TEMP = SSZ(J) + LA;     /* SAVE ADDRESS OF NEXT SEGMENT */
        SSZ(J) = LA;            /* SET ADDRESS OF THIS SEGMENT */
        LA = TEMP;              /* SET ADDRESS FOR NEXT SEGMENT */
    END;
END CONCAT;

ENTRY: PROCEDURE(N) ADDRESS;
    DECLARE N BYTE;
    /* RETURN ADEQUATE ENTRY POINT IN MODULE M FOR THE ADDRESS
       DESCRIBED BY THE CURRENT RELOCATION RECORD */
    IF RBASE = CA THEN RETURN MCA(N);
    IF RBASE = IDA THEN RETURN MIDA(N);
    IF RBASE = WA THEN RETURN MWA(N);
    CALL ERROR(7);      /* ELSE: BAD FILE - QUIT */
END ENTRY;

RESOLVE: PROCEDURE;
    /* USE THE INFORMATION IN THE CURRENT RELOCATION RECORD
       TO RESOLVE ONE ADDRESS IN THE SEGMENT (CA, IDA) CURRENTLY
       IN MEMORY, WHICH BELONGS TO MODULE M */
    DECLARE K BYTE;

    IF REXT <> 0 THEN   /* AN EXTERNAL REFERENCE */
    DO;                 /* FIND INDEX OF EXTERNAL MODULE */
        K = SYMLIST(REXT - 1);  /* POINTER TO EXTERNAL MODULE IN MM */
        TEMP = ENTRY(K);
        K = SEG(RLOC - 1);      /* LOOK AT PREVIOUS INSTRUCTION */
        IF RBASE = CA AND (K = 0CDH /* CALL */
                           OR (K AND 0C7H) = 0C4H) /* CNZ, CZ, ETC */ THEN
            TEMP = TEMP + 3;    /* ADJUST ENTRY TO PROCEDURE */
    END;
    ELSE        /* NOT AN EXTERNAL REFERENCE */
        TEMP = ENTRY(M);
    CALL STORE(TEMP + RDISPL, .SEG(RLOC));
END RESOLVE;

LST$REF: PROCEDURE;
    /* PRINT INFORMATION ABOUT SYMBOL WHOSE RELOCATION RECORD
       IS CURRENTLY IN MEMORY, AND WHICH BELONGS TO MODULE M */
    IF STYPE = EXT OR STYPE = GLOB THEN
        RETURN;
    OUTDEV = PRINTDEV;          /* SENT OUTPUT TO PRINTING DEVICE */
    CALL PRL(.('L:$'));
    CALL PRINTHA(SLINE);
    CALL PRS(.(' A:$'));
    CALL PRINTHA(ENTRY(M) + SDISPL);
    CALL PRS(.(' T:$'));
    IF STYPE = KLABEL THEN CALL PRC('L');
    ELSE IF STYPE = KBYTE THEN CALL PRC('B');
    ELSE IF STYPE = PROC THEN CALL PRC('P');
    ELSE IF STYPE = STRING THEN CALL PRC('S');
    CALL PRC(' ');
    CALL PRNAME(.SYMLIST(SNAME));
    OUTDEV = CRT;
END LST$REF;


MAIN:
/* INITIALISE */
DECLARE (C, J) BYTE, A ADDRESS INITIAL(1A00H);

    /* ASK FOR PARAMETERS */
    IF IFCB(9) <> ' ' THEN
    DO;
        TRACE$ON
        CALL PRL(.'TRACE$'); CALL YN; TRACE = YES;
        TRACE$OFF *** */
        CALL PRL(.('SYMBOL LISTING$'));
        CALL YN;
        LSTREQ = YES;
        IF LSTREQ THEN
        DO;
            CALL PRL(.('OUTPUT TO PRINTER$'));
            CALL YN; IF YES THEN PRINTDEV = PRINTER;
        END;
        CALL PRLA(LOADADR);
        CALL YN;
        IF NOT YES THEN
        DO;
             CALL PRL(.('LA (XXXX) = $'));
             J = READCB;
             LOADADR = DOUBLET(READCB, J);
        END;
    END;
    LA = LOADADR;
    /* SET UP NAME OF ARGUMENT PROGRAM INTO THE GLOBAL SYMBOL LIST */
    MEMORY(1) = 0;      /* POINTER FROM SYMBOL TO MODULE MAP */
    MEMPTR = 2;         /* NAME BEGINS AT MEMORY(2) */
    MNAME(0) = .MEMORY(2);      /* POINTER FROM MM TO SYMBOL */
    J = 1;              /* INDEX OF PROG NAME IN THE INPUT FCB */
    DO WHILE J < 9 AND (C := IFCB(J)) <> ' ';
        MEMORY(MEMPTR), OFCB(J) = C;    /* SET ALSO THE OUTPUT FCB */
        MEMPTR = MEMPTR + 1;
        J = J + 1;
    END;
    MEMORY(MEMPTR) = 0; /* FLAG FOR END OF NAME */
    MEMPTR = MEMPTR + 1;
    MHASH(0) = HASHF(.MEMORY(2));
    /* SET UP MODULE MAP */
    M = 0;      /* INDEX OF 1ST MODULE */
    DO WHILE M <= MTOP;         /* GET INFO ABOUT MODULE M */
        MSYMB(M) = .MEMORY(MEMPTR);     /* SAVE BASE OF M'S SYMBOL LIST */
        CALL READF('S', 1);     /* READ SYMB LIST OF MODULE M INTO MEMORY */
        CALL OPENRT;            /* OPEN RT FILE OF MODULE M */
        CALL READRR;            /* READ RECORD FROM RT FILE */
        DO WHILE REC <> '.';    /* NOT END OF RELOCATION TABLE */
            IF REC = 'R' /* RELOCATION RECORD */
               AND REXT <> 0 THEN       /* EXTERNAL REFERENCE */
            DO;                 /* CREATE ANOTHER ENTRY IN THE MODULE MAP */
                /* BUT FIRST CHECK IF ALREADY THERE */
                A = .SYMLIST(REXT);     /* ADDRESS OF THE SYMBOL */
                IF NEW(A) THEN  /* NOT YET IN THE MODULE MAP */
                DO;
                    IF (MTOP := MTOP + 1) >= MSIZE THEN
                        CALL ERROR(0);  /* MM OVERFLOW - QUIT */
                    /* SET POINTER FROM SYMBOL TO MM */
                    SYMLIST(REXT - 1) = MTOP;
                    /* SET POINTER FROM MM TO SYMBOL */
                    MNAME(MTOP) = A;    /* ADDRESS */
                    /* SAVE SYMBOL HASHCODE IN MM */
                    MHASH(MTOP) = HASHCODE;
                END; /* OF TRY TO INSTALL IT IN MM */
            END; /* OF CREATE ANOTHER ENTRY IN MM */
            CALL READRR;        /* READ NEXT RECORD FROM RT FILE */
        END;    /* OF REC <> '.' */
        /* '.' RECORD: END OF RELOCATION TABLE */
        /* SET SEGMENT SIZES FOR MODULE M*/
        MCA(M), NCA(M) = CASIZE;
        MIDA(M), NIDA(M) = IDASIZE;
        MWA(M) = WASIZE;
        /* ADVANCE TO NEXT MODULE */
        M = M + 1;
    END;
    /* NOW THE MODULE MAP IS COMPLETE; THE BASE ADDRESSES OF EACH
       SEGMENT IN EACH MODULE CAN BE COMPUTED */
    CALL CONCAT(.MCA);  /* CONCATENATE ALL CA'S */
    CALL CONCAT(.MIDA); /* CONCATENATE ALL IDA'S */
    CALL CONCAT(.MWA);  /* CONCATENATE ALL WA'S */
    TRACE$ON
    CALL TRAC('P');
    TRACE$OFF *** */

/* CONSTRUCT THE OBJECT MODULE */
    /* CREATE OUTPUT FILE */
    CALL CMON(DELETE, .OFCB);
    IF VMON(MAKE, .OFCB) = 255 THEN
         CALL ERROR(1); /* ERROR */
    OFCB(32) = 0;       /* NEXT RECORD */
    SEGB = .MEMORY(MEMPTR);     /* BASE ADDRESS FOR SEGMENTS */
    DO M = 0 TO MTOP;
        CALL READF('C', 0);     /* READ CA OF MODULE M INTO MEMORY */
        TRACE$ON
        TRACT=NCA(M); CALL TRAC('A');
        TRACE$OFF *** */
        CALL OPENRT;            /* OPEN RT FILE OF MODULE M */
        CALL READRR;            /* READ RT RECORD */
        DO WHILE REC <> '.';    /* NOT EOD OF RELOCATION TABLE */
            IF REC = 'R' AND RSEG = CA THEN     /* RESOLVE THE REFERENCE */
                CALL RESOLVE;
            CALL READRR;        /* NEXT RECORD */
        END;
        TRACE$ON
        CALL TRAC('C');
        TRACE$OFF *** */
        CALL DUMP(NCA(M));      /* DUMP CA OF MODULE M */
    END;
    /* BRING IDA'S INTO MEMORY, RESOLVE THEIR ADDRESSES AND DUMP THEM;
       AT THE SAME TIME PRINT SYMBOL REFERENCE LIST, IF REQUIRED */
    DO M = 0 TO MTOP;
        CALL READF('D', 0);     /* READ IDA OF MODULE M INTO MEMORY */
        TRACE$ON
        TRACT=NIDA(M); CALL TRAC('B');
        TRACE$OFF *** */
        CALL OPENRT;            /* OPEN RT FILE OF MODULE M */
        CALL READRR;            /* READ RT RECORD */
        DO WHILE REC <> '.';    /* NOT END OF RELOCATION TABLE */
            IF REC = 'R' AND RSEG = IDA THEN    /* RESOLVE THE ADDRESS */
                CALL RESOLVE;
            IF REC = 'S' AND LSTREQ THEN /* SYMBOL RECORD AND LISTING */
                CALL LST$REF;
            CALL READRR;        /* NEXT RECORD */
        END;
        CALL DUMP(NIDA(M));
    END;

/* TERMINATE */
    CALL FLUSH;                 /* WRITE LAST RECORD */
    IF VMON(CLOSE, .OFCB) = 0FFH THEN   /* CLOSE OBJECT FILE */
        CALL ERROR(2);
    /* PRINT SUMMARY */
    CALL PRLA(LOADADR);
    CALL PRL(.('LAST ADDRESS = $'));
    CALL PRINTHA(LA - 1);
    CALL CRLF;
    CALL PRL(.('MODULES LINKED: $'));
    DO J = 0 TO MTOP;
        CALL CRLF;
        CALL PRMN(J);           /* PRINT NAME OF MODULE M */
    END;
    CALL CRLF;
    /* QUIT */
    CALL EXIT;
EOF;
